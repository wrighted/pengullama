[{
  "instruction": "scripts: twister: Don't use match/case statements",
  "input": "       match(status):\n           case TwisterStatus.PASS:\n               color = Fore.GREEN\n           case TwisterStatus.SKIP | TwisterStatus.FILTER | TwisterStatus.BLOCK:\n               color = Fore.YELLOW\n           case TwisterStatus.FAIL | TwisterStatus.ERROR:\n               color = Fore.RED\n           case TwisterStatus.STARTED | TwisterStatus.NONE:\n               color = Fore.MAGENTA\n           case _:\n               color = Fore.RESET\n       return color",
  "result": "diff --git a/scripts/pylib/twister/twisterlib/statuses.py b/scripts/pylib/twister/twisterlib/statuses.py\nindex 2983917467f..c5545b3fe28 100644\n--- a/scripts/pylib/twister/twisterlib/statuses.py\n+++ b/scripts/pylib/twister/twisterlib/statuses.py\n@@ -23,18 +23,17 @@ class TwisterStatus(str, Enum):\n \n     @staticmethod\n     def get_color(status: TwisterStatus) -> str:\n-        match(status):\n-            case TwisterStatus.PASS:\n-                color = Fore.GREEN\n-            case TwisterStatus.SKIP | TwisterStatus.FILTER | TwisterStatus.BLOCK:\n-                color = Fore.YELLOW\n-            case TwisterStatus.FAIL | TwisterStatus.ERROR:\n-                color = Fore.RED\n-            case TwisterStatus.STARTED | TwisterStatus.NONE:\n-                color = Fore.MAGENTA\n-            case _:\n-                color = Fore.RESET\n-        return color\n+        status2color = {\n+            TwisterStatus.PASS: Fore.GREEN,\n+            TwisterStatus.SKIP: Fore.YELLOW,\n+            TwisterStatus.FILTER: Fore.YELLOW,\n+            TwisterStatus.BLOCK: Fore.YELLOW,\n+            TwisterStatus.FAIL: Fore.RED,\n+            TwisterStatus.ERROR: Fore.RED,\n+            TwisterStatus.STARTED: Fore.MAGENTA,\n+            TwisterStatus.NONE: Fore.MAGENTA\n+        }\n+        return status2color[status] if status in status2color else Fore.RESET\n \n     # All statuses below this comment can be used for TestCase\n     BLOCK = 'blocked'"
},{
  "instruction": "tests: drivers: build_all: Add auxdisplay drivers test",
  "input": "",
  "result": "diff --git a/tests/drivers/build_all/auxdisplay/CMakeLists.txt b/tests/drivers/build_all/auxdisplay/CMakeLists.txt\nnew file mode 100644\nindex 00000000000..b9cc9b347eb\n--- /dev/null\n+++ b/tests/drivers/build_all/auxdisplay/CMakeLists.txt\n@@ -0,0 +1,8 @@\n+# SPDX-License-Identifier: Apache-2.0\n+\n+cmake_minimum_required(VERSION 3.20.0)\n+find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})\n+project(build_all_auxdisplay)\n+\n+FILE(GLOB app_sources src/*.c)\n+target_sources(app PRIVATE ${app_sources})\ndiff --git a/tests/drivers/build_all/auxdisplay/i2c_devices.overlay b/tests/drivers/build_all/auxdisplay/i2c_devices.overlay\nnew file mode 100644\nindex 00000000000..3092cf637d7\n--- /dev/null\n+++ b/tests/drivers/build_all/auxdisplay/i2c_devices.overlay\n@@ -0,0 +1,46 @@\n+/*\n+ * Copyright (c) 2024 TOKITA Hiroshi\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+/ {\n+\ttest {\n+\t\t#address-cells = <1>;\n+\t\t#size-cells = <1>;\n+\n+\t\ttest_gpio: gpio@deadbeef {\n+\t\t\tcompatible = \"vnd,gpio\";\n+\t\t\tgpio-controller;\n+\t\t\treg = <0xdeadbeef 0x1000>;\n+\t\t\t#gpio-cells = <0x2>;\n+\t\t\tstatus = \"okay\";\n+\t\t};\n+\n+\t\ttest_i2c: i2c@11112222 {\n+\t\t\t#address-cells = <1>;\n+\t\t\t#size-cells = <0>;\n+\t\t\tcompatible = \"vnd,i2c\";\n+\t\t\treg = <0x11112222 0x1000>;\n+\t\t\tstatus = \"okay\";\n+\t\t\tclock-frequency = <100000>;\n+\n+\t\t\ttest_serlcd: serlcd@0 {\n+\t\t\t\tcompatible = \"sparkfun,serlcd\";\n+\t\t\t\treg = <0x0>;\n+\t\t\t\tstatus = \"okay\";\n+\t\t\t\tcolumns = <16>;\n+\t\t\t\trows = <2>;\n+\t\t\t\tcommand-delay-ms = <10>;\n+\t\t\t\tspecial-command-delay-ms = <50>;\n+\t\t\t};\n+\n+\t\t\ttest_jhd1313: jhd1313@0 {\n+\t\t\t\tcompatible = \"jhd,jhd1313\";\n+\t\t\t\treg = <0x1>;\n+\t\t\t\tstatus = \"okay\";\n+\t\t\t\tcolumns = <16>;\n+\t\t\t\trows = <2>;\n+\t\t\t};\n+\t\t};\n+\t};\n+};\ndiff --git a/tests/drivers/build_all/auxdisplay/prj.conf b/tests/drivers/build_all/auxdisplay/prj.conf\nnew file mode 100644\nindex 00000000000..8d653804a34\n--- /dev/null\n+++ b/tests/drivers/build_all/auxdisplay/prj.conf\n@@ -0,0 +1,4 @@\n+CONFIG_TEST=y\n+CONFIG_TEST_USERSPACE=y\n+CONFIG_GPIO=y\n+CONFIG_AUXDISPLAY=y\ndiff --git a/tests/drivers/build_all/auxdisplay/spi_devices.overlay b/tests/drivers/build_all/auxdisplay/spi_devices.overlay\nnew file mode 100644\nindex 00000000000..d354c8f582f\n--- /dev/null\n+++ b/tests/drivers/build_all/auxdisplay/spi_devices.overlay\n@@ -0,0 +1,44 @@\n+/*\n+ * Copyright (c) 2024 TOKITA Hiroshi\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+/ {\n+\ttest {\n+\t\t#address-cells = <1>;\n+\t\t#size-cells = <1>;\n+\n+\t\ttest_gpio: gpio@deadbeef {\n+\t\t\tcompatible = \"vnd,gpio\";\n+\t\t\tgpio-controller;\n+\t\t\treg = <0xdeadbeef 0x1000>;\n+\t\t\t#gpio-cells = <0x2>;\n+\t\t\tstatus = \"okay\";\n+\t\t};\n+\n+\t\ttest_spi: spi@33334444 {\n+\t\t\t#address-cells = <1>;\n+\t\t\t#size-cells = <0>;\n+\t\t\tcompatible = \"vnd,spi\";\n+\t\t\treg = <0x33334444 0x1000>;\n+\t\t\tstatus = \"okay\";\n+\t\t\tclock-frequency = <2000000>;\n+\n+\t\t\t/* one entry for every devices at spi.dtsi */\n+\t\t\tcs-gpios = <&test_gpio 0 0>,\n+\t\t\t\t   <&test_gpio 0 0>,\n+\t\t\t\t   <&test_gpio 0 0>,\n+\t\t\t\t   <&test_gpio 0 0>,\n+\t\t\t\t   <&test_gpio 0 0>;\n+\n+\t\t\ttest_spi_pt6314: pt6314@0 {\n+\t\t\t\tcompatible = \"ptc,pt6314\";\n+\t\t\t\treg = <0>;\n+\t\t\t\tstatus = \"okay\";\n+\t\t\t\tspi-max-frequency = <1000000>;\n+\t\t\t\tcolumns = <20>;\n+\t\t\t\trows = <2>;\n+\t\t\t};\n+\t\t};\n+\t};\n+};\ndiff --git a/tests/drivers/build_all/auxdisplay/src/main.c b/tests/drivers/build_all/auxdisplay/src/main.c\nnew file mode 100644\nindex 00000000000..19f5ee731af\n--- /dev/null\n+++ b/tests/drivers/build_all/auxdisplay/src/main.c\n@@ -0,0 +1,10 @@\n+/*\n+ * Copyright (c) 2024 TOKITA Hiroshi\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+int main(void)\n+{\n+\treturn 0;\n+}\ndiff --git a/tests/drivers/build_all/auxdisplay/testcase.yaml b/tests/drivers/build_all/auxdisplay/testcase.yaml\nnew file mode 100644\nindex 00000000000..7ba4c2b8ff2\n--- /dev/null\n+++ b/tests/drivers/build_all/auxdisplay/testcase.yaml\n@@ -0,0 +1,27 @@\n+common:\n+  build_only: true\n+  tags:\n+    - drivers\n+    - rtc\n+tests:\n+  drivers.auxdisplay.build.i2c:\n+    extra_args: DTC_OVERLAY_FILE=\"i2c_devices.overlay\"\n+    extra_configs:\n+      - CONFIG_I2C=y\n+    platform_allow:\n+      - native_sim\n+      - native_sim/native/64\n+  drivers.auxdisplay.build.spi:\n+    extra_args: DTC_OVERLAY_FILE=\"spi_devices.overlay\"\n+    extra_configs:\n+      - CONFIG_SPI=y\n+    platform_allow:\n+      - native_sim\n+      - native_sim/native/64\n+  drivers.auxdisplay.build.uart:\n+    extra_args: DTC_OVERLAY_FILE=\"uart_devices.overlay\"\n+    extra_configs:\n+      - CONFIG_SERIAL=y\n+    platform_allow:\n+      - native_sim\n+      - native_sim/native/64\ndiff --git a/tests/drivers/build_all/auxdisplay/uart_devices.overlay b/tests/drivers/build_all/auxdisplay/uart_devices.overlay\nnew file mode 100644\nindex 00000000000..2e6a2589a14\n--- /dev/null\n+++ b/tests/drivers/build_all/auxdisplay/uart_devices.overlay\n@@ -0,0 +1,32 @@\n+/*\n+ * Copyright (c) 2024 TOKITA Hiroshi\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+/ {\n+\ttest {\n+\t\t#address-cells = <1>;\n+\t\t#size-cells = <1>;\n+\n+\t\ttest_gpio: gpio@deadbeef {\n+\t\t\tcompatible = \"vnd,gpio\";\n+\t\t\tgpio-controller;\n+\t\t\treg = <0xdeadbeef 0x1000>;\n+\t\t\t#gpio-cells = <0x2>;\n+\t\t\tstatus = \"okay\";\n+\t\t};\n+\n+\t\ttest_uart: uart@55556666 {\n+\t\t\tcompatible = \"vnd,serial\";\n+\t\t\treg = <0x55556666 0x1000>;\n+\t\t\tstatus = \"okay\";\n+\n+\t\t\ttest_uart_itron: itron {\n+\t\t\t\tcompatible = \"noritake,itron\";\n+\t\t\t\tstatus = \"okay\";\n+\t\t\t\tcolumns = <20>;\n+\t\t\t\trows = <2>;\n+\t\t\t};\n+\t\t};\n+\t};\n+};"
},{
  "instruction": "drivers: auxdisplay: Remove unused variables",
  "input": "\tint rc = 0;\n\tuint8_t inst;\n\tstruct auxdisplay_pt6314_data *data = dev->data;\n\tuint8_t inst;",
  "result": "diff --git a/drivers/auxdisplay/auxdisplay_itron.c b/drivers/auxdisplay/auxdisplay_itron.c\nindex 1783d8d7d66..b5aa5d89f67 100644\n--- a/drivers/auxdisplay/auxdisplay_itron.c\n+++ b/drivers/auxdisplay/auxdisplay_itron.c\n@@ -153,7 +153,6 @@ static int auxdisplay_itron_init(const struct device *dev)\n \n static int auxdisplay_itron_set_powered(const struct device *dev, bool enabled)\n {\n-\tint rc = 0;\n \tuint8_t cmd[] = {AUXDISPLAY_ITRON_CMD_USER_SETTING, AUXDISPLAY_ITRON_CMD_ACTION,\n \t\t\t AUXDISPLAY_ITRON_CMD_N, AUXDISPLAY_ITRON_CMD_SCREEN_SAVER, 0};\n \ndiff --git a/drivers/auxdisplay/auxdisplay_pt6314.c b/drivers/auxdisplay/auxdisplay_pt6314.c\nindex f3676be9b4e..e204783f8f7 100644\n--- a/drivers/auxdisplay/auxdisplay_pt6314.c\n+++ b/drivers/auxdisplay/auxdisplay_pt6314.c\n@@ -164,7 +164,6 @@ static int auxdisplay_pt6314_cursor_position_set(const struct device *dev,\n {\n \tconst struct auxdisplay_pt6314_config *config = dev->config;\n \tstruct auxdisplay_pt6314_data *data = dev->data;\n-\tuint8_t inst;\n \n \tif (type == AUXDISPLAY_POSITION_RELATIVE) {\n \t\tx += data->cursor_x;\n@@ -273,8 +272,6 @@ static int auxdisplay_pt6314_write(const struct device *dev, const uint8_t *text\n static int auxdisplay_pt6314_init(const struct device *dev)\n {\n \tconst struct auxdisplay_pt6314_config *config = dev->config;\n-\tstruct auxdisplay_pt6314_data *data = dev->data;\n-\tuint8_t inst;\n \n \tif (!device_is_ready(config->bus.bus)) {\n \t\treturn -ENODEV;"
},{
  "instruction": "tests: drivers: build_all: led_strip: Add RaspberryPi Pico PIO driver",
  "input": "",
  "result": "diff --git a/tests/drivers/build_all/led_strip/testcase.yaml b/tests/drivers/build_all/led_strip/testcase.yaml\nindex 411480b28e1..307ab5a6672 100644\n--- a/tests/drivers/build_all/led_strip/testcase.yaml\n+++ b/tests/drivers/build_all/led_strip/testcase.yaml\n@@ -8,3 +8,6 @@ tests:\n     depends_on:\n       - gpio\n       - spi\n+  drivers.led_strip.build.rpi_pico_pio:\n+    build_only: true\n+    platform_allow: rpi_pico"
},{
  "instruction": "drivers: led_strip: tlc5971: Enable when the dt-node exists",
  "input": "CONFIG_TLC5971_STRIP=y",
  "result": "diff --git a/drivers/led_strip/Kconfig.tlc5971 b/drivers/led_strip/Kconfig.tlc5971\nindex a8586fa92e0..f47f64bf259 100644\n--- a/drivers/led_strip/Kconfig.tlc5971\n+++ b/drivers/led_strip/Kconfig.tlc5971\n@@ -5,5 +5,7 @@\n config TLC5971_STRIP\n \tbool \"TLC5971 (and compatible) LED strip driver\"\n \tdepends on SPI\n+\tdepends on DT_HAS_TI_TLC5971_ENABLED\n+\tdefault y\n \thelp\n \t  Enable LED strip driver for daisy chains of TLC5971-ish devices\ndiff --git a/tests/drivers/build_all/led_strip/prj.conf b/tests/drivers/build_all/led_strip/prj.conf\nindex ac3c9da0c81..e0f1437d391 100644\n--- a/tests/drivers/build_all/led_strip/prj.conf\n+++ b/tests/drivers/build_all/led_strip/prj.conf\n@@ -4,4 +4,3 @@ CONFIG_TEST_USERSPACE=y\n CONFIG_GPIO=y\n CONFIG_SPI=y\n CONFIG_LED_STRIP=y\n-CONFIG_TLC5971_STRIP=y"
},{
  "instruction": "tests: drivers: build_all: led_strip: Add i2c-devices build test",
  "input": "\t\t\tcs-gpios = <&test_gpio 0 0>;",
  "result": "diff --git a/tests/drivers/build_all/led_strip/app.overlay b/tests/drivers/build_all/led_strip/app.overlay\nindex 0b7e47205aa..3e91113543c 100644\n--- a/tests/drivers/build_all/led_strip/app.overlay\n+++ b/tests/drivers/build_all/led_strip/app.overlay\n@@ -35,7 +35,10 @@\n \t\t\tstatus = \"okay\";\n \t\t\tclock-frequency = <DT_FREQ_M(2)>;\n \n-\t\t\tcs-gpios = <&test_gpio 0 0>;\n+\t\t\tcs-gpios = <&test_gpio 0 0>,\n+\t\t\t\t   <&test_gpio 0 0>,\n+\t\t\t\t   <&test_gpio 0 0>,\n+\t\t\t\t   <&test_gpio 0 0>;\n \n \t\t\ttest_spi_tlc5971: tlc5971@0 {\n \t\t\t\tstatus = \"okay\";\n@@ -47,6 +50,39 @@\n \t\t\t\t\t\t<LED_COLOR_ID_GREEN>,\n \t\t\t\t\t\t<LED_COLOR_ID_RED>;\n \t\t\t};\n+\n+\t\t\ttest_spi_apa102: apa102@1 {\n+\t\t\t\tcompatible = \"apa,apa102\";\n+\t\t\t\treg = <0x1>;\n+\t\t\t\tspi-max-frequency = <5250000>;\n+\t\t\t\tchain-length = <4>;\n+\t\t\t\tcolor-mapping = <LED_COLOR_ID_BLUE\n+\t\t\t\t\t\t LED_COLOR_ID_GREEN\n+\t\t\t\t\t\t LED_COLOR_ID_RED>;\n+\t\t\t};\n+\n+\t\t\ttest_spi_lpd8806: lpd8806@2 {\n+\t\t\t\tcompatible = \"greeled,lpd8806\";\n+\t\t\t\treg = <0x2>;\n+\t\t\t\tspi-max-frequency = <2000000>;\n+\t\t\t\tchain-length = <1>;\n+\t\t\t\tcolor-mapping = <LED_COLOR_ID_RED\n+\t\t\t\t\t\t LED_COLOR_ID_GREEN\n+\t\t\t\t\t\t LED_COLOR_ID_BLUE>;\n+\t\t\t};\n+\n+\t\t\ttest_spi_ws2812: ws2812@3 {\n+\t\t\t\tcompatible = \"worldsemi,ws2812-spi\";\n+\t\t\t\treg = <0x3>;\n+\t\t\t\tspi-max-frequency = <2000000>;\n+\n+\t\t\t\tchain-length = <1>;\n+\t\t\t\tcolor-mapping = <LED_COLOR_ID_GREEN>,\n+\t\t\t\t\t<LED_COLOR_ID_RED>,\n+\t\t\t\t\t<LED_COLOR_ID_BLUE>;\n+\t\t\t\tspi-one-frame = <1>;\n+\t\t\t\tspi-zero-frame = <2>;\n+\t\t\t};\n \t\t};\n \t};\n };"
},{
  "instruction": "soc: riscv: andes_v5: fix PMA compilation warnings",
  "input": "#ifdef CONFIG_NOCACHE_MEMORY",
  "result": "diff --git a/soc/andestech/ae350/pma.c b/soc/andestech/ae350/pma.c\nindex 0fb162cc959..71da2248b72 100644\n--- a/soc/andestech/ae350/pma.c\n+++ b/soc/andestech/ae350/pma.c\n@@ -70,6 +70,7 @@ struct pma_region {\n \tstruct pma_region_attr attr;\n };\n \n+#ifdef CONFIG_NOCACHE_MEMORY\n /*\n  * Write value to CSRs pmaaddr{i}\n  */\n@@ -165,7 +166,6 @@ static int pma_region_is_valid(const struct pma_region *region)\n \treturn 0;\n }\n \n-#ifdef CONFIG_NOCACHE_MEMORY\n static void configure_nocache_region(void)\n {\n \tconst struct pma_region nocache_region = {"
},{
  "instruction": "drivers: stepper: shell: Add test for stepper shell",
  "input": "",
  "result": "diff --git a/tests/drivers/stepper/shell/CMakeLists.txt b/tests/drivers/stepper/shell/CMakeLists.txt\nnew file mode 100644\nindex 00000000000..7a7892c68da\n--- /dev/null\n+++ b/tests/drivers/stepper/shell/CMakeLists.txt\n@@ -0,0 +1,8 @@\n+# SPDX-License-Identifier: Apache-2.0\n+\n+cmake_minimum_required(VERSION 3.20.0)\n+find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})\n+project(can_shell)\n+\n+FILE(GLOB app_sources src/*.c)\n+target_sources(app PRIVATE ${app_sources})\ndiff --git a/tests/drivers/stepper/shell/app.overlay b/tests/drivers/stepper/shell/app.overlay\nnew file mode 100644\nindex 00000000000..ee0a78de9b7\n--- /dev/null\n+++ b/tests/drivers/stepper/shell/app.overlay\n@@ -0,0 +1,12 @@\n+/*\n+ * Copyright (c) 2024 Fabian Blatz <fabianblatz@gmail.com>\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+/{\n+\tfake_stepper: fake_stepper {\n+\t\tcompatible = \"zephyr,fake-stepper\";\n+\t\tstatus = \"okay\";\n+\t};\n+};\ndiff --git a/tests/drivers/stepper/shell/prj.conf b/tests/drivers/stepper/shell/prj.conf\nnew file mode 100644\nindex 00000000000..135010e4e73\n--- /dev/null\n+++ b/tests/drivers/stepper/shell/prj.conf\n@@ -0,0 +1,7 @@\n+CONFIG_SHELL=y\n+CONFIG_SHELL_BACKEND_SERIAL=n\n+CONFIG_SHELL_BACKEND_DUMMY=y\n+CONFIG_STEPPER=y\n+CONFIG_STEPPER_SHELL=y\n+CONFIG_ZTEST=y\n+CONFIG_ZTEST_STACK_SIZE=1536\ndiff --git a/tests/drivers/stepper/shell/src/main.c b/tests/drivers/stepper/shell/src/main.c\nnew file mode 100644\nindex 00000000000..c83595a43f6\n--- /dev/null\n+++ b/tests/drivers/stepper/shell/src/main.c\n@@ -0,0 +1,177 @@\n+/*\n+ * Copyright (c) 2024 Fabian Blatz <fabianblatz@gmail.com>\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+#include <string.h>\n+\n+#include <zephyr/drivers/stepper.h>\n+#include <zephyr/drivers/stepper/stepper_fake.h>\n+#include <zephyr/fff.h>\n+#include <zephyr/shell/shell.h>\n+#include <zephyr/shell/shell_dummy.h>\n+#include <zephyr/ztest.h>\n+#include <zephyr/sys/util.h>\n+\n+#define FAKE_STEPPER_NAME DEVICE_DT_NAME(DT_NODELABEL(fake_stepper))\n+\n+/* Global variables */\n+static const struct device *const fake_stepper_dev = DEVICE_DT_GET(DT_NODELABEL(fake_stepper));\n+\n+DEFINE_FFF_GLOBALS;\n+\n+#define ASSERT_STEPPER_FUNC_CALLED(stepper_fake_func, retval)                                      \\\n+\tzassert_ok(retval, \"failed to execute shell command (err %d)\", retval);                    \\\n+\tzassert_equal(stepper_fake_func.call_count, 1,                                             \\\n+\t\t      STRINGIFY(stepper_fake_func) \" function not called\");                        \\\n+\tzassert_equal(stepper_fake_func.arg0_val, fake_stepper_dev, \"wrong device pointer\")\n+\n+static void *stepper_shell_setup(void)\n+{\n+\tconst struct shell *sh = shell_backend_dummy_get_ptr();\n+\n+\t/* Wait for the initialization of the shell dummy backend. */\n+\tWAIT_FOR(shell_ready(sh), 20000, k_msleep(1));\n+\tzassert_true(shell_ready(sh), \"timed out waiting for dummy shell backend\");\n+\n+\treturn NULL;\n+}\n+\n+ZTEST_SUITE(stepper_shell, NULL, stepper_shell_setup, NULL, NULL, NULL);\n+\n+ZTEST(stepper_shell, test_stepper_enable)\n+{\n+\tconst struct shell *sh = shell_backend_dummy_get_ptr();\n+\tint err = shell_execute_cmd(sh, \"stepper enable \" FAKE_STEPPER_NAME \" on\");\n+\n+\tASSERT_STEPPER_FUNC_CALLED(fake_stepper_enable_fake, err);\n+\tzassert_equal(fake_stepper_enable_fake.arg1_val, true, \"wrong enable value\");\n+\n+\tRESET_FAKE(fake_stepper_enable);\n+\n+\terr = shell_execute_cmd(sh, \"stepper enable \" FAKE_STEPPER_NAME \" off\");\n+\tASSERT_STEPPER_FUNC_CALLED(fake_stepper_enable_fake, err);\n+\tzassert_equal(fake_stepper_enable_fake.arg1_val, false, \"wrong enable value\");\n+}\n+\n+ZTEST(stepper_shell, test_stepper_move)\n+{\n+\tconst struct shell *sh = shell_backend_dummy_get_ptr();\n+\tint err = shell_execute_cmd(sh, \"stepper move \" FAKE_STEPPER_NAME \" 1000\");\n+\n+\tASSERT_STEPPER_FUNC_CALLED(fake_stepper_move_fake, err);\n+\tzassert_equal(fake_stepper_move_fake.arg1_val, 1000, \"wrong microsteps value\");\n+#ifdef CONFIG_STEPPER_SHELL_ASYNC\n+\tzassert_not_null(fake_stepper_move_fake.arg2_val, \"async poll signal not be null\");\n+#else\n+\tzassert_is_null(fake_stepper_move_fake.arg2_val, \"async poll signal is null\");\n+#endif /* CONFIG_STEPPER_SHELL_ASYNC */\n+}\n+\n+ZTEST(stepper_shell, test_stepper_set_max_velocity)\n+{\n+\tconst struct shell *sh = shell_backend_dummy_get_ptr();\n+\tint err = shell_execute_cmd(sh, \"stepper set_max_velocity \" FAKE_STEPPER_NAME \" 200\");\n+\n+\tASSERT_STEPPER_FUNC_CALLED(fake_stepper_set_max_velocity_fake, err);\n+\tzassert_equal(fake_stepper_set_max_velocity_fake.arg1_val, 200, \"wrong velocity value\");\n+}\n+\n+ZTEST(stepper_shell, test_stepper_set_micro_step_res)\n+{\n+\tconst struct shell *sh = shell_backend_dummy_get_ptr();\n+\tint err = shell_execute_cmd(sh, \"stepper set_micro_step_res \" FAKE_STEPPER_NAME \" 64\");\n+\n+\tASSERT_STEPPER_FUNC_CALLED(fake_stepper_set_micro_step_res_fake, err);\n+\tzassert_equal(fake_stepper_set_micro_step_res_fake.arg1_val, 64,\n+\t\t      \"wrong micro steps resolution value\");\n+}\n+\n+ZTEST(stepper_shell, test_stepper_set_micro_step_res_invalid_value)\n+{\n+\tconst struct shell *sh = shell_backend_dummy_get_ptr();\n+\tint err = shell_execute_cmd(sh, \"stepper set_micro_step_res \" FAKE_STEPPER_NAME \" 111\");\n+\n+\tzassert_not_equal(err, 0, \" executed set_micro_step_res with invalid micro steps value\");\n+}\n+\n+ZTEST(stepper_shell, test_stepper_get_micro_step_res)\n+{\n+\tconst struct shell *sh = shell_backend_dummy_get_ptr();\n+\tint err = shell_execute_cmd(sh, \"stepper get_micro_step_res \" FAKE_STEPPER_NAME);\n+\n+\tASSERT_STEPPER_FUNC_CALLED(fake_stepper_get_micro_step_res_fake, err);\n+}\n+\n+ZTEST(stepper_shell, test_stepper_set_actual_position)\n+{\n+\tconst struct shell *sh = shell_backend_dummy_get_ptr();\n+\tint err = shell_execute_cmd(sh, \"stepper set_actual_position \" FAKE_STEPPER_NAME \" 100\");\n+\n+\tASSERT_STEPPER_FUNC_CALLED(fake_stepper_set_actual_position_fake, err);\n+\tzassert_equal(fake_stepper_set_actual_position_fake.arg1_val, 100,\n+\t\t      \"wrong actual position value\");\n+}\n+\n+ZTEST(stepper_shell, test_stepper_get_actual_position)\n+{\n+\tconst struct shell *sh = shell_backend_dummy_get_ptr();\n+\tint err = shell_execute_cmd(sh, \"stepper get_actual_position \" FAKE_STEPPER_NAME);\n+\n+\tASSERT_STEPPER_FUNC_CALLED(fake_stepper_get_actual_position_fake, err);\n+}\n+\n+ZTEST(stepper_shell, test_stepper_set_target_position)\n+{\n+\tconst struct shell *sh = shell_backend_dummy_get_ptr();\n+\tint err = shell_execute_cmd(sh, \"stepper set_target_position \" FAKE_STEPPER_NAME \" 200\");\n+\n+\tASSERT_STEPPER_FUNC_CALLED(fake_stepper_set_target_position_fake, err);\n+\tzassert_equal(fake_stepper_set_target_position_fake.arg1_val, 200,\n+\t\t      \"wrong target position value\");\n+#ifdef CONFIG_STEPPER_SHELL_ASYNC\n+\tzassert_not_null(fake_stepper_set_target_position_fake.arg2_val,\n+\t\t\t \"async poll signal not be null\");\n+#else\n+\tzassert_is_null(fake_stepper_set_target_position_fake.arg2_val,\n+\t\t\t\"async poll signal is null\");\n+#endif /* CONFIG_STEPPER_SHELL_ASYNC */\n+}\n+\n+ZTEST(stepper_shell, test_stepper_enable_constant_velocity_mode)\n+{\n+\tconst struct shell *sh = shell_backend_dummy_get_ptr();\n+\tint err = shell_execute_cmd(sh, \"stepper enable_constant_velocity_mode \" FAKE_STEPPER_NAME\n+\t\t\t\t\t\" positive 200\");\n+\n+\tASSERT_STEPPER_FUNC_CALLED(fake_stepper_enable_constant_velocity_mode_fake, err);\n+\tzassert_equal(fake_stepper_enable_constant_velocity_mode_fake.arg1_val,\n+\t\t      STEPPER_DIRECTION_POSITIVE, \"wrong direction value\");\n+\tzassert_equal(fake_stepper_enable_constant_velocity_mode_fake.arg2_val, 200,\n+\t\t      \"wrong velocity value\");\n+}\n+\n+ZTEST(stepper_shell, test_stepper_enable_constant_velocity_mode_invalid_direction)\n+{\n+\tconst struct shell *sh = shell_backend_dummy_get_ptr();\n+\tint err = shell_execute_cmd(sh, \"stepper enable_constant_velocity_mode \" FAKE_STEPPER_NAME\n+\t\t\t\t\t\" foo 200\");\n+\n+\tzassert_not_equal(err, 0,\n+\t\t\t  \" executed enable_constant_velocity_mode with invalid direction value\");\n+}\n+\n+ZTEST(stepper_shell, test_stepper_info)\n+{\n+\tconst struct shell *sh = shell_backend_dummy_get_ptr();\n+\tint err = shell_execute_cmd(sh, \"stepper info \" FAKE_STEPPER_NAME);\n+\n+\tzassert_ok(err, \"failed to execute shell command (err %d)\", err);\n+\n+\tzassert_equal(fake_stepper_is_moving_fake.call_count, 1, \"is_moving function not called\");\n+\tzassert_equal(fake_stepper_get_actual_position_fake.call_count, 1,\n+\t\t      \"get_actual_position function not called\");\n+\tzassert_equal(fake_stepper_get_micro_step_res_fake.call_count, 1,\n+\t\t      \"get_micro_step_res function not called\");\n+}\ndiff --git a/tests/drivers/stepper/shell/testcase.yaml b/tests/drivers/stepper/shell/testcase.yaml\nnew file mode 100644\nindex 00000000000..b3a3193ee7b\n--- /dev/null\n+++ b/tests/drivers/stepper/shell/testcase.yaml\n@@ -0,0 +1,17 @@\n+common:\n+  tags:\n+    - drivers\n+    - stepper\n+    - shell\n+\n+tests:\n+  drivers.stepper.shell:\n+    integration_platforms:\n+      - native_sim\n+      - native_sim/native/64\n+  drivers.stepper.shell_async:\n+    integration_platforms:\n+      - native_sim\n+      - native_sim/native/64\n+    extra_configs:\n+      - CONFIG_STEPPER_SHELL_ASYNC=y"
},{
  "instruction": "drivers: stepper: Add fake stepper driver",
  "input": "",
  "result": "diff --git a/drivers/stepper/CMakeLists.txt b/drivers/stepper/CMakeLists.txt\nindex a7d2bdd5b71..f45c0d0d717 100644\n--- a/drivers/stepper/CMakeLists.txt\n+++ b/drivers/stepper/CMakeLists.txt\n@@ -5,6 +5,7 @@ zephyr_syscall_header(${ZEPHYR_BASE}/include/zephyr/drivers/stepper.h)\n \n zephyr_library()\n \n+zephyr_library_sources_ifdef(CONFIG_FAKE_STEPPER fake_stepper_controller.c)\n zephyr_library_sources_ifdef(CONFIG_GPIO_STEPPER gpio_stepper_controller.c)\n \n zephyr_library_sources_ifdef(CONFIG_STEPPER_SHELL stepper_shell.c)\ndiff --git a/drivers/stepper/Kconfig b/drivers/stepper/Kconfig\nindex da8fe013a25..43e4c2d49ae 100644\n--- a/drivers/stepper/Kconfig\n+++ b/drivers/stepper/Kconfig\n@@ -49,6 +49,7 @@ config STEPPER_SHELL_THREAD_PRIORITY\n \n comment \"Stepper Drivers\"\n \n+rsource \"Kconfig.fake\"\n rsource \"Kconfig.gpio\"\n \n endif\ndiff --git a/drivers/stepper/Kconfig.fake b/drivers/stepper/Kconfig.fake\nnew file mode 100644\nindex 00000000000..942a556f1be\n--- /dev/null\n+++ b/drivers/stepper/Kconfig.fake\n@@ -0,0 +1,11 @@\n+# Fake stepper configuration options\n+\n+# Copyright (c) 2024 Fabian Blatz <fabianblatz@gmail.com>\n+# SPDX-License-Identifier: Apache-2.0\n+\n+config FAKE_STEPPER\n+\tbool \"Fake stepper driver\"\n+\tdefault y\n+\tdepends on DT_HAS_ZEPHYR_FAKE_STEPPER_ENABLED\n+\thelp\n+\t  Enable support for the FFF-based fake stepper driver.\ndiff --git a/drivers/stepper/fake_stepper_controller.c b/drivers/stepper/fake_stepper_controller.c\nnew file mode 100644\nindex 00000000000..8c0f2a3ff2d\n--- /dev/null\n+++ b/drivers/stepper/fake_stepper_controller.c\n@@ -0,0 +1,147 @@\n+/*\n+ * SPDX-FileCopyrightText: Copyright (c) 2024 Fabian Blatz <fabianblatz@gmail.com>\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+#include <zephyr/device.h>\n+#include <zephyr/drivers/stepper.h>\n+#include <zephyr/drivers/stepper/stepper_fake.h>\n+#include <zephyr/fff.h>\n+\n+#ifdef CONFIG_ZTEST\n+#include <zephyr/ztest.h>\n+#endif /* CONFIG_ZTEST */\n+\n+#define DT_DRV_COMPAT zephyr_fake_stepper\n+\n+struct fake_stepper_data {\n+\tenum micro_step_resolution micro_step_res;\n+\tint32_t actual_position;\n+};\n+\n+DEFINE_FAKE_VALUE_FUNC(int, fake_stepper_enable, const struct device *, const bool);\n+\n+DEFINE_FAKE_VALUE_FUNC(int, fake_stepper_is_moving, const struct device *, bool *);\n+\n+DEFINE_FAKE_VALUE_FUNC(int, fake_stepper_move, const struct device *, const int32_t,\n+\t\t       struct k_poll_signal *);\n+\n+DEFINE_FAKE_VALUE_FUNC(int, fake_stepper_set_max_velocity, const struct device *, const uint32_t);\n+\n+DEFINE_FAKE_VALUE_FUNC(int, fake_stepper_set_micro_step_res, const struct device *,\n+\t\t       const enum micro_step_resolution);\n+\n+DEFINE_FAKE_VALUE_FUNC(int, fake_stepper_get_micro_step_res, const struct device *,\n+\t\t       enum micro_step_resolution *);\n+\n+DEFINE_FAKE_VALUE_FUNC(int, fake_stepper_set_actual_position, const struct device *, const int32_t);\n+\n+DEFINE_FAKE_VALUE_FUNC(int, fake_stepper_get_actual_position, const struct device *, int32_t *);\n+\n+DEFINE_FAKE_VALUE_FUNC(int, fake_stepper_set_target_position, const struct device *, const int32_t,\n+\t\t       struct k_poll_signal *);\n+\n+DEFINE_FAKE_VALUE_FUNC(int, fake_stepper_enable_constant_velocity_mode, const struct device *,\n+\t\t       const enum stepper_direction, const uint32_t);\n+\n+static int fake_stepper_set_micro_step_res_delegate(const struct device *dev,\n+\t\t\t\t\t\t    const enum micro_step_resolution res)\n+{\n+\tstruct fake_stepper_data *data = dev->data;\n+\n+\tdata->micro_step_res = res;\n+\n+\treturn 0;\n+}\n+\n+static int fake_stepper_get_micro_step_res_delegate(const struct device *dev,\n+\t\t\t\t\t\t    enum micro_step_resolution *res)\n+{\n+\tstruct fake_stepper_data *data = dev->data;\n+\n+\t*res = data->micro_step_res;\n+\n+\treturn 0;\n+}\n+\n+static int fake_stepper_set_actual_position_delegate(const struct device *dev, const int32_t pos)\n+{\n+\tstruct fake_stepper_data *data = dev->data;\n+\n+\tdata->actual_position = pos;\n+\n+\treturn 0;\n+}\n+\n+static int fake_stepper_get_actual_position_delegate(const struct device *dev, int32_t *pos)\n+{\n+\tstruct fake_stepper_data *data = dev->data;\n+\n+\t*pos = data->actual_position;\n+\n+\treturn 0;\n+}\n+\n+#ifdef CONFIG_ZTEST\n+static void fake_stepper_reset_rule_before(const struct ztest_unit_test *test, void *fixture)\n+{\n+\tARG_UNUSED(test);\n+\tARG_UNUSED(fixture);\n+\n+\tRESET_FAKE(fake_stepper_enable);\n+\tRESET_FAKE(fake_stepper_move);\n+\tRESET_FAKE(fake_stepper_is_moving);\n+\tRESET_FAKE(fake_stepper_set_max_velocity);\n+\tRESET_FAKE(fake_stepper_set_micro_step_res);\n+\tRESET_FAKE(fake_stepper_get_micro_step_res);\n+\tRESET_FAKE(fake_stepper_set_actual_position);\n+\tRESET_FAKE(fake_stepper_get_actual_position);\n+\tRESET_FAKE(fake_stepper_set_target_position);\n+\tRESET_FAKE(fake_stepper_enable_constant_velocity_mode);\n+\n+\t/* Install custom fakes for the setter and getter functions */\n+\tfake_stepper_set_micro_step_res_fake.custom_fake = fake_stepper_set_micro_step_res_delegate;\n+\tfake_stepper_get_micro_step_res_fake.custom_fake = fake_stepper_get_micro_step_res_delegate;\n+\tfake_stepper_set_actual_position_fake.custom_fake =\n+\t\tfake_stepper_set_actual_position_delegate;\n+\tfake_stepper_get_actual_position_fake.custom_fake =\n+\t\tfake_stepper_get_actual_position_delegate;\n+}\n+\n+ZTEST_RULE(fake_stepper_reset_rule, fake_stepper_reset_rule_before, NULL);\n+#endif /* CONFIG_ZTEST */\n+\n+static int fake_stepper_init(const struct device *dev)\n+{\n+\tfake_stepper_set_micro_step_res_fake.custom_fake = fake_stepper_set_micro_step_res_delegate;\n+\tfake_stepper_get_micro_step_res_fake.custom_fake = fake_stepper_get_micro_step_res_delegate;\n+\tfake_stepper_set_actual_position_fake.custom_fake =\n+\t\tfake_stepper_set_actual_position_delegate;\n+\tfake_stepper_get_actual_position_fake.custom_fake =\n+\t\tfake_stepper_get_actual_position_delegate;\n+\n+\treturn 0;\n+}\n+\n+static const struct stepper_driver_api fake_stepper_driver_api = {\n+\t.enable = fake_stepper_enable,\n+\t.move = fake_stepper_move,\n+\t.is_moving = fake_stepper_is_moving,\n+\t.set_max_velocity = fake_stepper_set_max_velocity,\n+\t.set_micro_step_res = fake_stepper_set_micro_step_res,\n+\t.get_micro_step_res = fake_stepper_get_micro_step_res,\n+\t.set_actual_position = fake_stepper_set_actual_position,\n+\t.get_actual_position = fake_stepper_get_actual_position,\n+\t.set_target_position = fake_stepper_set_target_position,\n+\t.enable_constant_velocity_mode = fake_stepper_enable_constant_velocity_mode,\n+};\n+\n+#define FAKE_STEPPER_INIT(inst)                                                                    \\\n+                                                                                                   \\\n+\tstatic struct fake_stepper_data fake_stepper_data_##inst;                                  \\\n+                                                                                                   \\\n+\tDEVICE_DT_INST_DEFINE(inst, fake_stepper_init, NULL, &fake_stepper_data_##inst, NULL,      \\\n+\t\t\t      POST_KERNEL, CONFIG_STEPPER_INIT_PRIORITY,                           \\\n+\t\t\t      &fake_stepper_driver_api);\n+\n+DT_INST_FOREACH_STATUS_OKAY(FAKE_STEPPER_INIT)\ndiff --git a/dts/bindings/stepper/zephyr,fake-stepper.yaml b/dts/bindings/stepper/zephyr,fake-stepper.yaml\nnew file mode 100644\nindex 00000000000..d286dfbfeb4\n--- /dev/null\n+++ b/dts/bindings/stepper/zephyr,fake-stepper.yaml\n@@ -0,0 +1,10 @@\n+# Copyright (c) 2024 Fabian Blatz <fabianblatz@gmail.com>\n+# SPDX-License-Identifier: Apache-2.0\n+\n+description: |\n+    This binding provides a fake stepper controller for use as either a stub or a mock in\n+    Zephyr testing.\n+\n+compatible: \"zephyr,fake-stepper\"\n+\n+include: stepper-controller.yaml\ndiff --git a/include/zephyr/drivers/stepper/stepper_fake.h b/include/zephyr/drivers/stepper/stepper_fake.h\nnew file mode 100644\nindex 00000000000..d329d6ee388\n--- /dev/null\n+++ b/include/zephyr/drivers/stepper/stepper_fake.h\n@@ -0,0 +1,47 @@\n+/*\n+ * Copyright (c) 2024 Fabian Blatz <fabianblatz@gmail.com>\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+#ifndef ZEPHYR_INCLUDE_DRIVERS_STEPPER_STEPPER_FAKE_H_\n+#define ZEPHYR_INCLUDE_DRIVERS_STEPPER_STEPPER_FAKE_H_\n+\n+#include <zephyr/drivers/stepper.h>\n+#include <zephyr/fff.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+DECLARE_FAKE_VALUE_FUNC(int, fake_stepper_enable, const struct device *, const bool);\n+\n+DECLARE_FAKE_VALUE_FUNC(int, fake_stepper_move, const struct device *, const int32_t,\n+\t\t\tstruct k_poll_signal *);\n+\n+DECLARE_FAKE_VALUE_FUNC(int, fake_stepper_set_max_velocity, const struct device *, const uint32_t);\n+\n+DECLARE_FAKE_VALUE_FUNC(int, fake_stepper_set_micro_step_res, const struct device *,\n+\t\t\tconst enum micro_step_resolution);\n+\n+DECLARE_FAKE_VALUE_FUNC(int, fake_stepper_get_micro_step_res, const struct device *,\n+\t\t\tenum micro_step_resolution *);\n+\n+DECLARE_FAKE_VALUE_FUNC(int, fake_stepper_set_actual_position, const struct device *,\n+\t\t\tconst int32_t);\n+\n+DECLARE_FAKE_VALUE_FUNC(int, fake_stepper_get_actual_position, const struct device *, int32_t *);\n+\n+DECLARE_FAKE_VALUE_FUNC(int, fake_stepper_set_target_position, const struct device *, const int32_t,\n+\t\t\tstruct k_poll_signal *);\n+\n+DECLARE_FAKE_VALUE_FUNC(int, fake_stepper_is_moving, const struct device *, bool *);\n+\n+DECLARE_FAKE_VALUE_FUNC(int, fake_stepper_enable_constant_velocity_mode, const struct device *,\n+\t\t\tconst enum stepper_direction, const uint32_t);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* ZEPHYR_INCLUDE_DRIVERS_STEPPER_STEPPER_FAKE_H_ */"
},{
  "instruction": "drivers: stepper: add stepper shell",
  "input": "",
  "result": "diff --git a/drivers/stepper/CMakeLists.txt b/drivers/stepper/CMakeLists.txt\nindex f7986fbfff7..a7d2bdd5b71 100644\n--- a/drivers/stepper/CMakeLists.txt\n+++ b/drivers/stepper/CMakeLists.txt\n@@ -6,3 +6,5 @@ zephyr_syscall_header(${ZEPHYR_BASE}/include/zephyr/drivers/stepper.h)\n zephyr_library()\n \n zephyr_library_sources_ifdef(CONFIG_GPIO_STEPPER gpio_stepper_controller.c)\n+\n+zephyr_library_sources_ifdef(CONFIG_STEPPER_SHELL stepper_shell.c)\ndiff --git a/drivers/stepper/Kconfig b/drivers/stepper/Kconfig\nindex 79dc03b65bc..da8fe013a25 100644\n--- a/drivers/stepper/Kconfig\n+++ b/drivers/stepper/Kconfig\n@@ -18,6 +18,35 @@ config STEPPER_INIT_PRIORITY\n \thelp\n \t  Stepper motor controller initialization priority.\n \n+config STEPPER_SHELL\n+\tbool \"Stepper shell\"\n+\tdepends on SHELL\n+\thelp\n+\t  Enable stepper shell for testing.\n+\n+config STEPPER_SHELL_ASYNC\n+\tbool \"Asynchronous stepper shell\"\n+\tdepends on STEPPER_SHELL\n+\tselect POLL\n+\thelp\n+\t  If enabled, the shell will run in asynchronous mode, spawning a thread\n+\t  that polls the completion of stepper motor moves and prints a message\n+\t  when all steps are completed.\n+\n+config STEPPER_SHELL_THREAD_STACK_SIZE\n+\tint \"Stepper shell thread stack size\"\n+\tdefault 1024\n+\tdepends on STEPPER_SHELL_ASYNC\n+\thelp\n+\t  The stack size for the stepper shell thread when asynchronous mode is enabled.\n+\n+config STEPPER_SHELL_THREAD_PRIORITY\n+\tint \"Stepper shell thread priority\"\n+\tdefault 7\n+\tdepends on STEPPER_SHELL_ASYNC\n+\thelp\n+\t  The priority for the stepper shell thread when asynchronous mode is enabled.\n+\n comment \"Stepper Drivers\"\n \n rsource \"Kconfig.gpio\"\ndiff --git a/drivers/stepper/stepper_shell.c b/drivers/stepper/stepper_shell.c\nnew file mode 100644\nindex 00000000000..fba5c3014ee\n--- /dev/null\n+++ b/drivers/stepper/stepper_shell.c\n@@ -0,0 +1,505 @@\n+/*\n+ * Copyright (c) 2024, Fabian Blatz <fabianblatz@gmail.com>\n+ * Copyright (c) 2024, Jilay Sandeep Pandya\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+#include <zephyr/shell/shell.h>\n+#include <zephyr/device.h>\n+#include <zephyr/drivers/stepper.h>\n+#include <stdlib.h>\n+\n+#include <zephyr/logging/log.h>\n+LOG_MODULE_REGISTER(stepper_shell, CONFIG_STEPPER_LOG_LEVEL);\n+\n+enum {\n+\tARG_IDX_DEV = 1,\n+\tARG_IDX_PARAM = 2,\n+\tARG_IDX_VALUE = 3,\n+};\n+\n+struct stepper_microstep_map {\n+\tconst char *name;\n+\tenum micro_step_resolution microstep;\n+};\n+\n+struct stepper_direction_map {\n+\tconst char *name;\n+\tenum stepper_direction direction;\n+};\n+\n+#define STEPPER_DIRECTION_MAP_ENTRY(_name, _dir)                                                   \\\n+\t{                                                                                          \\\n+\t\t.name = _name,                                                                     \\\n+\t\t.direction = _dir,                                                                 \\\n+\t}\n+\n+#define STEPPER_MICROSTEP_MAP(_name, _microstep)                                                   \\\n+\t{                                                                                          \\\n+\t\t.name = _name,                                                                     \\\n+\t\t.microstep = _microstep,                                                           \\\n+\t}\n+\n+#ifdef CONFIG_STEPPER_SHELL_ASYNC\n+\n+static struct k_poll_signal stepper_signal;\n+static struct k_poll_event stepper_poll_event =\n+\tK_POLL_EVENT_INITIALIZER(K_POLL_TYPE_SIGNAL, K_POLL_MODE_NOTIFY_ONLY, &stepper_signal);\n+\n+static bool poll_thread_started;\n+K_THREAD_STACK_DEFINE(poll_thread_stack, CONFIG_STEPPER_SHELL_THREAD_STACK_SIZE);\n+static struct k_thread poll_thread;\n+static int start_polling(const struct shell *sh);\n+\n+#endif /* CONFIG_STEPPER_SHELL_ASYNC */\n+\n+static const struct stepper_direction_map stepper_direction_map[] = {\n+\tSTEPPER_DIRECTION_MAP_ENTRY(\"positive\", STEPPER_DIRECTION_POSITIVE),\n+\tSTEPPER_DIRECTION_MAP_ENTRY(\"negative\", STEPPER_DIRECTION_NEGATIVE),\n+};\n+\n+static const struct stepper_microstep_map stepper_microstep_map[] = {\n+\tSTEPPER_MICROSTEP_MAP(\"1\", STEPPER_FULL_STEP),\n+\tSTEPPER_MICROSTEP_MAP(\"2\", STEPPER_MICRO_STEP_2),\n+\tSTEPPER_MICROSTEP_MAP(\"4\", STEPPER_MICRO_STEP_4),\n+\tSTEPPER_MICROSTEP_MAP(\"8\", STEPPER_MICRO_STEP_8),\n+\tSTEPPER_MICROSTEP_MAP(\"16\", STEPPER_MICRO_STEP_16),\n+\tSTEPPER_MICROSTEP_MAP(\"32\", STEPPER_MICRO_STEP_32),\n+\tSTEPPER_MICROSTEP_MAP(\"64\", STEPPER_MICRO_STEP_64),\n+\tSTEPPER_MICROSTEP_MAP(\"128\", STEPPER_MICRO_STEP_128),\n+\tSTEPPER_MICROSTEP_MAP(\"256\", STEPPER_MICRO_STEP_256),\n+};\n+\n+static void cmd_stepper_direction(size_t idx, struct shell_static_entry *entry)\n+{\n+\tif (idx < ARRAY_SIZE(stepper_direction_map)) {\n+\t\tentry->syntax = stepper_direction_map[idx].name;\n+\t} else {\n+\t\tentry->syntax = NULL;\n+\t}\n+\tentry->handler = NULL;\n+\tentry->help = \"Stepper direction\";\n+\tentry->subcmd = NULL;\n+}\n+\n+SHELL_DYNAMIC_CMD_CREATE(dsub_stepper_direction, cmd_stepper_direction);\n+\n+static void cmd_stepper_microstep(size_t idx, struct shell_static_entry *entry)\n+{\n+\tif (idx < ARRAY_SIZE(stepper_microstep_map)) {\n+\t\tentry->syntax = stepper_microstep_map[idx].name;\n+\t} else {\n+\t\tentry->syntax = NULL;\n+\t}\n+\tentry->handler = NULL;\n+\tentry->help = \"Stepper microstep resolution\";\n+\tentry->subcmd = NULL;\n+}\n+\n+SHELL_DYNAMIC_CMD_CREATE(dsub_stepper_microstep, cmd_stepper_microstep);\n+\n+static void cmd_pos_stepper_motor_name(size_t idx, struct shell_static_entry *entry)\n+{\n+\tconst struct device *dev = shell_device_lookup(idx, NULL);\n+\n+\tentry->syntax = (dev != NULL) ? dev->name : NULL;\n+\tentry->handler = NULL;\n+\tentry->help = \"List Devices\";\n+\tentry->subcmd = NULL;\n+}\n+\n+SHELL_DYNAMIC_CMD_CREATE(dsub_pos_stepper_motor_name, cmd_pos_stepper_motor_name);\n+\n+static void cmd_pos_stepper_motor_name_dir(size_t idx, struct shell_static_entry *entry)\n+{\n+\tconst struct device *dev = shell_device_lookup(idx, NULL);\n+\n+\tif (dev != NULL) {\n+\t\tentry->syntax = dev->name;\n+\t} else {\n+\t\tentry->syntax = NULL;\n+\t}\n+\tentry->handler = NULL;\n+\tentry->help = \"List Devices\";\n+\tentry->subcmd = &dsub_stepper_direction;\n+}\n+\n+SHELL_DYNAMIC_CMD_CREATE(dsub_pos_stepper_motor_name_dir, cmd_pos_stepper_motor_name_dir);\n+\n+static void cmd_pos_stepper_motor_name_microstep(size_t idx, struct shell_static_entry *entry)\n+{\n+\tconst struct device *dev = shell_device_lookup(idx, NULL);\n+\n+\tif (dev != NULL) {\n+\t\tentry->syntax = dev->name;\n+\t} else {\n+\t\tentry->syntax = NULL;\n+\t}\n+\tentry->handler = NULL;\n+\tentry->help = \"List Devices\";\n+\tentry->subcmd = &dsub_stepper_microstep;\n+}\n+\n+SHELL_DYNAMIC_CMD_CREATE(dsub_pos_stepper_motor_name_microstep,\n+\t\t\t cmd_pos_stepper_motor_name_microstep);\n+\n+static int parse_device_arg(const struct shell *sh, char **argv, const struct device **dev)\n+{\n+\t*dev = device_get_binding(argv[ARG_IDX_DEV]);\n+\tif (!*dev) {\n+\t\tshell_error(sh, \"Stepper device %s not found\", argv[ARG_IDX_DEV]);\n+\t\treturn -ENODEV;\n+\t}\n+\treturn 0;\n+}\n+\n+static int cmd_stepper_enable(const struct shell *sh, size_t argc, char **argv)\n+{\n+\tconst struct device *dev;\n+\tint err = 0;\n+\tbool enable = shell_strtobool(argv[ARG_IDX_PARAM], 10, &err);\n+\n+\tif (err < 0) {\n+\t\treturn err;\n+\t}\n+\n+\terr = parse_device_arg(sh, argv, &dev);\n+\tif (err < 0) {\n+\t\treturn err;\n+\t}\n+\n+\terr = stepper_enable(dev, enable);\n+\tif (err) {\n+\t\tshell_error(sh, \"Error: %d\", err);\n+\t}\n+\n+\treturn err;\n+}\n+\n+static int cmd_stepper_move(const struct shell *sh, size_t argc, char **argv)\n+{\n+\tconst struct device *dev;\n+\tint err = 0;\n+\tstruct k_poll_signal *poll_signal =\n+\t\tCOND_CODE_1(CONFIG_STEPPER_SHELL_ASYNC, (&stepper_signal), (NULL));\n+\tint32_t micro_steps = shell_strtol(argv[ARG_IDX_PARAM], 10, &err);\n+\n+\tif (err < 0) {\n+\t\treturn err;\n+\t}\n+\n+\terr = parse_device_arg(sh, argv, &dev);\n+\tif (err < 0) {\n+\t\treturn err;\n+\t}\n+\n+#ifdef CONFIG_STEPPER_SHELL_ASYNC\n+\tstart_polling(sh);\n+#endif /* CONFIG_STEPPER_SHELL_ASYNC */\n+\n+\terr = stepper_move(dev, micro_steps, poll_signal);\n+\tif (err) {\n+\t\tshell_error(sh, \"Error: %d\", err);\n+\t}\n+\n+\treturn err;\n+}\n+\n+static int cmd_stepper_set_max_velocity(const struct shell *sh, size_t argc, char **argv)\n+{\n+\tconst struct device *dev;\n+\tint err = 0;\n+\tuint32_t velocity = shell_strtoul(argv[ARG_IDX_PARAM], 10, &err);\n+\n+\tif (err < 0) {\n+\t\treturn err;\n+\t}\n+\n+\terr = parse_device_arg(sh, argv, &dev);\n+\tif (err < 0) {\n+\t\treturn err;\n+\t}\n+\n+\terr = stepper_set_max_velocity(dev, velocity);\n+\tif (err) {\n+\t\tshell_error(sh, \"Error: %d\", err);\n+\t}\n+\n+\treturn err;\n+}\n+\n+static int cmd_stepper_set_micro_step_res(const struct shell *sh, size_t argc, char **argv)\n+{\n+\tconst struct device *dev;\n+\tenum micro_step_resolution resolution;\n+\tint err = -EINVAL;\n+\n+\tfor (int i = 0; i < ARRAY_SIZE(stepper_microstep_map); i++) {\n+\t\tif (strcmp(argv[ARG_IDX_PARAM], stepper_microstep_map[i].name) == 0) {\n+\t\t\tresolution = stepper_microstep_map[i].microstep;\n+\t\t\terr = 0;\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\tif (err != 0) {\n+\t\tshell_error(sh, \"Invalid microstep value %s\", argv[ARG_IDX_PARAM]);\n+\t\treturn err;\n+\t}\n+\n+\terr = parse_device_arg(sh, argv, &dev);\n+\tif (err < 0) {\n+\t\treturn err;\n+\t}\n+\n+\terr = stepper_set_micro_step_res(dev, resolution);\n+\tif (err) {\n+\t\tshell_error(sh, \"Error: %d\", err);\n+\t}\n+\n+\treturn err;\n+}\n+\n+static int cmd_stepper_get_micro_step_res(const struct shell *sh, size_t argc, char **argv)\n+{\n+\tconst struct device *dev;\n+\tint err;\n+\tenum micro_step_resolution micro_step_res;\n+\n+\terr = parse_device_arg(sh, argv, &dev);\n+\tif (err < 0) {\n+\t\treturn err;\n+\t}\n+\n+\terr = stepper_get_micro_step_res(dev, &micro_step_res);\n+\tif (err < 0) {\n+\t\tshell_warn(sh, \"Failed to get micro-step resolution: %d\", err);\n+\t} else {\n+\t\tshell_print(sh, \"Micro-step Resolution: %d\", micro_step_res);\n+\t}\n+\n+\treturn err;\n+}\n+\n+static int cmd_stepper_set_actual_position(const struct shell *sh, size_t argc, char **argv)\n+{\n+\tconst struct device *dev;\n+\tint err = 0;\n+\tint32_t position = shell_strtol(argv[ARG_IDX_PARAM], 10, &err);\n+\n+\tif (err < 0) {\n+\t\treturn err;\n+\t}\n+\n+\terr = parse_device_arg(sh, argv, &dev);\n+\tif (err < 0) {\n+\t\treturn err;\n+\t}\n+\n+\terr = stepper_set_actual_position(dev, position);\n+\tif (err) {\n+\t\tshell_error(sh, \"Error: %d\", err);\n+\t}\n+\n+\treturn err;\n+}\n+\n+static int cmd_stepper_get_actual_position(const struct shell *sh, size_t argc, char **argv)\n+{\n+\tconst struct device *dev;\n+\tint err;\n+\tint32_t actual_position;\n+\n+\terr = parse_device_arg(sh, argv, &dev);\n+\tif (err < 0) {\n+\t\treturn err;\n+\t}\n+\n+\terr = stepper_get_actual_position(dev, &actual_position);\n+\tif (err < 0) {\n+\t\tshell_warn(sh, \"Failed to get actual position: %d\", err);\n+\t} else {\n+\t\tshell_print(sh, \"Actual Position: %d\", actual_position);\n+\t}\n+\n+\treturn err;\n+}\n+\n+static int cmd_stepper_set_target_position(const struct shell *sh, size_t argc, char **argv)\n+{\n+\tconst struct device *dev;\n+\tint err = 0;\n+\tconst int32_t position = shell_strtol(argv[ARG_IDX_PARAM], 10, &err);\n+\n+\tif (err < 0) {\n+\t\treturn err;\n+\t}\n+\n+\tstruct k_poll_signal *poll_signal =\n+\t\tCOND_CODE_1(CONFIG_STEPPER_SHELL_ASYNC, (&stepper_signal), (NULL));\n+\n+\terr = parse_device_arg(sh, argv, &dev);\n+\tif (err < 0) {\n+\t\treturn err;\n+\t}\n+\n+#ifdef CONFIG_STEPPER_SHELL_ASYNC\n+\tstart_polling(sh);\n+#endif /* CONFIG_STEPPER_SHELL_ASYNC */\n+\n+\terr = stepper_set_target_position(dev, position, poll_signal);\n+\tif (err) {\n+\t\tshell_error(sh, \"Error: %d\", err);\n+\t}\n+\n+\treturn err;\n+}\n+\n+static int cmd_stepper_enable_constant_velocity_mode(const struct shell *sh, size_t argc,\n+\t\t\t\t\t\t     char **argv)\n+{\n+\tconst struct device *dev;\n+\tint err = -EINVAL;\n+\tenum stepper_direction direction;\n+\n+\tfor (int i = 0; i < ARRAY_SIZE(stepper_direction_map); i++) {\n+\t\tif (strcmp(argv[ARG_IDX_PARAM], stepper_direction_map[i].name) == 0) {\n+\t\t\tdirection = stepper_direction_map[i].direction;\n+\t\t\terr = 0;\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\tif (err != 0) {\n+\t\tshell_error(sh, \"Invalid direction %s\", argv[ARG_IDX_PARAM]);\n+\t\treturn err;\n+\t}\n+\n+\tuint32_t velocity = shell_strtoul(argv[ARG_IDX_VALUE], 10, &err);\n+\n+\tif (err < 0) {\n+\t\treturn err;\n+\t}\n+\n+\terr = parse_device_arg(sh, argv, &dev);\n+\tif (err < 0) {\n+\t\treturn err;\n+\t}\n+\n+\terr = stepper_enable_constant_velocity_mode(dev, direction, velocity);\n+\tif (err) {\n+\t\tshell_error(sh, \"Error: %d\", err);\n+\t\treturn err;\n+\t}\n+\n+\treturn 0;\n+}\n+\n+static int cmd_stepper_info(const struct shell *sh, size_t argc, char **argv)\n+{\n+\tconst struct device *dev;\n+\tint err;\n+\tbool is_moving;\n+\tint32_t actual_position;\n+\tenum micro_step_resolution micro_step_res;\n+\n+\terr = parse_device_arg(sh, argv, &dev);\n+\tif (err < 0) {\n+\t\treturn err;\n+\t}\n+\n+\tshell_print(sh, \"Stepper Info:\");\n+\tshell_print(sh, \"Device: %s\", dev->name);\n+\n+\terr = stepper_get_actual_position(dev, &actual_position);\n+\tif (err < 0) {\n+\t\tshell_warn(sh, \"Failed to get actual position: %d\", err);\n+\t} else {\n+\t\tshell_print(sh, \"Actual Position: %d\", actual_position);\n+\t}\n+\n+\terr = stepper_get_micro_step_res(dev, &micro_step_res);\n+\tif (err < 0) {\n+\t\tshell_warn(sh, \"Failed to get micro-step resolution: %d\", err);\n+\t} else {\n+\t\tshell_print(sh, \"Micro-step Resolution: %d\", micro_step_res);\n+\t}\n+\n+\terr = stepper_is_moving(dev, &is_moving);\n+\tif (err < 0) {\n+\t\tshell_warn(sh, \"Failed to check if the motor is moving: %d\", err);\n+\t} else {\n+\t\tshell_print(sh, \"Is Moving: %s\", is_moving ? \"Yes\" : \"No\");\n+\t}\n+\n+\treturn 0;\n+}\n+\n+#ifdef CONFIG_STEPPER_SHELL_ASYNC\n+\n+static void stepper_poll_thread(void *p1, void *p2, void *p3)\n+{\n+\tARG_UNUSED(p2);\n+\tARG_UNUSED(p3);\n+\tconst struct shell *sh = p1;\n+\n+\twhile (1) {\n+\t\tk_poll(&stepper_poll_event, 1, K_FOREVER);\n+\n+\t\tif (stepper_poll_event.signal->result == STEPPER_SIGNAL_STEPS_COMPLETED) {\n+\t\t\tshell_print(sh, \"Stepper: All steps completed\");\n+\t\t\tk_poll_signal_reset(&stepper_signal);\n+\t\t}\n+\t}\n+}\n+\n+static int start_polling(const struct shell *sh)\n+{\n+\tk_tid_t tid;\n+\n+\tif (poll_thread_started) {\n+\t\treturn 0;\n+\t}\n+\n+\tk_poll_signal_init(&stepper_signal);\n+\ttid = k_thread_create(&poll_thread, poll_thread_stack,\n+\t\t\t      K_KERNEL_STACK_SIZEOF(poll_thread_stack), stepper_poll_thread,\n+\t\t\t      (void *)sh, NULL, NULL, CONFIG_STEPPER_SHELL_THREAD_PRIORITY, 0,\n+\t\t\t      K_NO_WAIT);\n+\tif (!tid) {\n+\t\tshell_error(sh, \"Cannot start poll thread\");\n+\t\treturn -ENOEXEC;\n+\t}\n+\n+\tk_thread_name_set(tid, \"stepper_shell\");\n+\tk_thread_start(tid);\n+\tpoll_thread_started = true;\n+\treturn 0;\n+}\n+\n+#endif /* CONFIG_STEPPER_SHELL_ASYNC */\n+\n+SHELL_STATIC_SUBCMD_SET_CREATE(\n+\tstepper_cmds,\n+\tSHELL_CMD_ARG(enable, &dsub_pos_stepper_motor_name, \"<device> <on/off>\", cmd_stepper_enable,\n+\t\t      3, 0),\n+\tSHELL_CMD_ARG(move, &dsub_pos_stepper_motor_name, \"<device> <micro_steps>\",\n+\t\t      cmd_stepper_move, 3, 0),\n+\tSHELL_CMD_ARG(set_max_velocity, &dsub_pos_stepper_motor_name, \"<device> <velocity>\",\n+\t\t      cmd_stepper_set_max_velocity, 3, 0),\n+\tSHELL_CMD_ARG(set_micro_step_res, &dsub_pos_stepper_motor_name_microstep,\n+\t\t      \"<device> <resolution>\", cmd_stepper_set_micro_step_res, 3, 0),\n+\tSHELL_CMD_ARG(get_micro_step_res, &dsub_pos_stepper_motor_name, \"<device>\",\n+\t\t      cmd_stepper_get_micro_step_res, 2, 0),\n+\tSHELL_CMD_ARG(set_actual_position, &dsub_pos_stepper_motor_name, \"<device> <position>\",\n+\t\t      cmd_stepper_set_actual_position, 3, 0),\n+\tSHELL_CMD_ARG(get_actual_position, &dsub_pos_stepper_motor_name, \"<device>\",\n+\t\t      cmd_stepper_get_actual_position, 2, 0),\n+\tSHELL_CMD_ARG(set_target_position, &dsub_pos_stepper_motor_name, \"<device> <micro_steps>\",\n+\t\t      cmd_stepper_set_target_position, 3, 0),\n+\tSHELL_CMD_ARG(enable_constant_velocity_mode, &dsub_pos_stepper_motor_name_dir,\n+\t\t      \"<device> <direction> <velocity>\", cmd_stepper_enable_constant_velocity_mode,\n+\t\t      4, 0),\n+\tSHELL_CMD_ARG(info, &dsub_pos_stepper_motor_name, \"<device>\", cmd_stepper_info, 2, 0),\n+\tSHELL_SUBCMD_SET_END);\n+\n+SHELL_CMD_REGISTER(stepper, &stepper_cmds, \"Stepper motor commands\", NULL);"
},{
  "instruction": "samples: wifi: ESP32-S2 sample configuration",
  "input": "CONFIG_HEAP_MEM_POOL_SIZE=34816\n# decrease packet count and size to save RAM\nCONFIG_NET_PKT_RX_COUNT=7\nCONFIG_NET_PKT_TX_COUNT=7\nCONFIG_NET_BUF_RX_COUNT=7\nCONFIG_NET_BUF_TX_COUNT=7\nCONFIG_ESP32_WIFI_IRAM_OPT=n\nCONFIG_ESP32_WIFI_RX_IRAM_OPT=n",
  "result": "diff --git a/samples/net/wifi/socs/esp32s2.conf b/samples/net/wifi/socs/esp32s2.conf\nindex e9ce202c42c..da326160cb5 100644\n--- a/samples/net/wifi/socs/esp32s2.conf\n+++ b/samples/net/wifi/socs/esp32s2.conf\n@@ -1,14 +1,4 @@\n CONFIG_WIFI=y\n-CONFIG_HEAP_MEM_POOL_SIZE=34816\n-\n-# decrease packet count and size to save RAM\n-CONFIG_NET_PKT_RX_COUNT=7\n-CONFIG_NET_PKT_TX_COUNT=7\n-CONFIG_NET_BUF_RX_COUNT=7\n-CONFIG_NET_BUF_TX_COUNT=7\n-\n-CONFIG_ESP32_WIFI_IRAM_OPT=n\n-CONFIG_ESP32_WIFI_RX_IRAM_OPT=n\n \n CONFIG_NETWORKING=y\n CONFIG_NET_L2_ETHERNET=y"
},{
  "instruction": "boards: espressif: Update system heap increment",
  "input": "\tdefault 65535 if WIFI && BT\n\tdefault 51200 if WIFI\n\tdefault 40960 if BT\n\tdefault 4096\n\tdefault 65535 if WIFI && BT\n\tdefault 51200 if WIFI\n\tdefault 40960 if BT\n\tdefault 4096\n\tdefault 65535 if WIFI && BT\n\tdefault 51200 if WIFI\n\tdefault 40960 if BT\n\tdefault 4096\n\tdefault 65535 if WIFI && BT\n\tdefault 51200 if WIFI\n\tdefault 40960 if BT\n\tdefault 4096\n\tdefault 32768 if WIFI\n\tdefault 4096\n\tdefault 32768 if WIFI\n\tdefault 4096\n\tdefault 65535 if WIFI && BT\n\tdefault 51200 if WIFI\n\tdefault 40960 if BT\n\tdefault 65535 if WIFI && BT\n\tdefault 51200 if WIFI\n\tdefault 40960 if BT\n\tdefault 65535 if WIFI && BT\n\tdefault 51200 if WIFI\n\tdefault 40960 if BT\n\tdefault 4096\n\tdefault 65535 if WIFI && BT\n\tdefault 51200 if WIFI\n\tdefault 40960 if BT\n\tdefault 4096",
  "result": "diff --git a/boards/espressif/esp32_devkitc_wroom/Kconfig.defconfig b/boards/espressif/esp32_devkitc_wroom/Kconfig.defconfig\nindex 374b423b548..94d147b529f 100644\n--- a/boards/espressif/esp32_devkitc_wroom/Kconfig.defconfig\n+++ b/boards/espressif/esp32_devkitc_wroom/Kconfig.defconfig\n@@ -7,10 +7,7 @@ if BOARD_ESP32_DEVKITC_WROOM_ESP32_PROCPU\n \n config HEAP_MEM_POOL_ADD_SIZE_BOARD\n \tint\n-\tdefault 65535 if WIFI && BT\n-\tdefault 51200 if WIFI\n-\tdefault 40960 if BT\n-\tdefault 4096\n+\tdefault 8192\n \n endif # BOARD_ESP32_DEVKITC_WROOM_ESP32_PROCPU\n \ndiff --git a/boards/espressif/esp32_devkitc_wrover/Kconfig.defconfig b/boards/espressif/esp32_devkitc_wrover/Kconfig.defconfig\nindex c56c404a40e..a5f2c065833 100644\n--- a/boards/espressif/esp32_devkitc_wrover/Kconfig.defconfig\n+++ b/boards/espressif/esp32_devkitc_wrover/Kconfig.defconfig\n@@ -5,10 +5,7 @@ if BOARD_ESP32_DEVKITC_WROVER_ESP32_PROCPU\n \n config HEAP_MEM_POOL_ADD_SIZE_BOARD\n \tint\n-\tdefault 65535 if WIFI && BT\n-\tdefault 51200 if WIFI\n-\tdefault 40960 if BT\n-\tdefault 4096\n+\tdefault 8192\n \n endif # BOARD_ESP32_DEVKITC_WROVER_ESP32_PROCPU\n \ndiff --git a/boards/espressif/esp32_ethernet_kit/Kconfig.defconfig b/boards/espressif/esp32_ethernet_kit/Kconfig.defconfig\nindex 75b0cc9f631..b3e17cd8c4e 100644\n--- a/boards/espressif/esp32_ethernet_kit/Kconfig.defconfig\n+++ b/boards/espressif/esp32_ethernet_kit/Kconfig.defconfig\n@@ -14,10 +14,7 @@ endchoice\n \n config HEAP_MEM_POOL_ADD_SIZE_BOARD\n \tint\n-\tdefault 65535 if WIFI && BT\n-\tdefault 51200 if WIFI\n-\tdefault 40960 if BT\n-\tdefault 4096\n+\tdefault 8192\n \n endif # BOARD_ESP32_ETHERNET_KIT_ESP32_PROCPU\n \ndiff --git a/boards/espressif/esp32c3_devkitc/Kconfig.defconfig b/boards/espressif/esp32c3_devkitc/Kconfig.defconfig\nindex 2e71f23c2d7..aa8bed9c1e2 100644\n--- a/boards/espressif/esp32c3_devkitc/Kconfig.defconfig\n+++ b/boards/espressif/esp32c3_devkitc/Kconfig.defconfig\n@@ -5,7 +5,4 @@\n \n config HEAP_MEM_POOL_ADD_SIZE_BOARD\n \tint\n-\tdefault 65535 if WIFI && BT\n-\tdefault 51200 if WIFI\n-\tdefault 40960 if BT\n-\tdefault 4096\n+\tdefault 8192\ndiff --git a/boards/espressif/esp32s2_devkitc/Kconfig.defconfig b/boards/espressif/esp32s2_devkitc/Kconfig.defconfig\nindex 03bfd65b195..e4ef6b1c24a 100644\n--- a/boards/espressif/esp32s2_devkitc/Kconfig.defconfig\n+++ b/boards/espressif/esp32s2_devkitc/Kconfig.defconfig\n@@ -8,5 +8,4 @@ config ENTROPY_GENERATOR\n \n config HEAP_MEM_POOL_ADD_SIZE_BOARD\n \tint\n-\tdefault 32768 if WIFI\n-\tdefault 4096\n+\tdefault 8192\ndiff --git a/boards/espressif/esp32s2_devkitc/esp32s2_devkitc_defconfig b/boards/espressif/esp32s2_devkitc/esp32s2_devkitc_defconfig\nindex 5476839e2ba..f029cac9e9e 100644\n--- a/boards/espressif/esp32s2_devkitc/esp32s2_devkitc_defconfig\n+++ b/boards/espressif/esp32s2_devkitc/esp32s2_devkitc_defconfig\n@@ -1,6 +1,5 @@\n # SPDX-License-Identifier: Apache-2.0\n \n-\n CONFIG_MAIN_STACK_SIZE=2048\n \n CONFIG_CONSOLE=y\ndiff --git a/boards/espressif/esp32s2_saola/Kconfig.defconfig b/boards/espressif/esp32s2_saola/Kconfig.defconfig\nindex 5beaa3e15b1..2126b0a5979 100644\n--- a/boards/espressif/esp32s2_saola/Kconfig.defconfig\n+++ b/boards/espressif/esp32s2_saola/Kconfig.defconfig\n@@ -8,5 +8,4 @@ config ENTROPY_GENERATOR\n \n config HEAP_MEM_POOL_ADD_SIZE_BOARD\n \tint\n-\tdefault 32768 if WIFI\n-\tdefault 4096\n+\tdefault 8192\ndiff --git a/boards/espressif/esp32s3_devkitc/Kconfig.defconfig b/boards/espressif/esp32s3_devkitc/Kconfig.defconfig\nindex d539cd66523..80ccffe84ff 100644\n--- a/boards/espressif/esp32s3_devkitc/Kconfig.defconfig\n+++ b/boards/espressif/esp32s3_devkitc/Kconfig.defconfig\n@@ -7,9 +7,6 @@ if BOARD_ESP32S3_DEVKITC_ESP32S3_PROCPU\n \n config HEAP_MEM_POOL_ADD_SIZE_BOARD\n \tint\n-\tdefault 65535 if WIFI && BT\n-\tdefault 51200 if WIFI\n-\tdefault 40960 if BT\n \tdefault 4096\n \n endif # BOARD_ESP32S3_DEVKITC_ESP32S3_PROCPU\ndiff --git a/boards/espressif/esp32s3_devkitm/Kconfig.defconfig b/boards/espressif/esp32s3_devkitm/Kconfig.defconfig\nindex 26339590ee3..5438681fcdf 100644\n--- a/boards/espressif/esp32s3_devkitm/Kconfig.defconfig\n+++ b/boards/espressif/esp32s3_devkitm/Kconfig.defconfig\n@@ -7,9 +7,6 @@ if BOARD_ESP32S3_DEVKITM_ESP32S3_PROCPU\n \n config HEAP_MEM_POOL_ADD_SIZE_BOARD\n \tint\n-\tdefault 65535 if WIFI && BT\n-\tdefault 51200 if WIFI\n-\tdefault 40960 if BT\n \tdefault 4096\n \n endif # BOARD_ESP32S3_DEVKITM_ESP32S3_PROCPU\ndiff --git a/boards/espressif/esp8684_devkitm/Kconfig.defconfig b/boards/espressif/esp8684_devkitm/Kconfig.defconfig\nindex 60266dd5fd8..1d2813b0bc1 100644\n--- a/boards/espressif/esp8684_devkitm/Kconfig.defconfig\n+++ b/boards/espressif/esp8684_devkitm/Kconfig.defconfig\n@@ -5,7 +5,4 @@\n \n config HEAP_MEM_POOL_ADD_SIZE_BOARD\n \tint\n-\tdefault 65535 if WIFI && BT\n-\tdefault 51200 if WIFI\n-\tdefault 40960 if BT\n-\tdefault 4096\n+\tdefault 8192\ndiff --git a/boards/espressif/esp_wrover_kit/Kconfig.defconfig b/boards/espressif/esp_wrover_kit/Kconfig.defconfig\nindex adf8cd7e398..84228983f4e 100644\n--- a/boards/espressif/esp_wrover_kit/Kconfig.defconfig\n+++ b/boards/espressif/esp_wrover_kit/Kconfig.defconfig\n@@ -7,10 +7,7 @@ if BOARD_ESP_WROVER_KIT_ESP32_PROCPU\n \n config HEAP_MEM_POOL_ADD_SIZE_BOARD\n \tint\n-\tdefault 65535 if WIFI && BT\n-\tdefault 51200 if WIFI\n-\tdefault 40960 if BT\n-\tdefault 4096\n+\tdefault 8192\n \n config DISK_DRIVER_SDMMC\n \tdefault y"
},{
  "instruction": "soc: esp32c6: Add runtime heap symbols",
  "input": " ASSERT(((__bss_end - ORIGIN(sram0_0_seg)) <= LENGTH(sram0_0_seg)), \"DRAM segment data does not fit.\")\n#define DRAM_STACK_START         0x4087c610\n#define BOOTLOADER_IRAM_LOADER_SEG_START\t\\\n\t\t(BOOTLOADER_USER_SRAM_END -\tBOOTLOADER_IRAM_LOADER_SEG_LEN)",
  "result": "diff --git a/soc/espressif/esp32c6/default.ld b/soc/espressif/esp32c6/default.ld\nindex 52fcf69732f..45c762e8e73 100644\n--- a/soc/espressif/esp32c6/default.ld\n+++ b/soc/espressif/esp32c6/default.ld\n@@ -93,6 +93,8 @@ REGION_ALIAS(\"rtc_reserved_seg\", lp_reserved_seg );\n /*  Default entry point:  */\n ENTRY(CONFIG_KERNEL_ENTRY)\n \n+_heap_sentry = DRAM_RESERVED_START;\n+\n SECTIONS\n {\n #ifdef CONFIG_BOOTLOADER_MCUBOOT\n@@ -651,7 +653,7 @@ SECTIONS\n   _image_ram_start = _iram_start;\n   #include <zephyr/linker/ram-end.ld>\n \n-  ASSERT(((__bss_end - ORIGIN(sram0_0_seg)) <= LENGTH(sram0_0_seg)), \"DRAM segment data does not fit.\")\n+  ASSERT(((_end - ORIGIN(sram0_0_seg)) <= LENGTH(sram0_0_seg)), \"SRAM code/data does not fit.\")\n \n   /* --- END OF DRAM --- */\n \ndiff --git a/soc/espressif/esp32c6/memory.h b/soc/espressif/esp32c6/memory.h\nindex 500325545f0..496ea78b73e 100644\n--- a/soc/espressif/esp32c6/memory.h\n+++ b/soc/espressif/esp32c6/memory.h\n@@ -28,9 +28,13 @@\n  */\n \n #define DRAM_BUFFERS_START       0x4086ad08\n-#define DRAM_STACK_START         0x4087c610\n+#define DRAM_BUFFERS_END         0x4087c610\n+#define DRAM_STACK_START         DRAM_BUFFERS_END\n #define DRAM_ROM_BSS_DATA_START  0x4087e610\n \n+/* Set the limit for the application runtime dynamic allocations */\n+#define DRAM_RESERVED_START      DRAM_BUFFERS_END\n+\n /* For safety margin between bootloader data section and startup stacks */\n #define BOOTLOADER_STACK_OVERHEAD      0x0\n /* These lengths can be adjusted, if necessary: FIXME: optimize ram usage */\n@@ -44,8 +48,7 @@\n #define BOOTLOADER_USER_SRAM_END (DRAM_BUFFERS_START - BOOTLOADER_STACK_OVERHEAD)\n \n /* Start of the lower region is determined by region size and the end of the higher region */\n-#define BOOTLOADER_IRAM_LOADER_SEG_START\t\\\n-\t\t(BOOTLOADER_USER_SRAM_END -\tBOOTLOADER_IRAM_LOADER_SEG_LEN)\n+#define BOOTLOADER_IRAM_LOADER_SEG_START (BOOTLOADER_USER_SRAM_END - BOOTLOADER_IRAM_LOADER_SEG_LEN)\n #define BOOTLOADER_IRAM_SEG_START (BOOTLOADER_IRAM_LOADER_SEG_START - BOOTLOADER_IRAM_SEG_LEN)\n #define BOOTLOADER_DRAM_SEG_START (BOOTLOADER_IRAM_SEG_START - BOOTLOADER_DRAM_SEG_LEN)\n "
},{
  "instruction": "soc: esp32c2: ESP WiFi heap",
  "input": " ASSERT(((__bss_end - ORIGIN(dram0_0_seg)) <= LENGTH(dram0_0_seg)), \"DRAM segment data does not fit.\")\n*  - 0x3fccae00 - 0x3fcdc710: Shared buffers, used in UART/USB/SPI download mode only\n*  - 0x3fcdc710 - 0x3fcde710: PRO CPU stack, can be reclaimed as heap after RTOS startup\n*  - 0x3fcde710 - 0x3fce0000: ROM .bss and .data (not easily reclaimable)\n*  buffers area (0x3fcdc710).\n#define IRAM_DRAM_OFFSET         SRAM1_IRAM_START - SRAM1_DRAM_START\n#define DRAM_BUFFERS_START       0x3fccae00\n#define DRAM_STACK_START         0x3fcdc710\n#define DRAM_ROM_BSS_DATA_START  0x3fcde710\n/* Base address used for calculating memory layout\n* counted from Dbus backwards and back to the Ibus\n*/\n#define BOOTLOADER_USER_DRAM_END DRAM_BUFFERS_START\n#define BOOTLOADER_DRAM_SEG_LEN        0x9800\n#define BOOTLOADER_IRAM_SEG_LEN        0x9800\n#define BOOTLOADER_IRAM_LOADER_SEG_END (BOOTLOADER_USER_DRAM_END + \\\n\t\t\t\t\tBOOTLOADER_STACK_OVERHEAD + IRAM_DRAM_OFFSET)\n#define BOOTLOADER_IRAM_LOADER_SEG_START (BOOTLOADER_IRAM_LOADER_SEG_END - \\\n\t\t\t\t\tBOOTLOADER_IRAM_LOADER_SEG_LEN)\n#define BOOTLOADER_IRAM_SEG_START (BOOTLOADER_IRAM_LOADER_SEG_START - BOOTLOADER_IRAM_SEG_LEN)\n#define BOOTLOADER_DRAM_SEG_START (BOOTLOADER_IRAM_SEG_START - IRAM_DRAM_OFFSET - \\\n\t\t\t\t\tBOOTLOADER_DRAM_SEG_LEN)",
  "result": "diff --git a/soc/espressif/esp32c2/default.ld b/soc/espressif/esp32c2/default.ld\nindex 38f43b1edff..bb7dea04924 100644\n--- a/soc/espressif/esp32c2/default.ld\n+++ b/soc/espressif/esp32c2/default.ld\n@@ -85,6 +85,9 @@ _rom_store_table = 0;\n \n _iram_dram_offset = IRAM_DRAM_OFFSET;\n \n+/* Used as a pointer to the heap end */\n+_heap_sentry = DRAM_RESERVED_START;\n+\n SECTIONS\n {\n #ifdef CONFIG_BOOTLOADER_MCUBOOT\n@@ -585,7 +588,7 @@ SECTIONS\n   _image_ram_start = _iram_start - IRAM_DRAM_OFFSET;\n   #include <zephyr/linker/ram-end.ld>\n \n-  ASSERT(((__bss_end - ORIGIN(dram0_0_seg)) <= LENGTH(dram0_0_seg)), \"DRAM segment data does not fit.\")\n+  ASSERT(((_end - ORIGIN(dram0_0_seg)) <= LENGTH(dram0_0_seg)), \"SRAM code/data does not fit.\")\n \n   /* --- END OF DRAM --- */\n \ndiff --git a/soc/espressif/esp32c2/memory.h b/soc/espressif/esp32c2/memory.h\nindex 2ff56374bc0..c9ca4b55574 100644\n--- a/soc/espressif/esp32c2/memory.h\n+++ b/soc/espressif/esp32c2/memory.h\n@@ -7,9 +7,12 @@\n /* SRAM0 (16kB) memory */\n #define SRAM0_IRAM_START   0x4037c000\n #define SRAM0_SIZE         0x4000\n+\n /* SRAM1 (256kB) memory */\n #define SRAM1_DRAM_START   0x3fca0000\n #define SRAM1_IRAM_START   0x40380000\n+#define SRAM1_SIZE         0x40000\n+\n /* ICache size is fixed to 16KB on ESP32-C2 */\n #define ICACHE_SIZE        SRAM0_SIZE\n \n@@ -17,42 +20,44 @@\n  *  Make sure the bootloader can load into main memory without overwriting itself.\n  *\n  *  ESP32-C2 ROM static data usage is as follows:\n- *  - 0x3fccae00 - 0x3fcdc710: Shared buffers, used in UART/USB/SPI download mode only\n- *  - 0x3fcdc710 - 0x3fcde710: PRO CPU stack, can be reclaimed as heap after RTOS startup\n- *  - 0x3fcde710 - 0x3fce0000: ROM .bss and .data (not easily reclaimable)\n+ *  - 0x3fccb264 - 0x3fcdcb70: Shared buffers, used in UART/USB/SPI download mode only\n+ *  - 0x3fcdcb70 - 0x3fcdeb70: PRO CPU stack, can be reclaimed as heap after RTOS startup\n+ *  - 0x3fcdeb70 - 0x3fce0000: ROM .bss and .data (not easily reclaimable)\n  *\n  *  The 2nd stage bootloader can take space up to the end of ROM shared\n- *  buffers area (0x3fcdc710).\n+ *  buffers area (0x3fcdcb70).\n  */\n \n /* The offset between Dbus and Ibus.\n  * Used to convert between 0x403xxxxx and 0x3fcxxxxx addresses.\n  */\n-#define IRAM_DRAM_OFFSET         SRAM1_IRAM_START - SRAM1_DRAM_START\n-#define DRAM_BUFFERS_START       0x3fccae00\n-#define DRAM_STACK_START         0x3fcdc710\n-#define DRAM_ROM_BSS_DATA_START  0x3fcde710\n+#define IRAM_DRAM_OFFSET         0x6e0000\n \n-/* Base address used for calculating memory layout\n- * counted from Dbus backwards and back to the Ibus\n- */\n-#define BOOTLOADER_USER_DRAM_END DRAM_BUFFERS_START\n+#define DRAM_BUFFERS_START       0x3fccb264\n+#define DRAM_STACK_START         0x3fcdcb70\n+#define DRAM_ROM_BSS_DATA_START  0x3fcdeb70\n+\n+#define DRAM_RESERVED_START      DRAM_STACK_START\n \n /* For safety margin between bootloader data section and startup stacks */\n #define BOOTLOADER_STACK_OVERHEAD      0x0\n /* These lengths can be adjusted, if necessary: */\n-#define BOOTLOADER_DRAM_SEG_LEN        0x9800\n-#define BOOTLOADER_IRAM_SEG_LEN        0x9800\n+#define BOOTLOADER_DRAM_SEG_LEN        0xb000\n+#define BOOTLOADER_IRAM_SEG_LEN        0xc800\n #define BOOTLOADER_IRAM_LOADER_SEG_LEN 0x1400\n \n+/* Base address used for calculating memory layout\n+ * counted from Dbus backwards and back to the Ibus\n+ */\n+#define BOOTLOADER_USER_DRAM_END (DRAM_BUFFERS_START + BOOTLOADER_STACK_OVERHEAD)\n+\n /* Start of the lower region is determined by region size and the end of the higher region */\n-#define BOOTLOADER_IRAM_LOADER_SEG_END (BOOTLOADER_USER_DRAM_END + \\\n-\t\t\t\t\tBOOTLOADER_STACK_OVERHEAD + IRAM_DRAM_OFFSET)\n-#define BOOTLOADER_IRAM_LOADER_SEG_START (BOOTLOADER_IRAM_LOADER_SEG_END - \\\n-\t\t\t\t\tBOOTLOADER_IRAM_LOADER_SEG_LEN)\n-#define BOOTLOADER_IRAM_SEG_START (BOOTLOADER_IRAM_LOADER_SEG_START - BOOTLOADER_IRAM_SEG_LEN)\n-#define BOOTLOADER_DRAM_SEG_START (BOOTLOADER_IRAM_SEG_START - IRAM_DRAM_OFFSET - \\\n-\t\t\t\t\tBOOTLOADER_DRAM_SEG_LEN)\n+#define BOOTLOADER_IRAM_LOADER_SEG_START \\\n+\t(BOOTLOADER_USER_DRAM_END - BOOTLOADER_IRAM_LOADER_SEG_LEN + IRAM_DRAM_OFFSET)\n+#define BOOTLOADER_IRAM_SEG_START \\\n+\t(BOOTLOADER_IRAM_LOADER_SEG_START - BOOTLOADER_IRAM_SEG_LEN)\n+#define BOOTLOADER_DRAM_SEG_START \\\n+\t(BOOTLOADER_IRAM_SEG_START - BOOTLOADER_DRAM_SEG_LEN - IRAM_DRAM_OFFSET)\n \n /* Flash */\n #ifdef CONFIG_FLASH_SIZE"
},{
  "instruction": "soc: esp32c3: ESP WiFi heap",
  "input": " ASSERT(((__bss_end - ORIGIN(dram0_0_seg)) <= LENGTH(dram0_0_seg)), \"DRAM segment data does not fit.\")\n#define BOOTLOADER_IRAM_LOADER_SEG_END (BOOTLOADER_USER_DRAM_END + \\\n\t\t\t\t\tBOOTLOADER_STACK_OVERHEAD + IRAM_DRAM_OFFSET)\n#define BOOTLOADER_IRAM_LOADER_SEG_START (BOOTLOADER_IRAM_LOADER_SEG_END - \\\n\t\t\t\t\tBOOTLOADER_IRAM_LOADER_SEG_LEN)\n#define BOOTLOADER_IRAM_SEG_START (BOOTLOADER_IRAM_LOADER_SEG_START - BOOTLOADER_IRAM_SEG_LEN)\n#define BOOTLOADER_DRAM_SEG_START (BOOTLOADER_IRAM_SEG_START - IRAM_DRAM_OFFSET - \\\n\t\t\t\t\tBOOTLOADER_DRAM_SEG_LEN)",
  "result": "diff --git a/soc/espressif/esp32c3/default.ld b/soc/espressif/esp32c3/default.ld\nindex bbb992fcf6f..2d07480c06e 100644\n--- a/soc/espressif/esp32c3/default.ld\n+++ b/soc/espressif/esp32c3/default.ld\n@@ -93,6 +93,9 @@ _rom_store_table = 0;\n \n _iram_dram_offset = IRAM_DRAM_OFFSET;\n \n+/* Stack sentry */\n+_heap_sentry = DRAM_RESERVED_START;\n+\n SECTIONS\n {\n #ifdef CONFIG_BOOTLOADER_MCUBOOT\n@@ -651,7 +654,7 @@ SECTIONS\n   _image_ram_start = _iram_start - IRAM_DRAM_OFFSET;\n   #include <zephyr/linker/ram-end.ld>\n \n-  ASSERT(((__bss_end - ORIGIN(dram0_0_seg)) <= LENGTH(dram0_0_seg)), \"DRAM segment data does not fit.\")\n+  ASSERT(((_end - ORIGIN(dram0_0_seg)) <= LENGTH(dram0_0_seg)), \"SRAM instruction/data does not fit.\")\n \n   /* --- END OF DRAM --- */\n \ndiff --git a/soc/espressif/esp32c3/memory.h b/soc/espressif/esp32c3/memory.h\nindex 297735a5f5c..97b2068bb45 100644\n--- a/soc/espressif/esp32c3/memory.h\n+++ b/soc/espressif/esp32c3/memory.h\n@@ -10,6 +10,7 @@\n /* SRAM1 (384kB) memory */\n #define SRAM1_DRAM_START   0x3fc80000\n #define SRAM1_IRAM_START   0x40380000\n+#define SRAM1_SIZE         0x60000\n /* ICache size is fixed to 16KB on ESP32-C3 */\n #define ICACHE_SIZE        SRAM0_SIZE\n \n@@ -30,9 +31,13 @@\n  */\n #define IRAM_DRAM_OFFSET         0x700000\n #define DRAM_BUFFERS_START       0x3fccae00\n+#define DRAM_BUFFERS_END         0x3fccc000\n #define DRAM_STACK_START         0x3fcdc710\n #define DRAM_ROM_BSS_DATA_START  0x3fcde710\n \n+/* Set the limit for the application runtime dynamic allocations */\n+#define DRAM_RESERVED_START      DRAM_BUFFERS_END\n+\n /* Base address used for calculating memory layout\n  * counted from Dbus backwards and back to the Ibus\n  */\n@@ -46,13 +51,14 @@\n #define BOOTLOADER_IRAM_LOADER_SEG_LEN 0x1400\n \n /* Start of the lower region is determined by region size and the end of the higher region */\n-#define BOOTLOADER_IRAM_LOADER_SEG_END (BOOTLOADER_USER_DRAM_END + \\\n-\t\t\t\t\tBOOTLOADER_STACK_OVERHEAD + IRAM_DRAM_OFFSET)\n-#define BOOTLOADER_IRAM_LOADER_SEG_START (BOOTLOADER_IRAM_LOADER_SEG_END - \\\n-\t\t\t\t\tBOOTLOADER_IRAM_LOADER_SEG_LEN)\n-#define BOOTLOADER_IRAM_SEG_START (BOOTLOADER_IRAM_LOADER_SEG_START - BOOTLOADER_IRAM_SEG_LEN)\n-#define BOOTLOADER_DRAM_SEG_START (BOOTLOADER_IRAM_SEG_START - IRAM_DRAM_OFFSET - \\\n-\t\t\t\t\tBOOTLOADER_DRAM_SEG_LEN)\n+#define BOOTLOADER_IRAM_LOADER_SEG_END \\\n+\t\t(BOOTLOADER_USER_DRAM_END + BOOTLOADER_STACK_OVERHEAD + IRAM_DRAM_OFFSET)\n+#define BOOTLOADER_IRAM_LOADER_SEG_START \\\n+\t\t(BOOTLOADER_IRAM_LOADER_SEG_END - BOOTLOADER_IRAM_LOADER_SEG_LEN)\n+#define BOOTLOADER_IRAM_SEG_START \\\n+\t\t(BOOTLOADER_IRAM_LOADER_SEG_START - BOOTLOADER_IRAM_SEG_LEN)\n+#define BOOTLOADER_DRAM_SEG_START \\\n+\t\t(BOOTLOADER_IRAM_SEG_START - IRAM_DRAM_OFFSET - BOOTLOADER_DRAM_SEG_LEN)\n \n /* Flash */\n #ifdef CONFIG_FLASH_SIZE"
},{
  "instruction": "soc: esp32s3: ESP WiFi heap",
  "input": "_heap_sentry = DRAM_BUFFERS_START;\n .dram0.noinit (NOLOAD):\n {\n   . = ALIGN(4);\n   *(.noinit)\n   *(.noinit.*)\n   . = ALIGN(4) ;\n } GROUP_LINK_IN(RAMABLE_REGION)\n .dram0.heap_start (NOLOAD) :\n   . = ALIGN (8);\n   /* Lowest possible start address for the heap */\n   _heap_start = ABSOLUTE(.);\n ASSERT(((__bss_end - ORIGIN(dram0_0_seg)) <= LENGTH(dram0_0_seg)), \"DRAM segment data does not fit.\")\nASSERT(((_iram_end - ORIGIN(iram0_0_seg)) <= LENGTH(iram0_0_seg)),\n         \"IRAM0 segment data does not fit.\")\nASSERT(((_heap_start - ORIGIN(dram0_0_seg)) <= LENGTH(dram0_0_seg)),\n         \"DRAM segment data does not fit.\")\n   _end = ABSOLUTE(.);\n   _heap_sentry = .;\n\t. = ALIGN(4);",
  "result": "diff --git a/soc/espressif/esp32s3/default.ld b/soc/espressif/esp32s3/default.ld\nindex 7806ab16441..6b9c0ccbc66 100644\n--- a/soc/espressif/esp32s3/default.ld\n+++ b/soc/espressif/esp32s3/default.ld\n@@ -101,7 +101,7 @@ MEMORY\n ENTRY(CONFIG_KERNEL_ENTRY)\n \n /* Used as a pointer to the heap end */\n-_heap_sentry = DRAM_BUFFERS_START;\n+_heap_sentry = DRAM_RESERVED_START;\n \n SECTIONS\n {\n@@ -689,14 +689,6 @@ SECTIONS\n     _data_end = ABSOLUTE(.);\n   } GROUP_DATA_LINK_IN(RAMABLE_REGION, ROMABLE_REGION)\n \n-  .dram0.noinit (NOLOAD):\n-  {\n-    . = ALIGN(4);\n-    *(.noinit)\n-    *(.noinit.*)\n-    . = ALIGN(4) ;\n-  } GROUP_LINK_IN(RAMABLE_REGION)\n-\n   /* Shared RAM */\n   .dram0.bss (NOLOAD) :\n   {\n@@ -729,18 +721,19 @@ SECTIONS\n     __bss_end = ABSOLUTE(.);\n   } GROUP_LINK_IN(RAMABLE_REGION)\n \n-  .dram0.heap_start (NOLOAD) :\n+  .dram0.noinit (NOLOAD):\n   {\n-    . = ALIGN (8);\n-    /* Lowest possible start address for the heap */\n-    _heap_start = ABSOLUTE(.);\n+    . = ALIGN(4);\n+    *(.noinit)\n+    *(.noinit.*)\n+    . = ALIGN(4) ;\n   } GROUP_LINK_IN(RAMABLE_REGION)\n \n   /* Provide total SRAM usage, including IRAM and DRAM */\n   _image_ram_start = _iram_start - IRAM_DRAM_OFFSET;\n   #include <zephyr/linker/ram-end.ld>\n \n-  ASSERT(((__bss_end - ORIGIN(dram0_0_seg)) <= LENGTH(dram0_0_seg)), \"DRAM segment data does not fit.\")\n+  ASSERT(((_end - ORIGIN(dram0_0_seg)) <= LENGTH(dram0_0_seg)), \"DRAM segment data does not fit.\")\n \n   /* --- END OF DRAM --- */\n \n@@ -906,6 +899,7 @@ SECTIONS\n \n #endif /* CONFIG_ESP_SPIRAM */\n \n+  /* --- XTENSA GLUE AND DEBUG BEGIN --- */\n \n #ifdef CONFIG_GEN_ISR_TABLES\n #include <zephyr/linker/intlist.ld>\n@@ -949,11 +943,7 @@ SECTIONS\n \n }\n \n-ASSERT(((_iram_end - ORIGIN(iram0_0_seg)) <= LENGTH(iram0_0_seg)),\n-          \"IRAM0 segment data does not fit.\")\n-\n-ASSERT(((_heap_start - ORIGIN(dram0_0_seg)) <= LENGTH(dram0_0_seg)),\n-          \"DRAM segment data does not fit.\")\n+  /* --- XTENSA GLUE AND DEBUG END --- */\n \n #if defined(CONFIG_ESP_SPIRAM)\n ASSERT(((_ext_ram_bss_end - _ext_ram_bss_start) <= CONFIG_ESP_SPIRAM_SIZE),\ndiff --git a/soc/espressif/esp32s3/default_appcpu.ld b/soc/espressif/esp32s3/default_appcpu.ld\nindex bfdaefac078..4641540db75 100644\n--- a/soc/espressif/esp32s3/default_appcpu.ld\n+++ b/soc/espressif/esp32s3/default_appcpu.ld\n@@ -12,6 +12,8 @@\n #define SRAM_DIRAM_I_START  0x40378000\n #define SRAM_IRAM_END       0x403BA000\n #define I_D_SRAM_OFFSET     (SRAM_DIRAM_I_START - SRAM_DRAM_START)\n+#define DRAM_RESERVED_START 0x3fce9704\n+#define IRAM_DRAM_OFFSET    0x6f0000\n \n #define SRAM_DRAM_START     0x3FC88000\n #define SRAM_DRAM_END       (SRAM_IRAM_END - I_D_SRAM_OFFSET)\n@@ -34,6 +36,9 @@ MEMORY\n /*  Default entry point:  */\n ENTRY(__app_cpu_start)\n \n+/* Used as a pointer to the heap end */\n+_heap_sentry = DRAM_RESERVED_START;\n+\n SECTIONS\n {\n   #include <zephyr/linker/rel-sections.ld>\n@@ -259,9 +264,6 @@ SECTIONS\n     #include <snippets-rwdata.ld>\n \n     . = ALIGN(4);\n-    _end = ABSOLUTE(.);\n-    _heap_sentry = .;\n-\t. = ALIGN(4);\n     __data_end = ABSOLUTE(.);\n   } GROUP_DATA_LINK_IN(RAMABLE_REGION, IRAM_REGION)\n \n@@ -290,6 +292,10 @@ SECTIONS\n     __bss_end = ABSOLUTE(.);\n   } GROUP_LINK_IN(RAMABLE_REGION)\n \n+  /* Provide total SRAM usage, including IRAM and DRAM */\n+  _image_ram_start = _iram_start - IRAM_DRAM_OFFSET;\n+  #include <zephyr/linker/ram-end.ld>\n+\n   ASSERT(((__bss_end - ORIGIN(dram0_0_seg)) <= LENGTH(dram0_0_seg)), \"DRAM segment data does not fit.\")\n \n   SECTION_DATA_PROLOGUE(_NOINIT_SECTION_NAME, (NOLOAD),)\ndiff --git a/soc/espressif/esp32s3/memory.h b/soc/espressif/esp32s3/memory.h\nindex 01dfc69fe7d..7df7f26bccb 100644\n--- a/soc/espressif/esp32s3/memory.h\n+++ b/soc/espressif/esp32s3/memory.h\n@@ -33,11 +33,15 @@\n  */\n #define IRAM_DRAM_OFFSET         0x6f0000\n #define DRAM_BUFFERS_START       0x3fcd7e00\n+#define DRAM_BUFFERS_END         0x3fce9704\n #define DRAM_PROCPU_STACK_START  0x3fce9710\n #define DRAM_STACK_START DRAM_PROCPU_STACK_START\n #define DRAM_APPCPU_STACK_START  0x3fceb710\n #define DRAM_ROM_BSS_DATA_START  0x3fcf0000\n \n+/* Set the limit for the application runtime dynamic allocations */\n+#define DRAM_RESERVED_START      DRAM_BUFFERS_END\n+\n /* Base address used for calculating memory layout\n  * counted from Dbus backwards and back to the Ibus\n  */"
},{
  "instruction": "soc: esp32s2: ESP WiFi heap",
  "input": "user_iram_seg_org = (SRAM_IRAM_START + SRAM_CACHE_SIZE);\nuser_dram_seg_org = (SRAM_DRAM_START + SRAM_CACHE_SIZE);\nuser_dram_end = (user_iram_end - IRAM_DRAM_OFFSET);\nuser_idram_size = (user_dram_end - user_dram_seg_org);\nuser_iram_seg_len = user_idram_size;\nuser_dram_seg_len = user_idram_size;\n_heap_sentry = DRAM_BUFFERS_START;\n   . = ALIGN(8);\n   . = ALIGN(8);\n ASSERT(((__bss_end - ORIGIN(dram0_0_seg)) <= LENGTH(dram0_0_seg)), \"DRAM segment data does not fit.\")\nASSERT(((__bss_end - ORIGIN(dram0_0_seg)) <= LENGTH(dram0_0_seg)),\n         \"DRAM0 segment data does not fit.\")\nASSERT(((_iram_end - ORIGIN(iram0_0_seg)) <= LENGTH(iram0_0_seg)),\n         \"IRAM0 segment data does not fit.\")\n#define SRAM_CACHE_SIZE  (CONFIG_ESP32S2_INSTRUCTION_CACHE_SIZE \\\n\t\t\t+ CONFIG_ESP32S2_DATA_CACHE_SIZE)\n#define DRAM_BUFFERS_START       0x3ffeab00\n#define DRAM_RESERVED_START      0x3ffec000\n#define DRAM_STACK_START         0x3fffc410\n#define BOOTLOADER_DRAM_SEG_LEN        0x7000\n#define BOOTLOADER_USER_DRAM_END (DRAM_RESERVED_START - BOOTLOADER_STACK_OVERHEAD)\n#define BOOTLOADER_IRAM_LOADER_SEG_START (BOOTLOADER_USER_DRAM_END + IRAM_DRAM_OFFSET \\\n\t\t\t\t\t- BOOTLOADER_IRAM_LOADER_SEG_LEN)\n#define BOOTLOADER_DRAM_SEG_START (BOOTLOADER_IRAM_LOADER_SEG_START - BOOTLOADER_DRAM_SEG_LEN \\\n\t\t\t\t\t- IRAM_DRAM_OFFSET)\n#define BOOTLOADER_IRAM_SEG_START (BOOTLOADER_DRAM_SEG_START - BOOTLOADER_IRAM_SEG_LEN \\\n\t\t\t\t\t+ IRAM_DRAM_OFFSET)",
  "result": "diff --git a/soc/espressif/esp32s2/default.ld b/soc/espressif/esp32s2/default.ld\nindex 30956a2d43c..4aac69804ac 100644\n--- a/soc/espressif/esp32s2/default.ld\n+++ b/soc/espressif/esp32s2/default.ld\n@@ -23,12 +23,12 @@ user_iram_end = BOOTLOADER_IRAM_LOADER_SEG_START;\n #endif\n \n /* User available SRAM memory segments */\n-user_iram_seg_org = (SRAM_IRAM_START + SRAM_CACHE_SIZE);\n-user_dram_seg_org = (SRAM_DRAM_START + SRAM_CACHE_SIZE);\n-user_dram_end = (user_iram_end - IRAM_DRAM_OFFSET);\n-user_idram_size = (user_dram_end - user_dram_seg_org);\n-user_iram_seg_len = user_idram_size;\n-user_dram_seg_len = user_idram_size;\n+user_iram_seg_org = SRAM_IRAM_START + SRAM_CACHE_SIZE;\n+user_dram_seg_org = SRAM_DRAM_START + SRAM_CACHE_SIZE;\n+user_dram_end = user_iram_end - IRAM_DRAM_OFFSET;\n+user_sram_size = (user_dram_end - user_dram_seg_org);\n+user_iram_seg_len = user_sram_size;\n+user_dram_seg_len = user_sram_size;\n \n /* Aliases */\n #define FLASH_CODE_REGION irom0_0_seg\n@@ -102,7 +102,7 @@ ENTRY(CONFIG_KERNEL_ENTRY)\n _rom_store_table = 0;\n \n /* Used as a pointer to the heap end */\n-_heap_sentry = DRAM_BUFFERS_START;\n+_heap_sentry = DRAM_RESERVED_START;\n \n SECTIONS\n {\n@@ -797,17 +797,17 @@ SECTIONS\n \n   .dram0.noinit (NOLOAD) :\n   {\n-    . = ALIGN(8);\n+    . = ALIGN(4);\n     *(.noinit)\n     *(.noinit.*)\n-    . = ALIGN(8);\n+    . = ALIGN(16);\n   } GROUP_LINK_IN(RAMABLE_REGION)\n \n   /* Provide total SRAM usage, including IRAM and DRAM */\n   _image_ram_start = _iram_start - IRAM_DRAM_OFFSET;\n   #include <zephyr/linker/ram-end.ld>\n \n-  ASSERT(((__bss_end - ORIGIN(dram0_0_seg)) <= LENGTH(dram0_0_seg)), \"DRAM segment data does not fit.\")\n+  ASSERT(((_end - ORIGIN(dram0_0_seg)) <= LENGTH(dram0_0_seg)), \"SRAM code/data does not fit.\")\n \n   /* --- END OF DRAM --- */\n \n@@ -946,6 +946,8 @@ SECTIONS\n \n   /* --- END OF .rodata --- */\n \n+  /* --- XTENSA GLUE AND DEBUG BEGIN --- */\n+\n #ifdef CONFIG_GEN_ISR_TABLES\n #include <zephyr/linker/intlist.ld>\n #endif\n@@ -987,11 +989,7 @@ SECTIONS\n   }\n }\n \n-ASSERT(((__bss_end - ORIGIN(dram0_0_seg)) <= LENGTH(dram0_0_seg)),\n-          \"DRAM0 segment data does not fit.\")\n-\n-ASSERT(((_iram_end - ORIGIN(iram0_0_seg)) <= LENGTH(iram0_0_seg)),\n-          \"IRAM0 segment data does not fit.\")\n+  /* --- XTENSA GLUE AND DEBUG END --- */\n \n #ifdef CONFIG_ESP_SPIRAM\n ASSERT(((_ext_ram_data_end - _ext_ram_data_start) <= CONFIG_ESP_SPIRAM_SIZE),\ndiff --git a/soc/espressif/esp32s2/memory.h b/soc/espressif/esp32s2/memory.h\nindex 4e2ae76cb2d..74a0f7f05fe 100644\n--- a/soc/espressif/esp32s2/memory.h\n+++ b/soc/espressif/esp32s2/memory.h\n@@ -9,8 +9,7 @@\n  */\n #define SRAM_IRAM_START  0x40020000\n #define SRAM_DRAM_START  0x3ffb0000\n-#define SRAM_CACHE_SIZE  (CONFIG_ESP32S2_INSTRUCTION_CACHE_SIZE \\\n-\t\t\t+ CONFIG_ESP32S2_DATA_CACHE_SIZE)\n+#define SRAM_CACHE_SIZE  (CONFIG_ESP32S2_INSTRUCTION_CACHE_SIZE + CONFIG_ESP32S2_DATA_CACHE_SIZE)\n \n /** Simplified memory map for the bootloader.\n  *  Make sure the bootloader can load into main memory without overwriting itself.\n@@ -28,29 +27,31 @@\n  * Used to convert between 0x4002xxxx and 0x3ffbxxxx addresses.\n  */\n #define IRAM_DRAM_OFFSET         0x70000\n-#define DRAM_BUFFERS_START       0x3ffeab00\n-#define DRAM_RESERVED_START      0x3ffec000\n-#define DRAM_STACK_START         0x3fffc410\n+#define DRAM_BUFFERS_START       0x3ffea400\n+#define DRAM_BUFFERS_END         0x3fffc410\n+#define DRAM_ROM_CPU_STACK_START 0x3fffc410\n #define DRAM_ROM_BSS_DATA_START  0x3fffe710\n \n /* For safety margin between bootloader data section and startup stacks */\n #define BOOTLOADER_STACK_OVERHEAD      0x0\n-#define BOOTLOADER_DRAM_SEG_LEN        0x7000\n+#define BOOTLOADER_DRAM_SEG_LEN        0x8000\n #define BOOTLOADER_IRAM_LOADER_SEG_LEN 0x3000\n #define BOOTLOADER_IRAM_SEG_LEN        0xa000\n \n+/* Set the limit for the application runtime dynamic allocations */\n+#define DRAM_RESERVED_START      DRAM_BUFFERS_END\n+\n /* Base address used for calculating memory layout\n  * counted from Dbus backwards and back to the Ibus\n  */\n-#define BOOTLOADER_USER_DRAM_END (DRAM_RESERVED_START - BOOTLOADER_STACK_OVERHEAD)\n+#define BOOTLOADER_USER_DRAM_END (DRAM_BUFFERS_START - BOOTLOADER_STACK_OVERHEAD)\n \n /* Start of the lower region is determined by region size and the end of the higher region */\n-#define BOOTLOADER_IRAM_LOADER_SEG_START (BOOTLOADER_USER_DRAM_END + IRAM_DRAM_OFFSET \\\n-\t\t\t\t\t- BOOTLOADER_IRAM_LOADER_SEG_LEN)\n-#define BOOTLOADER_DRAM_SEG_START (BOOTLOADER_IRAM_LOADER_SEG_START - BOOTLOADER_DRAM_SEG_LEN \\\n-\t\t\t\t\t- IRAM_DRAM_OFFSET)\n-#define BOOTLOADER_IRAM_SEG_START (BOOTLOADER_DRAM_SEG_START - BOOTLOADER_IRAM_SEG_LEN \\\n-\t\t\t\t\t+ IRAM_DRAM_OFFSET)\n+#define BOOTLOADER_IRAM_LOADER_SEG_START \\\n+\t(BOOTLOADER_USER_DRAM_END - BOOTLOADER_IRAM_LOADER_SEG_LEN + IRAM_DRAM_OFFSET)\n+#define BOOTLOADER_IRAM_SEG_START (BOOTLOADER_IRAM_LOADER_SEG_START - BOOTLOADER_IRAM_SEG_LEN)\n+#define BOOTLOADER_DRAM_SEG_START \\\n+\t(BOOTLOADER_IRAM_SEG_START - BOOTLOADER_DRAM_SEG_LEN - IRAM_DRAM_OFFSET)\n \n /* Flash */\n #ifdef CONFIG_FLASH_SIZE"
},{
  "instruction": "soc: esp32: ESP WiFi heap",
  "input": "user_dram_seg_len = SRAM2_USER_SIZE;\n#ifdef CONFIG_BT\n_heap_sentry = SRAM1_DRAM_USER_START;\n#else\n_heap_sentry = DRAM1_BT_SHM_BUFFERS_START; /* was 0x3ffe3f20; */\n#endif\n/*  TODO: optimize SRAM usage\n   *libzephyr.a:periph_ctrl.*(.literal.periph_module_reset .text.periph_module_reset)\n   *libzephyr.a:periph_ctrl.*(.literal.wifi_module_disable .text.wifi_module_disable)\n   *libzephyr.a:periph_ctrl.*(.literal.wifi_module_enable .text.wifi_module_enable)\n   *libzephyr.a:rtc_wdt.*(.literal .literal.* .text .text.*)\n*/\n   /* to overcome the bug in esptool making Simple boot compatible image */\n ASSERT(((__bss_end - ORIGIN(dram0_0_seg)) <= LENGTH(dram0_0_seg)),\n         \"DRAM segment data does not fit.\")\n .dram0.end (NOLOAD) :\n {\n   . = ALIGN(4);\n   _end = ABSOLUTE(.);\n } GROUP_DATA_LINK_IN(RAMABLE_REGION, ROMABLE_REGION)\n /* TODO: Provide total SRAM usage, including IRAM and DRAM */\n /* _image_ram_start = _iram_start - IRAM_DRAM_OFFSET; */\n /* #include <zephyr/linker/ram-end.ld> */\nASSERT(((_iram_end - ORIGIN(iram0_0_seg)) <= LENGTH(iram0_0_seg)),\n         \"IRAM0 segment data does not fit.\")\n   _end = ABSOLUTE(.);\n   _end = ABSOLUTE(.);\n_heap_sentry = 0x3ffe3f20;\n/* SRAM0 (64k+128k)  instruction cache+memory */\n/* SRAM1 (128k) instruction/data memory */\n#define SRAM1_DRAM_USER_START 0x3ffe5400\n/* SRAM2 (200k) data memory */\n#define SRAM2_DRAM_START    0x3ffae000\n#define SRAM2_SIZE          0x32000\n#define SRAM2_DRAM_SHM_PRIV_SIZE 0x2000\n#define SRAM2_DRAM_USER_START 0x3ffb0000\n#define SRAM2_USER_SIZE     (SRAM1_DRAM_START - SRAM2_DRAM_USER_START)\n/* Conversion beween IRAM and DRAM in SRAM1 memory */\n#define SRAM1_IRAM_DRAM_CALC(addr_iram) \\\n\t(SRAM1_SIZE - ((addr_iram) - SRAM1_IRAM_START) + SRAM1_DRAM_START)\n\t(SRAM1_SIZE - ((addr_dram) - SRAM1_DRAM_START) + SRAM1_IRAM_START)\n/* For safety margin between bootloader data section and startup stacks */\n#define BOOTLOADER_DRAM_SEG_START  0x3fff0000",
  "result": "diff --git a/soc/espressif/esp32/default.ld b/soc/espressif/esp32/default.ld\nindex 5a80d593c37..593c895d61e 100644\n--- a/soc/espressif/esp32/default.ld\n+++ b/soc/espressif/esp32/default.ld\n@@ -24,7 +24,7 @@ user_iram_end = SRAM1_DRAM_IRAM_CALC(SRAM1_DRAM_USER_START);\n user_iram_seg_org = (SRAM0_IRAM_START + SRAM0_CACHE_SIZE);\n user_iram_seg_len = user_iram_end - user_iram_seg_org;\n user_dram_seg_org = SRAM2_DRAM_USER_START;\n-user_dram_seg_len = SRAM2_USER_SIZE;\n+user_dram_seg_len = SRAM2_DRAM_USER_SIZE;\n user_dram_2_seg_org = SRAM1_DRAM_USER_START;\n user_dram_2_seg_len = SRAM1_USER_SIZE;\n \n@@ -116,11 +116,7 @@ _rom_store_table = 0;\n PROVIDE(_memmap_vecbase_reset = 0x40000450);\n PROVIDE(_memmap_reset_vector = 0x40000400);\n \n-#ifdef CONFIG_BT\n-_heap_sentry = SRAM1_DRAM_USER_START;\n-#else\n-_heap_sentry = DRAM1_BT_SHM_BUFFERS_START; /* was 0x3ffe3f20; */\n-#endif\n+_heap_sentry = SRAM2_DRAM_END;\n \n SECTIONS\n {\n@@ -357,12 +353,6 @@ SECTIONS\n     *libzephyr.a:periph_ctrl.*(.literal .text .literal.* .text.*)\n     *(.literal.sar_periph_ctrl_power_enable .text.sar_periph_ctrl_power_enable)\n \n-/*  TODO: optimize SRAM usage\n-    *libzephyr.a:periph_ctrl.*(.literal.periph_module_reset .text.periph_module_reset)\n-    *libzephyr.a:periph_ctrl.*(.literal.wifi_module_disable .text.wifi_module_disable)\n-    *libzephyr.a:periph_ctrl.*(.literal.wifi_module_enable .text.wifi_module_enable)\n-    *libzephyr.a:rtc_wdt.*(.literal .literal.* .text .text.*)\n-*/\n     *libzephyr.a:esp_system_chip.*(.literal.esp_system_abort .text.esp_system_abort)\n     *libzephyr.a:spi_hal_iram.*(.literal .literal.* .text .text.*)\n     *libzephyr.a:spi_slave_hal_iram.*(.literal .literal.* .text .text.*)\n@@ -453,7 +443,7 @@ SECTIONS\n     *libzephyr.a:mpu_hal.*(.literal .text .literal.* .text.*)\n     *libzephyr.a:cpu_region_protect.*(.literal .text .literal.* .text.*)\n \n-    /* to overcome the bug in esptool making Simple boot compatible image */\n+    /* NOTE: to overcome the bug in esptool making Simple boot compatible image */\n     . += 16;\n     . = ALIGN(16);\n   } GROUP_DATA_LINK_IN(IRAM_REGION, ROMABLE_REGION)\n@@ -488,6 +478,12 @@ SECTIONS\n     _iram_end = ABSOLUTE(.);\n   } GROUP_LINK_IN(IRAM_REGION)\n \n+  /* This symbol is here to check SRAM1 usage in case it is used for data too */\n+  _iram_end_at_dram_addr = SRAM1_IRAM_DRAM_CALC(_iram_end);\n+  _unallocated_iram_memory_size = ORIGIN(iram0_0_seg) + LENGTH(iram0_0_seg) - _iram_end;\n+\n+  ASSERT(((_iram_end - ORIGIN(iram0_0_seg)) <= LENGTH(iram0_0_seg)), \"IRAM code does not fit.\")\n+\n   /* --- IRAM END --- */\n \n   /* --- DRAM BEGIN --- */\n@@ -707,9 +703,6 @@ SECTIONS\n     _bss_end = ABSOLUTE(.);\n   } GROUP_LINK_IN(RAMABLE_REGION)\n \n-  ASSERT(((__bss_end - ORIGIN(dram0_0_seg)) <= LENGTH(dram0_0_seg)),\n-          \"DRAM segment data does not fit.\")\n-\n   .dram0.noinit (NOLOAD) :\n   {\n     . = ALIGN (8);\n@@ -718,15 +711,12 @@ SECTIONS\n     . = ALIGN (8);\n   } GROUP_LINK_IN(RAMABLE_REGION_1)\n \n-  .dram0.end (NOLOAD) :\n-  {\n-    . = ALIGN(4);\n-    _end = ABSOLUTE(.);\n-  } GROUP_DATA_LINK_IN(RAMABLE_REGION, ROMABLE_REGION)\n+  /* Provide total SRAM usage, including IRAM and DRAM */\n+  _image_ram_start = _dram_data_start;\n+  #include <zephyr/linker/ram-end.ld>\n+  _image_ram_size += _iram_end - _iram_start;\n \n-  /* TODO: Provide total SRAM usage, including IRAM and DRAM */\n-  /* _image_ram_start = _iram_start - IRAM_DRAM_OFFSET; */\n-  /* #include <zephyr/linker/ram-end.ld> */\n+  ASSERT(((_end - ORIGIN(dram0_0_seg)) <= LENGTH(dram0_0_seg)), \"DRAM data does not fit.\")\n \n   /* --- DRAM END --- */\n \n@@ -934,9 +924,6 @@ SECTIONS\n \n   /* --- XTENSA GLUE AND DEBUG END --- */\n \n-ASSERT(((_iram_end - ORIGIN(iram0_0_seg)) <= LENGTH(iram0_0_seg)),\n-          \"IRAM0 segment data does not fit.\")\n-\n #ifdef CONFIG_ESP_SPIRAM\n ASSERT(((_ext_ram_data_end - _ext_ram_data_start) <= CONFIG_ESP_SPIRAM_SIZE),\n           \"External SPIRAM overflowed.\")\ndiff --git a/soc/espressif/esp32/default_appcpu.ld b/soc/espressif/esp32/default_appcpu.ld\nindex 2fd38f3909e..145f23e6d71 100644\n--- a/soc/espressif/esp32/default_appcpu.ld\n+++ b/soc/espressif/esp32/default_appcpu.ld\n@@ -51,6 +51,8 @@ _rom_store_table = 0;\n PROVIDE(_memmap_vecbase_reset = 0x40000450);\n PROVIDE(_memmap_reset_vector = 0x40000400);\n \n+_heap_sentry = 0x3ffe3f20;\n+\n SECTIONS\n {\n #include <zephyr/linker/rel-sections.ld>\n@@ -285,9 +287,10 @@ SECTIONS\n   .dram0.end :\n   {\n     . = ALIGN(4);\n+\n     #include <snippets-rwdata.ld>\n+\n     . = ALIGN(4);\n-    _end = ABSOLUTE(.);\n     __data_end = ABSOLUTE(.);\n   } GROUP_DATA_LINK_IN(RAMABLE_REGION, ROMABLE_DATA_REGION)\n \n@@ -322,9 +325,13 @@ SECTIONS\n     *(COMMON)\n     . = ALIGN (8);\n     __bss_end = ABSOLUTE(.);\n-    _end = ABSOLUTE(.);\n   } GROUP_LINK_IN(RAMABLE_REGION)\n \n+  /* Provide total SRAM usage, including IRAM and DRAM */\n+  _image_ram_start = __rodata_region_start;\n+  #include <zephyr/linker/ram-end.ld>\n+  _image_ram_size += _iram_end - _iram_start;\n+\n   ASSERT(((__bss_end - ORIGIN(dram0_0_seg)) <= LENGTH(dram0_0_seg)),\n           \"DRAM segment data does not fit.\")\n \n@@ -357,7 +364,6 @@ SECTIONS\n     _flash_cache_start = ABSOLUTE(0);\n   } GROUP_DATA_LINK_IN(FLASH_CODE_REGION, ROMABLE_REGION)\n \n-_heap_sentry = 0x3ffe3f20;\n \n #include <zephyr/linker/debug-sections.ld>\n \ndiff --git a/soc/espressif/esp32/memory.h b/soc/espressif/esp32/memory.h\nindex 6f391e5fcb0..de298c34976 100644\n--- a/soc/espressif/esp32/memory.h\n+++ b/soc/espressif/esp32/memory.h\n@@ -4,25 +4,27 @@\n  */\n #pragma once\n \n-/* SRAM0 (64k+128k)  instruction cache+memory */\n+/* SRAM0 (192kB)  instruction cache+memory */\n #define SRAM0_IRAM_START    0x40070000\n #define SRAM0_CACHE_SIZE    0x10000\n #define SRAM0_SIZE          0x30000\n \n-/* SRAM1 (128k) instruction/data memory */\n+/* SRAM1 (128kB) instruction/data memory */\n #define SRAM1_IRAM_START    0x400a0000\n #define SRAM1_DRAM_START    0x3ffe0000\n #define SRAM1_SIZE          0x20000\n+#define SRAM1_DRAM_END      (SRAM1_DRAM_START + SRAM1_SIZE)\n #define SRAM1_DRAM_PROAPP_PRIV_SIZE 0x8000\n-#define SRAM1_DRAM_USER_START 0x3ffe5400\n+#define SRAM1_DRAM_USER_START 0x3ffe8000\n #define SRAM1_USER_SIZE     (0x40000000 - SRAM1_DRAM_USER_START)\n \n-/* SRAM2 (200k) data memory */\n-#define SRAM2_DRAM_START    0x3ffae000\n-#define SRAM2_SIZE          0x32000\n-#define SRAM2_DRAM_SHM_PRIV_SIZE 0x2000\n-#define SRAM2_DRAM_USER_START 0x3ffb0000\n-#define SRAM2_USER_SIZE     (SRAM1_DRAM_START - SRAM2_DRAM_USER_START)\n+/* SRAM2 (200kB) data memory */\n+#define SRAM2_DRAM_START      0x3ffae000\n+#define SRAM2_DRAM_SIZE       0x32000\n+#define SRAM2_DRAM_SHM_SIZE   0x2000\n+#define SRAM2_DRAM_END        (SRAM2_DRAM_START + SRAM2_DRAM_SIZE)\n+#define SRAM2_DRAM_USER_START (SRAM2_DRAM_START + SRAM2_DRAM_SHM_SIZE)\n+#define SRAM2_DRAM_USER_SIZE  (SRAM2_DRAM_END - SRAM2_DRAM_USER_START)\n \n /** Simplified memory map for the bootloader.\n  *  Make sure the bootloader can load into main memory without overwriting itself.\n@@ -41,19 +43,20 @@\n #define DRAM1_BT_SHM_BUFFERS_START  0x3ffe4350\n #define DRAM1_BT_SHM_BUFFERS_END    0x3ffe5230\n \n-/* Conversion beween IRAM and DRAM in SRAM1 memory */\n-#define SRAM1_IRAM_DRAM_CALC(addr_iram) \\\n-\t(SRAM1_SIZE - ((addr_iram) - SRAM1_IRAM_START) + SRAM1_DRAM_START)\n+/* Convert IRAM address to its DRAM counterpart in SRAM1 memory */\n+#define SRAM1_IRAM_DRAM_CALC(addr_iram) ((addr_iram > SRAM1_IRAM_START) ? \\\n+\t(SRAM1_SIZE - (addr_iram - SRAM1_IRAM_START) + SRAM1_DRAM_START) : (SRAM1_DRAM_END))\n+/* Convert DRAM address to its IRAM counterpart in SRAM1 memory */\n #define SRAM1_DRAM_IRAM_CALC(addr_dram) \\\n-\t(SRAM1_SIZE - ((addr_dram) - SRAM1_DRAM_START) + SRAM1_IRAM_START)\n+\t(SRAM1_SIZE - (addr_dram - SRAM1_DRAM_START) + SRAM1_IRAM_START)\n \n-/* For safety margin between bootloader data section and startup stacks */\n+/* Set bootloader segments size */\n #define BOOTLOADER_DRAM_SEG_LEN        0x7a00\n #define BOOTLOADER_IRAM_LOADER_SEG_LEN 0x4000\n #define BOOTLOADER_IRAM_SEG_LEN        0xa000\n \n /* Start of the lower region is determined by region size and the end of the higher region */\n-#define BOOTLOADER_DRAM_SEG_START  0x3fff0000\n+#define BOOTLOADER_DRAM_SEG_START  0x3ffe8000\n #define BOOTLOADER_DRAM_SEG_END    (BOOTLOADER_DRAM_SEG_START + BOOTLOADER_DRAM_SEG_LEN)\n #define BOOTLOADER_IRAM_LOADER_SEG_START 0x40078000\n #define BOOTLOADER_IRAM_SEG_START  0x400a0000"
},{
  "instruction": "soc: espressif: Introduce runtime heap mempool",
  "input": "# Copyright (c) 2023 Espressif Systems (Shanghai) Co., Ltd.\nzephyr_sources_ifdef(CONFIG_ESP_SPIRAM psram.c)",
  "result": "diff --git a/soc/espressif/common/CMakeLists.txt b/soc/espressif/common/CMakeLists.txt\nindex 98984d2503f..f51b5f8683d 100644\n--- a/soc/espressif/common/CMakeLists.txt\n+++ b/soc/espressif/common/CMakeLists.txt\n@@ -1,8 +1,11 @@\n-# Copyright (c) 2023 Espressif Systems (Shanghai) Co., Ltd.\n+# Copyright (c) 2024 Espressif Systems (Shanghai) Co., Ltd.\n # SPDX-License-Identifier: Apache-2.0\n \n if(CONFIG_SOC_SERIES_ESP32 OR CONFIG_SOC_SERIES_ESP32S2 OR CONFIG_SOC_SERIES_ESP32S3)\n   zephyr_include_directories(include)\n endif()\n \n-zephyr_sources_ifdef(CONFIG_ESP_SPIRAM psram.c)\n+if(NOT CONFIG_MCUBOOT AND NOT CONFIG_SOC_ESP32_APPCPU AND NOT CONFIG_SOC_ESP32S3_APPCPU)\n+  zephyr_sources_ifdef(CONFIG_ESP_SPIRAM psram.c)\n+  zephyr_sources_ifdef(CONFIG_ESP_RUNTIME_HEAP heap.c)\n+endif()\ndiff --git a/soc/espressif/common/Kconfig b/soc/espressif/common/Kconfig\nindex 5e3a0503d52..23f82735f29 100644\n--- a/soc/espressif/common/Kconfig\n+++ b/soc/espressif/common/Kconfig\n@@ -24,6 +24,14 @@ config ESP_SIMPLE_BOOT\n \t  Please note that this method brings the system up with all memories set-up, but\n \t  all other features, such as secure boot OTA or slots management are not available.\n \n+config ESP_RUNTIME_HEAP\n+\tbool\n+\tdefault y\n+\thelp\n+\t  Enabling this will allocate SRAM area starting by a last linked data at symbolic `_end`,\n+\t  ending by a last memory location that can be safely accesed (depending on a boot mode).\n+\t  This is a memory pool used in runtime to create a new heap memory.\n+\n rsource \"Kconfig.spiram\"\n rsource \"Kconfig.esptool\"\n rsource \"Kconfig.flash\"\ndiff --git a/soc/espressif/common/Kconfig.wifi b/soc/espressif/common/Kconfig.wifi\nindex ea124b2e7d2..0f329a0b240 100644\n--- a/soc/espressif/common/Kconfig.wifi\n+++ b/soc/espressif/common/Kconfig.wifi\n@@ -29,6 +29,23 @@ config ESP32_PHY_MAX_TX_POWER\n \tint\n \tdefault ESP32_PHY_MAX_WIFI_TX_POWER\n \n+choice ESP_WIFI_HEAP\n+\tprompt \"Wifi adapter heap in use\"\n+\tdefault ESP_WIFI_HEAP_RUNTIME\n+\n+\tconfig ESP_WIFI_HEAP_RUNTIME\n+\t\tbool \"Wifi adapter use ESP runtime heap\"\n+\t\tdepends on ESP_RUNTIME_HEAP\n+\n+\tconfig ESP_WIFI_HEAP_SPIRAM\n+\t\tbool \"Wifi adapter use SPIRAM heap\"\n+\t\tdepends on ESP_SPIRAM\n+\n+\tconfig ESP_WIFI_HEAP_SYSTEM\n+\t\tbool \"Wifi adapter use system heap\"\n+\n+endchoice # ESP_WIFI_HEAP\n+\n endmenu # ESP32 Wi-Fi config\n \n endif # SOC_FAMILY_ESPRESSIF_ESP32\ndiff --git a/soc/espressif/common/heap.c b/soc/espressif/common/heap.c\nnew file mode 100644\nindex 00000000000..6e2d2efc986\n--- /dev/null\n+++ b/soc/espressif/common/heap.c\n@@ -0,0 +1,48 @@\n+/*\n+ * Copyright (c) 2024 Espressif Systems (Shanghai) Co., Ltd.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+#include <zephyr/types.h>\n+#include <zephyr/kernel.h>\n+#include <soc.h>\n+#include <esp_err.h>\n+#include \"esp_log.h\"\n+\n+#define TAG \"heap\"\n+\n+/* ESP dynamic pool heap */\n+extern unsigned int z_mapped_end;\n+extern unsigned int _heap_sentry;\n+static void *esp_runtime_heap_init_mem = &z_mapped_end;\n+\n+#define ESP_RUNTIME_HEAP_MAX_SIZE  ((uintptr_t)&_heap_sentry - (uintptr_t)&z_mapped_end)\n+\n+struct k_heap esp_runtime_heap;\n+\n+static int esp_runtime_heap_init(void)\n+{\n+\tESP_EARLY_LOGI(TAG, \"ESP runtime heap init at 0x%x size %d kB.\\n\",\n+\t\t\tesp_runtime_heap_init_mem, ESP_RUNTIME_HEAP_MAX_SIZE/1024);\n+\n+\tk_heap_init(&esp_runtime_heap, esp_runtime_heap_init_mem, ESP_RUNTIME_HEAP_MAX_SIZE);\n+\n+#ifdef CONFIG_ESP_WIFI_HEAP_RUNTIME\n+\n+#if defined(CONFIG_WIFI) && defined(CONFIG_BT)\n+\tassert(ESP_RUNTIME_HEAP_MAX_SIZE > 65535);\n+#elif defined(CONFIG_WIFI)\n+\tassert(ESP_RUNTIME_HEAP_MAX_SIZE > 51200);\n+#elif defined(CONFIG_BT)\n+\tassert(ESP_RUNTIME_HEAP_MAX_SIZE > 40960);\n+#endif\n+\n+#endif /* CONFIG_ESP_WIFI_HEAP_RUNTIME */\n+\n+\treturn 0;\n+}\n+\n+SYS_INIT(esp_runtime_heap_init, PRE_KERNEL_2, CONFIG_KERNEL_INIT_PRIORITY_DEVICE);"
},{
  "instruction": "manifest: update hal_espressif",
  "input": "     revision: de5ea5987baaa5492fb9cc0d01222e8b07c78a70",
  "result": "diff --git a/west.yml b/west.yml\nindex db147508b73..277bcd853a7 100644\n--- a/west.yml\n+++ b/west.yml\n@@ -157,7 +157,7 @@ manifest:\n       groups:\n         - hal\n     - name: hal_espressif\n-      revision: de5ea5987baaa5492fb9cc0d01222e8b07c78a70\n+      revision: 0bd00ce82fcf48281c9206fc28bd39785f059d64\n       path: modules/hal/espressif\n       west-commands: west/west-commands.yml\n       groups:"
},{
  "instruction": "riscv: support dumping privilege stack during coredump",
  "input": "",
  "result": "diff --git a/arch/Kconfig b/arch/Kconfig\nindex 5171a86eff4..0bce3cae7a4 100644\n--- a/arch/Kconfig\n+++ b/arch/Kconfig\n@@ -115,6 +115,7 @@ config RISCV\n \tbool\n \tselect ARCH_IS_SET\n \tselect ARCH_SUPPORTS_COREDUMP\n+\tselect ARCH_SUPPORTS_COREDUMP_PRIV_STACKS\n \tselect ARCH_SUPPORTS_ROM_START if !SOC_FAMILY_ESPRESSIF_ESP32\n \tselect ARCH_SUPPORTS_EMPTY_IRQ_SPURIOUS\n \tselect ARCH_HAS_CODE_DATA_RELOCATION\ndiff --git a/arch/riscv/core/coredump.c b/arch/riscv/core/coredump.c\nindex 70d7a9976d4..003c7b9fce9 100644\n--- a/arch/riscv/core/coredump.c\n+++ b/arch/riscv/core/coredump.c\n@@ -5,6 +5,7 @@\n  */\n \n #include <string.h>\n+#include <zephyr/kernel.h>\n #include <zephyr/debug/coredump.h>\n \n #ifndef CONFIG_64BIT\n@@ -116,3 +117,21 @@ uint16_t arch_coredump_tgt_code_get(void)\n {\n \treturn COREDUMP_TGT_RISC_V;\n }\n+\n+#if defined(CONFIG_DEBUG_COREDUMP_DUMP_THREAD_PRIV_STACK)\n+void arch_coredump_priv_stack_dump(struct k_thread *thread)\n+{\n+\tuintptr_t start_addr, end_addr;\n+\n+\t/* See: zephyr/include/zephyr/arch/riscv/arch.h */\n+\tif (IS_ENABLED(CONFIG_PMP_POWER_OF_TWO_ALIGNMENT)) {\n+\t\tstart_addr = thread->arch.priv_stack_start + Z_RISCV_STACK_GUARD_SIZE;\n+\t} else {\n+\t\tstart_addr = thread->stack_info.start - CONFIG_PRIVILEGED_STACK_SIZE;\n+\t}\n+\tend_addr = Z_STACK_PTR_ALIGN(thread->arch.priv_stack_start + K_KERNEL_STACK_RESERVED +\n+\t\t\t\t     CONFIG_PRIVILEGED_STACK_SIZE);\n+\n+\tcoredump_memory_dump(start_addr, end_addr);\n+}\n+#endif /* CONFIG_DEBUG_COREDUMP_DUMP_THREAD_PRIV_STACK */"
},{
  "instruction": "soc: cdns/dc233c: advertise coredump with privilege stack",
  "input": "",
  "result": "diff --git a/soc/cdns/dc233c/Kconfig b/soc/cdns/dc233c/Kconfig\nindex 01ffa1c92ca..c0becdd0ba4 100644\n--- a/soc/cdns/dc233c/Kconfig\n+++ b/soc/cdns/dc233c/Kconfig\n@@ -11,4 +11,6 @@ config SOC_XTENSA_DC233C\n \tselect CPU_HAS_MMU\n \tselect ARCH_HAS_RESERVED_PAGE_FRAMES if XTENSA_MMU\n \tselect ARCH_HAS_USERSPACE if XTENSA_MMU\n+\tselect ARCH_SUPPORTS_COREDUMP\n+\tselect ARCH_SUPPORTS_COREDUMP_PRIV_STACKS\n \tselect XTENSA_INVALIDATE_MEM_DOMAIN_TLB_ON_SWAP if XTENSA_MMU"
},{
  "instruction": "xtensa: coredump: support dumping privilege stack",
  "input": "",
  "result": "diff --git a/arch/xtensa/core/coredump.c b/arch/xtensa/core/coredump.c\nindex 0ee1f8992a6..8e4b08ee2fa 100644\n--- a/arch/xtensa/core/coredump.c\n+++ b/arch/xtensa/core/coredump.c\n@@ -5,6 +5,7 @@\n  */\n \n #include <string.h>\n+#include <zephyr/kernel.h>\n #include <zephyr/debug/coredump.h>\n #include <xtensa_asm2_context.h>\n #include <zephyr/offsets.h>\n@@ -189,3 +190,18 @@ uint16_t arch_coredump_tgt_code_get(void)\n {\n \treturn COREDUMP_TGT_XTENSA;\n }\n+\n+#if defined(CONFIG_DEBUG_COREDUMP_DUMP_THREAD_PRIV_STACK)\n+void arch_coredump_priv_stack_dump(struct k_thread *thread)\n+{\n+\tstruct xtensa_thread_stack_header *hdr_stack_obj;\n+\tuintptr_t start_addr, end_addr;\n+\n+\thdr_stack_obj = (struct xtensa_thread_stack_header *)thread->stack_obj;\n+\n+\tstart_addr = (uintptr_t)&hdr_stack_obj->privilege_stack[0];\n+\tend_addr = start_addr + sizeof(hdr_stack_obj->privilege_stack);\n+\n+\tcoredump_memory_dump(start_addr, end_addr);\n+}\n+#endif /* CONFIG_DEBUG_COREDUMP_DUMP_THREAD_PRIV_STACK */"
},{
  "instruction": "x86: coredump: support dumping privilege stack",
  "input": "",
  "result": "diff --git a/arch/Kconfig b/arch/Kconfig\nindex 06bbf15c908..5171a86eff4 100644\n--- a/arch/Kconfig\n+++ b/arch/Kconfig\n@@ -83,6 +83,7 @@ config X86\n \tselect ARCH_IS_SET\n \tselect ATOMIC_OPERATIONS_BUILTIN\n \tselect ARCH_SUPPORTS_COREDUMP\n+\tselect ARCH_SUPPORTS_COREDUMP_PRIV_STACKS\n \tselect ARCH_SUPPORTS_ROM_START if !X86_64\n \tselect CPU_HAS_MMU\n \tselect ARCH_MEM_DOMAIN_DATA if USERSPACE && !X86_COMMON_PAGE_TABLE\ndiff --git a/arch/x86/core/ia32/coredump.c b/arch/x86/core/ia32/coredump.c\nindex fb7d0fcfd8c..c443dc4091b 100644\n--- a/arch/x86/core/ia32/coredump.c\n+++ b/arch/x86/core/ia32/coredump.c\n@@ -5,6 +5,7 @@\n  */\n \n #include <string.h>\n+#include <zephyr/kernel.h>\n #include <zephyr/debug/coredump.h>\n \n #define ARCH_HDR_VER\t\t\t1\n@@ -80,3 +81,22 @@ uint16_t arch_coredump_tgt_code_get(void)\n {\n \treturn COREDUMP_TGT_X86;\n }\n+\n+#if defined(CONFIG_DEBUG_COREDUMP_DUMP_THREAD_PRIV_STACK)\n+void arch_coredump_priv_stack_dump(struct k_thread *thread)\n+{\n+\tstruct z_x86_thread_stack_header *hdr_stack_obj;\n+\tuintptr_t start_addr, end_addr;\n+\n+#if defined(CONFIG_THREAD_STACK_MEM_MAPPED)\n+\thdr_stack_obj = (struct z_x86_thread_stack_header *)thread->stack_info.mapped.addr;\n+#else\n+\thdr_stack_obj = (struct z_x86_thread_stack_header *)thread->stack_obj;\n+#endif /* CONFIG_THREAD_STACK_MEM_MAPPED) */\n+\n+\tstart_addr = (uintptr_t)&hdr_stack_obj->privilege_stack[0];\n+\tend_addr = start_addr + sizeof(hdr_stack_obj->privilege_stack);\n+\n+\tcoredump_memory_dump(start_addr, end_addr);\n+}\n+#endif /* CONFIG_DEBUG_COREDUMP_DUMP_THREAD_PRIV_STACK */\ndiff --git a/arch/x86/core/intel64/coredump.c b/arch/x86/core/intel64/coredump.c\nindex 65a9306ca07..68aa04888ee 100644\n--- a/arch/x86/core/intel64/coredump.c\n+++ b/arch/x86/core/intel64/coredump.c\n@@ -5,6 +5,7 @@\n  */\n \n #include <string.h>\n+#include <zephyr/kernel.h>\n #include <zephyr/debug/coredump.h>\n \n #define ARCH_HDR_VER\t\t\t1\n@@ -106,3 +107,22 @@ uint16_t arch_coredump_tgt_code_get(void)\n {\n \treturn COREDUMP_TGT_X86_64;\n }\n+\n+#if defined(CONFIG_DEBUG_COREDUMP_DUMP_THREAD_PRIV_STACK)\n+void arch_coredump_priv_stack_dump(struct k_thread *thread)\n+{\n+\tstruct z_x86_thread_stack_header *hdr_stack_obj;\n+\tuintptr_t start_addr, end_addr;\n+\n+#if defined(CONFIG_THREAD_STACK_MEM_MAPPED)\n+\thdr_stack_obj = (struct z_x86_thread_stack_header *)thread->stack_info.mapped.addr;\n+#else\n+\thdr_stack_obj = (struct z_x86_thread_stack_header *)thread->stack_obj;\n+#endif /* CONFIG_THREAD_STACK_MEM_MAPPED) */\n+\n+\tstart_addr = (uintptr_t)&hdr_stack_obj->privilege_stack[0];\n+\tend_addr = start_addr + sizeof(hdr_stack_obj->privilege_stack);\n+\n+\tcoredump_memory_dump(start_addr, end_addr);\n+}\n+#endif /* CONFIG_DEBUG_COREDUMP_DUMP_THREAD_PRIV_STACK */"
},{
  "instruction": "tests: debug/coredump: crash from user thread if userspace",
  "input": "int main(void)",
  "result": "diff --git a/tests/subsys/debug/coredump/src/main.c b/tests/subsys/debug/coredump/src/main.c\nindex f97494df171..e1c1aead92c 100644\n--- a/tests/subsys/debug/coredump/src/main.c\n+++ b/tests/subsys/debug/coredump/src/main.c\n@@ -12,6 +12,8 @@\n #include <zephyr/debug/gcov.h>\n #endif\n \n+struct k_thread crash_thread;\n+K_THREAD_STACK_DEFINE(crash_stack, CONFIG_MAIN_STACK_SIZE);\n \n void k_sys_fatal_error_handler(unsigned int reason, const struct arch_esf *pEsf)\n {\n@@ -68,10 +70,16 @@ void func_1(uint32_t *addr)\n \tfunc_2(addr);\n }\n \n-int main(void)\n+static void crash_entry(void *p1, void *p2, void *p3)\n {\n \tprintk(\"Coredump: %s\\n\", CONFIG_BOARD);\n \n \tfunc_1(0);\n+}\n+\n+int main(void)\n+{\n+\tk_thread_create(&crash_thread, crash_stack, CONFIG_MAIN_STACK_SIZE, crash_entry, NULL, NULL,\n+\t\t\tNULL, -1, IS_ENABLED(CONFIG_USERSPACE) ? K_USER : 0, K_NO_WAIT);\n \treturn 0;\n }\ndiff --git a/tests/subsys/debug/coredump/testcase.yaml b/tests/subsys/debug/coredump/testcase.yaml\nindex 5b7dde692b1..673382bf455 100644\n--- a/tests/subsys/debug/coredump/testcase.yaml\n+++ b/tests/subsys/debug/coredump/testcase.yaml\n@@ -22,3 +22,32 @@ tests:\n         - \"E: #CD:4([dD])([0-9a-fA-F]+)\"\n         - \"E: #CD:END#\"\n         - \"k_sys_fatal_error_handler\"\n+  debug.coredump.logging_backend.userspace:\n+    tags: coredump\n+    ignore_faults: true\n+    ignore_qemu_crash: true\n+    filter: CONFIG_ARCH_SUPPORTS_COREDUMP and CONFIG_ARCH_HAS_USERSPACE\n+    extra_configs:\n+      - CONFIG_TEST_USERSPACE=y\n+    integration_platforms:\n+      - qemu_x86\n+    platform_allow:\n+      - qemu_riscv32\n+      - qemu_riscv64\n+      - qemu_x86\n+      - qemu_x86_64\n+      - qemu_xtensa/dc233c/mmu\n+    harness: console\n+    harness_config:\n+      type: multi_line\n+      regex:\n+        - \"Coredump: (.*)\"\n+        - \">>> ZEPHYR FATAL ERROR \"\n+        - \"E: #CD:BEGIN#\"\n+        - \"E: #CD:5([aA])45([0-9a-fA-F]+)\"\n+        - \"E: #CD:41([0-9a-fA-F]+)\"\n+        - \"E: #CD:4([dD])([0-9a-fA-F]+)\"\n+        - \"E: #CD:4([dD])([0-9a-fA-F]+)\"\n+        - \"E: #CD:4([dD])([0-9a-fA-F]+)\"\n+        - \"E: #CD:END#\"\n+        - \"k_sys_fatal_error_handler\""
},{
  "instruction": "debug: coredump: dump privileged stack",
  "input": "",
  "result": "diff --git a/arch/Kconfig b/arch/Kconfig\nindex 94f8ee48691..06bbf15c908 100644\n--- a/arch/Kconfig\n+++ b/arch/Kconfig\n@@ -679,6 +679,9 @@ config ARCH_SUPPORTS_COREDUMP\n config ARCH_SUPPORTS_COREDUMP_THREADS\n \tbool\n \n+config ARCH_SUPPORTS_COREDUMP_PRIV_STACKS\n+\tbool\n+\n config ARCH_SUPPORTS_ARCH_HW_INIT\n \tbool\n \ndiff --git a/subsys/debug/coredump/Kconfig b/subsys/debug/coredump/Kconfig\nindex 18c49c68158..ad46d7d80b8 100644\n--- a/subsys/debug/coredump/Kconfig\n+++ b/subsys/debug/coredump/Kconfig\n@@ -107,4 +107,15 @@ config DEBUG_COREDUMP_THREADS_METADATA\n \t  Core dump will contain the threads metadata section containing\n \t  any necessary data to enable debugging threads\n \n+config DEBUG_COREDUMP_DUMP_THREAD_PRIV_STACK\n+\tbool \"Dump privilege stack of user threads\"\n+\tdefault y\n+\tdepends on ARCH_SUPPORTS_COREDUMP_PRIV_STACKS\n+\tdepends on USERSPACE\n+\thelp\n+\t  Dump the privilege stack of user threads.\n+\n+\t  Say n to conserve space on coredump backend or if you will never\n+\t  need to look into the privilege stacks.\n+\n endif # DEBUG_COREDUMP\ndiff --git a/subsys/debug/coredump/coredump_core.c b/subsys/debug/coredump/coredump_core.c\nindex 9121d4ae548..dd246623089 100644\n--- a/subsys/debug/coredump/coredump_core.c\n+++ b/subsys/debug/coredump/coredump_core.c\n@@ -37,6 +37,14 @@ static struct coredump_backend_api\n #define DT_DRV_COMPAT zephyr_coredump\n #endif\n \n+#if defined(CONFIG_DEBUG_COREDUMP_DUMP_THREAD_PRIV_STACK)\n+__weak void arch_coredump_priv_stack_dump(struct k_thread *thread)\n+{\n+\t/* Stub if architecture has not implemented this. */\n+\tARG_UNUSED(thread);\n+}\n+#endif /* CONFIG_DEBUG_COREDUMP_DUMP_THREAD_PRIV_STACK */\n+\n static void dump_header(unsigned int reason)\n {\n \tstruct coredump_hdr_t hdr = {\n@@ -81,6 +89,12 @@ static void dump_thread(struct k_thread *thread)\n \tend_addr = thread->stack_info.start + thread->stack_info.size;\n \n \tcoredump_memory_dump(thread->stack_info.start, end_addr);\n+\n+#if defined(CONFIG_DEBUG_COREDUMP_DUMP_THREAD_PRIV_STACK)\n+\tif ((thread->base.user_options & K_USER) == K_USER) {\n+\t\tarch_coredump_priv_stack_dump(thread);\n+\t}\n+#endif /* CONFIG_DEBUG_COREDUMP_DUMP_THREAD_PRIV_STACK */\n }\n #endif\n "
},{
  "instruction": "arch: add interface to dump privileged stack in coredump",
  "input": "",
  "result": "diff --git a/kernel/include/kernel_arch_interface.h b/kernel/include/kernel_arch_interface.h\nindex dcf16a4c5f6..0b7504c5b9e 100644\n--- a/kernel/include/kernel_arch_interface.h\n+++ b/kernel/include/kernel_arch_interface.h\n@@ -634,6 +634,19 @@ void arch_coredump_info_dump(const struct arch_esf *esf);\n  */\n uint16_t arch_coredump_tgt_code_get(void);\n \n+#if defined(CONFIG_USERSPACE) || defined(__DOXYGEN__)\n+\n+/**\n+ * @brief Architecture-specific handling of dumping privileged stack\n+ *\n+ * This dumps the architecture-specific privileged stack during coredump.\n+ *\n+ * @param thread Pointer to thread object\n+ */\n+void arch_coredump_priv_stack_dump(struct k_thread *thread);\n+\n+#endif /* CONFIG_USERSPACE || __DOXYGEN__ */\n+\n /** @} */\n \n /**"
},{
  "instruction": "Bluetooth: Host: Set scan option type to uint8_t",
  "input": "\tuint32_t options;",
  "result": "diff --git a/include/zephyr/bluetooth/bluetooth.h b/include/zephyr/bluetooth/bluetooth.h\nindex 6f565bd400f..bc5b7b0731c 100644\n--- a/include/zephyr/bluetooth/bluetooth.h\n+++ b/include/zephyr/bluetooth/bluetooth.h\n@@ -2065,7 +2065,7 @@ struct bt_le_scan_param {\n \tuint8_t  type;\n \n \t/** Bit-field of scanning options. */\n-\tuint32_t options;\n+\tuint8_t options;\n \n \t/** Scan interval (N * 0.625 ms).\n \t *"
},{
  "instruction": "soc: stm32g4x/stm32l0x: fix soc hook calls",
  "input": "/* Initialize STM32 Power */\nvoid soc_early_init_hook(void)\n{\n\t/* Enable Power clock */\n\tLL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);\n}",
  "result": "diff --git a/soc/st/stm32/stm32g4x/soc.c b/soc/st/stm32/stm32g4x/soc.c\nindex f21906f397c..870f6e784f3 100644\n--- a/soc/st/stm32/stm32g4x/soc.c\n+++ b/soc/st/stm32/stm32g4x/soc.c\n@@ -20,6 +20,8 @@\n #include <stm32_ll_pwr.h>\n #endif /* PWR_CR3_UCPD_DBDIS */\n \n+extern void stm32_power_init(void);\n+\n /**\n  * @brief Perform basic hardware initialization at boot.\n  *\ndiff --git a/soc/st/stm32/stm32l0x/power.c b/soc/st/stm32/stm32l0x/power.c\nindex 45d353472c0..aa3dd1caf8a 100644\n--- a/soc/st/stm32/stm32l0x/power.c\n+++ b/soc/st/stm32/stm32l0x/power.c\n@@ -72,11 +72,3 @@ void pm_state_exit_post_ops(enum pm_state state, uint8_t substate_id)\n \t */\n \tirq_unlock(0);\n }\n-\n-/* Initialize STM32 Power */\n-void soc_early_init_hook(void)\n-{\n-\n-\t/* Enable Power clock */\n-\tLL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);\n-}\ndiff --git a/soc/st/stm32/stm32l0x/soc.c b/soc/st/stm32/stm32l0x/soc.c\nindex 174ae67514d..17a9d0cd1c0 100644\n--- a/soc/st/stm32/stm32l0x/soc.c\n+++ b/soc/st/stm32/stm32l0x/soc.c\n@@ -40,4 +40,8 @@ void soc_early_init_hook(void)\n \t * https://github.com/zephyrproject-rtos/zephyr/issues/#34324 )\n \t */\n \tLL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_DMA1);\n+#ifdef CONFIG_PM\n+\t/* Enable Power clock */\n+\tLL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);\n+#endif\n }"
},{
  "instruction": "soc: intel_ish: remove duplicate hook",
  "input": "extern void sedi_pm_init(void);\nvoid soc_early_init_hook(void)\n{\n\tsedi_pm_init();\n}",
  "result": "diff --git a/soc/intel/intel_ish/intel_ish5/pm/power.c b/soc/intel/intel_ish/intel_ish5/pm/power.c\nindex 1ad559c3fea..8da03692305 100644\n--- a/soc/intel/intel_ish/intel_ish5/pm/power.c\n+++ b/soc/intel/intel_ish/intel_ish5/pm/power.c\n@@ -69,10 +69,3 @@ void sys_arch_reboot(int type)\n \tsedi_pm_reset();\n }\n #endif\n-\n-extern void sedi_pm_init(void);\n-\n-void soc_early_init_hook(void)\n-{\n-\tsedi_pm_init();\n-}\ndiff --git a/soc/intel/intel_ish/intel_ish5/soc.c b/soc/intel/intel_ish/intel_ish5/soc.c\nindex 6547b219d4e..488b0aedf89 100644\n--- a/soc/intel/intel_ish/intel_ish5/soc.c\n+++ b/soc/intel/intel_ish/intel_ish5/soc.c\n@@ -11,9 +11,14 @@\n #include \"sedi_driver_hpet.h\"\n #endif\n \n+extern void sedi_pm_init(void);\n+\n void soc_early_init_hook(void)\n {\n #if defined(CONFIG_HPET_TIMER)\n \tsedi_hpet_set_min_delay(HPET_CMP_MIN_DELAY);\n #endif\n+#if defined(CONFIG_PM)\n+\tsedi_pm_init();\n+#endif\n }"
},{
  "instruction": "github: workflows: Add cargo support to twister",
  "input": "",
  "result": "diff --git a/.github/workflows/twister.yaml b/.github/workflows/twister.yaml\nindex a4bc219f36d..b0b8701adf1 100644\n--- a/.github/workflows/twister.yaml\n+++ b/.github/workflows/twister.yaml\n@@ -190,6 +190,7 @@ jobs:\n             git log  --pretty=oneline | head -n 10\n           fi\n           echo \"$HOME/.local/bin\" >> $GITHUB_PATH\n+          echo \"$HOME/.cargo/bin\" >> $GITHUB_PATH\n \n           west init -l . || true\n           west config manifest.group-filter -- +ci,+optional\n@@ -203,6 +204,8 @@ jobs:\n         run: |\n           cmake --version\n           gcc --version\n+          cargo --version\n+          rustup target list --installed\n           ls -la\n           echo \"github.ref: ${{ github.ref }}\"\n           echo \"github.base_ref: ${{ github.base_ref }}\""
},{
  "instruction": "tests: drivers: dma: Enabled DMA Tests for MIMXRT1010_EVK",
  "input": "",
  "result": "diff --git a/tests/drivers/dma/chan_blen_transfer/boards/mimxrt1010_evk.conf b/tests/drivers/dma/chan_blen_transfer/boards/mimxrt1010_evk.conf\nnew file mode 100644\nindex 00000000000..433a67585be\n--- /dev/null\n+++ b/tests/drivers/dma/chan_blen_transfer/boards/mimxrt1010_evk.conf\n@@ -0,0 +1,3 @@\n+CONFIG_CODE_DATA_RELOCATION=y\n+CONFIG_MEM_ATTR_HEAP=y\n+CONFIG_DMA_LOOP_TRANSFER_RELOCATE_SECTION=\"DTCM\"\ndiff --git a/tests/drivers/dma/chan_blen_transfer/boards/mimxrt1010_evk.overlay b/tests/drivers/dma/chan_blen_transfer/boards/mimxrt1010_evk.overlay\nnew file mode 100644\nindex 00000000000..e653967c9c8\n--- /dev/null\n+++ b/tests/drivers/dma/chan_blen_transfer/boards/mimxrt1010_evk.overlay\n@@ -0,0 +1,7 @@\n+/*\n+ * Copyright 2024 NXP\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+tst_dma0: &edma0 { };\ndiff --git a/tests/drivers/dma/chan_link_transfer/boards/mimxrt1010_evk.overlay b/tests/drivers/dma/chan_link_transfer/boards/mimxrt1010_evk.overlay\nnew file mode 100644\nindex 00000000000..edc11dd90c5\n--- /dev/null\n+++ b/tests/drivers/dma/chan_link_transfer/boards/mimxrt1010_evk.overlay\n@@ -0,0 +1,8 @@\n+/*\n+ * Copyright 2024 NXP\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ *\n+ */\n+\n+dma0: &edma0 {};\ndiff --git a/tests/drivers/dma/chan_link_transfer/testcase.yaml b/tests/drivers/dma/chan_link_transfer/testcase.yaml\nindex e22eb92057a..516a61a6ce3 100644\n--- a/tests/drivers/dma/chan_link_transfer/testcase.yaml\n+++ b/tests/drivers/dma/chan_link_transfer/testcase.yaml\n@@ -8,6 +8,7 @@ tests:\n     platform_allow:\n       - frdm_k64f\n       - mimxrt595_evk/mimxrt595s/cm33\n+      - mimxrt1010_evk\n       - mimxrt1050_evk\n       - mimxrt1060_evk\n       - mimxrt1064_evk\ndiff --git a/tests/drivers/dma/loop_transfer/boards/mimxrt1010_evk.conf b/tests/drivers/dma/loop_transfer/boards/mimxrt1010_evk.conf\nnew file mode 100644\nindex 00000000000..10d9fc007df\n--- /dev/null\n+++ b/tests/drivers/dma/loop_transfer/boards/mimxrt1010_evk.conf\n@@ -0,0 +1,4 @@\n+CONFIG_CODE_DATA_RELOCATION=y\n+CONFIG_MEM_ATTR_HEAP=y\n+CONFIG_DMA_LOOP_TRANSFER_RELOCATE_SECTION=\"DTCM\"\n+CONFIG_DMA_LOOP_TRANSFER_SIZE=4096\ndiff --git a/tests/drivers/dma/loop_transfer/boards/mimxrt1010_evk.overlay b/tests/drivers/dma/loop_transfer/boards/mimxrt1010_evk.overlay\nnew file mode 100644\nindex 00000000000..e653967c9c8\n--- /dev/null\n+++ b/tests/drivers/dma/loop_transfer/boards/mimxrt1010_evk.overlay\n@@ -0,0 +1,7 @@\n+/*\n+ * Copyright 2024 NXP\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+tst_dma0: &edma0 { };\ndiff --git a/tests/drivers/dma/scatter_gather/boards/mimxrt1010_evk.conf b/tests/drivers/dma/scatter_gather/boards/mimxrt1010_evk.conf\nnew file mode 100644\nindex 00000000000..5bfda6a5251\n--- /dev/null\n+++ b/tests/drivers/dma/scatter_gather/boards/mimxrt1010_evk.conf\n@@ -0,0 +1,2 @@\n+CONFIG_DMA_TCD_QUEUE_SIZE=4\n+CONFIG_DMA_SG_XFER_SIZE=4096\ndiff --git a/tests/drivers/dma/scatter_gather/boards/mimxrt1010_evk.overlay b/tests/drivers/dma/scatter_gather/boards/mimxrt1010_evk.overlay\nnew file mode 100644\nindex 00000000000..d22f675e226\n--- /dev/null\n+++ b/tests/drivers/dma/scatter_gather/boards/mimxrt1010_evk.overlay\n@@ -0,0 +1,11 @@\n+/*\n+ * Copyright 2024 NXP\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+/ {\n+\taliases {\n+\t\tdma0 = &edma0;\n+\t};\n+};\ndiff --git a/tests/drivers/dma/scatter_gather/testcase.yaml b/tests/drivers/dma/scatter_gather/testcase.yaml\nindex 407793a96de..22bed4e612c 100644\n--- a/tests/drivers/dma/scatter_gather/testcase.yaml\n+++ b/tests/drivers/dma/scatter_gather/testcase.yaml\n@@ -7,6 +7,7 @@ tests:\n     platform_allow:\n       - intel_adsp/cavs25\n       - frdm_k64f\n+      - mimxrt1010_evk\n       - mimxrt1060_evk\n       - lpcxpresso55s36\n       - native_sim"
},{
  "instruction": "drivers: mcux_igpio: improve pin-gaps handling",
  "input": "struct gpio_pin_gaps {\n\tuint8_t start;\n\tuint8_t len;\n};\n\tconst struct gpio_pin_gaps *pin_gaps;\n\tuint8_t gap_count;\n\tfor (i = 0; i < config->gap_count; i++) {\n\t\tif (pin >= config->pin_gaps[i].start) {\n\t\t\tif (pin < (config->pin_gaps[i].start +\n\t\t\t\tconfig->pin_gaps[i].len)) {\n\t\t\t\t/* Pin is not connected to a mux */\n\t\t\t\treturn -ENOTSUP;\n\t\t\t}\n\t\t\tcfg_idx -= config->pin_gaps[i].len;\n\t};\t\t\t\t\t\t\t\t\t\\\n\tconst uint8_t mcux_igpio_pin_gaps_##n[] =\t\t\t\t\\\n\t\tDT_INST_PROP_OR(n, gpio_reserved_ranges, {});\n\t.pin_gaps = (const struct gpio_pin_gaps *)mcux_igpio_pin_gaps_##n,\t\\\n\t.mux_count = DT_PROP_LEN(DT_DRV_INST(n), pinmux),\t\t\t\\\n\t.gap_count = (ARRAY_SIZE(mcux_igpio_pin_gaps_##n) / 2)\n\t\t\t.port_pin_mask = GPIO_PORT_PIN_MASK_FROM_DT_INST(n),\\",
  "result": "diff --git a/drivers/gpio/gpio_mcux_igpio.c b/drivers/gpio/gpio_mcux_igpio.c\nindex a6ce542175f..9a04172a49f 100644\n--- a/drivers/gpio/gpio_mcux_igpio.c\n+++ b/drivers/gpio/gpio_mcux_igpio.c\n@@ -18,19 +18,13 @@\n \n #include <zephyr/drivers/gpio/gpio_utils.h>\n \n-struct gpio_pin_gaps {\n-\tuint8_t start;\n-\tuint8_t len;\n-};\n \n struct mcux_igpio_config {\n \t/* gpio_driver_config needs to be first */\n \tstruct gpio_driver_config common;\n \tGPIO_Type *base;\n \tconst struct pinctrl_soc_pinmux *pin_muxes;\n-\tconst struct gpio_pin_gaps *pin_gaps;\n \tuint8_t mux_count;\n-\tuint8_t gap_count;\n };\n \n struct mcux_igpio_data {\n@@ -49,15 +43,15 @@ static int mcux_igpio_configure(const struct device *dev,\n \tstruct pinctrl_soc_pin pin_cfg;\n \tint cfg_idx = pin, i;\n \n+\t/* Make sure pin is supported */\n+\tif ((config->common.port_pin_mask & BIT(pin)) == 0) {\n+\t\treturn -ENOTSUP;\n+\t}\n+\n \t/* Some SOCs have non-contiguous gpio pin layouts, account for this */\n-\tfor (i = 0; i < config->gap_count; i++) {\n-\t\tif (pin >= config->pin_gaps[i].start) {\n-\t\t\tif (pin < (config->pin_gaps[i].start +\n-\t\t\t\tconfig->pin_gaps[i].len)) {\n-\t\t\t\t/* Pin is not connected to a mux */\n-\t\t\t\treturn -ENOTSUP;\n-\t\t\t}\n-\t\t\tcfg_idx -= config->pin_gaps[i].len;\n+\tfor (i = 0; i < pin; i++) {\n+\t\tif ((config->common.port_pin_mask & BIT(i)) == 0) {\n+\t\t\tcfg_idx--;\n \t\t}\n \t}\n \n@@ -274,6 +268,11 @@ static int mcux_igpio_pin_interrupt_configure(const struct device *dev,\n \tuint8_t icr;\n \tint shift;\n \n+\t/* Make sure pin is supported */\n+\tif ((config->common.port_pin_mask & BIT(pin)) == 0) {\n+\t\treturn -ENOTSUP;\n+\t}\n+\n \tif (mode == GPIO_INT_MODE_DISABLED) {\n \t\tkey = irq_lock();\n \n@@ -356,14 +355,10 @@ static const struct gpio_driver_api mcux_igpio_driver_api = {\n #define MCUX_IGPIO_PIN_DECLARE(n)\t\t\t\t\t\t\\\n \tconst struct pinctrl_soc_pinmux mcux_igpio_pinmux_##n[] = {\t\t\\\n \t\tDT_FOREACH_PROP_ELEM(DT_DRV_INST(n), pinmux, PINMUX_INIT)\t\\\n-\t};\t\t\t\t\t\t\t\t\t\\\n-\tconst uint8_t mcux_igpio_pin_gaps_##n[] =\t\t\t\t\\\n-\t\tDT_INST_PROP_OR(n, gpio_reserved_ranges, {});\n+\t};\n #define MCUX_IGPIO_PIN_INIT(n)\t\t\t\t\t\t\t\\\n \t.pin_muxes = mcux_igpio_pinmux_##n,\t\t\t\t\t\\\n-\t.pin_gaps = (const struct gpio_pin_gaps *)mcux_igpio_pin_gaps_##n,\t\\\n-\t.mux_count = DT_PROP_LEN(DT_DRV_INST(n), pinmux),\t\t\t\\\n-\t.gap_count = (ARRAY_SIZE(mcux_igpio_pin_gaps_##n) / 2)\n+\t.mux_count = DT_PROP_LEN(DT_DRV_INST(n), pinmux)\n \n #define MCUX_IGPIO_IRQ_INIT(n, i)\t\t\t\t\t\\\n \tdo {\t\t\t\t\t\t\t\t\\\n@@ -381,7 +376,8 @@ static const struct gpio_driver_api mcux_igpio_driver_api = {\n \t\t\t\t\t\t\t\t\t\\\n \tstatic const struct mcux_igpio_config mcux_igpio_##n##_config = {\\\n \t\t.common = {\t\t\t\t\t\t\\\n-\t\t\t.port_pin_mask = GPIO_PORT_PIN_MASK_FROM_DT_INST(n),\\\n+\t\t\t.port_pin_mask = GPIO_DT_INST_PORT_PIN_MASK_NGPIOS_EXC(\\\n+\t\t\t\tn, DT_INST_PROP(n, ngpios)),\\\n \t\t},\t\t\t\t\t\t\t\\\n \t\t.base = (GPIO_Type *)DT_INST_REG_ADDR(n),\t\t\\\n \t\tMCUX_IGPIO_PIN_INIT(n)\t\t\t\t\t\\"
},{
  "instruction": "drivers: mcux_rgpio: improve pin-gaps handling",
  "input": "struct gpio_pin_gaps {\n\tuint8_t start;\n\tuint8_t len;\n};\n\tconst struct gpio_pin_gaps *pin_gaps;\n\tuint8_t gap_count;\n\tfor (i = 0; i < config->gap_count; i++) {\n\t\tif (pin >= config->pin_gaps[i].start) {\n\t\t\tif (pin < (config->pin_gaps[i].start +\n\t\t\t\tconfig->pin_gaps[i].len)) {\n\t\t\t\t/* Pin is not connected to a mux */\n\t\t\t\treturn -ENOTSUP;\n\t\t\t}\n\t\t\tcfg_idx -= config->pin_gaps[i].len;\n\t};\t\t\t\t\t\t\t\t\t\\\n\tconst uint8_t mcux_rgpio_pin_gaps_##n[] =\t\t\t\t\\\n\t\tDT_INST_PROP_OR(n, gpio_reserved_ranges, {});\n\t.pin_gaps = (const struct gpio_pin_gaps *)mcux_rgpio_pin_gaps_##n,\t\\\n\t.mux_count = DT_PROP_LEN(DT_DRV_INST(n), pinmux),\t\t\t\\\n\t.gap_count = (ARRAY_SIZE(mcux_rgpio_pin_gaps_##n) / 2)\n\tstatic const struct mcux_rgpio_config mcux_rgpio_##n##_config = {\\\n\t\t\t.port_pin_mask = GPIO_PORT_PIN_MASK_FROM_DT_INST(n),\\",
  "result": "diff --git a/drivers/gpio/gpio_mcux_rgpio.c b/drivers/gpio/gpio_mcux_rgpio.c\nindex ce0d3dffd23..4ad998545e5 100644\n--- a/drivers/gpio/gpio_mcux_rgpio.c\n+++ b/drivers/gpio/gpio_mcux_rgpio.c\n@@ -16,11 +16,6 @@\n \n #include <zephyr/drivers/gpio/gpio_utils.h>\n \n-struct gpio_pin_gaps {\n-\tuint8_t start;\n-\tuint8_t len;\n-};\n-\n /* Required by DEVICE_MMIO_NAMED_* macros */\n #define DEV_CFG(_dev) \\\n \t((const struct mcux_rgpio_config *)(_dev)->config)\n@@ -33,9 +28,7 @@ struct mcux_rgpio_config {\n \tDEVICE_MMIO_NAMED_ROM(reg_base);\n \n \tconst struct pinctrl_soc_pinmux *pin_muxes;\n-\tconst struct gpio_pin_gaps *pin_gaps;\n \tuint8_t mux_count;\n-\tuint8_t gap_count;\n };\n \n struct mcux_rgpio_data {\n@@ -57,15 +50,15 @@ static int mcux_rgpio_configure(const struct device *dev,\n \tstruct pinctrl_soc_pin pin_cfg;\n \tint cfg_idx = pin, i;\n \n+\t/* Make sure pin is supported */\n+\tif ((config->common.port_pin_mask & BIT(pin)) == 0) {\n+\t\treturn -ENOTSUP;\n+\t}\n+\n \t/* Some SOCs have non-contiguous gpio pin layouts, account for this */\n-\tfor (i = 0; i < config->gap_count; i++) {\n-\t\tif (pin >= config->pin_gaps[i].start) {\n-\t\t\tif (pin < (config->pin_gaps[i].start +\n-\t\t\t\tconfig->pin_gaps[i].len)) {\n-\t\t\t\t/* Pin is not connected to a mux */\n-\t\t\t\treturn -ENOTSUP;\n-\t\t\t}\n-\t\t\tcfg_idx -= config->pin_gaps[i].len;\n+\tfor (i = 0; i < pin; i++) {\n+\t\tif ((config->common.port_pin_mask & BIT(i)) == 0) {\n+\t\t\tcfg_idx--;\n \t\t}\n \t}\n \n@@ -214,9 +207,15 @@ static int mcux_rgpio_pin_interrupt_configure(const struct device *dev,\n \t\t\t\t\t\t  enum gpio_int_trig trig)\n {\n \tRGPIO_Type *base = (RGPIO_Type *)DEVICE_MMIO_NAMED_GET(dev, reg_base);\n+\tconst struct mcux_rgpio_config *config = dev->config;\n \tunsigned int key;\n \tuint8_t irqs, irqc;\n \n+\t/* Make sure pin is supported */\n+\tif ((config->common.port_pin_mask & BIT(pin)) == 0) {\n+\t\treturn -ENOTSUP;\n+\t}\n+\n \tirqs = 0; /* only irq0 is used for irq */\n \n \tif (mode == GPIO_INT_MODE_DISABLED) {\n@@ -284,14 +283,10 @@ static const struct gpio_driver_api mcux_rgpio_driver_api = {\n #define MCUX_RGPIO_PIN_DECLARE(n)\t\t\t\t\t\t\\\n \tconst struct pinctrl_soc_pinmux mcux_rgpio_pinmux_##n[] = {\t\t\\\n \t\tDT_FOREACH_PROP_ELEM(DT_DRV_INST(n), pinmux, PINMUX_INIT)\t\\\n-\t};\t\t\t\t\t\t\t\t\t\\\n-\tconst uint8_t mcux_rgpio_pin_gaps_##n[] =\t\t\t\t\\\n-\t\tDT_INST_PROP_OR(n, gpio_reserved_ranges, {});\n+\t};\n #define MCUX_RGPIO_PIN_INIT(n)\t\t\t\t\t\t\t\\\n \t.pin_muxes = mcux_rgpio_pinmux_##n,\t\t\t\t\t\\\n-\t.pin_gaps = (const struct gpio_pin_gaps *)mcux_rgpio_pin_gaps_##n,\t\\\n-\t.mux_count = DT_PROP_LEN(DT_DRV_INST(n), pinmux),\t\t\t\\\n-\t.gap_count = (ARRAY_SIZE(mcux_rgpio_pin_gaps_##n) / 2)\n+\t.mux_count = DT_PROP_LEN(DT_DRV_INST(n), pinmux),\n \n #define MCUX_RGPIO_IRQ_INIT(n, i)\t\t\t\t\t\\\n \tdo {\t\t\t\t\t\t\t\t\\\n@@ -307,9 +302,10 @@ static const struct gpio_driver_api mcux_rgpio_driver_api = {\n \tMCUX_RGPIO_PIN_DECLARE(n)\t\t\t\t\t\\\n \tstatic int mcux_rgpio_##n##_init(const struct device *dev);\t\\\n \t\t\t\t\t\t\t\t\t\\\n-\tstatic const struct mcux_rgpio_config mcux_rgpio_##n##_config = {\\\n+\tstatic const struct mcux_rgpio_config mcux_rgpio_##n##_config = { \\\n \t\t.common = {\t\t\t\t\t\t\\\n-\t\t\t.port_pin_mask = GPIO_PORT_PIN_MASK_FROM_DT_INST(n),\\\n+\t\t\t.port_pin_mask = GPIO_DT_INST_PORT_PIN_MASK_NGPIOS_EXC( \\\n+\t\t\t\t\tn, DT_INST_PROP(n, ngpios)) \\\n \t\t},\t\t\t\t\t\t\t\\\n \t\tDEVICE_MMIO_NAMED_ROM_INIT(reg_base, DT_DRV_INST(n)), \\\n \t\tMCUX_RGPIO_PIN_INIT(n)\t\t\t\t\t\\"
},{
  "instruction": "samples: drivers: video: add arduino nicla vision",
  "input": "\tstruct video_buffer *buffers[2], *vbuf;",
  "result": "diff --git a/samples/drivers/video/capture/README.rst b/samples/drivers/video/capture/README.rst\nindex eace71ecff0..22634811a4e 100644\n--- a/samples/drivers/video/capture/README.rst\n+++ b/samples/drivers/video/capture/README.rst\n@@ -24,6 +24,9 @@ Supported camera modules on some i.MX RT boards can be found below.\n - :ref:`mimxrt1170_evk`\n - `OV5640 camera module`_\n \n+Also :ref:`arduino_nicla_vision_board` can be used in this sample as capture device, in that case\n+The user can transfer the captured frames through on board USB.\n+\n Wiring\n ******\n \n@@ -35,6 +38,8 @@ On :ref:`mimxrt1170_evk`, the OV5640 camera module should be plugged into the\n J2 camera connector. A USB cable should be connected from a host to the micro\n USB debug connector (J11) in order to get console output via the daplink interface.\n \n+For :ref:`arduino_nicla_vision_board` there is no extra wiring required.\n+\n Building and Running\n ********************\n \n@@ -56,6 +61,14 @@ For :ref:`mimxrt1170_evk`, build this sample application with the following comm\n    :goals: build\n    :compact:\n \n+For :ref:`arduino_nicla_vision_board`, build this sample application with the following commands:\n+\n+.. zephyr-app-commands::\n+   :zephyr-app: samples/drivers/video/capture\n+   :board: arduino_nicla_vision/stm32h747xx/m7\n+   :goals: build\n+   :compact:\n+\n For testing purpose without the need of any real video capture and/or display hardwares,\n a video software pattern generator is supported by the above build commands without\n specifying the shields.\ndiff --git a/samples/drivers/video/capture/boards/arduino_nicla_vision_stm32h747xx_m7.conf b/samples/drivers/video/capture/boards/arduino_nicla_vision_stm32h747xx_m7.conf\nnew file mode 100644\nindex 00000000000..6ae5e7da478\n--- /dev/null\n+++ b/samples/drivers/video/capture/boards/arduino_nicla_vision_stm32h747xx_m7.conf\n@@ -0,0 +1,15 @@\n+CONFIG_VIDEO_BUFFER_POOL_NUM_MAX=1\n+CONFIG_VIDEO_BUFFER_POOL_SZ_MAX=160000\n+CONFIG_DMA=y\n+\n+# Arduino Nicla Vision has easy access to the USB console\n+# So use it to check the log messages\n+CONFIG_USB_DEVICE_STACK=y\n+CONFIG_USB_WORKQUEUE_STACK_SIZE=8192\n+CONFIG_USB_DEVICE_INITIALIZE_AT_BOOT=y\n+CONFIG_MAIN_STACK_SIZE=4096\n+\n+CONFIG_SERIAL=y\n+CONFIG_CONSOLE=y\n+CONFIG_UART_CONSOLE=y\n+CONFIG_UART_LINE_CTRL=y\ndiff --git a/samples/drivers/video/capture/boards/arduino_nicla_vision_stm32h747xx_m7.overlay b/samples/drivers/video/capture/boards/arduino_nicla_vision_stm32h747xx_m7.overlay\nnew file mode 100644\nindex 00000000000..93a64c17d7e\n--- /dev/null\n+++ b/samples/drivers/video/capture/boards/arduino_nicla_vision_stm32h747xx_m7.overlay\n@@ -0,0 +1,18 @@\n+/*\n+ * Copyright 2024 Felipe Neves\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+/ {\n+\tchosen {\n+\t\tzephyr,console = &cdc_acm_uart0;\n+\t\tzephyr,shell-uart = &cdc_acm_uart0;\n+\t};\n+};\n+\n+zephyr_udc0: &usbotg_hs {\n+\tstatus = \"okay\";\n+\tcdc_acm_uart0: cdc_acm_uart0 {\n+\t\tcompatible = \"zephyr,cdc-acm-uart\";\n+\t};\n+};\ndiff --git a/samples/drivers/video/capture/sample.yaml b/samples/drivers/video/capture/sample.yaml\nindex 4426202a691..6d3724b106f 100644\n--- a/samples/drivers/video/capture/sample.yaml\n+++ b/samples/drivers/video/capture/sample.yaml\n@@ -20,6 +20,7 @@ tests:\n         - \"size\"\n         - \"timestamp\"\n     platform_allow:\n+      - arduino_nicla_vision/stm32h747xx/m7\n       - mimxrt1064_evk\n       - mimxrt1170_evk/mimxrt1176/cm7\n       - mm_swiftio\ndiff --git a/samples/drivers/video/capture/src/main.c b/samples/drivers/video/capture/src/main.c\nindex 862dff287f7..d04d0de0954 100644\n--- a/samples/drivers/video/capture/src/main.c\n+++ b/samples/drivers/video/capture/src/main.c\n@@ -75,7 +75,7 @@ static inline void video_display_frame(const struct device *const display_dev,\n \n int main(void)\n {\n-\tstruct video_buffer *buffers[2], *vbuf;\n+\tstruct video_buffer *buffers[CONFIG_VIDEO_BUFFER_POOL_NUM_MAX], *vbuf;\n \tstruct video_format fmt;\n \tstruct video_caps caps;\n \tunsigned int frame = 0;"
},{
  "instruction": "drivers: video: gc2145: add resolution support",
  "input": "#define GC2145_VIDEO_FORMAT_CAP(width, height, format) \\\n\t{                                              \\\n\t.pixelformat = format,                         \\\n\t.width_min = width,                            \\\n\t.width_max = width,                            \\\n\t.height_min = height,                          \\\n\t.height_max = height,                          \\\n\t.width_step = 0,                               \\\n\t.height_step = 0,                              \\\n\tGC2145_VIDEO_FORMAT_CAP(1600, 1200, VIDEO_PIX_FMT_RGB565), /* UXGA  */\n\t{0},\nstatic int gc2145_set_resolution(const struct device *dev, uint16_t img_width, uint16_t img_height)\n\tuint16_t win_w = UXGA_HSIZE + 16;\n\tuint16_t win_h = UXGA_VSIZE + 8;\n\tuint16_t c_ratio = 1;\n\tuint16_t r_ratio = 1;\n\tuint16_t x = (((win_w / c_ratio) - UXGA_HSIZE) / 2);\n\tuint16_t y = (((win_h / r_ratio) - UXGA_VSIZE) / 2);\n\tuint16_t win_x = ((UXGA_HSIZE - win_w) / 2);\n\tuint16_t win_y = ((UXGA_VSIZE - win_h) / 2);\n\tret = gc2145_set_window(dev, GC2145_REG_BLANK_WINDOW_BASE, win_x, win_y, win_w, win_h);\n\tret = gc2145_set_window(dev, GC2145_REG_WINDOW_BASE, x, y, 1, 1);\n\t\tLOG_ERR(\"failed to detect GC2145 pid: 0x%x rev: 0x%x\", reg_pid_val, reg_ver_val);\n\t\treturn -EIO;\n\t\t\tret = gc2145_set_resolution(dev, fmt->width, fmt->height);\n\t/* set default/init format SVGA RGB565 */\n\tfmt.width = UXGA_HSIZE;\n\tfmt.height = UXGA_VSIZE;\n\tfmt.pitch = UXGA_HSIZE * 2;",
  "result": "diff --git a/drivers/video/gc2145.c b/drivers/video/gc2145.c\nindex 19404c27e9c..0c8a0ad113c 100644\n--- a/drivers/video/gc2145.c\n+++ b/drivers/video/gc2145.c\n@@ -689,20 +689,24 @@ struct gc2145_data {\n \tstruct video_format fmt;\n };\n \n-#define GC2145_VIDEO_FORMAT_CAP(width, height, format) \\\n-\t{                                              \\\n-\t.pixelformat = format,                         \\\n-\t.width_min = width,                            \\\n-\t.width_max = width,                            \\\n-\t.height_min = height,                          \\\n-\t.height_max = height,                          \\\n-\t.width_step = 0,                               \\\n-\t.height_step = 0,                              \\\n+#define GC2145_VIDEO_FORMAT_CAP(width, height, format)                                             \\\n+\t{                                                                                          \\\n+\t\t.pixelformat = format, .width_min = width, .width_max = width,                     \\\n+\t\t.height_min = height, .height_max = height, .width_step = 0, .height_step = 0,     \\\n \t}\n \n+enum resolutions {\n+\tQVGA_RESOLUTION = 0,\n+\tVGA_RESOLUTION,\n+\tUXGA_RESOLUTION,\n+\tRESOLUTIONS_MAX,\n+};\n+\n static const struct video_format_cap fmts[] = {\n-\tGC2145_VIDEO_FORMAT_CAP(1600, 1200, VIDEO_PIX_FMT_RGB565), /* UXGA  */\n-\t{0},\n+\t[QVGA_RESOLUTION] = GC2145_VIDEO_FORMAT_CAP(320, 240, VIDEO_PIX_FMT_RGB565),   /* QVGA */\n+\t[VGA_RESOLUTION] = GC2145_VIDEO_FORMAT_CAP(640, 480, VIDEO_PIX_FMT_RGB565),    /* VGA  */\n+\t[UXGA_RESOLUTION] = GC2145_VIDEO_FORMAT_CAP(1600, 1200, VIDEO_PIX_FMT_RGB565), /* UXGA */\n+\t[RESOLUTIONS_MAX] = {0},\n };\n \n static int gc2145_write_reg(const struct i2c_dt_spec *spec, uint8_t reg_addr, uint8_t value)\n@@ -901,28 +905,65 @@ static int gc2145_set_output_format(const struct device *dev, int output_format)\n \treturn 0;\n }\n \n-static int gc2145_set_resolution(const struct device *dev, uint16_t img_width, uint16_t img_height)\n+static int gc2145_set_resolution(const struct device *dev, enum resolutions res)\n {\n \tint ret;\n \tconst struct gc2145_config *cfg = dev->config;\n \n-\tuint16_t win_w = UXGA_HSIZE + 16;\n-\tuint16_t win_h = UXGA_VSIZE + 8;\n-\tuint16_t c_ratio = 1;\n-\tuint16_t r_ratio = 1;\n-\tuint16_t x = (((win_w / c_ratio) - UXGA_HSIZE) / 2);\n-\tuint16_t y = (((win_h / r_ratio) - UXGA_VSIZE) / 2);\n-\tuint16_t win_x = ((UXGA_HSIZE - win_w) / 2);\n-\tuint16_t win_y = ((UXGA_VSIZE - win_h) / 2);\n+\tuint16_t w;\n+\tuint16_t h;\n+\tuint16_t win_w;\n+\tuint16_t win_h;\n+\tuint16_t c_ratio;\n+\tuint16_t r_ratio;\n+\tuint16_t x;\n+\tuint16_t y;\n+\tuint16_t win_x;\n+\tuint16_t win_y;\n+\n+\tif (res >= RESOLUTIONS_MAX) {\n+\t\treturn -EIO;\n+\t}\n+\n+\tw = fmts[res].width_min;\n+\th = fmts[res].height_min;\n+\n+\t/* Add the subsampling factor depending on resolution */\n+\tswitch (res) {\n+\tcase QVGA_RESOLUTION:\n+\t\tc_ratio = 3;\n+\t\tr_ratio = 3;\n+\t\tbreak;\n+\tcase VGA_RESOLUTION:\n+\t\tc_ratio = 2;\n+\t\tr_ratio = 2;\n+\t\tbreak;\n+\tcase UXGA_RESOLUTION:\n+\t\tc_ratio = 1;\n+\t\tr_ratio = 1;\n+\t\tbreak;\n+\tdefault:\n+\t\tLOG_ERR(\"Unsupported resolution %d\", res);\n+\t\treturn -EIO;\n+\t};\n+\n+\t/* Calculates the window boundaries to obtain the desired resolution */\n+\twin_w = w * c_ratio;\n+\twin_h = h * r_ratio;\n+\tx = (((win_w / c_ratio) - w) / 2);\n+\ty = (((win_h / r_ratio) - h) / 2);\n+\twin_x = ((UXGA_HSIZE - win_w) / 2);\n+\twin_y = ((UXGA_VSIZE - win_h) / 2);\n \n \t/* Set readout window first. */\n-\tret = gc2145_set_window(dev, GC2145_REG_BLANK_WINDOW_BASE, win_x, win_y, win_w, win_h);\n+\tret = gc2145_set_window(dev, GC2145_REG_BLANK_WINDOW_BASE, win_x, win_y, win_w + 16,\n+\t\t\t\twin_h + 8);\n \tif (ret < 0) {\n \t\treturn ret;\n \t}\n \n \t/* Set cropping window next. */\n-\tret = gc2145_set_window(dev, GC2145_REG_WINDOW_BASE, x, y, 1, 1);\n+\tret = gc2145_set_window(dev, GC2145_REG_WINDOW_BASE, x, y, w, h);\n \tif (ret < 0) {\n \t\treturn ret;\n \t}\n@@ -972,8 +1013,7 @@ static uint8_t gc2145_check_connection(const struct device *dev)\n \t}\n \n \tif ((reg_ver_val != GC2145_REV_VAL) || (reg_pid_val != GC2145_PID_VAL)) {\n-\t\tLOG_ERR(\"failed to detect GC2145 pid: 0x%x rev: 0x%x\", reg_pid_val, reg_ver_val);\n-\t\treturn -EIO;\n+\t\tLOG_WRN(\"Unexpected GC2145 pid: 0x%x or rev: 0x%x\", reg_pid_val, reg_ver_val);\n \t}\n \n \treturn 0;\n@@ -1014,7 +1054,7 @@ static int gc2145_set_fmt(const struct device *dev, enum video_endpoint_id ep,\n \t\tif (fmts[i].width_min == width && fmts[i].height_min == height &&\n \t\t    fmts[i].pixelformat == fmt->pixelformat) {\n \t\t\t/* Set window size */\n-\t\t\tret = gc2145_set_resolution(dev, fmt->width, fmt->height);\n+\t\t\tret = gc2145_set_resolution(dev, (enum resolutions)i);\n \t\t\tif (ret < 0) {\n \t\t\t\tLOG_ERR(\"Failed to set the resolution\");\n \t\t\t}\n@@ -1105,11 +1145,12 @@ static int gc2145_init(const struct device *dev)\n \tgc2145_soft_reset(dev);\n \tgc2145_write_all(dev, default_regs, ARRAY_SIZE(default_regs));\n \n-\t/* set default/init format SVGA RGB565 */\n+\t/* set default/init format QVGA RGB565 */\n \tfmt.pixelformat = VIDEO_PIX_FMT_RGB565;\n-\tfmt.width = UXGA_HSIZE;\n-\tfmt.height = UXGA_VSIZE;\n-\tfmt.pitch = UXGA_HSIZE * 2;\n+\tfmt.width = fmts[QVGA_RESOLUTION].width_min;\n+\tfmt.height = fmts[QVGA_RESOLUTION].height_min;\n+\tfmt.pitch = fmts[QVGA_RESOLUTION].width_min * 2;\n+\n \tret = gc2145_set_fmt(dev, VIDEO_EP_OUT, &fmt);\n \tif (ret) {\n \t\tLOG_ERR(\"Unable to configure default format\");"
},{
  "instruction": "boards: arduino_nicla_vision: add camera subsystem",
  "input": "&i2c3 {\n\tstatus = \"okay\";\n\tpinctrl-0 = <&i2c3_scl_pa8 &i2c3_sda_pc9>;\n\tpinctrl-names = \"default\";\n\tclock-frequency = <I2C_BITRATE_FAST>;\n};",
  "result": "diff --git a/boards/arduino/nicla_vision/CMakeLists.txt b/boards/arduino/nicla_vision/CMakeLists.txt\nnew file mode 100644\nindex 00000000000..31b0b2ec593\n--- /dev/null\n+++ b/boards/arduino/nicla_vision/CMakeLists.txt\n@@ -0,0 +1,4 @@\n+# Copyright 2024 Felipe Neves\n+# SPDX-License-Identifier: Apache-2.0\n+\n+zephyr_sources_ifdef(CONFIG_VIDEO camera_ext_clock.c)\ndiff --git a/boards/arduino/nicla_vision/arduino_nicla_vision_stm32h747xx_m7.dts b/boards/arduino/nicla_vision/arduino_nicla_vision_stm32h747xx_m7.dts\nindex ffd72fe9fb7..1fe8d2f9610 100644\n--- a/boards/arduino/nicla_vision/arduino_nicla_vision_stm32h747xx_m7.dts\n+++ b/boards/arduino/nicla_vision/arduino_nicla_vision_stm32h747xx_m7.dts\n@@ -22,6 +22,7 @@\n \t\tzephyr,sram = &sram0;\n \t\tzephyr,flash = &flash0;\n \t\tzephyr,code-partition = &slot0_partition;\n+\t\tzephyr,camera = &dcmi;\n \t};\n \n \tsdram1: sdram@c0000000 {\n@@ -122,13 +123,6 @@\n \t};\n };\n \n-&i2c3 {\n-\tstatus = \"okay\";\n-\tpinctrl-0 = <&i2c3_scl_pa8 &i2c3_sda_pc9>;\n-\tpinctrl-names = \"default\";\n-\tclock-frequency = <I2C_BITRATE_FAST>;\n-};\n-\n &spi4 {\n \tstatus = \"okay\";\n \tpinctrl-0 = <&spi4_nss_pe11 &spi4_sck_pe12\n@@ -192,3 +186,81 @@ zephyr_udc0: &usbotg_hs {\n \tphys = <&otghs_ulpi_phy>;\n \tstatus = \"okay\";\n };\n+\n+&i2c3 {\n+\tstatus = \"okay\";\n+\tpinctrl-0 = <&i2c3_scl_pa8 &i2c3_sda_pc9>;\n+\tpinctrl-names = \"default\";\n+\tclock-frequency = <I2C_BITRATE_FAST>;\n+\n+\tgc2145: gc2145@3c {\n+\t\tcompatible = \"galaxycore,gc2145\";\n+\t\treg = <0x3c>;\n+\t\tstatus = \"okay\";\n+\n+\t\tport {\n+\t\t\tgc2145_ep_out: endpoint {\n+\t\t\t\tremote-endpoint = <&dcmi_ep_in>;\n+\t\t\t};\n+\t\t};\n+\n+\t};\n+};\n+\n+&dcmi {\n+\tpinctrl-0 = <&dcmi_d0_pc6 &dcmi_d1_pc7 &dcmi_d2_pe0 &dcmi_d3_pe1\n+\t\t     &dcmi_d4_pe4 &dcmi_d5_pd3 &dcmi_d6_pe5 &dcmi_d7_pe6\n+\t\t     &dcmi_pixclk_pa6 &dcmi_hsync_pa4 &dcmi_vsync_pg9>;\n+\n+\tpinctrl-names = \"default\";\n+\tstatus = \"okay\";\n+\n+\tsensor = <&gc2145>;\n+\tbus-width = <8>;\n+\thsync-active = <0>;\n+\tvsync-active = <0>;\n+\tpixelclk-active = <0>;\n+\tcapture-rate = <1>;\n+\tdmas = <&dma1 0 38 (STM32_DMA_PERIPH_TO_MEMORY | STM32_DMA_PERIPH_NO_INC |\n+\t\tSTM32_DMA_MEM_INC | STM32_DMA_PERIPH_8BITS | STM32_DMA_MEM_32BITS |\n+\t\tSTM32_DMA_PRIORITY_HIGH) STM32_DMA_FIFO_1_4>;\n+\n+\tport {\n+\t\tdcmi_ep_in: endpoint {\n+\t\t\tremote-endpoint = <&gc2145_ep_out>;\n+\t\t};\n+\t};\n+};\n+\n+/* The Arduino nicla uses a PWM output to generate the clock for the\n+ * GC2145 sensor, so we need to configure the PWM generator...\n+ */\n+&timers3 {\n+\tstatus = \"okay\";\n+\tst,prescaler = <0>;\n+\n+\tcam_clock_pwm: pwm {\n+\t\tstatus = \"okay\";\n+\t\tpinctrl-0 = <&tim3_ch2_pa7>;\n+\t\tpinctrl-names = \"default\";\n+\t};\n+};\n+\n+&cam_clock_pwm {\n+\t/* ...then use the pwmclock node to start the clock generation */\n+\tpwmclock: pwmclock {\n+\t\tstatus = \"okay\";\n+\t\tcompatible = \"pwm-clock\";\n+\t\tclock-frequency = <0>;\n+\t\t#clock-cells = <1>;\n+\t\tpwms = <&cam_clock_pwm 2 PWM_HZ(10000000) PWM_POLARITY_NORMAL>;\n+\t};\n+};\n+\n+&dma1 {\n+\tstatus = \"okay\";\n+};\n+\n+&dmamux1 {\n+\tstatus = \"okay\";\n+};\ndiff --git a/boards/arduino/nicla_vision/camera_ext_clock.c b/boards/arduino/nicla_vision/camera_ext_clock.c\nnew file mode 100644\nindex 00000000000..82b3695feb7\n--- /dev/null\n+++ b/boards/arduino/nicla_vision/camera_ext_clock.c\n@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2024 Felipe Neves\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+#include <zephyr/kernel.h>\n+#include <zephyr/device.h>\n+#include <zephyr/drivers/clock_control.h>\n+#include <zephyr/logging/log.h>\n+\n+LOG_MODULE_REGISTER(camera_ext_clock, CONFIG_CLOCK_CONTROL_LOG_LEVEL);\n+\n+int camera_ext_clock_enable(void)\n+{\n+\tint ret;\n+\tuint32_t rate;\n+\tconst struct device *cam_ext_clk_dev = DEVICE_DT_GET(DT_NODELABEL(pwmclock));\n+\n+\tif (!device_is_ready(cam_ext_clk_dev)) {\n+\t\tLOG_ERR(\"Camera external clock source device is not ready!\");\n+\t\treturn -ENODEV;\n+\t}\n+\n+\tret = clock_control_on(cam_ext_clk_dev, (clock_control_subsys_t)0);\n+\tif (ret < 0) {\n+\t\tLOG_ERR(\"Failed to enable camera external clock error: (%d)\", ret);\n+\t\treturn ret;\n+\t}\n+\n+\tret = clock_control_get_rate(cam_ext_clk_dev, (clock_control_subsys_t)0, &rate);\n+\tif (ret < 0) {\n+\t\tLOG_ERR(\"Failed to get camera external clock rate, error: (%d)\", ret);\n+\t\treturn ret;\n+\t}\n+\n+\tLOG_INF(\"Camera external clock rate: (%u) Hz\", rate);\n+\n+\treturn 0;\n+}\n+\n+SYS_INIT(camera_ext_clock_enable, POST_KERNEL, CONFIG_CLOCK_CONTROL_PWM_INIT_PRIORITY);\ndiff --git a/boards/arduino/nicla_vision/doc/index.rst b/boards/arduino/nicla_vision/doc/index.rst\nindex fac12f25fac..73b2d7cd733 100644\n--- a/boards/arduino/nicla_vision/doc/index.rst\n+++ b/boards/arduino/nicla_vision/doc/index.rst\n@@ -61,6 +61,8 @@ following hardware features:\n +-----------+------------+-------------------------------------+\n | SPI       | on-chip    | spi                                 |\n +-----------+------------+-------------------------------------+\n+| DCMI      | on-chip    | Parallel Camera interface           |\n++-----------+------------+-------------------------------------+\n | IPM       | on-chip    | virtual mailbox based on HSEM       |\n +-----------+------------+-------------------------------------+\n | RADIO     | Murata 1DX | WiFi and Bluetooth module           |"
},{
  "instruction": "logging: frontend: stmesp_demux: Improve robustness",
  "input": "",
  "result": "diff --git a/subsys/logging/frontends/Kconfig b/subsys/logging/frontends/Kconfig\nindex e5c3870b1b6..9d4b7a43797 100644\n--- a/subsys/logging/frontends/Kconfig\n+++ b/subsys/logging/frontends/Kconfig\n@@ -95,6 +95,12 @@ config LOG_FRONTEND_STMESP_DEMUX_BUFFER_SIZE\n config LOG_FRONTEND_STMESP_DEMUX_MAX_UTILIZATION\n \tbool \"Track maximum utilization\"\n \n+config LOG_FRONTEND_STMESP_DEMUX_GC_TIMEOUT\n+\tint \"Message timeout (in milliseconds)\"\n+\tdefault 100\n+\thelp\n+\t  If log message is not completed within that time frame it is discarded.\n+\n endif # LOG_FRONTEND_STMESP_DEMUX\n \n config LOG_FRONTEND_STMESP_FLUSH_PORT_ID\ndiff --git a/subsys/logging/frontends/log_frontend_stmesp_demux.c b/subsys/logging/frontends/log_frontend_stmesp_demux.c\nindex ed09f89ec8e..a3c052eab25 100644\n--- a/subsys/logging/frontends/log_frontend_stmesp_demux.c\n+++ b/subsys/logging/frontends/log_frontend_stmesp_demux.c\n@@ -25,6 +25,7 @@ BUILD_ASSERT(sizeof(struct log_frontend_stmesp_demux_log_header) == sizeof(uint3\n struct log_frontend_stmesp_demux_active_entry {\n \tsys_snode_t node;\n \tuint32_t m_ch;\n+\tuint32_t ts;\n \tstruct log_frontend_stmesp_demux_log *packet;\n \tint off;\n };\n@@ -221,6 +222,36 @@ static void log_frontend_stmesp_demux_hw_event(uint64_t *ts, uint8_t data)\n \tmpsc_pbuf_put_data(&demux.pbuf, (const uint32_t *)&packet, wlen);\n }\n \n+/* Check if there are any active messages which are not completed for a significant\n+ * amount of time. It may indicate that part of message was lost (due to reset,\n+ * fault in the core or fault on the bus). In that case message shall be closed as\n+ * incomplete to not block processing of other messages.\n+ */\n+static void garbage_collector(uint32_t now)\n+{\n+\tsys_snode_t *node;\n+\n+\tSYS_SLIST_FOR_EACH_NODE(&demux.active_entries, node) {\n+\t\tstruct log_frontend_stmesp_demux_active_entry *entry =\n+\t\t\tCONTAINER_OF(node, struct log_frontend_stmesp_demux_active_entry, node);\n+\n+\t\tif ((now - entry->ts) > CONFIG_LOG_FRONTEND_STMESP_DEMUX_GC_TIMEOUT) {\n+\t\t\tunion log_frontend_stmesp_demux_packet p = {.log = entry->packet};\n+\n+\t\t\tsys_slist_find_and_remove(&demux.active_entries, node);\n+\t\t\tentry->packet->content_invalid = 1;\n+\t\t\tmpsc_pbuf_commit(&demux.pbuf, p.generic);\n+\t\t\tdemux.dropped++;\n+\t\t\tk_mem_slab_free(&demux.mslab, entry);\n+\t\t\t/* After removing one we need to stop as removing disrupts\n+\t\t\t * iterating over the list as current node is no longer in\n+\t\t\t * the list.\n+\t\t\t */\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+}\n+\n int log_frontend_stmesp_demux_packet_start(uint32_t *data, uint64_t *ts)\n {\n \tif (skip) {\n@@ -265,9 +296,10 @@ int log_frontend_stmesp_demux_packet_start(uint32_t *data, uint64_t *ts)\n \tunion log_frontend_stmesp_demux_header hdr = {.raw = *data};\n \tuint32_t pkt_len = hdr.log.total_len + offsetof(struct log_frontend_stmesp_demux_log, data);\n \tuint32_t wlen = calc_wlen(pkt_len);\n+\tuint32_t now = k_uptime_get_32();\n \n+\tgarbage_collector(now);\n \terr = k_mem_slab_alloc(&demux.mslab, (void **)&entry, K_NO_WAIT);\n-\n \tif (err < 0) {\n \t\tgoto on_nomem;\n \t}\n@@ -288,6 +320,7 @@ int log_frontend_stmesp_demux_packet_start(uint32_t *data, uint64_t *ts)\n \t}\n \tentry->packet->hdr = hdr.log;\n \tentry->packet->hdr.major = m;\n+\tentry->ts = now;\n \tdemux.curr = entry;\n \tsys_slist_append(&demux.active_entries, &entry->node);\n "
},{
  "instruction": "logging: frontend_stmesp: Avoid unaligned word access",
  "input": "\tuint32_t *p32 = (uint32_t *)data;\n\tuint8_t *p8 = (uint8_t *)p32;\n\twhile (len > 0) {\n\t\tSTM_D8(stm_esp, *p8++, false, false);\n\t\tlen--;",
  "result": "diff --git a/subsys/logging/frontends/log_frontend_stmesp.c b/subsys/logging/frontends/log_frontend_stmesp.c\nindex e1d3a7a7e8b..4042fac853c 100644\n--- a/subsys/logging/frontends/log_frontend_stmesp.c\n+++ b/subsys/logging/frontends/log_frontend_stmesp.c\n@@ -33,6 +33,10 @@ BUILD_ASSERT(sizeof(void *) == sizeof(uint32_t));\n \tstmesp_data8(reg, data, timestamp, marked,                                                 \\\n \t\t     IS_ENABLED(CONFIG_LOG_FRONTEND_STMESP_GUARANTEED_ACCESS))\n \n+#define STM_D16(reg, data, timestamp, marked)                                                      \\\n+\tstmesp_data16(reg, data, timestamp, marked,                                                \\\n+\t\t      IS_ENABLED(CONFIG_LOG_FRONTEND_STMESP_GUARANTEED_ACCESS))\n+\n #define STM_D32(reg, data, timestamp, marked)                                                      \\\n \tstmesp_data32(reg, data, timestamp, marked,                                                \\\n \t\t      IS_ENABLED(CONFIG_LOG_FRONTEND_STMESP_GUARANTEED_ACCESS))\n@@ -211,18 +215,72 @@ static int early_package_cb(const void *buf, size_t len, void *ctx)\n \n static inline void write_data(const void *data, size_t len, STMESP_Type *const stm_esp)\n {\n-\tuint32_t *p32 = (uint32_t *)data;\n+\tconst uint8_t *p8 = data;\n+\tconst uint32_t *p32;\n+\tuint32_t unaligned;\n+\n+\tif (!len) {\n+\t\treturn;\n+\t}\n \n+\t/* Start by writing using D8 or D16 until pointer is word aligned. */\n+\tunaligned = (uintptr_t)data & 0x00000003UL;\n+\tif (unaligned != 0) {\n+\t\tunaligned = 4 - unaligned;\n+\t\tunaligned = MIN(len, unaligned);\n+\n+\t\tlen -= unaligned;\n+\n+\t\tswitch (unaligned) {\n+\t\tcase 3:\n+\t\t\tSTM_D8(stm_esp, *p8++, false, false);\n+\t\t\tSTM_D16(stm_esp, *(uint16_t *)p8, false, false);\n+\t\t\tp8 += sizeof(uint16_t);\n+\t\t\tbreak;\n+\t\tcase 2:\n+\t\t\tif (len) {\n+\t\t\t\tSTM_D16(stm_esp, *(uint16_t *)p8, false, false);\n+\t\t\t\tp8 += sizeof(uint16_t);\n+\t\t\t} else {\n+\t\t\t\t/* If len 0 then it means that even though 2 bytes are\n+\t\t\t\t * to be copied we can have address which is not aligned\n+\t\t\t\t * to 2 bytes.\n+\t\t\t\t */\n+\t\t\t\tSTM_D8(stm_esp, *p8++, false, false);\n+\t\t\t\tSTM_D8(stm_esp, *p8++, false, false);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\t/* 1 byte to align. */\n+\t\t\tSTM_D8(stm_esp, *p8++, false, false);\n+\t\t}\n+\t}\n+\n+\tp32 = (const uint32_t *)p8;\n+\n+\t/* Use D32 to write as much data as possible. */\n \twhile (len >= sizeof(uint32_t)) {\n \t\tSTM_D32(stm_esp, *p32++, false, false);\n \t\tlen -= sizeof(uint32_t);\n \t}\n \n-\tuint8_t *p8 = (uint8_t *)p32;\n-\n-\twhile (len > 0) {\n-\t\tSTM_D8(stm_esp, *p8++, false, false);\n-\t\tlen--;\n+\t/* Write tail using D16 or D8. Address is word aligned at that point. */\n+\tif (len) {\n+\t\tp8 = (const uint8_t *)p32;\n+\t\tswitch (len) {\n+\t\tcase 2:\n+\t\t\tSTM_D16(stm_esp, *(uint16_t *)p8, false, false);\n+\t\t\tp8 += sizeof(uint16_t);\n+\t\t\tbreak;\n+\t\tcase 3:\n+\t\t\tSTM_D16(stm_esp, *(uint16_t *)p8, false, false);\n+\t\t\tp8 += sizeof(uint16_t);\n+\t\t\t/* fallthrough */\n+\t\tdefault:\n+\t\t\t/* 1 byte to align. */\n+\t\t\tSTM_D8(stm_esp, *p8++, false, false);\n+\t\t\tbreak;\n+\t\t}\n \t}\n }\n "
},{
  "instruction": "logging: frontends: stmesp: Run clang-format",
  "input": "#define STM_FLAG(reg) \\\n#define STM_D8(reg, data, timestamp, marked)       \\\n\tstmesp_data8(reg, data, timestamp, marked, \\\n#define STM_D32(reg, data, timestamp, marked)       \\\n\tstmesp_data32(reg, data, timestamp, marked, \\\n\t\t.hdr = {.ver = CONFIG_LOG_FRONTEND_STMESP_DICT_VER,                         \\\n\tstatic const uint32_t flags = CBPRINTF_PACKAGE_CONVERT_RW_STR |\n\t\t\t\t      CBPRINTF_PACKAGE_CONVERT_RO_STR;\n\tpackage_len = cbprintf_package_convert(package, desc.package_len, NULL, NULL, flags,\n\t\t\t\t\t       strl, ARRAY_SIZE(strl));\n\t\t(void)cbprintf_package_convert(package, desc.package_len,\n\t\t\t\t\t       package_cb, stm_esp, flags, strl, ARRAY_SIZE(strl));\n\t\t(void)cbprintf_package_convert(package, desc.package_len, early_package_cb,\n\t\t\t\t\t       NULL, flags, strl, ARRAY_SIZE(strl));\n\t\t(void)cbprintf_package_convert(package, desc.package_len, package_cb,\n\t\t\t\t\t       stm_esp, flags, NULL, 0);\n\t\t(void)cbprintf_package_convert(package, desc.package_len, early_package_cb,\n\t\t\t\t\t       NULL, flags, NULL, 0);\nstatic inline uint32_t *early_msg_start(uint32_t level, const void *source,\n\t\t\t\t\tuint32_t package_hdr, const char *fmt)\nstatic inline void msg_start(STMESP_Type *stm_esp, uint32_t level,\n\t\t\t     const void *source, uint32_t package_hdr, const char *fmt)",
  "result": "diff --git a/subsys/logging/frontends/log_frontend_stmesp.c b/subsys/logging/frontends/log_frontend_stmesp.c\nindex 389f0f72aeb..e1d3a7a7e8b 100644\n--- a/subsys/logging/frontends/log_frontend_stmesp.c\n+++ b/subsys/logging/frontends/log_frontend_stmesp.c\n@@ -26,15 +26,15 @@ BUILD_ASSERT(sizeof(void *) == sizeof(uint32_t));\n \n #define STMESP_FLUSH_WORD 0xaabbccdd\n \n-#define STM_FLAG(reg) \\\n+#define STM_FLAG(reg)                                                                              \\\n \tstmesp_flag(reg, 1, false, IS_ENABLED(CONFIG_LOG_FRONTEND_STMESP_GUARANTEED_ACCESS))\n \n-#define STM_D8(reg, data, timestamp, marked)       \\\n-\tstmesp_data8(reg, data, timestamp, marked, \\\n+#define STM_D8(reg, data, timestamp, marked)                                                       \\\n+\tstmesp_data8(reg, data, timestamp, marked,                                                 \\\n \t\t     IS_ENABLED(CONFIG_LOG_FRONTEND_STMESP_GUARANTEED_ACCESS))\n \n-#define STM_D32(reg, data, timestamp, marked)       \\\n-\tstmesp_data32(reg, data, timestamp, marked, \\\n+#define STM_D32(reg, data, timestamp, marked)                                                      \\\n+\tstmesp_data32(reg, data, timestamp, marked,                                                \\\n \t\t      IS_ENABLED(CONFIG_LOG_FRONTEND_STMESP_GUARANTEED_ACCESS))\n \n /* Buffer for storing frontend data before STM/ETR is ready for usage.\n@@ -95,7 +95,7 @@ union stm_log_dict_hdr {\n /* Dictionary header initializer. */\n #define DICT_HDR_INITIALIZER(_level, _source_id, _data_len)                                        \\\n \t{                                                                                          \\\n-\t\t.hdr = {.ver = CONFIG_LOG_FRONTEND_STMESP_DICT_VER,                         \\\n+\t\t.hdr = {.ver = CONFIG_LOG_FRONTEND_STMESP_DICT_VER,                                \\\n \t\t\t.type = STM_MSG_TYPE_LOG_DICT,                                             \\\n \t\t\t.level = _level,                                                           \\\n \t\t\t.data_len = _data_len,                                                     \\\n@@ -281,8 +281,8 @@ void log_frontend_msg(const void *source, const struct log_msg_desc desc, uint8_\n \tsize_t sname_len;\n \tint package_len;\n \tint total_len;\n-\tstatic const uint32_t flags = CBPRINTF_PACKAGE_CONVERT_RW_STR |\n-\t\t\t\t      CBPRINTF_PACKAGE_CONVERT_RO_STR;\n+\tstatic const uint32_t flags =\n+\t\tCBPRINTF_PACKAGE_CONVERT_RW_STR | CBPRINTF_PACKAGE_CONVERT_RO_STR;\n \n \tsname = log_source_name_get(0, get_source_id(source));\n \tif (sname) {\n@@ -293,8 +293,8 @@ void log_frontend_msg(const void *source, const struct log_msg_desc desc, uint8_\n \t}\n \ttotal_len = desc.data_len + sname_len /* null terminator */;\n \n-\tpackage_len = cbprintf_package_convert(package, desc.package_len, NULL, NULL, flags,\n-\t\t\t\t\t       strl, ARRAY_SIZE(strl));\n+\tpackage_len = cbprintf_package_convert(package, desc.package_len, NULL, NULL, flags, strl,\n+\t\t\t\t\t       ARRAY_SIZE(strl));\n \thdr.log.total_len = total_len + package_len;\n \thdr.log.package_len = package_len;\n \n@@ -308,8 +308,8 @@ void log_frontend_msg(const void *source, const struct log_msg_desc desc, uint8_\n \t\t}\n \n \t\tSTM_D32(stm_esp, hdr.raw, use_timestamp, true);\n-\t\t(void)cbprintf_package_convert(package, desc.package_len,\n-\t\t\t\t\t       package_cb, stm_esp, flags, strl, ARRAY_SIZE(strl));\n+\t\t(void)cbprintf_package_convert(package, desc.package_len, package_cb, stm_esp,\n+\t\t\t\t\t       flags, strl, ARRAY_SIZE(strl));\n \t\twrite_data(sname, sname_len, stm_esp);\n \t\tif (data) {\n \t\t\twrite_data(data, desc.data_len, stm_esp);\n@@ -327,8 +327,8 @@ void log_frontend_msg(const void *source, const struct log_msg_desc desc, uint8_\n \t\t}\n \n \t\tearly_buf_put_data((const uint8_t *)&hdr, sizeof(hdr));\n-\t\t(void)cbprintf_package_convert(package, desc.package_len, early_package_cb,\n-\t\t\t\t\t       NULL, flags, strl, ARRAY_SIZE(strl));\n+\t\t(void)cbprintf_package_convert(package, desc.package_len, early_package_cb, NULL,\n+\t\t\t\t\t       flags, strl, ARRAY_SIZE(strl));\n \t\tearly_buf_put_data(sname, sname_len);\n \t\tif (data) {\n \t\t\tearly_buf_put_data(data, desc.data_len);\n@@ -357,8 +357,8 @@ void log_frontend_msg(const void *source, const struct log_msg_desc desc, uint8_\n \t\t}\n \n \t\tSTM_D32(stm_esp, dict_desc.raw, true, true);\n-\t\t(void)cbprintf_package_convert(package, desc.package_len, package_cb,\n-\t\t\t\t\t       stm_esp, flags, NULL, 0);\n+\t\t(void)cbprintf_package_convert(package, desc.package_len, package_cb, stm_esp,\n+\t\t\t\t\t       flags, NULL, 0);\n \t\tif (data) {\n \t\t\tpackage_cb(data, desc.data_len, stm_esp);\n \t\t}\n@@ -370,8 +370,8 @@ void log_frontend_msg(const void *source, const struct log_msg_desc desc, uint8_\n \t\tkey = k_spin_lock(&lock);\n \t\tlen_loc = early_buf_len_loc();\n \t\tearly_package_cb(&dict_desc.raw, sizeof(dict_desc.raw), NULL);\n-\t\t(void)cbprintf_package_convert(package, desc.package_len, early_package_cb,\n-\t\t\t\t\t       NULL, flags, NULL, 0);\n+\t\t(void)cbprintf_package_convert(package, desc.package_len, early_package_cb, NULL,\n+\t\t\t\t\t       flags, NULL, 0);\n \t\tif (data) {\n \t\t\tearly_package_cb(data, desc.data_len, NULL);\n \t\t}\n@@ -383,8 +383,8 @@ void log_frontend_msg(const void *source, const struct log_msg_desc desc, uint8_\n /* Common function for optimized message (log with 0-2 arguments) which is used in\n  * case when STMESP is not yet ready.\n  */\n-static inline uint32_t *early_msg_start(uint32_t level, const void *source,\n-\t\t\t\t\tuint32_t package_hdr, const char *fmt)\n+static inline uint32_t *early_msg_start(uint32_t level, const void *source, uint32_t package_hdr,\n+\t\t\t\t\tconst char *fmt)\n {\n \tunion stm_log_dict_hdr dict_desc = DICT_HDR_INITIALIZER(level, get_source_id(source), 0);\n \tuint32_t fmt32 = (uint32_t)fmt;\n@@ -398,8 +398,8 @@ static inline uint32_t *early_msg_start(uint32_t level, const void *source,\n }\n \n /* Common function for optimized message (log with 0-2 arguments) which writes to STMESP */\n-static inline void msg_start(STMESP_Type *stm_esp, uint32_t level,\n-\t\t\t     const void *source, uint32_t package_hdr, const char *fmt)\n+static inline void msg_start(STMESP_Type *stm_esp, uint32_t level, const void *source,\n+\t\t\t     uint32_t package_hdr, const char *fmt)\n \n {\n \tunion stm_log_dict_hdr dict_desc = DICT_HDR_INITIALIZER(level, get_source_id(source), 0);"
},{
  "instruction": "boards: npcx_evb: update espi vw index for DnX",
  "input": "",
  "result": "diff --git a/boards/nuvoton/npcx4m8f_evb/npcx4m8f_evb.dts b/boards/nuvoton/npcx4m8f_evb/npcx4m8f_evb.dts\nindex 2993b816956..e175105a7e1 100644\n--- a/boards/nuvoton/npcx4m8f_evb/npcx4m8f_evb.dts\n+++ b/boards/nuvoton/npcx4m8f_evb/npcx4m8f_evb.dts\n@@ -7,6 +7,7 @@\n /dts-v1/;\n \n #include <nuvoton/npcx4m8f.dtsi>\n+#include <nuvoton/npcx/npcx-espi-vws-ex-map.dtsi>\n #include \"npcx4m8f_evb-pinctrl.dtsi\"\n \n / {\ndiff --git a/dts/arm/nuvoton/npcx/npcx-espi-vws-ex-map.dtsi b/dts/arm/nuvoton/npcx/npcx-espi-vws-ex-map.dtsi\nindex f01448b4e77..2d5cf414aa4 100644\n--- a/dts/arm/nuvoton/npcx/npcx-espi-vws-ex-map.dtsi\n+++ b/dts/arm/nuvoton/npcx/npcx-espi-vws-ex-map.dtsi\n@@ -24,6 +24,10 @@\n  *  [S] System-/[P] Platform-Specific Virtual Wires\n  */\n \n+&espi0 {\n+\tvw-index-extend-set = < ESPI_NPCX_VW_EX_VAL(1, 6, 0x4A) >;\n+};\n+\n / {\n \tnpcx-espi-vws-map {\n \t\t/* eSPI Virtual Vire (VW) input configuration */"
},{
  "instruction": "drivers: espi: npcx: add support to customize vw index",
  "input": "",
  "result": "diff --git a/drivers/espi/espi_npcx.c b/drivers/espi/espi_npcx.c\nindex feca4ad5099..67eee0f1baa 100644\n--- a/drivers/espi/espi_npcx.c\n+++ b/drivers/espi/espi_npcx.c\n@@ -52,6 +52,26 @@ struct espi_npcx_data {\n #endif\n };\n \n+#if DT_NODE_HAS_PROP(DT_DRV_INST(0), vw_index_extend_set)\n+struct espi_npcx_vw_ex {\n+\tuint8_t direction;\n+\tuint8_t group_num;\n+\tuint8_t index;\n+};\n+\n+/* n = node, p = property, i = index */\n+#define ESPI_NPCX_VW_EX_INFO(n, p, i)                                                              \\\n+\t{                                                                                          \\\n+\t\t.index = ESPI_NPCX_VW_EX_INDEX(DT_PROP_BY_IDX(n, p, i)),                           \\\n+\t\t.group_num = ESPI_NPCX_VW_EX_GROUP_NUM(DT_PROP_BY_IDX(n, p, i)),                   \\\n+\t\t.direction = ESPI_NPCX_VW_EX_DIR(DT_PROP_BY_IDX(n, p, i)),                         \\\n+\t},\n+\n+static const struct espi_npcx_vw_ex espi_npcx_vw_ex_0[] = {\n+\tDT_FOREACH_PROP_ELEM(DT_DRV_INST(0), vw_index_extend_set, ESPI_NPCX_VW_EX_INFO)\n+};\n+#endif\n+\n /* Driver convenience defines */\n #define HAL_INSTANCE(dev)                                                                          \\\n \t((struct espi_reg *)((const struct espi_npcx_config *)(dev)->config)->base)\n@@ -1421,6 +1441,38 @@ static int espi_npcx_init(const struct device *dev)\n \tespi_init_wui_callback(dev, &espi_rst_callback,\n \t\t\t\t&config->espi_rst_wui, espi_vw_espi_rst_isr);\n \n+#if DT_NODE_HAS_PROP(DT_DRV_INST(0), vw_index_extend_set)\n+\tuint8_t vw_ex_len = ARRAY_SIZE(espi_npcx_vw_ex_0);\n+\tuint8_t dir, num, index;\n+\n+\tfor (i = 0; i < vw_ex_len; i++) {\n+\t\tdir = espi_npcx_vw_ex_0[i].direction;\n+\t\tnum = espi_npcx_vw_ex_0[i].group_num;\n+\t\tindex = espi_npcx_vw_ex_0[i].index;\n+\n+\t\tif (dir == ESPI_CONTROLLER_TO_TARGET) {\n+\t\t\tif (num >= NPCX_VWEVMS_MAX) {\n+\t\t\t\tLOG_ERR(\"Error Setting for VW extend MS group (%x)\", num);\n+\t\t\t\treturn -EINVAL;\n+\t\t\t}\n+\t\t\tSET_FIELD(inst->VWEVMS[num], NPCX_VWEVMS_INDEX, index);\n+\t\t\tSET_FIELD(inst->VWEVMS[num], NPCX_VWEVMS_VALID, 0x0);\n+\t\t\tinst->VWEVMS[num] |= BIT(NPCX_VWEVMS_INDEX_EN);\n+\t\t} else if (dir == ESPI_TARGET_TO_CONTROLLER) {\n+\t\t\tif (num >= NPCX_VWEVSM_MAX) {\n+\t\t\t\tLOG_ERR(\"Error Setting for VW extend SM group (%x)\", num);\n+\t\t\t\treturn -EINVAL;\n+\t\t\t}\n+\t\t\tSET_FIELD(inst->VWEVSM[num], NPCX_VWEVSM_INDEX, index);\n+\t\t\tSET_FIELD(inst->VWEVSM[num], NPCX_VWEVSM_VALID, 0x0);\n+\t\t\tinst->VWEVSM[num] |= BIT(NPCX_VWEVSM_INDEX_EN);\n+\t\t} else {\n+\t\t\tLOG_ERR(\"Error Setting for VW extend direction (%x)\", dir);\n+\t\t\treturn -EINVAL;\n+\t\t}\n+\t}\n+#endif\n+\n \t/* Configure pin-mux for eSPI bus device */\n \tret = pinctrl_apply_state(config->pcfg, PINCTRL_STATE_DEFAULT);\n \tif (ret < 0) {"
},{
  "instruction": "dts: espi: npcx: add property for customize vw index",
  "input": "#define NPCX_VWEVSM10 10\n#define NPCX_VWEVSM11 11",
  "result": "diff --git a/dts/bindings/espi/nuvoton,npcx-espi.yaml b/dts/bindings/espi/nuvoton,npcx-espi.yaml\nindex e53c3acb94b..f03608194b6 100644\n--- a/dts/bindings/espi/nuvoton,npcx-espi.yaml\n+++ b/dts/bindings/espi/nuvoton,npcx-espi.yaml\n@@ -40,3 +40,17 @@ properties:\n     type: int\n     required: true\n     description: The maximum transmit channel payload size.\n+\n+  vw-index-extend-set:\n+    type: array\n+    description: |\n+      Array of encoded virtual wire information\n+      Update the vw index in group setting. Here is the format.\n+      < ESPI_NPCX_VW_EX_VAL(direction, group_number, index) >\n+      direction: 1 for ESPI_CONTROLLER_TO_TARGET and 0 for ESPI_TARGET_TO_CONTROLLER.\n+      group_number: The number of VWEVMS or VWEVSM.\n+      index: The index to be replaced.\n+\n+      For example, update the index of VWEVMS6 into 0x4A and the index of VWEVSM8 into 0x53\n+        vw-index-extend-set = < ESPI_NPCX_VW_EX_VAL(1, 6, 0x4A)\n+                                ESPI_NPCX_VW_EX_VAL(0, 8, 0x53) >\ndiff --git a/include/zephyr/dt-bindings/espi/npcx_espi.h b/include/zephyr/dt-bindings/espi/npcx_espi.h\nindex d73eef41596..e4851cc832b 100644\n--- a/include/zephyr/dt-bindings/espi/npcx_espi.h\n+++ b/include/zephyr/dt-bindings/espi/npcx_espi.h\n@@ -6,6 +6,20 @@\n #ifndef ZEPHYR_INCLUDE_DT_BINDINGS_ESPI_NPCX_ESPI_H_\n #define ZEPHYR_INCLUDE_DT_BINDINGS_ESPI_NPCX_ESPI_H_\n \n+/*\n+ * Encode virtual wire information into a 16-bit unsigned.\n+ * index  = bits[7:0], Replacement index number\n+ * group = bits[11:8], Group number for VWEVMS or VWEVSM\n+ * dir = bits[13:12], Direction for controller to target or target to controller\n+ */\n+#define ESPI_NPCX_VW_EX_VAL(dir, group, index)                                                     \\\n+\t(((dir & 0x1) << 12) + ((group & 0xf) << 8) + (index & 0xff))\n+\n+/* extract specific information from encoded ESPI_NPCX_VW_EX_VAL */\n+#define ESPI_NPCX_VW_EX_INDEX(e)     ((e) & 0xff)\n+#define ESPI_NPCX_VW_EX_GROUP_NUM(e) (((e) >> 8) & 0xf)\n+#define ESPI_NPCX_VW_EX_DIR(e)       (((e) >> 12) & 0x1)\n+\n /* eSPI VW Master to Slave Register Index */\n #define NPCX_VWEVMS0 0\n #define NPCX_VWEVMS1 1\n@@ -17,6 +31,9 @@\n #define NPCX_VWEVMS7 7\n #define NPCX_VWEVMS8 8\n #define NPCX_VWEVMS9 9\n+#define NPCX_VWEVMS10 10\n+#define NPCX_VWEVMS11 11\n+#define NPCX_VWEVMS_MAX 12\n \n /* eSPI VW Slave to Master Register Index */\n #define NPCX_VWEVSM0 0\n@@ -29,8 +46,7 @@\n #define NPCX_VWEVSM7 7\n #define NPCX_VWEVSM8 8\n #define NPCX_VWEVSM9 9\n-#define NPCX_VWEVSM10 10\n-#define NPCX_VWEVSM11 11\n+#define NPCX_VWEVSM_MAX 10\n \n /* eSPI VW GPIO Slave to Master Register Index */\n #define NPCX_VWGPSM0 0"
},{
  "instruction": "drivers: espi: npcx: add support for DnX VW",
  "input": "",
  "result": "diff --git a/drivers/espi/espi_npcx.c b/drivers/espi/espi_npcx.c\nindex 0eae6578ed7..feca4ad5099 100644\n--- a/drivers/espi/espi_npcx.c\n+++ b/drivers/espi/espi_npcx.c\n@@ -146,6 +146,10 @@ static const struct npcx_vw_in_config vw_in_tbl[] = {\n \t/* index 42h (In)  */\n \tNPCX_DT_VW_IN_CONF(ESPI_VWIRE_SIGNAL_SLP_LAN, vw_slp_lan),\n \tNPCX_DT_VW_IN_CONF(ESPI_VWIRE_SIGNAL_SLP_WLAN, vw_slp_wlan),\n+#if DT_NODE_EXISTS(DT_CHILD(DT_PATH(npcx_espi_vws_map), vw_dnx_warn))\n+\t/* index 4Ah (In) */\n+\tNPCX_DT_VW_IN_CONF(ESPI_VWIRE_SIGNAL_DNX_WARN, vw_dnx_warn),\n+#endif\n };\n \n static const struct npcx_vw_out_config vw_out_tbl[] = {\n@@ -165,6 +169,9 @@ static const struct npcx_vw_out_config vw_out_tbl[] = {\n \tNPCX_DT_VW_OUT_CONF(ESPI_VWIRE_SIGNAL_HOST_RST_ACK, vw_host_rst_ack),\n \t/* index 40h (Out) */\n \tNPCX_DT_VW_OUT_CONF(ESPI_VWIRE_SIGNAL_SUS_ACK, vw_sus_ack),\n+#if DT_NODE_EXISTS(DT_CHILD(DT_PATH(npcx_espi_vws_map), vw_dnx_ack))\n+\tNPCX_DT_VW_OUT_CONF(ESPI_VWIRE_SIGNAL_DNX_ACK, vw_dnx_ack),\n+#endif\n };\n \n /*  Virtual wire GPIOs for platform level usage (High at Reset state) */\n@@ -563,6 +570,11 @@ static void espi_vw_notify_host_warning(const struct device *dev,\n \t\tespi_npcx_send_vwire(dev, ESPI_VWIRE_SIGNAL_OOB_RST_ACK,\n \t\t\t\twire);\n \t\tbreak;\n+#if DT_NODE_EXISTS(DT_CHILD(DT_PATH(npcx_espi_vws_map), vw_dnx_warn))\n+\tcase ESPI_VWIRE_SIGNAL_DNX_WARN:\n+\t\tespi_npcx_send_vwire(dev, ESPI_VWIRE_SIGNAL_DNX_ACK, wire);\n+\t\tbreak;\n+#endif\n \tdefault:\n \t\tbreak;\n \t}\n@@ -634,9 +646,16 @@ static void espi_vw_generic_isr(const struct device *dev, struct npcx_wui *wui)\n \t\t|| signal == ESPI_VWIRE_SIGNAL_SLP_S5\n \t\t|| signal == ESPI_VWIRE_SIGNAL_SLP_A) {\n \t\tespi_vw_notify_system_state(dev, signal);\n+#if DT_NODE_EXISTS(DT_CHILD(DT_PATH(npcx_espi_vws_map), vw_dnx_warn))\n+\t} else if (signal == ESPI_VWIRE_SIGNAL_HOST_RST_WARN\n+\t\t|| signal == ESPI_VWIRE_SIGNAL_SUS_WARN\n+\t\t|| signal == ESPI_VWIRE_SIGNAL_OOB_RST_WARN\n+\t\t|| signal == ESPI_VWIRE_SIGNAL_DNX_WARN) {\n+#else\n \t} else if (signal == ESPI_VWIRE_SIGNAL_HOST_RST_WARN\n \t\t|| signal == ESPI_VWIRE_SIGNAL_SUS_WARN\n \t\t|| signal == ESPI_VWIRE_SIGNAL_OOB_RST_WARN) {\n+#endif\n \t\tespi_vw_notify_host_warning(dev, signal);\n \t} else if (signal == ESPI_VWIRE_SIGNAL_PLTRST) {\n \t\tespi_vw_notify_plt_rst(dev);"
},{
  "instruction": "dts: espi: npcx: add definition for DnX VW",
  "input": "\t\t\tmiwus = <&miwu2 2 1>; /* SLP_WLAN_L) */",
  "result": "diff --git a/dts/arm/nuvoton/npcx/npcx-espi-vws-ex-map.dtsi b/dts/arm/nuvoton/npcx/npcx-espi-vws-ex-map.dtsi\nnew file mode 100644\nindex 00000000000..f01448b4e77\n--- /dev/null\n+++ b/dts/arm/nuvoton/npcx/npcx-espi-vws-ex-map.dtsi\n@@ -0,0 +1,42 @@\n+/*\n+ * Copyright (c) 2021 Nuvoton Technology Corporation.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+/* Common eSPI Virtual Wire (VW) mapping configurations in npcx family */\n+\n+#include <nuvoton/npcx/npcx-espi-vws-map.dtsi>\n+\n+/*\n+ *                Nuvoton NPCX eSPI Virtual Wires Mapping Table\n+ * |--------------------------------------------------------------------------|\n+ * | VW idx | SLV reg | Wire Bit 3   | Wire Bit 2   | Wire Bit 1| Wire Bit 0  |\n+ * |--------------------------------------------------------------------------|\n+ * |                 Input (Master-to-Slave) Virtual Wires                    |\n+ * |--------------------------------------------------------------------------|\n+ * | 4Ah[P] | VWEVMS6 | Reserved     | Reserved     | DnX_WARN  | Reserved    |\n+ * |--------------------------------------------------------------------------|\n+ * |                Output (Slave-to-Master) Virtual Wires                    |\n+ * |--------------------------------------------------------------------------|\n+ * | 40h[P] | VWEVSM3 | Reserved     | Reserved     | DNX_ACK   | SUS_ACK#    |\n+ * |--------------------------------------------------------------------------|\n+ *  [S] System-/[P] Platform-Specific Virtual Wires\n+ */\n+\n+/ {\n+\tnpcx-espi-vws-map {\n+\t\t/* eSPI Virtual Vire (VW) input configuration */\n+\t\t/* index 4Ah (In) */\n+\t\tvw-dnx-warn {\n+\t\t\tvw-reg = <NPCX_VWEVMS6 0x02>;\n+\t\t\tvw-wui = <&wui_vw_dnx_warn>;\n+\t\t};\n+\n+\t\t/* eSPI Virtual Vire (VW) output configuration */\n+\t\t/* index 40h (Out) */\n+\t\tvw-dnx-ack {\n+\t\t\tvw-reg = <NPCX_VWEVSM3 0x02>;\n+\t\t};\n+\t};\n+};\ndiff --git a/dts/arm/nuvoton/npcx/npcx-miwus-wui-map.dtsi b/dts/arm/nuvoton/npcx/npcx-miwus-wui-map.dtsi\nindex e1a1266a483..ec82dd71a86 100644\n--- a/dts/arm/nuvoton/npcx/npcx-miwus-wui-map.dtsi\n+++ b/dts/arm/nuvoton/npcx/npcx-miwus-wui-map.dtsi\n@@ -439,7 +439,7 @@\n \t\t\tmiwus = <&miwu2 2 0>; /* SLP_LAN_L */\n \t\t};\n \t\twui_vw_slp_wlan: wui2-3-1 {\n-\t\t\tmiwus = <&miwu2 2 1>; /* SLP_WLAN_L) */\n+\t\t\tmiwus = <&miwu2 2 1>; /* SLP_WLAN_L */\n \t\t};\n \t\twui_vw_fl_ack: wui2-3-4 {\n \t\t\tmiwus = <&miwu2 2 4>; /* FL_ACK */\n@@ -461,6 +461,9 @@\n \t\twui_vw_pch_to_ec_gen_5: wui2-4-1 {\n \t\t\tmiwus = <&miwu2 3 1>; /* PCH_TO_EC_GENERIC_5 */\n \t\t};\n+\t\twui_vw_dnx_warn: wui2-4-1-alter {\n+\t\t\tmiwus = <&miwu2 3 1>; /* DnX_WARN */\n+\t\t};\n \t\twui_vw_pch_to_ec_gen_6: wui2-4-2 {\n \t\t\tmiwus = <&miwu2 3 2>; /* PCH_TO_EC_GENERIC_6 */\n \t\t};"
},{
  "instruction": "soc: npcx: update register definition for espi vw",
  "input": "",
  "result": "diff --git a/soc/nuvoton/npcx/common/reg/reg_def.h b/soc/nuvoton/npcx/common/reg/reg_def.h\nindex b43c3d54bc1..915694ba606 100644\n--- a/soc/nuvoton/npcx/common/reg/reg_def.h\n+++ b/soc/nuvoton/npcx/common/reg/reg_def.h\n@@ -750,10 +750,14 @@ struct espi_reg {\n #define NPCX_VWSWIRQ_EDGE_IRQ            28\n #define NPCX_VWEVMS_WIRE                 FIELD(0, 4)\n #define NPCX_VWEVMS_VALID                FIELD(4, 4)\n+#define NPCX_VWEVMS_INDEX                FIELD(8, 7)\n+#define NPCX_VWEVMS_INDEX_EN             15\n #define NPCX_VWEVMS_IE                   18\n #define NPCX_VWEVMS_WE                   20\n #define NPCX_VWEVSM_WIRE                 FIELD(0, 4)\n #define NPCX_VWEVSM_VALID                FIELD(4, 4)\n+#define NPCX_VWEVSM_INDEX                FIELD(8, 7)\n+#define NPCX_VWEVSM_INDEX_EN             15\n #define NPCX_VWEVSM_BIT_VALID(n)         (4+n)\n #define NPCX_VWEVSM_HW_WIRE              FIELD(24, 4)\n #define NPCX_VWGPSM_INDEX_EN             15"
},{
  "instruction": "soc: mcxw71: Enable FMU flash controller",
  "input": "\t\t\tfmu: flash-module@20000 {\n\t\t\t\tcompatible = \"nxp,fmu-k4\";",
  "result": "diff --git a/boards/nxp/frdm_mcxw71/doc/index.rst b/boards/nxp/frdm_mcxw71/doc/index.rst\nindex 2ed258c39a4..a77c11ae1ba 100644\n--- a/boards/nxp/frdm_mcxw71/doc/index.rst\n+++ b/boards/nxp/frdm_mcxw71/doc/index.rst\n@@ -55,6 +55,8 @@ The ``frdm_mcxw71`` board target in Zephyr currently supports the following feat\n | LPUART    | on-chip    | serial port-polling;                |\n |           |            | serial port-interrupt               |\n +-----------+------------+-------------------------------------+\n+| FMU       | on-chip    | flash                               |\n++-----------+------------+-------------------------------------+\n \n Programming and Debugging\n *************************\ndiff --git a/boards/nxp/frdm_mcxw71/frdm_mcxw71.dts b/boards/nxp/frdm_mcxw71/frdm_mcxw71.dts\nindex 6577fe5ccca..6d48f571eee 100644\n--- a/boards/nxp/frdm_mcxw71/frdm_mcxw71.dts\n+++ b/boards/nxp/frdm_mcxw71/frdm_mcxw71.dts\n@@ -17,6 +17,7 @@\n \n \tchosen {\n \t\tzephyr,flash = &flash;\n+\t\tzephyr,flash-controller = &fmu;\n \t\tzephyr,code-partition = &code_partition;\n \t\tzephyr,sram = &stcm0;\n \t\tzephyr,console = &lpuart1;\n@@ -60,3 +61,7 @@\n \t\t};\n \t};\n };\n+\n+&fmu {\n+\tstatus = \"okay\";\n+};\ndiff --git a/dts/arm/nxp/nxp_mcxw71.dtsi b/dts/arm/nxp/nxp_mcxw71.dtsi\nindex 51e529e483c..ca40080e2f4 100644\n--- a/dts/arm/nxp/nxp_mcxw71.dtsi\n+++ b/dts/arm/nxp/nxp_mcxw71.dtsi\n@@ -67,13 +67,15 @@\n \t\tperipheral: peripheral@50000000 {\n \t\t\tranges = <0x0 0x50000000 0x10000000>;\n \n-\t\t\tfmu: flash-module@20000 {\n+\t\t\tfmu: memory-controller@20000 {\n \t\t\t\tranges = <0x0 0x10000000 DT_SIZE_M(1)>;\n \t\t\t\t#address-cells = <1>;\n \t\t\t\t#size-cells = <1>;\n \n-\t\t\t\tcompatible = \"nxp,fmu-k4\";\n+\t\t\t\tcompatible = \"nxp,iap-msf1\";\n \t\t\t\treg = <0x20000 0x1000>;\n+\t\t\t\tinterrupts = <27 0>;\n+\t\t\t\tstatus = \"disabled\";\n \n \t\t\t\tflash: flash@0 {\n \t\t\t\t\treg = <0x0 DT_SIZE_M(1)>;\ndiff --git a/soc/nxp/mcx/mcxw/Kconfig.defconfig b/soc/nxp/mcx/mcxw/Kconfig.defconfig\nindex b57cb97a8ff..38c57f960f7 100644\n--- a/soc/nxp/mcx/mcxw/Kconfig.defconfig\n+++ b/soc/nxp/mcx/mcxw/Kconfig.defconfig\n@@ -9,4 +9,7 @@ config NUM_IRQS\n config SYS_CLOCK_HW_CYCLES_PER_SEC\n \tdefault 96000000 if CORTEX_M_SYSTICK\n \n+config MCUX_FLASH_K4_API\n+\tdefault y\n+\n endif # SOC_SERIES_MCXW"
},{
  "instruction": "drivers: soc_mcux_flash: Add flash_k4 support",
  "input": "\trc = FLASH_Erase(&priv->config, addr, len, kFLASH_ApiEraseKey);\n\trc = FLASH_Program(&priv->config, addr, (uint8_t *) data, len);\n#if defined(SOC_HAS_IAP) || defined(SOC_HAS_IAP_MSF1)\n\tFLASH_GetProperty(&priv->config, kFLASH_PropertyPflashBlockBaseAddr,\n\t\t\t  &pflash_block_base);\n#else\n\tFLASH_GetProperty(&priv->config, kFLASH_PropertyPflash0BlockBaseAddr,\n\t\t\t  &pflash_block_base);\n#endif",
  "result": "diff --git a/drivers/flash/Kconfig.mcux b/drivers/flash/Kconfig.mcux\nindex 22695bece12..2ec37bc5f62 100644\n--- a/drivers/flash/Kconfig.mcux\n+++ b/drivers/flash/Kconfig.mcux\n@@ -30,6 +30,12 @@ config CHECK_BEFORE_READING\n \t  This feature prevents erroneous/forbidden reading. Some ECC enabled\n \t  devices will crash when reading an erased or wrongly programmed area.\n \n+config MCUX_FLASH_K4_API\n+\tbool\n+\thelp\n+\t  Set from SOC level configuration if the platform is meant to use the\n+\t  flash_k4 SDK IAP API.\n+\n endif # SOC_FLASH_MCUX\n \n if DT_HAS_NXP_IMX_FLEXSPI_ENABLED\ndiff --git a/drivers/flash/soc_flash_mcux.c b/drivers/flash/soc_flash_mcux.c\nindex 6eaf90cd010..e4a9e8ff7de 100644\n--- a/drivers/flash/soc_flash_mcux.c\n+++ b/drivers/flash/soc_flash_mcux.c\n@@ -47,11 +47,12 @@ LOG_MODULE_REGISTER(flash_mcux);\n #include \"fsl_romapi.h\"\n #define FLASH_Erase   FLASH_EraseSector\n #define FLASH_Program FLASH_ProgramPhrase\n+#elif defined(CONFIG_MCUX_FLASH_K4_API)\n+#include \"fsl_k4_flash.h\"\n #else\n #include \"fsl_flash.h\"\n #endif /* SOC_HAS_IAP && !CONFIG_SOC_LPC55S36*/\n \n-\n #define SOC_NV_FLASH_NODE DT_INST(0, soc_nv_flash)\n \n #if defined(CONFIG_CHECK_BEFORE_READING)  && !defined(CONFIG_SOC_LPC55S36)\n@@ -166,7 +167,11 @@ static int flash_mcux_erase(const struct device *dev, off_t offset,\n \taddr = offset + priv->pflash_block_base;\n \n \tkey = irq_lock();\n-\trc = FLASH_Erase(&priv->config, addr, len, kFLASH_ApiEraseKey);\n+\trc = FLASH_Erase(&priv->config,\n+#if CONFIG_MCUX_FLASH_K4_API\n+\t\t\t(FMU_Type *) DT_INST_REG_ADDR(0),\n+#endif\n+\t\t\taddr, len, kFLASH_ApiEraseKey);\n \tirq_unlock(key);\n \n \tk_sem_give(&priv->write_lock);\n@@ -247,7 +252,11 @@ static int flash_mcux_write(const struct device *dev, off_t offset,\n \taddr = offset + priv->pflash_block_base;\n \n \tkey = irq_lock();\n-\trc = FLASH_Program(&priv->config, addr, (uint8_t *) data, len);\n+\trc = FLASH_Program(&priv->config,\n+#if CONFIG_MCUX_FLASH_K4_API\n+\t\t\t(FMU_Type *) DT_INST_REG_ADDR(0),\n+#endif\n+\t\t\taddr, (uint8_t *) data, len);\n \tirq_unlock(key);\n \n \tk_sem_give(&priv->write_lock);\n@@ -291,6 +300,12 @@ static const struct flash_driver_api flash_mcux_api = {\n #endif\n };\n \n+#if (defined(SOC_HAS_IAP) || defined(SOC_HAS_IAP_MSF1)) && !defined(CONFIG_MCUX_FLASH_K4_API)\n+#define FLASH_PROP_BLOCK_BASE\tkFLASH_PropertyPflashBlockBaseAddr\n+#else\n+#define FLASH_PROP_BLOCK_BASE kFLASH_PropertyPflash0BlockBaseAddr\n+#endif\n+\n static int flash_mcux_init(const struct device *dev)\n {\n \tstruct flash_priv *priv = dev->data;\n@@ -301,13 +316,8 @@ static int flash_mcux_init(const struct device *dev)\n \n \trc = FLASH_Init(&priv->config);\n \n-#if defined(SOC_HAS_IAP) || defined(SOC_HAS_IAP_MSF1)\n-\tFLASH_GetProperty(&priv->config, kFLASH_PropertyPflashBlockBaseAddr,\n-\t\t\t  &pflash_block_base);\n-#else\n-\tFLASH_GetProperty(&priv->config, kFLASH_PropertyPflash0BlockBaseAddr,\n-\t\t\t  &pflash_block_base);\n-#endif\n+\tFLASH_GetProperty(&priv->config, FLASH_PROP_BLOCK_BASE, &pflash_block_base);\n+\n \tpriv->pflash_block_base = (uint32_t) pflash_block_base;\n \n \treturn (rc == kStatus_Success) ? 0 : -EIO;"
},{
  "instruction": "boards: nxp: Add FRDM-MCXW71",
  "input": "",
  "result": "diff --git a/boards/nxp/frdm_mcxw71/Kconfig.frdm_mcxw71 b/boards/nxp/frdm_mcxw71/Kconfig.frdm_mcxw71\nnew file mode 100644\nindex 00000000000..1febea3fe4a\n--- /dev/null\n+++ b/boards/nxp/frdm_mcxw71/Kconfig.frdm_mcxw71\n@@ -0,0 +1,6 @@\n+# Copyright 2024 NXP\n+# SPDX-License-Identifier: Apache-2.0\n+\n+config BOARD_FRDM_MCXW71\n+\tselect SOC_MCXW716C\n+\tselect SOC_PART_NUMBER_MCXW716CMFTA\ndiff --git a/boards/nxp/frdm_mcxw71/board.cmake b/boards/nxp/frdm_mcxw71/board.cmake\nnew file mode 100644\nindex 00000000000..27c59c8d358\n--- /dev/null\n+++ b/boards/nxp/frdm_mcxw71/board.cmake\n@@ -0,0 +1,6 @@\n+# Copyright 2024 NXP\n+# SPDX-License-Identifier: Apache-2.0\n+\n+board_runner_args(jlink \"--device=mcxw716\" \"--reset-after-load\")\n+\n+include(${ZEPHYR_BASE}/boards/common/jlink.board.cmake)\ndiff --git a/boards/nxp/frdm_mcxw71/board.yml b/boards/nxp/frdm_mcxw71/board.yml\nnew file mode 100644\nindex 00000000000..2a40433c84b\n--- /dev/null\n+++ b/boards/nxp/frdm_mcxw71/board.yml\n@@ -0,0 +1,5 @@\n+board:\n+  name: frdm_mcxw71\n+  vendor: nxp\n+  socs:\n+    - name: mcxw716c\ndiff --git a/boards/nxp/frdm_mcxw71/doc/frdm_mcxw71.webp b/boards/nxp/frdm_mcxw71/doc/frdm_mcxw71.webp\nnew file mode 100644\nindex 00000000000..25c7ca3feb5\nBinary files /dev/null and b/boards/nxp/frdm_mcxw71/doc/frdm_mcxw71.webp differ\ndiff --git a/boards/nxp/frdm_mcxw71/doc/index.rst b/boards/nxp/frdm_mcxw71/doc/index.rst\nnew file mode 100644\nindex 00000000000..2ed258c39a4\n--- /dev/null\n+++ b/boards/nxp/frdm_mcxw71/doc/index.rst\n@@ -0,0 +1,141 @@\n+.. _frdm_mcxw71:\n+\n+NXP FRDM-MCXW71\n+################\n+\n+Overview\n+********\n+\n+The FRDM-MCXW71 is a compact and scalable development board for rapid\n+prototyping of the MCX W71 wireless MCU. It offers easy evaluation of the MCX\n+W71's multiprotocol wireless support for Bluetooth LE, Zigbee, Thread and\n+Matter. The board includes an on-board MCU-Link debugger, industry standard\n+headers for easy access to the MCUs I/Os, an accelerometer, a light sensor and\n+external SPI flash memory.\n+\n+The MCX W71x family features a 96 MHz Arm Cortex-M33 core coupled with a\n+multiprotocol radio subsystem supporting Matter, Thread, Zigbee and Bluetooth\n+LE. The independent radio subsystem, with a dedicated core and memory, offloads\n+the main CPU, preserving it for the primary application and allowing firmware\n+updates to support future wireless standards.\n+\n+.. image:: frdm_mcxw71.webp\n+   :align: center\n+   :alt: FRDM-MCXW71\n+\n+Hardware\n+********\n+\n+- MCXW71 Arm Cortex-M33 microcontroller running up to 96 MHz\n+- 1MB on-chip Flash memory unit\n+- 128 KB TCM RAM\n+- On-board MCU-Link debugger with CMSIS-DAP\n+\n+For more information about the MCXW71 SoC and FRDM-MCXW71 board, see:\n+\n+- `MCXW71 SoC Website`_\n+- `FRDM-MCXW71 Website`_\n+\n+Supported Features\n+==================\n+\n+The ``frdm_mcxw71`` board target in Zephyr currently supports the following features:\n+\n++-----------+------------+-------------------------------------+\n+| Interface | Controller | Driver/Component                    |\n++===========+============+=====================================+\n+| NVIC      | on-chip    | nested vector interrupt controller  |\n++-----------+------------+-------------------------------------+\n+| SYSTICK   | on-chip    | systick                             |\n++-----------+------------+-------------------------------------+\n+| PINMUX    | on-chip    | pinctrl                             |\n++-----------+------------+-------------------------------------+\n+| GPIO      | on-chip    | gpio                                |\n++-----------+------------+-------------------------------------+\n+| LPUART    | on-chip    | serial port-polling;                |\n+|           |            | serial port-interrupt               |\n++-----------+------------+-------------------------------------+\n+\n+Programming and Debugging\n+*************************\n+\n+Build and flash applications as usual (see :ref:`build_an_application` and\n+:ref:`application_run` for more details).\n+\n+Configuring a Debug Probe\n+=========================\n+\n+A debug probe is used for both flashing and debugging the board. This board is\n+configured by default to use the MCU-Link CMSIS-DAP Onboard Debug Probe.\n+\n+Using J-Link\n+------------\n+\n+There are two options. The onboard debug circuit can be updated with Segger\n+J-Link firmware by following the instructions in\n+:ref:`mcu-link-jlink-onboard-debug-probe`.\n+To be able to program the firmware, you need to put the board in ``DFU mode``\n+by shortening the jumper JP5.\n+The second option is to attach a :ref:`jlink-external-debug-probe` to the\n+10-pin SWD connector (J12) of the board.\n+For both options use the ``-r jlink`` option with west to use the jlink runner.\n+\n+.. code-block:: console\n+\n+   west flash -r jlink\n+\n+Configuring a Console\n+=====================\n+\n+Connect a USB cable from your PC to J10, and use the serial terminal of your choice\n+(minicom, putty, etc.) with the following settings:\n+\n+- Speed: 115200\n+- Data: 8 bits\n+- Parity: None\n+- Stop bits: 1\n+\n+Flashing\n+========\n+\n+Here is an example for the :zephyr:code-sample:`hello_world` application.\n+\n+.. zephyr-app-commands::\n+   :zephyr-app: samples/hello_world\n+   :board: frdm_mcxw71/mcxw716c\n+   :goals: flash\n+\n+Open a serial terminal, reset the board (press the RESET button), and you should\n+see the following message in the terminal:\n+\n+.. code-block:: console\n+\n+   *** Booting Zephyr OS build v3.7.0-xxx-xxxx ***\n+   Hello World! frdm_mcxw71/mcxw716c\n+\n+Debugging\n+=========\n+\n+Here is an example for the :zephyr:code-sample:`hello_world` application.\n+\n+.. zephyr-app-commands::\n+   :zephyr-app: samples/hello_world\n+   :board: frdm_mcxw71/mcxw716c\n+   :goals: debug\n+\n+Open a serial terminal, step through the application in your debugger, and you\n+should see the following message in the terminal:\n+\n+.. code-block:: console\n+\n+   *** Booting Zephyr OS build v3.7.0-xxx-xxxx ***\n+   Hello World! frdm_mcxw71/mcxw716c\n+\n+References\n+**********\n+\n+.. _MCXW71 SoC Website:\n+   https://www.nxp.com/products/processors-and-microcontrollers/arm-microcontrollers/general-purpose-mcus/mcx-arm-cortex-m/mcx-w-series-microcontrollers/mcx-w71x-secure-and-ultra-low-power-mcus-for-matter-thread-zigbee-and-bluetooth-le:MCX-W71X\n+\n+.. _FRDM-MCXW71 Website:\n+   https://www.nxp.com/design/design-center/development-boards-and-designs/general-purpose-mcus/frdm-development-board-for-mcx-w71x-wireless-mcus:FRDM-MCXW71\ndiff --git a/boards/nxp/frdm_mcxw71/frdm_mcxw71-pinctrl.dtsi b/boards/nxp/frdm_mcxw71/frdm_mcxw71-pinctrl.dtsi\nnew file mode 100644\nindex 00000000000..d834ed38453\n--- /dev/null\n+++ b/boards/nxp/frdm_mcxw71/frdm_mcxw71-pinctrl.dtsi\n@@ -0,0 +1,16 @@\n+/*\n+ * Copyright 2024 NXP\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+#include <nxp/mcx/MCXW716CMFTA-pinctrl.h>\n+\n+&pinctrl {\n+\tpinmux_lpuart1: pinmux_lpuart1 {\n+\t\tgroup0 {\n+\t\t\tpinmux = <LPUART1_RX_PTC2>, <LPUART1_TX_PTC3>;\n+\t\t\tdrive-strength = \"low\";\n+\t\t\tslew-rate = \"fast\";\n+\t\t};\n+\t};\n+};\ndiff --git a/boards/nxp/frdm_mcxw71/frdm_mcxw71.dts b/boards/nxp/frdm_mcxw71/frdm_mcxw71.dts\nnew file mode 100644\nindex 00000000000..6577fe5ccca\n--- /dev/null\n+++ b/boards/nxp/frdm_mcxw71/frdm_mcxw71.dts\n@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2024 NXP\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+/dts-v1/;\n+\n+#include <nxp/nxp_mcxw71.dtsi>\n+#include \"frdm_mcxw71-pinctrl.dtsi\"\n+\n+/ {\n+\tmodel = \"NXP FRDM-MCXW71 board\";\n+\n+\taliases {\n+\t\tled0 = &green_led;\n+\t};\n+\n+\tchosen {\n+\t\tzephyr,flash = &flash;\n+\t\tzephyr,code-partition = &code_partition;\n+\t\tzephyr,sram = &stcm0;\n+\t\tzephyr,console = &lpuart1;\n+\t\tzephyr,shell-uart = &lpuart1;\n+\t};\n+\n+\tuser_led {\n+\t\tcompatible = \"gpio-leds\";\n+\t\tgreen_led: led {\n+\t\t\tgpios = <&gpioc 1 GPIO_ACTIVE_LOW>;\n+\t\t};\n+\t};\n+};\n+\n+&gpioc {\n+\tstatus = \"okay\";\n+};\n+\n+&lpuart1 {\n+\tcurrent-speed = <115200>;\n+\tstatus =  \"okay\";\n+\tpinctrl-0 = <&pinmux_lpuart1>;\n+\tpinctrl-names = \"default\";\n+};\n+\n+&flash {\n+\tpartitions {\n+\t\tcompatible = \"fixed-partitions\";\n+\t\t#address-cells = <1>;\n+\t\t#size-cells = <1>;\n+\n+\t\tcode_partition: partition@0 {\n+\t\t\treg = <0x0 DT_SIZE_K(896)>;\n+\t\t\tlabel = \"code\";\n+\t\t\tread-only;\n+\t\t};\n+\n+\t\tstorage_partition: partition@e0000 {\n+\t\t\treg = <0xe0000 DT_SIZE_K(128)>;\n+\t\t\tlabel = \"storage\";\n+\t\t};\n+\t};\n+};\ndiff --git a/boards/nxp/frdm_mcxw71/frdm_mcxw71.yaml b/boards/nxp/frdm_mcxw71/frdm_mcxw71.yaml\nnew file mode 100644\nindex 00000000000..bdc3c13959b\n--- /dev/null\n+++ b/boards/nxp/frdm_mcxw71/frdm_mcxw71.yaml\n@@ -0,0 +1,15 @@\n+identifier: frdm_mcxw71\n+name: NXP FRDM_MCXW71\n+type: mcu\n+arch: arm\n+ram: 64\n+flash: 1024\n+toolchain:\n+  - zephyr\n+  - gnuarmemb\n+  - xtools\n+supported:\n+  - gpio\n+  - uart\n+  - pinctrl\n+  - flash\ndiff --git a/boards/nxp/frdm_mcxw71/frdm_mcxw71_defconfig b/boards/nxp/frdm_mcxw71/frdm_mcxw71_defconfig\nnew file mode 100644\nindex 00000000000..ef284e16e65\n--- /dev/null\n+++ b/boards/nxp/frdm_mcxw71/frdm_mcxw71_defconfig\n@@ -0,0 +1,13 @@\n+#\n+# Copyright 2023 NXP\n+#\n+# SPDX-License-Identifier: Apache-2.0\n+#\n+\n+CONFIG_ARM_MPU=y\n+CONFIG_TRUSTED_EXECUTION_SECURE=y\n+CONFIG_PINCTRL=y\n+CONFIG_SERIAL=y\n+CONFIG_CONSOLE=y\n+CONFIG_UART_CONSOLE=y\n+CONFIG_GPIO=y"
},{
  "instruction": "soc: nxp: Add MCXW71",
  "input": "     revision: 17aac63df44266c4ea0e111c731ca7664fe51e70",
  "result": "diff --git a/soc/nxp/mcx/mcxw/CMakeLists.txt b/soc/nxp/mcx/mcxw/CMakeLists.txt\nnew file mode 100644\nindex 00000000000..47cef05f237\n--- /dev/null\n+++ b/soc/nxp/mcx/mcxw/CMakeLists.txt\n@@ -0,0 +1,9 @@\n+# Copyright 2023 NXP\n+#\n+# SPDX-License-Identifier: Apache-2.0\n+\n+zephyr_sources(soc.c mcxw71_platform_init.S)\n+\n+zephyr_include_directories(.)\n+\n+set(SOC_LINKER_SCRIPT ${CMAKE_CURRENT_SOURCE_DIR}/linker.ld CACHE INTERNAL \"\")\ndiff --git a/soc/nxp/mcx/mcxw/Kconfig b/soc/nxp/mcx/mcxw/Kconfig\nnew file mode 100644\nindex 00000000000..39028b33226\n--- /dev/null\n+++ b/soc/nxp/mcx/mcxw/Kconfig\n@@ -0,0 +1,16 @@\n+# Copyright 2024 NXP\n+# SPDX-License-Identifier: Apache-2.0\n+\n+config SOC_SERIES_MCXW\n+\tselect ARM\n+\tselect CPU_CORTEX_M33\n+\tselect CPU_CORTEX_M_HAS_DWT\n+\tselect ARM_TRUSTZONE_M\n+\tselect CPU_CORTEX_M_HAS_SYSTICK\n+\tselect CPU_HAS_FPU\n+\tselect CPU_HAS_ARM_SAU\n+\tselect CPU_HAS_ARM_MPU\n+\tselect ARMV8_M_DSP\n+\tselect HAS_MCUX\n+\tselect PLATFORM_SPECIFIC_INIT\n+\tselect CLOCK_CONTROL\ndiff --git a/soc/nxp/mcx/mcxw/Kconfig.defconfig b/soc/nxp/mcx/mcxw/Kconfig.defconfig\nnew file mode 100644\nindex 00000000000..b57cb97a8ff\n--- /dev/null\n+++ b/soc/nxp/mcx/mcxw/Kconfig.defconfig\n@@ -0,0 +1,12 @@\n+# Copyright 2023-2024 NXP\n+# SPDX-License-Identifier: Apache-2.0\n+\n+if SOC_SERIES_MCXW\n+\n+config NUM_IRQS\n+\tdefault 76\n+\n+config SYS_CLOCK_HW_CYCLES_PER_SEC\n+\tdefault 96000000 if CORTEX_M_SYSTICK\n+\n+endif # SOC_SERIES_MCXW\ndiff --git a/soc/nxp/mcx/mcxw/Kconfig.soc b/soc/nxp/mcx/mcxw/Kconfig.soc\nnew file mode 100644\nindex 00000000000..f6b03d9b893\n--- /dev/null\n+++ b/soc/nxp/mcx/mcxw/Kconfig.soc\n@@ -0,0 +1,22 @@\n+# Copyright 2024 NXP\n+# SPDX-License-Identifier: Apache-2.0\n+\n+config SOC_SERIES_MCXW\n+\tbool\n+\tselect SOC_FAMILY_NXP_MCX\n+\n+config SOC_SERIES\n+\tdefault \"mcxw\" if SOC_SERIES_MCXW\n+\n+config SOC_MCXW716C\n+\tbool\n+\tselect SOC_SERIES_MCXW\n+\n+config SOC\n+\tdefault \"mcxw716c\" if SOC_MCXW716C\n+\n+config SOC_PART_NUMBER_MCXW716CMFTA\n+\tbool\n+\n+config SOC_PART_NUMBER\n+\tdefault \"MCXW716CMFTA\" if SOC_PART_NUMBER_MCXW716CMFTA\ndiff --git a/soc/nxp/mcx/mcxw/linker.ld b/soc/nxp/mcx/mcxw/linker.ld\nnew file mode 100644\nindex 00000000000..91fd2750e64\n--- /dev/null\n+++ b/soc/nxp/mcx/mcxw/linker.ld\n@@ -0,0 +1,25 @@\n+/*\n+ * Copyright 2023 NXP\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+#include <zephyr/devicetree.h>\n+\n+m_sector_size                       = 0x2000;\n+m_flash_end                         = 0x000FFFFF;\n+\n+\n+m_fsl_prodInfo_size                 = m_sector_size;\n+m_fsl_prodInfo_start                = m_flash_end - m_fsl_prodInfo_size + 1;\n+m_fsl_prodInfo_end                  = m_flash_end;\n+PROD_DATA_BASE_ADDR                 = m_fsl_prodInfo_start;\n+\n+/*\n+ * We perform all custom placement before including the generic linker file. This\n+ * is done because calling this linker at the beginning will place some sections\n+ * first, such as .noinit*, and this includes the rpmsg_sh_mem, which results\n+ * in placing the rpmsg section in RAM instead of shared mem.\n+ */\n+\n+#include <zephyr/arch/arm/cortex_m/scripts/linker.ld>\ndiff --git a/soc/nxp/mcx/mcxw/mcxw71_platform_init.S b/soc/nxp/mcx/mcxw/mcxw71_platform_init.S\nnew file mode 100644\nindex 00000000000..c161f7e8eb0\n--- /dev/null\n+++ b/soc/nxp/mcx/mcxw/mcxw71_platform_init.S\n@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2023 NXP\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+/**\n+ * @file\n+ * @brief MCXW71 Platform-Specific Initialization\n+ *\n+ * MCXW71 SOC reset code that initializes RAM\n+ * to prevent ECC causing faults, and calls SystemInit\n+ */\n+\n+#include <zephyr/toolchain.h>\n+#include <zephyr/linker/sections.h>\n+\n+_ASM_FILE_PROLOGUE\n+#ifdef CONFIG_PLATFORM_SPECIFIC_INIT\n+\n+\n+GTEXT(z_arm_platform_init)\n+SECTION_SUBSEC_FUNC(TEXT,_reset_section,z_arm_platform_init)\n+\n+.z_arm_platform_init:\n+    ldr r0, =0x14000000\n+    ldr r1, =.ram_init_ctcm01\n+    bics r1, #0x10000000\n+    cmp r0, r1\n+    bcc .ram_init_done\n+.ram_init_ctcm01: /* Initialize ctcm01 */\n+    ldr r0, =0x14000000\n+    ldr r1, =0x14004000\n+    ldr r2, =0\n+    ldr r3, =0\n+    ldr r4, =0\n+    ldr r5, =0\n+.loop01:\n+    stmia r0!, {r2 - r5}\n+    cmp r0, r1\n+    bcc .loop01\n+.ram_init_stcm012: /* Initialize stcm012 */\n+    ldr r0, =0x30000000\n+    ldr r1, =0x30010000\n+.loop012:\n+    stmia r0!, {r2 - r5}\n+    cmp r0, r1\n+    bcc .loop012\n+.ram_init_stcm5:\n+    ldr r0, =0x3001a000\n+    ldr r1, =0x3001c000\n+.loop5: /* Initialize stcm5 */\n+    stmia r0!, {r2 - r5}\n+    cmp r0, r1\n+    bcc .loop5\n+.ram_init_done:\n+    b SystemInit\n+\n+#endif /* CONFIG_PLATFORM_SPECIFIC_INIT */\ndiff --git a/soc/nxp/mcx/mcxw/pinctrl_soc.h b/soc/nxp/mcx/mcxw/pinctrl_soc.h\nnew file mode 100644\nindex 00000000000..9a6c34358d0\n--- /dev/null\n+++ b/soc/nxp/mcx/mcxw/pinctrl_soc.h\n@@ -0,0 +1,7 @@\n+/*\n+ * Copyright 2024 NXP\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+#include <zephyr/drivers/pinctrl/pinctrl_soc_kinetis_common.h>\ndiff --git a/soc/nxp/mcx/mcxw/soc.c b/soc/nxp/mcx/mcxw/soc.c\nnew file mode 100644\nindex 00000000000..f37424ad198\n--- /dev/null\n+++ b/soc/nxp/mcx/mcxw/soc.c\n@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2023 NXP\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+#include <zephyr/arch/cpu.h>\n+#include <zephyr/device.h>\n+#include <zephyr/init.h>\n+#include <zephyr/kernel.h>\n+#include <zephyr/linker/sections.h>\n+\n+#include <soc.h>\n+\n+#include <fsl_ccm32k.h>\n+#include <fsl_common.h>\n+#include <fsl_clock.h>\n+\n+extern uint32_t SystemCoreClock;\n+\n+static ALWAYS_INLINE void clock_init(void)\n+{\n+\t/* Unlock Reference Clock Status Registers to allow writes */\n+\tCLOCK_UnlockFircControlStatusReg();\n+\tCLOCK_UnlockSircControlStatusReg();\n+\tCLOCK_UnlockRoscControlStatusReg();\n+\tCLOCK_UnlockSysOscControlStatusReg();\n+\n+\t/*\n+\t * Configuration for the 32 kHz Oscillator module\n+\t * Internal capatitor bank is required in order to use the more stable OSC32K source\n+\t */\n+\tccm32k_osc_config_t ccm32k_osc_config = {\n+\t\t.coarseAdjustment = kCCM32K_OscCoarseAdjustmentRange0, /* ESR_Range0 */\n+\t\t.enableInternalCapBank = true,      /* Internal capacitance bank is enabled */\n+\t\t.xtalCap = kCCM32K_OscXtal8pFCap,   /* 8 pF */\n+\t\t.extalCap = kCCM32K_OscExtal8pFCap, /* 8 pF */\n+\t};\n+\t/* Enable OSC32K */\n+\tCCM32K_Set32kOscConfig(CCM32K, kCCM32K_Enable32kHzCrystalOsc, &ccm32k_osc_config);\n+\t/* Disable ROSC Monitor, because switching the source would generate an expected error */\n+\tCLOCK_SetRoscMonitorMode(kSCG_RoscMonitorDisable);\n+\t/* Select the Real Time Clock (RTC) source as OSC32K */\n+\tCCM32K_SelectClockSource(CCM32K, kCCM32K_ClockSourceSelectOsc32k);\n+\t/* Wait for RTC Oscillator to be Valid */\n+\twhile (!CLOCK_IsRoscValid())\n+\t\t;\n+\t/* Re-enable monitor */\n+\tCLOCK_SetRoscMonitorMode(kSCG_RoscMonitorInt);\n+\t/* Disable the FRO32K to save power */\n+\tCCM32K_Enable32kFro(CCM32K, false);\n+\n+\t/* Configuration to set FIRC to maximum frequency */\n+\tscg_firc_config_t scg_firc_config = {\n+\t\t.enableMode = kSCG_FircEnable, /* Fast IRC is enabled */\n+\t\t.range = kSCG_FircRange96M,    /* 96 Mhz FIRC clock selected */\n+\t\t.trimConfig = NULL,\n+\t};\n+\n+\tscg_sys_clk_config_t sys_clk_safe_config_source = {\n+\t\t.divSlow = (uint32_t)kSCG_SysClkDivBy4,\n+\t\t.divCore = (uint32_t)kSCG_SysClkDivBy1,\n+\t\t.src = (uint32_t)kSCG_SysClkSrcSirc,\n+\t};\n+\n+\tCLOCK_SetRunModeSysClkConfig(&sys_clk_safe_config_source);\n+\n+\tscg_sys_clk_config_t cur_config;\n+\n+\tdo {\n+\t\tCLOCK_GetCurSysClkConfig(&cur_config);\n+\t} while (cur_config.src != sys_clk_safe_config_source.src);\n+\n+\t(void)CLOCK_InitFirc(&scg_firc_config);\n+\n+\tscg_sys_clk_config_t sys_clk_config = {\n+\t\t.divSlow = (uint32_t)kSCG_SysClkDivBy4, /* Slow Clock Divider: divided by 4 */\n+\t\t.divBus = (uint32_t)kSCG_SysClkDivBy1,  /* Bus Clock Divider: divided by 1 */\n+\t\t.divCore = (uint32_t)kSCG_SysClkDivBy1, /* Core Clock Divider: divided by 1 */\n+\t\t.src = (uint32_t)kSCG_SysClkSrcFirc,    /* Select Fast IRC as System Clock */\n+\t};\n+\tCLOCK_SetRunModeSysClkConfig(&sys_clk_config);\n+\n+\t/* Wait for clock source switch to finish */\n+\tdo {\n+\t\tCLOCK_GetCurSysClkConfig(&cur_config);\n+\t} while (cur_config.src != sys_clk_config.src);\n+\n+\tSystemCoreClock = 96000000U;\n+\n+\t/* OSC-RF / System Oscillator Configuration */\n+\tscg_sosc_config_t sosc_config = {\n+\t\t.freq = 32000U,\n+\t\t.monitorMode = kSCG_SysOscMonitorDisable,\n+\t\t.enableMode = kSCG_SoscEnable,\n+\t};\n+\n+\t/* Init OSC-RF / SOSC */\n+\t(void)CLOCK_InitSysOsc(&sosc_config);\n+\tCLOCK_SetXtal0Freq(sosc_config.freq);\n+\n+\t/* Slow internal reference clock (SIRC) configuration */\n+\tscg_sirc_config_t sirc_config = {\n+\t\t.enableMode = kSCG_SircDisableInSleep,\n+\t};\n+\n+\t/* Init SIRC */\n+\t(void)CLOCK_InitSirc(&sirc_config);\n+\n+\t/* Attach Clocks */\n+\tCLOCK_SetIpSrc(kCLOCK_Lpuart0, kCLOCK_IpSrcFro192M);\n+\tCLOCK_SetIpSrc(kCLOCK_Lpuart1, kCLOCK_IpSrcFro192M);\n+\tCLOCK_SetIpSrc(kCLOCK_Lpspi0, kCLOCK_IpSrcFro192M);\n+\tCLOCK_SetIpSrc(kCLOCK_Lpspi1, kCLOCK_IpSrcFro192M);\n+\tCLOCK_SetIpSrc(kCLOCK_Can0, kCLOCK_IpSrcFro192M);\n+\tCLOCK_SetIpSrc(kCLOCK_Tpm0, kCLOCK_IpSrcFro192M);\n+\tCLOCK_SetIpSrc(kCLOCK_Tpm1, kCLOCK_IpSrcFro192M);\n+\tCLOCK_SetIpSrc(kCLOCK_Lpi2c0, kCLOCK_IpSrcFro192M);\n+\tCLOCK_SetIpSrcDiv(kCLOCK_Lpi2c0, kSCG_SysClkDivBy16);\n+\tCLOCK_SetIpSrc(kCLOCK_Lpi2c1, kCLOCK_IpSrcFro192M);\n+\tCLOCK_SetIpSrcDiv(kCLOCK_Lpi2c1, kSCG_SysClkDivBy16);\n+\n+\t/* Ungate clocks if the peripheral is enabled in devicetree */\n+#if (DT_NODE_HAS_COMPAT_STATUS(DT_NODELABEL(lpuart0), nxp_lpc_lpuart, okay))\n+\tCLOCK_EnableClock(kCLOCK_Lpuart0);\n+#endif\n+#if (DT_NODE_HAS_COMPAT_STATUS(DT_NODELABEL(lpuart1), nxp_lpc_lpuart, okay))\n+\tCLOCK_EnableClock(kCLOCK_Lpuart1);\n+#endif\n+}\n+\n+static void vbat_init(void)\n+{\n+\tVBAT_Type *base = (VBAT_Type *)DT_REG_ADDR(DT_NODELABEL(vbat));\n+\n+\t/* Write 1 to Clear POR detect status bit.\n+\t *\n+\t * Clearing this bit is acknowledement\n+\t * that software has recognized a power on reset.\n+\t *\n+\t * This avoids also niche issues with NVIC read/write\n+\t * when searching for available interrupt lines.\n+\t */\n+\tbase->STATUSA |= VBAT_STATUSA_POR_DET_MASK;\n+};\n+\n+static int nxp_mcxw71_init(void)\n+{\n+\tunsigned int oldLevel; /* old interrupt lock level */\n+\n+\t/* disable interrupts */\n+\toldLevel = irq_lock();\n+\n+\t/* Initialize system clock to 40 MHz */\n+\tclock_init();\n+\n+\t/* Smart power switch initialization */\n+\tvbat_init();\n+\n+\t/* restore interrupt state */\n+\tirq_unlock(oldLevel);\n+\n+\treturn 0;\n+}\n+\n+SYS_INIT(nxp_mcxw71_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nxp/mcx/mcxw/soc.h b/soc/nxp/mcx/mcxw/soc.h\nnew file mode 100644\nindex 00000000000..bd6650d57c8\n--- /dev/null\n+++ b/soc/nxp/mcx/mcxw/soc.h\n@@ -0,0 +1,13 @@\n+/*\n+ * Copyright 2023 NXP\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+#ifndef _SOC__H_\n+#define _SOC__H_\n+\n+#include <fsl_port.h>\n+\n+#define PORT_MUX_GPIO kPORT_MuxAsGpio\n+\n+#endif /* _SOC__H_ */\ndiff --git a/soc/nxp/mcx/soc.yml b/soc/nxp/mcx/soc.yml\nindex 1f1087348b5..de7fee7da33 100644\n--- a/soc/nxp/mcx/soc.yml\n+++ b/soc/nxp/mcx/soc.yml\n@@ -17,6 +17,9 @@ family:\n   - name: mcxa\n     socs:\n     - name: mcxa156\n+  - name: mcxw\n+    socs:\n+    - name: mcxw716c\n runners:\n   run_once:\n     '--erase':\ndiff --git a/west.yml b/west.yml\nindex bb0902ee3c3..db147508b73 100644\n--- a/west.yml\n+++ b/west.yml\n@@ -198,7 +198,7 @@ manifest:\n       groups:\n         - hal\n     - name: hal_nxp\n-      revision: 17aac63df44266c4ea0e111c731ca7664fe51e70\n+      revision: f4e26fad2cfd8b8e8988e835a28667573ed072cf\n       path: modules/hal/nxp\n       groups:\n         - hal"
},{
  "instruction": "dts: nxp: Add MCXW71 DTS",
  "input": "",
  "result": "diff --git a/dts/arm/nxp/nxp_mcxw71.dtsi b/dts/arm/nxp/nxp_mcxw71.dtsi\nnew file mode 100644\nindex 00000000000..51e529e483c\n--- /dev/null\n+++ b/dts/arm/nxp/nxp_mcxw71.dtsi\n@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2023 NXP\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+#include <mem.h>\n+#include <arm/armv8-m.dtsi>\n+#include <zephyr/dt-bindings/clock/scg_k4.h>\n+#include <zephyr/dt-bindings/gpio/gpio.h>\n+#include <zephyr/dt-bindings/pwm/pwm.h>\n+#include <zephyr/dt-bindings/i2c/i2c.h>\n+\n+/ {\n+\tcpus {\n+\t\t#address-cells = <1>;\n+\t\t#size-cells = <0>;\n+\n+\t\tcpu0: cpu@0 {\n+\t\t\tcompatible = \"arm,cortex-m33f\";\n+\t\t\treg = <0>;\n+\t\t\t#address-cells = <1>;\n+\t\t\t#size-cells = <1>;\n+\n+\t\t\tmpu: mpu@e000ed90 {\n+\t\t\t\tcompatible = \"arm,armv8m-mpu\";\n+\t\t\t\treg = <0xe000ed90 0x40>;\n+\t\t\t};\n+\t\t};\n+\t};\n+\n+\tsoc {\n+\t\tctcm: sram@14000000 {\n+\t\t\tranges = <0x0 0x14000000 DT_SIZE_K(16)>;\n+\t\t\t#address-cells = <1>;\n+\t\t\t#size-cells = <1>;\n+\n+\t\t\tctcm0: code_memory@0 {\n+\t\t\t\tcompatible = \"mmio-sram\";\n+\t\t\t\treg = <0x0 DT_SIZE_K(16)>;\n+\t\t\t};\n+\t\t};\n+\n+\t\tstcm: sram@30000000 {\n+\t\t\tranges = <0x0 0x30000000 DT_SIZE_K(112)>;\n+\t\t\t#address-cells = <1>;\n+\t\t\t#size-cells = <1>;\n+\n+\t\t\tstcm0: system_memory@0 {\n+\t\t\t\tcompatible = \"mmio-sram\";\n+\t\t\t\treg = <0x0 DT_SIZE_K(64)>;\n+\t\t\t};\n+\n+\t\t\tstcm1: system_memory@1a000 {\n+\t\t\t\tcompatible = \"zephyr,memory-region\",\"mmio-sram\";\n+\t\t\t\treg = <0x1a000 DT_SIZE_K(8)>;\n+\t\t\t\tzephyr,memory-region = \"RetainedMem\";\n+\t\t\t};\n+\t\t};\n+\n+\t\tsmu2: sram@489c0000 {\n+\t\t\tranges = <0x0 0x489c0000 DT_SIZE_K(40)>;\n+\t\t\t#address-cells = <1>;\n+\t\t\t#size-cells = <1>;\n+\t\t};\n+\n+\t\tperipheral: peripheral@50000000 {\n+\t\t\tranges = <0x0 0x50000000 0x10000000>;\n+\n+\t\t\tfmu: flash-module@20000 {\n+\t\t\t\tranges = <0x0 0x10000000 DT_SIZE_M(1)>;\n+\t\t\t\t#address-cells = <1>;\n+\t\t\t\t#size-cells = <1>;\n+\n+\t\t\t\tcompatible = \"nxp,fmu-k4\";\n+\t\t\t\treg = <0x20000 0x1000>;\n+\n+\t\t\t\tflash: flash@0 {\n+\t\t\t\t\treg = <0x0 DT_SIZE_M(1)>;\n+\t\t\t\t\tcompatible = \"soc-nv-flash\";\n+\t\t\t\t\twrite-block-size = <16>;\n+\t\t\t\t\terase-block-size = <8192>;\n+\t\t\t\t};\n+\t\t\t};\n+\t\t};\n+\t};\n+\n+\tpinctrl: pinctrl {\n+\t\tcompatible = \"nxp,kinetis-pinctrl\";\n+\t};\n+};\n+\n+&nvic {\n+\tarm,num-irq-priority-bits = <3>;\n+};\n+\n+&peripheral {\n+\t#address-cells = <1>;\n+\t#size-cells = <1>;\n+\n+\tscg: scg@1e000 {\n+\t\tcompatible = \"nxp,scg-k4\";\n+\t\treg = <0x1e000 0x404>;\n+\t\t#clock-cells = <2>;\n+\t};\n+\n+\tporta: pinmux@42000 {\n+\t\tcompatible = \"nxp,kinetis-pinmux\";\n+\t\treg = <0x42000 0xe0>;\n+\t\tclocks = <&scg SCG_K4_SLOW_CLK 0x108>;\n+\t};\n+\n+\tportb: pinmux@43000 {\n+\t\tcompatible = \"nxp,kinetis-pinmux\";\n+\t\treg = <0x43000 0xe0>;\n+\t\tclocks = <&scg SCG_K4_SLOW_CLK 0x10c>;\n+\t};\n+\n+\tportc: pinmux@44000 {\n+\t\tcompatible = \"nxp,kinetis-pinmux\";\n+\t\treg = <0x44000 0xe0>;\n+\t\tclocks = <&scg SCG_K4_SLOW_CLK 0x110>;\n+\t};\n+\n+\tportd: pinmux@45000 {\n+\t\tcompatible = \"nxp,kinetis-pinmux\";\n+\t\treg = <0x45000 0xe0>;\n+\t\tclocks = <&scg SCG_K4_SLOW_CLK 0>;\n+\t};\n+\n+\tlpuart0: lpuart@38000 {\n+\t\tcompatible = \"nxp,kinetis-lpuart\";\n+\t\treg = <0x38000 0x34>;\n+\t\tinterrupts = <44 0>;\n+\t\tclocks = <&scg SCG_K4_FIRC_CLK 0xe0>;\n+\t\tstatus = \"disabled\";\n+\t};\n+\n+\tlpuart1: lpuart@39000 {\n+\t\tcompatible = \"nxp,kinetis-lpuart\";\n+\t\treg = <0x39000 0x34>;\n+\t\tinterrupts = <45 0>;\n+\t\tclocks = <&scg SCG_K4_FIRC_CLK 0xe4>;\n+\t\tstatus = \"disabled\";\n+\t};\n+\n+\tgpioa: gpio@10000{\n+\t\tcompatible = \"nxp,kinetis-gpio\";\n+\t\tstatus = \"disabled\";\n+\t\tgpio-controller;\n+\t\t#gpio-cells = <2>;\n+\t\tnxp,kinetis-port = <&porta>;\n+\t\treg = <0x10000 0x128>;\n+\t\tinterrupts = <59 0>, <60 0>;\n+\t};\n+\n+\tgpiob: gpio@20000{\n+\t\tcompatible = \"nxp,kinetis-gpio\";\n+\t\tstatus = \"disabled\";\n+\t\tgpio-controller;\n+\t\t#gpio-cells = <2>;\n+\t\tnxp,kinetis-port = <&portb>;\n+\t\treg = <0x20000 0x128>;\n+\t\tinterrupts = <61 0>, <62 0>;\n+\t};\n+\n+\tgpioc: gpio@30000{\n+\t\tcompatible = \"nxp,kinetis-gpio\";\n+\t\tstatus = \"disabled\";\n+\t\tgpio-controller;\n+\t\t#gpio-cells = <2>;\n+\t\tnxp,kinetis-port = <&portc>;\n+\t\treg = <0x30000 0x128>;\n+\t\tinterrupts = <63 0>, <64 0>;\n+\t};\n+\n+\tgpiod: gpio@46000{\n+\t\tcompatible = \"nxp,kinetis-gpio\";\n+\t\tstatus = \"disabled\";\n+\t\tgpio-controller;\n+\t\t#gpio-cells = <2>;\n+\t\tnxp,kinetis-port = <&portd>;\n+\t\treg = <0x46000 0x128>;\n+\t\tinterrupts = <65 0>, <66 0>;\n+\t};\n+\n+\tvbat: vbat@2b000 {\n+\t\treg = <0x2b000 0x400>;\n+\t\tinterrupts = <74 0>;\n+\t};\n+};"
},{
  "instruction": "drivers: kinetis-pinctrl: Account for SCG K4",
  "input": "#define PINCTRL_MCUX_DT_INST_CLOCK_SUBSYS(n) \\\n\tCLK_GATE_DEFINE(DT_INST_CLOCKS_CELL(n, offset), \\\n\t\t\tDT_INST_CLOCKS_CELL(n, bits))",
  "result": "diff --git a/drivers/pinctrl/pinctrl_kinetis.c b/drivers/pinctrl/pinctrl_kinetis.c\nindex 13b0c8ac720..7a8151c7be1 100644\n--- a/drivers/pinctrl/pinctrl_kinetis.c\n+++ b/drivers/pinctrl/pinctrl_kinetis.c\n@@ -76,9 +76,13 @@ static int pinctrl_mcux_init(const struct device *dev)\n }\n \n #if DT_NODE_HAS_STATUS(DT_INST(0, nxp_kinetis_sim), okay)\n-#define PINCTRL_MCUX_DT_INST_CLOCK_SUBSYS(n) \\\n-\tCLK_GATE_DEFINE(DT_INST_CLOCKS_CELL(n, offset), \\\n-\t\t\tDT_INST_CLOCKS_CELL(n, bits))\n+#define PINCTRL_MCUX_DT_INST_CLOCK_SUBSYS(n)                                                       \\\n+\tCLK_GATE_DEFINE(DT_INST_CLOCKS_CELL(n, offset), DT_INST_CLOCKS_CELL(n, bits))\n+#elif DT_HAS_COMPAT_STATUS_OKAY(nxp_scg_k4)\n+#define PINCTRL_MCUX_DT_INST_CLOCK_SUBSYS(n)                                                       \\\n+\t(DT_INST_CLOCKS_CELL(n, mrcc_offset) == 0                                                  \\\n+\t\t ? 0                                                                               \\\n+\t\t : MAKE_MRCC_REGADDR(MRCC_BASE, DT_INST_CLOCKS_CELL(n, mrcc_offset)))\n #else\n #define PINCTRL_MCUX_DT_INST_CLOCK_SUBSYS(n) \\\n \tDT_INST_CLOCKS_CELL(n, name)"
},{
  "instruction": "drivers: clock_control: Add MCUX SCG K4 driver",
  "input": "",
  "result": "diff --git a/drivers/clock_control/CMakeLists.txt b/drivers/clock_control/CMakeLists.txt\nindex ffc19a3b729..e08891a42c7 100644\n--- a/drivers/clock_control/CMakeLists.txt\n+++ b/drivers/clock_control/CMakeLists.txt\n@@ -16,6 +16,7 @@ zephyr_library_sources_ifdef(CONFIG_CLOCK_CONTROL_MCUX_CCM_REV2       clock_cont\n zephyr_library_sources_ifdef(CONFIG_CLOCK_CONTROL_MCUX_MCG            clock_control_mcux_mcg.c)\n zephyr_library_sources_ifdef(CONFIG_CLOCK_CONTROL_MCUX_PCC            clock_control_mcux_pcc.c)\n zephyr_library_sources_ifdef(CONFIG_CLOCK_CONTROL_MCUX_SCG            clock_control_mcux_scg.c)\n+zephyr_library_sources_ifdef(CONFIG_CLOCK_CONTROL_MCUX_SCG_K4         clock_control_mcux_scg_k4.c)\n zephyr_library_sources_ifdef(CONFIG_CLOCK_CONTROL_MCUX_SIM            clock_control_mcux_sim.c)\n zephyr_library_sources_ifdef(CONFIG_CLOCK_CONTROL_MCUX_SYSCON         clock_control_mcux_syscon.c)\n zephyr_library_sources_ifdef(CONFIG_CLOCK_CONTROL_NPCX                clock_control_npcx.c)\ndiff --git a/drivers/clock_control/Kconfig.mcux_scg b/drivers/clock_control/Kconfig.mcux_scg\nindex 413db3bdd58..1096154be60 100644\n--- a/drivers/clock_control/Kconfig.mcux_scg\n+++ b/drivers/clock_control/Kconfig.mcux_scg\n@@ -1,6 +1,7 @@\n # MCUXpresso SDK SCG\n \n # Copyright (c) 2019 Vestas Wind Systems A/S\n+# Copyright 2023 NXP\n # SPDX-License-Identifier: Apache-2.0\n \n config CLOCK_CONTROL_MCUX_SCG\n@@ -9,3 +10,10 @@ config CLOCK_CONTROL_MCUX_SCG\n \tdepends on DT_HAS_NXP_KINETIS_SCG_ENABLED\n \thelp\n \t  Enable support for mcux scg driver.\n+\n+config CLOCK_CONTROL_MCUX_SCG_K4\n+\tbool \"MCUX driver for K4 Generation SCG\"\n+\tdefault y\n+\tdepends on DT_HAS_NXP_SCG_K4_ENABLED\n+\thelp\n+\t  Enable support for SCG K4 driver\ndiff --git a/drivers/clock_control/clock_control_mcux_scg_k4.c b/drivers/clock_control/clock_control_mcux_scg_k4.c\nnew file mode 100644\nindex 00000000000..7b9df3fe9e6\n--- /dev/null\n+++ b/drivers/clock_control/clock_control_mcux_scg_k4.c\n@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2023 NXP\n+ *\n+ * Based on clock_control_mcux_scg.c, which is:\n+ * Copyright (c) 2019-2021 Vestas Wind Systems A/S\n+ * Copyright (c) 2017, NXP\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+#define DT_DRV_COMPAT nxp_scg_k4\n+\n+#include <zephyr/drivers/clock_control.h>\n+#include <zephyr/dt-bindings/clock/scg_k4.h>\n+#include <soc.h>\n+#include <fsl_clock.h>\n+\n+#define LOG_LEVEL CONFIG_CLOCK_CONTROL_LOG_LEVEL\n+#include <zephyr/logging/log.h>\n+LOG_MODULE_REGISTER(clock_control_scg);\n+\n+#define MCUX_SCG_CLOCK_NODE(name) DT_INST_CHILD(0, name)\n+\n+static int mcux_scg_k4_on(const struct device *dev, clock_control_subsys_t sub_system)\n+{\n+\treturn 0;\n+}\n+\n+static int mcux_scg_k4_off(const struct device *dev, clock_control_subsys_t sub_system)\n+{\n+\treturn 0;\n+}\n+\n+static int mcux_scg_k4_get_rate(const struct device *dev, clock_control_subsys_t sub_system,\n+\t\t\t\tuint32_t *rate)\n+{\n+\tclock_name_t clock_name;\n+\n+\tswitch ((uint32_t)sub_system) {\n+\tcase SCG_K4_CORESYS_CLK:\n+\t\tclock_name = kCLOCK_CoreSysClk;\n+\t\tbreak;\n+\tcase SCG_K4_SLOW_CLK:\n+\t\tclock_name = kCLOCK_SlowClk;\n+\t\tbreak;\n+\tcase SCG_K4_PLAT_CLK:\n+\t\tclock_name = kCLOCK_PlatClk;\n+\t\tbreak;\n+\tcase SCG_K4_SYS_CLK:\n+\t\tclock_name = kCLOCK_SysClk;\n+\t\tbreak;\n+\tcase SCG_K4_BUS_CLK:\n+\t\tclock_name = kCLOCK_BusClk;\n+\t\tbreak;\n+\tcase SCG_K4_SYSOSC_CLK:\n+\t\tclock_name = kCLOCK_ScgSysOscClk;\n+\t\tbreak;\n+\tcase SCG_K4_SIRC_CLK:\n+\t\tclock_name = kCLOCK_ScgSircClk;\n+\t\tbreak;\n+\tcase SCG_K4_FIRC_CLK:\n+\t\tclock_name = kCLOCK_ScgFircClk;\n+\t\tbreak;\n+\tcase SCG_K4_RTCOSC_CLK:\n+\t\tclock_name = kCLOCK_RtcOscClk;\n+\t\tbreak;\n+\tdefault:\n+\t\tLOG_ERR(\"Unsupported clock name\");\n+\t\treturn -EINVAL;\n+\t}\n+\n+\t*rate = CLOCK_GetFreq(clock_name);\n+\treturn 0;\n+}\n+\n+static const struct clock_control_driver_api mcux_scg_driver_api = {\n+\t.on = mcux_scg_k4_on,\n+\t.off = mcux_scg_k4_off,\n+\t.get_rate = mcux_scg_k4_get_rate,\n+};\n+\n+DEVICE_DT_INST_DEFINE(0, NULL, NULL, NULL, NULL, PRE_KERNEL_1,\n+\t\t      CONFIG_CLOCK_CONTROL_INIT_PRIORITY, &mcux_scg_driver_api);\ndiff --git a/dts/bindings/clock/nxp,scg-k4.yaml b/dts/bindings/clock/nxp,scg-k4.yaml\nnew file mode 100644\nindex 00000000000..db3c39fbcc4\n--- /dev/null\n+++ b/dts/bindings/clock/nxp,scg-k4.yaml\n@@ -0,0 +1,19 @@\n+# Copyright 2023 NXP\n+# SPDX-License-Identifier: Apache-2.0\n+\n+description: NXP K4 Generation SCG (System Clock Generator) IP node\n+\n+compatible: \"nxp,scg-k4\"\n+\n+include: [clock-controller.yaml, base.yaml]\n+\n+properties:\n+  reg:\n+    required: true\n+\n+  \"#clock-cells\":\n+    const: 2\n+\n+clock-cells:\n+  - name\n+  - mrcc_offset # See fsl_clock.h clock IP names, 0 if N/A\ndiff --git a/include/zephyr/dt-bindings/clock/scg_k4.h b/include/zephyr/dt-bindings/clock/scg_k4.h\nnew file mode 100644\nindex 00000000000..985629a1f69\n--- /dev/null\n+++ b/include/zephyr/dt-bindings/clock/scg_k4.h\n@@ -0,0 +1,14 @@\n+/*\n+ * Copyright 2023 NXP\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+#define SCG_K4_CORESYS_CLK 0U\n+#define SCG_K4_SLOW_CLK    1U\n+#define SCG_K4_PLAT_CLK    2U\n+#define SCG_K4_SYS_CLK     3U\n+#define SCG_K4_BUS_CLK     4U\n+#define SCG_K4_SYSOSC_CLK  5U\n+#define SCG_K4_SIRC_CLK    6U\n+#define SCG_K4_FIRC_CLK    7U\n+#define SCG_K4_RTCOSC_CLK  8U"
},{
  "instruction": "boards: ct: ctcc: Fix unit and first address mismatch",
  "input": "\t\tslot1_partition: partition@87000 {",
  "result": "diff --git a/boards/ct/ctcc/ctcc_nrf52840.dts b/boards/ct/ctcc/ctcc_nrf52840.dts\nindex 0e026d1a828..13b88e1ee05 100644\n--- a/boards/ct/ctcc/ctcc_nrf52840.dts\n+++ b/boards/ct/ctcc/ctcc_nrf52840.dts\n@@ -58,7 +58,7 @@\n \t\t\tlabel = \"image-0\";\n \t\t\treg = <0x00012000 0x00076000>;\n \t\t};\n-\t\tslot1_partition: partition@87000 {\n+\t\tslot1_partition: partition@88000 {\n \t\t\tlabel = \"image-1\";\n \t\t\treg = <0x00088000 0x00074000>;\n \t\t};"
},{
  "instruction": "boards: arduino: nano_33_iot: Fix unit and first address mismatch",
  "input": "\tatecc608a@15 {",
  "result": "diff --git a/boards/arduino/nano_33_iot/arduino_nano_33_iot.dts b/boards/arduino/nano_33_iot/arduino_nano_33_iot.dts\nindex 6cce683f0a9..f5fc56c015f 100644\n--- a/boards/arduino/nano_33_iot/arduino_nano_33_iot.dts\n+++ b/boards/arduino/nano_33_iot/arduino_nano_33_iot.dts\n@@ -114,7 +114,7 @@\n \t\treg = <0x6a>;\n \t};\n \n-\tatecc608a@15 {\n+\tatecc608a@6a {\n \t\tcompatible = \"atmel,atecc608\";\n \t\treg = <0x6a>;\n \t};"
},{
  "instruction": "boards: seagate: legend: Fix unit and first address mismatch",
  "input": "\t\t\tled_das: partition@10000 {",
  "result": "diff --git a/boards/seagate/legend/legend.dts b/boards/seagate/legend/legend.dts\nindex d230345dd07..cb576ed09dd 100644\n--- a/boards/seagate/legend/legend.dts\n+++ b/boards/seagate/legend/legend.dts\n@@ -137,7 +137,7 @@\n \t\t\t\tlabel = \"product-info\";\n \t\t\t\treg = <0x00000000 DT_SIZE_K(4)>;\n \t\t\t};\n-\t\t\tled_das: partition@10000 {\n+\t\t\tled_das: partition@1000 {\n \t\t\t\tlabel = \"led-das\";\n \t\t\t\treg = <0x00001000 DT_SIZE_K(60)>;\n \t\t\t};"
},{
  "instruction": "drivers: mipi_dbi: add support for parallel 8080/6800 modes using GPIO",
  "input": "\t/** MIPI DBI mode (SPI 3 wire or 4 wire) */",
  "result": "diff --git a/drivers/mipi_dbi/CMakeLists.txt b/drivers/mipi_dbi/CMakeLists.txt\nindex dcbf29571ab..3bd1ee28473 100644\n--- a/drivers/mipi_dbi/CMakeLists.txt\n+++ b/drivers/mipi_dbi/CMakeLists.txt\n@@ -3,6 +3,7 @@\n # SPDX-License-Identifier: Apache-2.0\n \n zephyr_sources_ifdef(CONFIG_MIPI_DBI_SPI mipi_dbi_spi.c)\n+zephyr_sources_ifdef(CONFIG_MIPI_DBI_BITBANG mipi_dbi_bitbang.c)\n zephyr_sources_ifdef(CONFIG_MIPI_DBI_SMARTBOND mipi_dbi_smartbond.c)\n zephyr_sources_ifdef(CONFIG_MIPI_DBI_NXP_LCDIC mipi_dbi_nxp_lcdic.c)\n zephyr_sources_ifdef(CONFIG_MIPI_DBI_NXP_FLEXIO_LCDIF mipi_dbi_nxp_flexio_lcdif.c)\ndiff --git a/drivers/mipi_dbi/Kconfig b/drivers/mipi_dbi/Kconfig\nindex 0782664a3ef..ab3ac43c76e 100644\n--- a/drivers/mipi_dbi/Kconfig\n+++ b/drivers/mipi_dbi/Kconfig\n@@ -22,6 +22,7 @@ config MIPI_DBI_INIT_PRIORITY\n \t  MIPI-DBI Host Controllers initialization priority.\n \n source \"drivers/mipi_dbi/Kconfig.spi\"\n+source \"drivers/mipi_dbi/Kconfig.bitbang\"\n source \"drivers/mipi_dbi/Kconfig.smartbond\"\n source \"drivers/mipi_dbi/Kconfig.nxp_lcdic\"\n source \"drivers/mipi_dbi/Kconfig.nxp_flexio_lcdif\"\ndiff --git a/drivers/mipi_dbi/Kconfig.bitbang b/drivers/mipi_dbi/Kconfig.bitbang\nnew file mode 100644\nindex 00000000000..aafc8ed9f2d\n--- /dev/null\n+++ b/drivers/mipi_dbi/Kconfig.bitbang\n@@ -0,0 +1,11 @@\n+# Copyright 2024 Stefan Gloor\n+# SPDX-License-Identifier: Apache-2.0\n+\n+config MIPI_DBI_BITBANG\n+\tbool \"MIPI DBI bit banging driver\"\n+\tdefault y\n+\tdepends on DT_HAS_ZEPHYR_MIPI_DBI_BITBANG_ENABLED\n+\tselect GPIO\n+\thelp\n+\t  Enable support for MIPI DBI bit banging driver. This driver implements\n+\t  a MIPI-DBI mode A and B compatible controller using GPIO.\ndiff --git a/drivers/mipi_dbi/mipi_dbi_bitbang.c b/drivers/mipi_dbi/mipi_dbi_bitbang.c\nnew file mode 100644\nindex 00000000000..5c2b39f1749\n--- /dev/null\n+++ b/drivers/mipi_dbi/mipi_dbi_bitbang.c\n@@ -0,0 +1,347 @@\n+/*\n+ * MIPI DBI Type A and B driver using GPIO\n+ *\n+ * Copyright 2024 Stefan Gloor\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+#define DT_DRV_COMPAT zephyr_mipi_dbi_bitbang\n+\n+#include <zephyr/drivers/mipi_dbi.h>\n+#include <zephyr/drivers/gpio.h>\n+\n+#include <zephyr/logging/log.h>\n+LOG_MODULE_REGISTER(mipi_dbi_bitbang, CONFIG_MIPI_DBI_LOG_LEVEL);\n+\n+/* The MIPI DBI spec allows 8, 9, and 16 bits */\n+#define MIPI_DBI_MAX_DATA_BUS_WIDTH 16\n+\n+/* Compile in a data bus LUT for improved performance if at least one instance uses an 8-bit bus */\n+#define _8_BIT_MODE_PRESENT(n) (DT_INST_PROP_LEN(n, data_gpios) == 8) |\n+#define MIPI_DBI_8_BIT_MODE    DT_INST_FOREACH_STATUS_OKAY(_8_BIT_MODE_PRESENT) 0\n+\n+struct mipi_dbi_bitbang_config {\n+\t/* Parallel 8080/6800 data GPIOs */\n+\tconst struct gpio_dt_spec data[MIPI_DBI_MAX_DATA_BUS_WIDTH];\n+\tconst uint8_t data_bus_width;\n+\n+\t/* Read (type B) GPIO */\n+\tconst struct gpio_dt_spec rd;\n+\n+\t/* Write (type B) or Read/!Write (type A) GPIO */\n+\tconst struct gpio_dt_spec wr;\n+\n+\t/* Enable/strobe GPIO (type A) */\n+\tconst struct gpio_dt_spec e;\n+\n+\t/* Chip-select GPIO */\n+\tconst struct gpio_dt_spec cs;\n+\n+\t/* Command/Data GPIO */\n+\tconst struct gpio_dt_spec cmd_data;\n+\n+\t/* Reset GPIO */\n+\tconst struct gpio_dt_spec reset;\n+\n+#if MIPI_DBI_8_BIT_MODE\n+\t/* Data GPIO remap look-up table. Valid if mipi_dbi_bitbang_data.single_port is set */\n+\tconst uint32_t data_lut[256];\n+\n+\t/* Mask of all data pins. Valid if mipi_dbi_bitbang_data.single_port is set */\n+\tconst uint32_t data_mask;\n+#endif\n+};\n+\n+struct mipi_dbi_bitbang_data {\n+\tstruct k_mutex lock;\n+\n+#if MIPI_DBI_8_BIT_MODE\n+\t/* Indicates whether all data GPIO pins are on the same port and the data LUT is used. */\n+\tbool single_port;\n+\n+\t/* Data GPIO port device. Valid if mipi_dbi_bitbang_data.single_port is set */\n+\tconst struct device *data_port;\n+#endif\n+};\n+\n+static inline void mipi_dbi_bitbang_set_data_gpios(const struct mipi_dbi_bitbang_config *config,\n+\t\t\t\t\t\t   struct mipi_dbi_bitbang_data *data,\n+\t\t\t\t\t\t   uint32_t value)\n+{\n+#if MIPI_DBI_8_BIT_MODE\n+\tif (data->single_port) {\n+\t\tgpio_port_set_masked(data->data_port, config->data_mask, config->data_lut[value]);\n+\t} else {\n+#endif\n+\t\tfor (int i = 0; i < config->data_bus_width; i++) {\n+\t\t\tgpio_pin_set_dt(&config->data[i], (value & (1 << i)) != 0);\n+\t\t}\n+#if MIPI_DBI_8_BIT_MODE\n+\t}\n+#endif\n+}\n+\n+static int mipi_dbi_bitbang_write_helper(const struct device *dev,\n+\t\t\t\t\t const struct mipi_dbi_config *dbi_config, bool cmd_present,\n+\t\t\t\t\t uint8_t cmd, const uint8_t *data_buf, size_t len)\n+{\n+\tconst struct mipi_dbi_bitbang_config *config = dev->config;\n+\tstruct mipi_dbi_bitbang_data *data = dev->data;\n+\tint ret = 0;\n+\tuint8_t value;\n+\n+\tret = k_mutex_lock(&data->lock, K_FOREVER);\n+\tif (ret < 0) {\n+\t\treturn ret;\n+\t}\n+\n+\tswitch (dbi_config->mode) {\n+\tcase MIPI_DBI_MODE_8080_BUS_8_BIT:\n+\tcase MIPI_DBI_MODE_8080_BUS_9_BIT:\n+\tcase MIPI_DBI_MODE_8080_BUS_16_BIT:\n+\t\tgpio_pin_set_dt(&config->cs, 1);\n+\t\tif (cmd_present) {\n+\t\t\tgpio_pin_set_dt(&config->wr, 0);\n+\t\t\tgpio_pin_set_dt(&config->cmd_data, 0);\n+\t\t\tmipi_dbi_bitbang_set_data_gpios(config, data, cmd);\n+\t\t\tgpio_pin_set_dt(&config->wr, 1);\n+\t\t}\n+\t\tif (len > 0) {\n+\t\t\tgpio_pin_set_dt(&config->cmd_data, 1);\n+\t\t\twhile (len > 0) {\n+\t\t\t\tvalue = *(data_buf++);\n+\t\t\t\tgpio_pin_set_dt(&config->wr, 0);\n+\t\t\t\tmipi_dbi_bitbang_set_data_gpios(config, data, value);\n+\t\t\t\tgpio_pin_set_dt(&config->wr, 1);\n+\t\t\t\tlen--;\n+\t\t\t}\n+\t\t}\n+\t\tgpio_pin_set_dt(&config->cs, 0);\n+\t\tbreak;\n+\n+\t/* Clocked E mode */\n+\tcase MIPI_DBI_MODE_6800_BUS_8_BIT:\n+\tcase MIPI_DBI_MODE_6800_BUS_9_BIT:\n+\tcase MIPI_DBI_MODE_6800_BUS_16_BIT:\n+\t\tgpio_pin_set_dt(&config->cs, 1);\n+\t\tgpio_pin_set_dt(&config->wr, 0);\n+\t\tif (cmd_present) {\n+\t\t\tgpio_pin_set_dt(&config->e, 1);\n+\t\t\tgpio_pin_set_dt(&config->cmd_data, 0);\n+\t\t\tmipi_dbi_bitbang_set_data_gpios(config, data, cmd);\n+\t\t\tgpio_pin_set_dt(&config->e, 0);\n+\t\t}\n+\t\tif (len > 0) {\n+\t\t\tgpio_pin_set_dt(&config->cmd_data, 1);\n+\t\t\twhile (len > 0) {\n+\t\t\t\tvalue = *(data_buf++);\n+\t\t\t\tgpio_pin_set_dt(&config->e, 1);\n+\t\t\t\tmipi_dbi_bitbang_set_data_gpios(config, data, value);\n+\t\t\t\tgpio_pin_set_dt(&config->e, 0);\n+\t\t\t\tlen--;\n+\t\t\t}\n+\t\t}\n+\t\tgpio_pin_set_dt(&config->cs, 0);\n+\t\tbreak;\n+\n+\tdefault:\n+\t\tLOG_ERR(\"MIPI DBI mode %u is not supported.\", dbi_config->mode);\n+\t\tret = -ENOTSUP;\n+\t}\n+\n+\tk_mutex_unlock(&data->lock);\n+\treturn ret;\n+}\n+\n+static int mipi_dbi_bitbang_command_write(const struct device *dev,\n+\t\t\t\t\t  const struct mipi_dbi_config *dbi_config, uint8_t cmd,\n+\t\t\t\t\t  const uint8_t *data_buf, size_t len)\n+{\n+\treturn mipi_dbi_bitbang_write_helper(dev, dbi_config, true, cmd, data_buf, len);\n+}\n+\n+static int mipi_dbi_bitbang_write_display(const struct device *dev,\n+\t\t\t\t\t  const struct mipi_dbi_config *dbi_config,\n+\t\t\t\t\t  const uint8_t *framebuf,\n+\t\t\t\t\t  struct display_buffer_descriptor *desc,\n+\t\t\t\t\t  enum display_pixel_format pixfmt)\n+{\n+\tARG_UNUSED(pixfmt);\n+\n+\treturn mipi_dbi_bitbang_write_helper(dev, dbi_config, false, 0x0, framebuf, desc->buf_size);\n+}\n+\n+static int mipi_dbi_bitbang_reset(const struct device *dev, k_timeout_t delay)\n+{\n+\tconst struct mipi_dbi_bitbang_config *config = dev->config;\n+\tint ret;\n+\n+\tLOG_DBG(\"Performing hw reset.\");\n+\n+\tret = gpio_pin_set_dt(&config->reset, 1);\n+\tif (ret < 0) {\n+\t\treturn ret;\n+\t}\n+\tk_sleep(delay);\n+\treturn gpio_pin_set_dt(&config->reset, 0);\n+}\n+\n+static int mipi_dbi_bitbang_init(const struct device *dev)\n+{\n+\tconst struct mipi_dbi_bitbang_config *config = dev->config;\n+\tconst char *failed_pin = NULL;\n+\tint ret = 0;\n+#if MIPI_DBI_8_BIT_MODE\n+\tstruct mipi_dbi_bitbang_data *data = dev->data;\n+#endif\n+\n+\tif (gpio_is_ready_dt(&config->cmd_data)) {\n+\t\tret = gpio_pin_configure_dt(&config->cmd_data, GPIO_OUTPUT_ACTIVE);\n+\t\tif (ret < 0) {\n+\t\t\tfailed_pin = \"cmd_data\";\n+\t\t\tgoto fail;\n+\t\t}\n+\t\tgpio_pin_set_dt(&config->cmd_data, 0);\n+\t}\n+\tif (gpio_is_ready_dt(&config->rd)) {\n+\t\tgpio_pin_configure_dt(&config->rd, GPIO_OUTPUT_ACTIVE);\n+\t\t/* Don't emit an error because this pin is unused in type A */\n+\t\tgpio_pin_set_dt(&config->rd, 1);\n+\t}\n+\tif (gpio_is_ready_dt(&config->wr)) {\n+\t\tret = gpio_pin_configure_dt(&config->wr, GPIO_OUTPUT_ACTIVE);\n+\t\tif (ret < 0) {\n+\t\t\tfailed_pin = \"wr\";\n+\t\t\tgoto fail;\n+\t\t}\n+\t\tgpio_pin_set_dt(&config->wr, 1);\n+\t}\n+\tif (gpio_is_ready_dt(&config->e)) {\n+\t\tgpio_pin_configure_dt(&config->e, GPIO_OUTPUT_ACTIVE);\n+\t\t/* Don't emit an error because this pin is unused in type B */\n+\t\tgpio_pin_set_dt(&config->e, 0);\n+\t}\n+\tif (gpio_is_ready_dt(&config->cs)) {\n+\t\tret = gpio_pin_configure_dt(&config->cs, GPIO_OUTPUT_ACTIVE);\n+\t\tif (ret < 0) {\n+\t\t\tfailed_pin = \"cs\";\n+\t\t\tgoto fail;\n+\t\t}\n+\t\tgpio_pin_set_dt(&config->cs, 0);\n+\t}\n+\tif (gpio_is_ready_dt(&config->reset)) {\n+\t\tret = gpio_pin_configure_dt(&config->reset, GPIO_OUTPUT_ACTIVE);\n+\t\tif (ret < 0) {\n+\t\t\tfailed_pin = \"reset\";\n+\t\t\tgoto fail;\n+\t\t}\n+\t\tgpio_pin_set_dt(&config->reset, 0);\n+\t}\n+\tfor (int i = 0; i < config->data_bus_width; i++) {\n+\t\tif (gpio_is_ready_dt(&config->data[i])) {\n+\t\t\tret = gpio_pin_configure_dt(&config->data[i], GPIO_OUTPUT_ACTIVE);\n+\t\t\tif (ret < 0) {\n+\t\t\t\tfailed_pin = \"data\";\n+\t\t\t\tgoto fail;\n+\t\t\t}\n+\t\t\tgpio_pin_set_dt(&config->data[i], 0);\n+\t\t}\n+\t}\n+\n+#if MIPI_DBI_8_BIT_MODE\n+\t/* To optimize performance, we test whether all the data pins are\n+\t * on the same port. If they are, we can set the whole port in one go\n+\t * instead of setting each pin individually.\n+\t * For 8-bit mode only because LUT size grows exponentially.\n+\t */\n+\tif (config->data_bus_width == 8) {\n+\t\tdata->single_port = true;\n+\t\tdata->data_port = config->data[0].port;\n+\t\tfor (int i = 1; i < config->data_bus_width; i++) {\n+\t\t\tif (data->data_port != config->data[i].port) {\n+\t\t\t\tdata->single_port = false;\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif (data->single_port) {\n+\t\tLOG_DBG(\"LUT optimization enabled. data_mask=0x%x\", config->data_mask);\n+\t}\n+#endif\n+\n+\treturn ret;\n+fail:\n+\tLOG_ERR(\"Failed to configure %s GPIO pin.\", failed_pin);\n+\treturn ret;\n+}\n+\n+static const struct mipi_dbi_driver_api mipi_dbi_bitbang_driver_api = {\n+\t.reset = mipi_dbi_bitbang_reset,\n+\t.command_write = mipi_dbi_bitbang_command_write,\n+\t.write_display = mipi_dbi_bitbang_write_display\n+};\n+\n+/* This macro is repeatedly called by LISTIFY() at compile-time to generate the data bus LUT */\n+#define LUT_GEN(i, n) (((i & (1 << 0)) ? (1 << DT_INST_GPIO_PIN_BY_IDX(n, data_gpios, 0)) : 0) |   \\\n+\t\t       ((i & (1 << 1)) ? (1 << DT_INST_GPIO_PIN_BY_IDX(n, data_gpios, 1)) : 0) |   \\\n+\t\t       ((i & (1 << 2)) ? (1 << DT_INST_GPIO_PIN_BY_IDX(n, data_gpios, 2)) : 0) |   \\\n+\t\t       ((i & (1 << 3)) ? (1 << DT_INST_GPIO_PIN_BY_IDX(n, data_gpios, 3)) : 0) |   \\\n+\t\t       ((i & (1 << 4)) ? (1 << DT_INST_GPIO_PIN_BY_IDX(n, data_gpios, 4)) : 0) |   \\\n+\t\t       ((i & (1 << 5)) ? (1 << DT_INST_GPIO_PIN_BY_IDX(n, data_gpios, 5)) : 0) |   \\\n+\t\t       ((i & (1 << 6)) ? (1 << DT_INST_GPIO_PIN_BY_IDX(n, data_gpios, 6)) : 0) |   \\\n+\t\t       ((i & (1 << 7)) ? (1 << DT_INST_GPIO_PIN_BY_IDX(n, data_gpios, 7)) : 0))\n+\n+/* If at least one instance has an 8-bit bus, add a data look-up table to the read-only config.\n+ * Whether or not it is valid and actually used for a particular instance is decided at runtime\n+ * and stored in the instance's mipi_dbi_bitbang_data.single_port.\n+ */\n+#if MIPI_DBI_8_BIT_MODE\n+#define DATA_LUT_OPTIMIZATION(n)                                                                   \\\n+\t\t.data_lut = { LISTIFY(256, LUT_GEN, (,), n) },                                     \\\n+\t\t.data_mask = ((1 << DT_INST_GPIO_PIN_BY_IDX(n, data_gpios, 0)) |                   \\\n+\t\t\t      (1 << DT_INST_GPIO_PIN_BY_IDX(n, data_gpios, 1)) |                   \\\n+\t\t\t      (1 << DT_INST_GPIO_PIN_BY_IDX(n, data_gpios, 2)) |                   \\\n+\t\t\t      (1 << DT_INST_GPIO_PIN_BY_IDX(n, data_gpios, 3)) |                   \\\n+\t\t\t      (1 << DT_INST_GPIO_PIN_BY_IDX(n, data_gpios, 4)) |                   \\\n+\t\t\t      (1 << DT_INST_GPIO_PIN_BY_IDX(n, data_gpios, 5)) |                   \\\n+\t\t\t      (1 << DT_INST_GPIO_PIN_BY_IDX(n, data_gpios, 6)) |                   \\\n+\t\t\t      (1 << DT_INST_GPIO_PIN_BY_IDX(n, data_gpios, 7)))\n+#else\n+#define DATA_LUT_OPTIMIZATION(n)\n+#endif\n+\n+#define MIPI_DBI_BITBANG_INIT(n)                                                                   \\\n+\tstatic const struct mipi_dbi_bitbang_config mipi_dbi_bitbang_config_##n = {                \\\n+\t\t.data = {GPIO_DT_SPEC_INST_GET_BY_IDX_OR(n, data_gpios, 0, {0}),                   \\\n+\t\t\t GPIO_DT_SPEC_INST_GET_BY_IDX_OR(n, data_gpios, 1, {0}),                   \\\n+\t\t\t GPIO_DT_SPEC_INST_GET_BY_IDX_OR(n, data_gpios, 2, {0}),                   \\\n+\t\t\t GPIO_DT_SPEC_INST_GET_BY_IDX_OR(n, data_gpios, 3, {0}),                   \\\n+\t\t\t GPIO_DT_SPEC_INST_GET_BY_IDX_OR(n, data_gpios, 4, {0}),                   \\\n+\t\t\t GPIO_DT_SPEC_INST_GET_BY_IDX_OR(n, data_gpios, 5, {0}),                   \\\n+\t\t\t GPIO_DT_SPEC_INST_GET_BY_IDX_OR(n, data_gpios, 6, {0}),                   \\\n+\t\t\t GPIO_DT_SPEC_INST_GET_BY_IDX_OR(n, data_gpios, 7, {0}),                   \\\n+\t\t\t GPIO_DT_SPEC_INST_GET_BY_IDX_OR(n, data_gpios, 8, {0}),                   \\\n+\t\t\t GPIO_DT_SPEC_INST_GET_BY_IDX_OR(n, data_gpios, 9, {0}),                   \\\n+\t\t\t GPIO_DT_SPEC_INST_GET_BY_IDX_OR(n, data_gpios, 10, {0}),                  \\\n+\t\t\t GPIO_DT_SPEC_INST_GET_BY_IDX_OR(n, data_gpios, 11, {0}),                  \\\n+\t\t\t GPIO_DT_SPEC_INST_GET_BY_IDX_OR(n, data_gpios, 12, {0}),                  \\\n+\t\t\t GPIO_DT_SPEC_INST_GET_BY_IDX_OR(n, data_gpios, 13, {0}),                  \\\n+\t\t\t GPIO_DT_SPEC_INST_GET_BY_IDX_OR(n, data_gpios, 14, {0}),                  \\\n+\t\t\t GPIO_DT_SPEC_INST_GET_BY_IDX_OR(n, data_gpios, 15, {0})},                 \\\n+\t\t.data_bus_width = DT_INST_PROP_LEN(n, data_gpios),                                 \\\n+\t\t.rd = GPIO_DT_SPEC_INST_GET_OR(n, rd_gpios, {}),                                   \\\n+\t\t.wr = GPIO_DT_SPEC_INST_GET_OR(n, wr_gpios, {}),                                   \\\n+\t\t.e = GPIO_DT_SPEC_INST_GET_OR(n, e_gpios, {}),                                     \\\n+\t\t.cs = GPIO_DT_SPEC_INST_GET_OR(n, cs_gpios, {}),                                   \\\n+\t\t.cmd_data = GPIO_DT_SPEC_INST_GET_OR(n, dc_gpios, {}),                             \\\n+\t\t.reset = GPIO_DT_SPEC_INST_GET_OR(n, reset_gpios, {}),                             \\\n+\t\tDATA_LUT_OPTIMIZATION(n)                                                           \\\n+\t};                                                                                         \\\n+\tBUILD_ASSERT(DT_INST_PROP_LEN(n, data_gpios) < MIPI_DBI_MAX_DATA_BUS_WIDTH,                \\\n+\t\t     \"Number of data GPIOs in DT exceeds MIPI_DBI_MAX_DATA_BUS_WIDTH\");            \\\n+\tstatic struct mipi_dbi_bitbang_data mipi_dbi_bitbang_data_##n;                             \\\n+\tDEVICE_DT_INST_DEFINE(n, mipi_dbi_bitbang_init, NULL, &mipi_dbi_bitbang_data_##n,          \\\n+\t\t\t      &mipi_dbi_bitbang_config_##n, POST_KERNEL,                           \\\n+\t\t\t      CONFIG_MIPI_DBI_INIT_PRIORITY, &mipi_dbi_bitbang_driver_api);\n+\n+DT_INST_FOREACH_STATUS_OKAY(MIPI_DBI_BITBANG_INIT)\ndiff --git a/dts/bindings/mipi-dbi/zephyr,mipi-dbi-bitbang.yaml b/dts/bindings/mipi-dbi/zephyr,mipi-dbi-bitbang.yaml\nnew file mode 100644\nindex 00000000000..c0725d9a26b\n--- /dev/null\n+++ b/dts/bindings/mipi-dbi/zephyr,mipi-dbi-bitbang.yaml\n@@ -0,0 +1,56 @@\n+# Copyright 2024 Stefan Gloor\n+#\n+# SPDX-License-Identifier: Apache-2.0\n+\n+description: |\n+  MIPI-DBI Mode A and B bit banging controller. This driver emulates MIPI DBI mode A and B (6800\n+  and 8080 parallel interfaces) using GPIO pins.\n+\n+compatible: \"zephyr,mipi-dbi-bitbang\"\n+\n+include: [\"mipi-dbi-controller.yaml\", \"pinctrl-device.yaml\"]\n+\n+properties:\n+\n+  dc-gpios:\n+    type: phandle-array\n+    required: true\n+    description: |\n+      Data/command GPIO pin. Set to low when sending a command, or high when sending data.\n+\n+  reset-gpios:\n+    type: phandle-array\n+    required: true\n+    description: |\n+      Reset GPIO pin. Set high to reset the display.\n+\n+  rd-gpios:\n+    type: phandle-array\n+    description: |\n+      Read GPIO pin. Set high when reading from the display. Required for type B (Intel 8080) mode,\n+      unused for type A (Motorola 6800).\n+\n+  wr-gpios:\n+    type: phandle-array\n+    required: true\n+    description: |\n+      Write GPIO pin for type B (Intel 8080) mode, Read/!Write pin for type A (Motorola 6800) mode.\n+\n+  e-gpios:\n+    type: phandle-array\n+    description: |\n+      Clocked enable/strobe pin for type A (Motorola 6800) mode, unused for type B (Intel 8080).\n+      Fixed E mode is not supported.\n+\n+  cs-gpios:\n+    type: phandle-array\n+    required: true\n+    description: |\n+      Chip-select GPIO pin.\n+\n+  data-gpios:\n+    type: phandle-array\n+    required: true\n+    description: |\n+      GPIO pins used for the parallel data bus. This must have as many entries as the bus is wide\n+      of the selected mipi-mode.\ndiff --git a/include/zephyr/drivers/mipi_dbi.h b/include/zephyr/drivers/mipi_dbi.h\nindex f9c89e5ef1f..c2d52c77e0e 100644\n--- a/include/zephyr/drivers/mipi_dbi.h\n+++ b/include/zephyr/drivers/mipi_dbi.h\n@@ -118,7 +118,7 @@ extern \"C\" {\n  * Configuration for MIPI DBI controller write\n  */\n struct mipi_dbi_config {\n-\t/** MIPI DBI mode (SPI 3 wire or 4 wire) */\n+\t/** MIPI DBI mode */\n \tuint8_t mode;\n \t/** SPI configuration */\n \tstruct spi_config config;"
},{
  "instruction": "doc: update MIPI DBI API compatibility",
  "input": "Currently, the API only supports Type C controllers, options 1 and 3.\n* The current driver interface only supports type C modes 1 and 3",
  "result": "diff --git a/doc/hardware/peripherals/mipi_dbi.rst b/doc/hardware/peripherals/mipi_dbi.rst\nindex 672eb59f8f1..6ca91f4600e 100644\n--- a/doc/hardware/peripherals/mipi_dbi.rst\n+++ b/doc/hardware/peripherals/mipi_dbi.rst\n@@ -20,7 +20,8 @@ MIPI DBI defines 3 interface types:\n \n   #. 8 write clocks per byte. Command/data selected via GPIO pin\n \n-Currently, the API only supports Type C controllers, options 1 and 3.\n+Currently, the API does not support Type C controllers with 16 write clocks\n+(option 2).\n \n API Reference\n *************\ndiff --git a/include/zephyr/drivers/mipi_dbi.h b/include/zephyr/drivers/mipi_dbi.h\nindex dfd017bc4cc..f9c89e5ef1f 100644\n--- a/include/zephyr/drivers/mipi_dbi.h\n+++ b/include/zephyr/drivers/mipi_dbi.h\n@@ -15,7 +15,7 @@\n  *     1. 9 write clocks per byte, final bit is command/data selection bit\n  *     2. Same as above, but 16 write clocks per byte\n  *     3. 8 write clocks per byte. Command/data selected via GPIO pin\n- * The current driver interface only supports type C modes 1 and 3\n+ * The current driver interface does not support type C with 16 write clocks (option 2).\n  */\n \n #ifndef ZEPHYR_INCLUDE_DRIVERS_MIPI_DBI_H_"
},{
  "instruction": "drivers: display: ili9xxx: read mipi-mode, only use SPI mode as fallback",
  "input": "\t\t\t.mode = MIPI_DBI_MODE_SPI_4WIRE,                       \\",
  "result": "diff --git a/drivers/display/display_ili9xxx.c b/drivers/display/display_ili9xxx.c\nindex fd3cd4e7b9e..a13786122fb 100644\n--- a/drivers/display/display_ili9xxx.c\n+++ b/drivers/display/display_ili9xxx.c\n@@ -520,7 +520,8 @@ static const struct ili9xxx_quirks ili9488_quirks = {\n \t\t.quirks = &ili##t##_quirks,                                    \\\n \t\t.mipi_dev = DEVICE_DT_GET(DT_PARENT(INST_DT_ILI9XXX(n, t))),   \\\n \t\t.dbi_config = {                                                \\\n-\t\t\t.mode = MIPI_DBI_MODE_SPI_4WIRE,                       \\\n+\t\t\t.mode = DT_PROP_OR(INST_DT_ILI9XXX(n, t),              \\\n+\t\t\t\tmipi_mode, MIPI_DBI_MODE_SPI_4WIRE),           \\\n \t\t\t.config = MIPI_DBI_SPI_CONFIG_DT(                      \\\n \t\t\t\t\t\tINST_DT_ILI9XXX(n, t),         \\\n \t\t\t\t\t\tSPI_OP_MODE_MASTER |           \\"
},{
  "instruction": "tests: drivers: build_all: sensor: Adding Grove NTC Temperature Sensor",
  "input": "",
  "result": "diff --git a/tests/drivers/build_all/sensor/adc.dtsi b/tests/drivers/build_all/sensor/adc.dtsi\nindex 34f41297a51..87cf64faae9 100644\n--- a/tests/drivers/build_all/sensor/adc.dtsi\n+++ b/tests/drivers/build_all/sensor/adc.dtsi\n@@ -111,3 +111,8 @@ test_seeed_grove_light: seeed-grove-light {\n \tcompatible = \"seeed,grove-light\";\n \tio-channels = <&test_adc 0>;\n };\n+\n+test_seeed_grove_temperature: seeed-grove-temperature {\n+\tcompatible = \"seeed,grove-temperature\";\n+\tio-channels = <&test_adc 0>;\n+};"
},{
  "instruction": "tests: drivers: build_all: sensor: Adding Grove Photo-Resistor Light Sensor",
  "input": "",
  "result": "diff --git a/tests/drivers/build_all/sensor/adc.dtsi b/tests/drivers/build_all/sensor/adc.dtsi\nindex 1b29685b98d..34f41297a51 100644\n--- a/tests/drivers/build_all/sensor/adc.dtsi\n+++ b/tests/drivers/build_all/sensor/adc.dtsi\n@@ -106,3 +106,8 @@ test_murata_ncp15xh103: murata-ncp15xh103 {\n \tpulldown-ohm = <10000>;\n \tconnected-positive;\n };\n+\n+test_seeed_grove_light: seeed-grove-light {\n+\tcompatible = \"seeed,grove-light\";\n+\tio-channels = <&test_adc 0>;\n+};"
},{
  "instruction": "soc: esp32s3: bump esp32s3 bootloader iram and dram sizes.",
  "input": "#define BOOTLOADER_DRAM_SEG_LEN        0x8000\n#define BOOTLOADER_IRAM_SEG_LEN        0xa800",
  "result": "diff --git a/soc/espressif/esp32s3/memory.h b/soc/espressif/esp32s3/memory.h\nindex cd9a0ef984b..01dfc69fe7d 100644\n--- a/soc/espressif/esp32s3/memory.h\n+++ b/soc/espressif/esp32s3/memory.h\n@@ -45,9 +45,9 @@\n \n /* For safety margin between bootloader data section and startup stacks */\n #define BOOTLOADER_STACK_OVERHEAD      0x0\n-#define BOOTLOADER_DRAM_SEG_LEN        0x8000\n+#define BOOTLOADER_DRAM_SEG_LEN        0x9000\n #define BOOTLOADER_IRAM_LOADER_SEG_LEN 0x1a00\n-#define BOOTLOADER_IRAM_SEG_LEN        0xa800\n+#define BOOTLOADER_IRAM_SEG_LEN        0xc000\n \n /* Start of the lower region is determined by region size and the end of the higher region */\n #define BOOTLOADER_IRAM_LOADER_SEG_START (BOOTLOADER_USER_DRAM_END - BOOTLOADER_STACK_OVERHEAD + \\"
},{
  "instruction": "doc: dts: Link Linux binding guidelines.",
  "input": "",
  "result": "diff --git a/doc/build/dts/bindings-upstream.rst b/doc/build/dts/bindings-upstream.rst\nindex cf6d59c3a4a..b33b7f92452 100644\n--- a/doc/build/dts/bindings-upstream.rst\n+++ b/doc/build/dts/bindings-upstream.rst\n@@ -41,6 +41,12 @@ In particular, this rule applies if:\n General rules\n *************\n \n+Wherever possible, when writing Devicetree bindings for Zephyr, try to follow\n+the same `design guidelines laid out by Linux`_.\n+\n+.. _design guidelines laid out by Linux:\n+   https://docs.kernel.org/devicetree/bindings/writing-bindings.html\n+\n File names\n ==========\n "
},{
  "instruction": "soc: ti: move init code from SYS_INIT to hooks",
  "input": "static int am6x_m4_init(void)\n\treturn 0;\nSYS_INIT(am6x_m4_init, EARLY, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\nstatic int ti_cc13x2_cc26x2_init(void)\n\treturn 0;\nSYS_INIT(ti_cc13x2_cc26x2_init, PRE_KERNEL_1, 0);\nstatic int ti_cc13x7_cc26x7_init(void)\n\treturn 0;\nSYS_INIT(ti_cc13x7_cc26x7_init, PRE_KERNEL_1, 0);\nstatic int ti_cc32xx_init(void)\n\treturn 0;\nSYS_INIT(ti_cc32xx_init, PRE_KERNEL_1, 0);\nstatic int ti_msp432p4xx_init(void)\n\treturn 0;\nSYS_INIT(ti_msp432p4xx_init, PRE_KERNEL_1, 0);",
  "result": "diff --git a/soc/ti/k3/am6x/Kconfig b/soc/ti/k3/am6x/Kconfig\nindex f5596944bf8..39eaf92c858 100644\n--- a/soc/ti/k3/am6x/Kconfig\n+++ b/soc/ti/k3/am6x/Kconfig\n@@ -17,6 +17,7 @@ config SOC_SERIES_AM6X_M4\n \tselect EXTERNAL_ADDRESS_TRANSLATION\n \tselect MM_DRV\n \tselect MM_TI_RAT\n+\tselect SOC_PREP_HOOK\n \n config SOC_PART_NUMBER\n \tdefault \"AM6234\" if SOC_AM6234_A53\ndiff --git a/soc/ti/k3/am6x/m4/soc.c b/soc/ti/k3/am6x/m4/soc.c\nindex b2e261a4e9c..519a3fab21b 100644\n--- a/soc/ti/k3/am6x/m4/soc.c\n+++ b/soc/ti/k3/am6x/m4/soc.c\n@@ -62,12 +62,9 @@ static void am6x_mmr_unlock(void)\n \tsys_write32(KICK1_UNLOCK_VAL, kickAddr);   /* KICK 1 */\n }\n \n-static int am6x_m4_init(void)\n+void soc_prep_hook(void)\n {\n \tsys_mm_drv_ti_rat_init(am6x_region_config, ADDR_TRANSLATE_RAT_BASE_ADDR,\n \t\tARRAY_SIZE(am6x_region_config));\n \tam6x_mmr_unlock();\n-\treturn 0;\n }\n-\n-SYS_INIT(am6x_m4_init, EARLY, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/ti/simplelink/cc13x2_cc26x2/Kconfig b/soc/ti/simplelink/cc13x2_cc26x2/Kconfig\nindex 01acc8f48d8..6885038cc16 100644\n--- a/soc/ti/simplelink/cc13x2_cc26x2/Kconfig\n+++ b/soc/ti/simplelink/cc13x2_cc26x2/Kconfig\n@@ -14,6 +14,7 @@ config SOC_SERIES_CC13X2_CC26X2\n \tselect HAS_SEGGER_RTT if ZEPHYR_SEGGER_MODULE\n \tselect HAS_PM\n \tselect HAS_POWEROFF\n+\tselect SOC_EARLY_INIT_HOOK\n \n menu \"Customer Configuration (CCFG)\"\n depends on SOC_SERIES_CC13X2_CC26X2\ndiff --git a/soc/ti/simplelink/cc13x2_cc26x2/soc.c b/soc/ti/simplelink/cc13x2_cc26x2/soc.c\nindex 452c73254e7..c896cf2691f 100644\n--- a/soc/ti/simplelink/cc13x2_cc26x2/soc.c\n+++ b/soc/ti/simplelink/cc13x2_cc26x2/soc.c\n@@ -8,13 +8,9 @@\n \n #include <driverlib/setup.h>\n \n-static int ti_cc13x2_cc26x2_init(void)\n+void soc_early_init_hook(void)\n {\n \n \t/* Performs necessary trim of the device. */\n \tSetupTrimDevice();\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(ti_cc13x2_cc26x2_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/ti/simplelink/cc13x2x7_cc26x2x7/Kconfig b/soc/ti/simplelink/cc13x2x7_cc26x2x7/Kconfig\nindex e5c5a01eedf..d1b2fc58bd3 100644\n--- a/soc/ti/simplelink/cc13x2x7_cc26x2x7/Kconfig\n+++ b/soc/ti/simplelink/cc13x2x7_cc26x2x7/Kconfig\n@@ -14,6 +14,7 @@ config SOC_SERIES_CC13X2X7_CC26X2X7\n \tselect HAS_TI_CCFG if !BOOTLOADER_MCUBOOT\n \tselect HAS_SEGGER_RTT if ZEPHYR_SEGGER_MODULE\n \tselect HAS_PM\n+\tselect SOC_EARLY_INIT_HOOK\n \n menu \"Customer Configuration (CCFG)\"\n depends on SOC_SERIES_CC13X2X7_CC26X2X7\ndiff --git a/soc/ti/simplelink/cc13x2x7_cc26x2x7/soc.c b/soc/ti/simplelink/cc13x2x7_cc26x2x7/soc.c\nindex 8c2ea2f5350..22efa243e67 100644\n--- a/soc/ti/simplelink/cc13x2x7_cc26x2x7/soc.c\n+++ b/soc/ti/simplelink/cc13x2x7_cc26x2x7/soc.c\n@@ -8,13 +8,9 @@\n \n #include <driverlib/setup.h>\n \n-static int ti_cc13x7_cc26x7_init(void)\n+void soc_early_init_hook(void)\n {\n \n \t/* Performs necessary trim of the device. */\n \tSetupTrimDevice();\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(ti_cc13x7_cc26x7_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/ti/simplelink/cc32xx/Kconfig b/soc/ti/simplelink/cc32xx/Kconfig\nindex d8ec2f20715..8698ddd3452 100644\n--- a/soc/ti/simplelink/cc32xx/Kconfig\n+++ b/soc/ti/simplelink/cc32xx/Kconfig\n@@ -7,6 +7,7 @@ config SOC_SERIES_CC32XX\n \tselect CPU_CORTEX_M4\n \tselect CPU_CORTEX_M_HAS_DWT\n \tselect DYNAMIC_INTERRUPTS\n+\tselect SOC_EARLY_INIT_HOOK\n \n config SOC_CC3220SF\n \tselect HAS_CC3220SDK\ndiff --git a/soc/ti/simplelink/cc32xx/soc.c b/soc/ti/simplelink/cc32xx/soc.c\nindex f95141f5ddd..7e127ddfcba 100644\n--- a/soc/ti/simplelink/cc32xx/soc.c\n+++ b/soc/ti/simplelink/cc32xx/soc.c\n@@ -18,7 +18,7 @@ void sys_arch_reboot(int type)\n \tMAP_PRCMMCUReset(!!type);\n }\n \n-static int ti_cc32xx_init(void)\n+void soc_early_init_hook(void)\n {\n \n \t/* Note: This function also performs CC3220 Initialization */\n@@ -32,8 +32,4 @@ static int ti_cc32xx_init(void)\n \tMAP_PRCMPeripheralClkEnable(PRCM_UARTA0, PRCM_RUN_MODE_CLK |\n \t\t\t\t    PRCM_SLP_MODE_CLK);\n #endif\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(ti_cc32xx_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/ti/simplelink/msp432p4xx/Kconfig b/soc/ti/simplelink/msp432p4xx/Kconfig\nindex 9b44c5f34ab..d4a9b6cfac9 100644\n--- a/soc/ti/simplelink/msp432p4xx/Kconfig\n+++ b/soc/ti/simplelink/msp432p4xx/Kconfig\n@@ -9,6 +9,7 @@ config SOC_SERIES_MSP432P4XX\n \tselect DYNAMIC_INTERRUPTS\n \tselect CPU_HAS_FPU\n \tselect CPU_HAS_ARM_MPU\n+\tselect SOC_EARLY_INIT_HOOK\n \n config SOC_MSP432P401R\n \tselect HAS_MSP432P4XXSDK\ndiff --git a/soc/ti/simplelink/msp432p4xx/soc.c b/soc/ti/simplelink/msp432p4xx/soc.c\nindex 8faf547fdb1..185124d7ec0 100644\n--- a/soc/ti/simplelink/msp432p4xx/soc.c\n+++ b/soc/ti/simplelink/msp432p4xx/soc.c\n@@ -9,12 +9,8 @@\n #include <zephyr/init.h>\n #include <soc.h>\n \n-static int ti_msp432p4xx_init(void)\n+void soc_early_init_hook(void)\n {\n \n \tSystemInit();\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(ti_msp432p4xx_init, PRE_KERNEL_1, 0);"
},{
  "instruction": "soc: telink: move init code from SYS_INIT to hooks",
  "input": "static int soc_b91_init(void)\n\treturn 0;\nSYS_INIT(soc_b91_init, PRE_KERNEL_1, 0);",
  "result": "diff --git a/soc/telink/tlsr/tlsr951x/Kconfig b/soc/telink/tlsr/tlsr951x/Kconfig\nindex 82a8c7d536f..5b2b6f59627 100644\n--- a/soc/telink/tlsr/tlsr951x/Kconfig\n+++ b/soc/telink/tlsr/tlsr951x/Kconfig\n@@ -17,6 +17,7 @@ config SOC_SERIES_TLSR951X\n \tselect CPU_HAS_FPU\n \tselect INCLUDE_RESET_VECTOR\n \timply XIP\n+\tselect SOC_EARLY_INIT_HOOK\n \n if SOC_SERIES_TLSR951X\n \ndiff --git a/soc/telink/tlsr/tlsr951x/soc.c b/soc/telink/tlsr/tlsr951x/soc.c\nindex 28e29d5c585..e8c94f58e82 100644\n--- a/soc/telink/tlsr/tlsr951x/soc.c\n+++ b/soc/telink/tlsr/tlsr951x/soc.c\n@@ -71,7 +71,7 @@\n  *\n  * @return 0\n  */\n-static int soc_b91_init(void)\n+void soc_early_init_hook(void)\n {\n \tunsigned int cclk = DT_PROP(DT_PATH(cpus, cpu_0), clock_frequency);\n \n@@ -109,8 +109,6 @@ static int soc_b91_init(void)\n \t/* Init Machine Timer source clock: 32 KHz RC */\n \tclock_32k_init(CLK_32K_RC);\n \tclock_cal_32k_rc();\n-\n-\treturn 0;\n }\n \n /**\n@@ -122,5 +120,3 @@ void sys_arch_reboot(int type)\n \n \treg_reset = SOFT_RESET;\n }\n-\n-SYS_INIT(soc_b91_init, PRE_KERNEL_1, 0);"
},{
  "instruction": "soc: st: move init code from SYS_INIT to hooks",
  "input": "* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int stm32c0_init(void)\n\treturn 0;\nSYS_INIT(stm32c0_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int stm32f0_init(void)\n\treturn 0;\nSYS_INIT(stm32f0_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int stm32f1_init(void)\n\treturn 0;\nSYS_INIT(stm32f1_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int stm32f2_init(void)\n\treturn 0;\nSYS_INIT(stm32f2_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int stm32f3_init(void)\n\treturn 0;\nSYS_INIT(stm32f3_init, PRE_KERNEL_1, 0);\nstatic int stm32_power_init(void)\n\t/* Enabling debug during STOP mode is done by the common STM32 configuration */\n\treturn 0;\nSYS_INIT(stm32_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int st_stm32f4_init(void)\n\treturn 0;\nSYS_INIT(st_stm32f4_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int st_stm32f7_init(void)\n\treturn 0;\nSYS_INIT(st_stm32f7_init, PRE_KERNEL_1, 0);\nstatic int stm32_power_init(void)\n\treturn 0;\nSYS_INIT(stm32_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int stm32g0_init(void)\n\treturn 0;\nSYS_INIT(stm32g0_init, PRE_KERNEL_1, 0);\nstatic int stm32_power_init(void)\n\treturn 0;\nSYS_INIT(stm32_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int stm32g4_init(void)\n\treturn 0;\nSYS_INIT(stm32g4_init, PRE_KERNEL_1, 0);\nstatic int stm32_power_init(void)\n\treturn 0;\nSYS_INIT(stm32_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int stm32h5_init(void)\n\treturn 0;\n}\nSYS_INIT(stm32h5_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int stm32h7rs_init(void)\n\treturn 0;\nSYS_INIT(stm32h7rs_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int stm32h7_m4_init(void)\n\treturn 0;\nSYS_INIT(stm32h7_m4_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int stm32h7_init(void)\n\treturn 0;\nSYS_INIT(stm32h7_init, PRE_KERNEL_1, 0);\nstatic int stm32_power_init(void)\n\treturn 0;\nSYS_INIT(stm32_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int stm32l0_init(void)\n\treturn 0;\nSYS_INIT(stm32l0_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int stm32l1_init(void)\n\treturn 0;\nSYS_INIT(stm32l1_init, PRE_KERNEL_1, 0);\nstatic int stm32_power_init(void)\n\treturn 0;\nSYS_INIT(stm32_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int stm32l4_init(void)\n\treturn 0;\nSYS_INIT(stm32l4_init, PRE_KERNEL_1, 0);\nstatic int stm32_power_init(void)\n\treturn 0;\nSYS_INIT(stm32_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int stm32l5_init(void)\n\treturn 0;\nSYS_INIT(stm32l5_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int stm32m4_init(void)\n\treturn 0;\nSYS_INIT(stm32m4_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int stm32u0_init(void)\n\treturn 0;\nSYS_INIT(stm32u0_init, PRE_KERNEL_1, 0);\nstatic int stm32_power_init(void)\n\treturn 0;\nSYS_INIT(stm32_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int stm32u5_init(void)\n\treturn 0;\nSYS_INIT(stm32u5_init, PRE_KERNEL_1, 0);\nstatic int stm32_power_init(void);\nstatic int stm32_power_init(void)\n\treturn 0;\nSYS_INIT(stm32_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nint stm32wba_init(void)\n\treturn 0;\nSYS_INIT(stm32wba_init, PRE_KERNEL_1, 0);\nint stm32wba_init(void);\nstatic int stm32_power_init(void)\n\treturn 0;\nSYS_INIT(stm32_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int stm32wb_init(void)\n\treturn 0;\nSYS_INIT(stm32wb_init, PRE_KERNEL_1, 0);\nstatic int stm32_power_init(void)\n\treturn 0;\nSYS_INIT(stm32_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int stm32wl_init(void)\n\treturn 0;\nSYS_INIT(stm32wl_init, PRE_KERNEL_1, 0);",
  "result": "diff --git a/soc/st/stm32/stm32c0x/Kconfig b/soc/st/stm32/stm32c0x/Kconfig\nindex d24fdd311d8..1d9770c4e60 100644\n--- a/soc/st/stm32/stm32c0x/Kconfig\n+++ b/soc/st/stm32/stm32c0x/Kconfig\n@@ -11,3 +11,4 @@ config SOC_SERIES_STM32C0X\n \tselect HAS_STM32CUBE\n \tselect CPU_CORTEX_M_HAS_SYSTICK\n \tselect HAS_POWEROFF\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/st/stm32/stm32c0x/soc.c b/soc/st/stm32/stm32c0x/soc.c\nindex d607f247c6c..e1337f66923 100644\n--- a/soc/st/stm32/stm32c0x/soc.c\n+++ b/soc/st/stm32/stm32c0x/soc.c\n@@ -22,11 +22,8 @@\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int stm32c0_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Enable ART Accelerator I-cache and prefetch */\n \tLL_FLASH_EnableInstCache();\n@@ -35,8 +32,4 @@ static int stm32c0_init(void)\n \t/* Update CMSIS SystemCoreClock variable (HCLK) */\n \t/* At reset, system core clock is set to 48 MHz from HSI */\n \tSystemCoreClock = 48000000;\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(stm32c0_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/st/stm32/stm32f0x/Kconfig b/soc/st/stm32/stm32f0x/Kconfig\nindex 54eb854963a..4c0a44510d2 100644\n--- a/soc/st/stm32/stm32f0x/Kconfig\n+++ b/soc/st/stm32/stm32f0x/Kconfig\n@@ -9,3 +9,4 @@ config SOC_SERIES_STM32F0X\n \tselect CPU_CORTEX_M0_HAS_VECTOR_TABLE_REMAP\n \tselect CPU_CORTEX_M_HAS_SYSTICK\n \tselect HAS_STM32CUBE\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/st/stm32/stm32f0x/soc.c b/soc/st/stm32/stm32f0x/soc.c\nindex 73697f1acbd..b6cb76a24de 100644\n--- a/soc/st/stm32/stm32f0x/soc.c\n+++ b/soc/st/stm32/stm32f0x/soc.c\n@@ -61,11 +61,8 @@ void relocate_vector_table(void)\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int stm32f0_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Enable ART Accelerator prefetch */\n \tLL_FLASH_EnablePrefetch();\n@@ -73,8 +70,4 @@ static int stm32f0_init(void)\n \t/* Update CMSIS SystemCoreClock variable (HCLK) */\n \t/* At reset, system core clock is set to 8 MHz from HSI */\n \tSystemCoreClock = 8000000;\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(stm32f0_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/st/stm32/stm32f1x/Kconfig b/soc/st/stm32/stm32f1x/Kconfig\nindex 13680c516c1..fc6b8791acf 100644\n--- a/soc/st/stm32/stm32f1x/Kconfig\n+++ b/soc/st/stm32/stm32f1x/Kconfig\n@@ -9,3 +9,4 @@ config SOC_SERIES_STM32F1X\n \tselect CPU_CORTEX_M_HAS_DWT\n \tselect HAS_STM32CUBE\n \tselect HAS_SWO\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/st/stm32/stm32f1x/soc.c b/soc/st/stm32/stm32f1x/soc.c\nindex 6d65f64d18d..72e679fd391 100644\n--- a/soc/st/stm32/stm32f1x/soc.c\n+++ b/soc/st/stm32/stm32f1x/soc.c\n@@ -20,11 +20,8 @@\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int stm32f1_init(void)\n+void soc_early_init_hook(void)\n {\n #ifdef FLASH_ACR_PRFTBE\n \t/* Enable ART Accelerator prefetch */\n@@ -34,8 +31,4 @@ static int stm32f1_init(void)\n \t/* Update CMSIS SystemCoreClock variable (HCLK) */\n \t/* At reset, system core clock is set to 8 MHz from HSI */\n \tSystemCoreClock = 8000000;\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(stm32f1_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/st/stm32/stm32f2x/Kconfig b/soc/st/stm32/stm32f2x/Kconfig\nindex 4821425c09c..bcd07bcdd27 100644\n--- a/soc/st/stm32/stm32f2x/Kconfig\n+++ b/soc/st/stm32/stm32f2x/Kconfig\n@@ -10,3 +10,4 @@ config SOC_SERIES_STM32F2X\n \tselect HAS_STM32CUBE\n \tselect HAS_SWO\n \tselect CPU_HAS_ARM_MPU\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/st/stm32/stm32f2x/soc.c b/soc/st/stm32/stm32f2x/soc.c\nindex 39166ad3b25..b5ec98aa303 100644\n--- a/soc/st/stm32/stm32f2x/soc.c\n+++ b/soc/st/stm32/stm32f2x/soc.c\n@@ -23,11 +23,8 @@\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int stm32f2_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Enable ART Flash I/D-cache accelerator and prefetch */\n \tLL_FLASH_EnableInstCache();\n@@ -37,8 +34,4 @@ static int stm32f2_init(void)\n \t/* Update CMSIS SystemCoreClock variable (HCLK) */\n \t/* At reset, system core clock is set to 16 MHz from HSI */\n \tSystemCoreClock = 16000000;\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(stm32f2_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/st/stm32/stm32f3x/Kconfig b/soc/st/stm32/stm32f3x/Kconfig\nindex 50b83a2a4b6..c8f7bf044e8 100644\n--- a/soc/st/stm32/stm32f3x/Kconfig\n+++ b/soc/st/stm32/stm32f3x/Kconfig\n@@ -10,3 +10,4 @@ config SOC_SERIES_STM32F3X\n \tselect CPU_HAS_FPU\n \tselect HAS_STM32CUBE\n \tselect HAS_SWO\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/st/stm32/stm32f3x/soc.c b/soc/st/stm32/stm32f3x/soc.c\nindex 57ed24c75c7..10b30e63c9b 100644\n--- a/soc/st/stm32/stm32f3x/soc.c\n+++ b/soc/st/stm32/stm32f3x/soc.c\n@@ -19,11 +19,8 @@\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int stm32f3_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Enable ART Accelerator prefetch */\n \tLL_FLASH_EnablePrefetch();\n@@ -34,8 +31,4 @@ static int stm32f3_init(void)\n \n \t/* Allow reflashing the board */\n \tLL_DBGMCU_EnableDBGSleepMode();\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(stm32f3_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/st/stm32/stm32f4x/Kconfig b/soc/st/stm32/stm32f4x/Kconfig\nindex 92bba334775..2d8681f3da3 100644\n--- a/soc/st/stm32/stm32f4x/Kconfig\n+++ b/soc/st/stm32/stm32f4x/Kconfig\n@@ -12,3 +12,4 @@ config SOC_SERIES_STM32F4X\n \tselect CPU_HAS_ARM_MPU\n \tselect HAS_SWO\n \tselect HAS_PM\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/st/stm32/stm32f4x/power.c b/soc/st/stm32/stm32f4x/power.c\nindex 02b645ee9f1..d0e677b5dc3 100644\n--- a/soc/st/stm32/stm32f4x/power.c\n+++ b/soc/st/stm32/stm32f4x/power.c\n@@ -75,15 +75,10 @@ void pm_state_exit_post_ops(enum pm_state state, uint8_t substate_id)\n \tirq_unlock(0);\n }\n \n-static int stm32_power_init(void)\n+void stm32_power_init(void)\n {\n \t/* Enable Power clock. It should by done by default, but make sure to\n \t * enable it for all STM32F4x chips.\n \t */\n \tLL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);\n-\n-\t/* Enabling debug during STOP mode is done by the common STM32 configuration */\n-\treturn 0;\n }\n-\n-SYS_INIT(stm32_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/st/stm32/stm32f4x/soc.c b/soc/st/stm32/stm32f4x/soc.c\nindex d8960f81b28..941f0091997 100644\n--- a/soc/st/stm32/stm32f4x/soc.c\n+++ b/soc/st/stm32/stm32f4x/soc.c\n@@ -16,15 +16,14 @@\n #include <cmsis_core.h>\n #include <stm32_ll_system.h>\n \n+extern void stm32_power_init(void);\n+\n /**\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int st_stm32f4_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Enable ART Flash I/D-cache and prefetch */\n \tLL_FLASH_EnablePrefetch();\n@@ -34,8 +33,7 @@ static int st_stm32f4_init(void)\n \t/* Update CMSIS SystemCoreClock variable (HCLK) */\n \t/* At reset, system core clock is set to 16 MHz from HSI */\n \tSystemCoreClock = 16000000;\n-\n-\treturn 0;\n+#if CONFIG_PM\n+\tstm32_power_init();\n+#endif\n }\n-\n-SYS_INIT(st_stm32f4_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/st/stm32/stm32f7x/Kconfig b/soc/st/stm32/stm32f7x/Kconfig\nindex 1af203c4680..1d315341734 100644\n--- a/soc/st/stm32/stm32f7x/Kconfig\n+++ b/soc/st/stm32/stm32f7x/Kconfig\n@@ -13,3 +13,4 @@ config SOC_SERIES_STM32F7X\n \tselect HAS_STM32CUBE\n \tselect CPU_HAS_ARM_MPU\n \tselect HAS_SWO\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/st/stm32/stm32f7x/soc.c b/soc/st/stm32/stm32f7x/soc.c\nindex 528110e7805..0b27c4f41b0 100644\n--- a/soc/st/stm32/stm32f7x/soc.c\n+++ b/soc/st/stm32/stm32f7x/soc.c\n@@ -22,11 +22,8 @@\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int st_stm32f7_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Enable ART Flash cache accelerator and prefetch */\n \tLL_FLASH_EnableART();\n@@ -38,8 +35,4 @@ static int st_stm32f7_init(void)\n \t/* Update CMSIS SystemCoreClock variable (HCLK) */\n \t/* At reset, system core clock is set to 16 MHz from HSI */\n \tSystemCoreClock = 16000000;\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(st_stm32f7_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/st/stm32/stm32g0x/Kconfig b/soc/st/stm32/stm32g0x/Kconfig\nindex 8fac199d153..7361bef642c 100644\n--- a/soc/st/stm32/stm32g0x/Kconfig\n+++ b/soc/st/stm32/stm32g0x/Kconfig\n@@ -12,3 +12,4 @@ config SOC_SERIES_STM32G0X\n \tselect HAS_STM32CUBE\n \tselect CPU_CORTEX_M_HAS_SYSTICK\n \tselect HAS_PM\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/st/stm32/stm32g0x/power.c b/soc/st/stm32/stm32g0x/power.c\nindex b2dfd18bb52..88bff751d42 100644\n--- a/soc/st/stm32/stm32g0x/power.c\n+++ b/soc/st/stm32/stm32g0x/power.c\n@@ -81,13 +81,9 @@ void pm_state_exit_post_ops(enum pm_state state, uint8_t substate_id)\n }\n \n /* Initialize STM32 Power */\n-static int stm32_power_init(void)\n+void stm32_power_init(void)\n {\n \n \t/* enable Power clock */\n \tLL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(stm32_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/st/stm32/stm32g0x/soc.c b/soc/st/stm32/stm32g0x/soc.c\nindex bab4e3dbca2..8f2d45d24e3 100644\n--- a/soc/st/stm32/stm32g0x/soc.c\n+++ b/soc/st/stm32/stm32g0x/soc.c\n@@ -71,15 +71,14 @@ static void stm32g0_disable_dead_battery(void)\n #endif /* SYSCFG_CFGR1_UCPD1_STROBE || SYSCFG_CFGR1_UCPD2_STROBE */\n }\n \n+extern void stm32_power_init(void);\n+\n /**\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int stm32g0_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Enable ART Accelerator I-cache and prefetch */\n \tLL_FLASH_EnableInstCache();\n@@ -91,8 +90,7 @@ static int stm32g0_init(void)\n \n \t/* Disable the internal Pull-Up in Dead Battery pins of UCPD peripheral */\n \tstm32g0_disable_dead_battery();\n-\n-\treturn 0;\n+#if CONFIG_PM\n+\tstm32_power_init();\n+#endif\n }\n-\n-SYS_INIT(stm32g0_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/st/stm32/stm32g4x/Kconfig b/soc/st/stm32/stm32g4x/Kconfig\nindex 0c2e59d40fb..574d34969bb 100644\n--- a/soc/st/stm32/stm32g4x/Kconfig\n+++ b/soc/st/stm32/stm32g4x/Kconfig\n@@ -12,3 +12,4 @@ config SOC_SERIES_STM32G4X\n \tselect CPU_HAS_ARM_MPU\n \tselect HAS_PM\n \tselect HAS_SWO\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/st/stm32/stm32g4x/power.c b/soc/st/stm32/stm32g4x/power.c\nindex 3f2295e9440..092562c33ad 100644\n--- a/soc/st/stm32/stm32g4x/power.c\n+++ b/soc/st/stm32/stm32g4x/power.c\n@@ -79,13 +79,9 @@ void pm_state_exit_post_ops(enum pm_state state, uint8_t substate_id)\n }\n \n /* Initialize STM32 Power */\n-static int stm32_power_init(void)\n+void stm32_power_init(void)\n {\n \n \t/* enable Power clock */\n \tLL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(stm32_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/st/stm32/stm32g4x/soc.c b/soc/st/stm32/stm32g4x/soc.c\nindex befbc239f01..f21906f397c 100644\n--- a/soc/st/stm32/stm32g4x/soc.c\n+++ b/soc/st/stm32/stm32g4x/soc.c\n@@ -24,11 +24,8 @@\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int stm32g4_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Enable ART Accelerator I/D-cache and prefetch */\n \tLL_FLASH_EnableInstCache();\n@@ -51,7 +48,7 @@ static int stm32g4_init(void)\n \t}\n \n #endif /* PWR_CR3_UCPD_DBDIS */\n-\treturn 0;\n+#if CONFIG_PM\n+\tstm32_power_init();\n+#endif\n }\n-\n-SYS_INIT(stm32g4_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/st/stm32/stm32h5x/Kconfig b/soc/st/stm32/stm32h5x/Kconfig\nindex 6516a056490..07fa2c1a251 100644\n--- a/soc/st/stm32/stm32h5x/Kconfig\n+++ b/soc/st/stm32/stm32h5x/Kconfig\n@@ -15,3 +15,4 @@ config SOC_SERIES_STM32H5X\n \tselect HAS_STM32CUBE\n \tselect HAS_SWO\n \tselect HAS_PM\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/st/stm32/stm32h5x/power.c b/soc/st/stm32/stm32h5x/power.c\nindex 0dc1d30819a..1af853c6c0f 100644\n--- a/soc/st/stm32/stm32h5x/power.c\n+++ b/soc/st/stm32/stm32h5x/power.c\n@@ -68,9 +68,6 @@ void pm_state_exit_post_ops(enum pm_state state, uint8_t substate_id)\n }\n \n /* Initialize STM32 Power */\n-static int stm32_power_init(void)\n+void stm32_power_init(void)\n {\n-\treturn 0;\n }\n-\n-SYS_INIT(stm32_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/st/stm32/stm32h5x/soc.c b/soc/st/stm32/stm32h5x/soc.c\nindex 13b25257ed3..c4735c78c79 100644\n--- a/soc/st/stm32/stm32h5x/soc.c\n+++ b/soc/st/stm32/stm32h5x/soc.c\n@@ -21,15 +21,13 @@\n #define LOG_LEVEL CONFIG_SOC_LOG_LEVEL\n LOG_MODULE_REGISTER(soc);\n \n+extern void stm32_power_init(void);\n /**\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int stm32h5_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Enable instruction cache in 1-way (direct mapped cache) */\n \tLL_ICACHE_SetMode(LL_ICACHE_1WAY);\n@@ -47,7 +45,8 @@ static int stm32h5_init(void)\n \t}\n \n #endif /* PWR_UCPDR_UCPD_DBDIS */\n-\treturn 0;\n-}\n \n-SYS_INIT(stm32h5_init, PRE_KERNEL_1, 0);\n+#if CONFIG_PM\n+\tstm32_power_init();\n+#endif\n+}\ndiff --git a/soc/st/stm32/stm32h7rsx/Kconfig b/soc/st/stm32/stm32h7rsx/Kconfig\nindex 4b97d272a9e..2e0f9f5fcec 100644\n--- a/soc/st/stm32/stm32h7rsx/Kconfig\n+++ b/soc/st/stm32/stm32h7rsx/Kconfig\n@@ -14,3 +14,4 @@ config SOC_SERIES_STM32H7RSX\n \tselect CPU_HAS_FPU_DOUBLE_PRECISION\n \tselect CPU_HAS_ICACHE\n \tselect CPU_HAS_DCACHE\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/st/stm32/stm32h7rsx/soc.c b/soc/st/stm32/stm32h7rsx/soc.c\nindex 87d62a3c063..5bf2bfe43af 100644\n--- a/soc/st/stm32/stm32h7rsx/soc.c\n+++ b/soc/st/stm32/stm32h7rsx/soc.c\n@@ -25,11 +25,8 @@\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int stm32h7rs_init(void)\n+void soc_early_init_hook(void)\n {\n \tsys_cache_instr_enable();\n \tsys_cache_data_enable();\n@@ -71,8 +68,4 @@ static int stm32h7rs_init(void)\n \tLL_PWR_SetRegulVoltageScaling(LL_PWR_REGU_VOLTAGE_SCALE1);\n \twhile (LL_PWR_IsActiveFlag_VOSRDY() == 0) {\n \t}\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(stm32h7rs_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/st/stm32/stm32h7x/Kconfig b/soc/st/stm32/stm32h7x/Kconfig\nindex 45d7b5f6956..4f8fd585712 100644\n--- a/soc/st/stm32/stm32h7x/Kconfig\n+++ b/soc/st/stm32/stm32h7x/Kconfig\n@@ -15,6 +15,7 @@ config SOC_SERIES_STM32H7X\n \tselect CPU_HAS_FPU_DOUBLE_PRECISION if CPU_CORTEX_M7\n \tselect CPU_HAS_ICACHE if CPU_CORTEX_M7\n \tselect CPU_HAS_DCACHE if CPU_CORTEX_M7\n+\tselect SOC_EARLY_INIT_HOOK\n \n config SOC_STM32H723XX\n \tselect CPU_CORTEX_M7\ndiff --git a/soc/st/stm32/stm32h7x/soc_m4.c b/soc/st/stm32/stm32h7x/soc_m4.c\nindex 0af22ec94e0..96762f89b81 100644\n--- a/soc/st/stm32/stm32h7x/soc_m4.c\n+++ b/soc/st/stm32/stm32h7x/soc_m4.c\n@@ -26,11 +26,8 @@\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int stm32h7_m4_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Enable ART Flash cache accelerator */\n \tLL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_ART);\n@@ -55,8 +52,4 @@ static int stm32h7_m4_init(void)\n \t\t\t;\n \t\t}\n \t}\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(stm32h7_m4_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/st/stm32/stm32h7x/soc_m7.c b/soc/st/stm32/stm32h7x/soc_m7.c\nindex 39c1d917c34..79715a5f39e 100644\n--- a/soc/st/stm32/stm32h7x/soc_m7.c\n+++ b/soc/st/stm32/stm32h7x/soc_m7.c\n@@ -49,11 +49,8 @@ static int stm32h7_m4_wakeup(void)\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int stm32h7_init(void)\n+void soc_early_init_hook(void)\n {\n \tsys_cache_instr_enable();\n \tsys_cache_data_enable();\n@@ -105,13 +102,8 @@ static int stm32h7_init(void)\n \tif (LL_DBGMCU_GetRevisionID() == 0x1003) {\n \t\tMODIFY_REG(GPV->AXI_TARG7_FN_MOD, 0x1, 0x1);\n \t}\n-\n-\treturn 0;\n }\n \n-SYS_INIT(stm32h7_init, PRE_KERNEL_1, 0);\n-\n-\n #if defined(CONFIG_STM32H7_DUAL_CORE)\n /* Unlock M4 once system configuration has been done */\n SYS_INIT(stm32h7_m4_wakeup, POST_KERNEL, CONFIG_APPLICATION_INIT_PRIORITY);\ndiff --git a/soc/st/stm32/stm32l0x/Kconfig b/soc/st/stm32/stm32l0x/Kconfig\nindex 80479edffec..289d0c70e04 100644\n--- a/soc/st/stm32/stm32l0x/Kconfig\n+++ b/soc/st/stm32/stm32l0x/Kconfig\n@@ -10,6 +10,7 @@ config SOC_SERIES_STM32L0X\n \tselect HAS_STM32CUBE\n \tselect CPU_CORTEX_M_HAS_SYSTICK\n \tselect HAS_PM\n+\tselect SOC_EARLY_INIT_HOOK\n \n config SOC_STM32L051XX\n \tselect CPU_HAS_ARM_MPU\ndiff --git a/soc/st/stm32/stm32l0x/power.c b/soc/st/stm32/stm32l0x/power.c\nindex cfa2281fd6a..45d353472c0 100644\n--- a/soc/st/stm32/stm32l0x/power.c\n+++ b/soc/st/stm32/stm32l0x/power.c\n@@ -74,13 +74,9 @@ void pm_state_exit_post_ops(enum pm_state state, uint8_t substate_id)\n }\n \n /* Initialize STM32 Power */\n-static int stm32_power_init(void)\n+void soc_early_init_hook(void)\n {\n \n \t/* Enable Power clock */\n \tLL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(stm32_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/st/stm32/stm32l0x/soc.c b/soc/st/stm32/stm32l0x/soc.c\nindex 1fed31f1230..174ae67514d 100644\n--- a/soc/st/stm32/stm32l0x/soc.c\n+++ b/soc/st/stm32/stm32l0x/soc.c\n@@ -22,11 +22,8 @@\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int stm32l0_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Enable ART accelerator prefetch */\n \tLL_FLASH_EnablePrefetch();\n@@ -43,8 +40,4 @@ static int stm32l0_init(void)\n \t * https://github.com/zephyrproject-rtos/zephyr/issues/#34324 )\n \t */\n \tLL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_DMA1);\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(stm32l0_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/st/stm32/stm32l1x/Kconfig b/soc/st/stm32/stm32l1x/Kconfig\nindex db21b1d0bde..656bfcb7329 100644\n--- a/soc/st/stm32/stm32l1x/Kconfig\n+++ b/soc/st/stm32/stm32l1x/Kconfig\n@@ -10,3 +10,4 @@ config SOC_SERIES_STM32L1X\n \tselect HAS_STM32CUBE\n \tselect HAS_SWO\n \tselect CPU_HAS_ARM_MPU\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/st/stm32/stm32l1x/soc.c b/soc/st/stm32/stm32l1x/soc.c\nindex caad649a4b5..2d2f4b0a6b0 100644\n--- a/soc/st/stm32/stm32l1x/soc.c\n+++ b/soc/st/stm32/stm32l1x/soc.c\n@@ -23,11 +23,8 @@\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int stm32l1_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Enable ART accelerator prefetch */\n \tLL_FLASH_EnablePrefetch();\n@@ -42,8 +39,4 @@ static int stm32l1_init(void)\n \t */\n \tLL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);\n \tLL_PWR_SetRegulVoltageScaling(LL_PWR_REGU_VOLTAGE_SCALE1);\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(stm32l1_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/st/stm32/stm32l4x/Kconfig b/soc/st/stm32/stm32l4x/Kconfig\nindex 80bc62075c3..2f6c811d493 100644\n--- a/soc/st/stm32/stm32l4x/Kconfig\n+++ b/soc/st/stm32/stm32l4x/Kconfig\n@@ -14,3 +14,4 @@ config SOC_SERIES_STM32L4X\n \tselect HAS_SWO\n \tselect HAS_PM\n \tselect HAS_POWEROFF\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/st/stm32/stm32l4x/power.c b/soc/st/stm32/stm32l4x/power.c\nindex ff87553836e..056204dfe4e 100644\n--- a/soc/st/stm32/stm32l4x/power.c\n+++ b/soc/st/stm32/stm32l4x/power.c\n@@ -114,13 +114,9 @@ void pm_state_exit_post_ops(enum pm_state state, uint8_t substate_id)\n }\n \n /* Initialize STM32 Power */\n-static int stm32_power_init(void)\n+void stm32_power_init(void)\n {\n \n \t/* enable Power clock */\n \tLL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(stm32_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/st/stm32/stm32l4x/soc.c b/soc/st/stm32/stm32l4x/soc.c\nindex 8aaf22f1097..090c014ffdd 100644\n--- a/soc/st/stm32/stm32l4x/soc.c\n+++ b/soc/st/stm32/stm32l4x/soc.c\n@@ -20,16 +20,13 @@\n #define LOG_LEVEL CONFIG_SOC_LOG_LEVEL\n LOG_MODULE_REGISTER(soc);\n \n-\n+extern void stm32_power_init(void);\n /**\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int stm32l4_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Enable the ART Accelerator I-cache, D-cache and prefetch */\n \tLL_FLASH_EnableInstCache();\n@@ -39,8 +36,7 @@ static int stm32l4_init(void)\n \t/* Update CMSIS SystemCoreClock variable (HCLK) */\n \t/* At reset, system core clock is set to 4 MHz from MSI */\n \tSystemCoreClock = 4000000;\n-\n-\treturn 0;\n+#if CONFIG_PM\n+\tstm32_power_init();\n+#endif\n }\n-\n-SYS_INIT(stm32l4_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/st/stm32/stm32l5x/Kconfig b/soc/st/stm32/stm32l5x/Kconfig\nindex ac7de0dfd7d..be4ef81f8fd 100644\n--- a/soc/st/stm32/stm32l5x/Kconfig\n+++ b/soc/st/stm32/stm32l5x/Kconfig\n@@ -14,3 +14,4 @@ config SOC_SERIES_STM32L5X\n \tselect CPU_CORTEX_M_HAS_DWT\n \tselect HAS_STM32CUBE\n \tselect HAS_PM\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/st/stm32/stm32l5x/power.c b/soc/st/stm32/stm32l5x/power.c\nindex fa8d57c894d..fa3cce5172c 100644\n--- a/soc/st/stm32/stm32l5x/power.c\n+++ b/soc/st/stm32/stm32l5x/power.c\n@@ -98,13 +98,9 @@ void pm_state_exit_post_ops(enum pm_state state, uint8_t substate_id)\n }\n \n /* Initialize STM32 Power */\n-static int stm32_power_init(void)\n+void stm32_power_init(void)\n {\n \n \t/* enable Power clock */\n \tLL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(stm32_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/st/stm32/stm32l5x/soc.c b/soc/st/stm32/stm32l5x/soc.c\nindex a932db07f5d..4c52d30bd01 100644\n--- a/soc/st/stm32/stm32l5x/soc.c\n+++ b/soc/st/stm32/stm32l5x/soc.c\n@@ -21,15 +21,13 @@\n #define LOG_LEVEL CONFIG_SOC_LOG_LEVEL\n LOG_MODULE_REGISTER(soc);\n \n+extern void stm32_power_init(void);\n /**\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int stm32l5_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Enable ICACHE */\n \twhile (LL_ICACHE_IsActiveFlag_BUSY()) {\n@@ -49,8 +47,7 @@ static int stm32l5_init(void)\n \t\t/* Disable USB Type-C dead battery pull-down behavior */\n \t\tLL_PWR_DisableUCPDDeadBattery();\n \t}\n-\n-\treturn 0;\n+#if CONFIG_PM\n+\tstm32_power_init();\n+#endif\n }\n-\n-SYS_INIT(stm32l5_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/st/stm32/stm32mp1x/Kconfig b/soc/st/stm32/stm32mp1x/Kconfig\nindex 76e50a92e4a..9c778ae6ab7 100644\n--- a/soc/st/stm32/stm32mp1x/Kconfig\n+++ b/soc/st/stm32/stm32mp1x/Kconfig\n@@ -11,3 +11,4 @@ config SOC_SERIES_STM32MP1X\n \tselect CPU_HAS_ARM_MPU\n \tselect CPU_HAS_FPU\n \tselect OPENAMP_RSC_TABLE if RAM_CONSOLE\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/st/stm32/stm32mp1x/soc.c b/soc/st/stm32/stm32mp1x/soc.c\nindex c1bedf8e209..286b8f0748a 100644\n--- a/soc/st/stm32/stm32mp1x/soc.c\n+++ b/soc/st/stm32/stm32mp1x/soc.c\n@@ -21,19 +21,12 @@\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int stm32m4_init(void)\n+void soc_early_init_hook(void)\n {\n \t/*HW semaphore Clock enable*/\n \tLL_AHB3_GRP1_EnableClock(LL_AHB3_GRP1_PERIPH_HSEM);\n \n \t/* Update CMSIS SystemCoreClock variable (HCLK) */\n \tSystemCoreClock = 209000000;\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(stm32m4_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/st/stm32/stm32u0x/Kconfig b/soc/st/stm32/stm32u0x/Kconfig\nindex 20e21825cbb..e6035c0a2d0 100644\n--- a/soc/st/stm32/stm32u0x/Kconfig\n+++ b/soc/st/stm32/stm32u0x/Kconfig\n@@ -10,3 +10,4 @@ config SOC_SERIES_STM32U0X\n \tselect CPU_CORTEX_M_HAS_VTOR\n \tselect HAS_STM32CUBE\n \tselect CPU_CORTEX_M_HAS_SYSTICK\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/st/stm32/stm32u0x/soc.c b/soc/st/stm32/stm32u0x/soc.c\nindex 2d28cd9ad2a..2c9685932df 100644\n--- a/soc/st/stm32/stm32u0x/soc.c\n+++ b/soc/st/stm32/stm32u0x/soc.c\n@@ -24,11 +24,8 @@ LOG_MODULE_REGISTER(soc);\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int stm32u0_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Enable ART Accelerator prefetch */\n \tLL_FLASH_EnablePrefetch();\n@@ -38,8 +35,4 @@ static int stm32u0_init(void)\n \tSystemCoreClock = 16000000;\n \n \tLL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(stm32u0_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/st/stm32/stm32u5x/Kconfig b/soc/st/stm32/stm32u5x/Kconfig\nindex 8408bc1c4d2..0c259125429 100644\n--- a/soc/st/stm32/stm32u5x/Kconfig\n+++ b/soc/st/stm32/stm32u5x/Kconfig\n@@ -17,6 +17,7 @@ config SOC_SERIES_STM32U5X\n \tselect HAS_STM32CUBE\n \tselect HAS_PM\n \tselect HAS_POWEROFF\n+\tselect SOC_EARLY_INIT_HOOK\n \n config STM32_STOP3_LP_MODE\n \tbool\ndiff --git a/soc/st/stm32/stm32u5x/power.c b/soc/st/stm32/stm32u5x/power.c\nindex 076c33f9170..22f12dc57bb 100644\n--- a/soc/st/stm32/stm32u5x/power.c\n+++ b/soc/st/stm32/stm32u5x/power.c\n@@ -170,7 +170,7 @@ void pm_state_exit_post_ops(enum pm_state state, uint8_t substate_id)\n }\n \n /* Initialize STM32 Power */\n-static int stm32_power_init(void)\n+void stm32_power_init(void)\n {\n \n \t/* enable Power clock */\n@@ -181,8 +181,4 @@ static int stm32_power_init(void)\n \t\t    pwr_stop3_isr, 0, 0);\n \tirq_enable(PWR_S3WU_IRQn);\n #endif\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(stm32_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/st/stm32/stm32u5x/soc.c b/soc/st/stm32/stm32u5x/soc.c\nindex 86a296b68f3..b37acbe5014 100644\n--- a/soc/st/stm32/stm32u5x/soc.c\n+++ b/soc/st/stm32/stm32u5x/soc.c\n@@ -21,15 +21,13 @@\n #define LOG_LEVEL CONFIG_SOC_LOG_LEVEL\n LOG_MODULE_REGISTER(soc);\n \n+extern void stm32_power_init(void);\n /**\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int stm32u5_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Enable instruction cache in 1-way (direct mapped cache) */\n \tLL_ICACHE_SetMode(LL_ICACHE_1WAY);\n@@ -57,7 +55,7 @@ static int stm32u5_init(void)\n #error \"Unsupported power configuration\"\n #endif\n \n-\treturn 0;\n+#if CONFIG_PM\n+\tstm32_power_init();\n+#endif\n }\n-\n-SYS_INIT(stm32u5_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/st/stm32/stm32wbax/Kconfig b/soc/st/stm32/stm32wbax/Kconfig\nindex 2f737ebb4b9..1b1418e048a 100644\n--- a/soc/st/stm32/stm32wbax/Kconfig\n+++ b/soc/st/stm32/stm32wbax/Kconfig\n@@ -15,3 +15,4 @@ config SOC_SERIES_STM32WBAX\n \tselect HAS_STM32CUBE\n \tselect USE_STM32_HAL_PWR_EX\n \tselect HAS_PM\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/st/stm32/stm32wbax/power.c b/soc/st/stm32/stm32wbax/power.c\nindex ebb6d779a7b..6fc6e424b85 100644\n--- a/soc/st/stm32/stm32wbax/power.c\n+++ b/soc/st/stm32/stm32wbax/power.c\n@@ -26,7 +26,7 @@\n \n LOG_MODULE_DECLARE(soc, CONFIG_SOC_LOG_LEVEL);\n \n-static int stm32_power_init(void);\n+void stm32_power_init(void);\n \n static void disable_cache(void)\n {\n@@ -207,7 +207,7 @@ void pm_state_exit_post_ops(enum pm_state state, uint8_t substate_id)\n }\n \n /* Initialize STM32 Power */\n-static int stm32_power_init(void)\n+void stm32_power_init(void)\n {\n \n #ifdef CONFIG_BT_STM32WBA\n@@ -228,8 +228,4 @@ static int stm32_power_init(void)\n \tLL_PWR_EnableUltraLowPowerMode();\n \n \tLL_FLASH_EnableSleepPowerDown();\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(stm32_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/st/stm32/stm32wbax/soc.c b/soc/st/stm32/stm32wbax/soc.c\nindex 983d8018a8d..9e49f8be955 100644\n--- a/soc/st/stm32/stm32wbax/soc.c\n+++ b/soc/st/stm32/stm32wbax/soc.c\n@@ -18,7 +18,7 @@\n #include <zephyr/arch/cpu.h>\n #include <zephyr/irq.h>\n #include <zephyr/logging/log.h>\n-\n+#include \"soc.h\"\n #include <cmsis_core.h>\n \n #define LOG_LEVEL CONFIG_SOC_LOG_LEVEL\n@@ -28,11 +28,8 @@ LOG_MODULE_REGISTER(soc);\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-int stm32wba_init(void)\n+void stm32wba_init(void)\n {\n \t/* Enable instruction cache in 1-way (direct mapped cache) */\n \tLL_ICACHE_SetMode(LL_ICACHE_1WAY);\n@@ -53,8 +50,12 @@ int stm32wba_init(void)\n #elif defined(CONFIG_POWER_SUPPLY_LDO)\n \tLL_PWR_SetRegulatorSupply(LL_PWR_LDO_SUPPLY);\n #endif\n-\n-\treturn 0;\n }\n \n-SYS_INIT(stm32wba_init, PRE_KERNEL_1, 0);\n+void soc_early_init_hook(void)\n+{\n+\tstm32wba_init();\n+#if CONFIG_PM\n+\tstm32_power_init();\n+#endif\n+}\ndiff --git a/soc/st/stm32/stm32wbax/soc.h b/soc/st/stm32/stm32wbax/soc.h\nindex 0c337ea9e22..be7e08e7317 100644\n--- a/soc/st/stm32/stm32wbax/soc.h\n+++ b/soc/st/stm32/stm32wbax/soc.h\n@@ -17,8 +17,11 @@\n \n #include <stm32wbaxx.h>\n \n+\n /* function exported to the soc power.c */\n-int stm32wba_init(void);\n+void stm32wba_init(void);\n+\n+void stm32_power_init(void);\n \n #endif /* !_ASMLANGUAGE */\n \ndiff --git a/soc/st/stm32/stm32wbx/Kconfig b/soc/st/stm32/stm32wbx/Kconfig\nindex 65aadce2808..b35891837e3 100644\n--- a/soc/st/stm32/stm32wbx/Kconfig\n+++ b/soc/st/stm32/stm32wbx/Kconfig\n@@ -13,3 +13,4 @@ config SOC_SERIES_STM32WBX\n \tselect HAS_SWO\n \tselect HAS_PM\n \tselect HAS_POWEROFF\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/st/stm32/stm32wbx/power.c b/soc/st/stm32/stm32wbx/power.c\nindex 6836e88c4ed..33864decd82 100644\n--- a/soc/st/stm32/stm32wbx/power.c\n+++ b/soc/st/stm32/stm32wbx/power.c\n@@ -139,9 +139,6 @@ void pm_state_exit_post_ops(enum pm_state state, uint8_t substate_id)\n }\n \n /* Initialize STM32 Power */\n-static int stm32_power_init(void)\n+void stm32_pm_init(void)\n {\n-\treturn 0;\n }\n-\n-SYS_INIT(stm32_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/st/stm32/stm32wbx/soc.c b/soc/st/stm32/stm32wbx/soc.c\nindex 02ce55e433d..5eb0739e356 100644\n--- a/soc/st/stm32/stm32wbx/soc.c\n+++ b/soc/st/stm32/stm32wbx/soc.c\n@@ -20,15 +20,13 @@\n #define LOG_LEVEL CONFIG_SOC_LOG_LEVEL\n LOG_MODULE_REGISTER(soc);\n \n+extern void stm32_pm_init(void);\n /**\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int stm32wb_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Enable the ART Accelerator I-cache, D-cache and prefetch */\n \tLL_FLASH_EnableInstCache();\n@@ -42,8 +40,8 @@ static int stm32wb_init(void)\n \t/* Set C2 Power Mode to shutdown */\n \t/* It will be updated by C2 when required */\n \tLL_C2_PWR_SetPowerMode(LL_PWR_MODE_SHUTDOWN);\n+#if CONFIG_PM\n+\tstm32_pm_init();\n+#endif\n \n-\treturn 0;\n }\n-\n-SYS_INIT(stm32wb_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/st/stm32/stm32wlx/Kconfig b/soc/st/stm32/stm32wlx/Kconfig\nindex fb041578012..b710c7826da 100644\n--- a/soc/st/stm32/stm32wlx/Kconfig\n+++ b/soc/st/stm32/stm32wlx/Kconfig\n@@ -11,3 +11,4 @@ config SOC_SERIES_STM32WLX\n \tselect CPU_HAS_ARM_MPU\n \tselect HAS_PM\n \tselect HAS_POWEROFF\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/st/stm32/stm32wlx/power.c b/soc/st/stm32/stm32wlx/power.c\nindex dab500ecb77..8ab72d1a1f4 100644\n--- a/soc/st/stm32/stm32wlx/power.c\n+++ b/soc/st/stm32/stm32wlx/power.c\n@@ -83,9 +83,6 @@ void pm_state_exit_post_ops(enum pm_state state, uint8_t substate_id)\n }\n \n /* Initialize STM32 Power */\n-static int stm32_power_init(void)\n+void stm32_pm_init(void)\n {\n-\treturn 0;\n }\n-\n-SYS_INIT(stm32_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/st/stm32/stm32wlx/soc.c b/soc/st/stm32/stm32wlx/soc.c\nindex 2b707e83e4c..c66ad9948ee 100644\n--- a/soc/st/stm32/stm32wlx/soc.c\n+++ b/soc/st/stm32/stm32wlx/soc.c\n@@ -21,16 +21,13 @@\n #define LOG_LEVEL CONFIG_SOC_LOG_LEVEL\n LOG_MODULE_REGISTER(soc);\n \n-\n+extern void stm32_pm_init(void);\n /**\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int stm32wl_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Enable CPU data and instruction cache and prefetch */\n \tLL_FLASH_EnableInstCache();\n@@ -40,8 +37,7 @@ static int stm32wl_init(void)\n \t/* Update CMSIS SystemCoreClock variable (HCLK) */\n \t/* At reset, system core clock is set to 4 MHz from MSI */\n \tSystemCoreClock = 4000000;\n-\n-\treturn 0;\n+#if CONFIG_PM\n+\tstm32_pm_init();\n+#endif\n }\n-\n-SYS_INIT(stm32wl_init, PRE_KERNEL_1, 0);"
},{
  "instruction": "soc: snps: move init code from SYS_INIT to hooks",
  "input": "static int arc_iot_init(void)\n\tif (arc_iot_pll_fout_config(CPU_FREQ / 1000000) < 0) {\n\t\treturn -1;\n\t}\n\treturn 0;\nSYS_INIT(arc_iot_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\nstatic int uart_ns16550_init(void)\n\treturn 0;\nSYS_INIT(uart_ns16550_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);",
  "result": "diff --git a/soc/snps/arc_iot/Kconfig b/soc/snps/arc_iot/Kconfig\nindex 362d2d1ae71..0ea361d2325 100644\n--- a/soc/snps/arc_iot/Kconfig\n+++ b/soc/snps/arc_iot/Kconfig\n@@ -6,3 +6,4 @@ config SOC_ARC_IOT\n \tselect ARC\n \tselect CPU_HAS_MPU\n \tselect CPU_HAS_FPU\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/snps/arc_iot/soc.c b/soc/snps/arc_iot/soc.c\nindex 832c6df5f51..d42ed3f9d9c 100644\n--- a/soc/snps/arc_iot/soc.c\n+++ b/soc/snps/arc_iot/soc.c\n@@ -15,14 +15,7 @@\n \n #define CPU_FREQ DT_PROP(DT_PATH(cpus, cpu_0), clock_frequency)\n \n-static int arc_iot_init(void)\n+void soc_early_init_hook(void)\n {\n-\n-\tif (arc_iot_pll_fout_config(CPU_FREQ / 1000000) < 0) {\n-\t\treturn -1;\n-\t}\n-\n-\treturn 0;\n+\tarc_iot_pll_fout_config(CPU_FREQ / 1000000);\n }\n-\n-SYS_INIT(arc_iot_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/snps/emsk/Kconfig b/soc/snps/emsk/Kconfig\nindex 88cdfe70671..014d5357f0a 100644\n--- a/soc/snps/emsk/Kconfig\n+++ b/soc/snps/emsk/Kconfig\n@@ -4,12 +4,16 @@\n \n config SOC_EMSK\n \tselect ARC\n+\tselect SOC_EARLY_INIT_HOOK\n \n config SOC_EMSK_EM7D\n \tselect CPU_HAS_MPU\n+\tselect SOC_EARLY_INIT_HOOK\n \n config SOC_EMSK_EM9D\n \tselect CPU_HAS_FPU\n+\tselect SOC_EARLY_INIT_HOOK\n \n config SOC_EMSK_EM11D\n \tselect CPU_HAS_FPU\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/snps/emsk/soc_config.c b/soc/snps/emsk/soc_config.c\nindex adca19b683c..c43942facb0 100644\n--- a/soc/snps/emsk/soc_config.c\n+++ b/soc/snps/emsk/soc_config.c\n@@ -11,7 +11,7 @@\n \n #ifdef CONFIG_UART_NS16550\n \n-static int uart_ns16550_init(void)\n+void soc_early_init_hook(void)\n {\n \n \t/* On ARC EM Starter kit board,\n@@ -25,10 +25,6 @@ static int uart_ns16550_init(void)\n \tsys_write32(0, DT_REG_ADDR(DT_INST(1, ns16550))+0x4);\n \tsys_write32(0, DT_REG_ADDR(DT_INST(1, ns16550))+0x10);\n #endif /* DT_NODE_HAS_STATUS(DT_INST(1, ns16550), okay) */\n-\n-\treturn 0;\n }\n \n-SYS_INIT(uart_ns16550_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\n-\n #endif /* CONFIG_UART_NS16550 */"
},{
  "instruction": "soc: silabs: move init code from SYS_INIT to hooks",
  "input": "static int silabs_init(void)\n\treturn 0;\nSYS_INIT(silabs_init, PRE_KERNEL_1, 0);\nstatic int silabs_sim3u_init(void)\n\treturn 0;\nSYS_INIT(silabs_sim3u_init, PRE_KERNEL_1, 0);",
  "result": "diff --git a/soc/silabs/common/soc.c b/soc/silabs/common/soc.c\nindex 1136a1fedfd..5d3e9db5693 100644\n--- a/soc/silabs/common/soc.c\n+++ b/soc/silabs/common/soc.c\n@@ -206,7 +206,7 @@ static void swo_init(void)\n  *\n  * @return 0\n  */\n-static int silabs_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* handle chip errata */\n \tCHIP_Init();\n@@ -240,8 +240,4 @@ static int silabs_init(void)\n \tswo_init();\n #endif\n #endif /* !CONFIG_SOC_GECKO_DEV_INIT */\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(silabs_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/silabs/silabs_s0/Kconfig b/soc/silabs/silabs_s0/Kconfig\nindex 6baa33bc1ac..90a0814185f 100644\n--- a/soc/silabs/silabs_s0/Kconfig\n+++ b/soc/silabs/silabs_s0/Kconfig\n@@ -7,6 +7,7 @@ if SOC_FAMILY_SILABS_S0\n config SOC_FAMILY_SILABS_S0\n \tselect HAS_SEGGER_RTT if ZEPHYR_SEGGER_MODULE\n \tselect BUILD_OUTPUT_HEX\n+\tselect SOC_EARLY_INIT_HOOK\n \n rsource \"*/Kconfig\"\n \ndiff --git a/soc/silabs/silabs_s1/Kconfig b/soc/silabs/silabs_s1/Kconfig\nindex 5849bd9ecaf..655fec0ea33 100644\n--- a/soc/silabs/silabs_s1/Kconfig\n+++ b/soc/silabs/silabs_s1/Kconfig\n@@ -7,6 +7,7 @@ if SOC_FAMILY_SILABS_S1\n config SOC_FAMILY_SILABS_S1\n \tselect HAS_SEGGER_RTT if ZEPHYR_SEGGER_MODULE\n \tselect BUILD_OUTPUT_HEX\n+\tselect SOC_EARLY_INIT_HOOK\n \n rsource \"*/Kconfig\"\n \ndiff --git a/soc/silabs/silabs_s2/Kconfig b/soc/silabs/silabs_s2/Kconfig\nindex 8d1dab247c9..567a72e7ea2 100644\n--- a/soc/silabs/silabs_s2/Kconfig\n+++ b/soc/silabs/silabs_s2/Kconfig\n@@ -7,6 +7,7 @@ if SOC_FAMILY_SILABS_S2\n config SOC_FAMILY_SILABS_S2\n \tselect HAS_SEGGER_RTT if ZEPHYR_SEGGER_MODULE\n \tselect BUILD_OUTPUT_HEX\n+\tselect SOC_EARLY_INIT_HOOK\n \n rsource \"*/Kconfig\"\n \ndiff --git a/soc/silabs/silabs_sim3/sim3u/Kconfig b/soc/silabs/silabs_sim3/sim3u/Kconfig\nindex 39ef1525460..0233c9b94ec 100644\n--- a/soc/silabs/silabs_sim3/sim3u/Kconfig\n+++ b/soc/silabs/silabs_sim3/sim3u/Kconfig\n@@ -8,3 +8,4 @@ config SOC_SERIES_SIM3U\n \tselect CPU_CORTEX_M3\n \tselect CPU_CORTEX_M_HAS_SYSTICK\n \tselect HAS_SILABS_SI32\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/silabs/silabs_sim3/sim3u/soc.c b/soc/silabs/silabs_sim3/sim3u/soc.c\nindex 88355105b1e..9544d2edff9 100644\n--- a/soc/silabs/silabs_sim3/sim3u/soc.c\n+++ b/soc/silabs/silabs_sim3/sim3u/soc.c\n@@ -108,7 +108,7 @@ __no_optimization static void busy_delay(uint32_t cycles)\n \t}\n }\n \n-static int silabs_sim3u_init(void)\n+void soc_early_init_hook(void)\n {\n \tuint32_t key;\n \n@@ -130,8 +130,4 @@ static int silabs_sim3u_init(void)\n \tvmon_init();\n \n \tirq_unlock(key);\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(silabs_sim3u_init, PRE_KERNEL_1, 0);"
},{
  "instruction": "soc: sifive: move init code from SYS_INIT to hooks",
  "input": "static int fe310_clock_init(void)\n\treturn 0;\nSYS_INIT(fe310_clock_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\nstatic int fu540_clock_init(void)\n\treturn 0;\nSYS_INIT(fu540_clock_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\nstatic int fu740_clock_init(void)\n\treturn 0;\nSYS_INIT(fu740_clock_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);",
  "result": "diff --git a/soc/sifive/sifive_freedom/fe300/Kconfig b/soc/sifive/sifive_freedom/fe300/Kconfig\nindex 61fe4f5c5d0..c8004564cab 100644\n--- a/soc/sifive/sifive_freedom/fe300/Kconfig\n+++ b/soc/sifive/sifive_freedom/fe300/Kconfig\n@@ -20,5 +20,5 @@ config SOC_SERIES_SIFIVE_FREEDOM_FE300\n \n \tselect ATOMIC_OPERATIONS_C\n \tselect INCLUDE_RESET_VECTOR\n-\n+\tselect SOC_EARLY_INIT_HOOK\n \timply XIP\ndiff --git a/soc/sifive/sifive_freedom/fe300/clock.c b/soc/sifive/sifive_freedom/fe300/clock.c\nindex 8fde8121db9..22a4a0d8b89 100644\n--- a/soc/sifive/sifive_freedom/fe300/clock.c\n+++ b/soc/sifive/sifive_freedom/fe300/clock.c\n@@ -13,7 +13,7 @@\n BUILD_ASSERT(DT_PROP(DT_NODELABEL(tlclk), clock_div) == 1,\n \t\"Unsupported TLCLK divider\");\n \n-static int fe310_clock_init(void)\n+void soc_early_init_hook(void)\n {\n \n \t/*\n@@ -55,7 +55,4 @@ static int fe310_clock_init(void)\n \tPRCI_REG(PRCI_PLLDIV) = (PLL_FINAL_DIV_BY_1(1) | PLL_FINAL_DIV(0));\n \tPRCI_REG(PRCI_PLLCFG) |= PLL_SEL(1);\n \tPRCI_REG(PRCI_HFROSCCFG) &= ~ROSC_EN(1);\n-\treturn 0;\n }\n-\n-SYS_INIT(fe310_clock_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/sifive/sifive_freedom/fu500/Kconfig b/soc/sifive/sifive_freedom/fu500/Kconfig\nindex 741bae415d2..c0ff2cf5a80 100644\n--- a/soc/sifive/sifive_freedom/fu500/Kconfig\n+++ b/soc/sifive/sifive_freedom/fu500/Kconfig\n@@ -16,6 +16,6 @@ config SOC_SERIES_SIFIVE_FREEDOM_FU500\n \tselect RISCV_ISA_EXT_ZICSR\n \tselect RISCV_ISA_EXT_ZIFENCEI\n \timply XIP\n-\n+\tselect SOC_EARLY_INIT_HOOK\n \tselect 64BIT\n \tselect INCLUDE_RESET_VECTOR\ndiff --git a/soc/sifive/sifive_freedom/fu500/clock.c b/soc/sifive/sifive_freedom/fu500/clock.c\nindex 7e1d4b45118..b242ba16403 100644\n--- a/soc/sifive/sifive_freedom/fu500/clock.c\n+++ b/soc/sifive/sifive_freedom/fu500/clock.c\n@@ -18,7 +18,7 @@ BUILD_ASSERT(DT_PROP(DT_NODELABEL(tlclk), clock_div) == 2,\n  * Switch the clock source to 1GHz PLL from 33.333MHz oscillator on the HiFive\n  * Unleashed board.\n  */\n-static int fu540_clock_init(void)\n+void soc_early_init_hook(void)\n {\n \n \tPRCI_REG(PRCI_COREPLLCFG0) =\n@@ -34,8 +34,4 @@ static int fu540_clock_init(void)\n \n \t/* Switch clock to COREPLL */\n \tPRCI_REG(PRCI_CORECLKSEL) = CORECLKSEL_CORECLKSEL(CORECLKSEL_CORE_PLL);\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(fu540_clock_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/sifive/sifive_freedom/fu700/Kconfig b/soc/sifive/sifive_freedom/fu700/Kconfig\nindex 7ebbbd93525..ee4cfb1168b 100644\n--- a/soc/sifive/sifive_freedom/fu700/Kconfig\n+++ b/soc/sifive/sifive_freedom/fu700/Kconfig\n@@ -15,6 +15,6 @@ config SOC_SERIES_SIFIVE_FREEDOM_FU700\n \tselect RISCV_ISA_EXT_ZICSR\n \tselect RISCV_ISA_EXT_ZIFENCEI\n \timply XIP\n-\n+\tselect SOC_EARLY_INIT_HOOK\n \tselect INCLUDE_RESET_VECTOR\n \tselect 64BIT\ndiff --git a/soc/sifive/sifive_freedom/fu700/clock.c b/soc/sifive/sifive_freedom/fu700/clock.c\nindex f14b62a6d08..be736a828b5 100644\n--- a/soc/sifive/sifive_freedom/fu700/clock.c\n+++ b/soc/sifive/sifive_freedom/fu700/clock.c\n@@ -30,7 +30,7 @@ static inline void wait_controller_cycle(void)\n  *\n  * Note: Valid PLL VCO range is 2400MHz to 4800MHz\n  */\n-static int fu740_clock_init(void)\n+void soc_early_init_hook(void)\n {\n \n \tPRCI_REG(PRCI_COREPLLCFG) =\n@@ -92,7 +92,4 @@ static int fu740_clock_init(void)\n \tfor (int i = 0; i < 256; i++) {\n \t\t__asm__ volatile (\"nop\");\n \t}\n-\treturn 0;\n }\n-\n-SYS_INIT(fu740_clock_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);"
},{
  "instruction": "soc: renesas: move init code from SYS_INIT to hooks",
  "input": "* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int renesas_ra2a1_init(void)\n\treturn 0;\nSYS_INIT(renesas_ra2a1_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int renesas_ra4e2_init(void)\n\treturn 0;\nSYS_INIT(renesas_ra4e2_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int renesas_ra4m2_init(void)\n\treturn 0;\nSYS_INIT(renesas_ra4m2_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int renesas_ra4m3_init(void)\n\treturn 0;\nSYS_INIT(renesas_ra4m3_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int renesas_ra4w1_init(void)\n\treturn 0;\nSYS_INIT(renesas_ra4w1_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int renesas_ra6e1_init(void)\n\treturn 0;\nSYS_INIT(renesas_ra6e1_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int renesas_ra6e2_init(void)\n\treturn 0;\nSYS_INIT(renesas_ra6e2_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int renesas_ra6m1_init(void)\n\treturn 0;\nSYS_INIT(renesas_ra6m1_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int renesas_ra6m2_init(void)\n\treturn 0;\nSYS_INIT(renesas_ra6m2_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int renesas_ra6m3_init(void)\n\treturn 0;\nSYS_INIT(renesas_ra6m3_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int renesas_ra6m4_init(void)\n\treturn 0;\nSYS_INIT(renesas_ra6m4_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int renesas_ra6m5_init(void)\n\treturn 0;\nSYS_INIT(renesas_ra6m5_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int renesas_ra8d1_init(void)\n\treturn 0;\nSYS_INIT(renesas_ra8d1_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int renesas_ra8m1_init(void)\n\treturn 0;\nSYS_INIT(renesas_ra8m1_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int renesas_ra8t1_init(void)\n\treturn 0;\nSYS_INIT(renesas_ra8t1_init, PRE_KERNEL_1, 0);\nstatic int rzt2m_init(void)\n\treturn 0;\nSYS_INIT(rzt2m_init, PRE_KERNEL_1, 0);\nstatic int renesas_da1469x_pm_init(void)\nSYS_INIT(renesas_da1469x_pm_init, PRE_KERNEL_2, 2);\nstatic int renesas_da1469x_init(void)\n\treturn 0;\nSYS_INIT(renesas_da1469x_init, PRE_KERNEL_1, 0);",
  "result": "diff --git a/soc/renesas/ra/ra2a1/Kconfig b/soc/renesas/ra/ra2a1/Kconfig\nindex f447a628c3a..a9915c0f4ad 100644\n--- a/soc/renesas/ra/ra2a1/Kconfig\n+++ b/soc/renesas/ra/ra2a1/Kconfig\n@@ -10,3 +10,4 @@ config SOC_SERIES_RA2A1\n \tselect HAS_SWO\n \tselect XIP\n \tselect HAS_RENESAS_RA_FSP\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/renesas/ra/ra2a1/soc.c b/soc/renesas/ra/ra2a1/soc.c\nindex 5b944eaa92d..76fc4803360 100644\n--- a/soc/renesas/ra/ra2a1/soc.c\n+++ b/soc/renesas/ra/ra2a1/soc.c\n@@ -29,17 +29,10 @@ volatile uint32_t g_protect_pfswe_counter BSP_SECTION_EARLY_INIT;\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int renesas_ra2a1_init(void)\n+void soc_early_init_hook(void)\n {\n \tSystemCoreClock = BSP_MOCO_HZ;\n \tg_protect_pfswe_counter = 0;\n \tbsp_clock_init();\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(renesas_ra2a1_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/renesas/ra/ra4e2/Kconfig b/soc/renesas/ra/ra4e2/Kconfig\nindex 6c3c2b87468..bfe486040c4 100644\n--- a/soc/renesas/ra/ra4e2/Kconfig\n+++ b/soc/renesas/ra/ra4e2/Kconfig\n@@ -13,3 +13,4 @@ config SOC_SERIES_RA4E2\n \tselect FPU\n \tselect HAS_SWO\n \tselect XIP\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/renesas/ra/ra4e2/soc.c b/soc/renesas/ra/ra4e2/soc.c\nindex 74b0e8c7641..6d11bae8208 100644\n--- a/soc/renesas/ra/ra4e2/soc.c\n+++ b/soc/renesas/ra/ra4e2/soc.c\n@@ -30,11 +30,8 @@ volatile uint32_t g_protect_pfswe_counter BSP_SECTION_EARLY_INIT;\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int renesas_ra4e2_init(void)\n+void soc_early_init_hook(void)\n {\n \textern volatile uint16_t g_protect_counters[];\n \n@@ -62,8 +59,4 @@ static int renesas_ra4e2_init(void)\n \n \tSystemCoreClock = BSP_MOCO_HZ;\n \tg_protect_pfswe_counter = 0;\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(renesas_ra4e2_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/renesas/ra/ra4m2/Kconfig b/soc/renesas/ra/ra4m2/Kconfig\nindex 1231924935d..a4b6d2c7c50 100644\n--- a/soc/renesas/ra/ra4m2/Kconfig\n+++ b/soc/renesas/ra/ra4m2/Kconfig\n@@ -13,3 +13,4 @@ config SOC_SERIES_RA4M2\n \tselect FPU\n \tselect HAS_SWO\n \tselect XIP\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/renesas/ra/ra4m2/soc.c b/soc/renesas/ra/ra4m2/soc.c\nindex e6e846ab088..c3c21184aa4 100644\n--- a/soc/renesas/ra/ra4m2/soc.c\n+++ b/soc/renesas/ra/ra4m2/soc.c\n@@ -30,11 +30,8 @@ volatile uint32_t g_protect_pfswe_counter BSP_SECTION_EARLY_INIT;\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int renesas_ra4m2_init(void)\n+void soc_early_init_hook(void)\n {\n \textern volatile uint16_t g_protect_counters[];\n \n@@ -62,8 +59,4 @@ static int renesas_ra4m2_init(void)\n \n \tSystemCoreClock = BSP_MOCO_HZ;\n \tg_protect_pfswe_counter = 0;\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(renesas_ra4m2_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/renesas/ra/ra4m3/Kconfig b/soc/renesas/ra/ra4m3/Kconfig\nindex 00eb8c9a7ab..0898c3796bc 100644\n--- a/soc/renesas/ra/ra4m3/Kconfig\n+++ b/soc/renesas/ra/ra4m3/Kconfig\n@@ -13,3 +13,4 @@ config SOC_SERIES_RA4M3\n \tselect FPU\n \tselect HAS_SWO\n \tselect XIP\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/renesas/ra/ra4m3/soc.c b/soc/renesas/ra/ra4m3/soc.c\nindex f62cd1da28c..10658184372 100644\n--- a/soc/renesas/ra/ra4m3/soc.c\n+++ b/soc/renesas/ra/ra4m3/soc.c\n@@ -30,11 +30,8 @@ volatile uint32_t g_protect_pfswe_counter BSP_SECTION_EARLY_INIT;\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int renesas_ra4m3_init(void)\n+void soc_early_init_hook(void)\n {\n \textern volatile uint16_t g_protect_counters[];\n \n@@ -62,8 +59,4 @@ static int renesas_ra4m3_init(void)\n \n \tSystemCoreClock = BSP_MOCO_HZ;\n \tg_protect_pfswe_counter = 0;\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(renesas_ra4m3_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/renesas/ra/ra4w1/Kconfig b/soc/renesas/ra/ra4w1/Kconfig\nindex 358633bb895..c9d1fbb3703 100644\n--- a/soc/renesas/ra/ra4w1/Kconfig\n+++ b/soc/renesas/ra/ra4w1/Kconfig\n@@ -12,3 +12,4 @@ config SOC_SERIES_RA4W1\n \tselect FPU\n \tselect HAS_SWO\n \tselect XIP\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/renesas/ra/ra4w1/soc.c b/soc/renesas/ra/ra4w1/soc.c\nindex d3f9b351d24..6d84c068f7d 100644\n--- a/soc/renesas/ra/ra4w1/soc.c\n+++ b/soc/renesas/ra/ra4w1/soc.c\n@@ -30,16 +30,9 @@ volatile uint32_t g_protect_pfswe_counter BSP_SECTION_EARLY_INIT;\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int renesas_ra4w1_init(void)\n+void soc_early_init_hook(void)\n {\n \tSystemCoreClock = BSP_MOCO_HZ;\n \tg_protect_pfswe_counter = 0;\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(renesas_ra4w1_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/renesas/ra/ra6e1/Kconfig b/soc/renesas/ra/ra6e1/Kconfig\nindex e67c9f66dc2..accd57e26a0 100644\n--- a/soc/renesas/ra/ra6e1/Kconfig\n+++ b/soc/renesas/ra/ra6e1/Kconfig\n@@ -13,3 +13,4 @@ config SOC_SERIES_RA6E1\n \tselect FPU\n \tselect HAS_SWO\n \tselect XIP\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/renesas/ra/ra6e1/soc.c b/soc/renesas/ra/ra6e1/soc.c\nindex 5ca796f5bbe..ca37db8e274 100644\n--- a/soc/renesas/ra/ra6e1/soc.c\n+++ b/soc/renesas/ra/ra6e1/soc.c\n@@ -29,11 +29,8 @@ volatile uint32_t g_protect_pfswe_counter BSP_SECTION_EARLY_INIT;\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int renesas_ra6e1_init(void)\n+void soc_early_init_hook(void)\n {\n \tuint32_t key;\n \n@@ -67,8 +64,4 @@ static int renesas_ra6e1_init(void)\n \tg_protect_pfswe_counter = 0;\n \n \tirq_unlock(key);\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(renesas_ra6e1_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/renesas/ra/ra6e2/Kconfig b/soc/renesas/ra/ra6e2/Kconfig\nindex 9ac1ba7dd42..f7081a1c958 100644\n--- a/soc/renesas/ra/ra6e2/Kconfig\n+++ b/soc/renesas/ra/ra6e2/Kconfig\n@@ -13,3 +13,4 @@ config SOC_SERIES_RA6E2\n \tselect FPU\n \tselect HAS_SWO\n \tselect XIP\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/renesas/ra/ra6e2/soc.c b/soc/renesas/ra/ra6e2/soc.c\nindex 2249db628e4..2b34260479e 100644\n--- a/soc/renesas/ra/ra6e2/soc.c\n+++ b/soc/renesas/ra/ra6e2/soc.c\n@@ -29,11 +29,8 @@ volatile uint32_t g_protect_pfswe_counter BSP_SECTION_EARLY_INIT;\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int renesas_ra6e2_init(void)\n+void soc_early_init_hook(void)\n {\n \tuint32_t key;\n \n@@ -67,8 +64,4 @@ static int renesas_ra6e2_init(void)\n \tg_protect_pfswe_counter = 0;\n \n \tirq_unlock(key);\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(renesas_ra6e2_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/renesas/ra/ra6m1/Kconfig b/soc/renesas/ra/ra6m1/Kconfig\nindex e2520fc4569..649b6702629 100644\n--- a/soc/renesas/ra/ra6m1/Kconfig\n+++ b/soc/renesas/ra/ra6m1/Kconfig\n@@ -12,3 +12,4 @@ config SOC_SERIES_RA6M1\n \tselect FPU\n \tselect HAS_SWO\n \tselect XIP\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/renesas/ra/ra6m1/soc.c b/soc/renesas/ra/ra6m1/soc.c\nindex d56bde197e6..c9809254ae2 100644\n--- a/soc/renesas/ra/ra6m1/soc.c\n+++ b/soc/renesas/ra/ra6m1/soc.c\n@@ -29,11 +29,8 @@ volatile uint32_t g_protect_pfswe_counter BSP_SECTION_EARLY_INIT;\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int renesas_ra6m1_init(void)\n+void soc_early_init_hook(void)\n {\n \tuint32_t key;\n \n@@ -43,8 +40,4 @@ static int renesas_ra6m1_init(void)\n \tg_protect_pfswe_counter = 0;\n \n \tirq_unlock(key);\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(renesas_ra6m1_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/renesas/ra/ra6m2/Kconfig b/soc/renesas/ra/ra6m2/Kconfig\nindex 89c951a9db9..680e649349d 100644\n--- a/soc/renesas/ra/ra6m2/Kconfig\n+++ b/soc/renesas/ra/ra6m2/Kconfig\n@@ -12,3 +12,4 @@ config SOC_SERIES_RA6M2\n \tselect FPU\n \tselect HAS_SWO\n \tselect XIP\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/renesas/ra/ra6m2/soc.c b/soc/renesas/ra/ra6m2/soc.c\nindex 4b10f2123e6..f0d399463f5 100644\n--- a/soc/renesas/ra/ra6m2/soc.c\n+++ b/soc/renesas/ra/ra6m2/soc.c\n@@ -29,11 +29,8 @@ volatile uint32_t g_protect_pfswe_counter BSP_SECTION_EARLY_INIT;\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int renesas_ra6m2_init(void)\n+void soc_early_init_hook(void)\n {\n \tuint32_t key;\n \n@@ -43,8 +40,4 @@ static int renesas_ra6m2_init(void)\n \tg_protect_pfswe_counter = 0;\n \n \tirq_unlock(key);\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(renesas_ra6m2_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/renesas/ra/ra6m3/Kconfig b/soc/renesas/ra/ra6m3/Kconfig\nindex c91e5284022..bebd78f1bab 100644\n--- a/soc/renesas/ra/ra6m3/Kconfig\n+++ b/soc/renesas/ra/ra6m3/Kconfig\n@@ -12,3 +12,4 @@ config SOC_SERIES_RA6M3\n \tselect FPU\n \tselect HAS_SWO\n \tselect XIP\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/renesas/ra/ra6m3/soc.c b/soc/renesas/ra/ra6m3/soc.c\nindex b2d87b50f0a..99f9a60e6eb 100644\n--- a/soc/renesas/ra/ra6m3/soc.c\n+++ b/soc/renesas/ra/ra6m3/soc.c\n@@ -29,11 +29,8 @@ volatile uint32_t g_protect_pfswe_counter BSP_SECTION_EARLY_INIT;\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int renesas_ra6m3_init(void)\n+void soc_early_init_hook(void)\n {\n \tuint32_t key;\n \n@@ -43,8 +40,4 @@ static int renesas_ra6m3_init(void)\n \tg_protect_pfswe_counter = 0;\n \n \tirq_unlock(key);\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(renesas_ra6m3_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/renesas/ra/ra6m4/Kconfig b/soc/renesas/ra/ra6m4/Kconfig\nindex b74ea6807dc..ee2acc2855f 100644\n--- a/soc/renesas/ra/ra6m4/Kconfig\n+++ b/soc/renesas/ra/ra6m4/Kconfig\n@@ -13,3 +13,4 @@ config SOC_SERIES_RA6M4\n \tselect FPU\n \tselect HAS_SWO\n \tselect XIP\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/renesas/ra/ra6m4/soc.c b/soc/renesas/ra/ra6m4/soc.c\nindex 1d61e5f40c7..f561d631b67 100644\n--- a/soc/renesas/ra/ra6m4/soc.c\n+++ b/soc/renesas/ra/ra6m4/soc.c\n@@ -29,11 +29,8 @@ volatile uint32_t g_protect_pfswe_counter BSP_SECTION_EARLY_INIT;\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int renesas_ra6m4_init(void)\n+void soc_early_init_hook(void)\n {\n \tuint32_t key;\n \n@@ -67,8 +64,4 @@ static int renesas_ra6m4_init(void)\n \tg_protect_pfswe_counter = 0;\n \n \tirq_unlock(key);\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(renesas_ra6m4_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/renesas/ra/ra6m5/Kconfig b/soc/renesas/ra/ra6m5/Kconfig\nindex f7fdc083bc2..4a8f750eab6 100644\n--- a/soc/renesas/ra/ra6m5/Kconfig\n+++ b/soc/renesas/ra/ra6m5/Kconfig\n@@ -13,3 +13,4 @@ config SOC_SERIES_RA6M5\n \tselect FPU\n \tselect HAS_SWO\n \tselect XIP\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/renesas/ra/ra6m5/soc.c b/soc/renesas/ra/ra6m5/soc.c\nindex fda381f0f0d..f156a3c5fb2 100644\n--- a/soc/renesas/ra/ra6m5/soc.c\n+++ b/soc/renesas/ra/ra6m5/soc.c\n@@ -29,11 +29,8 @@ volatile uint32_t g_protect_pfswe_counter BSP_SECTION_EARLY_INIT;\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int renesas_ra6m5_init(void)\n+void soc_early_init_hook(void)\n {\n \tuint32_t key;\n \n@@ -67,8 +64,4 @@ static int renesas_ra6m5_init(void)\n \tg_protect_pfswe_counter = 0;\n \n \tirq_unlock(key);\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(renesas_ra6m5_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/renesas/ra/ra8d1/Kconfig b/soc/renesas/ra/ra8d1/Kconfig\nindex 8945d31a8b3..968c60343c6 100644\n--- a/soc/renesas/ra/ra8d1/Kconfig\n+++ b/soc/renesas/ra/ra8d1/Kconfig\n@@ -13,3 +13,4 @@ config SOC_SERIES_RA8D1\n \tselect XIP\n \tselect CLOCK_CONTROL_RENESAS_RA_CGC if CLOCK_CONTROL\n \tselect HAS_RENESAS_RA_FSP\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/renesas/ra/ra8d1/soc.c b/soc/renesas/ra/ra8d1/soc.c\nindex e915ceb8816..4d78ba0e1ca 100644\n--- a/soc/renesas/ra/ra8d1/soc.c\n+++ b/soc/renesas/ra/ra8d1/soc.c\n@@ -29,16 +29,9 @@ volatile uint32_t g_protect_pfswe_counter BSP_SECTION_EARLY_INIT;\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int renesas_ra8d1_init(void)\n+void soc_early_init_hook(void)\n {\n \tSystemCoreClock = BSP_MOCO_HZ;\n \tg_protect_pfswe_counter = 0;\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(renesas_ra8d1_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/renesas/ra/ra8m1/Kconfig b/soc/renesas/ra/ra8m1/Kconfig\nindex 98d6503297b..f1fd9d9967e 100644\n--- a/soc/renesas/ra/ra8m1/Kconfig\n+++ b/soc/renesas/ra/ra8m1/Kconfig\n@@ -13,5 +13,6 @@ config SOC_SERIES_RA8M1\n \tselect XIP\n \tselect CLOCK_CONTROL_RENESAS_RA_CGC if CLOCK_CONTROL\n \tselect HAS_RENESAS_RA_FSP\n+\tselect SOC_EARLY_INIT_HOOK\n \thelp\n \t  Enable support for Renesas RA8M1 MCU series\ndiff --git a/soc/renesas/ra/ra8m1/soc.c b/soc/renesas/ra/ra8m1/soc.c\nindex 3c110730f16..a0da08c8616 100644\n--- a/soc/renesas/ra/ra8m1/soc.c\n+++ b/soc/renesas/ra/ra8m1/soc.c\n@@ -29,16 +29,9 @@ volatile uint32_t g_protect_pfswe_counter BSP_SECTION_EARLY_INIT;\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int renesas_ra8m1_init(void)\n+void soc_early_init_hook(void)\n {\n \tSystemCoreClock = BSP_MOCO_HZ;\n \tg_protect_pfswe_counter = 0;\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(renesas_ra8m1_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/renesas/ra/ra8t1/Kconfig b/soc/renesas/ra/ra8t1/Kconfig\nindex 1c96706ad2f..426e72be95d 100644\n--- a/soc/renesas/ra/ra8t1/Kconfig\n+++ b/soc/renesas/ra/ra8t1/Kconfig\n@@ -13,3 +13,4 @@ config SOC_SERIES_RA8T1\n \tselect XIP\n \tselect CLOCK_CONTROL_RENESAS_RA_CGC if CLOCK_CONTROL\n \tselect HAS_RENESAS_RA_FSP\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/renesas/ra/ra8t1/soc.c b/soc/renesas/ra/ra8t1/soc.c\nindex e62a6d2c102..33948ba3097 100644\n--- a/soc/renesas/ra/ra8t1/soc.c\n+++ b/soc/renesas/ra/ra8t1/soc.c\n@@ -29,16 +29,9 @@ volatile uint32_t g_protect_pfswe_counter BSP_SECTION_EARLY_INIT;\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int renesas_ra8t1_init(void)\n+void soc_early_init_hook(void)\n {\n \tSystemCoreClock = BSP_MOCO_HZ;\n \tg_protect_pfswe_counter = 0;\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(renesas_ra8t1_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/renesas/rzt2m/Kconfig b/soc/renesas/rzt2m/Kconfig\nindex c8274534a24..1b0d438c31f 100644\n--- a/soc/renesas/rzt2m/Kconfig\n+++ b/soc/renesas/rzt2m/Kconfig\n@@ -8,3 +8,4 @@ config SOC_RENESAS_RZT2M\n \tselect GIC_SINGLE_SECURITY_STATE\n \tselect ARM_ARCH_TIMER\n \tselect SYSCON\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/renesas/rzt2m/soc.c b/soc/renesas/rzt2m/soc.c\nindex 673994e254d..183381179ba 100644\n--- a/soc/renesas/rzt2m/soc.c\n+++ b/soc/renesas/rzt2m/soc.c\n@@ -90,7 +90,7 @@ void rzt2m_enable_counters(void)\n \tsyscon_write_reg(dev, 0, CNTCR_EN);\n }\n \n-static int rzt2m_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Unlock the Protect Registers\n \t * so that device drivers can access configuration registers of peripherals.\n@@ -115,7 +115,4 @@ static int rzt2m_init(void)\n \trzt2m_lock_prcrn(PRCRN_PRC1 | PRCRN_PRC2 | PRCRN_PRC0);\n \n \trzt2m_enable_counters();\n-\treturn 0;\n }\n-\n-SYS_INIT(rzt2m_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/renesas/smartbond/da1469x/Kconfig b/soc/renesas/smartbond/da1469x/Kconfig\nindex 024120268ab..5c4225a0dcc 100644\n--- a/soc/renesas/smartbond/da1469x/Kconfig\n+++ b/soc/renesas/smartbond/da1469x/Kconfig\n@@ -14,4 +14,5 @@ config SOC_SERIES_DA1469X\n \tselect CLOCK_CONTROL_SMARTBOND\n \tselect SOC_RESET_HOOK\n \tselect PM_DEVICE if PM\n+\tselect SOC_EARLY_INIT_HOOK\n \timply TIMER_READS_ITS_FREQUENCY_AT_RUNTIME\ndiff --git a/soc/renesas/smartbond/da1469x/power.c b/soc/renesas/smartbond/da1469x/power.c\nindex 80a497acff5..3e39239bcd1 100644\n--- a/soc/renesas/smartbond/da1469x/power.c\n+++ b/soc/renesas/smartbond/da1469x/power.c\n@@ -45,7 +45,7 @@ void pm_state_exit_post_ops(enum pm_state state, uint8_t substate_id)\n \t}\n }\n \n-static int renesas_da1469x_pm_init(void)\n+int renesas_da1469x_pm_init(void)\n {\n \tstatic const struct da1469x_sleep_config sleep_cfg = {\n \t\t.enable_xtal_on_wakeup = DT_NODE_HAS_STATUS(DT_NODELABEL(xtal32m), okay),\n@@ -55,5 +55,3 @@ static int renesas_da1469x_pm_init(void)\n \n \treturn 0;\n }\n-\n-SYS_INIT(renesas_da1469x_pm_init, PRE_KERNEL_2, 2);\ndiff --git a/soc/renesas/smartbond/da1469x/soc.c b/soc/renesas/smartbond/da1469x/soc.c\nindex 40bb55ebd0d..79b191cb596 100644\n--- a/soc/renesas/smartbond/da1469x/soc.c\n+++ b/soc/renesas/smartbond/da1469x/soc.c\n@@ -131,7 +131,10 @@ void soc_reset_hook(void)\n #endif\n }\n \n-static int renesas_da1469x_init(void)\n+/* defined in power.c */\n+extern int renesas_da1469x_pm_init(void);\n+\n+void soc_early_init_hook(void)\n {\n \t/* Freeze watchdog until configured */\n \tGPREG->SET_FREEZE_REG = GPREG_SET_FREEZE_REG_FRZ_SYS_WDOG_Msk;\n@@ -176,8 +179,7 @@ static int renesas_da1469x_init(void)\n \tda1469x_pd_acquire(MCU_PD_DOMAIN_TIM);\n \n \tda1469x_pdc_reset();\n-\n-\treturn 0;\n+#if CONFIG_PM\n+\trenesas_da1469x_pm_init();\n+#endif\n }\n-\n-SYS_INIT(renesas_da1469x_init, PRE_KERNEL_1, 0);"
},{
  "instruction": "soc: quicklogic: move init code from SYS_INIT to hooks",
  "input": "static int eos_s3_init(void)\n\treturn 0;\nSYS_INIT(eos_s3_init, PRE_KERNEL_1, 0);",
  "result": "diff --git a/soc/quicklogic/eos_s3/Kconfig b/soc/quicklogic/eos_s3/Kconfig\nindex e294a432778..b68aa40bcf9 100644\n--- a/soc/quicklogic/eos_s3/Kconfig\n+++ b/soc/quicklogic/eos_s3/Kconfig\n@@ -8,3 +8,4 @@ config SOC_EOS_S3\n \tselect CPU_HAS_ARM_MPU\n \tselect CPU_HAS_FPU\n \tselect EOS_S3_HAL\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/quicklogic/eos_s3/soc.c b/soc/quicklogic/eos_s3/soc.c\nindex ff18c372740..0af6db2fd5c 100644\n--- a/soc/quicklogic/eos_s3/soc.c\n+++ b/soc/quicklogic/eos_s3/soc.c\n@@ -50,7 +50,7 @@ static void eos_s3_cru_init(void)\n \n \n \n-static int eos_s3_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Clocks setup */\n \teos_s3_lock_enable();\n@@ -64,8 +64,4 @@ static int eos_s3_init(void)\n \n \t/* Enable UART interrupt */\n \tINTR_CTRL->OTHER_INTR_EN_M4 = UART_INTR_EN_M4;\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(eos_s3_init, PRE_KERNEL_1, 0);"
},{
  "instruction": "soc: openisa: move init code from SYS_INIT to hooks",
  "input": "static int soc_rv32m1_init(void)\n\treturn 0;\nSYS_INIT(soc_rv32m1_init, PRE_KERNEL_1, 0);",
  "result": "diff --git a/soc/openisa/rv32m1/Kconfig b/soc/openisa/rv32m1/Kconfig\nindex 199d13ba744..0ee9dd7565a 100644\n--- a/soc/openisa/rv32m1/Kconfig\n+++ b/soc/openisa/rv32m1/Kconfig\n@@ -20,3 +20,4 @@ config SOC_OPENISA_RV32M1\n \tselect RISCV_ISA_EXT_C\n \tselect RISCV_ISA_EXT_ZICSR\n \tselect RISCV_ISA_EXT_ZIFENCEI\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/openisa/rv32m1/soc.c b/soc/openisa/rv32m1/soc.c\nindex 95edf0c5383..cfcc6a0387b 100644\n--- a/soc/openisa/rv32m1/soc.c\n+++ b/soc/openisa/rv32m1/soc.c\n@@ -218,7 +218,7 @@ static void rv32m1_setup_peripheral_clocks(void)\n  *\n  * @return 0\n  */\n-static int soc_rv32m1_init(void)\n+void soc_early_init_hook(void)\n {\n \tunsigned int key;\n \n@@ -239,8 +239,4 @@ static int soc_rv32m1_init(void)\n \trv32m1_setup_peripheral_clocks();\n \n \tirq_unlock(key);\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(soc_rv32m1_init, PRE_KERNEL_1, 0);"
},{
  "instruction": "soc: nxp: move init code from SYS_INIT to hooks",
  "input": "static int mcimx6x_m4_init(void)\n\treturn 0;\nSYS_INIT(mcimx6x_m4_init, PRE_KERNEL_1, 0);\nstatic int nxp_mcimx7_init(void)\n\treturn 0;\nSYS_INIT(nxp_mcimx7_init, PRE_KERNEL_1, 0);\nstatic int soc_init(void)\n\treturn 0;\nSYS_INIT(soc_init, EARLY, 1);\nstatic int nxp_mimx8mm6_init(void)\n\treturn 0;\nSYS_INIT(nxp_mimx8mm6_init, PRE_KERNEL_1, 0);\nstatic int nxp_mimx8mq6_init(void)\n\treturn 0;\nSYS_INIT(nxp_mimx8mq6_init, PRE_KERNEL_1, 0);\nstatic int nxp_mimx8ml8_init(void)\n\treturn 0;\nSYS_INIT(nxp_mimx8ml8_init, PRE_KERNEL_1, 0);\n\tselect SOC_RESET_HOOK\nstatic int imxrt_lpm_init(void)\n\treturn 0;\nSYS_INIT(imxrt_lpm_init, PRE_KERNEL_1, 0);\nstatic int rt10xx_power_init(void)\n\treturn 0;\nSYS_INIT(rt10xx_power_init, PRE_KERNEL_2, 0);\n*\n* @return 0\nstatic int imxrt_init(void)\n\treturn 0;\nSYS_INIT(imxrt_init, PRE_KERNEL_1, 0);\nstatic int imxrt_init(void)\n\treturn 0;\nSYS_INIT(imxrt_init, PRE_KERNEL_1, 0);\nstatic int rt5xx_power_init(void)\n\tint ret = 0;\n\treturn ret;\nSYS_INIT(rt5xx_power_init, PRE_KERNEL_2, 0);\n*\n* @return 0\nstatic int nxp_rt500_init(void)\n\treturn 0;\nSYS_INIT(nxp_rt500_init, PRE_KERNEL_1, 0);\n*\n* @return 0\nstatic int nxp_rt600_init(void)\n\treturn 0;\nSYS_INIT(nxp_rt600_init, PRE_KERNEL_1, 0);\nstatic int fsl_frdm_k22f_init(void)\n\treturn 0;\nSYS_INIT(fsl_frdm_k22f_init, PRE_KERNEL_1, 0);\n* @return 0\nstatic int k6x_init(void)\n\treturn 0;\nSYS_INIT(k6x_init, PRE_KERNEL_1, 0);\nstatic int k8x_init(void)\n\treturn 0;\nSYS_INIT(k8x_init, PRE_KERNEL_1, 0);\nstatic int ke1xf_init(void)\n\treturn 0;\nSYS_INIT(ke1xf_init, PRE_KERNEL_1, 0);\nstatic int ke1xz_init(void)\n\treturn 0;\nSYS_INIT(ke1xz_init, PRE_KERNEL_1, 0);\nstatic int kl2x_init(void)\n\treturn 0;\nSYS_INIT(kl2x_init, PRE_KERNEL_1, 0);\nstatic int kv5x_init(void)\n\treturn 0;\nSYS_INIT(kv5x_init, PRE_KERNEL_1, 0);\nstatic int kw2xd_init(void)\n\treturn 0;\nSYS_INIT(kw2xd_init, PRE_KERNEL_1, 0);\nstatic int kwx_init(void)\n\treturn 0;\nSYS_INIT(kwx_init, PRE_KERNEL_1, 0);\nint soc_init(void)\n\treturn 0;\nSYS_INIT(soc_init, PRE_KERNEL_1, 0);\nstatic int mcxc_init(void)\n\treturn 0;\nSYS_INIT(mcxc_init, PRE_KERNEL_1, 0);\nstatic int nxp_rw6xx_power_init(void)\n\treturn 0;\nSYS_INIT(nxp_rw6xx_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\n*\n* @return 0\nstatic int nxp_rw600_init(void)\n\treturn 0;\nSYS_INIT(nxp_rw600_init, PRE_KERNEL_1, 0);\nstatic int soc_init(void)\n\treturn 0;\nSYS_INIT(soc_init, PRE_KERNEL_1, 0);\nstatic int soc_init(void)\n\treturn 0;\nSYS_INIT(soc_init, PRE_KERNEL_1, 0);\nstatic int soc_init(void)\n\treturn 0;\nSYS_INIT(soc_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);",
  "result": "diff --git a/soc/nxp/imx/imx6sx/Kconfig b/soc/nxp/imx/imx6sx/Kconfig\nindex 901b2c90a64..f83d462be4c 100644\n--- a/soc/nxp/imx/imx6sx/Kconfig\n+++ b/soc/nxp/imx/imx6sx/Kconfig\n@@ -9,6 +9,7 @@ config SOC_SERIES_IMX6SX\n \tselect CPU_HAS_FPU\n \tselect CPU_HAS_ARM_MPU\n \tselect CLOCK_CONTROL\n+\tselect SOC_EARLY_INIT_HOOK\n \n config SOC_MCIMX6X_M4\n \tselect HAS_IMX_HAL\ndiff --git a/soc/nxp/imx/imx6sx/soc.c b/soc/nxp/imx/imx6sx/soc.c\nindex a968e5d5cb1..11cbac10002 100644\n--- a/soc/nxp/imx/imx6sx/soc.c\n+++ b/soc/nxp/imx/imx6sx/soc.c\n@@ -287,7 +287,7 @@ static void SOC_ClockInit(void)\n  *\n  * @return 0\n  */\n-static int mcimx6x_m4_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Configure RDC */\n \tSOC_RdcInit();\n@@ -300,8 +300,4 @@ static int mcimx6x_m4_init(void)\n \n \t/* Initialize clock */\n \tSOC_ClockInit();\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(mcimx6x_m4_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nxp/imx/imx7d/Kconfig b/soc/nxp/imx/imx7d/Kconfig\nindex fbebe524242..1aa97734285 100644\n--- a/soc/nxp/imx/imx7d/Kconfig\n+++ b/soc/nxp/imx/imx7d/Kconfig\n@@ -8,6 +8,7 @@ config SOC_SERIES_IMX7D\n \tselect CLOCK_CONTROL\n \tselect CPU_HAS_FPU\n \tselect CPU_HAS_ARM_MPU\n+\tselect SOC_EARLY_INIT_HOOK\n \n config SOC_MCIMX7D_M4\n \tselect HAS_IMX_HAL\ndiff --git a/soc/nxp/imx/imx7d/soc.c b/soc/nxp/imx/imx7d/soc.c\nindex 5ebf3ec0738..df3ee95f2e1 100644\n--- a/soc/nxp/imx/imx7d/soc.c\n+++ b/soc/nxp/imx/imx7d/soc.c\n@@ -222,7 +222,7 @@ static void nxp_mcimx7_mu_config(void)\n }\n #endif /* CONFIG_IPM_IMX */\n \n-static int nxp_mcimx7_init(void)\n+void soc_early_init_hook(void)\n {\n \n \t/* SoC specific RDC settings */\n@@ -250,8 +250,4 @@ static int nxp_mcimx7_init(void)\n #ifdef CONFIG_IPM_IMX\n \tnxp_mcimx7_mu_config();\n #endif /* CONFIG_IPM_IMX */\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(nxp_mcimx7_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nxp/imx/imx8m/Kconfig b/soc/nxp/imx/imx8m/Kconfig\nindex fe206de1527..a1344a8c38e 100644\n--- a/soc/nxp/imx/imx8m/Kconfig\n+++ b/soc/nxp/imx/imx8m/Kconfig\n@@ -10,6 +10,7 @@ config SOC_MIMX8MM6_A53\n \tselect HAS_MCUX_IOMUXC if PINCTRL\n \tselect HAS_MCUX_RDC\n \tselect HAS_MCUX_CACHE\n+\tselect SOC_PREP_HOOK\n \n config SOC_MIMX8MM6_M4\n \tselect ARM\n@@ -21,6 +22,7 @@ config SOC_MIMX8MM6_M4\n \tselect HAS_MCUX_RDC\n \tselect HAS_MCUX_IGPIO\n \tselect HAS_MCUX_IOMUXC\n+\tselect SOC_EARLY_INIT_HOOK\n \n config SOC_MIMX8ML8_A53\n \tselect ARM64\n@@ -31,6 +33,7 @@ config SOC_MIMX8ML8_A53\n \tselect HAS_MCUX_IOMUXC if PINCTRL\n \tselect HAS_MCUX_RDC\n \tselect HAS_MCUX_CACHE\n+\tselect SOC_PREP_HOOK\n \n config SOC_MIMX8MN6_A53\n \tselect ARM64\n@@ -41,6 +44,7 @@ config SOC_MIMX8MN6_A53\n \tselect HAS_MCUX_IOMUXC if PINCTRL\n \tselect HAS_MCUX_RDC\n \tselect HAS_MCUX_CACHE\n+\tselect SOC_PREP_HOOK\n \n config SOC_MIMX8ML8_ADSP\n \tselect XTENSA\n@@ -71,6 +75,7 @@ config SOC_MIMX8ML8_M7\n \tselect ARM_MPU\n \tselect HAS_MCUX_IGPIO\n \tselect HAS_MCUX_IOMUXC\n+\tselect SOC_EARLY_INIT_HOOK\n \n config SOC_MIMX8MQ6_M4\n \tselect ARM\ndiff --git a/soc/nxp/imx/imx8m/a53/soc.c b/soc/nxp/imx/imx8m/a53/soc.c\nindex c5eaa312370..a20ae395f18 100644\n--- a/soc/nxp/imx/imx8m/a53/soc.c\n+++ b/soc/nxp/imx/imx8m/a53/soc.c\n@@ -52,11 +52,7 @@ static void soc_rdc_init(void)\n \n #endif\n \n-static int soc_init(void)\n+void soc_prep_hook(void)\n {\n \tsoc_rdc_init();\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(soc_init, EARLY, 1);\ndiff --git a/soc/nxp/imx/imx8m/m4_mini/soc.c b/soc/nxp/imx/imx8m/m4_mini/soc.c\nindex fab49d98bff..784c39fcc04 100644\n--- a/soc/nxp/imx/imx8m/m4_mini/soc.c\n+++ b/soc/nxp/imx/imx8m/m4_mini/soc.c\n@@ -148,7 +148,7 @@ static void SOC_ClockInit(void)\n \tCLOCK_EnableClock(kCLOCK_Sec_Debug);\n }\n \n-static int nxp_mimx8mm6_init(void)\n+void soc_early_init_hook(void)\n {\n \n \t/* SoC specific RDC settings */\n@@ -156,8 +156,4 @@ static int nxp_mimx8mm6_init(void)\n \n \t/* SoC specific Clock settings */\n \tSOC_ClockInit();\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(nxp_mimx8mm6_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nxp/imx/imx8m/m4_quad/soc.c b/soc/nxp/imx/imx8m/m4_quad/soc.c\nindex e2849f62fe4..031121bc424 100644\n--- a/soc/nxp/imx/imx8m/m4_quad/soc.c\n+++ b/soc/nxp/imx/imx8m/m4_quad/soc.c\n@@ -111,7 +111,7 @@ static void SOC_ClockInit(void)\n \tCLOCK_EnableClock(kCLOCK_Sec_Debug);\n }\n \n-static int nxp_mimx8mq6_init(void)\n+void soc_early_init_hook(void)\n {\n \n \t/* SoC specific RDC settings */\n@@ -119,8 +119,4 @@ static int nxp_mimx8mq6_init(void)\n \n \t/* SoC specific Clock settings */\n \tSOC_ClockInit();\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(nxp_mimx8mq6_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nxp/imx/imx8m/m7/soc.c b/soc/nxp/imx/imx8m/m7/soc.c\nindex 724368eac37..683d550b149 100644\n--- a/soc/nxp/imx/imx8m/m7/soc.c\n+++ b/soc/nxp/imx/imx8m/m7/soc.c\n@@ -203,7 +203,7 @@ static void gpio_init(void)\n #endif\n }\n \n-static int nxp_mimx8ml8_init(void)\n+void soc_early_init_hook(void)\n {\n \n \t/* SoC specific RDC settings */\n@@ -213,8 +213,4 @@ static int nxp_mimx8ml8_init(void)\n \tSOC_ClockInit();\n \n \tgpio_init();\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(nxp_mimx8ml8_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nxp/imxrt/imxrt10xx/Kconfig b/soc/nxp/imxrt/imxrt10xx/Kconfig\nindex 05eb7b5e8ac..c86f946aab8 100644\n--- a/soc/nxp/imxrt/imxrt10xx/Kconfig\n+++ b/soc/nxp/imxrt/imxrt10xx/Kconfig\n@@ -6,7 +6,6 @@ config SOC_SERIES_IMXRT10XX\n \tselect CPU_CORTEX_M_HAS_DWT\n \tselect CPU_HAS_ICACHE\n \tselect CPU_HAS_DCACHE\n-\tselect SOC_RESET_HOOK\n \tselect CPU_HAS_CUSTOM_FIXED_SOC_MPU_REGIONS\n \tselect ARM\n \tselect CLOCK_CONTROL\n@@ -29,6 +28,8 @@ config SOC_SERIES_IMXRT10XX\n \tselect HAS_MCUX_USB_EHCI\n \tselect HAS_SWO\n \tselect HAS_PM\n+\tselect SOC_RESET_HOOK\n+\tselect SOC_EARLY_INIT_HOOK\n \n config SOC_MIMXRT1011\n \tselect CPU_HAS_FPU\ndiff --git a/soc/nxp/imxrt/imxrt10xx/lpm_rt1064.c b/soc/nxp/imxrt/imxrt10xx/lpm_rt1064.c\nindex c7cc46d0307..ad850f138f9 100644\n--- a/soc/nxp/imxrt/imxrt10xx/lpm_rt1064.c\n+++ b/soc/nxp/imxrt/imxrt10xx/lpm_rt1064.c\n@@ -339,7 +339,7 @@ void clock_lpm_init(void)\n \tXTALOSC24M->OSC_CONFIG1 = tmp_reg;\n }\n \n-static int imxrt_lpm_init(void)\n+void imxrt_lpm_init(void)\n {\n \n \tstruct clock_callbacks callbacks;\n@@ -464,8 +464,4 @@ static int imxrt_lpm_init(void)\n \n \t/* Install LPM callbacks */\n \timxrt_clock_pm_callbacks_register(&callbacks);\n-\treturn 0;\n }\n-\n-\n-SYS_INIT(imxrt_lpm_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nxp/imxrt/imxrt10xx/power.c b/soc/nxp/imxrt/imxrt10xx/power.c\nindex fac3180c0db..5936b70e02a 100644\n--- a/soc/nxp/imxrt/imxrt10xx/power.c\n+++ b/soc/nxp/imxrt/imxrt10xx/power.c\n@@ -240,7 +240,7 @@ void pm_state_exit_post_ops(enum pm_state state, uint8_t substate_id)\n }\n \n /* Initialize power system */\n-static int rt10xx_power_init(void)\n+void rt10xx_power_init(void)\n {\n \tdcdc_internal_regulator_config_t reg_config;\n \n@@ -268,9 +268,4 @@ static int rt10xx_power_init(void)\n \n \t/* Enable high gate drive on power FETs to reduce leakage current */\n \tPMU_CoreEnableIncreaseGateDrive(PMU, true);\n-\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(rt10xx_power_init, PRE_KERNEL_2, 0);\ndiff --git a/soc/nxp/imxrt/imxrt10xx/soc.c b/soc/nxp/imxrt/imxrt10xx/soc.c\nindex 9b197163567..d8a11dafd34 100644\n--- a/soc/nxp/imxrt/imxrt10xx/soc.c\n+++ b/soc/nxp/imxrt/imxrt10xx/soc.c\n@@ -332,25 +332,29 @@ void imxrt_audio_codec_pll_init(uint32_t clock_name, uint32_t clk_src,\n }\n #endif\n \n+extern void rt10xx_power_init(void);\n+extern void imxrt_lpm_init(void);\n+\n /**\n  *\n  * @brief Perform basic hardware initialization\n  *\n  * Initialize the interrupt controller device drivers.\n  * Also initialize the timer device driver, if required.\n- *\n- * @return 0\n  */\n-\n-static int imxrt_init(void)\n+void soc_early_init_hook(void)\n {\n \tsys_cache_instr_enable();\n \tsys_cache_data_enable();\n \n \t/* Initialize system clock */\n \tclock_init();\n-\n-\treturn 0;\n+#ifdef CONFIG_PM\n+#ifdef CONFIG_SOC_MIMXRT1064\n+\timxrt_lpm_init();\n+#endif\n+\trt10xx_power_init();\n+#endif\n }\n \n #ifdef CONFIG_SOC_RESET_HOOK\n@@ -365,5 +369,3 @@ void soc_reset_hook(void)\n #endif\n }\n #endif\n-\n-SYS_INIT(imxrt_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nxp/imxrt/imxrt118x/Kconfig b/soc/nxp/imxrt/imxrt118x/Kconfig\nindex 10c8180c300..8dc3afe19f9 100644\n--- a/soc/nxp/imxrt/imxrt118x/Kconfig\n+++ b/soc/nxp/imxrt/imxrt118x/Kconfig\n@@ -21,6 +21,7 @@ config SOC_SERIES_IMXRT118X\n \tselect HAS_MCUX_IOMUXC\n \tselect HAS_SWO\n \tselect HAS_MCUX_FLEXSPI\n+\tselect SOC_EARLY_INIT_HOOK\n \n config SOC_MIMXRT1189_CM33\n \tselect CPU_CORTEX_M33\ndiff --git a/soc/nxp/imxrt/imxrt118x/soc.c b/soc/nxp/imxrt/imxrt118x/soc.c\nindex 2576c858b9e..85299643de7 100644\n--- a/soc/nxp/imxrt/imxrt118x/soc.c\n+++ b/soc/nxp/imxrt/imxrt118x/soc.c\n@@ -394,7 +394,7 @@ static ALWAYS_INLINE void trdc_enable_all_access(void)\n  * @return 0\n  */\n \n-static int imxrt_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Initialize system clock */\n \tclock_init();\n@@ -409,8 +409,6 @@ static int imxrt_init(void)\n #endif\n \t__ISB();\n \t__DSB();\n-\n-\treturn 0;\n }\n \n #ifdef CONFIG_SOC_RESET_HOOK\n@@ -419,5 +417,3 @@ void soc_reset_hook(void)\n \tSystemInit();\n }\n #endif\n-\n-SYS_INIT(imxrt_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nxp/imxrt/imxrt5xx/Kconfig b/soc/nxp/imxrt/imxrt5xx/Kconfig\nindex dcaf50b03b1..81ccd78df6e 100644\n--- a/soc/nxp/imxrt/imxrt5xx/Kconfig\n+++ b/soc/nxp/imxrt/imxrt5xx/Kconfig\n@@ -31,6 +31,7 @@ config SOC_MIMXRT595S_CM33\n \tselect HAS_MCUX_USDHC2\n \tselect HAS_MCUX_USB_LPCIP3511\n \tselect HAS_MCUX_CTIMER\n+\tselect SOC_EARLY_INIT_HOOK\n \n config SOC_MIMXRT595S_F1\n \tselect XTENSA\ndiff --git a/soc/nxp/imxrt/imxrt5xx/cm33/power.c b/soc/nxp/imxrt/imxrt5xx/cm33/power.c\nindex 3599dcfa646..30911cbb22d 100644\n--- a/soc/nxp/imxrt/imxrt5xx/cm33/power.c\n+++ b/soc/nxp/imxrt/imxrt5xx/cm33/power.c\n@@ -61,10 +61,8 @@ void pm_state_exit_post_ops(enum pm_state state, uint8_t substate_id)\n }\n \n /* Initialize power system */\n-static int rt5xx_power_init(void)\n+void rt5xx_power_init(void)\n {\n-\tint ret = 0;\n-\n \t/* This function is called to set vddcore low voltage detection\n \t * falling trip voltage, this is not impacting the voltage in anyway.\n \t */\n@@ -75,7 +73,4 @@ static int rt5xx_power_init(void)\n \tPOWER_UpdatePmicRecoveryTime(1);\n #endif\n \n-\treturn ret;\n }\n-\n-SYS_INIT(rt5xx_power_init, PRE_KERNEL_2, 0);\ndiff --git a/soc/nxp/imxrt/imxrt5xx/cm33/soc.c b/soc/nxp/imxrt/imxrt5xx/cm33/soc.c\nindex c10b404ed48..f4371511e4e 100644\n--- a/soc/nxp/imxrt/imxrt5xx/cm33/soc.c\n+++ b/soc/nxp/imxrt/imxrt5xx/cm33/soc.c\n@@ -511,16 +511,16 @@ void __weak imxrt_deinit_display_interface(void)\n \n #endif\n \n+extern void rt5xx_power_init(void);\n+\n /**\n  *\n  * @brief Perform basic hardware initialization\n  *\n  * Initialize the interrupt controller device drivers.\n  * Also initialize the timer device driver, if required.\n- *\n- * @return 0\n  */\n-static int nxp_rt500_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Initialize clocks with tool generated code */\n \trt5xx_clock_init();\n@@ -536,8 +536,8 @@ static int nxp_rt500_init(void)\n \tIOPCTL->PIO[1][15] = 0;\n \tIOPCTL->PIO[3][28] = 0;\n \tIOPCTL->PIO[3][29] = 0;\n+#ifdef CONFIG_PM\n+\trt5xx_power_init();\n+#endif\n \n-\treturn 0;\n }\n-\n-SYS_INIT(nxp_rt500_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nxp/imxrt/imxrt6xx/Kconfig b/soc/nxp/imxrt/imxrt6xx/Kconfig\nindex b68855292e3..831b8b1b1ab 100644\n--- a/soc/nxp/imxrt/imxrt6xx/Kconfig\n+++ b/soc/nxp/imxrt/imxrt6xx/Kconfig\n@@ -30,6 +30,7 @@ config SOC_MIMXRT685S_CM33\n \tselect INIT_SYS_PLL\n \tselect HAS_MCUX_USB_LPCIP3511\n \tselect HAS_MCUX_CTIMER\n+\tselect SOC_EARLY_INIT_HOOK\n \n if SOC_SERIES_IMXRT6XX\n \ndiff --git a/soc/nxp/imxrt/imxrt6xx/cm33/soc.c b/soc/nxp/imxrt/imxrt6xx/cm33/soc.c\nindex d829558754e..9071a20bd68 100644\n--- a/soc/nxp/imxrt/imxrt6xx/cm33/soc.c\n+++ b/soc/nxp/imxrt/imxrt6xx/cm33/soc.c\n@@ -360,11 +360,9 @@ void imxrt_usdhc_dat3_pull(bool pullup)\n  *\n  * Initialize the interrupt controller device drivers.\n  * Also initialize the timer device driver, if required.\n- *\n- * @return 0\n  */\n \n-static int nxp_rt600_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Initialize clock */\n \tclock_init();\n@@ -372,8 +370,6 @@ static int nxp_rt600_init(void)\n #ifndef CONFIG_IMXRT6XX_CODE_CACHE\n \tCACHE64_DisableCache(CACHE64);\n #endif\n-\n-\treturn 0;\n }\n \n #ifdef CONFIG_SOC_RESET_HOOK\n@@ -400,5 +396,3 @@ void soc_reset_hook(void)\n }\n \n #endif\n-\n-SYS_INIT(nxp_rt600_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nxp/kinetis/k2x/Kconfig b/soc/nxp/kinetis/k2x/Kconfig\nindex cf61f57132b..f89d6c86b4c 100644\n--- a/soc/nxp/kinetis/k2x/Kconfig\n+++ b/soc/nxp/kinetis/k2x/Kconfig\n@@ -14,6 +14,7 @@ config SOC_SERIES_KINETIS_K2X\n \tselect CPU_CORTEX_M_HAS_DWT\n \tselect CLOCK_CONTROL\n \tselect SOC_RESET_HOOK\n+\tselect SOC_EARLY_INIT_HOOK\n \n config SOC_MK22F51212\n \tselect HAS_MCUX\ndiff --git a/soc/nxp/kinetis/k2x/soc.c b/soc/nxp/kinetis/k2x/soc.c\nindex 82aecf9b687..e89526f5556 100644\n--- a/soc/nxp/kinetis/k2x/soc.c\n+++ b/soc/nxp/kinetis/k2x/soc.c\n@@ -118,15 +118,13 @@ static ALWAYS_INLINE void clock_init(void)\n  * @return 0\n  */\n \n-static int fsl_frdm_k22f_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* release I/O power hold to allow normal run state */\n \tPMC->REGSC |= PMC_REGSC_ACKISO_MASK;\n \n \t/* Initialize PLL/system clock to 120 MHz */\n \tclock_init();\n-\n-\treturn 0;\n }\n \n #ifdef CONFIG_SOC_RESET_HOOK\n@@ -137,5 +135,3 @@ void soc_reset_hook(void)\n }\n \n #endif /* CONFIG_SOC_RESET_HOOK */\n-\n-SYS_INIT(fsl_frdm_k22f_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nxp/kinetis/k6x/Kconfig b/soc/nxp/kinetis/k6x/Kconfig\nindex 5ec9c9acf21..af342ae30ca 100644\n--- a/soc/nxp/kinetis/k6x/Kconfig\n+++ b/soc/nxp/kinetis/k6x/Kconfig\n@@ -11,6 +11,7 @@ config SOC_SERIES_KINETIS_K6X\n \tselect HAS_MCUX_PIT\n \tselect CLOCK_CONTROL\n \tselect SOC_RESET_HOOK\n+\tselect SOC_EARLY_INIT_HOOK\n \n config SOC_MK64F12\n \tselect HAS_MCUX\ndiff --git a/soc/nxp/kinetis/k6x/soc.c b/soc/nxp/kinetis/k6x/soc.c\nindex 41708af7954..c8eb6ba7870 100644\n--- a/soc/nxp/kinetis/k6x/soc.c\n+++ b/soc/nxp/kinetis/k6x/soc.c\n@@ -124,10 +124,9 @@ static ALWAYS_INLINE void clock_init(void)\n  * Initialize the interrupt controller device drivers.\n  * Also initialize the timer device driver, if required.\n  *\n- * @return 0\n  */\n \n-static int k6x_init(void)\n+void soc_early_init_hook(void)\n {\n #if !defined(CONFIG_ARM_MPU)\n \tuint32_t temp_reg;\n@@ -162,8 +161,6 @@ static int k6x_init(void)\n #endif\n \t/* Initialize PLL/system clock up to 180 MHz */\n \tclock_init();\n-\n-\treturn 0;\n }\n \n #ifdef CONFIG_SOC_RESET_HOOK\n@@ -174,5 +171,3 @@ void soc_reset_hook(void)\n }\n \n #endif /* CONFIG_SOC_RESET_HOOK */\n-\n-SYS_INIT(k6x_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nxp/kinetis/k8x/Kconfig b/soc/nxp/kinetis/k8x/Kconfig\nindex 649300c3dba..bf30d20797e 100644\n--- a/soc/nxp/kinetis/k8x/Kconfig\n+++ b/soc/nxp/kinetis/k8x/Kconfig\n@@ -27,6 +27,7 @@ config SOC_SERIES_KINETIS_K8X\n \tselect HAS_MCUX_RCM\n \tselect HAS_MCUX_CACHE\n \tselect SOC_RESET_HOOK\n+\tselect SOC_EARLY_INIT_HOOK\n \n if SOC_SERIES_KINETIS_K8X\n \ndiff --git a/soc/nxp/kinetis/k8x/soc.c b/soc/nxp/kinetis/k8x/soc.c\nindex 19d6f2df341..d338ad72a96 100644\n--- a/soc/nxp/kinetis/k8x/soc.c\n+++ b/soc/nxp/kinetis/k8x/soc.c\n@@ -92,7 +92,7 @@ static ALWAYS_INLINE void clk_init(void)\n #endif\n }\n \n-static int k8x_init(void)\n+void soc_early_init_hook(void)\n {\n #if !defined(CONFIG_ARM_MPU)\n \tuint32_t temp_reg;\n@@ -116,8 +116,6 @@ static int k8x_init(void)\n \n \t/* Initialize system clocks and PLL */\n \tclk_init();\n-\n-\treturn 0;\n }\n \n #ifdef CONFIG_SOC_RESET_HOOK\n@@ -128,5 +126,3 @@ void soc_reset_hook(void)\n }\n \n #endif /* CONFIG_SOC_RESET_HOOK */\n-\n-SYS_INIT(k8x_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nxp/kinetis/ke1xf/Kconfig b/soc/nxp/kinetis/ke1xf/Kconfig\nindex a89888edaad..b3cf86dd935 100644\n--- a/soc/nxp/kinetis/ke1xf/Kconfig\n+++ b/soc/nxp/kinetis/ke1xf/Kconfig\n@@ -30,6 +30,7 @@ config SOC_SERIES_KINETIS_KE1XF\n \tselect HAS_MCUX_PWT\n \tselect HAS_MCUX_RCM\n \tselect SOC_RESET_HOOK\n+\tselect SOC_EARLY_INIT_HOOK\n \tselect HAS_PM\n \n config SOC_MKE16F16\ndiff --git a/soc/nxp/kinetis/ke1xf/soc.c b/soc/nxp/kinetis/ke1xf/soc.c\nindex 7ada4249dfa..5d3e2291fe6 100644\n--- a/soc/nxp/kinetis/ke1xf/soc.c\n+++ b/soc/nxp/kinetis/ke1xf/soc.c\n@@ -237,7 +237,7 @@ static ALWAYS_INLINE void clk_init(void)\n #endif\n }\n \n-static int ke1xf_init(void)\n+void soc_early_init_hook(void)\n \n {\n #if !defined(CONFIG_ARM_MPU)\n@@ -264,8 +264,6 @@ static int ke1xf_init(void)\n \t/* SystemInit will have enabled the code cache. Disable it here */\n \tL1CACHE_DisableCodeCache();\n #endif\n-\n-\treturn 0;\n }\n \n #ifdef CONFIG_SOC_RESET_HOOK\n@@ -314,5 +312,3 @@ void soc_reset_hook(void)\n }\n \n #endif /* CONFIG_SOC_RESET_HOOK */\n-\n-SYS_INIT(ke1xf_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nxp/kinetis/ke1xz/Kconfig b/soc/nxp/kinetis/ke1xz/Kconfig\nindex 2563a220041..f8e878cb13a 100644\n--- a/soc/nxp/kinetis/ke1xz/Kconfig\n+++ b/soc/nxp/kinetis/ke1xz/Kconfig\n@@ -13,3 +13,4 @@ config SOC_SERIES_KE1XZ\n \tselect HAS_MCUX\n \tselect HAS_PM\n \tselect SOC_RESET_HOOK\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/nxp/kinetis/ke1xz/soc.c b/soc/nxp/kinetis/ke1xz/soc.c\nindex 38521bccc85..5a6b443c1fe 100644\n--- a/soc/nxp/kinetis/ke1xz/soc.c\n+++ b/soc/nxp/kinetis/ke1xz/soc.c\n@@ -144,13 +144,11 @@ static ALWAYS_INLINE void clk_init(void)\n #endif\n }\n \n-static int ke1xz_init(void)\n+void soc_early_init_hook(void)\n \n {\n \t/* Initialize system clocks and PLL */\n \tclk_init();\n-\n-\treturn 0;\n }\n \n #ifdef CONFIG_SOC_RESET_HOOK\n@@ -162,5 +160,3 @@ void soc_reset_hook(void)\n }\n \n #endif /* CONFIG_SOC_RESET_HOOK */\n-\n-SYS_INIT(ke1xz_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nxp/kinetis/kl2x/Kconfig b/soc/nxp/kinetis/kl2x/Kconfig\nindex c2e5255e00a..e545c2a6800 100644\n--- a/soc/nxp/kinetis/kl2x/Kconfig\n+++ b/soc/nxp/kinetis/kl2x/Kconfig\n@@ -10,6 +10,7 @@ config SOC_SERIES_KINETIS_KL2X\n \tselect CPU_CORTEX_M_HAS_VTOR\n \tselect CLOCK_CONTROL\n \tselect SOC_RESET_HOOK\n+\tselect SOC_EARLY_INIT_HOOK\n \n config SOC_MKL25Z4\n \tselect CPU_CORTEX_M0PLUS\ndiff --git a/soc/nxp/kinetis/kl2x/soc.c b/soc/nxp/kinetis/kl2x/soc.c\nindex 9a525b2632c..71fe3d35a35 100644\n--- a/soc/nxp/kinetis/kl2x/soc.c\n+++ b/soc/nxp/kinetis/kl2x/soc.c\n@@ -79,12 +79,10 @@ static ALWAYS_INLINE void clock_init(void)\n #endif\n }\n \n-static int kl2x_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Initialize system clock to 48 MHz */\n \tclock_init();\n-\n-\treturn 0;\n }\n \n #ifdef CONFIG_SOC_RESET_HOOK\n@@ -95,5 +93,3 @@ void soc_reset_hook(void)\n }\n \n #endif /* CONFIG_SOC_RESET_HOOK */\n-\n-SYS_INIT(kl2x_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nxp/kinetis/kv5x/Kconfig b/soc/nxp/kinetis/kv5x/Kconfig\nindex 6c9cd6f34ef..d4d977ce212 100644\n--- a/soc/nxp/kinetis/kv5x/Kconfig\n+++ b/soc/nxp/kinetis/kv5x/Kconfig\n@@ -22,3 +22,4 @@ config SOC_SERIES_KINETIS_KV5X\n \tselect HAS_MCG\n \tselect HAS_MCUX_RCM\n \tselect SOC_RESET_HOOK\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/nxp/kinetis/kv5x/soc.c b/soc/nxp/kinetis/kv5x/soc.c\nindex 91c4823e4e2..cd5d4048c42 100644\n--- a/soc/nxp/kinetis/kv5x/soc.c\n+++ b/soc/nxp/kinetis/kv5x/soc.c\n@@ -78,7 +78,7 @@ static ALWAYS_INLINE void clk_init(void)\n \tCLOCK_SetSimConfig(&sim_config);\n }\n \n-static int kv5x_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* release I/O power hold to allow normal run state */\n \tPMC->REGSC |= PMC_REGSC_ACKISO_MASK;\n@@ -93,8 +93,6 @@ static int kv5x_init(void)\n \n \tsys_cache_instr_enable();\n \tsys_cache_data_enable();\n-\n-\treturn 0;\n }\n \n #ifdef CONFIG_SOC_RESET_HOOK\n@@ -105,5 +103,3 @@ void soc_reset_hook(void)\n }\n \n #endif /* CONFIG_SOC_RESET_HOOK */\n-\n-SYS_INIT(kv5x_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nxp/kinetis/kwx/Kconfig b/soc/nxp/kinetis/kwx/Kconfig\nindex 49a9f78c04b..150de248d4e 100644\n--- a/soc/nxp/kinetis/kwx/Kconfig\n+++ b/soc/nxp/kinetis/kwx/Kconfig\n@@ -9,6 +9,7 @@ config SOC_SERIES_KINETIS_KWX\n \tselect CPU_CORTEX_M_HAS_VTOR\n \tselect CLOCK_CONTROL\n \tselect SOC_RESET_HOOK\n+\tselect SOC_EARLY_INIT_HOOK\n \n config SOC_MKW22D5\n \tselect CPU_CORTEX_M4\ndiff --git a/soc/nxp/kinetis/kwx/soc_kw2xd.c b/soc/nxp/kinetis/kwx/soc_kw2xd.c\nindex 95e5a955acc..c2fcddfa6ed 100644\n--- a/soc/nxp/kinetis/kwx/soc_kw2xd.c\n+++ b/soc/nxp/kinetis/kwx/soc_kw2xd.c\n@@ -147,15 +147,13 @@ static ALWAYS_INLINE void clock_init(void)\n  *\n  * @return 0\n  */\n-static int kw2xd_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* release I/O power hold to allow normal run state */\n \tPMC->REGSC |= PMC_REGSC_ACKISO_MASK;\n \n \t/* Initialize PLL/system clock to 48 MHz */\n \tclock_init();\n-\n-\treturn 0;\n }\n \n #ifdef CONFIG_SOC_RESET_HOOK\n@@ -166,5 +164,3 @@ void soc_reset_hook(void)\n }\n \n #endif /* CONFIG_SOC_RESET_HOOK */\n-\n-SYS_INIT(kw2xd_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nxp/kinetis/kwx/soc_kw4xz.c b/soc/nxp/kinetis/kwx/soc_kw4xz.c\nindex a14fe28c165..4e33f4df5b8 100644\n--- a/soc/nxp/kinetis/kwx/soc_kw4xz.c\n+++ b/soc/nxp/kinetis/kwx/soc_kw4xz.c\n@@ -79,12 +79,10 @@ static ALWAYS_INLINE void clock_init(void)\n #endif\n }\n \n-static int kwx_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Initialize system clock to 40 MHz */\n \tclock_init();\n-\n-\treturn 0;\n }\n \n #ifdef CONFIG_SOC_RESET_HOOK\n@@ -95,5 +93,3 @@ void soc_reset_hook(void)\n }\n \n #endif /* CONFIG_SOC_RESET_HOOK */\n-\n-SYS_INIT(kwx_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nxp/lpc/lpc51u68/Kconfig b/soc/nxp/lpc/lpc51u68/Kconfig\nindex 8a2436d1237..37c8231d7f6 100644\n--- a/soc/nxp/lpc/lpc51u68/Kconfig\n+++ b/soc/nxp/lpc/lpc51u68/Kconfig\n@@ -16,6 +16,7 @@ config SOC_SERIES_LPC51U68\n \tselect CPU_CORTEX_M_HAS_SYSTICK\n \tselect CPU_CORTEX_M_HAS_VTOR\n \tselect SOC_RESET_HOOK\n+\tselect SOC_EARLY_INIT_HOOK\n \n config SOC_LPC51U68\n \tselect CLOCK_CONTROL\ndiff --git a/soc/nxp/lpc/lpc51u68/soc.c b/soc/nxp/lpc/lpc51u68/soc.c\nindex b38b601baaa..fd8f23800b3 100644\n--- a/soc/nxp/lpc/lpc51u68/soc.c\n+++ b/soc/nxp/lpc/lpc51u68/soc.c\n@@ -11,7 +11,7 @@\n #include <fsl_power.h>\n #include <fsl_clock.h>\n \n-int soc_init(void)\n+void soc_early_init_hook(void)\n {\n \tPOWER_DisablePD(kPDRUNCFG_PD_FRO_EN);\n \tCLOCK_SetupFROClocking(12000000U);\n@@ -42,17 +42,11 @@ int soc_init(void)\n \tPOWER_DisablePD(kPDRUNCFG_PD_VD7_ENA);\n \tPOWER_DisablePD(kPDRUNCFG_PD_VREFP_SW);\n \tPOWER_DisablePD(kPDRUNCFG_PD_TEMPS);\n-\n-\treturn 0;\n }\n \n #ifdef CONFIG_SOC_RESET_HOOK\n-\n void soc_reset_hook(void)\n {\n \tSystemInit();\n }\n-\n #endif /* CONFIG_SOC_RESET_HOOK */\n-\n-SYS_INIT(soc_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nxp/mcx/mcxc/Kconfig b/soc/nxp/mcx/mcxc/Kconfig\nindex 02ed4233bc0..ff49d66ae65 100644\n--- a/soc/nxp/mcx/mcxc/Kconfig\n+++ b/soc/nxp/mcx/mcxc/Kconfig\n@@ -16,6 +16,7 @@ config SOC_SERIES_MCXC\n \tselect HAS_MCUX_LPUART\n \tselect HAS_MCUX_LPI2C\n \tselect HAS_MCUX_TPM\n+\tselect SOC_EARLY_INIT_HOOK\n \n if SOC_SERIES_MCXC\n \ndiff --git a/soc/nxp/mcx/mcxc/soc.c b/soc/nxp/mcx/mcxc/soc.c\nindex 0e12cf2e14b..1f4762e202a 100644\n--- a/soc/nxp/mcx/mcxc/soc.c\n+++ b/soc/nxp/mcx/mcxc/soc.c\n@@ -107,10 +107,9 @@ static void clock_init(void)\n #endif\n }\n \n-static int mcxc_init(void)\n+void soc_early_init_hook(void)\n {\n \tclock_init();\n-\treturn 0;\n }\n \n #ifdef CONFIG_SOC_RESET_HOOK\n@@ -121,5 +120,3 @@ void soc_reset_hook(void)\n }\n \n #endif /* CONFIG_SOC_RESET_HOOK */\n-\n-SYS_INIT(mcxc_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nxp/rw/Kconfig b/soc/nxp/rw/Kconfig\nindex e67d0013721..272d7073bfa 100644\n--- a/soc/nxp/rw/Kconfig\n+++ b/soc/nxp/rw/Kconfig\n@@ -17,6 +17,7 @@ config SOC_SERIES_RW6XX\n \tselect HAS_MCUX_FLEXCOMM\n \tselect HAS_MCUX_CACHE\n \tselect HAS_PM\n+\tselect SOC_EARLY_INIT_HOOK\n \n if SOC_SERIES_RW6XX\n \ndiff --git a/soc/nxp/rw/power.c b/soc/nxp/rw/power.c\nindex 2979d48ff5b..1f0255a388f 100644\n--- a/soc/nxp/rw/power.c\n+++ b/soc/nxp/rw/power.c\n@@ -109,7 +109,7 @@ __weak void pm_state_exit_post_ops(enum pm_state state, uint8_t substate_id)\n \t__enable_irq();\n }\n \n-static int nxp_rw6xx_power_init(void)\n+void nxp_rw6xx_power_init(void)\n {\n \tuint32_t suspend_sleepconfig[5] = DT_PROP_OR(NODE_ID, deep_sleep_config, {});\n \n@@ -142,8 +142,4 @@ static int nxp_rw6xx_power_init(void)\n \tIRQ_CONNECT(DT_IRQN(DT_NODELABEL(pin1)), DT_IRQ(DT_NODELABEL(pin1), priority), pin1_isr,\n \t\t    NULL, 0);\n #endif\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(nxp_rw6xx_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/nxp/rw/soc.c b/soc/nxp/rw/soc.c\nindex 8aa3d6f6dee..1a52626a053 100644\n--- a/soc/nxp/rw/soc.c\n+++ b/soc/nxp/rw/soc.c\n@@ -268,17 +268,16 @@ __ramfunc void clock_init(void)\n \n }\n \n+extern void nxp_rw6xx_power_init(void);\n /**\n  *\n  * @brief Perform basic hardware initialization\n  *\n  * Initialize the interrupt controller device drivers.\n  * Also initialize the timer device driver, if required.\n- *\n- * @return 0\n  */\n \n-static int nxp_rw600_init(void)\n+void soc_early_init_hook(void)\n {\n #if (DT_NODE_HAS_COMPAT_STATUS(DT_NODELABEL(wwdt), nxp_lpc_wwdt, okay))\n \tPOWER_EnableResetSource(kPOWER_ResetSourceWdt);\n@@ -305,8 +304,9 @@ static int nxp_rw600_init(void)\n #if defined(CONFIG_ADC_MCUX_GAU) ||  defined(CONFIG_DAC_MCUX_GAU)\n \tPOWER_PowerOnGau();\n #endif\n-\n-\treturn 0;\n+#if CONFIG_PM\n+\tnxp_rw6xx_power_init();\n+#endif\n }\n \n void soc_reset_hook(void)\n@@ -314,5 +314,3 @@ void soc_reset_hook(void)\n \t/* This is provided by the SDK */\n \tSystemInit();\n }\n-\n-SYS_INIT(nxp_rw600_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nxp/s32/s32k1/Kconfig b/soc/nxp/s32/s32k1/Kconfig\nindex 0883614c82b..2bb3a271904 100644\n--- a/soc/nxp/s32/s32k1/Kconfig\n+++ b/soc/nxp/s32/s32k1/Kconfig\n@@ -19,6 +19,7 @@ config SOC_SERIES_S32K1\n \tselect HAS_MCUX_WDOG32\n \tselect HAS_MCUX_RTC\n \tselect HAS_MCUX_ADC12\n+\tselect SOC_EARLY_INIT_HOOK\n \n config SOC_S32K116\n \tselect CPU_CORTEX_M0PLUS\ndiff --git a/soc/nxp/s32/s32k1/soc.c b/soc/nxp/s32/s32k1/soc.c\nindex 20a27eb13c0..484838cf68c 100644\n--- a/soc/nxp/s32/s32k1/soc.c\n+++ b/soc/nxp/s32/s32k1/soc.c\n@@ -48,7 +48,7 @@ void z_arm_watchdog_init(void)\n }\n #endif /* CONFIG_WDOG_INIT */\n \n-static int soc_init(void)\n+void soc_early_init_hook(void)\n {\n #if !defined(CONFIG_ARM_MPU)\n \tuint32_t tmp;\n@@ -71,8 +71,4 @@ static int soc_init(void)\n #endif\n \n \tOsIf_Init(NULL);\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(soc_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nxp/s32/s32k3/Kconfig b/soc/nxp/s32/s32k3/Kconfig\nindex fdf0bba2687..627898f7231 100644\n--- a/soc/nxp/s32/s32k3/Kconfig\n+++ b/soc/nxp/s32/s32k3/Kconfig\n@@ -22,6 +22,7 @@ config SOC_SERIES_S32K3\n \tselect HAS_MCUX_LPSPI\n \tselect HAS_MCUX_CACHE\n \tselect HAS_MCUX_EDMA\n+\tselect SOC_EARLY_INIT_HOOK\n \n if SOC_SERIES_S32K3\n \ndiff --git a/soc/nxp/s32/s32k3/soc.c b/soc/nxp/s32/s32k3/soc.c\nindex be822677189..e2ecba3c6fb 100644\n--- a/soc/nxp/s32/s32k3/soc.c\n+++ b/soc/nxp/s32/s32k3/soc.c\n@@ -49,14 +49,10 @@ const struct ivt ivt_header __attribute__((section(\".ivt_header\"))) = {\n };\n #endif /* CONFIG_XIP */\n \n-static int soc_init(void)\n+void soc_early_init_hook(void)\n {\n \tsys_cache_instr_enable();\n \tsys_cache_data_enable();\n \n \tOsIf_Init(NULL);\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(soc_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nxp/s32/s32ze/Kconfig b/soc/nxp/s32/s32ze/Kconfig\nindex 8c9041a2fe3..9ee9aaa1429 100644\n--- a/soc/nxp/s32/s32ze/Kconfig\n+++ b/soc/nxp/s32/s32ze/Kconfig\n@@ -18,6 +18,7 @@ config SOC_SERIES_S32ZE\n \tselect HAS_MCUX_PIT\n \tselect HAS_MCUX_FLEXCAN\n \tselect HAS_MCUX_LPI2C\n+\tselect SOC_EARLY_INIT_HOOK\n \n if SOC_SERIES_S32ZE\n \ndiff --git a/soc/nxp/s32/s32ze/soc.c b/soc/nxp/s32/s32ze/soc.c\nindex 801e0173ae3..da05a2085b7 100644\n--- a/soc/nxp/s32/s32ze/soc.c\n+++ b/soc/nxp/s32/s32ze/soc.c\n@@ -44,11 +44,7 @@ void soc_reset_hook(void)\n \t}\n }\n \n-static int soc_init(void)\n+void soc_early_init_hook(void)\n {\n \tOsIf_Init(NULL);\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(soc_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);"
},{
  "instruction": "soc: nuvoton: move init code from SYS_INIT to hooks",
  "input": "zephyr_sources(\n soc.c\n)\n/*\n* Copyright (c) 2024 Nuvoton Technology Corporation.\n*\n* SPDX-License-Identifier: Apache-2.0\n*/\n#include <zephyr/kernel.h>\n#include <zephyr/device.h>\n#include <zephyr/init.h>\n#include <soc.h>\n#include <zephyr/logging/log.h>\nLOG_MODULE_REGISTER(soc, CONFIG_SOC_LOG_LEVEL);\nstatic int soc_npcm4_init(void)\n{\n\treturn 0;\n}\nSYS_INIT(soc_npcm4_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\nstatic int npcx_scfg_init(void)\n\treturn 0;\nSYS_INIT(npcx_scfg_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\nstatic int soc_npcx4_init(void)\n\treturn 0;\nSYS_INIT(soc_npcx4_init, PRE_KERNEL_1, 0);\nstatic int soc_npcx7_init(void)\n\treturn 0;\nSYS_INIT(soc_npcx7_init, PRE_KERNEL_1, 0);\nstatic int soc_npcx9_init(void)\n\treturn 0;\nSYS_INIT(soc_npcx9_init, PRE_KERNEL_1, 0);",
  "result": "diff --git a/soc/nuvoton/npcm/npcm4/CMakeLists.txt b/soc/nuvoton/npcm/npcm4/CMakeLists.txt\nindex 9a246a41b34..37767af77fb 100644\n--- a/soc/nuvoton/npcm/npcm4/CMakeLists.txt\n+++ b/soc/nuvoton/npcm/npcm4/CMakeLists.txt\n@@ -8,8 +8,4 @@ zephyr_include_directories(\n   ${ZEPHYR_BASE}/drivers\n )\n \n-zephyr_sources(\n-  soc.c\n-)\n-\n set(SOC_LINKER_SCRIPT ${ZEPHYR_BASE}/include/zephyr/arch/arm/cortex_m/scripts/linker.ld CACHE INTERNAL \"\")\ndiff --git a/soc/nuvoton/npcm/npcm4/soc.c b/soc/nuvoton/npcm/npcm4/soc.c\ndeleted file mode 100644\nindex 42536543233..00000000000\n--- a/soc/nuvoton/npcm/npcm4/soc.c\n+++ /dev/null\n@@ -1,20 +0,0 @@\n-/*\n- * Copyright (c) 2024 Nuvoton Technology Corporation.\n- *\n- * SPDX-License-Identifier: Apache-2.0\n- */\n-\n-#include <zephyr/kernel.h>\n-#include <zephyr/device.h>\n-#include <zephyr/init.h>\n-#include <soc.h>\n-#include <zephyr/logging/log.h>\n-\n-LOG_MODULE_REGISTER(soc, CONFIG_SOC_LOG_LEVEL);\n-\n-static int soc_npcm4_init(void)\n-{\n-\treturn 0;\n-}\n-\n-SYS_INIT(soc_npcm4_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/nuvoton/npcx/common/scfg.c b/soc/nuvoton/npcx/common/scfg.c\nindex 6dac027cb2e..cb552e7ead1 100644\n--- a/soc/nuvoton/npcx/common/scfg.c\n+++ b/soc/nuvoton/npcx/common/scfg.c\n@@ -143,7 +143,7 @@ void npcx_dbg_freeze_enable(bool enable)\n }\n \n /* Pin-control driver registration */\n-static int npcx_scfg_init(void)\n+void scfg_init(void)\n {\n \t/* If booter doesn't set the host interface type */\n \tif (!NPCX_BOOTER_IS_HIF_TYPE_SET()) {\n@@ -154,8 +154,4 @@ static int npcx_scfg_init(void)\n \tfor (int i = 0; i < ARRAY_SIZE(def_alts); i++) {\n \t\tnpcx_pinctrl_alt_sel(&def_alts[i], 0);\n \t}\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(npcx_scfg_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/nuvoton/npcx/npcx4/Kconfig b/soc/nuvoton/npcx/npcx4/Kconfig\nindex 0983b7c7eff..795ee55c865 100644\n--- a/soc/nuvoton/npcx/npcx4/Kconfig\n+++ b/soc/nuvoton/npcx/npcx4/Kconfig\n@@ -10,3 +10,4 @@ config SOC_SERIES_NPCX4\n \tselect CPU_HAS_FPU\n \tselect CPU_HAS_ARM_MPU\n \tselect HAS_PM\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/nuvoton/npcx/npcx4/soc.c b/soc/nuvoton/npcx/npcx4/soc.c\nindex 28b868bda65..b6137292961 100644\n--- a/soc/nuvoton/npcx/npcx4/soc.c\n+++ b/soc/nuvoton/npcx/npcx4/soc.c\n@@ -18,7 +18,8 @@ static uintptr_t fiu_insts[] = {\n \tDT_FOREACH_STATUS_OKAY(nuvoton_npcx_fiu_qspi, NPCX_FIU_INST_INIT)\n };\n \n-static int soc_npcx4_init(void)\n+extern void scfg_init(void);\n+void soc_early_init_hook(void)\n {\n \t/*\n \t * Make sure UMA_ADDR_SIZE field of UMA_ECTS register is zero in npcx4\n@@ -29,8 +30,5 @@ static int soc_npcx4_init(void)\n \n \t\tSET_FIELD(inst->UMA_ECTS, NPCX_UMA_ECTS_UMA_ADDR_SIZE, 0);\n \t}\n-\n-\treturn 0;\n+\tscfg_init();\n }\n-\n-SYS_INIT(soc_npcx4_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nuvoton/npcx/npcx7/Kconfig b/soc/nuvoton/npcx/npcx7/Kconfig\nindex 55e5a1c50c0..7387e0b491f 100644\n--- a/soc/nuvoton/npcx/npcx7/Kconfig\n+++ b/soc/nuvoton/npcx/npcx7/Kconfig\n@@ -11,3 +11,4 @@ config SOC_SERIES_NPCX7\n \tselect CPU_HAS_ARM_MPU\n \tselect CPU_HAS_CUSTOM_FIXED_SOC_MPU_REGIONS\n \tselect HAS_PM\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/nuvoton/npcx/npcx7/soc.c b/soc/nuvoton/npcx/npcx7/soc.c\nindex ae892a7d166..0a550c7f323 100644\n--- a/soc/nuvoton/npcx/npcx7/soc.c\n+++ b/soc/nuvoton/npcx/npcx7/soc.c\n@@ -12,7 +12,8 @@\n \n LOG_MODULE_REGISTER(soc, CONFIG_SOC_LOG_LEVEL);\n \n-static int soc_npcx7_init(void)\n+extern void scfg_init(void);\n+void soc_early_init_hook(void)\n {\n \tstruct scfg_reg *inst_scfg = (struct scfg_reg *)\n \t\t\tDT_REG_ADDR_BY_NAME(DT_NODELABEL(scfg), scfg);\n@@ -22,8 +23,5 @@ static int soc_npcx7_init(void)\n \t * for more information. It will be fixed in next chip.\n \t */\n \tinst_scfg->DEVCNT |= BIT(7);\n-\n-\treturn 0;\n+\tscfg_init();\n }\n-\n-SYS_INIT(soc_npcx7_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/nuvoton/npcx/npcx9/Kconfig b/soc/nuvoton/npcx/npcx9/Kconfig\nindex dd93a355e93..44b64446f0e 100644\n--- a/soc/nuvoton/npcx/npcx9/Kconfig\n+++ b/soc/nuvoton/npcx/npcx9/Kconfig\n@@ -11,6 +11,7 @@ config SOC_SERIES_NPCX9\n \tselect CPU_HAS_ARM_MPU\n \tselect SOC_FAMILY_NPCX\n \tselect HAS_PM\n+\tselect SOC_EARLY_INIT_HOOK\n \n config NPCX_VCC1_RST_HANG_WORKAROUND\n \tbool\ndiff --git a/soc/nuvoton/npcx/npcx9/soc.c b/soc/nuvoton/npcx/npcx9/soc.c\nindex a1427a84088..99144ce904c 100644\n--- a/soc/nuvoton/npcx/npcx9/soc.c\n+++ b/soc/nuvoton/npcx/npcx9/soc.c\n@@ -12,7 +12,8 @@\n \n LOG_MODULE_REGISTER(soc, CONFIG_SOC_LOG_LEVEL);\n \n-static int soc_npcx9_init(void)\n+extern void scfg_init(void);\n+void soc_early_init_hook(void)\n {\n \tif (IS_ENABLED(CONFIG_NPCX_VCC1_RST_HANG_WORKAROUND)) {\n \t\tuintptr_t scfg_base = DT_REG_ADDR_BY_NAME(DT_NODELABEL(scfg), scfg);\n@@ -20,8 +21,5 @@ static int soc_npcx9_init(void)\n \t\tSET_FIELD(NPCX_JEN_CTL1(scfg_base), NPCX_JEN_CTL1_JEN_HEN,\n \t\t\t  NPCX_JEN_CTL1_JEN_DISABLE);\n \t}\n-\n-\treturn 0;\n+\tscfg_init();\n }\n-\n-SYS_INIT(soc_npcx9_init, PRE_KERNEL_1, 0);"
},{
  "instruction": "soc: microchip: move init code from SYS_INIT to hooks",
  "input": "static int soc_init(void)\n\treturn 0;\nSYS_INIT(soc_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\nstatic int soc_init(void)\n\treturn 0;\nSYS_INIT(soc_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\nstatic int soc_init(void)\n\treturn 0;\n/* Enabling HW debug and initializing the MEC interrupt aggregator should be done\n* before driver are loaded to not overwrite driver interrupt configuration.\n* Use early initialization category called soon after Zephyr z_cstart and before\n* Zephyr starts making driver initialization calls.\n*/\nSYS_INIT(soc_init, EARLY, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\nstatic int soc_init(void)\n\treturn 0;\n/* Enabling HW debug and initializing the MEC interrupt aggregator should be done\n* before driver are loaded to not overwrite driver interrupt configuration.\n* Use early initialization category called soon after Zephyr z_cstart and before\n* Zephyr starts making driver initialization calls.\n*/\nSYS_INIT(soc_init, EARLY, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\nstatic int soc_init(void)\n\treturn 0;\n/* Enabling HW debug and initializing the MEC interrupt aggregator should be done\n* before driver are loaded to not overwrite driver interrupt configuration.\n* Use early initialization category called soon after Zephyr z_cstart and before\n* Zephyr starts making driver initialization calls.\n*/\nSYS_INIT(soc_init, EARLY, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);",
  "result": "diff --git a/soc/microchip/mec/mec15xx/Kconfig b/soc/microchip/mec/mec15xx/Kconfig\nindex d00e938a6d1..510fbd898ea 100644\n--- a/soc/microchip/mec/mec15xx/Kconfig\n+++ b/soc/microchip/mec/mec15xx/Kconfig\n@@ -9,6 +9,7 @@ config SOC_SERIES_MEC15XX\n \tselect CPU_CORTEX_M_HAS_DWT\n \tselect CPU_HAS_ARM_MPU\n \tselect HAS_PM\n+\tselect SOC_EARLY_INIT_HOOK\n \n config SOC_MEC1501_HSZ\n \tselect HAS_MEC_HAL\ndiff --git a/soc/microchip/mec/mec15xx/soc.c b/soc/microchip/mec/mec15xx/soc.c\nindex 27fd059c339..df21dde363e 100644\n--- a/soc/microchip/mec/mec15xx/soc.c\n+++ b/soc/microchip/mec/mec15xx/soc.c\n@@ -71,7 +71,7 @@ static void configure_debug_interface(void)\n #endif /* CONFIG_SOC_MEC1501_DEBUG_WITHOUT_TRACING */\n }\n \n-static int soc_init(void)\n+void soc_early_init_hook(void)\n {\n \tuint32_t isave;\n \n@@ -94,8 +94,4 @@ static int soc_init(void)\n \tif (!isave) {\n \t\t__enable_irq();\n \t}\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(soc_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/microchip/mec/mec172x/Kconfig b/soc/microchip/mec/mec172x/Kconfig\nindex c529d83fc31..85f579ec776 100644\n--- a/soc/microchip/mec/mec172x/Kconfig\n+++ b/soc/microchip/mec/mec172x/Kconfig\n@@ -11,6 +11,7 @@ config SOC_SERIES_MEC172X\n \tselect CPU_HAS_ARM_MPU\n \tselect HAS_SWO\n \tselect HAS_PM\n+\tselect SOC_EARLY_INIT_HOOK\n \n if SOC_SERIES_MEC172X\n \ndiff --git a/soc/microchip/mec/mec172x/soc.c b/soc/microchip/mec/mec172x/soc.c\nindex 9de2f7ce552..6b000f957b0 100644\n--- a/soc/microchip/mec/mec172x/soc.c\n+++ b/soc/microchip/mec/mec172x/soc.c\n@@ -38,12 +38,8 @@ static void configure_debug_interface(void)\n #endif /* CONFIG_SOC_MEC172X_DEBUG_DISABLED */\n }\n \n-static int soc_init(void)\n+void soc_early_init_hook(void)\n {\n \n \tconfigure_debug_interface();\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(soc_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/microchip/mec/mec174x/Kconfig b/soc/microchip/mec/mec174x/Kconfig\nindex 52eb412941a..eeb77525d72 100644\n--- a/soc/microchip/mec/mec174x/Kconfig\n+++ b/soc/microchip/mec/mec174x/Kconfig\n@@ -12,6 +12,7 @@ config SOC_SERIES_MEC174X\n \tselect HAS_SWO\n \tselect HAS_MEC5_HAL\n \tselect HAS_PM\n+\tselect SOC_PREP_HOOK\n \n if SOC_SERIES_MEC174X\n \ndiff --git a/soc/microchip/mec/mec174x/soc.c b/soc/microchip/mec/mec174x/soc.c\nindex 6d7a502b082..f4d0db790d6 100644\n--- a/soc/microchip/mec/mec174x/soc.c\n+++ b/soc/microchip/mec/mec174x/soc.c\n@@ -10,15 +10,7 @@\n #include <soc.h>\n #include <soc_cmn_init.h>\n \n-static int soc_init(void)\n+void soc_prep_hook(void)\n {\n \tmec5_soc_common_init();\n-\treturn 0;\n }\n-\n-/* Enabling HW debug and initializing the MEC interrupt aggregator should be done\n- * before driver are loaded to not overwrite driver interrupt configuration.\n- * Use early initialization category called soon after Zephyr z_cstart and before\n- * Zephyr starts making driver initialization calls.\n- */\n-SYS_INIT(soc_init, EARLY, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/microchip/mec/mec175x/Kconfig b/soc/microchip/mec/mec175x/Kconfig\nindex 1cce7ce0e2b..5670fe72540 100644\n--- a/soc/microchip/mec/mec175x/Kconfig\n+++ b/soc/microchip/mec/mec175x/Kconfig\n@@ -12,6 +12,7 @@ config SOC_SERIES_MEC175X\n \tselect HAS_SWO\n \tselect HAS_MEC5_HAL\n \tselect HAS_PM\n+\tselect SOC_PREP_HOOK\n \n if SOC_SERIES_MEC175X\n \ndiff --git a/soc/microchip/mec/mec175x/soc.c b/soc/microchip/mec/mec175x/soc.c\nindex 6d7a502b082..f4d0db790d6 100644\n--- a/soc/microchip/mec/mec175x/soc.c\n+++ b/soc/microchip/mec/mec175x/soc.c\n@@ -10,15 +10,7 @@\n #include <soc.h>\n #include <soc_cmn_init.h>\n \n-static int soc_init(void)\n+void soc_prep_hook(void)\n {\n \tmec5_soc_common_init();\n-\treturn 0;\n }\n-\n-/* Enabling HW debug and initializing the MEC interrupt aggregator should be done\n- * before driver are loaded to not overwrite driver interrupt configuration.\n- * Use early initialization category called soon after Zephyr z_cstart and before\n- * Zephyr starts making driver initialization calls.\n- */\n-SYS_INIT(soc_init, EARLY, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/microchip/mec/mech172x/Kconfig b/soc/microchip/mec/mech172x/Kconfig\nindex 0bc04fbed20..d58d267e9cc 100644\n--- a/soc/microchip/mec/mech172x/Kconfig\n+++ b/soc/microchip/mec/mech172x/Kconfig\n@@ -12,6 +12,7 @@ config SOC_SERIES_MECH172X\n \tselect HAS_SWO\n \tselect HAS_MEC5_HAL\n \tselect HAS_PM\n+\tselect SOC_PREP_HOOK\n \n if SOC_SERIES_MECH172X\n \ndiff --git a/soc/microchip/mec/mech172x/soc.c b/soc/microchip/mec/mech172x/soc.c\nindex 6d7a502b082..f4d0db790d6 100644\n--- a/soc/microchip/mec/mech172x/soc.c\n+++ b/soc/microchip/mec/mech172x/soc.c\n@@ -10,15 +10,7 @@\n #include <soc.h>\n #include <soc_cmn_init.h>\n \n-static int soc_init(void)\n+void soc_prep_hook(void)\n {\n \tmec5_soc_common_init();\n-\treturn 0;\n }\n-\n-/* Enabling HW debug and initializing the MEC interrupt aggregator should be done\n- * before driver are loaded to not overwrite driver interrupt configuration.\n- * Use early initialization category called soon after Zephyr z_cstart and before\n- * Zephyr starts making driver initialization calls.\n- */\n-SYS_INIT(soc_init, EARLY, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);"
},{
  "instruction": "soc: lowrisc: move init code from SYS_INIT to hooks",
  "input": "static int soc_opentitan_init(void)\n\treturn 0;\nSYS_INIT(soc_opentitan_init, PRE_KERNEL_1, 0);",
  "result": "diff --git a/soc/lowrisc/opentitan/Kconfig b/soc/lowrisc/opentitan/Kconfig\nindex e4a6082cc5b..36662709cce 100644\n--- a/soc/lowrisc/opentitan/Kconfig\n+++ b/soc/lowrisc/opentitan/Kconfig\n@@ -20,3 +20,4 @@ config SOC_OPENTITAN\n \tselect RISCV_VECTORED_MODE\n \tselect GEN_IRQ_VECTOR_TABLE\n \timply XIP\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/lowrisc/opentitan/soc.c b/soc/lowrisc/opentitan/soc.c\nindex d627356c58f..79990d90493 100644\n--- a/soc/lowrisc/opentitan/soc.c\n+++ b/soc/lowrisc/opentitan/soc.c\n@@ -26,7 +26,7 @@\n #define RV_TIMER_LOWER0_OFFSET          0x110\n #define RV_TIMER_COMPARE_LOWER0_OFFSET  0x118\n \n-static int soc_opentitan_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Enable the watchdog reset (bit 1). */\n \tsys_write32(2u, PWRMGR_BASE + PWRMGR_RESET_EN_REG_OFFSET);\n@@ -40,6 +40,4 @@ static int soc_opentitan_init(void)\n \tsys_write32(1u, RV_TIMER_BASE + RV_TIMER_CTRL_REG_OFFSET);\n \t/* Enable timer interrupts. */\n \tsys_write32(1u, RV_TIMER_BASE + RV_TIMER_INTR_ENABLE_REG_OFFSET);\n-\treturn 0;\n }\n-SYS_INIT(soc_opentitan_init, PRE_KERNEL_1, 0);"
},{
  "instruction": "soc: intel: move init code from SYS_INIT to hooks",
  "input": "static int host_runtime_get(void)\n\treturn pm_device_runtime_get(INTEL_ADSP_HST_DOMAIN_DEV);\nSYS_INIT(host_runtime_get, POST_KERNEL, 99);\nSYS_INIT(boot_complete, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE);\nstatic __imr int soc_init(void)\n\treturn 0;\nSYS_INIT(soc_init, PRE_KERNEL_1, 99);\nstatic int ish_sedi_pm_init(void)\n\treturn 0;\nSYS_INIT(ish_sedi_pm_init, PRE_KERNEL_2, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\nstatic int intel_ish_init(void)\n\treturn 0;\nSYS_INIT(intel_ish_init, PRE_KERNEL_2, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\nstatic int soc_intel_cyclonev_init(void)\n\treturn 0;\nSYS_INIT(soc_intel_cyclonev_init, PRE_KERNEL_1,\n\tCONFIG_KERNEL_INIT_PRIORITY_DEFAULT);",
  "result": "diff --git a/soc/intel/intel_adsp/ace/Kconfig b/soc/intel/intel_adsp/ace/Kconfig\nindex e38ebdeb9c5..af4f25171de 100644\n--- a/soc/intel/intel_adsp/ace/Kconfig\n+++ b/soc/intel/intel_adsp/ace/Kconfig\n@@ -15,6 +15,8 @@ config SOC_SERIES_INTEL_ADSP_ACE\n \tselect XTENSA_CPU_HAS_HIFI3\n \tselect XTENSA_CPU_HAS_HIFI4\n \tselect ARCH_HAS_RESERVED_PAGE_FRAMES if MMU\n+\tselect SOC_LATE_INIT_HOOK\n+\tselect SOC_EARLY_INIT_HOOK\n \n config SOC_INTEL_COMM_WIDGET\n \tbool \"Intel Communication Widget driver\"\ndiff --git a/soc/intel/intel_adsp/ace/multiprocessing.c b/soc/intel/intel_adsp/ace/multiprocessing.c\nindex 77ab0057238..363dc9ae74d 100644\n--- a/soc/intel/intel_adsp/ace/multiprocessing.c\n+++ b/soc/intel/intel_adsp/ace/multiprocessing.c\n@@ -108,11 +108,11 @@ void soc_mp_init(void)\n \tsoc_cpus_active[0] = true;\n }\n \n-static int host_runtime_get(void)\n+void soc_late_init_hook(void)\n {\n-\treturn pm_device_runtime_get(INTEL_ADSP_HST_DOMAIN_DEV);\n+\tpm_device_runtime_get(INTEL_ADSP_HST_DOMAIN_DEV);\n }\n-SYS_INIT(host_runtime_get, POST_KERNEL, 99);\n+\n \n #ifdef CONFIG_ADSP_IMR_CONTEXT_SAVE\n /*\ndiff --git a/soc/intel/intel_adsp/cavs/Kconfig b/soc/intel/intel_adsp/cavs/Kconfig\nindex 01d325cc325..ecea64b1e7b 100644\n--- a/soc/intel/intel_adsp/cavs/Kconfig\n+++ b/soc/intel/intel_adsp/cavs/Kconfig\n@@ -11,6 +11,7 @@ config SOC_SERIES_INTEL_ADSP_CAVS\n \tselect ATOMIC_OPERATIONS_ARCH if \"$(ZEPHYR_TOOLCHAIN_VARIANT)\" = \"xcc\"\n \tselect ARCH_HAS_COHERENCE\n \tselect HAS_PM\n+\tselect SOC_EARLY_INIT_HOOK\n \n config SOC_INTEL_CAVS_V25\n \tselect XTENSA_WAITI_BUG\ndiff --git a/soc/intel/intel_adsp/common/boot_complete.c b/soc/intel/intel_adsp/common/boot_complete.c\nindex 3d27ae18d13..96e47ef0292 100644\n--- a/soc/intel/intel_adsp/common/boot_complete.c\n+++ b/soc/intel/intel_adsp/common/boot_complete.c\n@@ -28,5 +28,3 @@ int boot_complete(void)\n \n \treturn 0;\n }\n-\n-SYS_INIT(boot_complete, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE);\ndiff --git a/soc/intel/intel_adsp/common/soc.c b/soc/intel/intel_adsp/common/soc.c\nindex 97c481a165e..a25493ff766 100644\n--- a/soc/intel/intel_adsp/common/soc.c\n+++ b/soc/intel/intel_adsp/common/soc.c\n@@ -6,6 +6,7 @@\n #include <zephyr/init.h>\n #include <zephyr/linker/section_tags.h>\n \n+extern int boot_complete(void);\n extern void power_init(void);\n extern void adsp_clock_init(void);\n \n@@ -13,8 +14,9 @@ extern void adsp_clock_init(void);\n extern void soc_mp_init(void);\n #endif\n \n-static __imr int soc_init(void)\n+void soc_early_init_hook(void)\n {\n+\t(void)boot_complete();\n \tpower_init();\n \n #ifdef CONFIG_ADSP_CLOCK\n@@ -24,8 +26,4 @@ static __imr int soc_init(void)\n #if CONFIG_MP_MAX_NUM_CPUS > 1\n \tsoc_mp_init();\n #endif\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(soc_init, PRE_KERNEL_1, 99);\ndiff --git a/soc/intel/intel_ish/Kconfig b/soc/intel/intel_ish/Kconfig\nindex 31568e85d65..084fb45b70f 100644\n--- a/soc/intel/intel_ish/Kconfig\n+++ b/soc/intel/intel_ish/Kconfig\n@@ -13,3 +13,4 @@ config SOC_FAMILY_INTEL_ISH\n \tselect INTEL_HAL\n \tselect HAS_PM\n \tselect HAS_COVERAGE_SUPPORT\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/intel/intel_ish/intel_ish5/pm/power.c b/soc/intel/intel_ish/intel_ish5/pm/power.c\nindex 3ad15eee36b..1ad559c3fea 100644\n--- a/soc/intel/intel_ish/intel_ish5/pm/power.c\n+++ b/soc/intel/intel_ish/intel_ish5/pm/power.c\n@@ -72,11 +72,7 @@ void sys_arch_reboot(int type)\n \n extern void sedi_pm_init(void);\n \n-static int ish_sedi_pm_init(void)\n+void soc_early_init_hook(void)\n {\n \tsedi_pm_init();\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(ish_sedi_pm_init, PRE_KERNEL_2, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/intel/intel_ish/intel_ish5/soc.c b/soc/intel/intel_ish/intel_ish5/soc.c\nindex ccf044824a7..6547b219d4e 100644\n--- a/soc/intel/intel_ish/intel_ish5/soc.c\n+++ b/soc/intel/intel_ish/intel_ish5/soc.c\n@@ -11,13 +11,9 @@\n #include \"sedi_driver_hpet.h\"\n #endif\n \n-static int intel_ish_init(void)\n+void soc_early_init_hook(void)\n {\n #if defined(CONFIG_HPET_TIMER)\n \tsedi_hpet_set_min_delay(HPET_CMP_MIN_DELAY);\n #endif\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(intel_ish_init, PRE_KERNEL_2, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/intel/intel_socfpga_std/cyclonev/Kconfig b/soc/intel/intel_socfpga_std/cyclonev/Kconfig\nindex 2b6ba6587b3..8c4e2b84006 100644\n--- a/soc/intel/intel_socfpga_std/cyclonev/Kconfig\n+++ b/soc/intel/intel_socfpga_std/cyclonev/Kconfig\n@@ -7,3 +7,4 @@ config SOC_SERIES_CYCLONEV\n \tselect ARM_AARCH32_MMU\n \tselect ARM_ARCH_TIMER_ERRATUM_740657 if ARM_ARCH_TIMER\n \tselect ARCH_HAS_RESERVED_PAGE_FRAMES\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/intel/intel_socfpga_std/cyclonev/soc.c b/soc/intel/intel_socfpga_std/cyclonev/soc.c\nindex 51d4aebd0cd..59f0c68ebd0 100644\n--- a/soc/intel/intel_socfpga_std/cyclonev/soc.c\n+++ b/soc/intel/intel_socfpga_std/cyclonev/soc.c\n@@ -70,16 +70,12 @@ const struct arm_mmu_config mmu_config = {\n  *\n  * @return 0\n  */\n-static int soc_intel_cyclonev_init(void)\n+void soc_early_init_hook(void)\n {\n \tunsigned int sctlr = __get_SCTLR(); /* modifying some registers prior to initialization */\n \n \tsctlr &= ~SCTLR_A_Msk;\n \t__set_SCTLR(sctlr);\n \t__set_VBAR(0);\n-\treturn 0;\n }\n-\n-SYS_INIT(soc_intel_cyclonev_init, PRE_KERNEL_1,\n-\tCONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\n /* EOF */"
},{
  "instruction": "soc: gd: move init code from SYS_INIT to hooks",
  "input": "static int gd32a50x_soc_init(void)\n\treturn 0;\nSYS_INIT(gd32a50x_soc_init, PRE_KERNEL_1, 0);\nstatic int gd32e10x_soc_init(void)\n\treturn 0;\nSYS_INIT(gd32e10x_soc_init, PRE_KERNEL_1, 0);\nstatic int gd32e50x_soc_init(void)\n\treturn 0;\nSYS_INIT(gd32e50x_soc_init, PRE_KERNEL_1, 0);\nstatic int gd32f3x0_init(void)\n\treturn 0;\nSYS_INIT(gd32f3x0_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int gigadevice_gd32_soc_init(void)\n\treturn 0;\nSYS_INIT(gigadevice_gd32_soc_init, PRE_KERNEL_1, 0);\nstatic int gd32f4xx_soc_init(void)\n\treturn 0;\nSYS_INIT(gd32f4xx_soc_init, PRE_KERNEL_1, 0);\nstatic int gd32l23x_init(void)\n\treturn 0;\nSYS_INIT(gd32l23x_init, PRE_KERNEL_1, 0);\nstatic int gigadevice_gd32v_soc_init(void)\n\treturn 0;\nSYS_INIT(gigadevice_gd32v_soc_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);",
  "result": "diff --git a/soc/gd/gd32/gd32a50x/Kconfig b/soc/gd/gd32/gd32a50x/Kconfig\nindex 2d9eafd5da7..2479ebb81e4 100644\n--- a/soc/gd/gd32/gd32a50x/Kconfig\n+++ b/soc/gd/gd32/gd32a50x/Kconfig\n@@ -10,3 +10,4 @@ config SOC_SERIES_GD32A50X\n \tselect GD32_HAS_AF_PINMUX\n \tselect GD32_HAS_IRC_40K\n \tselect SOC_RESET_HOOK\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/gd/gd32/gd32a50x/soc.c b/soc/gd/gd32/gd32a50x/soc.c\nindex d19045f946c..c58814d8357 100644\n--- a/soc/gd/gd32/gd32a50x/soc.c\n+++ b/soc/gd/gd32/gd32a50x/soc.c\n@@ -19,11 +19,7 @@ void soc_reset_hook(void)\n \t}\n }\n \n-static int gd32a50x_soc_init(void)\n+void soc_early_init_hook(void)\n {\n \tSystemInit();\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(gd32a50x_soc_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/gd/gd32/gd32e10x/Kconfig b/soc/gd/gd32/gd32e10x/Kconfig\nindex 6b83464fd71..5c092bac972 100644\n--- a/soc/gd/gd32/gd32e10x/Kconfig\n+++ b/soc/gd/gd32/gd32e10x/Kconfig\n@@ -9,3 +9,4 @@ config SOC_SERIES_GD32E10X\n \tselect CPU_CORTEX_M_HAS_VTOR\n \tselect GD32_HAS_AFIO_PINMUX\n \tselect GD32_HAS_IRC_40K\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/gd/gd32/gd32e10x/soc.c b/soc/gd/gd32/gd32e10x/soc.c\nindex 939af3492c8..e28f7cb4876 100644\n--- a/soc/gd/gd32/gd32e10x/soc.c\n+++ b/soc/gd/gd32/gd32e10x/soc.c\n@@ -7,11 +7,7 @@\n #include <zephyr/init.h>\n #include <soc.h>\n \n-static int gd32e10x_soc_init(void)\n+void soc_early_init_hook(void)\n {\n \tSystemInit();\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(gd32e10x_soc_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/gd/gd32/gd32e50x/Kconfig b/soc/gd/gd32/gd32e50x/Kconfig\nindex d0672660e85..8cea22084d1 100644\n--- a/soc/gd/gd32/gd32e50x/Kconfig\n+++ b/soc/gd/gd32/gd32e50x/Kconfig\n@@ -9,3 +9,4 @@ config SOC_SERIES_GD32E50X\n \tselect ARMV8_M_DSP\n \tselect GD32_HAS_AFIO_PINMUX\n \tselect GD32_HAS_IRC_40K\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/gd/gd32/gd32e50x/soc.c b/soc/gd/gd32/gd32e50x/soc.c\nindex 0bd63afaff5..a3d978e5979 100644\n--- a/soc/gd/gd32/gd32e50x/soc.c\n+++ b/soc/gd/gd32/gd32e50x/soc.c\n@@ -6,11 +6,7 @@\n #include <zephyr/init.h>\n #include <soc.h>\n \n-static int gd32e50x_soc_init(void)\n+void soc_early_init_hook(void)\n {\n \tSystemInit();\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(gd32e50x_soc_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/gd/gd32/gd32f3x0/Kconfig b/soc/gd/gd32/gd32f3x0/Kconfig\nindex e2e9bff6ba1..84a2248b305 100644\n--- a/soc/gd/gd32/gd32f3x0/Kconfig\n+++ b/soc/gd/gd32/gd32f3x0/Kconfig\n@@ -7,3 +7,4 @@ config SOC_SERIES_GD32F3X0\n \tselect CPU_CORTEX_M4\n \tselect GD32_HAS_AF_PINMUX\n \tselect GD32_HAS_IRC_40K\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/gd/gd32/gd32f3x0/soc.c b/soc/gd/gd32/gd32f3x0/soc.c\nindex ebf0e3fea35..32acc3fef82 100644\n--- a/soc/gd/gd32/gd32f3x0/soc.c\n+++ b/soc/gd/gd32/gd32f3x0/soc.c\n@@ -7,11 +7,7 @@\n #include <zephyr/init.h>\n #include <soc.h>\n \n-static int gd32f3x0_init(void)\n+void soc_early_init_hook(void)\n {\n \tSystemInit();\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(gd32f3x0_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/gd/gd32/gd32f403/Kconfig b/soc/gd/gd32/gd32f403/Kconfig\nindex c4b31a0e41d..2fe9606d8e2 100644\n--- a/soc/gd/gd32/gd32f403/Kconfig\n+++ b/soc/gd/gd32/gd32f403/Kconfig\n@@ -10,3 +10,4 @@ config SOC_SERIES_GD32F403\n \tselect CPU_CORTEX_M_HAS_VTOR\n \tselect GD32_HAS_AFIO_PINMUX\n \tselect GD32_HAS_IRC_40K\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/gd/gd32/gd32f403/soc.c b/soc/gd/gd32/gd32f403/soc.c\nindex 2e52dd08508..f088099ed8f 100644\n--- a/soc/gd/gd32/gd32f403/soc.c\n+++ b/soc/gd/gd32/gd32f403/soc.c\n@@ -19,15 +19,8 @@\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int gigadevice_gd32_soc_init(void)\n+void soc_early_init_hook(void)\n {\n \tSystemInit();\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(gigadevice_gd32_soc_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/gd/gd32/gd32f4xx/Kconfig b/soc/gd/gd32/gd32f4xx/Kconfig\nindex efc8455e116..ff5aa3028fc 100644\n--- a/soc/gd/gd32/gd32f4xx/Kconfig\n+++ b/soc/gd/gd32/gd32f4xx/Kconfig\n@@ -8,3 +8,4 @@ config SOC_SERIES_GD32F4XX\n \tselect CPU_CORTEX_M4\n \tselect GD32_HAS_AF_PINMUX\n \tselect GD32_HAS_IRC_32K\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/gd/gd32/gd32f4xx/soc.c b/soc/gd/gd32/gd32f4xx/soc.c\nindex e096ba64b0b..136edfc6ae2 100644\n--- a/soc/gd/gd32/gd32f4xx/soc.c\n+++ b/soc/gd/gd32/gd32f4xx/soc.c\n@@ -7,11 +7,7 @@\n #include <zephyr/init.h>\n #include <soc.h>\n \n-static int gd32f4xx_soc_init(void)\n+void soc_early_init_hook(void)\n {\n \tSystemInit();\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(gd32f4xx_soc_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/gd/gd32/gd32l23x/Kconfig b/soc/gd/gd32/gd32l23x/Kconfig\nindex 5155d89ea15..c0156edde7e 100644\n--- a/soc/gd/gd32/gd32l23x/Kconfig\n+++ b/soc/gd/gd32/gd32l23x/Kconfig\n@@ -8,3 +8,4 @@ config SOC_SERIES_GD32L23X\n \tselect CPU_CORTEX_M_HAS_VTOR\n \tselect GD32_HAS_AF_PINMUX\n \tselect GD32_HAS_IRC_32K\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/gd/gd32/gd32l23x/soc.c b/soc/gd/gd32/gd32l23x/soc.c\nindex 38194133739..849f4e2f296 100644\n--- a/soc/gd/gd32/gd32l23x/soc.c\n+++ b/soc/gd/gd32/gd32l23x/soc.c\n@@ -7,11 +7,7 @@\n #include <zephyr/init.h>\n #include <soc.h>\n \n-static int gd32l23x_init(void)\n+void soc_early_init_hook(void)\n {\n \tSystemInit();\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(gd32l23x_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/gd/gd32/gd32vf103/Kconfig b/soc/gd/gd32/gd32vf103/Kconfig\nindex d206100c53e..4ec9057d196 100644\n--- a/soc/gd/gd32/gd32vf103/Kconfig\n+++ b/soc/gd/gd32/gd32vf103/Kconfig\n@@ -18,3 +18,4 @@ config SOC_SERIES_GD32VF103\n \tselect GD32_HAS_AFIO_PINMUX\n \tselect GD32_HAS_IRC_40K\n \tselect XIP\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/gd/gd32/gd32vf103/soc.c b/soc/gd/gd32/gd32vf103/soc.c\nindex f16597ab379..da38b0e38ad 100644\n--- a/soc/gd/gd32/gd32vf103/soc.c\n+++ b/soc/gd/gd32/gd32vf103/soc.c\n@@ -9,7 +9,7 @@\n \n #include <gd32vf103.h>\n \n-static int gigadevice_gd32v_soc_init(void)\n+void soc_early_init_hook(void)\n {\n \tuint32_t key;\n \n@@ -19,8 +19,4 @@ static int gigadevice_gd32v_soc_init(void)\n \tSystemInit();\n \n \tirq_unlock(key);\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(gigadevice_gd32v_soc_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);"
},{
  "instruction": "soc: ene: move init code from SYS_INIT to hooks",
  "input": "static int kb1200_init(void)\n\treturn 0;\nSYS_INIT(kb1200_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);",
  "result": "diff --git a/soc/ene/kb1200/Kconfig b/soc/ene/kb1200/Kconfig\nindex 102065edeb8..96f489d1d0e 100644\n--- a/soc/ene/kb1200/Kconfig\n+++ b/soc/ene/kb1200/Kconfig\n@@ -7,3 +7,4 @@ config SOC_KB1200\n \tselect CPU_HAS_ARM_MPU\n \tselect CPU_CORTEX_M_HAS_DWT\n \tselect CPU_HAS_FPU\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/ene/kb1200/soc.c b/soc/ene/kb1200/soc.c\nindex 6abf0180fb9..8ec63721dad 100644\n--- a/soc/ene/kb1200/soc.c\n+++ b/soc/ene/kb1200/soc.c\n@@ -39,11 +39,8 @@ static void clock_init(void)\n \t}\n }\n \n-static int kb1200_init(void)\n+void soc_early_init_hook(void)\n {\n \tclock_init();\n \tpmu_init();\n-\treturn 0;\n }\n-\n-SYS_INIT(kb1200_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);"
},{
  "instruction": "soc: brcm: move init code from SYS_INIT to hooks",
  "input": "* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int viper_init(void)\n\treturn 0;\nSYS_INIT(viper_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int viper_init(void)\n\treturn 0;\nSYS_INIT(viper_init, PRE_KERNEL_1, 0);",
  "result": "diff --git a/soc/brcm/bcmvk/viper/Kconfig b/soc/brcm/bcmvk/viper/Kconfig\nindex e6266d10456..20b30195bc6 100644\n--- a/soc/brcm/bcmvk/viper/Kconfig\n+++ b/soc/brcm/bcmvk/viper/Kconfig\n@@ -6,8 +6,10 @@ config SOC_BCM58402_M7\n \tselect CPU_CORTEX_M7\n \tselect CPU_CORTEX_M_HAS_SYSTICK\n \tselect CPU_HAS_ARM_MPU\n+\tselect SOC_EARLY_INIT_HOOK\n \n config SOC_BCM58402_A72\n \tselect ARM64\n \tselect CPU_CORTEX_A72\n \tselect ARM_ARCH_TIMER if SYS_CLOCK_EXISTS\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/brcm/bcmvk/viper/a72/soc.c b/soc/brcm/bcmvk/viper/a72/soc.c\nindex 9bc05f01425..a30d246cf07 100644\n--- a/soc/brcm/bcmvk/viper/a72/soc.c\n+++ b/soc/brcm/bcmvk/viper/a72/soc.c\n@@ -13,11 +13,8 @@\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int viper_init(void)\n+void soc_early_init_hook(void)\n {\n \tuint32_t key;\n \tuint32_t data;\n@@ -35,8 +32,4 @@ static int viper_init(void)\n \tsys_write32(data, LS_ICFG_PMON_LITE_SW_RESETN);\n \n \tirq_unlock(key);\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(viper_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/brcm/bcmvk/viper/m7/soc.c b/soc/brcm/bcmvk/viper/m7/soc.c\nindex d18d13ce884..61ab7eb3b30 100644\n--- a/soc/brcm/bcmvk/viper/m7/soc.c\n+++ b/soc/brcm/bcmvk/viper/m7/soc.c\n@@ -13,11 +13,8 @@\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int viper_init(void)\n+void soc_early_init_hook(void)\n {\n \tuint32_t data;\n \n@@ -29,8 +26,4 @@ static int viper_init(void)\n \tdata = sys_read32(LS_ICFG_PMON_LITE_SW_RESETN);\n \tdata |= PCIE_PMON_LITE_SW_RESETN;\n \tsys_write32(data, LS_ICFG_PMON_LITE_SW_RESETN);\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(viper_init, PRE_KERNEL_1, 0);"
},{
  "instruction": "soc: atmel: move init code from SYS_INIT to hooks",
  "input": "* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int atmel_same70_init(void)\n\treturn 0;\nSYS_INIT(atmel_same70_init, PRE_KERNEL_1, 0);\n*\n* @return 0\nstatic int atmel_same70_config(void)\n\treturn 0;\nSYS_INIT(atmel_same70_config, PRE_KERNEL_1, 1);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int atmel_samv71_init(void)\n\treturn 0;\nSYS_INIT(atmel_samv71_init, PRE_KERNEL_1, 0);\n*\n* @return 0\nstatic int atmel_samv71_config(void)\n\treturn 0;\nSYS_INIT(atmel_samv71_config, PRE_KERNEL_1, 1);",
  "result": "diff --git a/soc/atmel/sam/same70/Kconfig b/soc/atmel/sam/same70/Kconfig\nindex bea8055cbbd..a41b5e4e587 100644\n--- a/soc/atmel/sam/same70/Kconfig\n+++ b/soc/atmel/sam/same70/Kconfig\n@@ -17,3 +17,4 @@ config SOC_SERIES_SAME70\n \tselect HAS_SWO\n \tselect XIP\n \tselect HAS_POWEROFF\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/atmel/sam/same70/soc.c b/soc/atmel/sam/same70/soc.c\nindex a9d886c8a87..fdadb506dc5 100644\n--- a/soc/atmel/sam/same70/soc.c\n+++ b/soc/atmel/sam/same70/soc.c\n@@ -135,23 +135,18 @@ void soc_reset_hook(void)\n \tclock_init();\n }\n \n+extern void atmel_same70_config(void);\n /**\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run at the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int atmel_same70_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Check that the CHIP CIDR matches the HAL one */\n \tif (CHIPID->CHIPID_CIDR != CHIP_CIDR) {\n \t\tLOG_WRN(\"CIDR mismatch: chip = 0x%08x vs HAL = 0x%08x\",\n \t\t\t(uint32_t)CHIPID->CHIPID_CIDR, (uint32_t)CHIP_CIDR);\n \t}\n-\n-\treturn 0;\n+\tatmel_same70_config();\n }\n-\n-SYS_INIT(atmel_same70_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/atmel/sam/same70/soc_config.c b/soc/atmel/sam/same70/soc_config.c\nindex cd1f8b80d76..c390235c759 100644\n--- a/soc/atmel/sam/same70/soc_config.c\n+++ b/soc/atmel/sam/same70/soc_config.c\n@@ -18,10 +18,8 @@\n  *\n  * This should be run early during the boot process but after basic hardware\n  * initialization is done.\n- *\n- * @return 0\n  */\n-static int atmel_same70_config(void)\n+void atmel_same70_config(void)\n {\n \tif (IS_ENABLED(CONFIG_SOC_ATMEL_SAM_DISABLE_ERASE_PIN)) {\n \t\t/* Disable ERASE function on PB12 pin, this is controlled\n@@ -59,7 +57,4 @@ static int atmel_same70_config(void)\n \t\tMATRIX->CCFG_SYSIO |= CCFG_SYSIO_SYSIO5;\n \t}\n \n-\treturn 0;\n }\n-\n-SYS_INIT(atmel_same70_config, PRE_KERNEL_1, 1);\ndiff --git a/soc/atmel/sam/samv71/Kconfig b/soc/atmel/sam/samv71/Kconfig\nindex 347c798bb2d..c1dcc0c4e34 100644\n--- a/soc/atmel/sam/samv71/Kconfig\n+++ b/soc/atmel/sam/samv71/Kconfig\n@@ -17,3 +17,4 @@ config SOC_SERIES_SAMV71\n \tselect HAS_SWO\n \tselect XIP\n \tselect HAS_POWEROFF\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/atmel/sam/samv71/soc.c b/soc/atmel/sam/samv71/soc.c\nindex 8527e1b85a2..a69713167f7 100644\n--- a/soc/atmel/sam/samv71/soc.c\n+++ b/soc/atmel/sam/samv71/soc.c\n@@ -132,23 +132,18 @@ void soc_reset_hook(void)\n \tclock_init();\n }\n \n+extern void atmel_samv71_config(void);\n /**\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run at the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int atmel_samv71_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Check that the CHIP CIDR matches the HAL one */\n \tif (CHIPID->CHIPID_CIDR != CHIP_CIDR) {\n \t\tLOG_WRN(\"CIDR mismatch: chip = 0x%08x vs HAL = 0x%08x\",\n \t\t\t(uint32_t)CHIPID->CHIPID_CIDR, (uint32_t)CHIP_CIDR);\n \t}\n-\n-\treturn 0;\n+\tatmel_samv71_config();\n }\n-\n-SYS_INIT(atmel_samv71_init, PRE_KERNEL_1, 0);\ndiff --git a/soc/atmel/sam/samv71/soc_config.c b/soc/atmel/sam/samv71/soc_config.c\nindex 51638a997b3..85a07e6b6b1 100644\n--- a/soc/atmel/sam/samv71/soc_config.c\n+++ b/soc/atmel/sam/samv71/soc_config.c\n@@ -18,10 +18,8 @@\n  *\n  * This should be run early during the boot process but after basic hardware\n  * initialization is done.\n- *\n- * @return 0\n  */\n-static int atmel_samv71_config(void)\n+void atmel_samv71_config(void)\n {\n \tif (IS_ENABLED(CONFIG_SOC_ATMEL_SAM_DISABLE_ERASE_PIN)) {\n \t\t/* Disable ERASE function on PB12 pin, this is controlled\n@@ -59,8 +57,4 @@ static int atmel_samv71_config(void)\n \t\t/* Disable TDO/TRACESWO function on PB5 pin */\n \t\tMATRIX->CCFG_SYSIO |= CCFG_SYSIO_SYSIO5;\n \t}\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(atmel_samv71_config, PRE_KERNEL_1, 1);"
},{
  "instruction": "soc: arm: move init code from SYS_INIT to hooks",
  "input": "* So the init priority has to be 0 (zero).\n*\n* Assumption:\n* MAINCLK = 24Mhz\n*\n* @return 0\nstatic int arm_beetle_init(void)\n\treturn 0;\nSYS_INIT(arm_beetle_init, PRE_KERNEL_1, 0);",
  "result": "diff --git a/soc/arm/beetle/Kconfig b/soc/arm/beetle/Kconfig\nindex 19de2b1717c..3aee7f4196a 100644\n--- a/soc/arm/beetle/Kconfig\n+++ b/soc/arm/beetle/Kconfig\n@@ -8,3 +8,4 @@ config SOC_SERIES_BEETLE\n \tselect CPU_CORTEX_M3\n \tselect CPU_HAS_ARM_MPU\n \tselect CPU_CORTEX_M_HAS_DWT\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/arm/beetle/soc.c b/soc/arm/beetle/soc.c\nindex 0cf8668a514..b47425ba3b4 100644\n--- a/soc/arm/beetle/soc.c\n+++ b/soc/arm/beetle/soc.c\n@@ -21,19 +21,9 @@\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * Assumption:\n- * MAINCLK = 24Mhz\n- *\n- * @return 0\n  */\n-static int arm_beetle_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Setup various clocks and wakeup sources */\n \tsoc_power_init();\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(arm_beetle_init, PRE_KERNEL_1, 0);"
},{
  "instruction": "soc: andestech: move init code from SYS_INIT to hooks",
  "input": "static int pma_init(void)\n\treturn 0;\nSYS_INIT(pma_init, PRE_KERNEL_2, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);",
  "result": "diff --git a/soc/andestech/ae350/Kconfig b/soc/andestech/ae350/Kconfig\nindex bfe38058e1c..4d466048e84 100644\n--- a/soc/andestech/ae350/Kconfig\n+++ b/soc/andestech/ae350/Kconfig\n@@ -91,6 +91,7 @@ config SOC_ANDES_V5_EXECIT\n config SOC_ANDES_V5_PMA\n \tbool \"Andes V5 Physical Memory Attribute (PMA)\"\n \tselect ARCH_HAS_NOCACHE_MEMORY_SUPPORT\n+\tselect SOC_EARLY_INIT_HOOK\n \thelp\n \t\tThis option enables the Andes V5 PMA, in order to support SW to\n \t\tconfigure physical memory attribute by PMA CSRs. The address\ndiff --git a/soc/andestech/ae350/pma.c b/soc/andestech/ae350/pma.c\nindex 9847ba622eb..0fb162cc959 100644\n--- a/soc/andestech/ae350/pma.c\n+++ b/soc/andestech/ae350/pma.c\n@@ -201,7 +201,7 @@ void pma_init_per_core(void)\n #endif /* CONFIG_NOCACHE_MEMORY */\n }\n \n-static int pma_init(void)\n+void soc_early_init_hook(void)\n {\n \tunsigned long mmsc_cfg;\n \n@@ -220,8 +220,4 @@ static int pma_init(void)\n \t}\n \n \tpma_init_per_core();\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(pma_init, PRE_KERNEL_2, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);"
},{
  "instruction": "soc: ambiq: move init code from SYS_INIT to hooks",
  "input": "static int ambiq_power_init(void)\n\treturn 0;\nSYS_INIT(ambiq_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\nstatic int arm_apollo3_init(void)\n\treturn 0;\nSYS_INIT(arm_apollo3_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\nstatic int ambiq_power_init(void)\n\treturn 0;\nSYS_INIT(ambiq_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\nstatic int arm_apollo4_init(void)\n\treturn 0;\nSYS_INIT(arm_apollo4_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);",
  "result": "diff --git a/soc/ambiq/apollo3x/Kconfig b/soc/ambiq/apollo3x/Kconfig\nindex ad9fb253fcb..02bf72024a9 100644\n--- a/soc/ambiq/apollo3x/Kconfig\n+++ b/soc/ambiq/apollo3x/Kconfig\n@@ -11,3 +11,4 @@ config SOC_SERIES_APOLLO3X\n \tselect HAS_SWO\n \tselect AMBIQ_HAL\n \tselect HAS_PM\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/ambiq/apollo3x/power.c b/soc/ambiq/apollo3x/power.c\nindex 630a34638ab..d41dd20c996 100644\n--- a/soc/ambiq/apollo3x/power.c\n+++ b/soc/ambiq/apollo3x/power.c\n@@ -65,7 +65,7 @@ void pm_state_exit_post_ops(enum pm_state state, uint8_t substate_id)\n \tirq_unlock(0);\n }\n \n-static int ambiq_power_init(void)\n+void ambiq_power_init(void)\n {\n \t/* Enable flash.\n \t * Currently all flash area is powered on, but we should only enable the used flash area and\n@@ -100,8 +100,4 @@ static int ambiq_power_init(void)\n \t */\n \tam_hal_sysctrl_control(AM_HAL_SYSCTRL_CONTROL_DEEPSLEEP_MINPWR_EN, 0);\n #endif\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(ambiq_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/ambiq/apollo3x/soc.c b/soc/ambiq/apollo3x/soc.c\nindex c76dda6d850..bae475e814f 100644\n--- a/soc/ambiq/apollo3x/soc.c\n+++ b/soc/ambiq/apollo3x/soc.c\n@@ -8,7 +8,9 @@\n \n #include <am_mcu_apollo.h>\n \n-static int arm_apollo3_init(void)\n+extern void ambiq_power_init(void);\n+\n+void soc_early_init_hook(void)\n {\n \t/* Set the clock frequency. */\n \tam_hal_clkgen_control(AM_HAL_CLKGEN_CONTROL_SYSCLK_MAX, 0);\n@@ -23,7 +25,7 @@ static int arm_apollo3_init(void)\n \t/* Disable the RTC. */\n \tam_hal_rtc_osc_disable();\n \n-\treturn 0;\n+#ifdef CONFIG_PM\n+\tambiq_power_init();\n+#endif\n }\n-\n-SYS_INIT(arm_apollo3_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/ambiq/apollo4x/Kconfig b/soc/ambiq/apollo4x/Kconfig\nindex 9a48dc9eb21..b22a1c37cda 100644\n--- a/soc/ambiq/apollo4x/Kconfig\n+++ b/soc/ambiq/apollo4x/Kconfig\n@@ -12,3 +12,4 @@ config SOC_SERIES_APOLLO4X\n \tselect HAS_SWO\n \tselect AMBIQ_HAL\n \tselect HAS_PM\n+\tselect SOC_EARLY_INIT_HOOK\ndiff --git a/soc/ambiq/apollo4x/power.c b/soc/ambiq/apollo4x/power.c\nindex 30950436517..b799f29c224 100644\n--- a/soc/ambiq/apollo4x/power.c\n+++ b/soc/ambiq/apollo4x/power.c\n@@ -65,7 +65,7 @@ void pm_state_exit_post_ops(enum pm_state state, uint8_t substate_id)\n \tirq_unlock(0);\n }\n \n-static int ambiq_power_init(void)\n+void ambiq_power_init(void)\n {\n \tam_hal_pwrctrl_mcu_memory_config_t sMcuMemCfg = {\n \t\t.eCacheCfg    = AM_HAL_PWRCTRL_CACHE_NONE,\n@@ -98,8 +98,4 @@ static int ambiq_power_init(void)\n \tam_hal_pwrctrl_dsp_memory_config(AM_HAL_DSP0, &sDSPMemCfg);\n \n \tam_hal_pwrctrl_periph_disable(AM_HAL_PWRCTRL_PERIPH_CRYPTO);\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(ambiq_power_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\ndiff --git a/soc/ambiq/apollo4x/soc.c b/soc/ambiq/apollo4x/soc.c\nindex 225f5013441..b434e20f0ee 100644\n--- a/soc/ambiq/apollo4x/soc.c\n+++ b/soc/ambiq/apollo4x/soc.c\n@@ -8,7 +8,8 @@\n \n #include <am_mcu_apollo.h>\n \n-static int arm_apollo4_init(void)\n+extern void ambiq_power_init(void);\n+void soc_early_init_hook(void)\n {\n \n \t/* Initialize for low power in the power control block */\n@@ -19,8 +20,7 @@ static int arm_apollo4_init(void)\n \n \t/* Disable the RTC. */\n \tam_hal_rtc_osc_disable();\n-\n-\treturn 0;\n+#ifdef CONFIG_PM\n+\tambiq_power_init();\n+#endif\n }\n-\n-SYS_INIT(arm_apollo4_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);"
},{
  "instruction": "soc: adi: move init code from SYS_INIT to hooks",
  "input": "* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int max32xxx_init(void)\n\treturn 0;\nSYS_INIT(max32xxx_init, PRE_KERNEL_1, 0);",
  "result": "diff --git a/soc/adi/max32/Kconfig b/soc/adi/max32/Kconfig\nindex 80642dc3399..c845cc6c35c 100644\n--- a/soc/adi/max32/Kconfig\n+++ b/soc/adi/max32/Kconfig\n@@ -10,6 +10,7 @@ config SOC_FAMILY_MAX32\n \tselect CPU_CORTEX_M_HAS_SYSTICK\n \tselect CLOCK_CONTROL\n \tselect BUILD_OUTPUT_HEX\n+\tselect SOC_EARLY_INIT_HOOK\n \n config SOC_MAX32655\n \tselect CPU_CORTEX_M4\ndiff --git a/soc/adi/max32/soc.c b/soc/adi/max32/soc.c\nindex 5c7f875d029..c509e8e5cf3 100644\n--- a/soc/adi/max32/soc.c\n+++ b/soc/adi/max32/soc.c\n@@ -26,16 +26,9 @@ bool z_arm_on_enter_cpu_idle(void)\n  * @brief Perform basic hardware initialization at boot.\n  *\n  * This needs to be run from the very beginning.\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n  */\n-static int max32xxx_init(void)\n+void soc_early_init_hook(void)\n {\n \t/* Apply device related preinit configuration */\n \tmax32xx_system_init();\n-\n-\treturn 0;\n }\n-\n-SYS_INIT(max32xxx_init, PRE_KERNEL_1, 0);"
},{
  "instruction": "init: enhance kconfig docs for custom hooks",
  "input": "",
  "result": "diff --git a/kernel/Kconfig.init b/kernel/Kconfig.init\nindex 79121a96128..21cb5d9d8f1 100644\n--- a/kernel/Kconfig.init\n+++ b/kernel/Kconfig.init\n@@ -27,19 +27,31 @@ config SOC_EARLY_INIT_HOOK\n \thelp\n \t  Run an early SoC initialization hook.\n \n+\t  A custom SoC hook soc_early_init_hook() is executed before the kernel and\n+\t  devices are initialized\n+\n config SOC_LATE_INIT_HOOK\n \tbool \"Run late SoC hook\"\n \thelp\n \t  Run a late SoC initialization hook.\n \n+\t  A custom SoC hook soc_late_init_hook() is executed after the kernel and\n+\t  devices are initialized\n+\n config BOARD_EARLY_INIT_HOOK\n \tbool \"Run early board hook\"\n \thelp\n \t  Run an early board initialization hook.\n \n+\t  A custom board hook board_early_init_hook() is executed before the kernel and\n+\t  devices are initialized\n+\n config BOARD_LATE_INIT_HOOK\n \tbool \"Run late board hook\"\n \thelp\n \t  Run a late board initialization hook.\n \n+\t  A custom board hook board_late_init_hook() is executed after the kernel and\n+\t  devices are initialized\n+\n endmenu"
},{
  "instruction": "tests: drivers: build_all: display: Add i2c and spi devices build test",
  "input": "\t\t\t\t&test_gpio 0 6>;\n\t\t\ttest_ist3931:ist3931@3f{\n\t\t\t\treg=<0x3f>;",
  "result": "diff --git a/tests/drivers/build_all/display/app.overlay b/tests/drivers/build_all/display/app.overlay\nindex 15be892b8a1..d425bf103b9 100644\n--- a/tests/drivers/build_all/display/app.overlay\n+++ b/tests/drivers/build_all/display/app.overlay\n@@ -151,7 +151,7 @@\n \t\t\t */\n \t\t\tcs-gpios = <&test_gpio 0 0 &test_gpio 0 1 &test_gpio 0 2\n \t\t\t\t&test_gpio 0 3 &test_gpio 0 4 &test_gpio 0 5\n-\t\t\t\t&test_gpio 0 6>;\n+\t\t\t\t&test_gpio 0 6 &test_gpio 0 7 &test_gpio 0 8>;\n \n \t\t\ttest_led_strip_0: lpd8806@0 {\n \t\t\t\tcompatible = \"greeled,lpd8806\";\n@@ -173,6 +173,26 @@\n \t\t\t\tcolor-mapping = <0 1 2>;\n \t\t\t\treset-delay = <280>;\n \t\t\t};\n+\n+\t\t\ttest_ls0xx: ls0xx@7 {\n+\t\t\t\tcompatible = \"sharp,ls0xx\";\n+\t\t\t\tspi-max-frequency = <2000000>;\n+\t\t\t\treg = <0x7>;\n+\t\t\t\twidth = <128>;\n+\t\t\t\theight = <128>;\n+\t\t\t\textcomin-gpios = <&test_gpio 0 0>;\n+\t\t\t\textcomin-frequency = <60>;\n+\t\t\t\tdisp-en-gpios = <&test_gpio 0 0>;\n+\t\t\t};\n+\n+\t\t\ttest_max7219: max7219@8 {\n+\t\t\t\tcompatible = \"maxim,max7219\";\n+\t\t\t\treg = <0x8>;\n+\t\t\t\tspi-max-frequency = <1000000>;\n+\t\t\t\tnum-cascading = <1>;\n+\t\t\t\tintensity = <0>;\n+\t\t\t\tscan-limit = <7>;\n+\t\t\t};\n \t\t};\n \n \t\ttest_led_strip_matrix {\n@@ -197,8 +217,8 @@\n \t\t\tstatus=\"okay\";\n \t\t\tclock-frequency=<100000>;\n \n-\t\t\ttest_ist3931:ist3931@3f{\n-\t\t\t\treg=<0x3f>;\n+\t\t\ttest_ist3931:ist3931@0 {\n+\t\t\t\treg=<0x0>;\n \t\t\t\twidth=<64>;\n \t\t\t\theight=<32>;\n \t\t\t\tcompatible = \"istech,ist3931\";\n@@ -213,6 +233,20 @@\n \t\t\t\tframe-control=<400>;\n \t\t\t\treverse-com-output;\n \t\t\t};\n+\n+\t\t\ttest_ssd1306: ssd1306@1 {\n+\t\t\t\tcompatible = \"solomon,ssd1306fb\";\n+\t\t\t\treg = <0x1>;\n+\t\t\t\twidth = <128>;\n+\t\t\t\theight = <64>;\n+\t\t\t\tsegment-offset = <0>;\n+\t\t\t\tpage-offset = <0>;\n+\t\t\t\tdisplay-offset = <0>;\n+\t\t\t\tmultiplex-ratio = <63>;\n+\t\t\t\tsegment-remap;\n+\t\t\t\tcom-invdir;\n+\t\t\t\tprechargep = <0x22>;\n+\t\t\t};\n \t\t};\n \t};\n };"
},{
  "instruction": "boards: nxp: fix mcuboot slots per automatic max sectors",
  "input": "\t\t\t/* The MCUBoot swap-move algorithm uses the last 14 sectors\n\t\t\t\treg = <0x00020000 (DT_SIZE_M(3) + DT_SIZE_K(56))>;\n\t\t\tslot1_partition: partition@32E000 {\n\t\t\t\treg = <0x0032E000 DT_SIZE_M(3)>;\n\t\t\tstorage_partition: partition@62E000 {\n\t\t\t\treg = <0x0062E000 (DT_SIZE_M(58) - DT_SIZE_K(184))>;\n\t\t\t/* The MCUBoot swap-move algorithm uses the last 14 sectors\n\t\t\t\treg = <0x00020000 (DT_SIZE_M(3) + DT_SIZE_K(56))>;\n\t\t\tslot1_partition: partition@32E000 {\n\t\t\t\treg = <0x0032E000 DT_SIZE_M(3)>;\n\t\t\tstorage_partition: partition@62E000 {\n\t\t\t\treg = <0x0062E000 (DT_SIZE_M(58) - DT_SIZE_K(184))>;\n\t\t\t/* The MCUBoot swap-move algorithm uses the last 14 sectors\n\t\t\t\treg = <0x00020000 (DT_SIZE_M(3) + DT_SIZE_K(56))>;\n\t\t\tslot1_partition: partition@32E000 {\n\t\t\t\treg = <0x0032E000 DT_SIZE_M(3)>;\n\t\t\tstorage_partition: partition@62E000 {\n\t\t\t\treg = <0x0062E000 (DT_SIZE_M(58) - DT_SIZE_K(184))>;\n\t\t/* The MCUBoot swap-move algorithm uses the last 2 sectors\n\t\t\treg = <0x00010000 (DT_SIZE_K(928) + DT_SIZE_K(8))>;\n\t\tslot1_partition: partition@FA000 {\n\t\t\treg = <0x000FA000 DT_SIZE_K(928)>;\n\t\tstorage_partition: partition@1E2000 {\n\t\t\treg = <0x001E2000 DT_SIZE_K(120)>;",
  "result": "diff --git a/boards/nxp/mimxrt1050_evk/mimxrt1050_evk_mimxrt1052_hyperflash.overlay b/boards/nxp/mimxrt1050_evk/mimxrt1050_evk_mimxrt1052_hyperflash.overlay\nindex 4b3923c36d9..cc31988f583 100644\n--- a/boards/nxp/mimxrt1050_evk/mimxrt1050_evk_mimxrt1052_hyperflash.overlay\n+++ b/boards/nxp/mimxrt1050_evk/mimxrt1050_evk_mimxrt1052_hyperflash.overlay\n@@ -50,20 +50,20 @@\n \t\t\t\tlabel = \"mcuboot\";\n \t\t\t\treg = <0x00000000 DT_SIZE_K(128)>;\n \t\t\t};\n-\t\t\t/* The MCUBoot swap-move algorithm uses the last 14 sectors\n+\t\t\t/* The MCUBoot swap-move algorithm uses the last 11 sectors\n \t\t\t * of the primary slot0 for swap status and move.\n \t\t\t */\n \t\t\tslot0_partition: partition@20000 {\n \t\t\t\tlabel = \"image-0\";\n-\t\t\t\treg = <0x00020000 (DT_SIZE_M(3) + DT_SIZE_K(56))>;\n+\t\t\t\treg = <0x00020000 (DT_SIZE_M(3) + DT_SIZE_K(44))>;\n \t\t\t};\n-\t\t\tslot1_partition: partition@32E000 {\n+\t\t\tslot1_partition: partition@32B000 {\n \t\t\t\tlabel = \"image-1\";\n-\t\t\t\treg = <0x0032E000 DT_SIZE_M(3)>;\n+\t\t\t\treg = <0x0032B000 DT_SIZE_M(3)>;\n \t\t\t};\n-\t\t\tstorage_partition: partition@62E000 {\n+\t\t\tstorage_partition: partition@62B000 {\n \t\t\t\tlabel = \"storage\";\n-\t\t\t\treg = <0x0062E000 (DT_SIZE_M(58) - DT_SIZE_K(184))>;\n+\t\t\t\treg = <0x0062B000 (DT_SIZE_M(58) - DT_SIZE_K(172))>;\n \t\t\t};\n \t\t};\n \t};\ndiff --git a/boards/nxp/mimxrt1060_evk/mimxrt1060_evk_mimxrt1062_hyperflash.overlay b/boards/nxp/mimxrt1060_evk/mimxrt1060_evk_mimxrt1062_hyperflash.overlay\nindex 25d33e462a0..27e013f2cad 100644\n--- a/boards/nxp/mimxrt1060_evk/mimxrt1060_evk_mimxrt1062_hyperflash.overlay\n+++ b/boards/nxp/mimxrt1060_evk/mimxrt1060_evk_mimxrt1062_hyperflash.overlay\n@@ -48,20 +48,20 @@\n \t\t\t\tlabel = \"mcuboot\";\n \t\t\t\treg = <0x00000000 DT_SIZE_K(128)>;\n \t\t\t};\n-\t\t\t/* The MCUBoot swap-move algorithm uses the last 14 sectors\n+\t\t\t/* The MCUBoot swap-move algorithm uses the last 11 sectors\n \t\t\t * of the primary slot0 for swap status and move.\n \t\t\t */\n \t\t\tslot0_partition: partition@20000 {\n \t\t\t\tlabel = \"image-0\";\n-\t\t\t\treg = <0x00020000 (DT_SIZE_M(3) + DT_SIZE_K(56))>;\n+\t\t\t\treg = <0x00020000 (DT_SIZE_M(3) + DT_SIZE_K(44))>;\n \t\t\t};\n-\t\t\tslot1_partition: partition@32E000 {\n+\t\t\tslot1_partition: partition@32B000 {\n \t\t\t\tlabel = \"image-1\";\n-\t\t\t\treg = <0x0032E000 DT_SIZE_M(3)>;\n+\t\t\t\treg = <0x0032B000 DT_SIZE_M(3)>;\n \t\t\t};\n-\t\t\tstorage_partition: partition@62E000 {\n+\t\t\tstorage_partition: partition@62B000 {\n \t\t\t\tlabel = \"storage\";\n-\t\t\t\treg = <0x0062E000 (DT_SIZE_M(58) - DT_SIZE_K(184))>;\n+\t\t\t\treg = <0x0062B000 (DT_SIZE_M(58) - DT_SIZE_K(172))>;\n \t\t\t};\n \t\t};\n \t};\ndiff --git a/boards/nxp/mimxrt1062_fmurt6/mimxrt1062_fmurt6.dts b/boards/nxp/mimxrt1062_fmurt6/mimxrt1062_fmurt6.dts\nindex 96a96958a03..780e792eca6 100644\n--- a/boards/nxp/mimxrt1062_fmurt6/mimxrt1062_fmurt6.dts\n+++ b/boards/nxp/mimxrt1062_fmurt6/mimxrt1062_fmurt6.dts\n@@ -211,20 +211,20 @@\n \t\t\t\tlabel = \"mcuboot\";\n \t\t\t\treg = <0x00000000 DT_SIZE_K(128)>;\n \t\t\t};\n-\t\t\t/* The MCUBoot swap-move algorithm uses the last 14 sectors\n+\t\t\t/* The MCUBoot swap-move algorithm uses the last 11 sectors\n \t\t\t * of the primary slot0 for swap status and move.\n \t\t\t */\n \t\t\tslot0_partition: partition@20000 {\n \t\t\t\tlabel = \"image-0\";\n-\t\t\t\treg = <0x00020000 (DT_SIZE_M(3) + DT_SIZE_K(56))>;\n+\t\t\t\treg = <0x00020000 (DT_SIZE_M(3) + DT_SIZE_K(44))>;\n \t\t\t};\n-\t\t\tslot1_partition: partition@32E000 {\n+\t\t\tslot1_partition: partition@32B000 {\n \t\t\t\tlabel = \"image-1\";\n-\t\t\t\treg = <0x0032E000 DT_SIZE_M(3)>;\n+\t\t\t\treg = <0x0032B000 DT_SIZE_M(3)>;\n \t\t\t};\n-\t\t\tstorage_partition: partition@62E000 {\n+\t\t\tstorage_partition: partition@62B000 {\n \t\t\t\tlabel = \"storage\";\n-\t\t\t\treg = <0x0062E000 (DT_SIZE_M(58) - DT_SIZE_K(184))>;\n+\t\t\t\treg = <0x0062B000 (DT_SIZE_M(58) - DT_SIZE_K(172))>;\n \t\t\t};\n \t\t};\n \t};\ndiff --git a/boards/nxp/rddrone_fmuk66/rddrone_fmuk66.dts b/boards/nxp/rddrone_fmuk66/rddrone_fmuk66.dts\nindex 1dbc7ec3e12..127d6ffb724 100644\n--- a/boards/nxp/rddrone_fmuk66/rddrone_fmuk66.dts\n+++ b/boards/nxp/rddrone_fmuk66/rddrone_fmuk66.dts\n@@ -240,20 +240,20 @@ zephyr_udc0: &usbotg {\n \t\t\treg = <0x00000000 DT_SIZE_K(64)>;\n \t\t\tread-only;\n \t\t};\n-\t\t/* The MCUBoot swap-move algorithm uses the last 2 sectors\n+\t\t/* The MCUBoot swap-move algorithm uses the last 3 sectors\n \t\t * of the primary slot0 for swap status and move.\n \t\t */\n \t\tslot0_partition: partition@10000 {\n \t\t\tlabel = \"image-0\";\n-\t\t\treg = <0x00010000 (DT_SIZE_K(928) + DT_SIZE_K(8))>;\n+\t\t\treg = <0x00010000 (DT_SIZE_K(928) + DT_SIZE_K(12))>;\n \t\t};\n-\t\tslot1_partition: partition@FA000 {\n+\t\tslot1_partition: partition@FB000 {\n \t\t\tlabel = \"image-1\";\n-\t\t\treg = <0x000FA000 DT_SIZE_K(928)>;\n+\t\t\treg = <0x000FB000 DT_SIZE_K(928)>;\n \t\t};\n-\t\tstorage_partition: partition@1E2000 {\n+\t\tstorage_partition: partition@1E3000 {\n \t\t\tlabel = \"storage\";\n-\t\t\treg = <0x001E2000 DT_SIZE_K(120)>;\n+\t\t\treg = <0x001E3000 DT_SIZE_K(116)>;\n \t\t};\n \t};\n };"
},{
  "instruction": "boards: remove `CONFIG_PINCTRL` from defconfig files of FE310-based boards",
  "input": "CONFIG_PINCTRL=y\nCONFIG_PINCTRL=y\nCONFIG_PINCTRL=y",
  "result": "diff --git a/boards/qemu/riscv32_xip/qemu_riscv32_xip_defconfig b/boards/qemu/riscv32_xip/qemu_riscv32_xip_defconfig\nindex 578726a799f..b356602b0a0 100644\n--- a/boards/qemu/riscv32_xip/qemu_riscv32_xip_defconfig\n+++ b/boards/qemu/riscv32_xip/qemu_riscv32_xip_defconfig\n@@ -4,7 +4,6 @@ CONFIG_CONSOLE=y\n CONFIG_SERIAL=y\n CONFIG_UART_SIFIVE_PORT_0=y\n CONFIG_UART_CONSOLE=y\n-CONFIG_PINCTRL=y\n CONFIG_GPIO=y\n CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC=10000000\n CONFIG_QEMU_ICOUNT_SHIFT=6\ndiff --git a/boards/sifive/hifive1/hifive1_defconfig b/boards/sifive/hifive1/hifive1_defconfig\nindex 21c46be1caf..4a1d5391c78 100644\n--- a/boards/sifive/hifive1/hifive1_defconfig\n+++ b/boards/sifive/hifive1/hifive1_defconfig\n@@ -5,5 +5,4 @@ CONFIG_CONSOLE=y\n CONFIG_SERIAL=y\n CONFIG_UART_SIFIVE_PORT_0=y\n CONFIG_UART_CONSOLE=y\n-CONFIG_PINCTRL=y\n CONFIG_GPIO=y\ndiff --git a/boards/sparkfun/red_v_things_plus/sparkfun_red_v_things_plus_defconfig b/boards/sparkfun/red_v_things_plus/sparkfun_red_v_things_plus_defconfig\nindex 2085c58676a..db9df36022c 100644\n--- a/boards/sparkfun/red_v_things_plus/sparkfun_red_v_things_plus_defconfig\n+++ b/boards/sparkfun/red_v_things_plus/sparkfun_red_v_things_plus_defconfig\n@@ -2,7 +2,6 @@\n # SPDX-License-Identifier: Apache-2.0\n \n CONFIG_GPIO=y\n-CONFIG_PINCTRL=y\n CONFIG_CONSOLE=y\n CONFIG_SERIAL=y\n CONFIG_UART_SIFIVE_PORT_0=y\ndiff --git a/drivers/pwm/Kconfig.sifive b/drivers/pwm/Kconfig.sifive\nindex 18bac68b388..c7e3d4e8afa 100644\n--- a/drivers/pwm/Kconfig.sifive\n+++ b/drivers/pwm/Kconfig.sifive\n@@ -7,5 +7,6 @@ config PWM_SIFIVE\n \tbool \"SiFive Freedom PWM driver\"\n \tdefault y\n \tdepends on DT_HAS_SIFIVE_PWM0_ENABLED\n+\tselect PINCTRL if SOC_SERIES_SIFIVE_FREEDOM_FE300\n \thelp\n \t  Enable the PWM driver for the SiFive Freedom platform\ndiff --git a/drivers/serial/Kconfig.sifive b/drivers/serial/Kconfig.sifive\nindex ff9d9a07c40..f683924464e 100644\n--- a/drivers/serial/Kconfig.sifive\n+++ b/drivers/serial/Kconfig.sifive\n@@ -9,6 +9,7 @@ menuconfig UART_SIFIVE\n \tdepends on DT_HAS_SIFIVE_UART0_ENABLED\n \tselect SERIAL_HAS_DRIVER\n \tselect SERIAL_SUPPORT_INTERRUPT\n+\tselect PINCTRL if SOC_SERIES_SIFIVE_FREEDOM_FE300\n \thelp\n \t  This option enables the SiFive Freedom serial driver.\n \ndiff --git a/drivers/spi/Kconfig.sifive b/drivers/spi/Kconfig.sifive\nindex 51fc9a702d0..41ec94e8646 100644\n--- a/drivers/spi/Kconfig.sifive\n+++ b/drivers/spi/Kconfig.sifive\n@@ -7,5 +7,6 @@ config SPI_SIFIVE\n \tbool \"SiFive SPI controller driver\"\n \tdefault y\n \tdepends on DT_HAS_SIFIVE_SPI0_ENABLED\n+\tselect PINCTRL if SOC_SERIES_SIFIVE_FREEDOM_FE300\n \thelp\n \t  Enable the SPI peripherals on SiFive Freedom processors"
},{
  "instruction": "soc: sensry: Fix isa extension settings",
  "input": "zephyr_compile_options(-march=rv32imc_zicsr -mabi=ilp32)",
  "result": "diff --git a/soc/sensry/ganymed/sy1xx/CMakeLists.txt b/soc/sensry/ganymed/sy1xx/CMakeLists.txt\nindex d7fc1725229..4b5c2ac0121 100644\n--- a/soc/sensry/ganymed/sy1xx/CMakeLists.txt\n+++ b/soc/sensry/ganymed/sy1xx/CMakeLists.txt\n@@ -3,8 +3,6 @@\n \n zephyr_include_directories(common)\n \n-zephyr_compile_options(-march=rv32imc_zicsr -mabi=ilp32)\n-\n zephyr_sources(\n         common/crt0.S\n         common/soc.c\ndiff --git a/soc/sensry/ganymed/sy1xx/Kconfig b/soc/sensry/ganymed/sy1xx/Kconfig\nindex 54d6d4930bb..cf85d4ddddf 100644\n--- a/soc/sensry/ganymed/sy1xx/Kconfig\n+++ b/soc/sensry/ganymed/sy1xx/Kconfig\n@@ -5,6 +5,7 @@ config SOC_SERIES_SY1XX\n \tselect RISCV\n \tselect RISCV_ISA_RV32I\n \tselect RISCV_ISA_EXT_M\n+\tselect RISCV_ISA_EXT_C\n \tselect RISCV_ISA_EXT_ZICSR\n \tselect RISCV_PRIVILEGED\n \tselect ATOMIC_OPERATIONS_C"
},{
  "instruction": "boards: enclustra: mercury_xe: Remove pointless init function",
  "input": "# Copyright (c) 2020, Antmicro\n# SPDX-License-Identifier: Apache-2.0\nzephyr_library()\nzephyr_library_sources(board.c)\n/*\n* Copyright (c) 2020, Antmicro\n*\n* SPDX-License-Identifier: Apache-2.0\n*/\n#include <zephyr/arch/cpu.h>\n#include <zephyr/init.h>\nstatic int mercury_xu_init(void)\n{\n\treturn 0;\n}\nSYS_INIT(mercury_xu_init, PRE_KERNEL_2,\n\t\tCONFIG_KERNEL_INIT_PRIORITY_DEFAULT);",
  "result": "diff --git a/boards/enclustra/mercury_xu/CMakeLists.txt b/boards/enclustra/mercury_xu/CMakeLists.txt\ndeleted file mode 100644\nindex f1877356e3b..00000000000\n--- a/boards/enclustra/mercury_xu/CMakeLists.txt\n+++ /dev/null\n@@ -1,5 +0,0 @@\n-# Copyright (c) 2020, Antmicro\n-# SPDX-License-Identifier: Apache-2.0\n-\n-zephyr_library()\n-zephyr_library_sources(board.c)\ndiff --git a/boards/enclustra/mercury_xu/board.c b/boards/enclustra/mercury_xu/board.c\ndeleted file mode 100644\nindex db436299a9c..00000000000\n--- a/boards/enclustra/mercury_xu/board.c\n+++ /dev/null\n@@ -1,16 +0,0 @@\n-/*\n- * Copyright (c) 2020, Antmicro\n- *\n- * SPDX-License-Identifier: Apache-2.0\n- */\n-\n-#include <zephyr/arch/cpu.h>\n-#include <zephyr/init.h>\n-\n-static int mercury_xu_init(void)\n-{\n-\treturn 0;\n-}\n-\n-SYS_INIT(mercury_xu_init, PRE_KERNEL_2,\n-\t\tCONFIG_KERNEL_INIT_PRIORITY_DEFAULT);"
},{
  "instruction": "doc: releases: migration-guide: add nRF53 L|HFXO changes",
  "input": "",
  "result": "diff --git a/doc/releases/migration-guide-4.0.rst b/doc/releases/migration-guide-4.0.rst\nindex a7389850226..992d797b06e 100644\n--- a/doc/releases/migration-guide-4.0.rst\n+++ b/doc/releases/migration-guide-4.0.rst\n@@ -102,6 +102,53 @@ Device Drivers and Devicetree\n   their driver API, users of these devices should ensure they pass appropriate values to\n   :c:func:`gpio_pin_set`. (:github:`65797`)\n \n+Clock control\n+=============\n+\n+* LFXO/HFXO (High/Low Frequency Crystal Oscillator) present in nRF53 series can\n+  now be configured using devicetree. The Kconfig options\n+  :kconfig:option:`CONFIG_SOC_ENABLE_LFXO`,\n+  :kconfig:option:`CONFIG_SOC_LFXO_CAP_EXTERNAL`,\n+  :kconfig:option:`CONFIG_SOC_LFXO_CAP_INT_6PF`,\n+  :kconfig:option:`CONFIG_SOC_LFXO_CAP_INT_7PF`,\n+  :kconfig:option:`CONFIG_SOC_LFXO_CAP_INT_9PF`,\n+  :kconfig:option:`CONFIG_SOC_HFXO_CAP_DEFAULT`,\n+  :kconfig:option:`CONFIG_SOC_HFXO_CAP_EXTERNAL`,\n+  :kconfig:option:`CONFIG_SOC_HFXO_CAP_INTERNAL` and\n+  :kconfig:option:`CONFIG_SOC_HFXO_CAP_INT_VALUE_X2` have been deprecated.\n+\n+  LFXO can now be configured like this:\n+\n+  .. code-block:: devicetree\n+\n+     /* use external capacitors */\n+     &lfxo {\n+           load-capacitors = \"external\";\n+     };\n+\n+     /* use internal capacitors (value needs to be selected: 6, 7, 9pF)\n+     &lfxo {\n+           load-capacitors = \"internal\";\n+           load-capacitance-picofarad = <...>;\n+     };\n+\n+  HFXO can now be configured like this:\n+\n+  .. code-block:: devicetree\n+\n+     /* use external capacitors */\n+     &hfxo {\n+           load-capacitors = \"external\";\n+     };\n+\n+     /* use internal capacitors (value needs to be selected: 7pF...20pF in 0.5pF\n+      * steps, units: femtofarads)\n+      */\n+     &hfxo {\n+           load-capacitors = \"internal\";\n+           load-capacitance-femtofarad = <...>;\n+     };\n+\n Controller Area Network (CAN)\n =============================\n "
},{
  "instruction": "soc: nordic: nrf53: deprecate all L|HFXO options",
  "input": "\tdefault y\n\tdefault SOC_LFXO_CAP_INT_7PF",
  "result": "diff --git a/soc/nordic/nrf53/Kconfig b/soc/nordic/nrf53/Kconfig\nindex 56676ba6db3..92ed16ac3e2 100644\n--- a/soc/nordic/nrf53/Kconfig\n+++ b/soc/nordic/nrf53/Kconfig\n@@ -204,8 +204,12 @@ if !TRUSTED_EXECUTION_NONSECURE || BUILD_WITH_TFM\n \n config SOC_ENABLE_LFXO\n \tbool \"LFXO\"\n-\tdefault y\n+\tselect DEPRECATED\n \thelp\n+\t  This option is deprecated, use DT instead. For this option to apply,\n+\t  make sure to select either \"internal\" or \"external\" in the\n+\t  load-capacitors property.\n+\n \t  Enable the low-frequency oscillator (LFXO) functionality on XL1 and\n \t  XL2 pins.\n \t  This option must be enabled if either application or network core is\n@@ -215,19 +219,49 @@ config SOC_ENABLE_LFXO\n choice SOC_LFXO_LOAD_CAPACITANCE\n \tprompt \"LFXO load capacitance\"\n \tdepends on SOC_ENABLE_LFXO\n-\tdefault SOC_LFXO_CAP_INT_7PF\n \n config SOC_LFXO_CAP_EXTERNAL\n \tbool \"Use external load capacitors\"\n+\tselect DEPRECATED\n+\thelp\n+\t  This option is deprecated, use DT instead. Example configuration:\n+\n+\t  &lfxo {\n+\t      load-capacitors = \"external\";\n+\t  };\n \n config SOC_LFXO_CAP_INT_6PF\n \tbool \"6 pF internal load capacitance\"\n+\tselect DEPRECATED\n+\thelp\n+\t  This option is deprecated, use DT instead. Example configuration:\n+\n+\t  &lfxo {\n+\t      load-capacitors = \"internal\";\n+\t      load-capacitance-picofarad = <6>;\n+\t  };\n \n config SOC_LFXO_CAP_INT_7PF\n \tbool \"7 pF internal load capacitance\"\n+\tselect DEPRECATED\n+\thelp\n+\t  This option is deprecated, use DT instead. Example configuration:\n+\n+\t  &lfxo {\n+\t      load-capacitors = \"internal\";\n+\t      load-capacitance-picofarad = <7>;\n+\t  };\n \n config SOC_LFXO_CAP_INT_9PF\n \tbool \"9 pF internal load capacitance\"\n+\tselect DEPRECATED\n+\thelp\n+\t  This option is deprecated, use DT instead. Example configuration:\n+\n+\t  &lfxo {\n+\t      load-capacitors = \"internal\";\n+\t      load-capacitance-picofarad = <9>;\n+\t  };\n \n endchoice\n \n@@ -238,6 +272,9 @@ choice SOC_HFXO_LOAD_CAPACITANCE\n config SOC_HFXO_CAP_DEFAULT\n \tbool \"SoC default\"\n \thelp\n+\t  This option is deprecated, use DT instead. For this configuration to\n+\t  apply, no DT changes are required from the SoC DT file defaults.\n+\n \t  When this option is used, the SoC initialization routine does not\n \t  touch the XOSC32MCAPS register value, so the default setting for\n \t  the SoC is in effect. Please note that this may not necessarily be\n@@ -246,10 +283,27 @@ config SOC_HFXO_CAP_DEFAULT\n \n config SOC_HFXO_CAP_EXTERNAL\n \tbool \"Use external load capacitors\"\n+\tselect DEPRECATED\n+\thelp\n+\t  This option is deprecated, use DT instead. Example configuration:\n+\n+\t  &hfxo {\n+\t      load-capacitors = \"external\";\n+\t  };\n \n config SOC_HFXO_CAP_INTERNAL\n \tbool \"Use internal load capacitors\"\n \tdepends on NRF_SOC_SECURE_SUPPORTED\n+\tselect DEPRECATED\n+\thelp\n+\t  This option is deprecated, use DT instead. Example configuration:\n+\n+\t  &hfxo {\n+\t      load-capacitors = \"internal\";\n+\t      ...\n+\t  };\n+\n+\t  See CONFIG_SOC_HFXO_CAP_INT_VALUE_X2 for more information.\n \n endchoice\n \n@@ -258,6 +312,13 @@ config SOC_HFXO_CAP_INT_VALUE_X2\n \tdepends on SOC_HFXO_CAP_INTERNAL\n \trange 14 40\n \thelp\n+\t  This option is deprecated, use DT instead. Example configuration:\n+\n+\t  &hfxo {\n+\t      load-capacitors = \"internal\";\n+\t      load-capacitance-femtofarad = <7000>;\n+\t  };\n+\n \t  Internal capacitors ranging from 7.0 pF to 20.0 pF in 0.5 pF steps\n \t  can be enabled on pins XC1 and XC2. This option specifies doubled\n \t  capacitance value for the two capacitors. Set it to 14 to get 7.0 pF"
},{
  "instruction": "boards: nrf53*: add L|HFXO configurations",
  "input": "CONFIG_SOC_HFXO_CAP_INTERNAL=y\nCONFIG_SOC_HFXO_CAP_INT_VALUE_X2=27",
  "result": "diff --git a/boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp_common.dtsi b/boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp_common.dtsi\nindex af4f1cddeae..1aa2bb22660 100644\n--- a/boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp_common.dtsi\n+++ b/boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp_common.dtsi\n@@ -139,6 +139,16 @@\n \tstatus = \"okay\";\n };\n \n+&lfxo {\n+\tload-capacitors = \"internal\";\n+\tload-capacitance-picofarad = <7>;\n+};\n+\n+&hfxo {\n+\tload-capacitors = \"internal\";\n+\tload-capacitance-femtofarad = <13500>;\n+};\n+\n &adc {\n \tstatus = \"okay\";\n };\ndiff --git a/boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp_defconfig b/boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp_defconfig\nindex 2de02d0c2f0..115c1ec2952 100644\n--- a/boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp_defconfig\n+++ b/boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp_defconfig\n@@ -21,5 +21,3 @@ CONFIG_UART_CONSOLE=y\n \n # Setup clocks\n CONFIG_CLOCK_CONTROL_NRF_K32SRC_250PPM=y\n-CONFIG_SOC_HFXO_CAP_INTERNAL=y\n-CONFIG_SOC_HFXO_CAP_INT_VALUE_X2=27\ndiff --git a/boards/nordic/nrf5340_audio_dk/nrf5340_audio_dk_nrf5340_cpuapp_common.dtsi b/boards/nordic/nrf5340_audio_dk/nrf5340_audio_dk_nrf5340_cpuapp_common.dtsi\nindex 70517a604ea..71c05529cc1 100644\n--- a/boards/nordic/nrf5340_audio_dk/nrf5340_audio_dk_nrf5340_cpuapp_common.dtsi\n+++ b/boards/nordic/nrf5340_audio_dk/nrf5340_audio_dk_nrf5340_cpuapp_common.dtsi\n@@ -84,6 +84,11 @@\n \tstatus = \"okay\";\n };\n \n+&lfxo {\n+\tload-capacitors = \"internal\";\n+\tload-capacitance-picofarad = <7>;\n+};\n+\n &adc {\n \tstatus = \"okay\";\n \t#address-cells = <1>;\ndiff --git a/boards/nordic/nrf5340dk/nrf5340_cpuapp_common.dtsi b/boards/nordic/nrf5340dk/nrf5340_cpuapp_common.dtsi\nindex 21701d9922d..71060ba1ba2 100644\n--- a/boards/nordic/nrf5340dk/nrf5340_cpuapp_common.dtsi\n+++ b/boards/nordic/nrf5340dk/nrf5340_cpuapp_common.dtsi\n@@ -65,6 +65,11 @@\n \tstatus = \"okay\";\n };\n \n+&lfxo {\n+\tload-capacitors = \"internal\";\n+\tload-capacitance-picofarad = <7>;\n+};\n+\n &adc {\n \tstatus = \"okay\";\n };\ndiff --git a/boards/nordic/thingy53/thingy53_nrf5340_cpuapp.dts b/boards/nordic/thingy53/thingy53_nrf5340_cpuapp.dts\nindex d058f8da95b..41d287c8eba 100644\n--- a/boards/nordic/thingy53/thingy53_nrf5340_cpuapp.dts\n+++ b/boards/nordic/thingy53/thingy53_nrf5340_cpuapp.dts\n@@ -36,3 +36,8 @@\n &vregh {\n \tstatus = \"okay\";\n };\n+\n+&lfxo {\n+\tload-capacitors = \"internal\";\n+\tload-capacitance-picofarad = <7>;\n+};\ndiff --git a/boards/nordic/thingy53/thingy53_nrf5340_cpuapp_ns.dts b/boards/nordic/thingy53/thingy53_nrf5340_cpuapp_ns.dts\nindex 84fb9fbfc94..1ac7536fb00 100644\n--- a/boards/nordic/thingy53/thingy53_nrf5340_cpuapp_ns.dts\n+++ b/boards/nordic/thingy53/thingy53_nrf5340_cpuapp_ns.dts\n@@ -34,3 +34,8 @@\n &vregh {\n \tstatus = \"okay\";\n };\n+\n+&lfxo {\n+\tload-capacitors = \"internal\";\n+\tload-capacitance-picofarad = <7>;\n+};\ndiff --git a/boards/panasonic/pan1783/pan1783_nrf5340_cpuapp_common.dtsi b/boards/panasonic/pan1783/pan1783_nrf5340_cpuapp_common.dtsi\nindex 421ca523925..ad66cff5c5d 100644\n--- a/boards/panasonic/pan1783/pan1783_nrf5340_cpuapp_common.dtsi\n+++ b/boards/panasonic/pan1783/pan1783_nrf5340_cpuapp_common.dtsi\n@@ -171,6 +171,11 @@\n \tstatus = \"okay\";\n };\n \n+&lfxo {\n+\tload-capacitors = \"internal\";\n+\tload-capacitance-picofarad = <7>;\n+};\n+\n &adc {\n \tstatus = \"okay\";\n };\ndiff --git a/boards/raytac/mdbt53_db_40/raytac_mdbt53_db_40_nrf5340_cpuapp_common.dts b/boards/raytac/mdbt53_db_40/raytac_mdbt53_db_40_nrf5340_cpuapp_common.dts\nindex bd89fa1664f..0db7bc0f933 100644\n--- a/boards/raytac/mdbt53_db_40/raytac_mdbt53_db_40_nrf5340_cpuapp_common.dts\n+++ b/boards/raytac/mdbt53_db_40/raytac_mdbt53_db_40_nrf5340_cpuapp_common.dts\n@@ -108,6 +108,11 @@\n \tstatus = \"okay\";\n };\n \n+&lfxo {\n+\tload-capacitors = \"internal\";\n+\tload-capacitance-picofarad = <7>;\n+};\n+\n &adc {\n \tstatus = \"okay\";\n };\ndiff --git a/boards/raytac/mdbt53v_db_40/raytac_mdbt53v_db_40_nrf5340_cpuapp_common.dts b/boards/raytac/mdbt53v_db_40/raytac_mdbt53v_db_40_nrf5340_cpuapp_common.dts\nindex 71811564df1..add880e3518 100644\n--- a/boards/raytac/mdbt53v_db_40/raytac_mdbt53v_db_40_nrf5340_cpuapp_common.dts\n+++ b/boards/raytac/mdbt53v_db_40/raytac_mdbt53v_db_40_nrf5340_cpuapp_common.dts\n@@ -87,6 +87,11 @@\n \tstatus = \"okay\";\n };\n \n+&lfxo {\n+\tload-capacitors = \"internal\";\n+\tload-capacitance-picofarad = <7>;\n+};\n+\n &adc {\n \tstatus = \"okay\";\n };"
},{
  "instruction": "boards: bl5340_dvk: remove redundant LFXO option",
  "input": "CONFIG_SOC_LFXO_CAP_INT_7PF=y",
  "result": "diff --git a/boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp_defconfig b/boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp_defconfig\nindex b60faf810bb..2de02d0c2f0 100644\n--- a/boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp_defconfig\n+++ b/boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp_defconfig\n@@ -21,6 +21,5 @@ CONFIG_UART_CONSOLE=y\n \n # Setup clocks\n CONFIG_CLOCK_CONTROL_NRF_K32SRC_250PPM=y\n-CONFIG_SOC_LFXO_CAP_INT_7PF=y\n CONFIG_SOC_HFXO_CAP_INTERNAL=y\n CONFIG_SOC_HFXO_CAP_INT_VALUE_X2=27"
},{
  "instruction": "soc: nordic: nrf53: allow configuring L|HFXO from DT",
  "input": "#if defined(CONFIG_SOC_HFXO_CAP_INTERNAL)\n#if defined(CONFIG_SOC_HFXO_CAP_INTERNAL)\n#if defined(CONFIG_SOC_ENABLE_LFXO)\n\tnrf_oscillators_lfxo_cap_set(NRF_OSCILLATORS,\n\t\tIS_ENABLED(CONFIG_SOC_LFXO_CAP_INT_6PF) ?\n\t\t\tNRF_OSCILLATORS_LFXO_CAP_6PF :\n\t\tIS_ENABLED(CONFIG_SOC_LFXO_CAP_INT_7PF) ?\n\t\t\tNRF_OSCILLATORS_LFXO_CAP_7PF :\n\t\tIS_ENABLED(CONFIG_SOC_LFXO_CAP_INT_9PF) ?\n\t\t\tNRF_OSCILLATORS_LFXO_CAP_9PF :\n\t\t\tNRF_OSCILLATORS_LFXO_CAP_EXTERNAL);\n#endif /* defined(CONFIG_SOC_ENABLE_LFXO) */\n#if defined(CONFIG_SOC_HFXO_CAP_INTERNAL)\n\t\t((slope + 56) * (CONFIG_SOC_HFXO_CAP_INT_VALUE_X2 - 14)\n#elif defined(CONFIG_SOC_HFXO_CAP_EXTERNAL)",
  "result": "diff --git a/soc/nordic/common/soc_secure.h b/soc/nordic/common/soc_secure.h\nindex cb7054962f2..e4b34a9bf64 100644\n--- a/soc/nordic/common/soc_secure.h\n+++ b/soc/nordic/common/soc_secure.h\n@@ -34,7 +34,8 @@ static inline int soc_secure_mem_read(void *dst, void *src, size_t len)\n /* Include these soc_secure_* functions only when the FICR is mapped as secure only */\n #if defined(NRF_FICR_S)\n #if defined(CONFIG_TRUSTED_EXECUTION_NONSECURE)\n-#if defined(CONFIG_SOC_HFXO_CAP_INTERNAL)\n+#if defined(CONFIG_SOC_HFXO_CAP_INTERNAL) || \\\n+\tDT_ENUM_HAS_VALUE(DT_NODELABEL(hfxo), load_capacitors, internal)\n static inline uint32_t soc_secure_read_xosc32mtrim(void)\n {\n \tuint32_t xosc32mtrim;\n@@ -60,7 +61,8 @@ static inline void soc_secure_read_deviceid(uint32_t deviceid[2])\n }\n \n #else /* defined(CONFIG_TRUSTED_EXECUTION_NONSECURE) */\n-#if defined(CONFIG_SOC_HFXO_CAP_INTERNAL)\n+#if defined(CONFIG_SOC_HFXO_CAP_INTERNAL) || \\\n+\tDT_ENUM_HAS_VALUE(DT_NODELABEL(hfxo), load_capacitors, internal)\n static inline uint32_t soc_secure_read_xosc32mtrim(void)\n {\n \treturn NRF_FICR_S->XOSC32MTRIM;\ndiff --git a/soc/nordic/nrf53/soc.c b/soc/nordic/nrf53/soc.c\nindex 46e8e5ca20d..35a13be1b9a 100644\n--- a/soc/nordic/nrf53/soc.c\n+++ b/soc/nordic/nrf53/soc.c\n@@ -56,6 +56,37 @@\n \tDT_FOREACH_CHILD(node_id, ALL_GPIOS_IN_NODE)\n #endif\n \n+#ifdef CONFIG_SOC_NRF5340_CPUAPP\n+#define LFXO_NODE DT_NODELABEL(lfxo)\n+#define HFXO_NODE DT_NODELABEL(hfxo)\n+\n+/* LFXO config from DT */\n+#if DT_ENUM_HAS_VALUE(LFXO_NODE, load_capacitors, external)\n+#define LFXO_CAP NRF_OSCILLATORS_LFXO_CAP_EXTERNAL\n+#elif DT_ENUM_HAS_VALUE(LFXO_NODE, load_capacitors, internal)\n+#define LFXO_CAP (DT_ENUM_IDX(LFXO_NODE, load_capacitance_picofarad) + 1U)\n+#else\n+/* LFXO config from legacy Kconfig */\n+#if defined(CONFIG_SOC_LFXO_CAP_INT_6PF)\n+#define LFXO_CAP NRF_OSCILLATORS_LFXO_CAP_6PF\n+#elif defined(CONFIG_SOC_LFXO_CAP_INT_7PF)\n+#define LFXO_CAP NRF_OSCILLATORS_LFXO_CAP_7PF\n+#elif defined(CONFIG_SOC_LFXO_CAP_INT_9PF)\n+#define LFXO_CAP NRF_OSCILLATORS_LFXO_CAP_9PF\n+#else\n+#define LFXO_CAP NRF_OSCILLATORS_LFXO_CAP_EXTERNAL\n+#endif\n+#endif\n+\n+/* HFXO config from DT */\n+#if DT_ENUM_HAS_VALUE(HFXO_NODE, load_capacitors, internal)\n+#define HFXO_CAP_VAL_X2 (DT_PROP(HFXO_NODE, load_capacitance_femtofarad)) * 2U / 1000U\n+#elif defined(CONFIG_SOC_HFXO_CAP_INTERNAL)\n+/* HFXO config from legacy Kconfig */\n+#define HFXO_CAP_VAL_X2 CONFIG_SOC_HFXO_CAP_INT_VALUE_X2\n+#endif\n+#endif /* CONFIG_SOC_NRF5340_CPUAPP */\n+\n #define LOG_LEVEL CONFIG_SOC_LOG_LEVEL\n LOG_MODULE_REGISTER(soc);\n \n@@ -472,15 +503,9 @@ static int nordicsemi_nrf53_init(void)\n \tnrf_nvmc_icache_config_set(NRF_NVMC, NRF_NVMC_ICACHE_ENABLE);\n #endif\n \n-#if defined(CONFIG_SOC_ENABLE_LFXO)\n-\tnrf_oscillators_lfxo_cap_set(NRF_OSCILLATORS,\n-\t\tIS_ENABLED(CONFIG_SOC_LFXO_CAP_INT_6PF) ?\n-\t\t\tNRF_OSCILLATORS_LFXO_CAP_6PF :\n-\t\tIS_ENABLED(CONFIG_SOC_LFXO_CAP_INT_7PF) ?\n-\t\t\tNRF_OSCILLATORS_LFXO_CAP_7PF :\n-\t\tIS_ENABLED(CONFIG_SOC_LFXO_CAP_INT_9PF) ?\n-\t\t\tNRF_OSCILLATORS_LFXO_CAP_9PF :\n-\t\t\tNRF_OSCILLATORS_LFXO_CAP_EXTERNAL);\n+#ifdef CONFIG_SOC_NRF5340_CPUAPP\n+#if defined(LFXO_CAP)\n+\tnrf_oscillators_lfxo_cap_set(NRF_OSCILLATORS, LFXO_CAP);\n #if !defined(CONFIG_BUILD_WITH_TFM)\n \t/* This can only be done from secure code.\n \t * This is handled by the TF-M platform so we skip it when TF-M is\n@@ -489,8 +514,8 @@ static int nordicsemi_nrf53_init(void)\n \tnrf_gpio_pin_control_select(PIN_XL1, NRF_GPIO_PIN_SEL_PERIPHERAL);\n \tnrf_gpio_pin_control_select(PIN_XL2, NRF_GPIO_PIN_SEL_PERIPHERAL);\n #endif /* !defined(CONFIG_BUILD_WITH_TFM) */\n-#endif /* defined(CONFIG_SOC_ENABLE_LFXO) */\n-#if defined(CONFIG_SOC_HFXO_CAP_INTERNAL)\n+#endif /* defined(LFXO_CAP) */\n+#if defined(HFXO_CAP_VAL_X2)\n \t/* This register is only accessible from secure code. */\n \tuint32_t xosc32mtrim = soc_secure_read_xosc32mtrim();\n \t/* The SLOPE field is in the two's complement form, hence this special\n@@ -515,13 +540,15 @@ static int nordicsemi_nrf53_init(void)\n \t * value between 7.0 pF and 20.0 pF in 0.5 pF steps.\n \t */\n \tuint32_t capvalue =\n-\t\t((slope + 56) * (CONFIG_SOC_HFXO_CAP_INT_VALUE_X2 - 14)\n+\t\t((slope + 56) * (HFXO_CAP_VAL_X2 - 14)\n \t\t + ((offset - 8) << 4) + 32) >> 6;\n \n \tnrf_oscillators_hfxo_cap_set(NRF_OSCILLATORS, true, capvalue);\n-#elif defined(CONFIG_SOC_HFXO_CAP_EXTERNAL)\n+#elif defined(CONFIG_SOC_HFXO_CAP_EXTERNAL) || \\\n+\tDT_ENUM_HAS_VALUE(HFXO_NODE, load_capacitors, external)\n \tnrf_oscillators_hfxo_cap_set(NRF_OSCILLATORS, false, 0);\n #endif\n+#endif /* CONFIG_SOC_NRF5340_CPUAPP */\n \n #if defined(CONFIG_SOC_DCDC_NRF53X_APP) || \\\n \t(DT_PROP(DT_NODELABEL(vregmain), regulator_initial_mode) == NRF5X_REG_MODE_DCDC)"
},{
  "instruction": "dts: arm: nordic: nrf5340: instantiate HF crystal oscillator",
  "input": "",
  "result": "diff --git a/dts/arm/nordic/nrf5340_cpuapp_peripherals.dtsi b/dts/arm/nordic/nrf5340_cpuapp_peripherals.dtsi\nindex 24ee005871b..f976061e989 100644\n--- a/dts/arm/nordic/nrf5340_cpuapp_peripherals.dtsi\n+++ b/dts/arm/nordic/nrf5340_cpuapp_peripherals.dtsi\n@@ -21,6 +21,12 @@ oscillators: clock-controller@4000 {\n \t\t#clock-cells = <0>;\n \t\tclock-frequency = <32768>;\n \t};\n+\n+\thfxo: hfxo {\n+\t\tcompatible = \"nordic,nrf53-hfxo\";\n+\t\t#clock-cells = <0>;\n+\t\tclock-frequency = <DT_FREQ_M(32)>;\n+\t};\n };\n \n regulators: regulator@4000 {"
},{
  "instruction": "dts: arm: nordic: nrf5340: instantiate LF crystal oscillator",
  "input": "",
  "result": "diff --git a/dts/arm/nordic/nrf5340_cpuapp_peripherals.dtsi b/dts/arm/nordic/nrf5340_cpuapp_peripherals.dtsi\nindex 1540ad2dea0..24ee005871b 100644\n--- a/dts/arm/nordic/nrf5340_cpuapp_peripherals.dtsi\n+++ b/dts/arm/nordic/nrf5340_cpuapp_peripherals.dtsi\n@@ -15,6 +15,12 @@ dcnf: dcnf@0 {\n oscillators: clock-controller@4000 {\n \tcompatible = \"nordic,nrf53-oscillators\";\n \treg = <0x4000 0x1000>;\n+\n+\tlfxo: lfxo {\n+\t\tcompatible = \"nordic,nrf53-lfxo\";\n+\t\t#clock-cells = <0>;\n+\t\tclock-frequency = <32768>;\n+\t};\n };\n \n regulators: regulator@4000 {"
},{
  "instruction": "dts: arm: nordic: nrf5340: adjust OSCILLATORS IP description",
  "input": "oscillators: oscillator@4000 {\n\tcompatible = \"nordic,nrf-oscillators\";\n\tstatus = \"okay\";\n# Copyright (c) 2022 Nordic Semiconductor ASA\n# SPDX-License-Identifier: Apache-2.0\ndescription: Nordic nRF family OSCILLATORS (Oscillator Control)\ncompatible: \"nordic,nrf-oscillators\"\ninclude: base.yaml\nproperties:\n reg:\n   required: true",
  "result": "diff --git a/dts/arm/nordic/nrf5340_cpuapp_peripherals.dtsi b/dts/arm/nordic/nrf5340_cpuapp_peripherals.dtsi\nindex 7d79b227be2..1540ad2dea0 100644\n--- a/dts/arm/nordic/nrf5340_cpuapp_peripherals.dtsi\n+++ b/dts/arm/nordic/nrf5340_cpuapp_peripherals.dtsi\n@@ -12,10 +12,9 @@ dcnf: dcnf@0 {\n \tstatus = \"okay\";\n };\n \n-oscillators: oscillator@4000 {\n-\tcompatible = \"nordic,nrf-oscillators\";\n+oscillators: clock-controller@4000 {\n+\tcompatible = \"nordic,nrf53-oscillators\";\n \treg = <0x4000 0x1000>;\n-\tstatus = \"okay\";\n };\n \n regulators: regulator@4000 {\ndiff --git a/dts/bindings/clock/nordic,nrf-oscillators.yaml b/dts/bindings/clock/nordic,nrf-oscillators.yaml\ndeleted file mode 100644\nindex 2c3a4bcc720..00000000000\n--- a/dts/bindings/clock/nordic,nrf-oscillators.yaml\n+++ /dev/null\n@@ -1,12 +0,0 @@\n-# Copyright (c) 2022 Nordic Semiconductor ASA\n-# SPDX-License-Identifier: Apache-2.0\n-\n-description: Nordic nRF family OSCILLATORS (Oscillator Control)\n-\n-compatible: \"nordic,nrf-oscillators\"\n-\n-include: base.yaml\n-\n-properties:\n-  reg:\n-    required: true\ndiff --git a/dts/bindings/clock/nordic,nrf53-oscillators.yaml b/dts/bindings/clock/nordic,nrf53-oscillators.yaml\nnew file mode 100644\nindex 00000000000..57126102955\n--- /dev/null\n+++ b/dts/bindings/clock/nordic,nrf53-oscillators.yaml\n@@ -0,0 +1,12 @@\n+# Copyright (c) 2024 Nordic Semiconductor ASA\n+# SPDX-License-Identifier: Apache-2.0\n+\n+description: Nordic nRF53X OSCILLATORS (Oscillator Control)\n+\n+compatible: \"nordic,nrf53-oscillators\"\n+\n+include: base.yaml\n+\n+properties:\n+  reg:\n+    required: true"
}]
