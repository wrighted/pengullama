[{
  "instruction": "scripts: twister: Don't use match/case statements",
  "input": "       match(status):\n           case TwisterStatus.PASS:\n               color = Fore.GREEN\n           case TwisterStatus.SKIP | TwisterStatus.FILTER | TwisterStatus.BLOCK:\n               color = Fore.YELLOW\n           case TwisterStatus.FAIL | TwisterStatus.ERROR:\n               color = Fore.RED\n           case TwisterStatus.STARTED | TwisterStatus.NONE:\n               color = Fore.MAGENTA\n           case _:\n               color = Fore.RESET\n       return color",
  "result": "-        match(status):\n-            case TwisterStatus.PASS:\n-                color = Fore.GREEN\n-            case TwisterStatus.SKIP | TwisterStatus.FILTER | TwisterStatus.BLOCK:\n-                color = Fore.YELLOW\n-            case TwisterStatus.FAIL | TwisterStatus.ERROR:\n-                color = Fore.RED\n-            case TwisterStatus.STARTED | TwisterStatus.NONE:\n-                color = Fore.MAGENTA\n-            case _:\n-                color = Fore.RESET\n-        return color\n+        status2color = {\n+            TwisterStatus.PASS: Fore.GREEN,\n+            TwisterStatus.SKIP: Fore.YELLOW,\n+            TwisterStatus.FILTER: Fore.YELLOW,\n+            TwisterStatus.BLOCK: Fore.YELLOW,\n+            TwisterStatus.FAIL: Fore.RED,\n+            TwisterStatus.ERROR: Fore.RED,\n+            TwisterStatus.STARTED: Fore.MAGENTA,\n+            TwisterStatus.NONE: Fore.MAGENTA\n+        }\n+        return status2color[status] if status in status2color else Fore.RESET"
},{
  "instruction": "drivers: auxdisplay: Remove unused variables",
  "input": "\tint rc = 0;\n\tuint8_t inst;\n\tstruct auxdisplay_pt6314_data *data = dev->data;\n\tuint8_t inst;",
  "result": "-\tint rc = 0;\n-\tuint8_t inst;\n-\tstruct auxdisplay_pt6314_data *data = dev->data;\n-\tuint8_t inst;"
},{
  "instruction": "tests: drivers: build_all: led_strip: Add RaspberryPi Pico PIO driver",
  "input": "",
  "result": "+  drivers.led_strip.build.rpi_pico_pio:\n+    build_only: true\n+    platform_allow: rpi_pico"
},{
  "instruction": "drivers: led_strip: tlc5971: Enable when the dt-node exists",
  "input": "CONFIG_TLC5971_STRIP=y",
  "result": "+\tdepends on DT_HAS_TI_TLC5971_ENABLED\n+\tdefault y\n-CONFIG_TLC5971_STRIP=y"
},{
  "instruction": "soc: riscv: andes_v5: fix PMA compilation warnings",
  "input": "#ifdef CONFIG_NOCACHE_MEMORY",
  "result": "+#ifdef CONFIG_NOCACHE_MEMORY\n-#ifdef CONFIG_NOCACHE_MEMORY"
},{
  "instruction": "samples: wifi: ESP32-S2 sample configuration",
  "input": "CONFIG_HEAP_MEM_POOL_SIZE=34816\n# decrease packet count and size to save RAM\nCONFIG_NET_PKT_RX_COUNT=7\nCONFIG_NET_PKT_TX_COUNT=7\nCONFIG_NET_BUF_RX_COUNT=7\nCONFIG_NET_BUF_TX_COUNT=7\nCONFIG_ESP32_WIFI_IRAM_OPT=n\nCONFIG_ESP32_WIFI_RX_IRAM_OPT=n",
  "result": "-CONFIG_HEAP_MEM_POOL_SIZE=34816\n-\n-# decrease packet count and size to save RAM\n-CONFIG_NET_PKT_RX_COUNT=7\n-CONFIG_NET_PKT_TX_COUNT=7\n-CONFIG_NET_BUF_RX_COUNT=7\n-CONFIG_NET_BUF_TX_COUNT=7\n-\n-CONFIG_ESP32_WIFI_IRAM_OPT=n\n-CONFIG_ESP32_WIFI_RX_IRAM_OPT=n"
},{
  "instruction": "soc: esp32c6: Add runtime heap symbols",
  "input": " ASSERT(((__bss_end - ORIGIN(sram0_0_seg)) <= LENGTH(sram0_0_seg)), \"DRAM segment data does not fit.\")\n#define DRAM_STACK_START         0x4087c610\n#define BOOTLOADER_IRAM_LOADER_SEG_START\t\\\n\t\t(BOOTLOADER_USER_SRAM_END -\tBOOTLOADER_IRAM_LOADER_SEG_LEN)",
  "result": "+_heap_sentry = DRAM_RESERVED_START;\n+\n-  ASSERT(((__bss_end - ORIGIN(sram0_0_seg)) <= LENGTH(sram0_0_seg)), \"DRAM segment data does not fit.\")\n+  ASSERT(((_end - ORIGIN(sram0_0_seg)) <= LENGTH(sram0_0_seg)), \"SRAM code/data does not fit.\")\n-#define DRAM_STACK_START         0x4087c610\n+#define DRAM_BUFFERS_END         0x4087c610\n+#define DRAM_STACK_START         DRAM_BUFFERS_END\n+/* Set the limit for the application runtime dynamic allocations */\n+#define DRAM_RESERVED_START      DRAM_BUFFERS_END\n+\n-#define BOOTLOADER_IRAM_LOADER_SEG_START\t\\\n-\t\t(BOOTLOADER_USER_SRAM_END -\tBOOTLOADER_IRAM_LOADER_SEG_LEN)\n+#define BOOTLOADER_IRAM_LOADER_SEG_START (BOOTLOADER_USER_SRAM_END - BOOTLOADER_IRAM_LOADER_SEG_LEN)"
},{
  "instruction": "soc: esp32c3: ESP WiFi heap",
  "input": " ASSERT(((__bss_end - ORIGIN(dram0_0_seg)) <= LENGTH(dram0_0_seg)), \"DRAM segment data does not fit.\")\n#define BOOTLOADER_IRAM_LOADER_SEG_END (BOOTLOADER_USER_DRAM_END + \\\n\t\t\t\t\tBOOTLOADER_STACK_OVERHEAD + IRAM_DRAM_OFFSET)\n#define BOOTLOADER_IRAM_LOADER_SEG_START (BOOTLOADER_IRAM_LOADER_SEG_END - \\\n\t\t\t\t\tBOOTLOADER_IRAM_LOADER_SEG_LEN)\n#define BOOTLOADER_IRAM_SEG_START (BOOTLOADER_IRAM_LOADER_SEG_START - BOOTLOADER_IRAM_SEG_LEN)\n#define BOOTLOADER_DRAM_SEG_START (BOOTLOADER_IRAM_SEG_START - IRAM_DRAM_OFFSET - \\\n\t\t\t\t\tBOOTLOADER_DRAM_SEG_LEN)",
  "result": "+/* Stack sentry */\n+_heap_sentry = DRAM_RESERVED_START;\n+\n-  ASSERT(((__bss_end - ORIGIN(dram0_0_seg)) <= LENGTH(dram0_0_seg)), \"DRAM segment data does not fit.\")\n+  ASSERT(((_end - ORIGIN(dram0_0_seg)) <= LENGTH(dram0_0_seg)), \"SRAM instruction/data does not fit.\")\n+#define SRAM1_SIZE         0x60000\n+#define DRAM_BUFFERS_END         0x3fccc000\n+/* Set the limit for the application runtime dynamic allocations */\n+#define DRAM_RESERVED_START      DRAM_BUFFERS_END\n+\n-#define BOOTLOADER_IRAM_LOADER_SEG_END (BOOTLOADER_USER_DRAM_END + \\\n-\t\t\t\t\tBOOTLOADER_STACK_OVERHEAD + IRAM_DRAM_OFFSET)\n-#define BOOTLOADER_IRAM_LOADER_SEG_START (BOOTLOADER_IRAM_LOADER_SEG_END - \\\n-\t\t\t\t\tBOOTLOADER_IRAM_LOADER_SEG_LEN)\n-#define BOOTLOADER_IRAM_SEG_START (BOOTLOADER_IRAM_LOADER_SEG_START - BOOTLOADER_IRAM_SEG_LEN)\n-#define BOOTLOADER_DRAM_SEG_START (BOOTLOADER_IRAM_SEG_START - IRAM_DRAM_OFFSET - \\\n-\t\t\t\t\tBOOTLOADER_DRAM_SEG_LEN)\n+#define BOOTLOADER_IRAM_LOADER_SEG_END \\\n+\t\t(BOOTLOADER_USER_DRAM_END + BOOTLOADER_STACK_OVERHEAD + IRAM_DRAM_OFFSET)\n+#define BOOTLOADER_IRAM_LOADER_SEG_START \\\n+\t\t(BOOTLOADER_IRAM_LOADER_SEG_END - BOOTLOADER_IRAM_LOADER_SEG_LEN)\n+#define BOOTLOADER_IRAM_SEG_START \\\n+\t\t(BOOTLOADER_IRAM_LOADER_SEG_START - BOOTLOADER_IRAM_SEG_LEN)\n+#define BOOTLOADER_DRAM_SEG_START \\\n+\t\t(BOOTLOADER_IRAM_SEG_START - IRAM_DRAM_OFFSET - BOOTLOADER_DRAM_SEG_LEN)"
},{
  "instruction": "manifest: update hal_espressif",
  "input": "     revision: de5ea5987baaa5492fb9cc0d01222e8b07c78a70",
  "result": "-      revision: de5ea5987baaa5492fb9cc0d01222e8b07c78a70\n+      revision: 0bd00ce82fcf48281c9206fc28bd39785f059d64"
},{
  "instruction": "riscv: support dumping privilege stack during coredump",
  "input": "",
  "result": "+\tselect ARCH_SUPPORTS_COREDUMP_PRIV_STACKS\n+#include <zephyr/kernel.h>\n+\n+#if defined(CONFIG_DEBUG_COREDUMP_DUMP_THREAD_PRIV_STACK)\n+void arch_coredump_priv_stack_dump(struct k_thread *thread)\n+{\n+\tuintptr_t start_addr, end_addr;\n+\n+\t/* See: zephyr/include/zephyr/arch/riscv/arch.h */\n+\tif (IS_ENABLED(CONFIG_PMP_POWER_OF_TWO_ALIGNMENT)) {\n+\t\tstart_addr = thread->arch.priv_stack_start + Z_RISCV_STACK_GUARD_SIZE;\n+\t} else {\n+\t\tstart_addr = thread->stack_info.start - CONFIG_PRIVILEGED_STACK_SIZE;\n+\t}\n+\tend_addr = Z_STACK_PTR_ALIGN(thread->arch.priv_stack_start + K_KERNEL_STACK_RESERVED +\n+\t\t\t\t     CONFIG_PRIVILEGED_STACK_SIZE);\n+\n+\tcoredump_memory_dump(start_addr, end_addr);\n+}\n+#endif /* CONFIG_DEBUG_COREDUMP_DUMP_THREAD_PRIV_STACK */"
},{
  "instruction": "soc: cdns/dc233c: advertise coredump with privilege stack",
  "input": "",
  "result": "+\tselect ARCH_SUPPORTS_COREDUMP\n+\tselect ARCH_SUPPORTS_COREDUMP_PRIV_STACKS"
},{
  "instruction": "xtensa: coredump: support dumping privilege stack",
  "input": "",
  "result": "+#include <zephyr/kernel.h>\n+\n+#if defined(CONFIG_DEBUG_COREDUMP_DUMP_THREAD_PRIV_STACK)\n+void arch_coredump_priv_stack_dump(struct k_thread *thread)\n+{\n+\tstruct xtensa_thread_stack_header *hdr_stack_obj;\n+\tuintptr_t start_addr, end_addr;\n+\n+\thdr_stack_obj = (struct xtensa_thread_stack_header *)thread->stack_obj;\n+\n+\tstart_addr = (uintptr_t)&hdr_stack_obj->privilege_stack[0];\n+\tend_addr = start_addr + sizeof(hdr_stack_obj->privilege_stack);\n+\n+\tcoredump_memory_dump(start_addr, end_addr);\n+}\n+#endif /* CONFIG_DEBUG_COREDUMP_DUMP_THREAD_PRIV_STACK */"
},{
  "instruction": "arch: add interface to dump privileged stack in coredump",
  "input": "",
  "result": "+#if defined(CONFIG_USERSPACE) || defined(__DOXYGEN__)\n+\n+/**\n+ * @brief Architecture-specific handling of dumping privileged stack\n+ *\n+ * This dumps the architecture-specific privileged stack during coredump.\n+ *\n+ * @param thread Pointer to thread object\n+ */\n+void arch_coredump_priv_stack_dump(struct k_thread *thread);\n+\n+#endif /* CONFIG_USERSPACE || __DOXYGEN__ */\n+"
},{
  "instruction": "Bluetooth: Host: Set scan option type to uint8_t",
  "input": "\tuint32_t options;",
  "result": "-\tuint32_t options;\n+\tuint8_t options;"
},{
  "instruction": "soc: stm32g4x/stm32l0x: fix soc hook calls",
  "input": "/* Initialize STM32 Power */\nvoid soc_early_init_hook(void)\n{\n\t/* Enable Power clock */\n\tLL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);\n}",
  "result": "+extern void stm32_power_init(void);\n+\n-\n-/* Initialize STM32 Power */\n-void soc_early_init_hook(void)\n-{\n-\n-\t/* Enable Power clock */\n-\tLL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);\n-}\n+#ifdef CONFIG_PM\n+\t/* Enable Power clock */\n+\tLL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);\n+#endif"
},{
  "instruction": "soc: intel_ish: remove duplicate hook",
  "input": "extern void sedi_pm_init(void);\nvoid soc_early_init_hook(void)\n{\n\tsedi_pm_init();\n}",
  "result": "-\n-extern void sedi_pm_init(void);\n-\n-void soc_early_init_hook(void)\n-{\n-\tsedi_pm_init();\n-}\n+extern void sedi_pm_init(void);\n+\n+#if defined(CONFIG_PM)\n+\tsedi_pm_init();\n+#endif"
},{
  "instruction": "github: workflows: Add cargo support to twister",
  "input": "",
  "result": "+          echo \"$HOME/.cargo/bin\" >> $GITHUB_PATH\n+          cargo --version\n+          rustup target list --installed"
},{
  "instruction": "boards: npcx_evb: update espi vw index for DnX",
  "input": "",
  "result": "+#include <nuvoton/npcx/npcx-espi-vws-ex-map.dtsi>\n+&espi0 {\n+\tvw-index-extend-set = < ESPI_NPCX_VW_EX_VAL(1, 6, 0x4A) >;\n+};\n+"
},{
  "instruction": "drivers: espi: npcx: add support for DnX VW",
  "input": "",
  "result": "+#if DT_NODE_EXISTS(DT_CHILD(DT_PATH(npcx_espi_vws_map), vw_dnx_warn))\n+\t/* index 4Ah (In) */\n+\tNPCX_DT_VW_IN_CONF(ESPI_VWIRE_SIGNAL_DNX_WARN, vw_dnx_warn),\n+#endif\n+#if DT_NODE_EXISTS(DT_CHILD(DT_PATH(npcx_espi_vws_map), vw_dnx_ack))\n+\tNPCX_DT_VW_OUT_CONF(ESPI_VWIRE_SIGNAL_DNX_ACK, vw_dnx_ack),\n+#endif\n+#if DT_NODE_EXISTS(DT_CHILD(DT_PATH(npcx_espi_vws_map), vw_dnx_warn))\n+\tcase ESPI_VWIRE_SIGNAL_DNX_WARN:\n+\t\tespi_npcx_send_vwire(dev, ESPI_VWIRE_SIGNAL_DNX_ACK, wire);\n+\t\tbreak;\n+#endif\n+#if DT_NODE_EXISTS(DT_CHILD(DT_PATH(npcx_espi_vws_map), vw_dnx_warn))\n+\t} else if (signal == ESPI_VWIRE_SIGNAL_HOST_RST_WARN\n+\t\t|| signal == ESPI_VWIRE_SIGNAL_SUS_WARN\n+\t\t|| signal == ESPI_VWIRE_SIGNAL_OOB_RST_WARN\n+\t\t|| signal == ESPI_VWIRE_SIGNAL_DNX_WARN) {\n+#else\n+#endif"
},{
  "instruction": "soc: npcx: update register definition for espi vw",
  "input": "",
  "result": "+#define NPCX_VWEVMS_INDEX                FIELD(8, 7)\n+#define NPCX_VWEVMS_INDEX_EN             15\n+#define NPCX_VWEVSM_INDEX                FIELD(8, 7)\n+#define NPCX_VWEVSM_INDEX_EN             15"
},{
  "instruction": "soc: mcxw71: Enable FMU flash controller",
  "input": "\t\t\tfmu: flash-module@20000 {\n\t\t\t\tcompatible = \"nxp,fmu-k4\";",
  "result": "+| FMU       | on-chip    | flash                               |\n+\t\tzephyr,flash-controller = &fmu;\n+\n+&fmu {\n+\tstatus = \"okay\";\n+};\n-\t\t\tfmu: flash-module@20000 {\n+\t\t\tfmu: memory-controller@20000 {\n-\t\t\t\tcompatible = \"nxp,fmu-k4\";\n+\t\t\t\tcompatible = \"nxp,iap-msf1\";\n+\t\t\t\tinterrupts = <27 0>;\n+\t\t\t\tstatus = \"disabled\";\n+config MCUX_FLASH_K4_API\n+\tdefault y\n+"
},{
  "instruction": "drivers: kinetis-pinctrl: Account for SCG K4",
  "input": "#define PINCTRL_MCUX_DT_INST_CLOCK_SUBSYS(n) \\\n\tCLK_GATE_DEFINE(DT_INST_CLOCKS_CELL(n, offset), \\\n\t\t\tDT_INST_CLOCKS_CELL(n, bits))",
  "result": "-#define PINCTRL_MCUX_DT_INST_CLOCK_SUBSYS(n) \\\n-\tCLK_GATE_DEFINE(DT_INST_CLOCKS_CELL(n, offset), \\\n-\t\t\tDT_INST_CLOCKS_CELL(n, bits))\n+#define PINCTRL_MCUX_DT_INST_CLOCK_SUBSYS(n)                                                       \\\n+\tCLK_GATE_DEFINE(DT_INST_CLOCKS_CELL(n, offset), DT_INST_CLOCKS_CELL(n, bits))\n+#elif DT_HAS_COMPAT_STATUS_OKAY(nxp_scg_k4)\n+#define PINCTRL_MCUX_DT_INST_CLOCK_SUBSYS(n)                                                       \\\n+\t(DT_INST_CLOCKS_CELL(n, mrcc_offset) == 0                                                  \\\n+\t\t ? 0                                                                               \\\n+\t\t : MAKE_MRCC_REGADDR(MRCC_BASE, DT_INST_CLOCKS_CELL(n, mrcc_offset)))"
},{
  "instruction": "boards: ct: ctcc: Fix unit and first address mismatch",
  "input": "\t\tslot1_partition: partition@87000 {",
  "result": "-\t\tslot1_partition: partition@87000 {\n+\t\tslot1_partition: partition@88000 {"
},{
  "instruction": "boards: arduino: nano_33_iot: Fix unit and first address mismatch",
  "input": "\tatecc608a@15 {",
  "result": "-\tatecc608a@15 {\n+\tatecc608a@6a {"
},{
  "instruction": "boards: seagate: legend: Fix unit and first address mismatch",
  "input": "\t\t\tled_das: partition@10000 {",
  "result": "-\t\t\tled_das: partition@10000 {\n+\t\t\tled_das: partition@1000 {"
},{
  "instruction": "doc: update MIPI DBI API compatibility",
  "input": "Currently, the API only supports Type C controllers, options 1 and 3.\n* The current driver interface only supports type C modes 1 and 3",
  "result": "-Currently, the API only supports Type C controllers, options 1 and 3.\n+Currently, the API does not support Type C controllers with 16 write clocks\n+(option 2).\n- * The current driver interface only supports type C modes 1 and 3\n+ * The current driver interface does not support type C with 16 write clocks (option 2)."
},{
  "instruction": "drivers: display: ili9xxx: read mipi-mode, only use SPI mode as fallback",
  "input": "\t\t\t.mode = MIPI_DBI_MODE_SPI_4WIRE,                       \\",
  "result": "-\t\t\t.mode = MIPI_DBI_MODE_SPI_4WIRE,                       \\\n+\t\t\t.mode = DT_PROP_OR(INST_DT_ILI9XXX(n, t),              \\\n+\t\t\t\tmipi_mode, MIPI_DBI_MODE_SPI_4WIRE),           \\"
},{
  "instruction": "tests: drivers: build_all: sensor: Adding Grove NTC Temperature Sensor",
  "input": "",
  "result": "+\n+test_seeed_grove_temperature: seeed-grove-temperature {\n+\tcompatible = \"seeed,grove-temperature\";\n+\tio-channels = <&test_adc 0>;\n+};"
},{
  "instruction": "tests: drivers: build_all: sensor: Adding Grove Photo-Resistor Light Sensor",
  "input": "",
  "result": "+\n+test_seeed_grove_light: seeed-grove-light {\n+\tcompatible = \"seeed,grove-light\";\n+\tio-channels = <&test_adc 0>;\n+};"
},{
  "instruction": "soc: esp32s3: bump esp32s3 bootloader iram and dram sizes.",
  "input": "#define BOOTLOADER_DRAM_SEG_LEN        0x8000\n#define BOOTLOADER_IRAM_SEG_LEN        0xa800",
  "result": "-#define BOOTLOADER_DRAM_SEG_LEN        0x8000\n+#define BOOTLOADER_DRAM_SEG_LEN        0x9000\n-#define BOOTLOADER_IRAM_SEG_LEN        0xa800\n+#define BOOTLOADER_IRAM_SEG_LEN        0xc000"
},{
  "instruction": "doc: dts: Link Linux binding guidelines.",
  "input": "",
  "result": "+Wherever possible, when writing Devicetree bindings for Zephyr, try to follow\n+the same `design guidelines laid out by Linux`_.\n+\n+.. _design guidelines laid out by Linux:\n+   https://docs.kernel.org/devicetree/bindings/writing-bindings.html\n+"
},{
  "instruction": "soc: telink: move init code from SYS_INIT to hooks",
  "input": "static int soc_b91_init(void)\n\treturn 0;\nSYS_INIT(soc_b91_init, PRE_KERNEL_1, 0);",
  "result": "+\tselect SOC_EARLY_INIT_HOOK\n-static int soc_b91_init(void)\n+void soc_early_init_hook(void)\n-\n-\treturn 0;\n-\n-SYS_INIT(soc_b91_init, PRE_KERNEL_1, 0);"
},{
  "instruction": "soc: snps: move init code from SYS_INIT to hooks",
  "input": "static int arc_iot_init(void)\n\tif (arc_iot_pll_fout_config(CPU_FREQ / 1000000) < 0) {\n\t\treturn -1;\n\t}\n\treturn 0;\nSYS_INIT(arc_iot_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\nstatic int uart_ns16550_init(void)\n\treturn 0;\nSYS_INIT(uart_ns16550_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);",
  "result": "+\tselect SOC_EARLY_INIT_HOOK\n-static int arc_iot_init(void)\n+void soc_early_init_hook(void)\n-\n-\tif (arc_iot_pll_fout_config(CPU_FREQ / 1000000) < 0) {\n-\t\treturn -1;\n-\t}\n-\n-\treturn 0;\n+\tarc_iot_pll_fout_config(CPU_FREQ / 1000000);\n-\n-SYS_INIT(arc_iot_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\n+\tselect SOC_EARLY_INIT_HOOK\n+\tselect SOC_EARLY_INIT_HOOK\n+\tselect SOC_EARLY_INIT_HOOK\n+\tselect SOC_EARLY_INIT_HOOK\n-static int uart_ns16550_init(void)\n+void soc_early_init_hook(void)\n-\n-\treturn 0;\n-SYS_INIT(uart_ns16550_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\n-"
},{
  "instruction": "soc: silabs: move init code from SYS_INIT to hooks",
  "input": "static int silabs_init(void)\n\treturn 0;\nSYS_INIT(silabs_init, PRE_KERNEL_1, 0);\nstatic int silabs_sim3u_init(void)\n\treturn 0;\nSYS_INIT(silabs_sim3u_init, PRE_KERNEL_1, 0);",
  "result": "-static int silabs_init(void)\n+void soc_early_init_hook(void)\n-\n-\treturn 0;\n-\n-SYS_INIT(silabs_init, PRE_KERNEL_1, 0);\n+\tselect SOC_EARLY_INIT_HOOK\n+\tselect SOC_EARLY_INIT_HOOK\n+\tselect SOC_EARLY_INIT_HOOK\n+\tselect SOC_EARLY_INIT_HOOK\n-static int silabs_sim3u_init(void)\n+void soc_early_init_hook(void)\n-\n-\treturn 0;\n-\n-SYS_INIT(silabs_sim3u_init, PRE_KERNEL_1, 0);"
},{
  "instruction": "soc: sifive: move init code from SYS_INIT to hooks",
  "input": "static int fe310_clock_init(void)\n\treturn 0;\nSYS_INIT(fe310_clock_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\nstatic int fu540_clock_init(void)\n\treturn 0;\nSYS_INIT(fu540_clock_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\nstatic int fu740_clock_init(void)\n\treturn 0;\nSYS_INIT(fu740_clock_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);",
  "result": "-\n+\tselect SOC_EARLY_INIT_HOOK\n-static int fe310_clock_init(void)\n+void soc_early_init_hook(void)\n-\treturn 0;\n-\n-SYS_INIT(fe310_clock_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\n-\n+\tselect SOC_EARLY_INIT_HOOK\n-static int fu540_clock_init(void)\n+void soc_early_init_hook(void)\n-\n-\treturn 0;\n-\n-SYS_INIT(fu540_clock_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\n-\n+\tselect SOC_EARLY_INIT_HOOK\n-static int fu740_clock_init(void)\n+void soc_early_init_hook(void)\n-\treturn 0;\n-\n-SYS_INIT(fu740_clock_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);"
},{
  "instruction": "soc: quicklogic: move init code from SYS_INIT to hooks",
  "input": "static int eos_s3_init(void)\n\treturn 0;\nSYS_INIT(eos_s3_init, PRE_KERNEL_1, 0);",
  "result": "+\tselect SOC_EARLY_INIT_HOOK\n-static int eos_s3_init(void)\n+void soc_early_init_hook(void)\n-\n-\treturn 0;\n-\n-SYS_INIT(eos_s3_init, PRE_KERNEL_1, 0);"
},{
  "instruction": "soc: openisa: move init code from SYS_INIT to hooks",
  "input": "static int soc_rv32m1_init(void)\n\treturn 0;\nSYS_INIT(soc_rv32m1_init, PRE_KERNEL_1, 0);",
  "result": "+\tselect SOC_EARLY_INIT_HOOK\n-static int soc_rv32m1_init(void)\n+void soc_early_init_hook(void)\n-\n-\treturn 0;\n-\n-SYS_INIT(soc_rv32m1_init, PRE_KERNEL_1, 0);"
},{
  "instruction": "soc: lowrisc: move init code from SYS_INIT to hooks",
  "input": "static int soc_opentitan_init(void)\n\treturn 0;\nSYS_INIT(soc_opentitan_init, PRE_KERNEL_1, 0);",
  "result": "+\tselect SOC_EARLY_INIT_HOOK\n-static int soc_opentitan_init(void)\n+void soc_early_init_hook(void)\n-\treturn 0;\n-SYS_INIT(soc_opentitan_init, PRE_KERNEL_1, 0);"
},{
  "instruction": "soc: ene: move init code from SYS_INIT to hooks",
  "input": "static int kb1200_init(void)\n\treturn 0;\nSYS_INIT(kb1200_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);",
  "result": "+\tselect SOC_EARLY_INIT_HOOK\n-static int kb1200_init(void)\n+void soc_early_init_hook(void)\n-\treturn 0;\n-\n-SYS_INIT(kb1200_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);"
},{
  "instruction": "soc: brcm: move init code from SYS_INIT to hooks",
  "input": "* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int viper_init(void)\n\treturn 0;\nSYS_INIT(viper_init, PRE_KERNEL_1, 0);\n* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int viper_init(void)\n\treturn 0;\nSYS_INIT(viper_init, PRE_KERNEL_1, 0);",
  "result": "+\tselect SOC_EARLY_INIT_HOOK\n+\tselect SOC_EARLY_INIT_HOOK\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n-static int viper_init(void)\n+void soc_early_init_hook(void)\n-\n-\treturn 0;\n-\n-SYS_INIT(viper_init, PRE_KERNEL_1, 0);\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n-static int viper_init(void)\n+void soc_early_init_hook(void)\n-\n-\treturn 0;\n-\n-SYS_INIT(viper_init, PRE_KERNEL_1, 0);"
},{
  "instruction": "soc: arm: move init code from SYS_INIT to hooks",
  "input": "* So the init priority has to be 0 (zero).\n*\n* Assumption:\n* MAINCLK = 24Mhz\n*\n* @return 0\nstatic int arm_beetle_init(void)\n\treturn 0;\nSYS_INIT(arm_beetle_init, PRE_KERNEL_1, 0);",
  "result": "+\tselect SOC_EARLY_INIT_HOOK\n- * So the init priority has to be 0 (zero).\n- *\n- * Assumption:\n- * MAINCLK = 24Mhz\n- *\n- * @return 0\n-static int arm_beetle_init(void)\n+void soc_early_init_hook(void)\n-\n-\treturn 0;\n-\n-SYS_INIT(arm_beetle_init, PRE_KERNEL_1, 0);"
},{
  "instruction": "soc: andestech: move init code from SYS_INIT to hooks",
  "input": "static int pma_init(void)\n\treturn 0;\nSYS_INIT(pma_init, PRE_KERNEL_2, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);",
  "result": "+\tselect SOC_EARLY_INIT_HOOK\n-static int pma_init(void)\n+void soc_early_init_hook(void)\n-\n-\treturn 0;\n-\n-SYS_INIT(pma_init, PRE_KERNEL_2, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);"
},{
  "instruction": "soc: adi: move init code from SYS_INIT to hooks",
  "input": "* So the init priority has to be 0 (zero).\n*\n* @return 0\nstatic int max32xxx_init(void)\n\treturn 0;\nSYS_INIT(max32xxx_init, PRE_KERNEL_1, 0);",
  "result": "+\tselect SOC_EARLY_INIT_HOOK\n- * So the init priority has to be 0 (zero).\n- *\n- * @return 0\n-static int max32xxx_init(void)\n+void soc_early_init_hook(void)\n-\n-\treturn 0;\n-\n-SYS_INIT(max32xxx_init, PRE_KERNEL_1, 0);"
},{
  "instruction": "init: enhance kconfig docs for custom hooks",
  "input": "",
  "result": "+\t  A custom SoC hook soc_early_init_hook() is executed before the kernel and\n+\t  devices are initialized\n+\n+\t  A custom SoC hook soc_late_init_hook() is executed after the kernel and\n+\t  devices are initialized\n+\n+\t  A custom board hook board_early_init_hook() is executed before the kernel and\n+\t  devices are initialized\n+\n+\t  A custom board hook board_late_init_hook() is executed after the kernel and\n+\t  devices are initialized\n+"
},{
  "instruction": "boards: remove `CONFIG_PINCTRL` from defconfig files of FE310-based boards",
  "input": "CONFIG_PINCTRL=y\nCONFIG_PINCTRL=y\nCONFIG_PINCTRL=y",
  "result": "-CONFIG_PINCTRL=y\n-CONFIG_PINCTRL=y\n-CONFIG_PINCTRL=y\n+\tselect PINCTRL if SOC_SERIES_SIFIVE_FREEDOM_FE300\n+\tselect PINCTRL if SOC_SERIES_SIFIVE_FREEDOM_FE300\n+\tselect PINCTRL if SOC_SERIES_SIFIVE_FREEDOM_FE300"
},{
  "instruction": "soc: sensry: Fix isa extension settings",
  "input": "zephyr_compile_options(-march=rv32imc_zicsr -mabi=ilp32)",
  "result": "-zephyr_compile_options(-march=rv32imc_zicsr -mabi=ilp32)\n-\n+\tselect RISCV_ISA_EXT_C"
},{
  "instruction": "boards: enclustra: mercury_xe: Remove pointless init function",
  "input": "# Copyright (c) 2020, Antmicro\n# SPDX-License-Identifier: Apache-2.0\nzephyr_library()\nzephyr_library_sources(board.c)\n/*\n* Copyright (c) 2020, Antmicro\n*\n* SPDX-License-Identifier: Apache-2.0\n*/\n#include <zephyr/arch/cpu.h>\n#include <zephyr/init.h>\nstatic int mercury_xu_init(void)\n{\n\treturn 0;\n}\nSYS_INIT(mercury_xu_init, PRE_KERNEL_2,\n\t\tCONFIG_KERNEL_INIT_PRIORITY_DEFAULT);",
  "result": "-# Copyright (c) 2020, Antmicro\n-# SPDX-License-Identifier: Apache-2.0\n-\n-zephyr_library()\n-zephyr_library_sources(board.c)\n-/*\n- * Copyright (c) 2020, Antmicro\n- *\n- * SPDX-License-Identifier: Apache-2.0\n- */\n-\n-#include <zephyr/arch/cpu.h>\n-#include <zephyr/init.h>\n-\n-static int mercury_xu_init(void)\n-{\n-\treturn 0;\n-}\n-\n-SYS_INIT(mercury_xu_init, PRE_KERNEL_2,\n-\t\tCONFIG_KERNEL_INIT_PRIORITY_DEFAULT);"
},{
  "instruction": "boards: bl5340_dvk: remove redundant LFXO option",
  "input": "CONFIG_SOC_LFXO_CAP_INT_7PF=y",
  "result": "-CONFIG_SOC_LFXO_CAP_INT_7PF=y"
},{
  "instruction": "dts: arm: nordic: nrf5340: instantiate HF crystal oscillator",
  "input": "",
  "result": "+\n+\thfxo: hfxo {\n+\t\tcompatible = \"nordic,nrf53-hfxo\";\n+\t\t#clock-cells = <0>;\n+\t\tclock-frequency = <DT_FREQ_M(32)>;\n+\t};"
},{
  "instruction": "dts: arm: nordic: nrf5340: instantiate LF crystal oscillator",
  "input": "",
  "result": "+\n+\tlfxo: lfxo {\n+\t\tcompatible = \"nordic,nrf53-lfxo\";\n+\t\t#clock-cells = <0>;\n+\t\tclock-frequency = <32768>;\n+\t};"
},{
  "instruction": "hostap: only add STA interface when hostapd enabled",
  "input": "",
  "result": "+#ifdef CONFIG_WIFI_NM_HOSTAPD_AP\n+\tif (wifi_nm_iface_is_sap(iface)) {\n+\t\treturn;\n+\t}\n+#endif\n+"
},{
  "instruction": "Bluetooth: AICS: Fix race condition in AICS free inst get",
  "input": "\t\tif (!atomic_test_bit(aics_insts[i].cli.flags, BT_AICS_CLIENT_FLAG_ACTIVE)) {\n\t\t\tatomic_set_bit(aics_insts[i].cli.flags, BT_AICS_CLIENT_FLAG_ACTIVE);",
  "result": "-\t\tif (!atomic_test_bit(aics_insts[i].cli.flags, BT_AICS_CLIENT_FLAG_ACTIVE)) {\n+\t\tif (!atomic_test_and_set_bit(aics_insts[i].cli.flags, BT_AICS_CLIENT_FLAG_ACTIVE)) {\n-\t\t\tatomic_set_bit(aics_insts[i].cli.flags, BT_AICS_CLIENT_FLAG_ACTIVE);\n-"
},{
  "instruction": "style: tests: remove unnecessary `return` statements",
  "input": "\treturn (void)dst;\n\treturn (void)dst;\n\treturn z_impl_check_syscall_context();\n\treturn z_impl_test_helpers_log_setup();",
  "result": "-\n-\treturn (void)dst;\n-\treturn (void)dst;\n-\treturn z_impl_check_syscall_context();\n+\tz_impl_check_syscall_context();\n-\treturn z_impl_test_helpers_log_setup();\n+\tz_impl_test_helpers_log_setup();"
},{
  "instruction": "style: kernel: remove unnecessary `return` statements",
  "input": "\treturn z_impl_k_thread_start(thread);",
  "result": "-\treturn z_impl_k_thread_start(thread);\n+\tz_impl_k_thread_start(thread);"
},{
  "instruction": "style: arch: remove unnecessary `return` statements",
  "input": "\treturn xtensa_switch(switch_to, switched_from);\n\treturn z_soc_sys_write8(data, addr);\n\treturn z_soc_sys_write16(data, addr);\n\treturn z_soc_sys_write32(data, addr);\n\treturn z_soc_sys_write64(data, addr);",
  "result": "-\treturn xtensa_switch(switch_to, switched_from);\n+\txtensa_switch(switch_to, switched_from);\n-\treturn z_soc_sys_write8(data, addr);\n+\tz_soc_sys_write8(data, addr);\n-\treturn z_soc_sys_write16(data, addr);\n+\tz_soc_sys_write16(data, addr);\n-\treturn z_soc_sys_write32(data, addr);\n+\tz_soc_sys_write32(data, addr);\n-\treturn z_soc_sys_write64(data, addr);\n+\tz_soc_sys_write64(data, addr);"
},{
  "instruction": "net: dhcpv6: adjust switch-case in `dhcpv6_enter_state`",
  "input": "\t\treturn dhcpv6_enter_init(iface);\n\t\treturn dhcpv6_enter_soliciting(iface);\n\t\treturn dhcpv6_enter_requesting(iface);\n\t\treturn dhcpv6_enter_confirming(iface);\n\t\treturn dhcpv6_enter_renewing(iface);\n\t\treturn dhcpv6_enter_rebinding(iface);\n\t\treturn dhcpv6_enter_bound(iface);",
  "result": "-\t\treturn dhcpv6_enter_init(iface);\n+\t\tdhcpv6_enter_init(iface);\n+\t\tbreak;\n-\t\treturn dhcpv6_enter_soliciting(iface);\n+\t\tdhcpv6_enter_soliciting(iface);\n+\t\tbreak;\n-\t\treturn dhcpv6_enter_requesting(iface);\n+\t\tdhcpv6_enter_requesting(iface);\n+\t\tbreak;\n-\t\treturn dhcpv6_enter_confirming(iface);\n+\t\tdhcpv6_enter_confirming(iface);\n+\t\tbreak;\n-\t\treturn dhcpv6_enter_renewing(iface);\n+\t\tdhcpv6_enter_renewing(iface);\n+\t\tbreak;\n-\t\treturn dhcpv6_enter_rebinding(iface);\n+\t\tdhcpv6_enter_rebinding(iface);\n+\t\tbreak;\n-\t\treturn dhcpv6_enter_bound(iface);\n+\t\tdhcpv6_enter_bound(iface);\n+\t\tbreak;"
},{
  "instruction": "boards: nxp: frdm_ke17z: Fix MCUBoot build.",
  "input": "\t\t/* The MCUBoot swap-move algorithm uses the last 2 sectors\n\t\t\treg = <0x00010000 (DT_SIZE_K(202) + DT_SIZE_K(4))>;\n\t\tslot1_partition: partition@43800 {\n\t\t\treg = <0x00043800 DT_SIZE_K(202)>;\n\t\tstorage_partition: partition@76000 {\n\t\t\treg = <0x00076000 DT_SIZE_K(40)>;",
  "result": "+\t\tzephyr,code-partition = &slot0_partition;\n+\t\tzephyr,uart-mcumgr = &lpuart0;\n+\t\tzephyr,code-partition = &slot0_partition;\n+\t\tzephyr,uart-mcumgr = &lpuart2;\n-\t\t/* The MCUBoot swap-move algorithm uses the last 2 sectors\n+\t\t/* The MCUBoot swap-move algorithm uses the last 3 sectors\n-\t\t\treg = <0x00010000 (DT_SIZE_K(202) + DT_SIZE_K(4))>;\n+\t\t\treg = <0x00010000 (DT_SIZE_K(202) + DT_SIZE_K(6))>;\n-\t\tslot1_partition: partition@43800 {\n+\t\tslot1_partition: partition@44000 {\n-\t\t\treg = <0x00043800 DT_SIZE_K(202)>;\n+\t\t\treg = <0x00044000 DT_SIZE_K(202)>;\n-\t\tstorage_partition: partition@76000 {\n+\t\tstorage_partition: partition@76800 {\n-\t\t\treg = <0x00076000 DT_SIZE_K(40)>;\n+\t\t\treg = <0x00076800 DT_SIZE_K(38)>;"
},{
  "instruction": "tests: bsim: Bluetooth: Audio: Fix minor things in source files",
  "input": "#include \"common.h\"\nstatic volatile size_t sent_count;\n\t * we get a metadata udate, and we need to send an extra\n#include \"bap_common.h\"\n\tprintk(\"Stopped stream with reason 0x%02X%p\\n\", stream, reason);\nstatic void device_found(const struct bt_le_scan_recv_info *info, struct net_buf_simple *ad)\nstatic volatile bool members_discovered;\nstatic volatile uint8_t call_state;",
  "result": "+#include <zephyr/sys/util_macro.h>\n-#include \"common.h\"\n-static volatile size_t sent_count;\n-\t * we get a metadata udate, and we need to send an extra\n+\t * we get a metadata update, and we need to send an extra\n+#include <string.h>\n+#include <zephyr/bluetooth/audio/audio.h>\n+#include <zephyr/bluetooth/audio/bap.h>\n+#include <zephyr/bluetooth/uuid.h>\n+#include <zephyr/sys/util.h>\n-#include \"bap_common.h\"\n-\tprintk(\"Stopped stream with reason 0x%02X%p\\n\", stream, reason);\n+\tprintk(\"Stopped stream %p with reason 0x%02X\\n\", stream, reason);\n+#include <zephyr/bluetooth/audio/bap.h>\n-static void device_found(const struct bt_le_scan_recv_info *info, struct net_buf_simple *ad)\n+static void device_found(const struct bt_le_scan_recv_info *info, struct net_buf_simple *ad_buf)\n-static volatile bool members_discovered;\n+#include <stdint.h>\n-static volatile uint8_t call_state;\n+#include <stdio.h>"
},{
  "instruction": "tests: drivers: build_all: video: Add i2c-devices build test",
  "input": "",
  "result": "+\n+\t\t\ttest_i2c_gc2145: gc2145@5 {\n+\t\t\t\tcompatible = \"galaxycore,gc2145\";\n+\t\t\t\treg = <0x5>;\n+\t\t\t\treset-gpios = <&test_gpio 0 0>;\n+\t\t\t};"
},{
  "instruction": "kernel: Simplify k_thread_cpu_pin()",
  "input": "\tint ret;\n\tret = k_thread_cpu_mask_clear(thread);\n\tif (ret == 0) {\n\t\treturn k_thread_cpu_mask_enable(thread, cpu);\n\t}\n\treturn ret;",
  "result": "-\tint ret;\n+\tuint32_t mask = BIT(cpu);\n-\tret = k_thread_cpu_mask_clear(thread);\n-\tif (ret == 0) {\n-\t\treturn k_thread_cpu_mask_enable(thread, cpu);\n-\t}\n-\treturn ret;\n+\treturn cpu_mask_mod(thread, mask, ~mask);"
},{
  "instruction": "Bluetooth: Mesh: Use dfd_phase_set() in dfu_suspended()",
  "input": "\tsrv->phase = BT_MESH_DFD_PHASE_TRANSFER_SUSPENDED;",
  "result": "-\tsrv->phase = BT_MESH_DFD_PHASE_TRANSFER_SUSPENDED;\n+\tdfd_phase_set(srv, BT_MESH_DFD_PHASE_TRANSFER_SUSPENDED);"
},{
  "instruction": "soc: imx8m: change RDC configuration based on device tree",
  "input": "\tRDC_Init(RDC);\n\tRDC_SetMasterDomainAssignment(RDC, kRDC_Master_A53, &assignment);\n\tRDC_SetPeriphAccessConfig(RDC, &periphConfig);\n\tRDC_SetPeriphAccessConfig(RDC, &periphConfig);\n\tRDC_SetPeriphAccessConfig(RDC, &periphConfig);",
  "result": "+#if DT_NODE_HAS_STATUS(DT_NODELABEL(rdc), okay)\n+\n+#define rdc_inst ((RDC_Type *)DT_REG_ADDR(DT_NODELABEL(rdc)))\n+\n-\tRDC_Init(RDC);\n+\tRDC_Init(rdc_inst);\n-\tRDC_SetMasterDomainAssignment(RDC, kRDC_Master_A53, &assignment);\n+\tRDC_SetMasterDomainAssignment(rdc_inst, kRDC_Master_A53, &assignment);\n-\tRDC_SetPeriphAccessConfig(RDC, &periphConfig);\n+\tRDC_SetPeriphAccessConfig(rdc_inst, &periphConfig);\n-\tRDC_SetPeriphAccessConfig(RDC, &periphConfig);\n+\tRDC_SetPeriphAccessConfig(rdc_inst, &periphConfig);\n-\tRDC_SetPeriphAccessConfig(RDC, &periphConfig);\n+\tRDC_SetPeriphAccessConfig(rdc_inst, &periphConfig);\n+#else\n+\n+#define soc_rdc_init() do { } while (false)\n+\n+#endif\n+"
},{
  "instruction": "drivers: dma: dma_nxp_edma: support 64-bit TCD",
  "input": "",
  "result": "+\tif (data->hal_cfg->flags & EDMA_HAS_64BIT_TCD_FLAG) {\n+\t\tEDMA_ChannelRegWrite(data->hal_cfg, chan_id, EDMA_TCD_SLAST_SDA_HIGH,\n+\t\t\t\t     slast >= 0x0 ? 0x0 : 0xffffffff);\n+\t\tEDMA_ChannelRegWrite(data->hal_cfg, chan_id, EDMA_TCD_DLAST_SGA_HIGH,\n+\t\t\t\t     dlast >= 0x0 ? 0x0 : 0xffffffff);\n+\t}\n+"
},{
  "instruction": "drivers: dma: dma_nxp_edma: support MUX register in MP space",
  "input": "\t\tLOG_DBG(\"CH_MUX: 0x%x\",\n\t\t\tEDMA_ChannelRegRead(data->hal_cfg, chan_id, EDMA_TCD_CH_MUX));",
  "result": "+\tuint32_t mux_reg;\n+\n-\t\tLOG_DBG(\"CH_MUX: 0x%x\",\n-\t\t\tEDMA_ChannelRegRead(data->hal_cfg, chan_id, EDMA_TCD_CH_MUX));\n+\t\tif (data->hal_cfg->flags & EDMA_HAS_MP_MUX_FLAG) {\n+\t\t\tmux_reg = EDMA_MP_CH_MUX;\n+\t\t} else {\n+\t\t\tmux_reg = EDMA_TCD_CH_MUX;\n+\t\t}\n+\n+\t\tLOG_DBG(\"CH_MUX: 0x%x\", EDMA_ChannelRegRead(data->hal_cfg, chan_id, mux_reg));"
},{
  "instruction": "west.yml: hal_nxp: update hash",
  "input": "     revision: 77815705c465627b8436cbac51f0bf0594bbeba2",
  "result": "-      revision: 77815705c465627b8436cbac51f0bf0594bbeba2\n+      revision: 17aac63df44266c4ea0e111c731ca7664fe51e70"
},{
  "instruction": "manifest: update to support changes",
  "input": "     revision: aa6a967d1ab4077691aa046229a782102960218a",
  "result": "-      revision: aa6a967d1ab4077691aa046229a782102960218a\n+      revision: de5ea5987baaa5492fb9cc0d01222e8b07c78a70"
},{
  "instruction": "net: l2: wifi: ensure certificates directory is created",
  "input": "",
  "result": "+# Create output directory for test certs\n+file(MAKE_DIRECTORY ${gen_dir})"
},{
  "instruction": "tests: spi_loopback: kinetis dspi fix",
  "input": "CONFIG_MCUX_DSPI_BUFFER_SIZE=144",
  "result": "-CONFIG_MCUX_DSPI_BUFFER_SIZE=144\n+CONFIG_MCUX_DSPI_BUFFER_SIZE=5760\n+\n+#ifdef CONFIG_DSPI_MCUX_EDMA\n+/*DSPI DMA need aligned buffer for internal*/\n+#define BUF3_SIZE 1440\n+#else\n+#endif\n+\n+\tif (IS_ENABLED(CONFIG_DSPI_MCUX_EDMA)) {\n+\t\tLOG_INF(\"Skip rx bigger than tx\");\n+\t\treturn 0;\n+\t}\n+"
},{
  "instruction": "drivers: intc: shared_irq: change init and isr function to static",
  "input": "void shared_irq_isr(const struct device *dev)\nint shared_irq_initialize(const struct device *dev)",
  "result": "-void shared_irq_isr(const struct device *dev)\n+static void shared_irq_isr(const struct device *dev)\n-int shared_irq_initialize(const struct device *dev)\n+static int shared_irq_initialize(const struct device *dev)\n+"
},{
  "instruction": "MAINTAINERS: Add BT role specific conf files to right groups",
  "input": "",
  "result": "+    - tests/bluetooth/shell/audio.conf\n+    - tests/bluetooth/shell/mesh.conf\n+    - tests/bluetooth/shell/mesh.conf"
},{
  "instruction": "kernel: remove `CONFIG_MP_NUM_CPUS`",
  "input": "\t  incoherence and makes only sense when MP_NUM_CPUS > 1.\n\t  sense when MP_NUM_CPUS > 1.\nstatic void (*irq_offload_funcs[CONFIG_MP_NUM_CPUS])(const void *arg);\nstatic const void *irq_offload_args[CONFIG_MP_NUM_CPUS];\nconfig MP_NUM_CPUS\n\tint \"Number of CPUs/cores [DEPRECATED]\"\n\tdefault MP_MAX_NUM_CPUS\n\trange 1 12\n\thelp\n\t  This is deprecated, please use MP_MAX_NUM_CPUS instead.\nBUILD_ASSERT(CONFIG_MP_NUM_CPUS == CONFIG_MP_MAX_NUM_CPUS,\n\t     \"CONFIG_MP_NUM_CPUS and CONFIG_MP_MAX_NUM_CPUS need to be set the same\");",
  "result": "-\t  incoherence and makes only sense when MP_NUM_CPUS > 1.\n+\t  incoherence and makes only sense when MP_MAX_NUM_CPUS > 1.\n-\t  sense when MP_NUM_CPUS > 1.\n+\t  sense when MP_MAX_NUM_CPUS > 1.\n-static void (*irq_offload_funcs[CONFIG_MP_NUM_CPUS])(const void *arg);\n-static const void *irq_offload_args[CONFIG_MP_NUM_CPUS];\n+static void (*irq_offload_funcs[CONFIG_MP_MAX_NUM_CPUS])(const void *arg);\n+static const void *irq_offload_args[CONFIG_MP_MAX_NUM_CPUS];\n+* Removed the deprecated :kconfig:option:`CONFIG_MP_NUM_CPUS`, application should be updated to use\n+  :kconfig:option:`CONFIG_MP_MAX_NUM_CPUS` instead.\n+\n-config MP_NUM_CPUS\n-\tint \"Number of CPUs/cores [DEPRECATED]\"\n-\tdefault MP_MAX_NUM_CPUS\n-\trange 1 12\n-\thelp\n-\t  This is deprecated, please use MP_MAX_NUM_CPUS instead.\n-\n-BUILD_ASSERT(CONFIG_MP_NUM_CPUS == CONFIG_MP_MAX_NUM_CPUS,\n-\t     \"CONFIG_MP_NUM_CPUS and CONFIG_MP_MAX_NUM_CPUS need to be set the same\");\n-"
},{
  "instruction": "net: l2: ieee802154: fix typo",
  "input": "static bool ieeee802154_check_dst_addr(struct net_if *iface, struct ieee802154_mhr *mhr)\n\t    !ieeee802154_check_dst_addr(iface, &mpdu.mhr)) {",
  "result": "-static bool ieeee802154_check_dst_addr(struct net_if *iface, struct ieee802154_mhr *mhr)\n+static bool ieee802154_check_dst_addr(struct net_if *iface, struct ieee802154_mhr *mhr)\n-\t    !ieeee802154_check_dst_addr(iface, &mpdu.mhr)) {\n+\t    !ieee802154_check_dst_addr(iface, &mpdu.mhr)) {"
},{
  "instruction": "tests: latency_measure: fix stacks for the busy threads",
  "input": "K_THREAD_STACK_DEFINE(busy_thread_stack, BUSY_THREAD_STACK_SIZE);\n\t\tk_thread_create(&busy_thread[i], &busy_thread_stack[i],",
  "result": "+CONFIG_MP_MAX_NUM_CPUS=8\n+\n+# To support the amount of thread objects in userspace\n+CONFIG_MAX_THREAD_BYTES=3\n-K_THREAD_STACK_DEFINE(busy_thread_stack, BUSY_THREAD_STACK_SIZE);\n+K_THREAD_STACK_ARRAY_DEFINE(busy_thread_stack, CONFIG_MP_MAX_NUM_CPUS - 1, BUSY_THREAD_STACK_SIZE);\n-\t\tk_thread_create(&busy_thread[i], &busy_thread_stack[i],\n+\t\tk_thread_create(&busy_thread[i], busy_thread_stack[i],\n+      - qemu_riscv64/qemu_virt_riscv64/smp"
},{
  "instruction": "Bluetooth: MICP: Add bondable requirement",
  "input": "",
  "result": "+\tdepends on BT_BONDABLE\n+\tdepends on BT_BONDABLE"
},{
  "instruction": "bluetooth: smp: remove experimental from BT_GATT_AUTHORIZATION_CUSTOM",
  "input": "\tbool \"Custom authorization of GATT operations [EXPERIMENTAL]\"\n\tselect EXPERIMENTAL",
  "result": "-\tbool \"Custom authorization of GATT operations [EXPERIMENTAL]\"\n-\tselect EXPERIMENTAL\n+\tbool \"Custom authorization of GATT operations\""
},{
  "instruction": "drivers: wifi: nrfwifi: determine shared iovdd and bucken from dt",
  "input": "config NRF_WIFI_COMBINED_BUCKEN_IOVDD_GPIO\n\tbool\n\thelp\n\t  Enable this option to use a single GPIO to control both buck enable and IOVDD enable,\n\t  there will be a internal hardware switch to add delay between the two operations. This\n\t  is typically 4ms delay for nRF70.\n\tif (IS_ENABLED(CONFIG_NRF_WIFI_COMBINED_BUCKEN_IOVDD_GPIO)) {",
  "result": "-config NRF_WIFI_COMBINED_BUCKEN_IOVDD_GPIO\n-\tbool\n-\thelp\n-\t  Enable this option to use a single GPIO to control both buck enable and IOVDD enable,\n-\t  there will be a internal hardware switch to add delay between the two operations. This\n-\t  is typically 4ms delay for nRF70.\n-\n-\tif (IS_ENABLED(CONFIG_NRF_WIFI_COMBINED_BUCKEN_IOVDD_GPIO)) {\n+\tif ((bucken_spec.port == iovdd_ctrl_spec.port) &&\n+\t    (bucken_spec.pin == iovdd_ctrl_spec.pin)) {"
},{
  "instruction": "dts: mcxc: include pwm header file",
  "input": "",
  "result": "+#include <zephyr/dt-bindings/pwm/pwm.h>"
},{
  "instruction": "soc: mcxc444: add soc support for mcxc444",
  "input": "",
  "result": "+config SOC_MCXC444\n+\tbool\n+\tselect SOC_SERIES_MCXC\n+\n+\tdefault \"mcxc444\" if SOC_MCXC444\n+config SOC_PART_NUMBER_MCXC444VLH\n+\tbool\n+\n+config SOC_PART_NUMBER_MCXC444VMP\n+\tbool\n+\n+\tdefault \"MCXC444VLH\" if SOC_PART_NUMBER_MCXC444VLH\n+\tdefault \"MCXC444VMP\" if SOC_PART_NUMBER_MCXC444VMP\n+    - name: mcxc444"
},{
  "instruction": "dts: mcxc444: add dts for mcxc444",
  "input": "",
  "result": "+/*\n+ * Copyright 2024 NXP\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+#include <nxp/nxp_mcxc_common.dtsi>\n+\n+&sram0 {\n+\treg = <0x1FFFE000 DT_SIZE_K(32)>;\n+};\n+\n+&flash0 {\n+\treg = <0 DT_SIZE_K(256)>;\n+};"
},{
  "instruction": "boards: espressif: Add uart1 to esp_wrover_kit",
  "input": "",
  "result": "+\tuart1_default: uart1_default {\n+\t\tgroup1 {\n+\t\t\tpinmux = <UART1_TX_GPIO32>;\n+\t\t\toutput-high;\n+\t\t};\n+\t\tgroup2 {\n+\t\t\tpinmux = <UART1_RX_GPIO33>;\n+\t\t\tbias-pull-up;\n+\t\t};\n+\t};\n+\n+&uart1 {\n+\tstatus = \"disabled\";\n+\tcurrent-speed = <115200>;\n+\tpinctrl-0 = <&uart1_default>;\n+\tpinctrl-names = \"default\";\n+};\n+"
},{
  "instruction": "scripts: pylib: twister: twisterlib: prevent empty gcda files",
  "input": "                   fp.write(bytes.fromhex(hexdump_val))",
  "result": "+                hex_bytes = bytes.fromhex(hexdump_val)\n-                    fp.write(bytes.fromhex(hexdump_val))\n+                    fp.write(hex_bytes)"
},{
  "instruction": "samples: net: wifi: add build of nrf7002eb",
  "input": "",
  "result": "+  sample.net.wifi.nrf7002eb:\n+    extra_args:\n+      - CONFIG_NRF_WIFI_BUILD_ONLY_MODE=y\n+      - SHIELD=nrf7002eb\n+    platform_allow:\n+      - thingy53/nrf5340/cpuapp\n+    integration_platforms:\n+      - thingy53/nrf5340/cpuapp"
},{
  "instruction": "tests: drivers: build_all: ieee802154: Add overlay for native_sim and 64",
  "input": "",
  "result": "+/*\n+ * Copyright (c) 2024 TOKITA Hiroshi\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+#include \"native_posix.overlay\"\n+/*\n+ * Copyright (c) 2024 TOKITA Hiroshi\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+#include \"native_posix.overlay\"\n+      - native_sim/native/64"
},{
  "instruction": "drivers: ieee802154: mcr20a: Specify the dependency on HAL_MCUX",
  "input": "",
  "result": "+\tdepends on HAS_MCUX"
},{
  "instruction": "drivers: counter: Specify _POSIX_C_SOURCE when native_sim",
  "input": "",
  "result": "+#ifdef CONFIG_SOC_POSIX\n+#undef _POSIX_C_SOURCE\n+#define _POSIX_C_SOURCE 200809L /* Required for gmtime_r */\n+#endif\n+\n+#ifdef CONFIG_SOC_POSIX\n+#undef _POSIX_C_SOURCE\n+#define _POSIX_C_SOURCE 200809L /* Required for gmtime_r */\n+#endif\n+"
},{
  "instruction": "ci: github: git clean after rebase",
  "input": "",
  "result": "+          git clean -f -d\n+          git clean -f -d\n+        git clean -f -d\n+        git clean -f -d\n+        git clean -f -d\n+          git clean -f -d\n+          git clean -f -d\n+          git clean -f -d\n+            git clean -f -d"
},{
  "instruction": "net: l2: ieee802154: fix deadlock",
  "input": "\t\treturn false;",
  "result": "-\t\treturn false;\n+\t\tgoto out;\n+\t\tk_sem_give(&ctx->scan_ctx_lock);"
},{
  "instruction": "boards: st: nucleo_wb0: Remove arduino_gpio compatibility declaration",
  "input": " - arduino_gpio\n - arduino_gpio",
  "result": "-  - arduino_gpio\n-  - arduino_gpio"
},{
  "instruction": "west.yml: hal_stm32: revert ble_fw blobs",
  "input": "     revision: c4099c229323f305eef75ff6ba93ee9b89827581",
  "result": "-      revision: c4099c229323f305eef75ff6ba93ee9b89827581\n+      revision: 1ff820533c1b1c17f1a4d7d28ab99a94a234883b"
},{
  "instruction": "tests/bsim/bluetooth/host/adv/encrypted: Enable RealEncryption",
  "input": " -v=${verbosity_level} -s=${simulation_id} -d=0 -testid=central\n -v=${verbosity_level} -s=${simulation_id} -d=1 -testid=peripheral",
  "result": "-  -v=${verbosity_level} -s=${simulation_id} -d=0 -testid=central\n+  -v=${verbosity_level} -s=${simulation_id} -d=0 -testid=central -RealEncryption=1\n-  -v=${verbosity_level} -s=${simulation_id} -d=1 -testid=peripheral\n+  -v=${verbosity_level} -s=${simulation_id} -d=1 -testid=peripheral -RealEncryption=1"
},{
  "instruction": "tests/bsim/bluetooth/host/att: Enable RealEncryption",
  "input": " -v=${verbosity_level} -s=${simulation_id} -d=0 -testid=central_autoconnect\n -v=${verbosity_level} -s=${simulation_id} -d=1 -testid=peripheral_autoconnect\n -v=${verbosity_level} -s=${simulation_id} -d=0 -testid=central\n -v=${verbosity_level} -s=${simulation_id} -d=1 -testid=peripheral\n -v=${verbosity_level} -s=${simulation_id} -d=0 -testid=central_lowres\n -v=${verbosity_level} -s=${simulation_id} -d=1 -testid=peripheral_lowres\n -v=${verbosity_level} -s=${simulation_id} -d=0 -testid=central\n -v=${verbosity_level} -s=${simulation_id} -d=1 -testid=peripheral\n -v=${verbosity_level} -s=${simulation_id} -d=0 -testid=central_reconfigure\n -v=${verbosity_level} -s=${simulation_id} -d=1 -testid=peripheral_reconfigure\n -v=${verbosity_level} -s=${simulation_id} -d=0 -testid=client\n -v=${verbosity_level} -s=${simulation_id} -d=1 -testid=server",
  "result": "-  -v=${verbosity_level} -s=${simulation_id} -d=0 -testid=central_autoconnect\n+  -v=${verbosity_level} -s=${simulation_id} -d=0 -testid=central_autoconnect -RealEncryption=1\n-  -v=${verbosity_level} -s=${simulation_id} -d=1 -testid=peripheral_autoconnect\n+  -v=${verbosity_level} -s=${simulation_id} -d=1 -testid=peripheral_autoconnect -RealEncryption=1\n-  -v=${verbosity_level} -s=${simulation_id} -d=0 -testid=central\n+  -v=${verbosity_level} -s=${simulation_id} -d=0 -testid=central -RealEncryption=1\n-  -v=${verbosity_level} -s=${simulation_id} -d=1 -testid=peripheral\n+  -v=${verbosity_level} -s=${simulation_id} -d=1 -testid=peripheral -RealEncryption=1\n-  -v=${verbosity_level} -s=${simulation_id} -d=0 -testid=central_lowres\n+  -v=${verbosity_level} -s=${simulation_id} -d=0 -testid=central_lowres -RealEncryption=1\n-  -v=${verbosity_level} -s=${simulation_id} -d=1 -testid=peripheral_lowres\n+  -v=${verbosity_level} -s=${simulation_id} -d=1 -testid=peripheral_lowres -RealEncryption=1\n-  -v=${verbosity_level} -s=${simulation_id} -d=0 -testid=central\n+  -v=${verbosity_level} -s=${simulation_id} -d=0 -testid=central -RealEncryption=1\n-  -v=${verbosity_level} -s=${simulation_id} -d=1 -testid=peripheral\n+  -v=${verbosity_level} -s=${simulation_id} -d=1 -testid=peripheral -RealEncryption=1\n-  -v=${verbosity_level} -s=${simulation_id} -d=0 -testid=central_reconfigure\n+  -v=${verbosity_level} -s=${simulation_id} -d=0 -testid=central_reconfigure -RealEncryption=1\n-  -v=${verbosity_level} -s=${simulation_id} -d=1 -testid=peripheral_reconfigure\n+  -v=${verbosity_level} -s=${simulation_id} -d=1 -testid=peripheral_reconfigure -RealEncryption=1\n-  -v=${verbosity_level} -s=${simulation_id} -d=0 -testid=client\n+  -v=${verbosity_level} -s=${simulation_id} -d=0 -testid=client -RealEncryption=1\n-  -v=${verbosity_level} -s=${simulation_id} -d=1 -testid=server\n+  -v=${verbosity_level} -s=${simulation_id} -d=1 -testid=server -RealEncryption=1"
},{
  "instruction": "bluetooth: smp: remove experimental from BT_BONDABLE_PER_CONNECTION",
  "input": "\tbool \"Set/clear the bonding flag per-connection [EXPERIMENTAL]\"\n\tselect EXPERIMENTAL",
  "result": "-\tbool \"Set/clear the bonding flag per-connection [EXPERIMENTAL]\"\n-\tselect EXPERIMENTAL\n+\tbool \"Set/clear the bonding flag per-connection\""
},{
  "instruction": "docs: i3c: fix incorrect detail for SETDASA I3C CCC usage",
  "input": "  #. Do ``SETDASA`` to use static addresses as dynamic address",
  "result": "-   #. Do ``SETDASA`` to use static addresses as dynamic address\n+   #. Do ``SETDASA`` to assign a dynamic address using the static address of the device"
},{
  "instruction": "shell: kernel_service: heap: add required header",
  "input": "",
  "result": "+#include \"kernel_shell.h\"\n+"
},{
  "instruction": "cmake: set big-endian flags to TOOLCHAIN_*_FLAGS",
  "input": "\t  modifying it.  The option is used to select linker script OUTPUT_FORMAT\n\t  and command line option for gen_isr_tables.py.",
  "result": "-\t  modifying it.  The option is used to select linker script OUTPUT_FORMAT\n-\t  and command line option for gen_isr_tables.py.\n+\t  modifying it.  The option is used to select linker script OUTPUT_FORMAT,\n+\t  the toolchain flags (TOOLCHAIN_C_FLAGS, TOOLCHAIN_LD_FLAGS), and command\n+\t  line option for gen_isr_tables.py.\n+if(CONFIG_BIG_ENDIAN)\n+  list(APPEND TOOLCHAIN_C_FLAGS -mbig-endian)\n+  list(APPEND TOOLCHAIN_LD_FLAGS -mbig-endian)\n+endif()\n+"
},{
  "instruction": "samples: fs_sample: add required meta info for twister",
  "input": "",
  "result": "+      type: multi_line\n+      regex:\n+        - \"Block count\"\n+        - \"Sector size\"\n+        - \"Memory Size\"\n+        - \"Disk mounted\"\n+      type: multi_line\n+      regex:\n+        - \"Block count\"\n+        - \"Sector size\"\n+        - \"Memory Size\"\n+        - \"Disk mounted\""
},{
  "instruction": "tests: kernel.common.stack_sentinel: re-enable some platforms",
  "input": "     - hifive1        # FIXME: See issue #66070\n     - m2gl025_miv    # FIXME: See issue #66070",
  "result": "-      - hifive1        # FIXME: See issue #66070\n-      - m2gl025_miv    # FIXME: See issue #66070"
},{
  "instruction": "samples: driver: video: enable capture case to run",
  "input": "   build_only: true",
  "result": "-    build_only: true\n+    harness: console\n+    harness_config:\n+      fixture: fixture_camera\n+      type: multi_line\n+      ordered: true\n+      regex:\n+        - \"Capture started\"\n+        - \"Got frame\"\n+        - \"size\"\n+        - \"timestamp\""
},{
  "instruction": "net: sockets: tls: Prevent infinite block during handshake",
  "input": "\t\tret = tls_mbedtls_handshake(ctx, K_FOREVER);\n\tret = tls_mbedtls_handshake(child, K_FOREVER);",
  "result": "-\t\tret = tls_mbedtls_handshake(ctx, K_FOREVER);\n+\t\tret = tls_mbedtls_handshake(\n+\t\t\tctx, K_MSEC(CONFIG_NET_SOCKETS_CONNECT_TIMEOUT));\n-\tret = tls_mbedtls_handshake(child, K_FOREVER);\n+\tret = tls_mbedtls_handshake(\n+\t\tchild, K_MSEC(CONFIG_NET_SOCKETS_CONNECT_TIMEOUT));\n+\t\t * DTLS handshake timeout/retransmissions are limited by\n+\t\t * mbed TLS, so K_FOREVER is fine here, the function will not\n+\t\t * block indefinitely."
},{
  "instruction": "Ztest: Ztest_param fix",
  "input": "",
  "result": "+#ifndef CONFIG_ZTEST_SHUFFLE\n+#endif"
},{
  "instruction": "drivers/i2c: it8xxx2: Add a property for maximum time allowed I2C transfer",
  "input": "\t\t/* TODO: the timeout should be adjustable */\n\t\tres = k_sem_take(&data->device_sync_sem, K_MSEC(100));\n\tres = k_sem_take(&data->device_sync_sem, K_MSEC(100));\n\t\t/* TODO: the timeout should be adjustable */\n\t\tres = k_sem_take(&data->device_sync_sem, K_MSEC(100));",
  "result": "+\tint transfer_timeout_ms;\n-\t\t/* TODO: the timeout should be adjustable */\n-\t\tres = k_sem_take(&data->device_sync_sem, K_MSEC(100));\n+\t\tres = k_sem_take(&data->device_sync_sem, K_MSEC(config->transfer_timeout_ms));\n-\tres = k_sem_take(&data->device_sync_sem, K_MSEC(100));\n+\tres = k_sem_take(&data->device_sync_sem, K_MSEC(config->transfer_timeout_ms));\n+\t\t.transfer_timeout_ms = DT_INST_PROP(inst, transfer_timeout_ms), \\\n+\tint transfer_timeout_ms;\n-\t\t/* TODO: the timeout should be adjustable */\n-\t\tres = k_sem_take(&data->device_sync_sem, K_MSEC(100));\n+\t\tres = k_sem_take(&data->device_sync_sem, K_MSEC(config->transfer_timeout_ms));\n+\t\t.transfer_timeout_ms = DT_INST_PROP(inst, transfer_timeout_ms), \\\n+  transfer-timeout-ms:\n+    type: int\n+    default: 100\n+    description: |\n+      Maximum time allowed for an I2C transfer.\n+"
},{
  "instruction": "boards: nxp: mimxrt595_evk: Fix unit and first address mismatch",
  "input": "\taudio_codec: wm8904@1a {",
  "result": "-\taudio_codec: wm8904@1a {\n+\taudio_codec: wm8904@1a0000000000000000 {"
},{
  "instruction": "boards: nxp: mimxrt685_evk: Fix unit and first address mismatch",
  "input": "\taudio_codec: wm8904@1a {",
  "result": "-\taudio_codec: wm8904@1a {\n+\taudio_codec: wm8904@1a0000000000000000 {"
},{
  "instruction": "tests: net: wifi: exclude RW612 ethernet variant",
  "input": "     - frdm_rw612 # Requires binary blobs to build\n     - rd_rw612_bga # Requires binary blobs to build",
  "result": "-      - frdm_rw612 # Requires binary blobs to build\n-      - rd_rw612_bga # Requires binary blobs to build\n+      - rd_rw612_bga/rw612/ethernet # Requires binary blobs to build"
},{
  "instruction": "dts: rt5xx: rt6xx: Fix DTC sram warnings",
  "input": "\t\t\tranges = <0x0 0x10000000 0x500000\n\t\t\t\t0x20000000 0x30000000 0x500000>;\n\t\t\tranges = <0x0 0x10000000 0x500000\n\t\t\t\t0x20000000 0x30000000 0x500000>;",
  "result": "-\t\t\tranges = <0x0 0x10000000 0x500000\n-\t\t\t\t0x20000000 0x30000000 0x500000>;\n+\t\t\tranges = <0x20000000 0x30000000 0x500000\n+\t\t\t\t0x0 0x10000000 0x500000>;\n-\t\t\tranges = <0x0 0x10000000 0x500000\n-\t\t\t\t0x20000000 0x30000000 0x500000>;\n+\t\t\tranges = <0x20000000 0x30000000 0x500000\n+\t\t\t\t0x0 0x10000000 0x500000>;"
},{
  "instruction": "twister: Fix inconsistency among DT compat filters",
  "input": "           if compat in node.compats and node.status == \"okay\":\n           if node.status == \"okay\" and alias in node.aliases and parent.matching_compat == compat:\n       return parent is not None and parent.status == 'okay' and parent.matching_compat == compat",
  "result": "-            if compat in node.compats and node.status == \"okay\":\n+            if (node.matching_compat == compat or compat in node.compats) and node.status == \"okay\":\n-            if node.status == \"okay\" and alias in node.aliases and parent.matching_compat == compat:\n+            if node.status == \"okay\" and alias in node.aliases and \\\n+                    (parent.matching_compat == compat or compat in parent.compats):\n-        return parent is not None and parent.status == 'okay' and parent.matching_compat == compat\n+        return parent is not None and parent.status == 'okay' and \\\n+            (parent.matching_compat == compat or compat in parent.compats)"
},{
  "instruction": "modules: hal_nordic: dvfs: patch medlow trim entry",
  "input": "",
  "result": "+\t/* Temporary patch fixing medlow oppoint trim index */\n+\tif (oppoint == DVFS_FREQ_MEDLOW) {\n+\t\tfreq_trim = 2;\n+\t}\n+"
},{
  "instruction": "openthread: coprocessor: Enable support of cc1352p7 lp",
  "input": "",
  "result": "+/*\n+ * Copyright (c) 2024 Alexandre Bailon\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+/ {\n+\tchosen {\n+\t\t/* Use XDS110 UART for the NCP */\n+\t\tzephyr,ot-uart = &uart0;\n+\t\t/* Use UART1 for debugging / zephyr console */\n+\t\tzephyr,shell-uart = &uart1;\n+\t\tzephyr,console = &uart1;\n+\t};\n+};\n+\n+&uart1 {\n+\tstatus = \"okay\";\n+};"
},{
  "instruction": "boards: ti: launchxl: Add support of UART1",
  "input": "",
  "result": "+\t/* UART1 */\n+\tuart1_tx_default: uart1_tx_default {\n+\t\tpinmux = <22 IOC_PORT_MCU_UART1_TX>;\n+\t\tbias-disable;\n+\t};\n+\tuart1_rx_default: uart1_rx_default {\n+\t\tpinmux = <24 IOC_PORT_MCU_UART1_RX>;\n+\t\tbias-disable;\n+\t\tinput-enable;\n+\t};\n+\n+&uart1 {\n+\tstatus = \"disabled\";\n+\tcurrent-speed = <115200>;\n+\tpinctrl-0 = <&uart1_rx_default &uart1_tx_default>;\n+\tpinctrl-names = \"default\";\n+};\n+"
},{
  "instruction": "drivers: ieee802154: cc13xx_cc26xx: Enable support of OpenThread L2",
  "input": "\t\t\t  &ieee802154_cc13xx_cc26xx_radio_api, IEEE802154_L2,\n\t\t\t  NET_L2_GET_CTX_TYPE(IEEE802154_L2), IEEE802154_MTU);",
  "result": "+#if defined(CONFIG_NET_L2_OPENTHREAD)\n+#include <zephyr/net/openthread.h>\n+#endif\n+\n+#define L2 IEEE802154_L2\n+#define L2_CTX_TYPE NET_L2_GET_CTX_TYPE(IEEE802154_L2)\n+#define MTU IEEE802154_MTU\n+#elif defined(CONFIG_NET_L2_OPENTHREAD)\n+#define L2 OPENTHREAD_L2\n+#define L2_CTX_TYPE NET_L2_GET_CTX_TYPE(OPENTHREAD_L2)\n+#define MTU 1280\n+#endif\n+\n+#if defined(CONFIG_NET_L2_IEEE802154) || defined(CONFIG_NET_L2_PHY_IEEE802154)\n-\t\t\t  &ieee802154_cc13xx_cc26xx_radio_api, IEEE802154_L2,\n-\t\t\t  NET_L2_GET_CTX_TYPE(IEEE802154_L2), IEEE802154_MTU);\n+\t\t\t  &ieee802154_cc13xx_cc26xx_radio_api, L2,\n+\t\t\t  L2_CTX_TYPE, MTU);"
},{
  "instruction": "drivers: ieee802154: cc13xx_cc26xx: Fixup a bus error",
  "input": "",
  "result": "+#if defined(CONFIG_SOC_CC1352R) || defined(CONFIG_SOC_CC2652R) || \\\n+\tdefined(CONFIG_SOC_CC1352R7) || defined(CONFIG_SOC_CC2652R7)\n+#elif defined(CONFIG_SOC_CC1352P) || defined(CONFIG_SOC_CC2652P) || \\\n+\tdefined(CONFIG_SOC_CC1352P7) || defined(CONFIG_SOC_CC2652P7)\n+\t\t.commandNo = CMD_RADIO_SETUP_PA,\n+#endif /* CONFIG_SOC_CCxx52x */\n+#if defined(CONFIG_SOC_CC1352R) || defined(CONFIG_SOC_CC2652R) || \\\n+\tdefined(CONFIG_SOC_CC1352R7) || defined(CONFIG_SOC_CC2652R7)\n+#elif defined(CONFIG_SOC_CC1352P) || defined(CONFIG_SOC_CC2652P) || \\\n+\tdefined(CONFIG_SOC_CC1352P7) || defined(CONFIG_SOC_CC2652P7)\n+\tvolatile rfc_CMD_RADIO_SETUP_PA_t cmd_radio_setup;\n+#else\n+\tBUILD_ASSERT(false, \"unknown model\");\n+#endif /* CONFIG_SOC_CCxx52x */"
},{
  "instruction": "samples: subsys: settings: Add configuration for cc1352p7",
  "input": "",
  "result": "+CONFIG_NVS=y"
},{
  "instruction": "doc: Increase navigation depth in side nav bar",
  "input": "   \"prev_next_buttons_location\": None",
  "result": "-    \"prev_next_buttons_location\": None\n+    \"prev_next_buttons_location\": None,\n+    \"navigation_depth\": 5,"
},{
  "instruction": "arch: Simplify find_lsb_set()",
  "input": "\t * Toolchain does not have __builtin_ffs().\n\t * Need to do this manually.\n\tint bit;\n\tif (op == 0) {\n\t\treturn 0;\n\t}\n\tfor (bit = 0; bit < 32; bit++) {\n\t\tif ((op & (1 << bit)) != 0) {\n\t\t\treturn (bit + 1);\n\t\t}\n\t}\n\t/*\n\t * This should never happen but we need to keep\n\t * compiler happy.\n\t */\n\treturn 0;",
  "result": "-\t * Toolchain does not have __builtin_ffs().\n-\t * Need to do this manually.\n+\t * Toolchain does not have __builtin_ffs(). Leverage find_lsb_set()\n+\t * by first clearing all but the lowest set bit.\n-\tint bit;\n-\tif (op == 0) {\n-\t\treturn 0;\n-\t}\n+\top = op ^ (op & (op - 1));\n-\tfor (bit = 0; bit < 32; bit++) {\n-\t\tif ((op & (1 << bit)) != 0) {\n-\t\t\treturn (bit + 1);\n-\t\t}\n-\t}\n-\n-\t/*\n-\t * This should never happen but we need to keep\n-\t * compiler happy.\n-\t */\n-\treturn 0;\n+\treturn find_msb_set(op);"
},{
  "instruction": "dts: bindings: clock: rpi_pico: add XOSC definition",
  "input": "\t\t\tcompatible = \"raspberrypi,pico-clock\";",
  "result": "-\t\t\tcompatible = \"raspberrypi,pico-clock\";\n+\t\t\tcompatible = \"raspberrypi,pico-xosc\";\n+\t\t\tstartup-delay-multiplier = <64>;\n+# Copyright (c) 2024 Xudong Zheng\n+# SPDX-License-Identifier: Apache-2.0\n+\n+description: |\n+  The representation of Raspberry Pi Pico external oscillator\n+\n+compatible: \"raspberrypi,pico-xosc\"\n+\n+include: raspberrypi,pico-clock.yaml\n+\n+properties:\n+  startup-delay-multiplier:\n+    type: int\n+    description: Startup delay multiplier\n+#ifdef CONFIG_DT_HAS_RASPBERRYPI_PICO_XOSC_ENABLED\n+#include <zephyr/devicetree.h>\n+#define PICO_XOSC_STARTUP_DELAY_MULTIPLIER DT_PROP(DT_NODELABEL(xosc), startup_delay_multiplier)\n+#endif\n+"
},{
  "instruction": "drivers: usb: udc_dwc2: Restrict TxFIFO to SPRAM size",
  "input": "",
  "result": "+\t\t/* Do not allocate TxFIFO outside the SPRAM */\n+\t\tif (txfaddr + txfdep > priv->dfifodepth) {\n+\t\t\treturn -ENOMEM;\n+\t\t}\n+"
},{
  "instruction": "drivers: counter: shell: change callback functions to static",
  "input": "void timer_top_handler(const struct device *counter_dev, void *user_data)\nvoid timer_alarm_handler(const struct device *counter_dev, uint8_t chan_id,",
  "result": "-void timer_top_handler(const struct device *counter_dev, void *user_data)\n+static void timer_top_handler(const struct device *counter_dev, void *user_data)\n-void timer_alarm_handler(const struct device *counter_dev, uint8_t chan_id,\n+static void timer_alarm_handler(const struct device *counter_dev, uint8_t chan_id,"
},{
  "instruction": "dts: nios2: intel: Fix unit and first address mismatch",
  "input": "\t\tdma: dma@100200 {",
  "result": "-\t\tdma: dma@100200 {\n+\t\tdma: dma@1002c0 {"
},{
  "instruction": "dts: adding flexible memory controller (fmc) to H56x, H533",
  "input": "",
  "result": "+\n+\t\tfmc: memory-controller@47000400 {\n+\t\t\tcompatible = \"st,stm32-fmc\";\n+\t\t\treg = <0x47000400 0x400>;\n+\t\t\tclocks = <&rcc STM32_CLOCK_BUS_AHB4 0x00010000>;\n+\t\t\tstatus = \"disabled\";\n+\t\t};\n+\n+\t\tfmc: memory-controller@47000400 {\n+\t\t\tcompatible = \"st,stm32-fmc\";\n+\t\t\treg = <0x47000400 0x400>;\n+\t\t\tclocks = <&rcc STM32_CLOCK_BUS_AHB4 0x00010000>;\n+\t\t\tstatus = \"disabled\";\n+\t\t};"
},{
  "instruction": "scripts: check_compliance: Fix incorrect soc root lookup",
  "input": "       root_args = argparse.Namespace(**{'soc_roots': [Path(ZEPHYR_BASE)]})",
  "result": "-        root_args = argparse.Namespace(**{'soc_roots': [Path(ZEPHYR_BASE)]})\n+        root_args = argparse.Namespace(**{'soc_roots': soc_roots})"
},{
  "instruction": "doc: release: 4.0: add missing colon",
  "input": "     can be enabled witbh :kconfig:option`CONFIG_MCUMGR_GRP_OS_BOOTLOADER_INFO_HOOK`, the data",
  "result": "-      can be enabled witbh :kconfig:option`CONFIG_MCUMGR_GRP_OS_BOOTLOADER_INFO_HOOK`, the data\n+      can be enabled witbh :kconfig:option:`CONFIG_MCUMGR_GRP_OS_BOOTLOADER_INFO_HOOK`, the data"
},{
  "instruction": "west.yml: Update hal_stm32 with a fix on the stm32h7/L4/F7 drivers",
  "input": "     revision: 1e6116bd2a36db976d955ee772d21f329e529873",
  "result": "-      revision: 1e6116bd2a36db976d955ee772d21f329e529873\n+      revision: c4099c229323f305eef75ff6ba93ee9b89827581"
},{
  "instruction": "west.yml: update hostap revision",
  "input": "     revision: 7761b17eea9a2442af6ea9df830904fa4ba7bbca",
  "result": "-      revision: 7761b17eea9a2442af6ea9df830904fa4ba7bbca\n+      revision: cbae0170437dbe196d436b2b53d7aefb97044b0c"
},{
  "instruction": "hostap: add hostapd cli shell command",
  "input": "",
  "result": "+#ifdef CONFIG_WIFI_NM_HOSTAPD_AP\n+#include \"hostapd_cli_zephyr.h\"\n+#endif\n+#ifdef CONFIG_WIFI_NM_HOSTAPD_AP\n+static int cmd_hostapd_cli(const struct shell *sh, size_t argc, const char *argv[])\n+{\n+\tARG_UNUSED(sh);\n+\n+\tif (argc == 1) {\n+\t\tshell_error(sh, \"Missing argument\");\n+\t\treturn -EINVAL;\n+\t}\n+\n+\targv[argc] = \"interactive\";\n+\targc++;\n+\n+\t/* Remove hostapd_cli from the argument list */\n+\treturn zephyr_hostapd_ctrl_zephyr_cmd(argc - 1, &argv[1]);\n+}\n+#endif\n+\n+#ifdef CONFIG_WIFI_NM_HOSTAPD_AP\n+SHELL_CMD_REGISTER(hostapd_cli, NULL, \"hostapd_cli commands (only for internal use)\",\n+\t\t   cmd_hostapd_cli);\n+#endif"
},{
  "instruction": "boards: nordic: nrf52805: Fix slot1_partition base address",
  "input": "\t\tslot1_partition: partition@19000 {\n\t\t\treg = <0x00020000 0xe000>;",
  "result": "-\t\tslot1_partition: partition@19000 {\n+\t\tslot1_partition: partition@1a000 {\n-\t\t\treg = <0x00020000 0xe000>;\n+\t\t\treg = <0x0001a000 0xe000>;"
},{
  "instruction": "boards: infineon: cyw920829m2: Fix unit and first address mismatch",
  "input": "\t\t\t\tstorage_partition: storage_partition@70000 {",
  "result": "-\t\t\t\tstorage_partition: storage_partition@70000 {\n+\t\t\t\tstorage_partition: storage_partition@60000 {"
},{
  "instruction": "modules: tflite-micro: add batch_matmul.cc to cmakelists.txt",
  "input": "",
  "result": "+    ${TENSORFLOW_LITE_MICRO_DIR}/tensorflow/lite/micro/kernels/batch_matmul.cc"
},{
  "instruction": "net: Add onlink and forwarding check to IPv6-prepare",
  "input": "\t      net_ipv6_is_ll_addr((struct in6_addr *)ip_hdr->dst)) ||",
  "result": "-\t      net_ipv6_is_ll_addr((struct in6_addr *)ip_hdr->dst)) ||\n+\t      (net_ipv6_is_ll_addr((struct in6_addr *)ip_hdr->dst) ||\n+\t       net_if_ipv6_addr_onlink(NULL, (struct in6_addr *)ip_hdr->dst) ||\n+\t       net_pkt_forwarding(pkt))) ||"
},{
  "instruction": "doc: security: Disclose CVE-2024-6259",
  "input": "Under embargo until 2024-09-12",
  "result": "-Under embargo until 2024-09-12\n+BT: HCI: adv_ext_report Improper discarding in adv_ext_report\n+\n+  <https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-p5j7-v26w-wmcp>`_\n+\n+This has been fixed in main for v3.7.0\n+\n+  <https://github.com/zephyrproject-rtos/zephyr/pull/74639>`_\n+\n+  <https://github.com/zephyrproject-rtos/zephyr/pull/77960>`_"
},{
  "instruction": "doc: security: Disclose CVE-2024-6137",
  "input": "Under embargo until 2024-09-11",
  "result": "-Under embargo until 2024-09-11\n+BT: Classic: SDP OOB access in get_att_search_list\n+\n+  <https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-pm38-7g85-cf4f>`_\n+\n+This has been fixed in main for v3.7.0\n+\n+  <https://github.com/zephyrproject-rtos/zephyr/pull/75575>`_"
},{
  "instruction": "doc: security: Disclose CVE-2024-6135",
  "input": "Under embargo until 2024-09-11",
  "result": "-Under embargo until 2024-09-11\n+BT:Classic: Multiple missing buf length checks\n+\n+  <https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-2mp4-4g6f-cqcx>`_\n+\n+This has been fixed in main for v3.7.0\n+\n+  <https://github.com/zephyrproject-rtos/zephyr/pull/74283>`_\n+\n+  <https://github.com/zephyrproject-rtos/zephyr/pull/77964>`_"
},{
  "instruction": "doc: security: Disclose CVE-2024-5931",
  "input": "Under embargo until 2024-09-10",
  "result": "-Under embargo until 2024-09-10\n+BT: Unchecked user input in bap_broadcast_assistant\n+\n+  <https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-r8h3-64gp-wv7f>`_\n+\n+This has been fixed in main for v3.7.0\n+\n+  <https://github.com/zephyrproject-rtos/zephyr/pull/74062>`_\n+\n+  <https://github.com/zephyrproject-rtos/zephyr/pull/77966>`_\n+"
},{
  "instruction": "doc: security: Disclose CVE-2024-6258",
  "input": "Under embargo until 2024-09-05",
  "result": "-Under embargo until 2024-09-05\n+BT: Missing length checks of net_buf in rfcomm_handle_data\n+\n+  <https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-7833-fcpm-3ggm>`_\n+\n+This has been fixed in main for v3.7.0\n+\n+  <https://github.com/zephyrproject-rtos/zephyr/pull/74640>`_"
},{
  "instruction": "doc: security: Disclose CVE-2024-5754",
  "input": "Under embargo until 2024-09-04",
  "result": "-Under embargo until 2024-09-04\n+BT: Encryption procedure host vulnerability\n+\n+  <https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-gvv5-66hw-5qrc>`_\n+\n+This has been fixed in main for v3.7.0\n+\n+  <https://github.com/zephyrproject-rtos/zephyr/pull/7395>`_\n+\n+  <https://github.com/zephyrproject-rtos/zephyr/pull/74124>`_\n+\n+  <https://github.com/zephyrproject-rtos/zephyr/pull/74123>`_\n+\n+  <https://github.com/zephyrproject-rtos/zephyr/pull/74122>`_"
},{
  "instruction": "doc: security: Add CVE under embargo",
  "input": "",
  "result": "+\n+CVE-2024-8798\n+\n+Under embargo until 2024-11-22"
},{
  "instruction": "doc: relnotes/4.0: Add info about CVE-2024-8798",
  "input": "",
  "result": "+* CVE-2024-8798: Under embargo until 2024-11-22\n+"
},{
  "instruction": "net: shell: increase number of arguments to net suspend command",
  "input": "\t\t cmd_net_suspend, 1, 0);",
  "result": "-\t\t cmd_net_suspend, 1, 0);\n+\t\t cmd_net_suspend, 2, 0);"
},{
  "instruction": "drivers: spi: update casting for MSTP register",
  "input": "\t\t\t\t.mstp = (uint32_t *)DT_INST_CLOCKS_CELL_BY_NAME(index, spiclk,     \\\n\t\t\t\t\t\t\t\t\t\tmstp),             \\",
  "result": "-\t\t\t\t.mstp = (uint32_t *)DT_INST_CLOCKS_CELL_BY_NAME(index, spiclk,     \\\n-\t\t\t\t\t\t\t\t\t\tmstp),             \\\n+\t\t\t\t.mstp = (uint32_t)DT_INST_CLOCKS_CELL_BY_NAME(index, spiclk,       \\\n+\t\t\t\t\t\t\t\t\t      mstp),               \\"
},{
  "instruction": "drivers: video: gc2145: fixes the prefix",
  "input": "\tdepends on DT_HAS_GC_GC2145_ENABLED\n#define DT_DRV_COMPAT gc_gc2145\ncompatible: \"gc,gc2145\"",
  "result": "-\tdepends on DT_HAS_GC_GC2145_ENABLED\n+\tdepends on DT_HAS_GALAXYCORE_GC2145_ENABLED\n-#define DT_DRV_COMPAT gc_gc2145\n+#define DT_DRV_COMPAT galaxycore_gc2145\n-compatible: \"gc,gc2145\"\n+compatible: \"galaxycore,gc2145\""
},{
  "instruction": "doc: i2c, i3c: remove unnecessary preposition 'in'",
  "input": "in particularly the start and stop conditions and the clock.  This is\nthe bus, in particularly the start and stop conditions and the clock.",
  "result": "-in particularly the start and stop conditions and the clock.  This is\n+particularly the start and stop conditions and the clock.  This is\n-the bus, in particularly the start and stop conditions and the clock.\n+the bus, particularly the start and stop conditions and the clock."
},{
  "instruction": "boards: google: twinkie_v2: Fix unit and first address mismatch",
  "input": "\tchannel@15 {\n\tchannel@17 {\n\tchannel@18 {",
  "result": "-\tchannel@15 {\n+\tchannel@f {\n-\tchannel@17 {\n+\tchannel@11 {\n-\tchannel@18 {\n+\tchannel@12 {"
},{
  "instruction": "dts: arm: nxp: lpc55S0x: Fix unit and first address mismatch",
  "input": "\t\tuuid: flash@9fc70 {",
  "result": "-\t\tuuid: flash@9fc70 {\n+\t\tuuid: flash@3fc70 {"
},{
  "instruction": "dts: arm: nxp: lpc55S2x: Fix unit and first address mismatch",
  "input": "\tusbhs: usbhs@144000 {",
  "result": "-\tusbhs: usbhs@144000 {\n+\tusbhs: usbhs@94000 {"
},{
  "instruction": "dts: arm: nxp: lpc55S1x: Fix unit and first address mismatch",
  "input": "\t\tuuid: flash@9fc70 {",
  "result": "-\t\tuuid: flash@9fc70 {\n+\t\tuuid: flash@3fc70 {"
},{
  "instruction": "dts: arm: nxp: lpc55S1x: Fix unit and first address mismatch",
  "input": "\tusbhs: usbhs@144000 {",
  "result": "-\tusbhs: usbhs@144000 {\n+\tusbhs: usbhs@94000 {"
},{
  "instruction": "boards: nxp: imx8mp: Fix unit and first address mismatch",
  "input": "\tphy: phy@0 {",
  "result": "-\tphy: phy@0 {\n+\tphy: phy@1 {"
},{
  "instruction": "boards: nxp: frdm_kw41z: Fix unit and first address mismatch",
  "input": "\t\tstorage_partition: partition@700000 {",
  "result": "-\t\tstorage_partition: partition@700000 {\n+\t\tstorage_partition: partition@70000 {"
},{
  "instruction": "boards: nxp: frdm_mcxn236: Fix unit and first address mismatch",
  "input": "\t\tslot1_partition: partition@80000 {",
  "result": "-\t\tslot1_partition: partition@80000 {\n+\t\tslot1_partition: partition@88000 {"
},{
  "instruction": "boards: nxp: usb_kw24d512: Fix unit and first address mismatch",
  "input": "\t\tstorage_partition: partition@700000 {",
  "result": "-\t\tstorage_partition: partition@700000 {\n+\t\tstorage_partition: partition@70000 {"
},{
  "instruction": "boards: nxp: imx8mp_evk: Fix unit and first address mismatch",
  "input": "\tphy: phy@0 {",
  "result": "-\tphy: phy@0 {\n+\tphy: phy@1 {"
},{
  "instruction": "boards: nxp: imx93_evk: Fix unit and first address mismatch",
  "input": "\tphy: phy@0 {",
  "result": "-\tphy: phy@0 {\n+\tphy: phy@2 {"
},{
  "instruction": "drivers: i3c: shell: record getcaps in to desc from shell",
  "input": "",
  "result": "+\t\tmemcpy(&desc->getcaps, &caps, sizeof(desc->getcaps));"
},{
  "instruction": "drivers: i3c: add helper for if target is controller capable",
  "input": "\t\tif (I3C_BCR_DEVICE_ROLE(i3c_desc->bcr) ==\n\t\t    I3C_BCR_DEVICE_ROLE_I3C_CONTROLLER_CAPABLE) {",
  "result": "-\t\tif (I3C_BCR_DEVICE_ROLE(i3c_desc->bcr) ==\n-\t\t    I3C_BCR_DEVICE_ROLE_I3C_CONTROLLER_CAPABLE) {\n+\t\tif (i3c_device_is_controller_capable(i3c_desc)) {\n+/**\n+ * @brief Check if the target is controller capable\n+ *\n+ * This reads the BCR from the device descriptor struct to determine\n+ * whether the target is controller capable\n+ *\n+ * Note that BCR must have been obtained from device and\n+ * i3c_device_desc::bcr must be set.\n+ *\n+ * @return True if target is controller capable, false otherwise.\n+ */\n+static inline int i3c_device_is_controller_capable(struct i3c_device_desc *target)\n+{\n+\treturn I3C_BCR_DEVICE_ROLE(target->bcr)\n+\t\t== I3C_BCR_DEVICE_ROLE_I3C_CONTROLLER_CAPABLE;\n+}\n+\n+ * @param dev Pointer to controller device driver instance.\n+ *"
},{
  "instruction": "drivers: i3c: fix static addr for deftgts AC",
  "input": "\tdeftgts->active_controller.static_addr = config_target.static_addr << 1;",
  "result": "-\tdeftgts->active_controller.static_addr = config_target.static_addr << 1;\n+\tdeftgts->active_controller.static_addr = I3C_BROADCAST_ADDR << 1;"
},{
  "instruction": "drivers: i3c: add missing parameter to doxygen for deftgts",
  "input": "",
  "result": "+ * @param dev Pointer to controller device driver instance.\n+ *"
},{
  "instruction": "tests: drivers: Fix adc labels in sensors test",
  "input": "\tio-channels = <&adc0 0>;\n\tio-channels = <&adc0 0>;",
  "result": "-\tio-channels = <&adc0 0>;\n+\tio-channels = <&test_adc 0>;\n-\tio-channels = <&adc0 0>;\n+\tio-channels = <&test_adc 0>;"
},{
  "instruction": "tests: build_all: sensor: Fix i2c duplicate address",
  "input": "test_i2c_sht21@91 {\ntest_i2c_icm42670: icm42670@92 {\n\treg = <0x92>;\ntest_i2c_fxls8974: fxls8974@93 {\n\treg = <0x93>;\ntest_i2c_bmp180: bmp180@94 {\n\treg = <0x94>;\ntest_i2c_apds9253: apds9253@91 {\n\treg = <0x91>;",
  "result": "-test_i2c_sht21@91 {\n+test_i2c_sht21: sht21@91 {\n-test_i2c_icm42670: icm42670@92 {\n+test_i2c_icm42670: icm42670@93 {\n-\treg = <0x92>;\n+\treg = <0x93>;\n-test_i2c_fxls8974: fxls8974@93 {\n+test_i2c_fxls8974: fxls8974@94 {\n-\treg = <0x93>;\n+\treg = <0x94>;\n-test_i2c_bmp180: bmp180@94 {\n+test_i2c_bmp180: bmp180@95 {\n-\treg = <0x94>;\n+\treg = <0x95>;\n-test_i2c_apds9253: apds9253@91 {\n+test_i2c_apds9253: apds9253@96 {\n-\treg = <0x91>;\n+\treg = <0x96>;"
},{
  "instruction": "arch: arm64: init xen in arch_kernel_init()",
  "input": "static int xen_enlighten_init(void)\nSYS_INIT(xen_enlighten_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE);",
  "result": "-static int xen_enlighten_init(void)\n+int xen_enlighten_init(void)\n-\n-SYS_INIT(xen_enlighten_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE);\n+extern void xen_enlighten_init(void);\n+\n+#ifdef CONFIG_XEN\n+\txen_enlighten_init();\n+#endif"
},{
  "instruction": "x86: init spec_ctrl in prep_c, do not use SYS_INIT",
  "input": "static int spec_ctrl_init(void)\nSYS_INIT(spec_ctrl_init, PRE_KERNEL_1, 0);",
  "result": "+\n+\n+extern int spec_ctrl_init(void);\n+\n+#if defined(CONFIG_X86_DISABLE_SSBD) || defined(CONFIG_X86_ENABLE_EXTENDED_IBRS)\n+\tspec_ctrl_init();\n+#endif\n-static int spec_ctrl_init(void)\n+int spec_ctrl_init(void)\n-SYS_INIT(spec_ctrl_init, PRE_KERNEL_1, 0);"
},{
  "instruction": "arm: init null pointer detection in prep_c, do not use SYS_INIT",
  "input": "static int z_arm_debug_enable_null_pointer_detection(void)\nSYS_INIT(z_arm_debug_enable_null_pointer_detection, PRE_KERNEL_1,\n\t CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);",
  "result": "-static int z_arm_debug_enable_null_pointer_detection(void)\n+int z_arm_debug_enable_null_pointer_detection(void)\n-SYS_INIT(z_arm_debug_enable_null_pointer_detection, PRE_KERNEL_1,\n-\t CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\n-\n+\n+#ifdef CONFIG_NULL_POINTER_EXCEPTION_DETECTION_DWT\n+\tz_arm_debug_enable_null_pointer_detection();\n+#endif"
},{
  "instruction": "arc: start secureshield in prep_c, do not use SYS_INIT",
  "input": "static int arc_secureshield_init(void)\n\treturn 0;\nSYS_INIT(arc_secureshield_init, PRE_KERNEL_1,\n\t\tCONFIG_KERNEL_INIT_PRIORITY_DEFAULT);",
  "result": "+extern void arc_secureshield_init(void);\n+#endif\n+#ifdef CONFIG_ARC_SECURE_FIRMWARE\n+\tarc_secureshield_init();\n-static int arc_secureshield_init(void)\n+void arc_secureshield_init(void)\n-\n-\treturn 0;\n-\n-SYS_INIT(arc_secureshield_init, PRE_KERNEL_1,\n-\t\tCONFIG_KERNEL_INIT_PRIORITY_DEFAULT);"
},{
  "instruction": "arc: start mpu in prep_c, do not use SYS_INIT",
  "input": "static int arc_mpu_init(void)\n\t\treturn -EINVAL;\n\treturn 0;\nSYS_INIT(arc_mpu_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\nstatic int arc_mpu_init(void)\n\t\treturn -EINVAL;\n\t\t\t\treturn -EINVAL;\n\treturn 0;\nSYS_INIT(arc_mpu_init, PRE_KERNEL_1,\n\t CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);",
  "result": "-static int arc_mpu_init(void)\n+void arc_mpu_init(void)\n-\t\treturn -EINVAL;\n-\n-\treturn 0;\n-SYS_INIT(arc_mpu_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\n-static int arc_mpu_init(void)\n+void arc_mpu_init(void)\n-\t\treturn -EINVAL;\n+\t\treturn;\n-\t\t\t\treturn -EINVAL;\n+\t\t\t\treturn;\n-\treturn 0;\n+\treturn;\n-SYS_INIT(arc_mpu_init, PRE_KERNEL_1,\n-\t CONFIG_KERNEL_INIT_PRIORITY_DEFAULT);\n+extern void arc_mpu_init(void);\n+\n+#endif\n+#ifdef CONFIG_ARC_MPU\n+\tarc_mpu_init();"
},{
  "instruction": "drivers: gpio: stm32: Fix compiler warning",
  "input": "static inline uint32_t ll_gpio_get_pin_pull(GPIO_TypeDef *GPIOx, uint32_t Pin)",
  "result": "-static inline uint32_t ll_gpio_get_pin_pull(GPIO_TypeDef *GPIOx, uint32_t Pin)\n+__maybe_unused static inline uint32_t ll_gpio_get_pin_pull(GPIO_TypeDef *GPIOx, uint32_t Pin)"
},{
  "instruction": "edtlib: Remove unreachable code",
  "input": "               continue",
  "result": "-                continue"
},{
  "instruction": "drivers: sensors: fix compile error due to conflicting types.",
  "input": "\t\t\t\t\t\t       const enum sensor_channel *channels,",
  "result": "-\t\t\t\t\t\t       const enum sensor_channel *channels,\n+\t\t\t\t\t\t       const struct sensor_chan_spec *channels,"
},{
  "instruction": "boards: witte: linum: mention the board website",
  "input": "",
  "result": "+More information about the board, can be found at the `Witte Linum website`_.\n+"
},{
  "instruction": "boards: witte: linum: fix documentation",
  "input": ":zephyr_file:`boards/witte_technology/linum/linum_defconfig`",
  "result": "-:zephyr_file:`boards/witte_technology/linum/linum_defconfig`\n+:zephyr_file:`boards/witte/linum/linum_defconfig`"
},{
  "instruction": "xtensa: add kconfig to allow non-preemptible interrupts",
  "input": "",
  "result": "+config XTENSA_INTERRUPT_NONPREEMPTABLE\n+\tbool \"Xtensa exceptions and interrupts cannot be pre-empted\"\n+\thelp\n+\t  Allow use of medium and high priority interrupts without\n+\t  pre-empting low priority interrupts and exceptions.\n+\n+#ifdef CONFIG_XTENSA_INTERRUPT_NONPREEMPTABLE\n+\n+\t/* Setting the interrupt mask to the max non-debug level\n+\t * to prevent lower priority interrupts being preempted by\n+\t * high level interrupts until processing of that lower level\n+\t * interrupt has completed.\n+\t */\n+\trsr.ps a0\n+\tmovi a3, ~(PS_INTLEVEL_MASK)\n+\tand a0, a0, a3\n+\tmovi a3, PS_INTLEVEL(ZSR_RFI_LEVEL)\n+\tor a0, a0, a3\n+\twsr.ps a0\n+\n+#else\n+\n+\n+#endif /* CONFIG_XTENSA_INTERRUPT_NONPREEMPTABLE */"
},{
  "instruction": "kscan: mark the kscan driver class as deprecated",
  "input": "\tbool \"Keyboard scan drivers\"",
  "result": "+.. note:: Kscan APIs are deprecated, any driver and applications should be\n+   ported over to use :ref:`input` instead.\n+\n+\n+* The :ref:`kscan_api` subsystem has been marked as deprecated.\n+\n-\tbool \"Keyboard scan drivers\"\n+\tbool \"Keyboard scan drivers [DEPRECATED]\"\n+\tselect DEPRECATED\n+ * @deprecated\n+ * @deprecated\n+ * @deprecated\n+ * @deprecated\n+ * @deprecated\n+ * @deprecated"
},{
  "instruction": "soc: arm: nxp: fix USB w/ SPEED_OPTIMIZATIONS",
  "input": "\t*((uint32_t *)(USBFSH_BASE + 0x5C)) |= USBFSH_PORTMODE_DEV_ENABLE_MASK;\n\t*((uint32_t *)(USBHSH_BASE + 0x50)) = USBHSH_PORTMODE_SW_PDCOM_MASK;\n\t*((uint32_t *)(USBHSH_BASE + 0x50)) |= USBHSH_PORTMODE_DEV_ENABLE_MASK;",
  "result": "-\t*((uint32_t *)(USBFSH_BASE + 0x5C)) |= USBFSH_PORTMODE_DEV_ENABLE_MASK;\n+\tUSBFSH->PORTMODE |= USBFSH_PORTMODE_DEV_ENABLE_MASK;\n-\t*((uint32_t *)(USBHSH_BASE + 0x50)) = USBHSH_PORTMODE_SW_PDCOM_MASK;\n+\tUSBHSH->PORTMODE = USBHSH_PORTMODE_SW_PDCOM_MASK;\n-\t*((uint32_t *)(USBHSH_BASE + 0x50)) |= USBHSH_PORTMODE_DEV_ENABLE_MASK;\n+\tUSBHSH->PORTMODE |= USBHSH_PORTMODE_DEV_ENABLE_MASK;"
},{
  "instruction": "samples: bluetooth: remove outdated platform_exclude",
  "input": "   # FIXME: exclude due to build error\n   platform_exclude: 96b_carbon stm32l562e_dk",
  "result": "-    # FIXME: exclude due to build error\n-    platform_exclude: 96b_carbon stm32l562e_dk"
},{
  "instruction": "llext: (cosmetic) fix a name in an error message",
  "input": "\tzassert_not_null(test_entry_fn, \"test_dependent should be an exported symbol\");",
  "result": "-\tzassert_not_null(test_entry_fn, \"test_dependent should be an exported symbol\");\n+\tzassert_not_null(test_entry_fn, \"test_entry should be an exported symbol\");"
},{
  "instruction": "MAINTAINERS: add mmahadevan108 as second maintainer for NXP",
  "input": " collaborators:\n collaborators:\n collaborators:",
  "result": "-  collaborators:\n+  collaborators:\n-  collaborators:\n+  collaborators:\n-  collaborators:\n+  collaborators:"
},{
  "instruction": "cmake: Add REQUIRED option to devicetree getters",
  "input": " cmake_parse_arguments(DT_LABEL \"\" \"${req_single_args}\" \"\" ${ARGN})\n cmake_parse_arguments(DT_ALIAS \"\" \"${req_single_args}\" \"\" ${ARGN})\n cmake_parse_arguments(DT_PROP \"\" \"${req_single_args};${single_args}\" \"\" ${ARGN})",
  "result": "+# REQUIRED           : Generate a fatal error if the node-label is not found\n+  set(options \"REQUIRED\")\n-  cmake_parse_arguments(DT_LABEL \"\" \"${req_single_args}\" \"\" ${ARGN})\n+  cmake_parse_arguments(DT_LABEL \"${options}\" \"${req_single_args}\" \"\" ${ARGN})\n+    if(DT_LABEL_REQUIRED)\n+      message(FATAL_ERROR \"required nodelabel not found: ${DT_LABEL_NODELABEL}\")\n+    endif()\n+# REQUIRED        : Generate a fatal error if the alias is not found\n+  set(options \"REQUIRED\")\n-  cmake_parse_arguments(DT_ALIAS \"\" \"${req_single_args}\" \"\" ${ARGN})\n+  cmake_parse_arguments(DT_ALIAS \"${options}\" \"${req_single_args}\" \"\" ${ARGN})\n+    if(DT_ALIAS_REQUIRED)\n+      message(FATAL_ERROR \"required alias not found: ${DT_ALIAS_PROPERTY}\")\n+    endif()\n+# REQUIRED       : Generate a fatal error if the property is not found\n+  set(options \"REQUIRED\")\n-  cmake_parse_arguments(DT_PROP \"\" \"${req_single_args};${single_args}\" \"\" ${ARGN})\n+  cmake_parse_arguments(DT_PROP \"${options}\" \"${req_single_args};${single_args}\" \"\" ${ARGN})\n+    if(DT_PROP_REQUIRED)\n+      message(FATAL_ERROR \"required property not found: ${canonical}/${DT_PROP_PROPERTY}\")\n+    endif()"
},{
  "instruction": "modules: hostap: Add wifi statistics reset support",
  "input": "",
  "result": "+\n+int supplicant_reset_stats(const struct device *dev)\n+{\n+\tconst struct wifi_mgmt_ops *const wifi_mgmt_api = get_wifi_mgmt_api(dev);\n+\n+\tif (!wifi_mgmt_api || !wifi_mgmt_api->reset_stats) {\n+\t\twpa_printf(MSG_WARNING, \"Reset stats not supported\");\n+\t\treturn -ENOTSUP;\n+\t}\n+\n+\treturn wifi_mgmt_api->reset_stats(dev);\n+}\n+/**\n+ * @brief Reset Wi-Fi statistics\n+ *\n+ * @param dev Wi-Fi interface name to use\n+ *\n+ * @return 0 for OK; -1 for ERROR\n+ */\n+int supplicant_reset_stats(const struct device *dev);\n+\t.reset_stats = supplicant_reset_stats,"
},{
  "instruction": "Bluetooth: Host: Defer `conn.recycled()` to the syswq",
  "input": "\t\tnotify_recycled_conn_slot();",
  "result": "+static K_SEM_DEFINE(pending_recycled_events, 0, K_SEM_MAX_LIMIT);\n+\n+static void recycled_work_handler(struct k_work *work)\n+{\n+\tif (k_sem_take(&pending_recycled_events, K_NO_WAIT) == 0) {\n+\t\tnotify_recycled_conn_slot();\n+\t\tk_work_submit(work);\n+\t}\n+}\n+\n+static K_WORK_DEFINE(recycled_work, recycled_work_handler);\n+\n-\t\tnotify_recycled_conn_slot();\n+\t\tk_sem_give(&pending_recycled_events);\n+\t\tk_work_submit(&recycled_work);"
},{
  "instruction": "boards: esp8684_devkitm: Update doc and .yaml for SPI support",
  "input": "",
  "result": "+| SPI Master | on-chip    | spi                                 |\n+| SPI DMA    | on-chip    | spi                                 |\n+  - spi"
},{
  "instruction": "drivers: video: esp32s3",
  "input": "",
  "result": "+\tif (video_stream_start(cfg->source_dev)) {\n+\t\treturn -EIO;\n+\t}\n+\n+\tif (video_stream_stop(cfg->source_dev)) {\n+\t\treturn -EIO;\n+\t}\n+"
},{
  "instruction": "net: lwm2m: check each block for TLV header",
  "input": "\t/* In case of block transfer go directly to the\n\t * message processing - consecutive blocks will not carry the TLV\n\t * header.\n\t\treturn 0;",
  "result": "-\t/* In case of block transfer go directly to the\n-\t * message processing - consecutive blocks will not carry the TLV\n-\t * header.\n+\t/* In case of block transfer, check if there are any fragments\n+\t * left from the previous resource (instance). If this is the\n+\t * case, proceed directly to processing the message -\n+\t * consecutive blocks from the same resource do not carry the\n+\t * TLV header.\n-\t\treturn 0;"
},{
  "instruction": "net: lwm2m: check lwm2m path level while getting the block ctx",
  "input": "\t\tif (memcmp(path, &block1_contexts[i].path,\n\t\t\t  sizeof(struct lwm2m_obj_path)) == 0) {",
  "result": "-\t\tif (memcmp(path, &block1_contexts[i].path,\n-\t\t\t  sizeof(struct lwm2m_obj_path)) == 0) {\n+\t\tif (lwm2m_obj_path_equal(path, &block1_contexts[i].path)) {"
},{
  "instruction": "doc: release: 4.0: Add note on new MCUmgr bootloader info hook",
  "input": "",
  "result": "+    * Added support for custom os mgmt bootloader info responses using notification hooks, this\n+      can be enabled witbh :kconfig:option`CONFIG_MCUMGR_GRP_OS_BOOTLOADER_INFO_HOOK`, the data\n+      structure is :c:struct:`os_mgmt_bootloader_info_data`."
},{
  "instruction": "soc: mimxrt685s/cm33: Fix lockup on clock config",
  "input": "#if DT_NODE_HAS_COMPAT_STATUS(DT_NODELABEL(dmic0), nxp_dmic, okay)",
  "result": "+config AUDIO_DMIC_MCUX\n+\tselect INIT_AUDIO_PLL\n+\n-#if DT_NODE_HAS_COMPAT_STATUS(DT_NODELABEL(dmic0), nxp_dmic, okay)\n+#if DT_NODE_HAS_COMPAT_STATUS(DT_NODELABEL(dmic0), nxp_dmic, okay) && CONFIG_INIT_AUDIO_PLL"
},{
  "instruction": "dts: arm: st:  add digi-temp node in dtsi file",
  "input": "",
  "result": "+\n+\t\tdigi_die_temp: digi_dietemp@40008c00 {\n+\t\t\tcompatible = \"st,stm32-digi-temp\";\n+\t\t\treg = <0x40008c00 0x400>;\n+\t\t\tinterrupts = <113 0>;\n+\t\t\tinterrupt-names = \"digi_temp\";\n+\t\t\tclocks = <&rcc STM32_CLOCK_BUS_APB1_2 0x00000008>;\n+\t\t\tstatus = \"disabled\";\n+\t\t};\n+\tdie_temp: dietemp {\n+\t\tcompatible = \"st,stm32-temp-cal\";\n+\t\tts-cal1-addr = <0x0BF90710>;\n+\t\tts-cal2-addr = <0x0BF90742>;\n+\t\tts-cal1-temp = <30>;\n+\t\tts-cal2-temp = <130>;\n+\t\tts-cal-vrefanalog = <3000>;\n+\t\tio-channels = <&adc4 13>;\n+\t\tstatus = \"disabled\";\n+\t};\n+"
},{
  "instruction": "scripts: twister: handlers: Enable BinaryHandler to run sysbuilt tests",
  "input": "           command = [self.generator_cmd, \"run\"]\n   (False, True, False, 123, None, ['generator', 'run', '--seed=123']),",
  "result": "-            command = [self.generator_cmd, \"run\"]\n+            command = [self.generator_cmd, \"-C\", self.get_default_domain_build_dir(), \"run\"]\n-    (False, True, False, 123, None, ['generator', 'run', '--seed=123']),\n+    (False, True, False, 123, None, ['generator', '-C', 'build_dir', 'run', '--seed=123']),"
},{
  "instruction": "modules: tflite-micro: Fix CMakeLists.txt",
  "input": "# Copyright 2022 Arm Limited and/or its affiliates <open-source-office@arm.com>",
  "result": "-# Copyright 2022 Arm Limited and/or its affiliates <open-source-office@arm.com>\n+# Copyright 2022, 2024 Arm Limited and/or its affiliates <open-source-office@arm.com>\n+    ${TENSORFLOW_LITE_MICRO_DIR}/tensorflow/lite/micro/kernels/strided_slice_common.cc"
},{
  "instruction": "drivers: i2s: esp32: remove unused code",
  "input": "\tconst struct i2s_esp32_cfg *dev_cfg = dev->config;\n\tconst struct i2s_esp32_cfg *dev_cfg = dev->config;",
  "result": "-\tconst struct i2s_esp32_cfg *dev_cfg = dev->config;\n-\tconst struct i2s_esp32_cfg *dev_cfg = dev->config;"
},{
  "instruction": "ci: doc: build the documentation using GitHub-hosted runners",
  "input": "   runs-on:\n     group: zephyr-runner-v2-linux-x64-4xlarge\n   - name: Print cloud service information\n     run: |\n       echo \"ZEPHYR_RUNNER_CLOUD_PROVIDER = ${ZEPHYR_RUNNER_CLOUD_PROVIDER}\"\n       echo \"ZEPHYR_RUNNER_CLOUD_NODE = ${ZEPHYR_RUNNER_CLOUD_NODE}\"\n       echo \"ZEPHYR_RUNNER_CLOUD_POD = ${ZEPHYR_RUNNER_CLOUD_POD}\"\n   runs-on:\n     group: zephyr-runner-v2-linux-x64-4xlarge\n   - name: Print cloud service information\n     run: |\n       echo \"ZEPHYR_RUNNER_CLOUD_PROVIDER = ${ZEPHYR_RUNNER_CLOUD_PROVIDER}\"\n       echo \"ZEPHYR_RUNNER_CLOUD_NODE = ${ZEPHYR_RUNNER_CLOUD_NODE}\"\n       echo \"ZEPHYR_RUNNER_CLOUD_POD = ${ZEPHYR_RUNNER_CLOUD_POD}\"",
  "result": "-    runs-on:\n-      group: zephyr-runner-v2-linux-x64-4xlarge\n+    runs-on: ubuntu-22.04\n-    - name: Print cloud service information\n-      run: |\n-        echo \"ZEPHYR_RUNNER_CLOUD_PROVIDER = ${ZEPHYR_RUNNER_CLOUD_PROVIDER}\"\n-        echo \"ZEPHYR_RUNNER_CLOUD_NODE = ${ZEPHYR_RUNNER_CLOUD_NODE}\"\n-        echo \"ZEPHYR_RUNNER_CLOUD_POD = ${ZEPHYR_RUNNER_CLOUD_POD}\"\n-\n-    runs-on:\n-      group: zephyr-runner-v2-linux-x64-4xlarge\n+    runs-on: ubuntu-22.04\n-    - name: Print cloud service information\n-      run: |\n-        echo \"ZEPHYR_RUNNER_CLOUD_PROVIDER = ${ZEPHYR_RUNNER_CLOUD_PROVIDER}\"\n-        echo \"ZEPHYR_RUNNER_CLOUD_NODE = ${ZEPHYR_RUNNER_CLOUD_NODE}\"\n-        echo \"ZEPHYR_RUNNER_CLOUD_POD = ${ZEPHYR_RUNNER_CLOUD_POD}\"\n-"
},{
  "instruction": "cpp: Fix warnings",
  "input": "#define Z_EMUL_REG_BUS_IDENTIFIER(_dev_node_id) (_CONCAT(_CONCAT(__emulreg_, _dev_node_id), _bus))\n\tuint8_t data;\n\tuint8_t data;",
  "result": "-#define Z_EMUL_REG_BUS_IDENTIFIER(_dev_node_id) (_CONCAT(_CONCAT(__emulreg_, _dev_node_id), _bus))\n+#define Z_EMUL_REG_BUS_IDENTIFIER(_dev_node_id) _CONCAT(_CONCAT(__emulreg_, _dev_node_id), _bus)\n-\tuint8_t data;\n+\tuint8_t data = 0;\n-\tuint8_t data;\n+\tuint8_t data = 0;"
},{
  "instruction": "doc: kernel/arch: fix some wrong doxygen references",
  "input": "* Sets the IRQ line <irq> to trigger an interrupt based on the level or the\n* edge of the signal. Valid values for <trigger> are _ARC_V2_INT_LEVEL and\n* Gets the IRQ line <irq> trigger type.\n* Valid values for <trigger> are _ARC_V2_INT_LEVEL and _ARC_V2_INT_PULSE.\n* The @ref _current value may have changed after this call and not refer",
  "result": "- * Sets the IRQ line <irq> to trigger an interrupt based on the level or the\n- * edge of the signal. Valid values for <trigger> are _ARC_V2_INT_LEVEL and\n+ * Sets the IRQ line @p irq to trigger an interrupt based on the level or the\n+ * edge of the signal. Valid values for @p trigger are _ARC_V2_INT_LEVEL and\n+ * @param irq IRQ line\n+ * @param trigger Trigger state\n- * Gets the IRQ line <irq> trigger type.\n- * Valid values for <trigger> are _ARC_V2_INT_LEVEL and _ARC_V2_INT_PULSE.\n+ * Gets the IRQ line @p irq trigger type.\n+ * Valid values for @retval trigger are _ARC_V2_INT_LEVEL and _ARC_V2_INT_PULSE.\n+ *\n+ * @param irq IRQ line\n- * The @ref _current value may have changed after this call and not refer\n+ * The _current value may have changed after this call and not refer"
},{
  "instruction": "doc: kernel: define additional doxygen groups",
  "input": "",
  "result": "+@brief Tests\n+@defgroup all_tests Tests\n+@{\n+@}\n+\n+@defgroup kernel_memprotect_tests Memory Protection\n+@ingroup all_tests\n+@{\n+@}\n+\n+\n+"
},{
  "instruction": "tests: kernel: fix test groups for semaphore/mutex",
  "input": "* @brief Test semaphore initialization at running time",
  "result": "+\n+\n+/**\n+ * @defgroup kernel_mutex_tests Mutexes\n+ * @ingroup all_tests\n+ * @{\n+ * @}\n+ */\n+\n+\n+/**\n+ * @defgroup kernel_semaphore_tests Semaphores\n+ * @ingroup all_tests\n+ * @{\n+ * @}\n+ */\n+\n- * @brief Test semaphore initialization at running time\n+ * @brief Test semaphore initialization at runtime"
},{
  "instruction": "drivers: dac_stm32: make pinctrl config in the device tree optional",
  "input": "\tif (err < 0) {\n pinctrl-0:\n   required: true\n pinctrl-names:\n   required: true",
  "result": "-\tif (err < 0) {\n+\tif ((err < 0) && (err != -ENOENT)) {\n-  pinctrl-0:\n-    required: true\n-\n-  pinctrl-names:\n-    required: true\n-"
},{
  "instruction": "drivers: dac: add flag to channel config to support internal connections",
  "input": "\tbool buffered;",
  "result": "-\tbool buffered;\n+\tbool buffered: 1;\n+\t/** Enable internal output path for this channel. This is relevant for channels that\n+\t * support directly connecting to on-chip peripherals via internal paths. The actual\n+\t * details on this are hardware dependent.\n+\t */\n+\tbool internal: 1;"
},{
  "instruction": "drivers: i3c: shell: use `shell_fprintf_normal` instead of `shell_fprintf`",
  "input": "\t\tshell_fprintf(sh, SHELL_NORMAL, \"%02x: \", i);\n\t\t\t\tshell_fprintf(sh, SHELL_NORMAL, \"   \");\n\t\t\t\t\tshell_fprintf(sh, SHELL_NORMAL, \"%02x \", i + j);\n\t\t\t\t\tshell_fprintf(sh, SHELL_NORMAL, \"-- \");\n\t\t\t\tshell_fprintf(sh, SHELL_NORMAL, \"I3 \");\n\t\t\t\tshell_fprintf(sh, SHELL_NORMAL, \"I2 \");\n\t\t\t\tshell_fprintf(sh, SHELL_NORMAL, \"RS \");\n\t\t\t\tshell_fprintf(sh, SHELL_NORMAL, \"-- \");",
  "result": "-\t\tshell_fprintf(sh, SHELL_NORMAL, \"%02x: \", i);\n+\t\tshell_fprintf_normal(sh, \"%02x: \", i);\n-\t\t\t\tshell_fprintf(sh, SHELL_NORMAL, \"   \");\n+\t\t\t\tshell_fprintf_normal(sh, \"   \");\n-\t\t\t\t\tshell_fprintf(sh, SHELL_NORMAL, \"%02x \", i + j);\n+\t\t\t\t\tshell_fprintf_normal(sh, \"%02x \", i + j);\n-\t\t\t\t\tshell_fprintf(sh, SHELL_NORMAL, \"-- \");\n+\t\t\t\t\tshell_fprintf_normal(sh, \"-- \");\n-\t\t\t\tshell_fprintf(sh, SHELL_NORMAL, \"I3 \");\n+\t\t\t\tshell_fprintf_normal(sh, \"I3 \");\n-\t\t\t\tshell_fprintf(sh, SHELL_NORMAL, \"I2 \");\n+\t\t\t\tshell_fprintf_normal(sh, \"I2 \");\n-\t\t\t\tshell_fprintf(sh, SHELL_NORMAL, \"RS \");\n+\t\t\t\tshell_fprintf_normal(sh, \"RS \");\n-\t\t\t\tshell_fprintf(sh, SHELL_NORMAL, \"-- \");\n+\t\t\t\tshell_fprintf_normal(sh, \"-- \");"
},{
  "instruction": "drivers: i3c: shell: fix compilation error in `cmd_i3c_ccc_getmxds`",
  "input": "\t\t\tdesc->maxwr = mxds.fmt3.wrrdturn[0];\n\t\t\tdesc->maxrd = mxds.fmt3.wrrdturn[1];\n\t\t\tdesc->max_read_turnaround = sys_get_le24(&mxds.fmt3.wrrdturn[2]);\n\t\tdesc->maxwr = mxds.fmt2.maxwr;\n\t\tdesc->maxrd = mxds.fmt2.maxrd;\n\t\tdesc->max_read_turnaround = sys_get_le24(mxds.fmt2.maxrdturn);",
  "result": "-\t\t\tdesc->maxwr = mxds.fmt3.wrrdturn[0];\n-\t\t\tdesc->maxrd = mxds.fmt3.wrrdturn[1];\n-\t\t\tdesc->max_read_turnaround = sys_get_le24(&mxds.fmt3.wrrdturn[2]);\n+\t\t\tdesc->data_speed.maxwr = mxds.fmt3.wrrdturn[0];\n+\t\t\tdesc->data_speed.maxrd = mxds.fmt3.wrrdturn[1];\n+\t\t\tdesc->data_speed.max_read_turnaround = sys_get_le24(&mxds.fmt3.wrrdturn[2]);\n-\t\tdesc->maxwr = mxds.fmt2.maxwr;\n-\t\tdesc->maxrd = mxds.fmt2.maxrd;\n-\t\tdesc->max_read_turnaround = sys_get_le24(mxds.fmt2.maxrdturn);\n+\t\tdesc->data_speed.maxwr = mxds.fmt2.maxwr;\n+\t\tdesc->data_speed.maxrd = mxds.fmt2.maxrd;\n+\t\tdesc->data_speed.max_read_turnaround = sys_get_le24(mxds.fmt2.maxrdturn);"
},{
  "instruction": "tests: bluetooth: mesh_shell: add brg_cfg_srv instance",
  "input": "",
  "result": "+#if defined(CONFIG_BT_MESH_BRG_CFG_SRV)\n+\tBT_MESH_MODEL_BRG_CFG_SRV,\n+#endif"
},{
  "instruction": "bluetooth: mesh: brg_cfg_srv: check buf tailroom before packing data",
  "input": "",
  "result": "+\t\tif (net_buf_simple_tailroom(&msg) < 3 + BT_MESH_MIC_SHORT) {\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\t\t\tif (net_buf_simple_tailroom(&msg) < 5 + BT_MESH_MIC_SHORT) {\n+\t\t\t\t\tLOG_WRN(\"Bridging Table List message too large\");\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+"
},{
  "instruction": "bluetooth: mesh: adv_ext: resched main adv set if relay doesn't have own",
  "input": "\t/* Attempt to use the main adv set for the sending of relay messages. */\n\tif (IS_ENABLED(CONFIG_BT_MESH_ADV_EXT_RELAY_USING_MAIN_ADV_SET)) {",
  "result": "-\t/* Attempt to use the main adv set for the sending of relay messages. */\n-\tif (IS_ENABLED(CONFIG_BT_MESH_ADV_EXT_RELAY_USING_MAIN_ADV_SET)) {\n+\t/* Use the main adv set for the sending of relay messages. */\n+\tif (IS_ENABLED(CONFIG_BT_MESH_ADV_EXT_RELAY_USING_MAIN_ADV_SET) ||\n+\t    CONFIG_BT_MESH_RELAY_ADV_SETS == 0) {"
},{
  "instruction": "bluetooth: mesh: net: bridge traffic regardless of relay state",
  "input": "\t\t\t      struct bt_mesh_net_rx *rx, bool update_nid)\n\tif (rx->friend_cred || update_nid) {\n\tif (relay_to_adv(rx->net_if) || rx->friend_cred) {",
  "result": "-\t\t\t      struct bt_mesh_net_rx *rx, bool update_nid)\n+\t\t\t      struct bt_mesh_net_rx *rx, bool bridge)\n+\t    !bridge &&\n-\tif (rx->friend_cred || update_nid) {\n+\tif (rx->friend_cred || bridge) {\n-\tif (relay_to_adv(rx->net_if) || rx->friend_cred) {\n+\tif (relay_to_adv(rx->net_if) || rx->friend_cred || bridge) {"
},{
  "instruction": "bluetooth: mesh: brg_cfg: add constants for directions",
  "input": "",
  "result": "+/* Briding from Addr1 to Addr2. */\n+#define BT_MESH_SUBNET_BRIDGE_DIR_ONEWAY 1\n+/* Bidirectional briging between Addr1 and Addr2. */\n+#define BT_MESH_SUBNET_BRIDGE_DIR_TWOWAY 2\n+"
},{
  "instruction": "bluetooth: mesh: brg_cfg: fix restoring bridging table",
  "input": "\tint err = bt_mesh_settings_set(read_cb, cb_arg, brg_tbl, sizeof(brg_tbl));\n\tif (err) {\n\t\tLOG_ERR(\"Failed to set bridging table entries\");\n\t\treturn err;\n\tLOG_DBG(\"Restored bridging table\");",
  "result": "+\tssize_t len;\n+\n-\tint err = bt_mesh_settings_set(read_cb, cb_arg, brg_tbl, sizeof(brg_tbl));\n+\tif (len_rd % sizeof(brg_tbl[0])) {\n+\t\tLOG_ERR(\"Invalid data size\");\n+\t\treturn -EINVAL;\n+\t}\n-\tif (err) {\n-\t\tLOG_ERR(\"Failed to set bridging table entries\");\n-\t\treturn err;\n+\tif (len_rd > sizeof(brg_tbl)) {\n+\t\tLOG_ERR(\"Too many entries to fit in bridging table\");\n+\t\treturn -ENOMEM;\n+\t}\n+\n+\tlen = read_cb(cb_arg, brg_tbl, sizeof(brg_tbl));\n+\tif (len < 0 || len % sizeof(brg_tbl[0])) {\n+\t\tLOG_ERR(\"Failed to read bridging table entries (err %zd)\", len);\n+\t\treturn len < 0 ? len : -EINVAL;\n-\tLOG_DBG(\"Restored bridging table\");\n+\tbt_mesh_brg_cfg_row_cnt = len / sizeof(brg_tbl[0]);\n+\tLOG_DBG(\"Restored %d entries in bridging table\", bt_mesh_brg_cfg_row_cnt);"
},{
  "instruction": "Bluetooth: Mesh: Fixed bugs found in PTS testing",
  "input": "\tBT_MESH_MODEL_CB(BT_MESH_MODEL_ID_BRG_CFG_SRV, bt_mesh_brg_cfg_srv_op,     \\\n\t\t\t NULL, NULL, &bt_mesh_brg_cfg_srv_cb)\n\t\t\t\tbrg_tbl_compact();\n\t\tentry.directions = 0;",
  "result": "-\tBT_MESH_MODEL_CB(BT_MESH_MODEL_ID_BRG_CFG_SRV, bt_mesh_brg_cfg_srv_op,     \\\n-\t\t\t NULL, NULL, &bt_mesh_brg_cfg_srv_cb)\n+\tBT_MESH_MODEL_CB(BT_MESH_MODEL_ID_BRG_CFG_SRV, _bt_mesh_brg_cfg_srv_op,     \\\n+\t\t\t NULL, NULL, &_bt_mesh_brg_cfg_srv_cb)\n-\t\t\t\tbrg_tbl_compact();\n+\n+\t/* Compact when all rows have been deleted. */\n+\tbrg_tbl_compact();\n+\n+\tentry.directions = 0;\n-\t\tentry.directions = 0;"
},{
  "instruction": "Bluetooth: Mesh: Change bridge table add params",
  "input": "struct bridging_table_entry {\n\tstruct bridging_table_entry entry;\n*  @param directions Allowed directions for the bridged traffic\n*  @param net_idx1   NetKey Index of the first subnet\n*  @param net_idx2   NetKey Index of the second subnet\n*  @param addr1      Address of the node in the first subnet\n*  @param addr2      Address of the node in the second subnet\nint bt_mesh_brg_cfg_cli_bridging_table_add(uint16_t net_idx, uint16_t addr, uint8_t directions,\n\t\t\t\t\t   uint16_t net_idx1, uint16_t net_idx2,\n\t\t\t\t\t   uint16_t addr1, uint16_t addr2,",
  "result": "-struct bridging_table_entry {\n+struct bt_mesh_bridging_table_entry {\n-\tstruct bridging_table_entry entry;\n+\tstruct bt_mesh_bridging_table_entry entry;\n- *  @param directions Allowed directions for the bridged traffic\n- *  @param net_idx1   NetKey Index of the first subnet\n- *  @param net_idx2   NetKey Index of the second subnet\n- *  @param addr1      Address of the node in the first subnet\n- *  @param addr2      Address of the node in the second subnet\n+ *  @param entry      Pointer to bridging Table entry to add.\n-int bt_mesh_brg_cfg_cli_bridging_table_add(uint16_t net_idx, uint16_t addr, uint8_t directions,\n-\t\t\t\t\t   uint16_t net_idx1, uint16_t net_idx2,\n-\t\t\t\t\t   uint16_t addr1, uint16_t addr2,\n+int bt_mesh_brg_cfg_cli_bridging_table_add(uint16_t net_idx, uint16_t addr,\n+\t\t\t\t\t   struct bt_mesh_bridging_table_entry *entry,"
},{
  "instruction": "Bluetooth: Mesh: Fix subnet bridge table status type",
  "input": "\tenum bt_mesh_subnet_bridge_state status;",
  "result": "-\tenum bt_mesh_subnet_bridge_state status;\n+\tuint8_t status;"
},{
  "instruction": "arch: common: Add user can specify the nocache location",
  "input": "} GROUP_DATA_LINK_IN(RAMABLE_REGION, RAMABLE_REGION)",
  "result": "+#if DT_NODE_HAS_STATUS(DT_CHOSEN(zephyr_nocache_ram), okay)\n+#define NOCACHE_REGION LINKER_DT_NODE_REGION_NAME_TOKEN(DT_CHOSEN(zephyr_nocache_ram))\n+#else\n+#define NOCACHE_REGION RAMABLE_REGION\n+#endif\n+\n-} GROUP_DATA_LINK_IN(RAMABLE_REGION, RAMABLE_REGION)\n+} GROUP_DATA_LINK_IN(NOCACHE_REGION, NOCACHE_REGION)"
},{
  "instruction": "boards: nxp: mimxrt1050: add LinkServer runner support for qspi board",
  "input": " board_runner_args(linkserver  \"--device=MIMXRT1052xxxxB:EVKB-IMXRT1050\")\n include(${ZEPHYR_BASE}/boards/common/linkserver.board.cmake)",
  "result": "+board_runner_args(linkserver \"--device=MIMXRT1052xxxxB:EVKB-IMXRT1050\")\n+  board_runner_args(linkserver \"--override=/device/memory/3/flash-driver=MIMXRT1050_SFDP_QSPI.cfx\")\n-  board_runner_args(linkserver  \"--device=MIMXRT1052xxxxB:EVKB-IMXRT1050\")\n-  include(${ZEPHYR_BASE}/boards/common/linkserver.board.cmake)\n+include(${ZEPHYR_BASE}/boards/common/linkserver.board.cmake)"
},{
  "instruction": "doc: ipc: icmsg: fix numbered list in bonding section",
  "input": "memory.\nhas been written. Sending the signal to the other domain or CPU is repeated\nwith timeout specified by\n:kconfig:option:`CONFIG_IPC_SERVICE_ICMSG_BOND_NOTIFY_REPEAT_TO_MS` option.\nis read from ``rx-region``. If it is correct, the bonding process is finished\nand the backend informs the application by calling\n:c:member:`ipc_service_cb.bound` callback.",
  "result": "-memory.\n+   memory.\n-has been written. Sending the signal to the other domain or CPU is repeated\n-with timeout specified by\n-:kconfig:option:`CONFIG_IPC_SERVICE_ICMSG_BOND_NOTIFY_REPEAT_TO_MS` option.\n+   has been written. Sending the signal to the other domain or CPU is repeated\n+   with timeout specified by\n+   :kconfig:option:`CONFIG_IPC_SERVICE_ICMSG_BOND_NOTIFY_REPEAT_TO_MS` option.\n-is read from ``rx-region``. If it is correct, the bonding process is finished\n-and the backend informs the application by calling\n-:c:member:`ipc_service_cb.bound` callback.\n+   is read from ``rx-region``. If it is correct, the bonding process is finished\n+   and the backend informs the application by calling\n+   :c:member:`ipc_service_cb.bound` callback."
},{
  "instruction": "doc: update references to video capture sample",
  "input": "  :zephyr-app: samples/subsys/video/capture\n  :zephyr-app: samples/subsys/video/capture\n  :zephyr-app: samples/subsys/video/capture",
  "result": "-   :zephyr-app: samples/subsys/video/capture\n+   :zephyr-app: samples/drivers/video/capture\n-   :zephyr-app: samples/subsys/video/capture\n+   :zephyr-app: samples/drivers/video/capture\n-   :zephyr-app: samples/subsys/video/capture\n+   :zephyr-app: samples/drivers/video/capture"
},{
  "instruction": "arch: arm: do not enable PLATFORM_SPECIFIC_INIT if SOC_RESET_HOOK=y",
  "input": "\tdefault y if SOC_RESET_HOOK",
  "result": "-\tdefault y if SOC_RESET_HOOK"
},{
  "instruction": "manifest: update to sha with fix to PLATFORM_SPECIFIC_INIT",
  "input": "     revision: f91541b8a4c39395a4ab9445fee69eeeaa050d6c",
  "result": "-      revision: f91541b8a4c39395a4ab9445fee69eeeaa050d6c\n+      revision: 77815705c465627b8436cbac51f0bf0594bbeba2"
},{
  "instruction": "soc: mcxa156: use soc hooks",
  "input": "\tselect PLATFORM_SPECIFIC_INIT\n#ifdef CONFIG_PLATFORM_SPECIFIC_INIT\nvoid z_arm_platform_init(void)",
  "result": "-\tselect PLATFORM_SPECIFIC_INIT\n+\tselect SOC_RESET_HOOK\n-#ifdef CONFIG_PLATFORM_SPECIFIC_INIT\n-\n-void z_arm_platform_init(void)\n+#ifdef CONFIG_SOC_RESET_HOOK\n+void soc_reset_hook(void)\n-"
},{
  "instruction": "tests: gen_isr_table: remove misnamed platform",
  "input": "     - stmf103_mini",
  "result": "-      - stmf103_mini\n+      - stm32f103_mini"
},{
  "instruction": "doc: Document deprecated stm32 MCO kconfig options for MCO",
  "input": "",
  "result": "+  * STM32: Deprecated MCO configuration via Kconfig in favour of setting it through devicetree.\n+    See ``samples/boards/stm32/mco`` sample."
},{
  "instruction": "boards: Add MCO support for the stm32c0xx family",
  "input": "",
  "result": "+\tmcos {\n+\t\tmco1: mco1 {\n+\t\t\tcompatible = \"st,stm32-clock-mco\";\n+\t\t\tstatus = \"disabled\";\n+\t\t};\n+\n+\t\tmco2: mco2 {\n+\t\t\tcompatible = \"st,stm32-clock-mco\";\n+\t\t\tstatus = \"disabled\";\n+\t\t};\n+\t};\n+\n+/** @brief RCC_CFGRx register offset */\n+#define CFGR1_REG               0x08\n+\n+/** CFGR1 devices */\n+#define MCO1_SEL(val)           STM32_MCO_CFGR(val, 0x7, 24, CFGR1_REG)\n+#define MCO1_PRE(val)           STM32_MCO_CFGR(val, 0x7, 28, CFGR1_REG)\n+#define MCO2_SEL(val)           STM32_MCO_CFGR(val, 0x7, 16, CFGR1_REG)\n+#define MCO2_PRE(val)           STM32_MCO_CFGR(val, 0x7, 20, CFGR1_REG)\n+"
},{
  "instruction": "include: dt-bindings: clock: fix stm32f7 missing HSE and PLLI2S_R source",
  "input": "#define STM32_SRC_PLL_P\t\t(STM32_SRC_HSI + 1)",
  "result": "+#define STM32_SRC_HSE           (STM32_SRC_HSI + 1)\n-#define STM32_SRC_PLL_P\t\t(STM32_SRC_HSI + 1)\n+#define STM32_SRC_PLL_P\t\t(STM32_SRC_HSE + 1)\n+#define STM32_SRC_PLLI2S_R      (STM32_SRC_PCLK + 1)\n+"
},{
  "instruction": "drivers: clock_control: Expose enabled_clock for clock driver library",
  "input": "__unused\nstatic int enabled_clock(uint32_t src_clk)\nstatic int enabled_clock(uint32_t src_clk)\nstatic int enabled_clock(uint32_t src_clk)\nstatic int enabled_clock(uint32_t src_clk)\n__unused\nstatic int enabled_clock(uint32_t src_clk)",
  "result": "-__unused\n-static int enabled_clock(uint32_t src_clk)\n+int enabled_clock(uint32_t src_clk)\n+int enabled_clock(uint32_t src_clk);\n-static int enabled_clock(uint32_t src_clk)\n+int enabled_clock(uint32_t src_clk)\n-static int enabled_clock(uint32_t src_clk)\n+int enabled_clock(uint32_t src_clk)\n-static int enabled_clock(uint32_t src_clk)\n+int enabled_clock(uint32_t src_clk)\n-__unused\n-static int enabled_clock(uint32_t src_clk)\n+int enabled_clock(uint32_t src_clk)"
},{
  "instruction": "spi: spi_mcux_lpspi: Removed spin lock from iodev_start",
  "input": "\tk_spinlock_key_t key = spi_spin_lock(dev);\n\tspi_spin_unlock(dev, key);",
  "result": "-\tk_spinlock_key_t key = spi_spin_lock(dev);\n-\n-\tspi_spin_unlock(dev, key);"
},{
  "instruction": "drivers: i2c: esp32: Fix DT node instance.",
  "input": "\tCOND_CODE_1(DT_INST_NODE_HAS_PROP(inst, scl_timeout_us),\t\\\n\t\t    (DT_INST_PROP(inst, scl_timeout_us)), (0))\n\t\t.irq_source = DT_INST_IRQ_BY_IDX(idx, 0, irq),\t\t\t\t   \\\n\t\t.irq_priority = DT_INST_IRQ_BY_IDX(idx, 0, priority),\t\t   \\\n\t\t.irq_flags = DT_INST_IRQ_BY_IDX(idx, 0, flags),\t\t\t\t   \\",
  "result": "-\tCOND_CODE_1(DT_INST_NODE_HAS_PROP(inst, scl_timeout_us),\t\\\n-\t\t    (DT_INST_PROP(inst, scl_timeout_us)), (0))\n+\tCOND_CODE_1(DT_NODE_HAS_PROP(I2C(inst), scl_timeout_us),\t\\\n+\t\t    (DT_PROP(I2C(inst), scl_timeout_us)), (0))\n-\t\t.irq_source = DT_INST_IRQ_BY_IDX(idx, 0, irq),\t\t\t\t   \\\n-\t\t.irq_priority = DT_INST_IRQ_BY_IDX(idx, 0, priority),\t\t   \\\n-\t\t.irq_flags = DT_INST_IRQ_BY_IDX(idx, 0, flags),\t\t\t\t   \\\n+\t\t.irq_source = DT_IRQ_BY_IDX(I2C(idx), 0, irq),\t\t\t\t   \\\n+\t\t.irq_priority = DT_IRQ_BY_IDX(I2C(idx), 0, priority),\t\t   \\\n+\t\t.irq_flags = DT_IRQ_BY_IDX(I2C(idx), 0, flags),\t\t\t\t   \\"
},{
  "instruction": "drivers: ethernet: Modify RX thread creation and update KConfig",
  "input": "\tint \"RX thread priority\"\n\t  RX thread priority\n\t\t\t\tK_PRIO_COOP(CONFIG_ETH_STM32_HAL_RX_THREAD_PRIO),",
  "result": "-\tint \"RX thread priority\"\n+\tint \"STM32 Ethernet RX Thread Priority\"\n-\t  RX thread priority\n+\t  This option allows to configure the priority of the RX thread that\n+\t  handles incoming Ethernet packets.\n+\t  Switching between preemptive and cooperative scheduling can be done by\n+\t  NET_TC_THREAD_PREEMPTIVE.\n+\t  Preemptive scheduling can lead to more responsive handling of network traffic,\n+\t  especially under high load.\n-\t\t\t\tK_PRIO_COOP(CONFIG_ETH_STM32_HAL_RX_THREAD_PRIO),\n+\t\t\t\tIS_ENABLED(CONFIG_NET_TC_THREAD_PREEMPTIVE)\n+\t\t\t\t\t? K_PRIO_PREEMPT(CONFIG_ETH_STM32_HAL_RX_THREAD_PRIO)\n+\t\t\t\t\t: K_PRIO_COOP(CONFIG_ETH_STM32_HAL_RX_THREAD_PRIO),"
},{
  "instruction": "sysbuild: fix extra kconfig targets when using sysbuild",
  "input": "     ${EXTRA_KCONFIG_TARGETS}\n ExternalProject_Get_Property(${ZCMAKE_APPLICATION} SOURCE_DIR BINARY_DIR CMAKE_ARGS)",
  "result": "-      ${EXTRA_KCONFIG_TARGETS}\n+      $CACHE{EXTRA_KCONFIG_TARGETS}\n+\n+  set(list_separator \",\")\n+  set(image_extra_kconfig_targets \"-DEXTRA_KCONFIG_TARGETS=$CACHE{EXTRA_KCONFIG_TARGETS}\")\n+  string(REPLACE \";\" \"${list_separator}\" image_extra_kconfig_targets \"${image_extra_kconfig_targets}\")\n+  foreach(target $CACHE{EXTRA_KCONFIG_TARGETS})\n+    list(APPEND image_extra_kconfig_targets\n+         -DEXTRA_KCONFIG_TARGET_COMMAND_FOR_${target}=$CACHE{EXTRA_KCONFIG_TARGET_COMMAND_FOR_${target}}\n+    )\n+  endforeach()\n+\n+    LIST_SEPARATOR \"${list_separator}\"\n+               ${image_extra_kconfig_targets}\n-  ExternalProject_Get_Property(${ZCMAKE_APPLICATION} SOURCE_DIR BINARY_DIR CMAKE_ARGS)\n+  ExternalProject_Get_Property(${ZCMAKE_APPLICATION} SOURCE_DIR BINARY_DIR CMAKE_ARGS LIST_SEPARATOR)\n+  string(REPLACE \"${LIST_SEPARATOR}\" \"\\\\;\" CMAKE_ARGS \"${CMAKE_ARGS}\")\n+foreach(extra_target ${EXTRA_KCONFIG_TARGETS})\n+  set(EXTRA_KCONFIG_TARGET_COMMAND_FOR_sysbuild_${extra_target}\n+      \"${EXTRA_KCONFIG_TARGET_COMMAND_FOR_${extra_target}}\"\n+  )\n+endforeach()"
},{
  "instruction": "tests: drivers: dac: dac_api: src: update dac_api driver test",
  "input": "",
  "result": "+\tdefined(CONFIG_BOARD_STM32U083C_DK) || \\\n+\tdefined(CONFIG_BOARD_NUCLEO_U083RC) || \\\n+    min_ram: 16"
},{
  "instruction": "dts: arm: st: u0: add dac node in dtsi file",
  "input": "",
  "result": "+\t\tdac1: dac@40007400 {\n+\t\t\tcompatible = \"st,stm32-dac\";\n+\t\t\treg = <0x40007400 0x400>;\n+\t\t\tclocks = <&rcc STM32_CLOCK_BUS_APB1 0x20000000>;\n+\t\t\tstatus = \"disabled\";\n+\t\t\t#io-channel-cells = <1>;\n+\t\t};\n+"
},{
  "instruction": "drivers: clocks: remove check for sysclock in h7 clocks",
  "input": "#if SYSCLK_FREQ != CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC\n#error \"SYS clock frequency for M7 core doesn't match CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC\"\n#endif",
  "result": "-#if SYSCLK_FREQ != CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC\n-#error \"SYS clock frequency for M7 core doesn't match CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC\"\n-#endif\n-"
},{
  "instruction": "drivers: use fracn in clock stm32h7 driver",
  "input": "\t/* FRACN disable DIVP,DIVQ,DIVR enable*/",
  "result": "-\t/* FRACN disable DIVP,DIVQ,DIVR enable*/\n+\tif (IS_ENABLED(STM32_PLL_FRACN_ENABLED)) {\n+\t\tLL_RCC_PLL1_SetFRACN(STM32_PLL_FRACN_VALUE);\n+\t\tLL_RCC_PLL1FRACN_Enable();\n+\t}\n+\tif (IS_ENABLED(STM32_PLL2_FRACN_ENABLED)) {\n+\t\tLL_RCC_PLL2_SetFRACN(STM32_PLL2_FRACN_VALUE);\n+\t\tLL_RCC_PLL2FRACN_Enable();\n+\t}\n+\tif (IS_ENABLED(STM32_PLL3_FRACN_ENABLED)) {\n+\t\tLL_RCC_PLL3_SetFRACN(STM32_PLL3_FRACN_VALUE);\n+\t\tLL_RCC_PLL3FRACN_Enable();\n+\t}"
},{
  "instruction": "dts: add fracn to STM32H7 PLL clocks",
  "input": "",
  "result": "+\n+  fracn:\n+    type: int\n+    description: |\n+        PLLx FRACN value\n+        Valid range: 0 - 8191"
},{
  "instruction": "drivers: sdhc: esp32: remove unused code",
  "input": "\tconst sdmmc_dev_t *sdio_hw = cfg->sdio_hw;\n\tuint32_t timeout_cfg;\n\tint ret_esp;",
  "result": "-\tconst sdmmc_dev_t *sdio_hw = cfg->sdio_hw;\n-\tuint32_t timeout_cfg;\n-\tint ret_esp;\n+\tuint32_t timeout_cfg = 0;\n+\tint ret_esp = 0;"
},{
  "instruction": "boards: nucleo_h7a3zi_q: do not force USB_DC_HAS_HS_SUPPORT",
  "input": "# STM32H7A3ZI-Q Nucleo board configuration\n# Copyright (c) 2021 Electrolance Solutions\n# SPDX-License-Identifier: Apache-2.0\nif BOARD_NUCLEO_H7A3ZI_Q\nconfig USB_DC_HAS_HS_SUPPORT\n\tdefault y\n\tdepends on USB_DC_STM32\nendif # BOARD_NUCLEO_H7A3ZI_Q",
  "result": "-# STM32H7A3ZI-Q Nucleo board configuration\n-\n-# Copyright (c) 2021 Electrolance Solutions\n-# SPDX-License-Identifier: Apache-2.0\n-\n-if BOARD_NUCLEO_H7A3ZI_Q\n-\n-config USB_DC_HAS_HS_SUPPORT\n-\tdefault y\n-\tdepends on USB_DC_STM32\n-\n-endif # BOARD_NUCLEO_H7A3ZI_Q"
},{
  "instruction": "bluetooth: host: improve log for unhandled vs events",
  "input": "\t\tLOG_WRN(\"Unhandled vendor-specific event: %s\", bt_hex(buf->data, buf->len));",
  "result": "-\t\tLOG_WRN(\"Unhandled vendor-specific event: %s\", bt_hex(buf->data, buf->len));\n+\t\tLOG_WRN(\"Unhandled vendor-specific event 0x%02x len %u: %s\", event, buf->len,\n+\t\t\tbt_hex(buf->data, buf->len));"
},{
  "instruction": "soc: st: stm32wb0: support SoCs without SMPS output current limit",
  "input": "\t\t * SMPS should remain in PRECHARGE mode, but\n\t\t * we still have to configure the current limit.",
  "result": "+#if defined(PWR_CR5_SMPS_PRECH_CUR_SEL)\n+#endif /* PWR_CR5_SMPS_PRECH_CUR_SEL */\n+#if defined(PWR_CR5_SMPS_PRECH_CUR_SEL)\n-\t\t * SMPS should remain in PRECHARGE mode, but\n-\t\t * we still have to configure the current limit.\n+\t\t * SMPS should remain in PRECHARGE mode.\n+\t\t * We still have to configure the output current\n+\t\t * limit specified in Device Tree, though this\n+\t\t * can only be done if this SoC supports it.\n+#endif /* PWR_CR5_SMPS_PRECH_CUR_SEL */"
},{
  "instruction": "dts: bindings: power: add note on SMPS current limit for STM32WB0",
  "input": "         - Supplied current limitation can be programmed\n     The default value corresponds to the hardware reset\n     configuration of 20 mA output current limit.",
  "result": "-          - Supplied current limitation can be programmed\n+          - Current supplied to LDOs can be limited\n+            (feature only supported on STM32WB05 / STM32WB09)\n-      The default value corresponds to the hardware reset\n-      configuration of 20 mA output current limit.\n+      The default value of 20 mA corresponds to the maximal\n+      output current allowed for the SMPS, and is also equal\n+      to the hardware reset configuration.\n+\n+      On STM32WB06 and STM32WB07, this property is ignored as\n+      the output current limitation feature is not available."
},{
  "instruction": "soc: espressif: Default MCUboot mode for ESP32 family",
  "input": "\tdefault MCUBOOT_MODE_OVERWRITE_ONLY if SOC_SERIES_ESP32C3 || SOC_SERIES_ESP32C6 || SOC_ESP32_PROCPU || SOC_SERIES_ESP32S2 || SOC_ESP32S3_PROCPU",
  "result": "-\tdefault MCUBOOT_MODE_OVERWRITE_ONLY if SOC_SERIES_ESP32C3 || SOC_SERIES_ESP32C6 || SOC_ESP32_PROCPU || SOC_SERIES_ESP32S2 || SOC_ESP32S3_PROCPU\n+\tdefault MCUBOOT_MODE_OVERWRITE_ONLY if SOC_FAMILY_ESPRESSIF_ESP32"
},{
  "instruction": "picolibc: Update to version 1.8.7",
  "input": "     revision: 764ef4e401a8f4c6a86ab723533841f072885a5b",
  "result": "-      revision: 764ef4e401a8f4c6a86ab723533841f072885a5b\n+      revision: 06bde1fd7531b1f788f6e42b6f7b358c0fe4f814"
},{
  "instruction": "tests, samples: Define _POSIX_C_SOURCE where needed",
  "input": "#if defined(CONFIG_NATIVE_LIBC)\n#endif",
  "result": "+#undef _POSIX_C_SOURCE\n+#define _POSIX_C_SOURCE 200809L\n-#if defined(CONFIG_NATIVE_LIBC)\n-#endif\n+#undef _POSIX_C_SOURCE\n+#define _POSIX_C_SOURCE 200809L\n+\n+#undef _POSIX_C_SOURCE\n+#define _POSIX_C_SOURCE 200809L\n+"
},{
  "instruction": "tests/c_lib: Don't test undefined behavior of asctime and asctime_r",
  "input": "\t\tzassert_is_null(asctime_r(NULL, buf));\n\t\tzassert_is_null(asctime(NULL));\n\t\tzassert_is_null(asctime_r(&tp, NULL));",
  "result": "-\t\tzassert_is_null(asctime_r(NULL, buf));\n-\t\tzassert_is_null(asctime(NULL));\n-\n-\t\tzassert_is_null(asctime_r(&tp, NULL));\n-"
},{
  "instruction": "posix: sysconf.c uses POSIX values",
  "input": "",
  "result": "+#undef _POSIX_C_SOURCE\n+#define _POSIX_C_SOURCE 200809L"
},{
  "instruction": "posix: options/shm.c needs _POSIX_C_SOURCE",
  "input": "",
  "result": "+#undef _POSIX_C_SOURCE\n+#define _POSIX_C_SOURCE 200809L\n+"
},{
  "instruction": "posix: Need sys/types.h to get suseconds_t defined",
  "input": "",
  "result": "+#include <sys/types.h>"
},{
  "instruction": "libc/picolibc: Don't replace picolibc time _r functions",
  "input": "",
  "result": "+\tselect TC_PROVIDES_POSIX_C_LANG_SUPPORT_R"
},{
  "instruction": "lib/posix: Only enable Zephyr _r APIs when toolchain doesn't",
  "input": "\tselect COMMON_LIBC_ASCTIME_R\n\tselect COMMON_LIBC_CTIME_R\n\tselect COMMON_LIBC_GMTIME_R\n\tselect COMMON_LIBC_LOCALTIME_R_UTC",
  "result": "-\tselect COMMON_LIBC_ASCTIME_R\n-\tselect COMMON_LIBC_CTIME_R\n-\tselect COMMON_LIBC_GMTIME_R\n-\tselect COMMON_LIBC_LOCALTIME_R_UTC\n+\tselect COMMON_LIBC_ASCTIME_R if ! TC_PROVIDES_POSIX_C_LANG_SUPPORT_R\n+\tselect COMMON_LIBC_CTIME_R if ! TC_PROVIDES_POSIX_C_LANG_SUPPORT_R\n+\tselect COMMON_LIBC_GMTIME_R if ! TC_PROVIDES_POSIX_C_LANG_SUPPORT_R\n+\tselect COMMON_LIBC_LOCALTIME_R_UTC if ! TC_PROVIDES_POSIX_C_LANG_SUPPORT_R"
},{
  "instruction": "libc/common: Remove redundant Kconfig POSIX_THREAD_SAFE_FUNCTIONS uses",
  "input": "\tdefault y if POSIX_THREAD_SAFE_FUNCTIONS\n\tdefault y if POSIX_THREAD_SAFE_FUNCTIONS",
  "result": "-\tdefault y if POSIX_THREAD_SAFE_FUNCTIONS\n-\tdefault y if POSIX_THREAD_SAFE_FUNCTIONS"
},{
  "instruction": "posix: Define _POSIX_C_SOURCE to gain access to POSIX functions",
  "input": "",
  "result": "+#undef _POSIX_C_SOURCE\n+#define _POSIX_C_SOURCE 200809L\n+#undef _POSIX_C_SOURCE\n+#define _POSIX_C_SOURCE 200809L"
},{
  "instruction": "posix: Don't require struct itimerspec in posix/time.h",
  "input": "",
  "result": "+struct itimerspec;"
},{
  "instruction": "posix: Avoid redefining TZNAME_MAX",
  "input": "",
  "result": "+#ifndef TZNAME_MAX\n+#endif"
},{
  "instruction": "posix: Avoid stepping on picolibc clockid_t and timer_t",
  "input": "#ifndef __clockid_t_defined\n#ifndef __timer_t_defined",
  "result": "-#ifndef __clockid_t_defined\n+#if !defined(__clockid_t_defined) && !defined(_CLOCKID_T_DECLARED)\n-#ifndef __timer_t_defined\n+#if !defined(__timer_t_defined) && !defined(_TIMER_T_DECLARED)"
},{
  "instruction": "subsys/shell: cmd_date_set uses gmtime_r, a POSIX function",
  "input": "",
  "result": "+#undef _POSIX_C_SOURCE\n+#define _POSIX_C_SOURCE 200809L"
},{
  "instruction": "subsys/llext: Allow .exported_sym to be between other data sections",
  "input": "",
  "result": "+\t\t\t/*\n+\t\t\t * The export symbol table may be surrounded by\n+\t\t\t * other data sections. Ignore overlaps in that\n+\t\t\t * case.\n+\t\t\t */\n+\t\t\tif ((i == LLEXT_MEM_DATA || i == LLEXT_MEM_RODATA) &&\n+\t\t\t    j == LLEXT_MEM_EXPORT) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+"
},{
  "instruction": "net: dns: Ignore GCC warnings in mdns_responder.c",
  "input": "",
  "result": "+/*\n+ * GCC complains about struct sockaddr accesses due to the various\n+ * address-family-specific variants being of differing sizes. Let's not\n+ * mess with code (which looks correct), just silence the compiler.\n+ */\n+#ifdef __GNUC__\n+#pragma GCC diagnostic ignored \"-Wpragmas\"\n+#pragma GCC diagnostic ignored \"-Wunknown-warning-option\"\n+#pragma GCC diagnostic ignored \"-Warray-bounds\"\n+#pragma GCC diagnostic ignored \"-Wstringop-overread\"\n+#endif\n+"
},{
  "instruction": "libc/common: Define _POSIX_C_SOURCE to gain access to POSIX functions",
  "input": "",
  "result": "+#undef _POSIX_C_SOURCE\n+#define _POSIX_C_SOURCE 200809L\n+#undef _POSIX_C_SOURCE\n+#define _POSIX_C_SOURCE 200809L"
},{
  "instruction": "video: esp32_dvp: change default log level",
  "input": "LOG_MODULE_REGISTER(video_esp32_lcd_cam, LOG_LEVEL_INF);",
  "result": "-LOG_MODULE_REGISTER(video_esp32_lcd_cam, LOG_LEVEL_INF);\n+LOG_MODULE_REGISTER(video_esp32_lcd_cam, CONFIG_VIDEO_LOG_LEVEL);"
},{
  "instruction": "samples: drivers: video: complement renaming from subsys/ to drivers/",
  "input": "",
  "result": ""
},{
  "instruction": "tests: drivers: stepper: stepper_api: Fix UAF of poll signal",
  "input": "\tstruct k_poll_signal signal;\n\tk_poll_signal_init(&signal);\n\tstruct k_poll_event event;\n\tk_poll_event_init(&event, K_POLL_TYPE_SIGNAL, K_POLL_MODE_NOTIFY_ONLY, &signal);\n\t(void)stepper_set_target_position(fixture->dev, pos, &signal);\n\t(void)k_poll(&event, 1, K_SECONDS(2));\n\tk_poll_signal_check(&signal, &signaled, &result);",
  "result": "+\tstruct k_poll_signal signal;\n+\tstruct k_poll_event event;\n+\tk_poll_signal_init(&fixture.signal);\n+\tk_poll_event_init(&fixture.event, K_POLL_TYPE_SIGNAL, K_POLL_MODE_NOTIFY_ONLY,\n+\t\t\t  &fixture.signal);\n+\n+\tk_poll_signal_reset(&fixture->signal);\n-\tstruct k_poll_signal signal;\n-\n-\tk_poll_signal_init(&signal);\n-\tstruct k_poll_event event;\n-\tk_poll_event_init(&event, K_POLL_TYPE_SIGNAL, K_POLL_MODE_NOTIFY_ONLY, &signal);\n-\t(void)stepper_set_target_position(fixture->dev, pos, &signal);\n-\t(void)k_poll(&event, 1, K_SECONDS(2));\n+\t(void)stepper_set_target_position(fixture->dev, pos, &fixture->signal);\n+\t(void)k_poll(&fixture->event, 1, K_SECONDS(5));\n-\tk_poll_signal_check(&signal, &signaled, &result);\n+\tk_poll_signal_check(&fixture->signal, &signaled, &result);"
},{
  "instruction": "boards: silabs: slstk3401a: Fix unit and first address mismatch",
  "input": "\t\tstorage_partition: partition@fe800 {",
  "result": "-\t\tstorage_partition: partition@fe800 {\n+\t\tstorage_partition: partition@3e800 {"
},{
  "instruction": "tests/c_lib: Ensure TZ value is UTC for ctime/ctime_r tests",
  "input": "",
  "result": "+#ifdef CONFIG_NATIVE_LIBC\n+\tsetenv(\"TZ\", \"UTC\", 1);\n+#endif"
},{
  "instruction": "lib/libc/Kconfig: Fix libC depends with NATIVE_APPlICATION",
  "input": "\tdepends on !NATIVE_APPLICATION\n\tdepends on !NATIVE_APPLICATION\n\tdepends on !NATIVE_APPLICATION",
  "result": "+\tdepends on !NATIVE_APPLICATION\n+\tdepends on !NATIVE_APPLICATION\n-\tdepends on !NATIVE_APPLICATION\n-\tdepends on !NATIVE_APPLICATION\n-\tdepends on !NATIVE_APPLICATION"
},{
  "instruction": "samples: net: http_client: Fix busy-looping in case of errors",
  "input": "\tint ret;\n\t\t\texit(1);\n\texit(0);\n\treturn 0;",
  "result": "+\t\tclose(*sock);\n+\t\t*sock = -1;\n-\tint ret;\n+\tint ret = 0;\n-\t\t\texit(1);\n+\t\t\tret = 1;\n+\t\t\tbreak;\n+\t\t\t\tret = 0;\n+\t\t\tret = 0;\n-\texit(0);\n-\treturn 0;\n+\texit(ret);\n+\treturn ret;"
},{
  "instruction": "drivers: adc: stm32: don't fail init if pinctrl is not provided",
  "input": "\t/* Configure dt provided device signals when available */\n\tif (err < 0) {",
  "result": "-\t/* Configure dt provided device signals when available */\n+\t/* Configure ADC inputs as specified in Device Tree, if any */\n-\tif (err < 0) {\n+\tif ((err < 0) && (err != -ENOENT)) {\n+\t\t/*\n+\t\t * If the ADC is used only with internal channels, then no pinctrl is\n+\t\t * provided in Device Tree, and pinctrl_apply_state returns -ENOENT,\n+\t\t * but this should not be treated as an error.\n+\t\t */"
},{
  "instruction": "tests: remove misnamed platforms from platform_exclude",
  "input": "     - qemu_x86_tiny/ia32/768\n     - qemu_x86_tiny/ia32/768\n     - qemu_x86_tiny/ia32/768\n     - m5stack_core2 # renode times out\n platform_exclude: m2gl025_miv m5stack_core2 hifive1 qemu_xtensa/dc233c/mmu\n     - fvp_baser_aemv8r_aarch32_smp",
  "result": "-      - qemu_x86_tiny/ia32/768\n-      - qemu_x86_tiny/ia32/768\n-      - qemu_x86_tiny/ia32/768\n-      - m5stack_core2 # renode times out\n-  platform_exclude: m2gl025_miv m5stack_core2 hifive1 qemu_xtensa/dc233c/mmu\n+  platform_exclude:\n+    - m2gl025_miv\n+    - hifive1\n+    - qemu_xtensa/dc233c/mmu\n-      - fvp_baser_aemv8r_aarch32_smp"
},{
  "instruction": "twister: abort on unrecognised platforms",
  "input": "               self.verify_platforms_existence(\n                   ts.platform_allow, f\"{ts_name} - platform_allow\")",
  "result": "-                self.verify_platforms_existence(\n-                    ts.platform_allow, f\"{ts_name} - platform_allow\")\n+                self.verify_platforms_existence(ts.platform_allow, f\"{ts_name} - platform_allow\")\n+                        # works only when we have all platforms parsed, -p limits parsing...\n+                        if not platform_filter:\n+                            self.verify_platforms_existence(ts.platform_exclude, f\"{ts_name} - platform_exclude\")"
},{
  "instruction": "doc: modules: Document conventions for auto-generated Kconfig options",
  "input": "",
  "result": "+Additionally, ``ZEPHYR_<MODULE_NAME>_MODULE`` and ``ZEPHYR_<MODULE_NAME>_MODULE_BLOBS``\n+(in case the module declares blobs) symbols are automatically generated for available\n+modules. These can be used e.g. to declare dependencies from other Kconfig symbols\n+which depend on the module or blobs from the module. To satisfy compliance checking\n+when building Zephyr without the module present, it's recommended for the module to\n+have default definitions for these symbols in its respective Kconfig file under\n+``modules/`` in the Zephyr main tree.\n+"
},{
  "instruction": "modules: Kconfig: Provide default definitions for modules with blobs",
  "input": "",
  "result": "+config ZEPHYR_HAL_ESPRESSIF_MODULE\n+\tbool\n+\n+config ZEPHYR_HAL_ESPRESSIF_MODULE_BLOBS\n+\tbool\n+\n+config ZEPHYR_HAL_SILABS_MODULE\n+\tbool\n+\n+config ZEPHYR_HAL_SILABS_MODULE_BLOBS\n+\tbool\n+\n+config ZEPHYR_HAL_STM32_MODULE\n+\tbool\n+\n+config ZEPHYR_HAL_STM32_MODULE_BLOBS\n+\tbool\n+\n+config ZEPHYR_HAL_INFINEON_MODULE_BLOBS\n+\tbool\n+"
},{
  "instruction": "doc: misc Sphinx/ReST lint fixes",
  "input": "ACRN hypervisor supports a hybrid scenario where Zephyr runs in a so-\ncalled \"pre-launched\" mode. This means Zephyr will access the ACRN\n  oscillator to JP1 by desoldering the zero-ohm resistors from positions R11 / R23 and re-\n  soldering them to positions R12 / R24.\n.. _Designware ARC IoT Development Kit website: <https://www.synopsys.com/dw/ipdir.php?ds=arc_iot_development_kit>`_\n default internal 32-kHz REFOCLK. Therefore, the presence of the crystal allows the full range of low-\n power modes to be used.",
  "result": "-ACRN hypervisor supports a hybrid scenario where Zephyr runs in a so-\n-called \"pre-launched\" mode. This means Zephyr will access the ACRN\n+ACRN hypervisor supports a hybrid scenario where Zephyr runs in a so-called\n+\"pre-launched\" mode. This means Zephyr will access the ACRN\n-   oscillator to JP1 by desoldering the zero-ohm resistors from positions R11 / R23 and re-\n-   soldering them to positions R12 / R24.\n+   oscillator to JP1 by desoldering the zero-ohm resistors from positions R11 / R23 and re-soldering\n+   them to positions R12 / R24.\n-.. _Designware ARC IoT Development Kit website: <https://www.synopsys.com/dw/ipdir.php?ds=arc_iot_development_kit>`_\n+.. _Designware ARC IoT Development Kit website: https://www.synopsys.com/dw/ipdir.php?ds=arc_iot_development_kit\n-  default internal 32-kHz REFOCLK. Therefore, the presence of the crystal allows the full range of low-\n-  power modes to be used.\n+  default internal 32-kHz REFOCLK. Therefore, the presence of the crystal allows the full range of low-power\n+  modes to be used."
},{
  "instruction": "Intel: ACE: move hpsram_mask to a data section",
  "input": "hpsram_mask:\n\t.rept MAX_MEMORY_SEGMENTS\n\t\t.word 0\n\t.endr\n\t.global hpsram_mask",
  "result": "+\t.section .cached.hpsram_mask, \"w\"\n+\t.align 64\n+hpsram_mask:\n+\t.rept MAX_MEMORY_SEGMENTS\n+\t\t.word 0\n+\t.endr\n+\n+\t.global hpsram_mask\n+\n-hpsram_mask:\n-\t.rept MAX_MEMORY_SEGMENTS\n-\t\t.word 0\n-\t.endr\n-\t.global hpsram_mask"
},{
  "instruction": "bluetooth: kconfig: Add channel sounding kconfigs",
  "input": "",
  "result": "+config BT_CHANNEL_SOUNDING\n+\tbool \"Channel Sounding support\"\n+\tselect EXPERIMENTAL\n+\tdepends on !BT_CTLR || BT_CTLR_CHANNEL_SOUNDING_SUPPORT\n+\thelp\n+\t  Enable support for Bluetooth 6.0 Channel Sounding feature.\n+\n+config BT_CTLR_CHANNEL_SOUNDING_SUPPORT\n+\tbool\n+\n+config BT_CTLR_CHANNEL_SOUNDING\n+\tbool \"Channel Sounding support\"\n+\tdepends on BT_CTLR_CHANNEL_SOUNDING_SUPPORT\n+\tselect BT_CTLR_SET_HOST_FEATURE\n+\tdefault y if BT_CHANNEL_SOUNDING\n+\thelp\n+\t  Enable support for Bluetooth 6.0 Channel Sounding in the\n+\t  Controller.\n+"
},{
  "instruction": "doc: doxygen: add kconfig_dep alias",
  "input": "",
  "result": "+                         \"kconfig_dep{1}=\\attention Available only when the following Kconfig option is enabled: \\kconfig{\\1}.\" \\\n+                         \"kconfig_dep{2}=\\attention Available only when the following Kconfig options are enabled: \\kconfig{\\1}, \\kconfig{\\2}.\" \\\n+                         \"kconfig_dep{3}=\\attention Available only when the following Kconfig options are enabled: \\kconfig{\\1}, \\kconfig{\\2}, \\kconfig{\\3}.\" \\"
},{
  "instruction": "xtensa: mpu: update hardware if manipulating current domain",
  "input": "",
  "result": "+\tstruct k_thread *cur_thread;\n+\t/*\n+\t * Need to update hardware MPU regions if we are removing\n+\t * partition from the domain of the current running thread.\n+\t */\n+\tcur_thread = _current_cpu->current;\n+\tif (cur_thread->mem_domain_info.mem_domain == domain) {\n+\t\txtensa_mpu_map_write(cur_thread);\n+\t}\n+\n+\tstruct k_thread *cur_thread;\n+\t/*\n+\t * Need to update hardware MPU regions if we are removing\n+\t * partition from the domain of the current running thread.\n+\t *\n+\t * Note that this function can be called with dummy thread\n+\t * at boot so we need to avoid writing MPU regions to\n+\t * hardware.\n+\t */\n+\tcur_thread = _current_cpu->current;\n+\tif (((cur_thread->base.thread_state & _THREAD_DUMMY) != _THREAD_DUMMY) &&\n+\t    (cur_thread->mem_domain_info.mem_domain == domain)) {\n+\t\txtensa_mpu_map_write(cur_thread);\n+\t}\n+"
},{
  "instruction": "xtensa: mpu: make sure write to MPU regions is atomic",
  "input": "",
  "result": "+/** Make sure write to the MPU region is atomic. */\n+static struct k_spinlock xtensa_mpu_lock;\n+\n+\tk_spinlock_key_t key;\n+\n+\tkey = k_spin_lock(&xtensa_mpu_lock);\n+\n+\tk_spin_unlock(&xtensa_mpu_lock, key);"
},{
  "instruction": "Bluetooth: Controller: Add missing branch prediction in lll_scan_aux",
  "input": "\tif (!pdu->len || !pri_com_hdr->ext_hdr_len) {\n\tif (!ext_hdr->adv_addr) {\n\tif (!trx_done || !crc_ok) {\n\tif ((pdu->type != PDU_ADV_TYPE_EXT_IND) || !pdu->len) {\n\tif (!trx_done) {\n\tif (pdu_rx->type != PDU_ADV_TYPE_AUX_CONNECT_RSP) {\n\tif (pdu_rx->len != offsetof(struct pdu_adv_com_ext_adv,\n\t\t\t\t    ext_hdr_adv_data) +\n\t\t\t   offsetof(struct pdu_adv_ext_hdr, data) + ADVA_SIZE +\n\t\t\t   TARGETA_SIZE) {\n\tif (pdu_rx->adv_ext_ind.adv_mode ||\n\t    !pdu_rx->adv_ext_ind.ext_hdr.adv_addr ||\n\t    !pdu_rx->adv_ext_ind.ext_hdr.tgt_addr) {",
  "result": "-\tif (!pdu->len || !pri_com_hdr->ext_hdr_len) {\n+\tif (unlikely(!pdu->len || !pri_com_hdr->ext_hdr_len)) {\n-\tif (!ext_hdr->adv_addr) {\n+\tif (unlikely(!ext_hdr->adv_addr)) {\n-\tif (!trx_done || !crc_ok) {\n+\tif (unlikely(!trx_done || !crc_ok)) {\n-\tif ((pdu->type != PDU_ADV_TYPE_EXT_IND) || !pdu->len) {\n+\tif (unlikely((pdu->type != PDU_ADV_TYPE_EXT_IND) || !pdu->len)) {\n-\tif (!trx_done) {\n+\tif (unlikely(!trx_done)) {\n+\n-\tif (pdu_rx->type != PDU_ADV_TYPE_AUX_CONNECT_RSP) {\n+\tif (unlikely(pdu_rx->type != PDU_ADV_TYPE_AUX_CONNECT_RSP)) {\n-\tif (pdu_rx->len != offsetof(struct pdu_adv_com_ext_adv,\n-\t\t\t\t    ext_hdr_adv_data) +\n-\t\t\t   offsetof(struct pdu_adv_ext_hdr, data) + ADVA_SIZE +\n-\t\t\t   TARGETA_SIZE) {\n+\tif (unlikely(pdu_rx->len != (offsetof(struct pdu_adv_com_ext_adv, ext_hdr_adv_data) +\n+\t\t\t\t     offsetof(struct pdu_adv_ext_hdr, data) + ADVA_SIZE +\n+\t\t\t\t     TARGETA_SIZE))) {\n-\tif (pdu_rx->adv_ext_ind.adv_mode ||\n-\t    !pdu_rx->adv_ext_ind.ext_hdr.adv_addr ||\n-\t    !pdu_rx->adv_ext_ind.ext_hdr.tgt_addr) {\n+\tif (unlikely(pdu_rx->adv_ext_ind.adv_mode || !pdu_rx->adv_ext_ind.ext_hdr.adv_addr ||\n+\t\t     !pdu_rx->adv_ext_ind.ext_hdr.tgt_addr)) {"
},{
  "instruction": "Bluetooth: Controller: Define a macro to validate aux offset value",
  "input": "\tif (unlikely((aux_offset_us + window_size_us) < (pdu_us + EVENT_MAFS_US))) {\n\tif (unlikely((aux_offset_us + window_size_us) < (pdu_us + EVENT_MAFS_US))) {",
  "result": "+#define AUX_OFFSET_IS_VALID(_offset_us, _win_size_us, _pdu_us) \\\n+\t\t(((_offset_us) + (_win_size_us)) >= ((_pdu_us) + (EVENT_MAFS_US)))\n+\n-\tif (unlikely((aux_offset_us + window_size_us) < (pdu_us + EVENT_MAFS_US))) {\n+\tif (unlikely(!AUX_OFFSET_IS_VALID(aux_offset_us, window_size_us, pdu_us))) {\n-\tif (unlikely((aux_offset_us + window_size_us) < (pdu_us + EVENT_MAFS_US))) {\n+\tif (unlikely(!AUX_OFFSET_IS_VALID(aux_offset_us, window_size_us, pdu_us))) {"
},{
  "instruction": "Bluetooth: Controller: Infinite loop assertion on node_rx release",
  "input": "",
  "result": "+\t\tuint8_t loop = PDU_RX_POOL_SIZE / PDU_RX_NODE_POOL_ELEMENT_SIZE;\n+\t\t\tLL_ASSERT(loop);\n+\t\t\tloop--;\n+"
},{
  "instruction": "samples: arch: fix toctree hierarchy",
  "input": "  :maxdepth: 1\n  **/*",
  "result": "-   :maxdepth: 1\n+   :maxdepth: 2\n-   **/*\n+   */*"
},{
  "instruction": "samples: arch: use zephyr:code-sample directive",
  "input": ".. _mpu_test:\nMemory Protection Unit (MPU) Sample\n###################################\n.. _smp_pi:\nSMP Pi\n###########\n.. _smp_pktqueue:\nSMP pktqueue\n############",
  "result": "-.. _mpu_test:\n+.. zephyr:code-sample:: mpu\n+   :name: Memory Protection Unit (MPU)\n-Memory Protection Unit (MPU) Sample\n-###################################\n+   Use memory protection to prevent common security issues.\n-.. _smp_pi:\n+.. zephyr:code-sample:: smp_pi\n+   :name: SMP Pi\n-SMP Pi\n-###########\n+   Calculate the first 240 digits of Pi on multiple execution units.\n-.. _smp_pktqueue:\n+.. zephyr:code-sample:: smp_pktqueue\n+   :name: SMP pktqueue\n-SMP pktqueue\n-############\n+   Use SMP to process multiple packet headers in parallel."
},{
  "instruction": "boards: doc: reference tfm_ipc sample using zephyr:code-sample: role",
  "input": "using :ref:`tfm_ipc` sample:\nusing :ref:`tfm_ipc` sample:\nusing :ref:`tfm_ipc` sample:",
  "result": "-using :ref:`tfm_ipc` sample:\n+using :zephyr:code-sample:`tfm_ipc` sample:\n-using :ref:`tfm_ipc` sample:\n+using :zephyr:code-sample:`tfm_ipc` sample:\n-using :ref:`tfm_ipc` sample:\n+using :zephyr:code-sample:`tfm_ipc` sample:"
},{
  "instruction": "doc: releases: fix kconfig role typo in mbedtls section",
  "input": " * ``CONFIG_MBEDTLS_ENTROPY_ENABLED`` is now :kconfig:option:``CONFIG_MBEDTLS_ENTROPY_C``,\n * ``CONFIG_MBEDTLS_ZEPHYR_ENTROPY`` is now :kconfig:option:``CONFIG_MBEDTLS_ENTROPY_POLL_ZEPHYR``.",
  "result": "-  * ``CONFIG_MBEDTLS_ENTROPY_ENABLED`` is now :kconfig:option:``CONFIG_MBEDTLS_ENTROPY_C``,\n-  * ``CONFIG_MBEDTLS_ZEPHYR_ENTROPY`` is now :kconfig:option:``CONFIG_MBEDTLS_ENTROPY_POLL_ZEPHYR``.\n+  * ``CONFIG_MBEDTLS_ENTROPY_ENABLED`` is now :kconfig:option:`CONFIG_MBEDTLS_ENTROPY_C`,\n+  * ``CONFIG_MBEDTLS_ZEPHYR_ENTROPY`` is now :kconfig:option:`CONFIG_MBEDTLS_ENTROPY_POLL_ZEPHYR`."
},{
  "instruction": "samples: net: http_server: Add information about overlays",
  "input": "",
  "result": "+There are configuration files for various setups in the\n+:zephyr_file:`samples/net/sockets/http_server` directory:\n+\n+.. list-table::\n+\n+    * - :zephyr_file:`prj.conf <samples/net/sockets/http_server/prj.conf>`\n+      - This is the standard default config.\n+\n+    * - :zephyr_file:`ieee802154-overlay.conf <samples/net/sockets/http_server/ieee802154-overlay.conf>`\n+      - This overlay config can be added for IEEE 802.15.4 support.\n+\n+    * - :zephyr_file:`overlay-netusb.conf <samples/net/sockets/http_server/overlay-netusb.conf>`\n+      - This overlay config can be added for connecting via network USB.\n+"
},{
  "instruction": "dts: bindings: lp5562: Add enable-gpios property",
  "input": "",
  "result": "+  * lp5562: added ``enable-gpios`` property to describe the EN/VCC GPIO of the lp5562.\n+\n+\n+  enable-gpios:\n+    type: phandle-array\n+    description: |\n+      GPIO to enable LP5562 (both Charge-pump and Digital Communications interface).\n+      If not provided, user must ensure enable pin is already asserted externally (e.g:\n+      pull-up resistor)."
},{
  "instruction": "dts: stm32h7: Add missing ITCM memory to stm32h743.dtsi.",
  "input": "",
  "result": "+\titcm: memory@0 {\n+\t\tcompatible = \"zephyr,memory-region\", \"arm,itcm\";\n+\t\treg = <0x00000000 DT_SIZE_K(64)>;\n+\t\tzephyr,memory-region = \"ITCM\";\n+\t};\n+"
},{
  "instruction": "samples: boards: ti: use zephyr:code-sample directive",
  "input": ".. _ti-cc13x2_cc26x2-system-off-sample:\ncc13x2_cc26x2 System Off demo\n#############################",
  "result": "-.. _ti-cc13x2_cc26x2-system-off-sample:\n+.. zephyr:code-sample:: ti_cc13x2_cc26x2_system_off\n+   :name: CC13x2/CC26x2 System Off\n-cc13x2_cc26x2 System Off demo\n-#############################\n+   Exercise the various sleep modes on TI CC13x2/CC26x2 platforms."
},{
  "instruction": "samples: boards: enjoydigital: group Enjoydigital board samples",
  "input": "   - samples/boards/litex/",
  "result": "-    - samples/boards/litex/\n+    - samples/boards/enjoydigital/litex/\n+    ('samples/boards/litex/i2s/README', 'samples/boards/enjoydigital/litex/i2s/README'),"
},{
  "instruction": "samples: boards: nuvoton: group Nuvoton board samples",
  "input": "",
  "result": ""
},{
  "instruction": "samples: boards: raspberrypi: group Raspberry Pi board samples",
  "input": "",
  "result": ""
},{
  "instruction": "samples: boards: google: group Google board samples",
  "input": "   - samples/boards/google_*/\n.. _google_twinkie_v2_pda:\nTwinkie Power Delivery\n######################\n  :zephyr-app: samples/boards/google_twinkie_v2_pda",
  "result": "-    - samples/boards/google_*/\n+    - samples/boards/google/\n+    ('samples/boards/google_twinkie_v2_pda/README', 'samples/boards/google/twinkie_v2/pda/README'),\n-.. _google_twinkie_v2_pda:\n+.. zephyr:code-sample:: twinkie_v2_pda\n+   :name: Power Delivery Analyzer\n+   :relevant-api: adc_interface\n-Twinkie Power Delivery\n-######################\n+   Implement a basic Power Delivery Analyzer to determine if a USB device is currently charging.\n-   :zephyr-app: samples/boards/google_twinkie_v2_pda\n+   :zephyr-app: samples/boards/google/twinkie_v2/pda"
},{
  "instruction": "samples: boards: phytec: group Phytec board samples",
  "input": ".. _mesh_badge:\nMesh Badge\n##########",
  "result": "-.. _mesh_badge:\n+.. zephyr:code-sample:: mesh_badge\n+   :name: Bluetooth Mesh badge\n+   :relevant-api: monochrome_character_framebuffer bt_mesh bt_gatt bluetooth\n-Mesh Badge\n-##########\n+   Implement a smart badge using the reel board and Bluetooth Mesh."
},{
  "instruction": "samples: boards: intel: group Intel board samples",
  "input": "   - samples/boards/intel_adsp/\n.. _intel_adsp_code_relocation:\nIntel ADSP CAVS Code relocation\n###############################\n  :zephyr-app: samples/hello_world",
  "result": "-    - samples/boards/intel_adsp/\n+    - samples/boards/intel/adsp/\n+    ('samples/boards/intel_adsp/code_relocation/README', 'samples/boards/intel/adsp/code_relocation/README'),\n-.. _intel_adsp_code_relocation:\n+.. zephyr:code-sample:: intel_adsp_code_relocation\n+   :name: Code relocation\n-Intel ADSP CAVS Code relocation\n-###############################\n+   Relocate code using custom linker script.\n-   :zephyr-app: samples/hello_world\n+   :zephyr-app: samples/boards/intel/adsp/code_relocation"
},{
  "instruction": "samples: boards: quicklogic: group quicklogic board samples",
  "input": "     :zephyr-app: samples/boards/qomu\n  :zephyr-app: samples/boards/qomu",
  "result": "-      :zephyr-app: samples/boards/qomu\n+      :zephyr-app: samples/boards/quicklogic/qomu\n+    ('samples/boards/qomu/README', 'samples/boards/quicklogic/qomu/README'),\n-   :zephyr-app: samples/boards/qomu\n+   :zephyr-app: samples/boards/quicklogic/qomu"
},{
  "instruction": "samples: boards: microchip: group Microchip board samples",
  "input": ".. mec15xxevb_assy6853-samples:",
  "result": "+    ('samples/boards/mec15xxevb_assy6853/power_management/README', 'samples/boards/microchip/mec15xxevb_assy6853/power_management/README'),\n-.. mec15xxevb_assy6853-samples:\n+.. _mec15xxevb_assy6853-samples:"
},{
  "instruction": "samples: boards: 96boards: use zephyr:code-sample directive",
  "input": ".. _ArgonKey_Microphone:\nArgonKey Board Microphone\n#########################\n.. _ArgonKey_Sensors:\nArgonKey Board Sensors\n######################",
  "result": "-.. _ArgonKey_Microphone:\n+.. zephyr:code-sample:: argonkey_microphone\n+   :name: Microphone\n+   :relevant-api: audio_interface\n-ArgonKey Board Microphone\n-#########################\n+   Acquire audio through the ArgonKey's on-board MP34DT05 microphone.\n-.. _ArgonKey_Sensors:\n+.. zephyr:code-sample:: argonkey_sensors\n+   :name: Sensors\n-ArgonKey Board Sensors\n-######################\n+   Read sensor data from the ArgonKey board's onboard sensors."
},{
  "instruction": "samples: boards: 96boards: group 96boards board samples",
  "input": "   :zephyr-app: samples/boards/96b_argonkey/microphone\n   :zephyr-app: samples/boards/96b_argonkey/sensors",
  "result": "+    ('samples/boards/96b_argonkey/microphone/README', 'samples/boards/96boards/argonkey/microphone/README'),\n+    ('samples/boards/96b_argonkey/sensors/README', 'samples/boards/96boards/argonkey/sensors/README'),\n-    :zephyr-app: samples/boards/96b_argonkey/microphone\n+    :zephyr-app: samples/boards/96boards/argonkey/microphone\n-    :zephyr-app: samples/boards/96b_argonkey/sensors\n+    :zephyr-app: samples/boards/96boards/argonkey/sensors"
},{
  "instruction": "samples: boards: bbc: group BBC board samples",
  "input": "  :zephyr-app: samples/boards/bbc_microbit/display\n  :zephyr-app: samples/boards/bbc_microbit/line_follower_robot\n  :zephyr-app: samples/boards/bbc_microbit/pong\n  :zephyr-app: samples/boards/bbc_microbit/sound\n  :zephyr-app: samples/boards/bbc_microbit/sound",
  "result": "-   :zephyr-app: samples/boards/bbc_microbit/display\n+   :zephyr-app: samples/boards/bbc/microbit/display\n-   :zephyr-app: samples/boards/bbc_microbit/line_follower_robot\n+   :zephyr-app: samples/boards/bbc/microbit/line_follower_robot\n-   :zephyr-app: samples/boards/bbc_microbit/pong\n+   :zephyr-app: samples/boards/bbc/microbit/pong\n-   :zephyr-app: samples/boards/bbc_microbit/sound\n+   :zephyr-app: samples/boards/bbc/microbit/sound\n-   :zephyr-app: samples/boards/bbc_microbit/sound\n+   :zephyr-app: samples/boards/bbc/microbit/sound"
},{
  "instruction": "samples: boards: nxp: group NXP board samples",
  "input": "   - samples/boards/nxp_s32/\n  :zephyr-app: samples/boards/mimxrt1060_evk/system_off\n  :zephyr-app: samples/boards/mimxrt595_evk/system_off\n  :zephyr-app: samples/boards/nxp_s32/netc\n  :zephyr-app: samples/boards/nxp_s32/netc",
  "result": "-    - samples/boards/nxp_s32/\n+    - samples/boards/nxp/s32/\n+    ('samples/boards/mimxrt1060_evk/system_off/README', 'samples/boards/nxp/mimxrt1060_evk/system_off/README'),\n+    ('samples/boards/mimxrt1170_evk_cm7/magic_addr/README', 'samples/boards/nxp/mimxrt1170_evk_cm7/magic_addr/README'),\n+    ('samples/boards/mimxrt595_evk/system_off/README', 'samples/boards/nxp/mimxrt595_evk/system_off/README'),\n+    ('samples/boards/nxp_s32/netc/README', 'samples/boards/nxp/s32/netc/README'),\n-   :zephyr-app: samples/boards/mimxrt1060_evk/system_off\n+   :zephyr-app: samples/boards/nxp/mimxrt1060_evk/system_off\n-   :zephyr-app: samples/boards/mimxrt595_evk/system_off\n+   :zephyr-app: samples/boards/nxp/mimxrt595_evk/system_off\n-   :zephyr-app: samples/boards/nxp_s32/netc\n+   :zephyr-app: samples/boards/nxp/s32/netc\n-   :zephyr-app: samples/boards/nxp_s32/netc\n+   :zephyr-app: samples/boards/nxp/s32/netc"
},{
  "instruction": "samples: boards: espressif: group Espressif board samples",
  "input": "   - samples/boards/esp32*/\n* :zephyr_file:`samples/boards/esp32/deep_sleep/`\n  :zephyr-app: samples/boards/esp32/deep_sleep\n  west build -b esp32_devkitc_wrover samples/boards/esp32/flash_encryption\n  west build -b esp32s3_devkitm samples/boards/esp32/flash_memory_mapped\n  :zephyr-app: samples/boards/esp32/light_sleep\n  west build -b esp32s3_devkitm/esp32s3/procpu samples/boards/esp32/spiram_test\n  :zephyr-app: samples/boards/esp32/deep_sleep\n  west build -p -b esp32s3_devkitm/esp32s3/procpu samples/boards/esp32/xt_wdt",
  "result": "-    - samples/boards/esp32*/\n+    - samples/boards/espressif/\n+    ('samples/boards/esp32/deep_sleep/README', 'samples/boards/espressif/deep_sleep/README'),\n+    ('samples/boards/esp32/flash_encryption/README', 'samples/boards/espressif/flash_encryption/README'),\n+    ('samples/boards/esp32/flash_memory_mapped/README', 'samples/boards/espressif/flash_memory_mapped/README'),\n+    ('samples/boards/esp32/light_sleep/README', 'samples/boards/espressif/light_sleep/README'),\n+    ('samples/boards/esp32/spiram_test/README', 'samples/boards/espressif/spiram_test/README'),\n+    ('samples/boards/esp32/wifi_apsta_mode/README', 'samples/boards/espressif/wifi_apsta_mode/README'),\n+    ('samples/boards/esp32/xt_wdt/README', 'samples/boards/espressif/xt_wdt/README'),\n-* :zephyr_file:`samples/boards/esp32/deep_sleep/`\n+* :zephyr_file:`samples/boards/espressif/deep_sleep/`\n-   :zephyr-app: samples/boards/esp32/deep_sleep\n+   :zephyr-app: samples/boards/espressif/deep_sleep\n-   west build -b esp32_devkitc_wrover samples/boards/esp32/flash_encryption\n+   west build -b esp32_devkitc_wrover samples/boards/espressif/flash_encryption\n-   west build -b esp32s3_devkitm samples/boards/esp32/flash_memory_mapped\n+   west build -b esp32s3_devkitm samples/boards/espressif/flash_memory_mapped\n-   :zephyr-app: samples/boards/esp32/light_sleep\n+   :zephyr-app: samples/boards/espressif/light_sleep\n-   west build -b esp32s3_devkitm/esp32s3/procpu samples/boards/esp32/spiram_test\n+   west build -b esp32s3_devkitm/esp32s3/procpu samples/boards/espressif/spiram_test\n-   :zephyr-app: samples/boards/esp32/deep_sleep\n+   :zephyr-app: samples/boards/espressif/deep_sleep\n-   west build -p -b esp32s3_devkitm/esp32s3/procpu samples/boards/esp32/xt_wdt\n+   west build -p -b esp32s3_devkitm/esp32s3/procpu samples/boards/espressif/xt_wdt"
},{
  "instruction": "west.yml: MCUboot synchronization from upstream",
  "input": "     revision: 52e2afc2f809c424b0f337f56059d1dfcc7e6d98",
  "result": "-      revision: 52e2afc2f809c424b0f337f56059d1dfcc7e6d98\n+      revision: e890df7ab975da181a9f3fb3abc470bf935625ab"
},{
  "instruction": "samples: bluetooth: direction_finding_connectionless_rx: Fix sync timeout",
  "input": "\tsync_create_param.timeout = sync_create_timeout_ms * 10 / 10; /* 10 attempts */",
  "result": "-\tsync_create_param.timeout = sync_create_timeout_ms * 10 / 10; /* 10 attempts */\n+\tsync_create_param.timeout = sync_create_timeout_ms / 10;"
},{
  "instruction": "hostap: Add rts threshold get api support",
  "input": "",
  "result": "+int supplicant_get_rts_threshold(const struct device *dev, unsigned int *rts_threshold)\n+{\n+\tconst struct wifi_mgmt_ops *const wifi_mgmt_api = get_wifi_mgmt_api(dev);\n+\n+\tif (!wifi_mgmt_api || !wifi_mgmt_api->get_rts_threshold) {\n+\t\twpa_printf(MSG_ERROR, \"Get RTS not supported\");\n+\t\treturn -ENOTSUP;\n+\t}\n+\n+\treturn wifi_mgmt_api->get_rts_threshold(dev, rts_threshold);\n+}\n+\n+/**\n+ * @brief Get Wi-Fi RTS threshold\n+ *\n+ * @param dev Wi-Fi interface handle to use\n+ * @param rts_threshold Pointer to the RTS threshold value.\n+ * @return 0 for OK; -1 for ERROR\n+ */\n+int supplicant_get_rts_threshold(const struct device *dev, unsigned int *rts_threshold);\n+\n+\t.get_rts_threshold = supplicant_get_rts_threshold,"
},{
  "instruction": "manifest: net-tools: Update net-setup to add multi interface config",
  "input": "     revision: a1fb781b67c33e9a6868b0915b627315c5cac668",
  "result": "-      revision: a1fb781b67c33e9a6868b0915b627315c5cac668\n+      revision: 93acc8bac4661e74e695eb1aea94c7c5262db2e2"
},{
  "instruction": "doc: releases: migration-guide-4.0: Add missing bridge GH links",
  "input": " After this change the bridge shell is used by ``net bridge`` command.\n will take network interface pointer as a first parameter.",
  "result": "-  After this change the bridge shell is used by ``net bridge`` command.\n+  After this change the bridge shell is used by ``net bridge`` command. (:github:`77235`)\n-  will take network interface pointer as a first parameter.\n+  will take network interface pointer as a first parameter. (:github:`77987`)"
},{
  "instruction": "net: bridge: Ignore promisc mode errors for native-sim",
  "input": "\t\tNET_DBG(\"iface %d promiscuous mode failed: %d\",\n\t\t\tnet_if_get_by_iface(iface), ret);\n\t\teth_bridge_iface_remove(br, iface);\n\t\treturn ret;",
  "result": "-\t\tNET_DBG(\"iface %d promiscuous mode failed: %d\",\n-\t\t\tnet_if_get_by_iface(iface), ret);\n-\t\teth_bridge_iface_remove(br, iface);\n-\t\treturn ret;\n+\t\t/* Ignore any errors when using native-sim driver,\n+\t\t * we do not need host promiscuous working when testing\n+\t\t * bridging using native-sim.\n+\t\t */\n+\t\tif (!IS_ENABLED(CONFIG_ETH_NATIVE_POSIX)) {\n+\t\t\tNET_DBG(\"iface %d promiscuous mode failed: %d\",\n+\t\t\t\tnet_if_get_by_iface(iface), ret);\n+\t\t\teth_bridge_iface_remove(br, iface);\n+\t\t\treturn ret;\n+\t\t}"
},{
  "instruction": "drivers: eth: native_sim: Fix error output when creating interface",
  "input": "\t\tLOG_ERR(\"Cannot create %s (%d)\", ctx->if_name, -errno);",
  "result": "-\t\tLOG_ERR(\"Cannot create %s (%d)\", ctx->if_name, -errno);\n+\t\tLOG_ERR(\"Cannot create %s (%d/%s)\", ctx->if_name, ctx->dev_fd,\n+\t\t\tstrerror(-ctx->dev_fd));"
},{
  "instruction": "boards: nxp: imx95_evk: remove redundant CONFIG_PINCTRL in defconfig",
  "input": "CONFIG_PINCTRL=y\nCONFIG_PINCTRL=y\nCONFIG_PINCTRL=y",
  "result": "-CONFIG_PINCTRL=y\n-CONFIG_PINCTRL=y\n-CONFIG_PINCTRL=y"
},{
  "instruction": "boards: nxp: imx95_evk: improve doc",
  "input": "The Zephyr imx95_evk_m7 board configuration supports the following hardware features:\nThe Zephyr imx95_evk_a55 board configuration supports the following hardware features:\n  :goals: run\n  :goals: run",
  "result": "-The Zephyr imx95_evk_m7 board configuration supports the following hardware features:\n+The Zephyr ``imx95_evk/mimx9596/m7`` board target supports the following hardware features:\n-The Zephyr imx95_evk_a55 board configuration supports the following hardware features:\n+The Zephyr ``imx95_evk/mimx9596/a55`` and ``imx95_evk/mimx9596/a55/smp`` board targets support\n+the following hardware features:\n-   :goals: run\n+   :goals: build\n-   :goals: run\n+   :goals: build"
},{
  "instruction": "boards: nxp: imx95_evk: remove empty cmake files",
  "input": "# SPDX-License-Identifier: Apache-2.0\n# SPDX-License-Identifier: Apache-2.0",
  "result": "-# SPDX-License-Identifier: Apache-2.0\n-# SPDX-License-Identifier: Apache-2.0"
},{
  "instruction": "scripts: twister: Process KeyboardInterrupt Hardening",
  "input": "               next_op = None\n               additionals = {}",
  "result": "+        next_op = None\n+        additionals = {}\n+\n-                next_op = None\n-                additionals = {}"
},{
  "instruction": "drivers: udc_dwc2: Send isochronous data on next SOF",
  "input": "\t\t\tdiepctl |= USB_DWC2_DEPCTL_SETODDFR;\n\t\t} else {",
  "result": "+\t\t/* Queue transfer on next SOF. TODO: allow stack to explicitly\n+\t\t * specify on which (micro-)frame the data should be sent.\n+\t\t */\n-\t\t\tdiepctl |= USB_DWC2_DEPCTL_SETODDFR;\n-\t\t} else {\n+\t\t} else {\n+\t\t\tdiepctl |= USB_DWC2_DEPCTL_SETODDFR;"
},{
  "instruction": "usb: device_next: uac2: Write feedback as soon as possible",
  "input": "",
  "result": "+\t} else if (is_feedback) {\n+\t\twrite_explicit_feedback(c_data, ep, cfg->as_terminals[as_idx]);"
},{
  "instruction": "mbedtls: add ability to use custom memory section for mbedtls heap",
  "input": "\tdepends on MBEDTLS_ENABLE_HEAP\n#if !defined(CONFIG_MBEDTLS_HEAP_SIZE)\n#error \"Please set heap size to be used. Set value to CONFIG_MBEDTLS_HEAP_SIZE \\\noption.\"\n#endif\nstatic unsigned char _mbedtls_heap[CONFIG_MBEDTLS_HEAP_SIZE];",
  "result": "+if MBEDTLS_ENABLE_HEAP\n+\n-\tdepends on MBEDTLS_ENABLE_HEAP\n+config MBEDTLS_HEAP_CUSTOM_SECTION\n+\tbool \"Use a custom section for the Mbed TLS heap\"\n+\thelp\n+\t  Place Mbed TLS heap in custom section, with tag \".mbedtls_heap\".\n+\t  This can be used by custom linker scripts to relocate the Mbed TLS\n+\t  heap to a custom location, such as another SRAM region or external memory.\n+\n+endif # MBEDTLS_ENABLE_HEAP\n+\n-#if !defined(CONFIG_MBEDTLS_HEAP_SIZE)\n-#error \"Please set heap size to be used. Set value to CONFIG_MBEDTLS_HEAP_SIZE \\\n-option.\"\n-#endif\n-\n-static unsigned char _mbedtls_heap[CONFIG_MBEDTLS_HEAP_SIZE];\n+#ifdef CONFIG_MBEDTLS_HEAP_CUSTOM_SECTION\n+#define HEAP_MEM_ATTRIBUTES Z_GENERIC_SECTION(.mbedtls_heap)\n+#else\n+#define HEAP_MEM_ATTRIBUTES\n+#endif /* CONFIG_MBEDTLS_HEAP_CUSTOM_SECTION */\n+static unsigned char _mbedtls_heap[CONFIG_MBEDTLS_HEAP_SIZE] HEAP_MEM_ATTRIBUTES;"
},{
  "instruction": "west.yaml: pickup the change in hal_nxp",
  "input": "     revision: 30bdef6d5a304abfa95cc19af4d3ba699aac456e",
  "result": "-      revision: 30bdef6d5a304abfa95cc19af4d3ba699aac456e\n+      revision: f91541b8a4c39395a4ab9445fee69eeeaa050d6c"
},{
  "instruction": "soc: infineon: cat1b: Enable flash memory caching",
  "input": "\t\tflash0: flash@60000000 {\n\t\t\treg = <0x60000000 DT_SIZE_K(512)>;\n\t\t\ttoc2_region: toc2_region@60000000 {\n\t\t\t\treg = <0x60000000 0x50>;\n\t\t\tbootstrap_region: bootstrap_region@60000050 {\n\t\t\t\treg = <0x60000050 DT_SIZE_K(12)>;\n\t\t\tapp_region: app_region@60003050 {\n\t\t\t\treg = <0x60003050 0x6CFB0>; /* 435kb */",
  "result": "-\t\tflash0: flash@60000000 {\n+\t\tflash0: flash@8000000 {\n-\t\t\treg = <0x60000000 DT_SIZE_K(512)>;\n+\t\t\treg = <0x08000000 DT_SIZE_K(512)>;\n-\t\t\ttoc2_region: toc2_region@60000000 {\n+\t\t\ttoc2_region: toc2_region@8000000 {\n-\t\t\t\treg = <0x60000000 0x50>;\n+\t\t\t\treg = <0x08000000 0x50>;\n-\t\t\tbootstrap_region: bootstrap_region@60000050 {\n+\t\t\tbootstrap_region: bootstrap_region@8000050 {\n-\t\t\t\treg = <0x60000050 DT_SIZE_K(12)>;\n+\t\t\t\treg = <0x08000050 DT_SIZE_K(12)>;\n-\t\t\tapp_region: app_region@60003050 {\n+\t\t\tapp_region: app_region@8003050 {\n-\t\t\t\treg = <0x60003050 0x6CFB0>; /* 435kb */\n+\t\t\t\treg = <0x08003050 0x6CFB0>; /* 435kb */\n+config BUILD_OUTPUT_ADJUST_LMA\n+\tdepends on XIP\n+\tdefault \"0x60000000 - $(dt_node_reg_addr_hex,$(dt_nodelabel_path,flash0))\"\n+"
},{
  "instruction": "modules: mbedtls: add Kconfig option for MBEDTLS_X509_CRT_WRITE_C",
  "input": "\tbool \"X509 CRL parsing\"\n\t  Used by X509 CRL parsing\n\tbool \"X509 Certificate Signing Requests writing\"\n\tbool \"X509 Certificate Signing Request parsing\"",
  "result": "-\tbool \"X509 CRL parsing\"\n+\tbool \"X.509 CRL parsing\"\n-\t  Used by X509 CRL parsing\n+\t  Used by X.509 CRL parsing\n-\tbool \"X509 Certificate Signing Requests writing\"\n+\tbool \"X.509 Certificate Signing Requests writing\"\n-\tbool \"X509 Certificate Signing Request parsing\"\n+\tbool \"X.509 Certificate Signing Request parsing\"\n+\n+config MBEDTLS_X509_CRT_WRITE_C\n+\tbool \"X.509 certificate creation\"\n+\n+#if defined(CONFIG_MBEDTLS_X509_CRT_WRITE_C)\n+#define MBEDTLS_X509_CRT_WRITE_C\n+#endif\n+"
},{
  "instruction": "arch: riscv: fill all IRQ stacks with 0xAA",
  "input": "\tli t1, __z_interrupt_stack_SIZEOF\n#endif",
  "result": "-\tli t1, __z_interrupt_stack_SIZEOF\n+\t/* Total size of all cores' IRQ stack */\n+\tli t1, __z_interrupt_all_stacks_SIZEOF\n-#endif\n+#endif /* CONFIG_INIT_STACKS */\n+GEN_ABSOLUTE_SYM(__z_interrupt_all_stacks_SIZEOF, sizeof(z_interrupt_stacks));"
},{
  "instruction": "dts: npcx: change the default memory configuration of npcx9m7fb",
  "input": "\t\treg = <0x10070000 DT_SIZE_K(320)>;\n\t\treg = <0x64000000 DT_SIZE_K(1024)>;\n\t\treg = <0x200C0000 DT_SIZE_K(64)>;\n\t\tsize = <DT_SIZE_M(1 * 8)>;",
  "result": "-\t\treg = <0x10070000 DT_SIZE_K(320)>;\n+\t\treg = <0x10070000 DT_SIZE_K(256)>;\n-\t\treg = <0x64000000 DT_SIZE_K(1024)>;\n+\t\treg = <0x64000000 DT_SIZE_K(512)>;\n-\t\treg = <0x200C0000 DT_SIZE_K(64)>;\n+\t\treg = <0x200B0000 DT_SIZE_K(128)>;\n-\t\tsize = <DT_SIZE_M(1 * 8)>;\n+\t\tsize = <DT_SIZE_K(512 * 8)>;"
},{
  "instruction": "soc: mcxc: replace PLATFORM_SPECIFIC_INIT with PLATFORM_RESET_HOOK",
  "input": "\tselect PLATFORM_SPECIFIC_INIT\n#ifdef CONFIG_PLATFORM_SPECIFIC_INIT\nvoid z_arm_platform_init(void)\n#endif /* CONFIG_PLATFORM_SPECIFIC_INIT */",
  "result": "-\tselect PLATFORM_SPECIFIC_INIT\n+\tselect SOC_RESET_HOOK\n-#ifdef CONFIG_PLATFORM_SPECIFIC_INIT\n+#ifdef CONFIG_SOC_RESET_HOOK\n-void z_arm_platform_init(void)\n+void soc_reset_hook(void)\n-#endif /* CONFIG_PLATFORM_SPECIFIC_INIT */\n+#endif /* CONFIG_SOC_RESET_HOOK */"
},{
  "instruction": "tests: Fix the platform exclude board name",
  "input": " platform_exclude: m2gl025_miv m5stack_core2 hifive1 qemu_xtensa_dc233c",
  "result": "-  platform_exclude: m2gl025_miv m5stack_core2 hifive1 qemu_xtensa_dc233c\n+  platform_exclude: m2gl025_miv m5stack_core2 hifive1 qemu_xtensa/dc233c/mmu"
},{
  "instruction": "mbedtls: remove unused option MBEDTLS_SSL_EXPORT_KEYS",
  "input": "config MBEDTLS_SSL_EXPORT_KEYS\n\tbool \"Support for exporting SSL key block and master secret\"\n#if defined(CONFIG_MBEDTLS_SSL_EXPORT_KEYS)\n#define MBEDTLS_SSL_EXPORT_KEYS\n#endif\n\tselect MBEDTLS_SSL_EXPORT_KEYS if OPENTHREAD_COMMISSIONER || OPENTHREAD_JOINER",
  "result": "+* The Kconfig option ``CONFIG_MBEDTLS_SSL_EXPORT_KEYS`` was removed because the\n+  corresponding build symbol was removed in Mbed TLS 3.1.0 and is now assumed to\n+  be enabled. (:github:`77657`)\n+\n-config MBEDTLS_SSL_EXPORT_KEYS\n-\tbool \"Support for exporting SSL key block and master secret\"\n-\n-#if defined(CONFIG_MBEDTLS_SSL_EXPORT_KEYS)\n-#define MBEDTLS_SSL_EXPORT_KEYS\n-#endif\n-\n+# Since Mbed TLS 3.1.0 MBEDTLS_SSL_EXPORT_KEYS was removed as build symbol and\n+# it's always assumed to be enabled. Corresponding kconfig was removed from\n+# Zephyr as well, but OpenThread code still uses it, so we add it here.\n+target_compile_definitions(ot-config INTERFACE -DMBEDTLS_SSL_EXPORT_KEYS)\n+\n-\tselect MBEDTLS_SSL_EXPORT_KEYS if OPENTHREAD_COMMISSIONER || OPENTHREAD_JOINER"
},{
  "instruction": "llext: test-simple: replace ARRAY_SIZE() with sizeof()",
  "input": "\t\t\t.buf_len = ARRAY_SIZE(_name ## _ext),\t\\\n\t\tLLEXT_BUF_LOADER(pre_located_ext, ARRAY_SIZE(pre_located_ext));\n\t\tLLEXT_BUF_LOADER(find_section_ext, ARRAY_SIZE(find_section_ext));",
  "result": "-\t\t\t.buf_len = ARRAY_SIZE(_name ## _ext),\t\\\n+\t\t\t.buf_len = sizeof(_name ## _ext),\t\\\n-\t\tLLEXT_BUF_LOADER(pre_located_ext, ARRAY_SIZE(pre_located_ext));\n+\t\tLLEXT_BUF_LOADER(pre_located_ext, sizeof(pre_located_ext));\n-\t\tLLEXT_BUF_LOADER(find_section_ext, ARRAY_SIZE(find_section_ext));\n+\t\tLLEXT_BUF_LOADER(find_section_ext, sizeof(find_section_ext));"
},{
  "instruction": "unittest: Enable debug info by default",
  "input": "",
  "result": "+target_compile_options(test_interface INTERFACE $<TARGET_PROPERTY:compiler,debug>)\n+"
},{
  "instruction": "tests: build_all: plic: install second instance to 0x8(uei)",
  "input": "\t\t\t\t&hlic0 0x03\n\t\t\t\t&hlic1 0x03\n\t\t\t\t&hlic2 0x03\n\t\t\t\t&hlic3 0x03\n\t\t\t\t&hlic4 0x03\n\t\t\t\t&hlic5 0x03\n\t\t\t\t&hlic6 0x03\n\t\t\t\t&hlic7 0x03\n     - CONFIG_2ND_LVL_INTR_01_OFFSET=3",
  "result": "-\t\t\t\t&hlic0 0x03\n-\t\t\t\t&hlic1 0x03\n-\t\t\t\t&hlic2 0x03\n-\t\t\t\t&hlic3 0x03\n-\t\t\t\t&hlic4 0x03\n-\t\t\t\t&hlic5 0x03\n-\t\t\t\t&hlic6 0x03\n-\t\t\t\t&hlic7 0x03\n+\t\t\t\t&hlic0 0x08\n+\t\t\t\t&hlic1 0x08\n+\t\t\t\t&hlic2 0x08\n+\t\t\t\t&hlic3 0x08\n+\t\t\t\t&hlic4 0x08\n+\t\t\t\t&hlic5 0x08\n+\t\t\t\t&hlic6 0x08\n+\t\t\t\t&hlic7 0x08\n-      - CONFIG_2ND_LVL_INTR_01_OFFSET=3\n+      - CONFIG_2ND_LVL_INTR_01_OFFSET=8"
},{
  "instruction": "drivers: intc: plic: refactor lock in `plic_irq_enable_set_state()`",
  "input": "\t\tuint32_t key;\n\t\tkey = irq_lock();\n\t\tirq_unlock(key);",
  "result": "-\n-\t\tuint32_t key;\n-\t\tkey = irq_lock();\n-\t\tirq_unlock(key);\n+\tuint32_t key = irq_lock();\n+\n+\n+\tirq_unlock(key);\n+\tuint32_t key = irq_lock();\n+\n+\n+\tirq_unlock(key);"
},{
  "instruction": "drivers: i3c: i3c_cdns Fix null pointer issue in i3c cadence driver.",
  "input": "\t\tconst struct i3c_target_callbacks *target_cb = data->target_config->callbacks;",
  "result": "-\t\tconst struct i3c_target_callbacks *target_cb = data->target_config->callbacks;\n+\t\tconst struct i3c_target_callbacks *target_cb =\n+\t\t\tdata->target_config ? data->target_config->callbacks : NULL;"
},{
  "instruction": "Bluetooth: Host: run clang-format on auto-init-procedures fns",
  "input": "\tif (IS_ENABLED(CONFIG_BT_AUTO_PHY_UPDATE) &&\n\t    BT_FEAT_LE_PHY_2M(bt_dev.le.features) &&\n\t\terr = bt_le_set_phy(conn, 0U, BT_HCI_LE_PHY_PREFER_2M,\n\t\t\t\t    BT_HCI_LE_PHY_PREFER_2M,\n\tif (IS_ENABLED(CONFIG_BT_AUTO_DATA_LEN_UPDATE) &&\n\t    BT_FEAT_LE_DLE(bt_dev.le.features) &&",
  "result": "-\tif (IS_ENABLED(CONFIG_BT_AUTO_PHY_UPDATE) &&\n-\t    BT_FEAT_LE_PHY_2M(bt_dev.le.features) &&\n+\tif (IS_ENABLED(CONFIG_BT_AUTO_PHY_UPDATE) && BT_FEAT_LE_PHY_2M(bt_dev.le.features) &&\n-\t\terr = bt_le_set_phy(conn, 0U, BT_HCI_LE_PHY_PREFER_2M,\n-\t\t\t\t    BT_HCI_LE_PHY_PREFER_2M,\n+\t\terr = bt_le_set_phy(conn, 0U, BT_HCI_LE_PHY_PREFER_2M, BT_HCI_LE_PHY_PREFER_2M,\n-\tif (IS_ENABLED(CONFIG_BT_AUTO_DATA_LEN_UPDATE) &&\n-\t    BT_FEAT_LE_DLE(bt_dev.le.features) &&\n+\tif (IS_ENABLED(CONFIG_BT_AUTO_DATA_LEN_UPDATE) && BT_FEAT_LE_DLE(bt_dev.le.features) &&"
},{
  "instruction": "Bluetooth: Host: refactor 2M PHY auto-update",
  "input": "static bool skip_auto_phy_update_on_conn_establishment(struct bt_conn *conn)\n\tif (IS_ENABLED(CONFIG_BT_AUTO_PHY_UPDATE) &&\n\t    IS_ENABLED(CONFIG_BT_EXT_ADV) &&\n\t    BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {\n#endif /* defined(CONFIG_BT_USER_PHY_UPDATE) */\n\t    !skip_auto_phy_update_on_conn_establishment(conn)) {",
  "result": "+\n+ *\n+ * It is ifdef'd because the struct fields don't exist in some configs.\n-static bool skip_auto_phy_update_on_conn_establishment(struct bt_conn *conn)\n+static bool uses_symmetric_2mbit_phy(struct bt_conn *conn)\n-\tif (IS_ENABLED(CONFIG_BT_AUTO_PHY_UPDATE) &&\n-\t    IS_ENABLED(CONFIG_BT_EXT_ADV) &&\n-\t    BT_DEV_FEAT_LE_EXT_ADV(bt_dev.le.features)) {\n+\tif (IS_ENABLED(CONFIG_BT_EXT_ADV)) {\n-#endif /* defined(CONFIG_BT_USER_PHY_UPDATE) */\n+#endif\n-\t    !skip_auto_phy_update_on_conn_establishment(conn)) {\n+\t    !uses_symmetric_2mbit_phy(conn)) {"
},{
  "instruction": "boards: nrf54h20dk: Fix settings partition",
  "input": "\t\t\treg = < 0x100000 DT_SIZE_K(892) >;\n\t\tstorage_partition: partition@1df000 {\n\t\t\treg = < 0x1df000 DT_SIZE_K(24) >;",
  "result": "-\t\t\treg = < 0x100000 DT_SIZE_K(892) >;\n+\t\t\treg = < 0x100000 DT_SIZE_K(908) >;\n-\t\tstorage_partition: partition@1df000 {\n-\t\t\treg = < 0x1df000 DT_SIZE_K(24) >;\n+\t\tstorage_partition: partition@1e3000 {\n+\t\t\treg = < 0x1e3000 DT_SIZE_K(24) >;"
},{
  "instruction": "ci: drop unused python exclusions",
  "input": "       exclude:\n       - os: macos-14\n         python-version: 3.6\n       - os: windows-2022\n         python-version: 3.6\n       exclude:\n       - os: macos-14\n         python-version: 3.6\n       - os: windows-2022\n         python-version: 3.6",
  "result": "-        exclude:\n-        - os: macos-14\n-          python-version: 3.6\n-        - os: windows-2022\n-          python-version: 3.6\n-        exclude:\n-        - os: macos-14\n-          python-version: 3.6\n-        - os: windows-2022\n-          python-version: 3.6"
},{
  "instruction": "west: fix for Python prior to 3.10",
  "input": "   def get_rtt_address(self) -> int | None:",
  "result": "-    def get_rtt_address(self) -> int | None:\n+    def get_rtt_address(self) -> Optional[int]:"
},{
  "instruction": "dts: arm: nxp: add Lpi2c support for S32Z27x",
  "input": "",
  "result": "+#include <zephyr/dt-bindings/i2c/i2c.h>\n+\t\tlpi2c1: i2c@409d0000 {\n+\t\t\tcompatible = \"nxp,imx-lpi2c\";\n+\t\t\treg = <0x409d0000 0x10000>;\n+\t\t\t#address-cells = <1>;\n+\t\t\t#size-cells = <0>;\n+\t\t\tinterrupts = <GIC_SPI 253 IRQ_TYPE_LEVEL IRQ_DEFAULT_PRIORITY>;\n+\t\t\tclocks = <&clock NXP_S32_P1_REG_INTF_CLK>;\n+\t\t\tclock-frequency = <I2C_BITRATE_STANDARD>;\n+\t\t\tstatus = \"disabled\";\n+\t\t};\n+\n+\t\tlpi2c2: i2c@421d0000 {\n+\t\t\tcompatible = \"nxp,imx-lpi2c\";\n+\t\t\treg = <0x421d0000 0x10000>;\n+\t\t\t#address-cells = <1>;\n+\t\t\t#size-cells = <0>;\n+\t\t\tinterrupts = <GIC_SPI 254 IRQ_TYPE_LEVEL IRQ_DEFAULT_PRIORITY>;\n+\t\t\tclocks = <&clock NXP_S32_P4_REG_INTF_CLK>;\n+\t\t\tclock-frequency = <I2C_BITRATE_STANDARD>;\n+\t\t\tstatus = \"disabled\";\n+\t\t};\n+\tselect HAS_MCUX_LPI2C"
},{
  "instruction": "intel_ish: add support for running with simics",
  "input": "",
  "result": "+set(SUPPORTED_EMU_PLATFORMS simics)\n+\n+if(CONFIG_BOARD_INTEL_ISH_5_8_0)\n+  board_emu_args(simics \"project=$ENV{SIMICS_PROJECT}\")\n+  board_emu_args(simics \"zephyr_elf=${APPLICATION_BINARY_DIR}/zephyr/${KERNEL_ELF_NAME}\")\n+  board_emu_args(simics \"zephyr_start_address=${CONFIG_SRAM_BASE_ADDRESS}\")\n+  include(${ZEPHYR_BASE}/boards/common/simics.board.cmake)\n+endif()\n+\n+simulation: simics\n+simulation_exec: simics"
},{
  "instruction": "twister: add simics as supported simulator",
  "input": "SUPPORTED_SIMS = [\"mdb-nsim\", \"nsim\", \"renode\", \"qemu\", \"tsim\", \"armfvp\", \"xt-sim\", \"native\", \"custom\"]\n       SUPPORTED_SIMS_WITH_EXEC = ['nsim', 'mdb-nsim', 'renode', 'tsim', 'native']",
  "result": "-SUPPORTED_SIMS = [\"mdb-nsim\", \"nsim\", \"renode\", \"qemu\", \"tsim\", \"armfvp\", \"xt-sim\", \"native\", \"custom\"]\n+SUPPORTED_SIMS = [\"mdb-nsim\", \"nsim\", \"renode\", \"qemu\", \"tsim\", \"armfvp\", \"xt-sim\", \"native\", \"custom\", \"simics\"]\n-        SUPPORTED_SIMS_WITH_EXEC = ['nsim', 'mdb-nsim', 'renode', 'tsim', 'native']\n+        SUPPORTED_SIMS_WITH_EXEC = ['nsim', 'mdb-nsim', 'renode', 'tsim', 'native', 'simics']"
},{
  "instruction": "doc: css: fix mobile layout and increase browser compatibility",
  "input": "",
  "result": "+    min-height: 100dvh;\n+        min-height: calc(100vh - 64px);"
},{
  "instruction": "llext: Add aarch64 to LLEXT tests",
  "input": "if (CONFIG_LLEXT_TYPE_ELF_RELOCATABLE AND CONFIG_XTENSA)\nif (CONFIG_LLEXT_TYPE_ELF_RELOCATABLE AND CONFIG_XTENSA)",
  "result": "-if (CONFIG_LLEXT_TYPE_ELF_RELOCATABLE AND CONFIG_XTENSA)\n+if (CONFIG_LLEXT_TYPE_ELF_RELOCATABLE AND NOT CONFIG_ARM)\n-if (CONFIG_LLEXT_TYPE_ELF_RELOCATABLE AND CONFIG_XTENSA)\n+if (CONFIG_LLEXT_TYPE_ELF_RELOCATABLE AND NOT CONFIG_ARM)\n+  extra_configs:\n+    - arch:arm64:CONFIG_LLEXT_HEAP_SIZE=128\n+  llext.simple.readonly_mmu:\n+    arch_allow: arm64 arm\n+    filter: CONFIG_ARM_MMU\n+    integration_platforms:\n+      - qemu_cortex_a53         # ARM Cortex-A53 (ARMv8-A ISA)\n+    extra_configs:\n+      - CONFIG_LLEXT_STORAGE_WRITABLE=n"
},{
  "instruction": "llext: Include aarch64 in LLEXT sample",
  "input": "",
  "result": "+    - qemu_cortex_a53         # ARM Cortex-A53 (ARMv8-A ISA)\n+    - qemu_cortex_a53"
},{
  "instruction": "llext: Add `RELA` sections processing for AARCH64",
  "input": "\t\t\t/* FIXME: currently implemented only on the Xtensa code path */\n\t\t\tif (!IS_ENABLED(CONFIG_XTENSA)) {",
  "result": "-\t\t\t/* FIXME: currently implemented only on the Xtensa code path */\n-\t\t\tif (!IS_ENABLED(CONFIG_XTENSA)) {\n+\t\t\tif (IS_ENABLED(CONFIG_ARM)) {"
},{
  "instruction": "llext: Removed unused i386 relocation name symbols",
  "input": "/**\n* Relocation names (should be moved to arch-specific files)\n* @cond ignore\n*/\n#define R_386_NONE 0\n#define R_386_32 1\n#define R_386_PC32 2\n#define R_386_GOT32 3\n#define R_386_PLT32 4\n#define R_386_COPY 5\n#define R_386_GLOB_DAT 6\n#define R_386_JMP_SLOT 7\n#define R_386_RELATIVE 8\n#define R_386_GOTOFF 9\n/** @endcond */",
  "result": "-/**\n- * Relocation names (should be moved to arch-specific files)\n- * @cond ignore\n- */\n-#define R_386_NONE 0\n-#define R_386_32 1\n-#define R_386_PC32 2\n-#define R_386_GOT32 3\n-#define R_386_PLT32 4\n-#define R_386_COPY 5\n-#define R_386_GLOB_DAT 6\n-#define R_386_JMP_SLOT 7\n-#define R_386_RELATIVE 8\n-#define R_386_GOTOFF 9\n-/** @endcond */\n-"
},{
  "instruction": "llext: Remove xtensa relocation names from arch agnostic LLEXT",
  "input": "#define R_XTENSA_NONE 0\n#define R_XTENSA_32 1\n#define R_XTENSA_SLOT0_OP 20",
  "result": "-\n-#define R_XTENSA_NONE 0\n-#define R_XTENSA_32 1\n-#define R_XTENSA_SLOT0_OP 20"
},{
  "instruction": "llext: Fix use of macro for relocation symbol index from r_info",
  "input": "\t\tunsigned int j = ELF32_R_SYM(rela.r_info);",
  "result": "-\t\tunsigned int j = ELF32_R_SYM(rela.r_info);\n+\t\tunsigned int j = ELF_R_SYM(rela.r_info);"
},{
  "instruction": "drivers: pwm: Fix NXP TPM without combine channel feature",
  "input": "",
  "result": "+#if defined(FSL_FEATURE_TPM_HAS_COMBINE) && FSL_FEATURE_TPM_HAS_COMBINE\n+#endif"
},{
  "instruction": "boards: st: nucleo_l496zg: add zephyr_udc0 and hsi48 dt nodes",
  "input": "",
  "result": "+| OTG FS    | on-chip    | USB OTG Full-speed                  |\n+&clk_hsi48 {\n+\tstatus = \"okay\";\n+};\n+\n+zephyr_udc0: &usbotg_fs {\n+\tpinctrl-0 = <&usb_otg_fs_dm_pa11 &usb_otg_fs_dp_pa12>;\n+\tpinctrl-names = \"default\";\n+\tstatus = \"okay\";\n+};\n+\n+  - usb\n+  - usb_device\n+  - usbd"
},{
  "instruction": "samples: posix: gettimeofday: add sntp resync option",
  "input": "",
  "result": "+CONFIG_NET_CONFIG_SNTP_INIT_RESYNC=y"
},{
  "instruction": "samples: nrf53_sync_rtc: Move shared memory buffer next to .data",
  "input": "NATIVE_SIMULATOR_IF uint32_t shared_cell_buffer;",
  "result": "-NATIVE_SIMULATOR_IF uint32_t shared_cell_buffer;\n+NATIVE_SIMULATOR_IF_DATA uint32_t shared_cell_buffer;"
},{
  "instruction": "boards: nrf_bsim: Move ipc backend next to .data",
  "input": "\tNATIVE_SIMULATOR_IF \\",
  "result": "-\tNATIVE_SIMULATOR_IF \\\n+\tNATIVE_SIMULATOR_IF_DATA \\"
},{
  "instruction": "arch posix/native: Let's make use of new split native simulator if",
  "input": "SECTIONS\n{\n} INSERT AFTER .text;\nSECTION_PROLOGUE (.native_sim_if,,)\n\tKEEP(*(.native_sim_if));\n\tKEEP(*(.native_sim_if.*));\n}",
  "result": "-SECTIONS\n-{\n-} INSERT AFTER .text;\n-SECTION_PROLOGUE (.native_sim_if,,)\n+#include <zephyr/linker/sections.h>\n+\n+SECTIONS\n+{\n+\tSECTION_PROLOGUE (.native_sim_if.data,,)\n+\t{\n+\t\tKEEP(*(.native_sim_if.data));\n+\t}\n+} INSERT AFTER .data;\n+\n+SECTIONS\n-\tKEEP(*(.native_sim_if));\n-\tKEEP(*(.native_sim_if.*));\n-}\n+\tSECTION_PROLOGUE (.native_sim_if,,)\n+\t{\n+\t\tKEEP(*(.native_sim_if));\n+\t\tKEEP(*(.native_sim_if.*));\n+\t}\n+} INSERT AFTER .text;"
},{
  "instruction": "native_simulator: Get latest from upstream",
  "input": "* Any symbol annotated by this macro will be visible outside of the\n#define NATIVE_SIMULATOR_IF __attribute__((visibility(\"default\"))) \\\n\t__attribute__((__section__(\".native_sim_if\")))",
  "result": "- * Any symbol annotated by this macro will be visible outside of the\n+ * Any symbol annotated by these macros will be visible outside of the\n-#define NATIVE_SIMULATOR_IF __attribute__((visibility(\"default\"))) \\\n-\t__attribute__((__section__(\".native_sim_if\")))\n+#define NATIVE_SIMULATOR_IF_SECT(sect) __attribute__((visibility(\"default\"))) \\\n+\t__attribute__((__section__(sect)))\n+#define NATIVE_SIMULATOR_IF NATIVE_SIMULATOR_IF_SECT(\".native_sim_if\")\n+#define NATIVE_SIMULATOR_IF_DATA NATIVE_SIMULATOR_IF_SECT(\".native_sim_if.data\")\n+#define NATIVE_SIMULATOR_IF_TEXT NATIVE_SIMULATOR_IF_SECT(\".native_sim_if.text\")\n+"
},{
  "instruction": "Tests: bsim: Use correct compilation folder",
  "input": "",
  "result": "+  local app_absolute=$(realpath \"${app_root}/${app}\")\n+  if [[ \"${app_absolute}\" != \"${app_root}\"* ]]; then\n+    this_dir=${WORK_DIR}/${app_absolute}/${exe_basename}\n+  fi"
},{
  "instruction": "ci: bsim tests: Also trigger on common nordic DT changes",
  "input": "",
  "result": "+      - \"boards/nordic/nrf5*/*dt*\"\n+      - \"dts/*/nordic/**\"\n+            boards/nordic/nrf5*/*dt*\n+            dts/*/nordic/"
},{
  "instruction": "ace: mm: tlb: Check tlb translation enabled before flushing cache",
  "input": "\tentry_idx = get_tlb_entry_idx(va);\n\tpa = tlb_entry_to_pa(tlb_entries[entry_idx]);",
  "result": "+\tuint16_t entry;\n+\tentry_idx = get_tlb_entry_idx(va);\n+\tentry = tlb_entries[entry_idx];\n+\n+\t/* Check if the translation is enabled in the TLB entry.\n+\t * Attempt to flush the cache of an inactive address will result in a cpu exception.\n+\t */\n+\tif (!(entry & TLB_ENABLE_BIT)) {\n+\t\tret = -EFAULT;\n+\t\tgoto out_unlock;\n+\t}\n+\n-\tentry_idx = get_tlb_entry_idx(va);\n-\tpa = tlb_entry_to_pa(tlb_entries[entry_idx]);\n+\tpa = tlb_entry_to_pa(entry);\n+out_unlock:"
},{
  "instruction": "tests: drivers: nrf_grtc: Add nRF54H20 PPR target",
  "input": "",
  "result": "+      - nrf54h20dk/nrf54h20/cpuppr"
},{
  "instruction": "samples: drivers: Enable SPI MEMORY driver samples for nrfl54l15",
  "input": "",
  "result": "+/*\n+ * Copyright (c) 2024 Nordic Semiconductor ASA\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+&mx25r64 {\n+\tstatus = \"okay\";\n+};\n+/*\n+ * Copyright (c) 2024 Nordic Semiconductor ASA\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+&mx25r64 {\n+\tstatus = \"okay\";\n+};"
},{
  "instruction": "tests: Add a CodeChecker config file",
  "input": "",
  "result": "+# SPDX-License-Identifier: Apache-2.0\n+#\n+# Copyright (c) 2024, Basalte bv\n+\n+analyzer:\n+  # Start by disabling all\n+  - --disable-all\n+\n+  # Enable the sensitive profile\n+  - --enable=sensitive\n+\n+  # Disable unused cases\n+  - --disable=boost\n+  - --disable=mpi\n+\n+  # Many identifiers in zephyr start with _\n+  - --disable=clang-diagnostic-reserved-identifier\n+  - --disable=clang-diagnostic-reserved-macro-identifier\n+\n+  # Cleanup\n+  - --clean"
},{
  "instruction": "cmake: sca: codechecker: Add cleanup step",
  "input": "",
  "result": "+zephyr_get(CODECHECKER_CLEANUP)\n+if(CODECHECKER_CLEANUP)\n+  add_custom_target(codechecker-cleanup ALL\n+    COMMAND ${CMAKE_COMMAND} -E rm -r ${output_dir}/codechecker.plist\n+  )\n+else()\n+  add_custom_target(codechecker-cleanup)\n+endif()\n+\n+add_dependencies(codechecker-cleanup codechecker)\n+\n+    add_dependencies(codechecker-cleanup codechecker-report-${export_item})\n+  add_dependencies(codechecker-cleanup codechecker-parse)\n+  add_dependencies(codechecker-cleanup codechecker-store)"
},{
  "instruction": "cmake: sca: codechecker: Parse twister variables",
  "input": "zephyr_get(CODECHECKER_TRIM_PATH_PREFIX)\n set(CODECHECKER_NAME zephyr)",
  "result": "+include(boards)\n+include(git)\n+include(extensions)\n+include(west)\n+\n-zephyr_get(CODECHECKER_TRIM_PATH_PREFIX)\n+zephyr_get(CODECHECKER_TRIM_PATH_PREFIX MERGE VAR CODECHECKER_TRIM_PATH_PREFIX WEST_TOPDIR)\n+\n+# Get twister runner specific variables\n+zephyr_get(TC_RUNID)\n+zephyr_get(TC_NAME)\n-  set(CODECHECKER_NAME zephyr)\n+  if(TC_NAME)\n+    set(CODECHECKER_NAME \"${BOARD}${BOARD_QUALIFIERS}:${TC_NAME}\")\n+  else()\n+    set(CODECHECKER_NAME zephyr)\n+  endif()\n+elseif(TC_RUNID)\n+  set(CODECHECKER_ANALYZE_JOBS \"--jobs;1\")\n+else()\n+  git_describe(${APPLICATION_SOURCE_DIR} app_version)\n+  if(app_version)\n+    set(CODECHECKER_STORE_TAG \"--tag;${app_version}\")\n+  endif()"
},{
  "instruction": "cmake: sca: codechecker: CMake targets instead of commands",
  "input": " BYPRODUCTS ${output_dir}/codechecker.plist\n   add_custom_command(\n     TARGET codechecker POST_BUILD\n add_custom_command(\n   TARGET codechecker POST_BUILD\n add_custom_command(\n   TARGET codechecker POST_BUILD",
  "result": "-  BYPRODUCTS ${output_dir}/codechecker.plist\n-    add_custom_command(\n-      TARGET codechecker POST_BUILD\n+    add_custom_target(codechecker-report-${export_item} ALL\n+    add_dependencies(codechecker-report-${export_item} codechecker)\n-  add_custom_command(\n-    TARGET codechecker POST_BUILD\n+    add_custom_target(codechecker-parse ALL\n+  add_dependencies(codechecker-parse codechecker)\n-  add_custom_command(\n-    TARGET codechecker POST_BUILD\n+  add_custom_target(codechecker-store ALL\n+  add_dependencies(codechecker-store codechecker)"
},{
  "instruction": "cmake: sca: codechecker: Use zephyr_get for variables",
  "input": "if(CODECHECKER_EXPORT)\nif(CODECHECKER_STORE OR CODECHECKER_STORE_OPTS)",
  "result": "+# Get CodeChecker specific variables\n+zephyr_get(CODECHECKER_ANALYZE_OPTS)\n+zephyr_get(CODECHECKER_EXPORT)\n+zephyr_get(CODECHECKER_PARSE_EXIT_STATUS)\n+zephyr_get(CODECHECKER_PARSE_OPTS)\n+zephyr_get(CODECHECKER_STORE)\n+zephyr_get(CODECHECKER_STORE_OPTS)\n+\n-\n-if(CODECHECKER_EXPORT)\n+if(DEFINED CODECHECKER_EXPORT)\n-if(CODECHECKER_STORE OR CODECHECKER_STORE_OPTS)\n+if(DEFINED CODECHECKER_STORE OR DEFINED CODECHECKER_STORE_OPTS)"
},{
  "instruction": "scripts: pylib: twister: Pass testsuite name to cmake",
  "input": "     '-B' + os.path.join('build', 'dir'), '-DTC_RUNID=1',\n     '-B' + os.path.join('build', 'dir'), '-DTC_RUNID=1',",
  "result": "+            f'-DTC_NAME={self.instance.testsuite.name}',\n-      '-B' + os.path.join('build', 'dir'), '-DTC_RUNID=1',\n+      '-B' + os.path.join('build', 'dir'), '-DTC_RUNID=1', '-DTC_NAME=testcase',\n-      '-B' + os.path.join('build', 'dir'), '-DTC_RUNID=1',\n+      '-B' + os.path.join('build', 'dir'), '-DTC_RUNID=1', '-DTC_NAME=testcase',\n+    instance_mock.testsuite.name = 'testcase'"
},{
  "instruction": "boards: st: nucleo_g0b1re: update pyocd target",
  "input": "# keil.stm32g0xx_dfp.1.3.0.pack introduced stm32g0b series, but the target does\n# not work with pyocd currently.\nboard_runner_args(pyocd \"--target=stm32g071rbtx\")\nPyocd support is currently limited: As the stm32g0b1 target causes issues,\nthe stm32g071 target is used. For STM32G0 support pyOCD needs additional target\ninformation, which can be installed by adding \"pack\" support with the\nfollowing pyOCD commands:",
  "result": "-# keil.stm32g0xx_dfp.1.3.0.pack introduced stm32g0b series, but the target does\n-# not work with pyocd currently.\n-board_runner_args(pyocd \"--target=stm32g071rbtx\")\n+board_runner_args(pyocd \"--target=stm32g0b1retx\")\n-Pyocd support is currently limited: As the stm32g0b1 target causes issues,\n-the stm32g071 target is used. For STM32G0 support pyOCD needs additional target\n-information, which can be installed by adding \"pack\" support with the\n-following pyOCD commands:\n+For STM32G0 support pyocd needs additional target information,\n+which can be installed by adding \"pack\" support with the following pyocd command:"
},{
  "instruction": "samples: shell_module: add imx93 board support",
  "input": "",
  "result": "+System Reboot (A55)\n+===================\n+\n+Currently i.MX93 only support cold reboot and doesn't support warm reboot.\n+Use this configuratiuon to verify cold reboot with :zephyr:code-sample:`shell-module`\n+sample:\n+\n+.. zephyr-app-commands::\n+   :zephyr-app: samples/subsys/shell/shell_module\n+   :host-os: unix\n+   :board: imx93_evk/mimx9352/a55\n+   :goals: build\n+\n+This will build an image with the shell sample app, boot it and execute\n+kernel reboot command in shell command line:\n+\n+.. code-block:: console\n+\n+    uart:~$ kernel reboot cold\n+\n+CONFIG_REBOOT=y\n+CONFIG_PM_CPU_OPS=y\n+CONFIG_PM_CPU_OPS_PSCI=y"
},{
  "instruction": "dts: imx93_a55: add PSCI device node",
  "input": "",
  "result": "+\tpsci: psci {\n+\t\tcompatible = \"arm,psci-1.1\";\n+\t\tmethod = \"smc\";\n+\t};\n+"
},{
  "instruction": "scripts: twister: add type hint to twister_main.py",
  "input": "def main(options, default_options):",
  "result": "+import argparse\n-def main(options, default_options):\n+def main(options: argparse.Namespace, default_options: argparse.Namespace):"
},{
  "instruction": "scripts: twisterlib: Fix warning about deprecation of truthiness",
  "input": "       if elem_ts := root.find('testsuite'):",
  "result": "-        if elem_ts := root.find('testsuite'):\n+\n+        if (elem_ts := root.find('testsuite')) is not None:"
},{
  "instruction": "drivers: hwinfo: stm32: mark STM32WB0 series as incompatible",
  "input": "\tdepends on SOC_FAMILY_STM32",
  "result": "-\tdepends on SOC_FAMILY_STM32\n+\tdepends on SOC_FAMILY_STM32 && !SOC_SERIES_STM32WB0X"
},{
  "instruction": "include: dt-bindings: add STM32WB0 reset header",
  "input": "",
  "result": "+/*\n+ * Copyright (c) 2024 STMicroelectronics\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+#ifndef ZEPHYR_INCLUDE_DT_BINDINGS_RESET_STM32WB0_RESET_H_\n+#define ZEPHYR_INCLUDE_DT_BINDINGS_RESET_STM32WB0_RESET_H_\n+\n+#include \"stm32-common.h\"\n+\n+/* RCC bus reset register offset */\n+#define STM32_RESET_BUS_AHB0\t0x30\n+#define STM32_RESET_BUS_APB0\t0x34\n+#define STM32_RESET_BUS_APB1\t0x38\n+#define STM32_RESET_BUS_APB2\t0x3C\n+\n+#endif /* ZEPHYR_INCLUDE_DT_BINDINGS_RESET_STM32WB0_RESET_H_ */"
},{
  "instruction": "dts: bindings: flash: add STM32WB0 flash controller",
  "input": "",
  "result": "+# Copyright (c) 2024 STMicroelectronics\n+# SPDX-License-Identifier: Apache-2.0\n+\n+description: STM32WB0 series flash controller\n+\n+compatible: \"st,stm32wb0-flash-controller\"\n+\n+include: flash-controller.yaml"
},{
  "instruction": "dts: bindings: intc: add STM32WB0 GPIO interrupt controller",
  "input": "",
  "result": "+# Copyright (c) 2024 STMicroelectronics\n+# SPDX-License-Identifier: Apache-2.0\n+\n+description: STM32WB0 GPIO Interrupt Controller\n+\n+compatible: \"st,stm32wb0-gpio-intc\"\n+\n+include: \"st,stm32-exti.yaml\""
},{
  "instruction": "modules: Kconfig.stm32: Add Kconfig symbols for RADIO",
  "input": "",
  "result": "+config USE_STM32_HAL_RADIO\n+\tbool\n+\thelp\n+\t  Enable STM32Cube Radio HAL module driver\n+\n+config USE_STM32_HAL_RADIO_TIMER\n+\tbool\n+\thelp\n+\t  Enable STM32Cube Radio Timer HAL module driver\n+"
},{
  "instruction": "west.yml: hal_stm32: Update to HAL integrating STM32WB0",
  "input": "     revision: 4c1adf8a2e2e9888f3b43374bf6521b0788aa82d",
  "result": "-      revision: 4c1adf8a2e2e9888f3b43374bf6521b0788aa82d\n+      revision: 1e6116bd2a36db976d955ee772d21f329e529873"
},{
  "instruction": "fix: power: ace: Move HST domain suspend before IMR context save",
  "input": "\t\t\tret = pm_device_runtime_put(INTEL_ADSP_HST_DOMAIN_DEV);\n\t\t\t__ASSERT_NO_MSG(ret == 0);",
  "result": "+\t\t\tret = pm_device_runtime_put(INTEL_ADSP_HST_DOMAIN_DEV);\n+\t\t\t__ASSERT_NO_MSG(ret == 0);\n-\t\t\tret = pm_device_runtime_put(INTEL_ADSP_HST_DOMAIN_DEV);\n-\t\t\t__ASSERT_NO_MSG(ret == 0);"
},{
  "instruction": "tests: posix: fs: add testsuite for open truncate",
  "input": "",
  "result": "+\n+ZTEST(posix_fs_file_test, test_file_open_truncate)\n+{\n+\tstruct stat buf = {0};\n+\n+\tzassert_ok(test_file_open());\n+\tzassert_ok(test_file_write());\n+\tzassert_ok(test_file_close());\n+\tfile = open(TEST_FILE, O_RDWR | O_TRUNC);\n+\tzassert_not_equal(file, -1,\n+\t\t\t  \"File open failed for truncate mode\");\n+\n+\tzassert_ok(test_file_close());\n+\tzassert_ok(stat(TEST_FILE, &buf));\n+\tzassert_equal(buf.st_size, 0, \"Error: file is not truncated\");\n+\tzassert_ok(test_file_delete());\n+}"
},{
  "instruction": "lib: posix:fs: handle O_TRUNC in open()",
  "input": "",
  "result": "+\tmode |= (mf & O_TRUNC) ? FS_O_TRUNC : 0;"
},{
  "instruction": "include: posix: fcntl: add O_TRUNC flags for posix open()",
  "input": "#define O_CREAT 0x0040\n#define O_CREAT 0x0200\n#define O_APPEND   0x0400",
  "result": "-#define O_CREAT 0x0040\n+#define O_CREAT\t 0x0040\n+#define O_TRUNC\t 0x0200\n+#define O_APPEND 0x0400\n-#define O_CREAT 0x0200\n+#define O_CREAT\t 0x0200\n+#define O_TRUNC\t 0x0400\n+#define O_APPEND 0x0008\n-#define O_APPEND   0x0400"
},{
  "instruction": "Bluetooth: Controller: Rework FAKE_ENTROPY_NATIVE_POSIX text",
  "input": "\t  Use random number generation provided by the Controller.\n\t  This option allows for Controller implementation that do not use true\n\t  random number generation and hence making the implementation as\n\t  experimental.\n\t  Controller implementations can provide custom bare-metal random number\n\t  implementation without any support in Zephyr driver, i.e. there is no\n\t  ENTROPY_HAS_DRIVER enabled.\n\t  Support for HCI LE Rand and HCI LE Encrypt commands are mandatory\n\t  by Bluetooth Core Specification.\n\t  combined builds for single CPU SoCs, applications can use its own",
  "result": "-\t  Use random number generation provided by the Controller.\n+\t  Use random number generation selected by the Controller.\n-\t  This option allows for Controller implementation that do not use true\n-\t  random number generation and hence making the implementation as\n-\t  experimental.\n+\t  Deselecting this option allows for Controllers to use other entropy\n+\t  generators which may not be true random number generators, and hence\n+\t  would make the implementation experimental.\n-\t  Controller implementations can provide custom bare-metal random number\n-\t  implementation without any support in Zephyr driver, i.e. there is no\n-\t  ENTROPY_HAS_DRIVER enabled.\n+\t  A Controller implementation could also provide custom bare-metal\n+\t  random number generator implementation without any support in Zephyr\n+\t  driver, i.e. there is no ENTROPY_HAS_DRIVER enabled.\n-\t  Support for HCI LE Rand and HCI LE Encrypt commands are mandatory\n-\t  by Bluetooth Core Specification.\n+\t  Support for HCI LE Rand and HCI LE Encrypt commands is mandatory by\n+\t  Bluetooth Core Specification.\n-\t  combined builds for single CPU SoCs, applications can use its own\n+\t  combined builds for single CPU SoCs, applications can use their own\n+/* FIXME: This could probably use a chosen entropy device instead on relying on\n+ * the nodelabel being the same as for the old nrf rng.\n+ */"
},{
  "instruction": "mbedtls: do not set PSA_WANT_KEY_TYPE_[RSA/ECC]_KEY_PAIR_BASIC",
  "input": "\tselect PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_BASIC if PSA_CRYPTO_CLIENT\nCONFIG_PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_BASIC=y\n\tselect PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_BASIC\n\tselect PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_BASIC if PSA_CRYPTO_CLIENT\nCONFIG_PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_BASIC=y\nCONFIG_PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_IMPORT=y",
  "result": "-\tselect PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_BASIC if PSA_CRYPTO_CLIENT\n+\tselect PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_EXPORT if PSA_CRYPTO_CLIENT\n+\tselect PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_GENERATE if PSA_CRYPTO_CLIENT\n-CONFIG_PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_BASIC=y\n+CONFIG_PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_IMPORT=y\n+CONFIG_PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_EXPORT=y\n-\tselect PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_BASIC\n+\tselect PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_IMPORT\n+\tselect PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_EXPORT\n-\tselect PSA_WANT_KEY_TYPE_RSA_KEY_PAIR_BASIC if PSA_CRYPTO_CLIENT\n-CONFIG_PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_BASIC=y\n-CONFIG_PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_IMPORT=y"
},{
  "instruction": "MAINTAINERS: add josuah as Video collaborator",
  "input": "",
  "result": "+    - josuah\n+    - samples/drivers/video/"
},{
  "instruction": "tests: demand_paging: move existing test to a mem_map subdirectory",
  "input": " kernel.demand_paging:\n kernel.demand_paging.timing_funcs:",
  "result": "-  kernel.demand_paging:\n+  kernel.demand_paging.mem_map:\n-  kernel.demand_paging.timing_funcs:\n+  kernel.demand_paging.mem_map.timing_funcs:"
},{
  "instruction": "arm64: demand paging is supported",
  "input": "   platform_allow: qemu_x86_tiny",
  "result": "+\tselect ARCH_HAS_DEMAND_PAGING\n+\tselect ARCH_HAS_DEMAND_MAPPING\n+# Copyright (c) 2024 BayLibre SAS\n+# SPDX-License-Identifier: Apache-2.0\n+\n+CONFIG_BACKING_STORE_RAM=y\n+CONFIG_BACKING_STORE_RAM_PAGES=24\n+CONFIG_SRAM_SIZE=400\n+# Copyright (c) 2024 BayLibre SAS\n+# SPDX-License-Identifier: Apache-2.0\n+\n+CONFIG_BACKING_STORE_RAM=y\n+CONFIG_BACKING_STORE_RAM_PAGES=24\n+CONFIG_SRAM_SIZE=450\n+CONFIG_DEMAND_PAGING_ALLOW_IRQ=y\n+CONFIG_DEMAND_PAGING=y\n-    platform_allow: qemu_x86_tiny\n+    platform_allow:\n+      - qemu_cortex_a53\n+      - qemu_cortex_a53/qemu_cortex_a53/smp\n+      - qemu_x86_tiny"
},{
  "instruction": "arm64: demand_paging: add the k_mem_paging_eviction_accessed() call",
  "input": "",
  "result": "+#include <zephyr/kernel/mm/demand_paging.h>\n+\tuintptr_t phys;\n+\n+\t\t/* tell the eviction algorithm about it */\n+\t\tphys = desc & PTE_PHYSADDR_MASK;\n+\t\tk_mem_paging_eviction_accessed(phys);\n+\n+\t\t/* this also counts as an access refresh */\n+\t\tphys = desc & PTE_PHYSADDR_MASK;\n+\t\tk_mem_paging_eviction_accessed(phys);\n+\tdefault EVICTION_LRU if ARM64"
},{
  "instruction": "arm64: mmu: be stricter about free page entries",
  "input": "",
  "result": "+\treturn desc == 0;\n+}\n+\n+static inline bool is_inval_desc(uint64_t desc)\n+{\n+\t/* invalid descriptors aren't necessarily free */"
},{
  "instruction": "samples: drivers: counter: Enable it for MAX32 MCUs",
  "input": "",
  "result": "+#elif defined(CONFIG_COUNTER_TIMER_MAX32)\n+#define TIMER DT_NODELABEL(counter0)"
},{
  "instruction": "boards: arm: Add counter in MAX32662 driver list",
  "input": "",
  "result": "+| Timer     | on-chip    | counter                             |\n+  - counter"
},{
  "instruction": "boards: arm: Add counter in MAX32666 driver list",
  "input": "",
  "result": "+| Timer     | on-chip    | counter                             |\n+  - counter\n+| Timer     | on-chip    | counter                             |\n+  - counter"
},{
  "instruction": "boards: arm: Add counter in MAX32680 driver list",
  "input": "",
  "result": "+| Timer     | on-chip    | counter                             |\n+  - counter"
},{
  "instruction": "boards: arm: Add counter in MAX32672 driver list",
  "input": "",
  "result": "+| Timer     | on-chip    | counter                             |\n+  - counter\n+| Timer     | on-chip    | counter                             |\n+  - counter"
},{
  "instruction": "boards: arm: Add counter in MAX32670 driver list",
  "input": "",
  "result": "+| Timer     | on-chip    | counter                             |\n+  - counter"
},{
  "instruction": "boards: arm: Add counter in MAX32690 driver list",
  "input": "",
  "result": "+  - counter\n+| Timer     | on-chip    | counter                            |\n+| Timer     | on-chip    | counter                             |\n+  - counter"
},{
  "instruction": "boards: arm: Add counter in MAX32655 driver list",
  "input": "",
  "result": "+| Timer     | on-chip    | counter                             |\n+  - counter\n+| Timer     | on-chip    | counter                             |\n+  - counter"
},{
  "instruction": "dts: arm: adi: Add timer counter instance for MAX32662",
  "input": "",
  "result": "+\t\t\tcounter {\n+\t\t\t\tcompatible = \"adi,max32-counter\";\n+\t\t\t\tstatus = \"disabled\";\n+\t\t\t};"
},{
  "instruction": "dts: arm: adi: Add timer counter instance for MAX32680",
  "input": "",
  "result": "+\t\t\tcounter {\n+\t\t\t\tcompatible = \"adi,max32-counter\";\n+\t\t\t\tstatus = \"disabled\";\n+\t\t\t};\n+\t\t\tcounter {\n+\t\t\t\tcompatible = \"adi,max32-counter\";\n+\t\t\t\tstatus = \"disabled\";\n+\t\t\t};"
},{
  "instruction": "dts: arm: adi: Add timer counter instance for MAX32672",
  "input": "",
  "result": "+\t\t\tcounter {\n+\t\t\t\tcompatible = \"adi,max32-counter\";\n+\t\t\t\tstatus = \"disabled\";\n+\t\t\t};\n+\t\t\tcounter {\n+\t\t\t\tcompatible = \"adi,max32-counter\";\n+\t\t\t\tstatus = \"disabled\";\n+\t\t\t};"
},{
  "instruction": "dts: arm: adi: Add timer counter instance to MAX32670",
  "input": "",
  "result": "+\t\t\tcounter {\n+\t\t\t\tcompatible = \"adi,max32-counter\";\n+\t\t\t\tstatus = \"disabled\";\n+\t\t\t};\n+\t\t\tcounter {\n+\t\t\t\tcompatible = \"adi,max32-counter\";\n+\t\t\t\tstatus = \"disabled\";\n+\t\t\t};"
},{
  "instruction": "dts: arm: adi: Add timer counter instance for MAX32690",
  "input": "",
  "result": "+\t\t\tcounter {\n+\t\t\t\tcompatible = \"adi,max32-counter\";\n+\t\t\t\tstatus = \"disabled\";\n+\t\t\t};\n+\t\t\tcounter {\n+\t\t\t\tcompatible = \"adi,max32-counter\";\n+\t\t\t\tstatus = \"disabled\";\n+\t\t\t};"
},{
  "instruction": "dts: arm: adi: Add MAX32662 timer instances",
  "input": "",
  "result": "+/delete-node/ &timer3;\n+\n+\n+\t\tlptimer0: timer@40113000 {\n+\t\t\tcompatible = \"adi,max32-timer\";\n+\t\t\treg = <0x40113000 0x2000>;\n+\t\t\tinterrupts = <8 0>;\n+\t\t\tstatus = \"disabled\";\n+\t\t\tclocks = <&gcr ADI_MAX32_CLOCK_BUS2 0>;\n+\t\t\tclock-source = <ADI_MAX32_PRPH_CLK_SRC_PCLK>;\n+\t\t\tprescaler = <1>;\n+\t\t};"
},{
  "instruction": "dts: arm: adi: Add MAX32666 timer instance",
  "input": "",
  "result": "+\n+\t\ttimer4: timer@40014000 {\n+\t\t\tcompatible = \"adi,max32-timer\";\n+\t\t\treg = <0x40014000 0x1000>;\n+\t\t\tinterrupts = <9 0>;\n+\t\t\tstatus = \"disabled\";\n+\t\t\tclocks = <&gcr ADI_MAX32_CLOCK_BUS0 19>;\n+\t\t\tclock-source = <ADI_MAX32_PRPH_CLK_SRC_PCLK>;\n+\t\t\tprescaler = <1>;\n+\t\t};\n+\n+\t\ttimer5: timer@40015000 {\n+\t\t\tcompatible = \"adi,max32-timer\";\n+\t\t\treg = <0x40015000 0x1000>;\n+\t\t\tinterrupts = <10 0>;\n+\t\t\tstatus = \"disabled\";\n+\t\t\tclocks = <&gcr ADI_MAX32_CLOCK_BUS0 20>;\n+\t\t\tclock-source = <ADI_MAX32_PRPH_CLK_SRC_PCLK>;\n+\t\t\tprescaler = <1>;\n+\t\t};"
},{
  "instruction": "dts: arm: adi: Add MAX32675 extra timer instance",
  "input": "",
  "result": "+\n+\t\tlptimer0: timer@40114000 {\n+\t\t\tcompatible = \"adi,max32-timer\";\n+\t\t\treg = <0x40114000 0x1000>;\n+\t\t\tinterrupts = <9 0>;\n+\t\t\tstatus = \"disabled\";\n+\t\t\tclocks = <&gcr ADI_MAX32_CLOCK_BUS2 0>;\n+\t\t\tclock-source = <ADI_MAX32_PRPH_CLK_SRC_PCLK>;\n+\t\t\tprescaler = <1>;\n+\t\t};"
},{
  "instruction": "dts: arm: adi: max32680 Add extra timer peripherals",
  "input": "",
  "result": "+\n+\t\tlptimer0: timer@40080c00 {\n+\t\t\tcompatible = \"adi,max32-timer\";\n+\t\t\treg = <0x40080c00 0x400>;\n+\t\t\tinterrupts = <9 0>;\n+\t\t\tstatus = \"disabled\";\n+\t\t\tclocks = <&gcr ADI_MAX32_CLOCK_BUS2 2>;\n+\t\t\tclock-source = <ADI_MAX32_PRPH_CLK_SRC_IBRO>;\n+\t\t\tprescaler = <1>;\n+\t\t};\n+\n+\t\tlptimer1: timer@40081000 {\n+\t\t\tcompatible = \"adi,max32-timer\";\n+\t\t\treg = <0x40081000 0x400>;\n+\t\t\tinterrupts = <10 0>;\n+\t\t\tstatus = \"disabled\";\n+\t\t\tclocks = <&gcr ADI_MAX32_CLOCK_BUS2 3>;\n+\t\t\tclock-source = <ADI_MAX32_PRPH_CLK_SRC_IBRO>;\n+\t\t\tprescaler = <1>;\n+\t\t};"
},{
  "instruction": "dts: arm: adi: Add MAX32672 timer instances",
  "input": "",
  "result": "+\n+\t\tlptimer0: timer@40114000 {\n+\t\t\tcompatible = \"adi,max32-timer\";\n+\t\t\treg = <0x40114000 0x1000>;\n+\t\t\tinterrupts = <9 0>;\n+\t\t\tstatus = \"disabled\";\n+\t\t\tclocks = <&gcr ADI_MAX32_CLOCK_BUS2 0>;\n+\t\t\tclock-source = <ADI_MAX32_PRPH_CLK_SRC_PCLK>;\n+\t\t\tprescaler = <1>;\n+\t\t};\n+\n+\t\tlptimer1: timer@40115000 {\n+\t\t\tcompatible = \"adi,max32-timer\";\n+\t\t\treg = <0x40115000 0x1000>;\n+\t\t\tinterrupts = <10 0>;\n+\t\t\tstatus = \"disabled\";\n+\t\t\tclocks = <&gcr ADI_MAX32_CLOCK_BUS2 1>;\n+\t\t\tclock-source = <ADI_MAX32_PRPH_CLK_SRC_PCLK>;\n+\t\t\tprescaler = <1>;\n+\t\t};"
},{
  "instruction": "dts: arm: adi: Add MAX32670 timer instances",
  "input": "",
  "result": "+\n+\t\tlptimer0: timer@40114000 {\n+\t\t\tcompatible = \"adi,max32-timer\";\n+\t\t\treg = <0x40114000 0x1000>;\n+\t\t\tinterrupts = <9 0>;\n+\t\t\tstatus = \"disabled\";\n+\t\t\tclocks = <&gcr ADI_MAX32_CLOCK_BUS2 0>;\n+\t\t\tclock-source = <ADI_MAX32_PRPH_CLK_SRC_PCLK>;\n+\t\t\tprescaler = <1>;\n+\t\t};\n+\n+\t\tlptimer1: timer@40115000 {\n+\t\t\tcompatible = \"adi,max32-timer\";\n+\t\t\treg = <0x40115000 0x1000>;\n+\t\t\tinterrupts = <10 0>;\n+\t\t\tstatus = \"disabled\";\n+\t\t\tclocks = <&gcr ADI_MAX32_CLOCK_BUS2 1>;\n+\t\t\tclock-source = <ADI_MAX32_PRPH_CLK_SRC_PCLK>;\n+\t\t\tprescaler = <1>;\n+\t\t};"
},{
  "instruction": "dts: arm: adi: Add MAX32690 timer instances",
  "input": "",
  "result": "+\n+\t\tlptimer0: timer@40080c00 {\n+\t\t\tcompatible = \"adi,max32-timer\";\n+\t\t\treg = <0x40080c00 0x400>;\n+\t\t\tinterrupts = <9 0>;\n+\t\t\tstatus = \"disabled\";\n+\t\t\tclocks = <&gcr ADI_MAX32_CLOCK_BUS2 2>;\n+\t\t\tclock-source = <ADI_MAX32_PRPH_CLK_SRC_IBRO>;\n+\t\t\tprescaler = <1>;\n+\t\t};\n+\n+\t\tlptimer1: timer@40081000 {\n+\t\t\tcompatible = \"adi,max32-timer\";\n+\t\t\treg = <0x40081000 0x400>;\n+\t\t\tinterrupts = <10 0>;\n+\t\t\tstatus = \"disabled\";\n+\t\t\tclocks = <&gcr ADI_MAX32_CLOCK_BUS2 3>;\n+\t\t\tclock-source = <ADI_MAX32_PRPH_CLK_SRC_IBRO>;\n+\t\t\tprescaler = <1>;\n+\t\t};"
},{
  "instruction": "samples: boards: nrf: nrfx: Fix (D)PPI dependency",
  "input": "source \"Kconfig.zephyr\"",
  "result": "+source \"Kconfig.zephyr\"\n+\n-\n-source \"Kconfig.zephyr\""
},{
  "instruction": "tests: Bluetooth: Fix minor issues for bap_base unit tests",
  "input": "project(bluetooth_codec)\n\tret = bt_bap_base_foreach_subgroup(base, test_base_get_subgroup_codec_id_cb, NULL);\n\tret = bt_bap_base_foreach_subgroup(base, test_base_get_subgroup_codec_data_cb, NULL);\n\tret = bt_bap_base_foreach_subgroup(base, test_base_get_subgroup_codec_meta_cb, NULL);\n\tret = bt_bap_base_foreach_subgroup(base, test_base_subgroup_codec_to_codec_cfg_cb, NULL);\n\tuint32_t bis_indexes;",
  "result": "-project(bluetooth_codec)\n+project(bluetooth_bap_base)\n-\tret = bt_bap_base_foreach_subgroup(base, test_base_get_subgroup_codec_id_cb, NULL);\n+\tret = bt_bap_base_foreach_subgroup(\n+\t\tbase, test_base_get_subgroup_codec_id_inval_param_null_cb, NULL);\n-\tret = bt_bap_base_foreach_subgroup(base, test_base_get_subgroup_codec_data_cb, NULL);\n+\tret = bt_bap_base_foreach_subgroup(\n+\t\tbase, test_base_get_subgroup_codec_data_inval_param_null_cb, NULL);\n-\tret = bt_bap_base_foreach_subgroup(base, test_base_get_subgroup_codec_meta_cb, NULL);\n+\tret = bt_bap_base_foreach_subgroup(\n+\t\tbase, test_base_get_subgroup_codec_meta_inval_param_null_cb, NULL);\n-\tret = bt_bap_base_foreach_subgroup(base, test_base_subgroup_codec_to_codec_cfg_cb, NULL);\n+\tret = bt_bap_base_foreach_subgroup(\n+\t\tbase, test_base_subgroup_codec_to_codec_cfg_inval_param_null_cb, NULL);\n-\tuint32_t bis_indexes;"
},{
  "instruction": "tests: Bluetooth: BAP: Fix BT_BAP_BASE dependency for unit tests",
  "input": "# Temporary override\n#\n# Copyright (c) 2024 Nordic Semiconductor ASA\n# SPDX-License-Identifier: Apache-2.0\n#\nconfig BT_BAP_BASE\n\t# Override until someone fixes the UT build system\n\tbool\n\tdefault y\n# Include Zephyr's Kconfig.\nsource \"Kconfig.zephyr\"",
  "result": "-# Temporary override\n-#\n-# Copyright (c) 2024 Nordic Semiconductor ASA\n-\n-# SPDX-License-Identifier: Apache-2.0\n-#\n-\n-config BT_BAP_BASE\n-\t# Override until someone fixes the UT build system\n-\tbool\n-\tdefault y\n-\n-# Include Zephyr's Kconfig.\n-source \"Kconfig.zephyr\"\n+# Need to enable one broadcast role to enable CONFIG_BT_BAP_BASE\n+CONFIG_BT_BAP_SCAN_DELEGATOR=y\n+CONFIG_BT_BAP_BASE_LOG_LEVEL_DBG=y"
},{
  "instruction": "tests: Bluetooth: Controller:  Move controller tests to same dir",
  "input": "   - tests/bluetooth/ctrl*/\n   - tests/bluetooth/ll_settings/\n   - tests/bluetooth/ctrl*/\n   - tests/bluetooth/ll_settings/",
  "result": "-    - tests/bluetooth/ctrl*/\n-    - tests/bluetooth/ll_settings/\n-    - tests/bluetooth/ctrl*/\n-    - tests/bluetooth/ll_settings/"
},{
  "instruction": "cmake: Fix finding python in virtualenv",
  "input": "   find_program(Python3_EXECUTABLE ${candidate} PATHS ENV VIRTUAL_ENV NO_CMAKE_PATH)",
  "result": "-    find_program(Python3_EXECUTABLE ${candidate} PATHS ENV VIRTUAL_ENV NO_CMAKE_PATH)\n+    find_program(Python3_EXECUTABLE ${candidate} PATHS ENV VIRTUAL_ENV NO_CMAKE_PATH NO_CMAKE_ENVIRONMENT_PATH)"
},{
  "instruction": "doc: new Kconfig to allow non-CS sources in psa_generate_random()",
  "input": "",
  "result": "+  * The Kconfig symbol :kconfig:option:`CONFIG_MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG_ALLOW_NON_CSPRNG`\n+    was added to allow ``psa_get_random()`` to make use of non-cryptographically\n+    secure random sources when :kconfig:option:`CONFIG_MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG`\n+    is also enabled. This is only meant to be used for test purposes, not in production.\n+    (:github:`76408`)"
},{
  "instruction": "doc: rename Mbed TLS entropy Kconfigs",
  "input": "",
  "result": "+* The following Kconfig symbols were renamed (:github:`76408`):\n+  * ``CONFIG_MBEDTLS_ENTROPY_ENABLED`` is now :kconfig:option:``CONFIG_MBEDTLS_ENTROPY_C``,\n+  * ``CONFIG_MBEDTLS_ZEPHYR_ENTROPY`` is now :kconfig:option:``CONFIG_MBEDTLS_ENTROPY_POLL_ZEPHYR``."
},{
  "instruction": "Bluetooth: GMAP: Replace busy bool with atomic",
  "input": "\tbool busy;\n\tgmap_cli->busy = false;\n\tif (gmap_cli->busy) {",
  "result": "+#include <zephyr/sys/atomic.h>\n+enum gmap_client_flag {\n+\tGMAP_CLIENT_FLAG_BUSY,\n+\n+\tGMAP_CLIENT_FLAG_NUM_FLAGS, /* keep as last */\n+};\n+\n-\tbool busy;\n-\n+\n+\tATOMIC_DEFINE(flags, GMAP_CLIENT_FLAG_NUM_FLAGS);\n-\tgmap_cli->busy = false;\n+\tatomic_clear_bit(gmap_cli->flags, GMAP_CLIENT_FLAG_BUSY);\n-\tif (gmap_cli->busy) {\n+\tif (atomic_test_and_set_bit(gmap_cli->flags, GMAP_CLIENT_FLAG_BUSY)) {\n+\t\tatomic_clear_bit(gmap_cli->flags, GMAP_CLIENT_FLAG_BUSY);\n+"
},{
  "instruction": "drivers: i2c: update i2c driver to integrate stm32u0",
  "input": "\t\t     SOC_SERIES_STM32G0X || SOC_SERIES_STM32L0X",
  "result": "-\t\t     SOC_SERIES_STM32G0X || SOC_SERIES_STM32L0X\n+\t\t     SOC_SERIES_STM32G0X || SOC_SERIES_STM32L0X || \\\n+\t\t     SOC_SERIES_STM32U0X\n+#if defined(I2C_CR1_SMBDEN) && defined(I2C_CR1_SMBHEN)\n+#endif\n+#if defined(I2C_CR1_SMBDEN) && defined(I2C_CR1_SMBHEN)\n+#endif"
},{
  "instruction": "soc: st: stm32: stm32u0x: add soc configs for i2c shared irq",
  "input": "",
  "result": "+if I2C_STM32\n+\n+config SHARED_INTERRUPTS\n+\tdefault y if $(dt_nodelabel_enabled,i2c2) && $(dt_nodelabel_enabled,i2c3)\n+\tdefault y if $(dt_nodelabel_enabled,i2c2) && $(dt_nodelabel_enabled,i2c4)\n+\tdefault y if $(dt_nodelabel_enabled,i2c3) && $(dt_nodelabel_enabled,i2c4)\n+\n+endif # I2C_STM32\n+"
},{
  "instruction": "tests: drivers: uart: uart_errors: Add missing pull up",
  "input": "\t\t\tpsels = <NRF_PSEL(UART_RX, 0, 6)>,\n\t\t\t\t<NRF_PSEL(UART_RTS, 0, 8)>;",
  "result": "-\t\t\tpsels = <NRF_PSEL(UART_RX, 0, 6)>,\n-\t\t\t\t<NRF_PSEL(UART_RTS, 0, 8)>;\n+\t\t\tpsels = <NRF_PSEL(UART_RX, 0, 6)>;\n+\t\t\tbias-pull-up;\n+\t\t};\n+\t\tgroup2 {\n+\t\t\tpsels = <NRF_PSEL(UART_RTS, 0, 8)>;"
},{
  "instruction": "llext: hotfix: fix function pointer logging",
  "input": "\t\t\tis_init ? \"bringup\" : \"teardown\", fn_table[i]);\n\tLOG_DBG(\"calling entry function %p(%p)\", entry_fn, user_data);\n\t\t\t\tLOG_ERR(\"init function %i (%p) outside text region\",",
  "result": "-\t\t\tis_init ? \"bringup\" : \"teardown\", fn_table[i]);\n+\t\t\tis_init ? \"bringup\" : \"teardown\", (void *)fn_table[i]);\n-\tLOG_DBG(\"calling entry function %p(%p)\", entry_fn, user_data);\n+\tLOG_DBG(\"calling entry function %p(%p)\", (void *)entry_fn, user_data);\n-\t\t\t\tLOG_ERR(\"init function %i (%p) outside text region\",\n+\t\t\t\tLOG_ERR(\"%s function %i (%p) outside text region\",\n+\t\t\t\t\tis_init ? \"bringup\" : \"teardown\","
},{
  "instruction": "arch: Fix assert logic for installing shared interrupt",
  "input": "\t\t__ASSERT(client->isr != routine && client->arg != param,\n\t\t\t \"trying to register duplicate ISR/arg pair\");",
  "result": "-\t\t__ASSERT(client->isr != routine && client->arg != param,\n-\t\t\t \"trying to register duplicate ISR/arg pair\");\n+\t\t__ASSERT((client->isr == routine && client->arg == param) == false,\n+\t\t\t \"ISR/arg combination is already registered\");"
},{
  "instruction": "style: soc: comply with MISRA C:2012 Rule 15.6",
  "input": "\tif (enable)\n\telse\n\tif (pm_state_next_get(cpu_num)->state == PM_STATE_ACTIVE)\n\telse\n\t\t\tfor (int i = 0; i < HPSRAM_SEGMENTS; i++)",
  "result": "-\tif (enable)\n+\tif (enable) {\n-\telse\n+\t} else {\n+\t}\n-\tif (pm_state_next_get(cpu_num)->state == PM_STATE_ACTIVE)\n+\tif (pm_state_next_get(cpu_num)->state == PM_STATE_ACTIVE) {\n-\telse\n+\t} else {\n+\t}\n-\t\t\tfor (int i = 0; i < HPSRAM_SEGMENTS; i++)\n+\t\t\tfor (int i = 0; i < HPSRAM_SEGMENTS; i++) {\n+\t\t\t}"
},{
  "instruction": "style: samples: comply with MISRA C:2012 Rule 15.6",
  "input": "\tfor (int i = 0; i < THREADS_NUM; i++)\n\tfor (int i = 0; i < QUEUE_NUM; i++)\n\tif (set_sampling_freq(dev) != 0)",
  "result": "-\tfor (int i = 0; i < THREADS_NUM; i++)\n+\tfor (int i = 0; i < THREADS_NUM; i++) {\n+\t}\n-\tfor (int i = 0; i < QUEUE_NUM; i++)\n+\tfor (int i = 0; i < QUEUE_NUM; i++) {\n+\t}\n-\tif (set_sampling_freq(dev) != 0)\n+\tif (set_sampling_freq(dev) != 0) {\n+\t}"
},{
  "instruction": "style: lib: comply with MISRA C:2012 Rule 15.6",
  "input": "\twhile (heap_size * 2 <= HEAP_SIZE)\n\t\tif (POINTER_TO_UINT(heap_base) + heap_size <= HEAP_BASE + HEAP_SIZE)\n\t\t\t\tif (ret < 0)\n\t\t\tif (ret < 0)\n\tif (*options == '+')\n\telse if (*options == '-')",
  "result": "-\twhile (heap_size * 2 <= HEAP_SIZE)\n+\twhile (heap_size * 2 <= HEAP_SIZE) {\n+\t}\n-\t\tif (POINTER_TO_UINT(heap_base) + heap_size <= HEAP_BASE + HEAP_SIZE)\n+\t\tif (POINTER_TO_UINT(heap_base) + heap_size <= HEAP_BASE + HEAP_SIZE) {\n+\t\t}\n-\t\t\t\tif (ret < 0)\n+\t\t\t\tif (ret < 0) {\n+\t\t\t\t}\n-\t\t\tif (ret < 0)\n+\t\t\tif (ret < 0) {\n+\t\t\t}\n-\tif (*options == '+')\n+\tif (*options == '+') {\n-\telse if (*options == '-')\n+\t} else if (*options == '-') {\n+\t}"
},{
  "instruction": "style: kernel: comply with MISRA C:2012 Rule 15.6",
  "input": "\t\tif (thread->base.cpu == cpu)",
  "result": "-\t\tif (thread->base.cpu == cpu)\n+\t\tif (thread->base.cpu == cpu) {\n+\t\t}"
},{
  "instruction": "style: boards: comply with MISRA C:2012 Rule 15.6",
  "input": "\tif (ret < 0)",
  "result": "-\tif (ret < 0)\n+\tif (ret < 0) {\n+\t}"
},{
  "instruction": "net: mdns_responder: Set socket of service for statistics purposes",
  "input": "",
  "result": "+\t/* Mark the fd so that \"net sockets\" can show it. This is needed if there\n+\t * is already a socket bound to same port and the dispatcher will mux\n+\t * the connections. Without this, the FD in \"net sockets\" services list will\n+\t * show the socket descriptor value as -1.\n+\t */\n+\tsvc->pev[0].event.fd = ctx->sock;\n+"
},{
  "instruction": "doc: sphinx-lint: fix missing-underscore-after-hyperlink",
  "input": "     - Functionality provided by `MCUboot <https://github.com/zephyrproject-rtos/mcuboot>`. Also see :ref:`Device Firwmware Upgrade  <dfu>`\n     - Functionality provided by `MCUboot <https://github.com/zephyrproject-rtos/mcuboot>`. Also see :ref:`Security Overview  <west-sign>`",
  "result": "-      - Functionality provided by `MCUboot <https://github.com/zephyrproject-rtos/mcuboot>`. Also see :ref:`Device Firwmware Upgrade  <dfu>`\n+      - Functionality provided by `MCUboot <https://github.com/zephyrproject-rtos/mcuboot>`_.\n+        Also see :ref:`Device Firwmware Upgrade  <dfu>`.\n-      - Functionality provided by `MCUboot <https://github.com/zephyrproject-rtos/mcuboot>`. Also see :ref:`Security Overview  <west-sign>`\n+      - Functionality provided by `MCUboot <https://github.com/zephyrproject-rtos/mcuboot>`_.\n+        Also see :ref:`Security Overview  <west-sign>`."
},{
  "instruction": "doc: sphinx-lint: fix unbalanced-inline-literals-delimiters",
  "input": "We recommend using a __``Debian 9.x (Stretch)``__ or recent __``Ubuntu``__\nas their usage information, use ``--context`` (or``-H``)::\n     logging the call at Verbosity.DBG_MORE`` level.\nEach test harness is defined by a ``struct bst_test_instance` structure, that",
  "result": "-We recommend using a __``Debian 9.x (Stretch)``__ or recent __``Ubuntu``__\n+We recommend using a Debian 9.x (Stretch) or recent Ubuntu\n-as their usage information, use ``--context`` (or``-H``)::\n+as their usage information, use ``--context`` (or ``-H``)::\n-      logging the call at Verbosity.DBG_MORE`` level.\n+      logging the call at ``Verbosity.DBG_MORE`` level.\n-Each test harness is defined by a ``struct bst_test_instance` structure, that\n+Each test harness is defined by a ``struct bst_test_instance`` structure, that"
},{
  "instruction": "doc: sphinx-lint: fix missing-space-before-role",
  "input": "File suffix support through the makevar:`FILE_SUFFIX` is supported in sysbuild\nSupport for an SCA tool is implemented in a file:`sca.cmake` file.\nThe file:`sca.cmake` must be placed under file:`<SCA_ROOT>/cmake/sca/<tool>/sca.cmake`.",
  "result": "-File suffix support through the makevar:`FILE_SUFFIX` is supported in sysbuild\n+File suffix support through the :makevar:`FILE_SUFFIX` is supported in sysbuild\n-Support for an SCA tool is implemented in a file:`sca.cmake` file.\n-The file:`sca.cmake` must be placed under file:`<SCA_ROOT>/cmake/sca/<tool>/sca.cmake`.\n+Support for an SCA tool is implemented in a :file:`sca.cmake` file.\n+The :file:`sca.cmake` must be placed under :file:`{SCA_ROOT}/cmake/sca/{tool}/sca.cmake`."
},{
  "instruction": "doc: sphinx-lint: fix role-without-backticks",
  "input": "Here,take :ref:'dining-philosophers-sample' as an example for normal",
  "result": "-Here,take :ref:'dining-philosophers-sample' as an example for normal\n+Here,take :ref:`dining-philosophers-sample` as an example for normal"
},{
  "instruction": "doc: sphinx-lint: fix missing-colon-in-role",
  "input": ":c:struct`mgmt_callback` structure. Handlers are called in the order that they\n:kconfig:option`CONFIG_RTIO_WORKQ_POOL_ITEMS`.",
  "result": "-:c:struct`mgmt_callback` structure. Handlers are called in the order that they\n+:c:struct:`mgmt_callback` structure. Handlers are called in the order that they\n-:kconfig:option`CONFIG_RTIO_WORKQ_POOL_ITEMS`.\n+:kconfig:option:`CONFIG_RTIO_WORKQ_POOL_ITEMS`."
},{
  "instruction": "boards: imx93_evk_mimx9352_a55: enable pcal6524 gpio expander",
  "input": "",
  "result": "+\n+\tgpio_exp1: pcal6524@22 {\n+\t\tcompatible = \"nxp,pcal6524\";\n+\t\treg = <0x22>;\n+\t\tgpio-controller;\n+\t\t#gpio-cells = <2>;\n+\t\tngpios = <24>;\n+\t\tint-gpios = <&gpio3 27 (GPIO_ACTIVE_LOW|GPIO_PULL_UP)>;\n+\t\tstatus = \"okay\";\n+\t};"
},{
  "instruction": "west.yml: hal_nxp: update to the latest",
  "input": "     revision: 338aec96ae7eace2db263a365ab3fae9bddc48aa",
  "result": "-      revision: 338aec96ae7eace2db263a365ab3fae9bddc48aa\n+      revision: 30bdef6d5a304abfa95cc19af4d3ba699aac456e"
},{
  "instruction": "test: kernel/common: custom MAX_THREAD_BYTES for imx95 SMP",
  "input": "",
  "result": "+#\n+# Copyright 2024 NXP\n+#\n+# SPDX-License-Identifier: Apache-2.0\n+\n+CONFIG_MAX_THREAD_BYTES=5"
},{
  "instruction": "test: kernel/sem/sem: custom MAX_THREAD_BYTES for imx95 SMP",
  "input": "",
  "result": "+#\n+# Copyright 2024 NXP\n+#\n+# SPDX-License-Identifier: Apache-2.0\n+\n+CONFIG_MAX_THREAD_BYTES=5"
},{
  "instruction": "test: kernel/sem/sys_sem: custom MAX_THREAD_BYTES for imx95 SMP",
  "input": "",
  "result": "+#\n+# Copyright 2024 NXP\n+#\n+# SPDX-License-Identifier: Apache-2.0\n+\n+CONFIG_MAX_THREAD_BYTES=5"
},{
  "instruction": "drivers: mbox: make mbox_nxp_imx_mu use PRE_KERNEL_1 init level",
  "input": "\t\t\t      &nxp_imx_mu_##idx##_config, POST_KERNEL, CONFIG_MBOX_INIT_PRIORITY,  \\",
  "result": "-\t\t\t      &nxp_imx_mu_##idx##_config, POST_KERNEL, CONFIG_MBOX_INIT_PRIORITY,  \\\n+\t\t\t      &nxp_imx_mu_##idx##_config, PRE_KERNEL_1, CONFIG_MBOX_INIT_PRIORITY, \\"
},{
  "instruction": "drivers: timer: grtc: Switch GRTC clock source to LFXO",
  "input": "#if NRF_GRTC_HAS_CLKSEL\n\t/* Use System LFCLK as the low-frequency clock source. */",
  "result": "-#if NRF_GRTC_HAS_CLKSEL\n+#if DT_NODE_HAS_STATUS(DT_NODELABEL(lfxo), okay) && NRF_GRTC_HAS_CLKSEL\n-\t/* Use System LFCLK as the low-frequency clock source. */\n+\t/* Use System LFCLK as the low-frequency clock source during initialization. */\n+#if defined(CONFIG_NRF_GRTC_TIMER_CLOCK_MANAGEMENT) &&                                             \\\n+\tDT_NODE_HAS_STATUS(DT_NODELABEL(lfxo), okay) && NRF_GRTC_HAS_CLKSEL\n+\t/* Switch to LFXO as the low-frequency clock source. */\n+\tnrfx_grtc_clock_source_set(NRF_GRTC_CLKSEL_LFXO);\n+#endif\n+"
},{
  "instruction": "devicetree: add `DT_INST_NUM_IRQS()`",
  "input": "",
  "result": "+/**\n+ * @brief Get a `DT_DRV_COMPAT`'s number of interrupts\n+ *\n+ * @param inst instance number\n+ * @return number of interrupts\n+ */\n+#define DT_INST_NUM_IRQS(inst) DT_NUM_IRQS(DT_DRV_INST(inst))\n+\n+\t/* DT_INST_NUM_IRQS */\n+\tzassert_equal(DT_INST_NUM_IRQS(0), 3);\n+"
},{
  "instruction": "modules: lvgl: provide alignment definition",
  "input": "",
  "result": "+#include <zephyr/toolchain.h>\n+\n+/* Provide definition to align LVGL buffers */\n+#define LV_ATTRIBUTE_MEM_ALIGN __aligned(CONFIG_LV_ATTRIBUTE_MEM_ALIGN_SIZE)\n+"
},{
  "instruction": "net: http_server: Enable v4-to-v6 mapping by default",
  "input": "",
  "result": "+\timply NET_IPV4_MAPPING_TO_IPV6 if NET_IPV4 && NET_IPV6"
},{
  "instruction": "net: if: Fix rejoining IPv6 multicast group",
  "input": "\t\t    net_if_ipv4_maddr_is_joined(&ipv6->mcast[i])) {",
  "result": "-\t\t    net_if_ipv4_maddr_is_joined(&ipv6->mcast[i])) {\n+\t\t    net_if_ipv6_maddr_is_joined(&ipv6->mcast[i])) {\n+\t\t} else {\n+\t\t\tNET_DBG(\"Rejoined mcast address %s for %d\",\n+\t\t\t\tnet_sprint_ipv6_addr(&ipv6->mcast[i].address.in6_addr),\n+\t\t\t\tnet_if_get_by_iface(iface));"
},{
  "instruction": "soc: esp32c2: esp8684: Console baudrate from device tree",
  "input": "board_runner_args(esp32 \"--esp-monitor-baud=74880\")",
  "result": "+# get UART baudrate from DT\n+dt_chosen(dts_shell_uart PROPERTY \"zephyr,shell-uart\")\n+dt_prop(monitor_baud PATH ${dts_shell_uart} PROPERTY \"current-speed\")\n+\n-board_runner_args(esp32 \"--esp-monitor-baud=74880\")\n+board_runner_args(esp32 \"--esp-monitor-baud=${monitor_baud}\")"
},{
  "instruction": "rtio: Disable xtensa dc233c",
  "input": " platform_exclude: m2gl025_miv m5stack_core2 hifive1",
  "result": "-  platform_exclude: m2gl025_miv m5stack_core2 hifive1\n+  # xtensa dc233 (with mmu) has a TLB exception for unclear reasons\n+  platform_exclude: m2gl025_miv m5stack_core2 hifive1 qemu_xtensa_dc233c"
},{
  "instruction": "rtio: Fix dc233c tlb exception",
  "input": "\tres = rtio_submit(r, 0);\n\tzassert_ok(res, \"Should return ok from rtio_execute\");\n\tzassert_equal(1, rtio_cqe_copy_out(r, &cqe, 1, K_FOREVER));",
  "result": "-\tres = rtio_submit(r, 0);\n-\tzassert_ok(res, \"Should return ok from rtio_execute\");\n+\tres = rtio_submit(r, 1);\n+\tzassert_ok(res, \"Should return ok from rtio_submit\");\n-\tzassert_equal(1, rtio_cqe_copy_out(r, &cqe, 1, K_FOREVER));\n+\tres = rtio_cqe_copy_out(r, &cqe, 1, K_FOREVER);\n+\tzassert_equal(1, res);"
},{
  "instruction": "drivers: flash: support flash driver for MCXA156",
  "input": "",
  "result": "+#elif defined(CONFIG_SOC_MCXA156)\n+#include \"fsl_romapi.h\"\n+#define FLASH_Erase   FLASH_EraseSector\n+#define FLASH_Program FLASH_ProgramPhrase"
},{
  "instruction": "drivers: gpio_mcux: update gpio_mcux driver for MCXA156",
  "input": "",
  "result": "+#else\n+\tint_status = 0U;\n+\tARG_UNUSED(config);"
},{
  "instruction": "include: pinctrl: Support MCXA in pinctrl_soc_kinetis_common.h",
  "input": "\t PORT_PCR_SRE_MASK | PORT_PCR_PE_MASK | PORT_PCR_PS_MASK)",
  "result": "+#if !(defined(CONFIG_SOC_SERIES_MCXA))\n+#define PORT_PCR_IBE(x)   0x0\n+#define PORT_PCR_IBE_MASK 0x0\n+#endif\n+\n+\t PORT_PCR_IBE(DT_PROP(node_id, input_enable)) |                                            \\\n-\t PORT_PCR_SRE_MASK | PORT_PCR_PE_MASK | PORT_PCR_PS_MASK)\n+\t PORT_PCR_IBE_MASK | PORT_PCR_SRE_MASK | PORT_PCR_PE_MASK | PORT_PCR_PS_MASK)"
},{
  "instruction": "manifest: update HAL NXP manifest",
  "input": "     revision: f90b09dea9a7f61e901afa6ce691e687900f5598",
  "result": "-      revision: f90b09dea9a7f61e901afa6ce691e687900f5598\n+      revision: 338aec96ae7eace2db263a365ab3fae9bddc48aa"
},{
  "instruction": "tests: drivers: dma: Enable for board sim3u1xx_dk",
  "input": "",
  "result": "+/*\n+ * Copyright (c) 2024 GARDENA GmbH\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+tst_dma0: &dma {\n+\tstatus = \"okay\";\n+};\n+CONFIG_DMA_LOOP_TRANSFER_CHANNEL_NR=0\n+CONFIG_DMA_LOOP_TRANSFER_SIZE=1024\n+/*\n+ * Copyright (c) 2024 GARDENA GmbH\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+tst_dma0: &dma {\n+\tstatus = \"okay\";\n+};"
},{
  "instruction": "boards: silabs: sim3u1xx_dk: Declare DMA support",
  "input": "",
  "result": "+| DMA       | on-chip    | dma                                 |\n+  - dma"
},{
  "instruction": "dts: arm: silabs: sim3u: Add DMA support node",
  "input": "",
  "result": "+\t\tdma: dma-controller@40036000 {\n+\t\t\tcompatible = \"silabs,si32-dma\";\n+\t\t\treg = <0x40036000 0x1000>;\n+\t\t\tinterrupts = <4 0>, <5 0>, <6 0>, <7 0>,\n+\t\t\t\t     <8 0>, <9 0>, <10 0>, <11 0>,\n+\t\t\t\t     <12 0>, <13 0>, <14 0>, <15 0>,\n+\t\t\t\t     <16 0>, <17 0>, <18 0>, <19 0>;\n+\t\t\tdma-channels = <16>;\n+\t\t\t#dma-cells = <3>;\n+\t\t\tstatus = \"disabled\";\n+\t\t};\n+"
},{
  "instruction": "boards: teensy4: Fix pinmux settings for LPSPI3",
  "input": "| 26  | AD_B1_14   | GPIO1_30                            |\n| 27  | AD_B1_15   | GPIO1_31                            |\n| 38  | AD_B1_12   | GPIO1_28                            |\n| 39  | AD_B1_13   | GPIO1_29                            |\n\t\t\t\t<&iomuxc_gpio_ad_b0_00_lpspi3_sck>,\n\t\t\t\t<&iomuxc_gpio_ad_b0_02_lpspi3_sdi>,\n\t\t\t\t<&iomuxc_gpio_ad_b0_01_lpspi3_sdo>;",
  "result": "-| 26  | AD_B1_14   | GPIO1_30                            |\n+| 26  | AD_B1_14   | GPIO1_30 / SPI3_MOSI                |\n-| 27  | AD_B1_15   | GPIO1_31                            |\n+| 27  | AD_B1_15   | GPIO1_31 / SPI3_SCK                 |\n-| 38  | AD_B1_12   | GPIO1_28                            |\n+| 38  | AD_B1_12   | GPIO1_28 / SPI3_CS                  |\n-| 39  | AD_B1_13   | GPIO1_29                            |\n+| 39  | AD_B1_13   | GPIO1_29 / SPI3_MISO                |\n-\t\t\t\t<&iomuxc_gpio_ad_b0_00_lpspi3_sck>,\n-\t\t\t\t<&iomuxc_gpio_ad_b0_02_lpspi3_sdi>,\n-\t\t\t\t<&iomuxc_gpio_ad_b0_01_lpspi3_sdo>;\n+\t\t\t\t<&iomuxc_gpio_ad_b1_15_lpspi3_sck>,\n+\t\t\t\t<&iomuxc_gpio_ad_b1_13_lpspi3_sdi>,\n+\t\t\t\t<&iomuxc_gpio_ad_b1_14_lpspi3_sdo>;"
},{
  "instruction": "tests: net: cm: Increase event wait time",
  "input": "#define EVENT_WAIT_TIME K_MSEC(1)",
  "result": "-#define EVENT_WAIT_TIME K_MSEC(1)\n+#define EVENT_WAIT_TIME K_MSEC(10)"
},{
  "instruction": "samples: usb/mass: fix board name for adafruit_feather_nrf52840_sense",
  "input": "     - adafruit_feather_nrf52840_sense\n     - adafruit_feather_nrf52840_sense\n     - adafruit_feather_nrf52840_sense",
  "result": "-      - adafruit_feather_nrf52840_sense\n+      - adafruit_feather_nrf52840/nrf52840/sense\n-      - adafruit_feather_nrf52840_sense\n+      - adafruit_feather_nrf52840/nrf52840/sense\n-      - adafruit_feather_nrf52840_sense\n+      - adafruit_feather_nrf52840/nrf52840/sense"
},{
  "instruction": "soc: imxrt: Fix flexspi xip configuration issue",
  "input": "\tdefault y if FLASH_MCUX_FLEXSPI_XIP && MEMC_MCUX_FLEXSPI\n\tdepends on MEMC_MCUX_FLEXSPI && FLASH_MCUX_FLEXSPI_XIP\nconfig CODE_DATA_RELOCATION_SRAM\n\tdefault n\n#\n# Copyright (c) 2021 NXP.\n# SPDX-License-Identifier: Apache-2.0\n#\nCONFIG_FLASH_MCUX_FLEXSPI_XIP_MEM=\"RAM\"",
  "result": "+if FLASH_MCUX_FLEXSPI_XIP && MEMC_MCUX_FLEXSPI\n+\n-\tdefault y if FLASH_MCUX_FLEXSPI_XIP && MEMC_MCUX_FLEXSPI\n+\tdefault y if !CPU_CORTEX_M7\n+\n+config CODE_DATA_RELOCATION\n+\tdefault y if CPU_CORTEX_M7\n-\tdepends on MEMC_MCUX_FLEXSPI && FLASH_MCUX_FLEXSPI_XIP\n+\n+endif\n-config CODE_DATA_RELOCATION_SRAM\n-\tdefault n\n-\n-#\n-# Copyright (c) 2021 NXP.\n-# SPDX-License-Identifier: Apache-2.0\n-#\n-\n-CONFIG_FLASH_MCUX_FLEXSPI_XIP_MEM=\"RAM\""
},{
  "instruction": "charger: bq25180: set a default constant-charge-voltage-max-microvolt",
  "input": "   required: true",
  "result": "-    required: true\n+    type: int\n+    default: 4200000\n+    description: |\n+      The maximum voltage that the battery will be charged at, defaults to\n+      4.2V, matching the device default reset configuration."
},{
  "instruction": "tests: usb: uac2: Add speed properties to UAC2 instances",
  "input": "",
  "result": "+\t\tfull-speed;\n+\t\tfull-speed;"
},{
  "instruction": "samples: usb: uac2: Add full-speed instance property",
  "input": "",
  "result": "+\t\tfull-speed;\n+\t\tfull-speed;"
},{
  "instruction": "boards: adafruit feather nrf52840 remove bossac",
  "input": "# enable bossac\nCONFIG_BOOTLOADER_BOSSA=y\nCONFIG_BOOTLOADER_BOSSA_ADAFRUIT_UF2=y",
  "result": "-# enable bossac\n-CONFIG_BOOTLOADER_BOSSA=y\n-CONFIG_BOOTLOADER_BOSSA_ADAFRUIT_UF2=y\n-"
},{
  "instruction": "manifest: hal_adi: Update to fix SPI build errors when DMA is enabled",
  "input": "     revision: a9ea9646a354bddf678c3ea5e4748ed1e38da542",
  "result": "-      revision: a9ea9646a354bddf678c3ea5e4748ed1e38da542\n+      revision: de5dadb5322c5da9647363a0d081aa002d4b796f"
},{
  "instruction": "modules: hal_nordic: nrfx: Add nrfx_config_ext.h",
  "input": "   #error \"Unknown device.\"",
  "result": "-    #error \"Unknown device.\"\n+    #include <nrfx_config_ext.h>\n+/*\n+ * Copyright (c) 2023 - 2024, Nordic Semiconductor ASA\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+#ifndef NRFX_CONFIG_EXT_H__\n+#define NRFX_CONFIG_EXT_H__\n+\n+#error \"Unknown device.\"\n+\n+#endif /* NRFX_CONFIG_EXT_H__ */"
},{
  "instruction": "sensor: bme680: only read compensation params once",
  "input": "",
  "result": "+\tif (data->has_read_compensation) {\n+\t\treturn 0;\n+\t}\n+\n+\tdata->has_read_compensation = true;\n+\tbool has_read_compensation;"
},{
  "instruction": "samples: net: wifi: add missing config for rd_rw612_bga board",
  "input": "CONFIG_POSIX_MAX_FDS=30\nCONFIG_ZVFS_OPEN_MAX=20\nCONFIG_NET_MGMT_EVENT_STACK_SIZE=2048\nCONFIG_COMMON_LIBC_MALLOC_ARENA_SIZE=60000",
  "result": "-CONFIG_POSIX_MAX_FDS=30\n-CONFIG_ZVFS_OPEN_MAX=20\n+CONFIG_ZVFS_OPEN_MAX=30\n+CONFIG_WIFI_MGMT_AP_MAX_NUM_STA=8\n+CONFIG_NET_L2_ETHERNET=y\n+CONFIG_NET_DHCPV4_SERVER_ADDR_COUNT=32\n+CONFIG_NET_IPV4=y\n+CONFIG_NET_IPV4_FRAGMENT=y\n+CONFIG_NET_IPV6_FRAGMENT=y\n+CONFIG_NET_MAX_CONN=10\n+CONFIG_PM_DEVICE_LOG_LEVEL_OFF=y\n-CONFIG_NET_MGMT_EVENT_STACK_SIZE=2048\n+CONFIG_NET_MGMT_EVENT_STACK_SIZE=4608\n-CONFIG_COMMON_LIBC_MALLOC_ARENA_SIZE=60000\n+CONFIG_COMMON_LIBC_MALLOC_ARENA_SIZE=80000"
},{
  "instruction": "drivers: wifi: nxp: update the correct Macro config.",
  "input": "#ifndef CONFIG_WIFI_NM_WPA_SUPPLICANT\n#ifndef CONFIG_WIFI_NM_WPA_SUPPLICANT\n#ifdef CONFIG_WIFI_NM_WPA_SUPPLICANT",
  "result": "-#ifndef CONFIG_WIFI_NM_WPA_SUPPLICANT\n+#ifndef CONFIG_WIFI_NM_HOSTAPD_AP\n-#ifndef CONFIG_WIFI_NM_WPA_SUPPLICANT\n+#ifndef CONFIG_WIFI_NM_HOSTAPD_AP\n-#ifdef CONFIG_WIFI_NM_WPA_SUPPLICANT\n+#ifdef CONFIG_WIFI_NM_HOSTAPD_AP"
},{
  "instruction": "drivers: display: stm32_ltdc: fix return value",
  "input": "\t\treturn 0;\n\t\treturn 0;",
  "result": "+\t/* Panel controller's phandle is not passed to LTDC in devicetree */\n-\t\treturn 0;\n+\t\tLOG_ERR(\"There is no panel controller to forward blanking_off call to\");\n+\t\treturn -ENOSYS;\n+\t/* Panel controller's phandle is not passed to LTDC in devicetree */\n-\t\treturn 0;\n+\t\tLOG_ERR(\"There is no panel controller to forward blanking_on call to\");\n+\t\treturn -ENOSYS;"
},{
  "instruction": "manifest: Update hal_nordic with nrfx changes",
  "input": "     revision: d1099d6c52fba81ed23f1ce6cb54f4387a88ccea",
  "result": "-      revision: d1099d6c52fba81ed23f1ce6cb54f4387a88ccea\n+      revision: af7b21c4f875bea26689307daa8e52e9a8e8323c"
},{
  "instruction": "tests: net: lib: lwm2m: content_link_format: Update BS discovery test",
  "input": "\tconst char *expected_payload = \"lwm2m=\\\"1.0\\\"\";",
  "result": "-\tconst char *expected_payload = \"lwm2m=\\\"1.0\\\"\";\n+\tconst char *expected_payload = \"</>;lwm2m=\\\"1.0\\\"\";"
},{
  "instruction": "net: lwm2m: Fix enabler version reporting during bootstrap discovery",
  "input": "#define ENABLER_VERSION \"lwm2m=\\\"\" LWM2M_PROTOCOL_VERSION_STRING \"\\\"\"",
  "result": "-#define ENABLER_VERSION \"lwm2m=\\\"\" LWM2M_PROTOCOL_VERSION_STRING \"\\\"\"\n+#if defined(CONFIG_LWM2M_VERSION_1_1)\n+#define ENABLER_VERSION \"</>;lwm2m=\" LWM2M_PROTOCOL_VERSION_STRING\n+#else\n+#define ENABLER_VERSION \"</>;lwm2m=\\\"\" LWM2M_PROTOCOL_VERSION_STRING \"\\\"\"\n+#endif"
},{
  "instruction": "samples: net: lwm2m_client: Remove unneeded Security object instance",
  "input": "\t/* Create 2nd instance of security object needed for bootstrap */\n\tlwm2m_create_object_inst(&LWM2M_OBJ(0, 1));",
  "result": "-\n-\t/* Create 2nd instance of security object needed for bootstrap */\n-\tlwm2m_create_object_inst(&LWM2M_OBJ(0, 1));"
},{
  "instruction": "manifest: Update nRF hw models to latest",
  "input": "     revision: 4b0b020e25dbf1a11ccccf7b7741d6ca991ba9e4",
  "result": "-      revision: 4b0b020e25dbf1a11ccccf7b7741d6ca991ba9e4\n+      revision: d2a119a9c7600ce06033a794de042e0ad9a38702"
},{
  "instruction": "MWDT: linker: fix regresion",
  "input": "set_ifndef(LINKERFLAGPREFIX -Wl,)\n   zephyr_link_libraries(${LINKERFLAGPREFIX}-u${symbol})\n   ${LINKERFLAGPREFIX}-T${TOOLCHAIN_LD_LINK_ELF_LINKER_SCRIPT}\n   ${LINKERFLAGPREFIX}--gc-sections\n   ${LINKERFLAGPREFIX}--entry=__start\n   ${LINKERFLAGPREFIX}--Map=${TOOLCHAIN_LD_LINK_ELF_OUTPUT_MAP}\n   ${LINKERFLAGPREFIX}--whole-archive\n   ${LINKERFLAGPREFIX}--no-whole-archive",
  "result": "-set_ifndef(LINKERFLAGPREFIX -Wl,)\n+set_ifndef(LINKERFLAGPREFIX -Wl)\n-    zephyr_link_libraries(${LINKERFLAGPREFIX}-u${symbol})\n+    zephyr_link_libraries(${LINKERFLAGPREFIX},-u${symbol})\n-    ${LINKERFLAGPREFIX}-T${TOOLCHAIN_LD_LINK_ELF_LINKER_SCRIPT}\n+    ${LINKERFLAGPREFIX},-T${TOOLCHAIN_LD_LINK_ELF_LINKER_SCRIPT}\n-    ${LINKERFLAGPREFIX}--gc-sections\n-    ${LINKERFLAGPREFIX}--entry=__start\n-    ${LINKERFLAGPREFIX}--Map=${TOOLCHAIN_LD_LINK_ELF_OUTPUT_MAP}\n-    ${LINKERFLAGPREFIX}--whole-archive\n+    ${LINKERFLAGPREFIX},--gc-sections\n+    ${LINKERFLAGPREFIX},--entry=__start\n+    ${LINKERFLAGPREFIX},--Map=${TOOLCHAIN_LD_LINK_ELF_OUTPUT_MAP}\n+    ${LINKERFLAGPREFIX},--whole-archive\n-    ${LINKERFLAGPREFIX}--no-whole-archive\n+    ${LINKERFLAGPREFIX},--no-whole-archive"
},{
  "instruction": "twister: fix dts path for module",
  "input": "           if soc_root:",
  "result": "-            if soc_root:\n+            if dts_root:"
},{
  "instruction": "x86: skip printing args when unwinding stack",
  "input": "typedef bool (*x86_stacktrace_cb)(void *cookie, unsigned long addr, unsigned long arg);\n#ifndef CONFIG_X86_64\n\tuintptr_t args;\n#endif\n__pinned_func static void walk_stackframe(x86_stacktrace_cb cb, void *cookie,\n\t\tif (!cb(cookie, frame->ret_addr,\n\t\t\tCOND_CODE_1(CONFIG_X86_64, (0), (frame->args)))) {\n\twalk_stackframe((x86_stacktrace_cb)callback_fn, cookie, esf,\nstatic bool print_trace_address(void *arg, unsigned long addr, unsigned long args)\n\tLOG_ERR(\"     %d: 0x%08lx (0x%lx)\", (*i)++, addr, args);\n__pinned_func\nstatic void unwind_stack(const struct arch_esf *esf)",
  "result": "-typedef bool (*x86_stacktrace_cb)(void *cookie, unsigned long addr, unsigned long arg);\n-\n-#ifndef CONFIG_X86_64\n-\tuintptr_t args;\n-#endif\n-__pinned_func static void walk_stackframe(x86_stacktrace_cb cb, void *cookie,\n+__pinned_func static void walk_stackframe(stack_trace_callback_fn cb, void *cookie,\n-\t\tif (!cb(cookie, frame->ret_addr,\n-\t\t\tCOND_CODE_1(CONFIG_X86_64, (0), (frame->args)))) {\n+\t\tif (!cb(cookie, frame->ret_addr)) {\n-\twalk_stackframe((x86_stacktrace_cb)callback_fn, cookie, esf,\n+\twalk_stackframe(callback_fn, cookie, esf,\n-static bool print_trace_address(void *arg, unsigned long addr, unsigned long args)\n+static bool print_trace_address(void *arg, unsigned long addr)\n-\tLOG_ERR(\"     %d: 0x%08lx (0x%lx)\", (*i)++, addr, args);\n+\tLOG_ERR(\"     %d: 0x%08lx\", (*i)++, addr);\n-__pinned_func\n-static void unwind_stack(const struct arch_esf *esf)\n+static ALWAYS_INLINE void unwind_stack(const struct arch_esf *esf)"
},{
  "instruction": "drivers: serial: ambiq uart update",
  "input": "static uart_register_state_t sRegState[2];",
  "result": "-static uart_register_state_t sRegState[2];\n+static uart_register_state_t sRegState[AM_REG_UART_NUM_MODULES];"
},{
  "instruction": "drivers: can_mcp251xfd: Delay initialization after reset",
  "input": "\treturn spi_write_dt(&dev_cfg->bus, &tx);",
  "result": "-\treturn spi_write_dt(&dev_cfg->bus, &tx);\n+\tret = spi_write_dt(&dev_cfg->bus, &tx);\n+\t/* Adding delay after init to fix occasional init issue. Delay time found experimentally. */\n+\tk_sleep(K_USEC(MCP251XFD_RESET_DELAY_USEC));\n+\treturn ret;\n+/* Delay time found experimentally to fix occasional init issue */\n+#define MCP251XFD_RESET_DELAY_USEC 5000"
},{
  "instruction": "bluetooth: AVDTP: Check buffer len before pulling data",
  "input": "",
  "result": "+\t\t\tif (buf->len < sizeof(sigid)) {\n+\t\t\t\tLOG_ERR(\"Invalid AVDTP Header\");\n+\t\t\t\treturn 0;\n+\t\t\t}\n+"
},{
  "instruction": "soc: nordic: Extend address validation for Haltium platform",
  "input": "#elif defined(CONFIG_SOC_NRF54H20)",
  "result": "-#elif defined(CONFIG_SOC_NRF54H20)\n+#elif defined(CONFIG_NRF_PLATFORM_HALTIUM)"
},{
  "instruction": "soc: nordic: nrf92: Update supported NRFS services",
  "input": "\tselect NRFS_HAS_DVFS_SERVICE",
  "result": "-\tselect NRFS_HAS_DVFS_SERVICE\n+\tselect NRFS_HAS_PMIC_SERVICE\n+\tselect NRFS_HAS_PMIC_SERVICE"
},{
  "instruction": "soc: nordic: nrf92: Set PPR hart ID to processor ID",
  "input": "",
  "result": "+config RV_BOOT_HART\n+\tdefault 13 if SOC_NRF9230_ENGB\n+"
},{
  "instruction": "modules: hal_nordic: Add NRFX_GPIOTE131_CHANNELS_USED mask",
  "input": "",
  "result": "+/** @brief Bitmask that defines GPIOTE131 channels reserved for use outside of the nrfx library. */\n+#define NRFX_GPIOTE131_CHANNELS_USED \\\n+\t(~NRFX_CONFIG_MASK_DT(DT_NODELABEL(gpiote131), owned_channels) | \\\n+\t NRFX_CONFIG_MASK_DT(DT_NODELABEL(gpiote131), child_owned_channels))\n+"
},{
  "instruction": "doc: css: stick footer at bottom",
  "input": "",
  "result": "+    min-height: 100vh;\n+    display: flex;\n+    .wy-nav-content {\n+        min-height: calc(100dvh - 64px);\n+    }\n+/* Make actual document take all vertical space available so that footer is always at the bottom */\n+\n+.rst-content {\n+    flex: 1;\n+    display: flex;\n+    flex-direction: column;\n+    width: 100%;\n+}\n+\n+.document {\n+    flex-grow: 1;\n+}\n+"
},{
  "instruction": "doc: css: drop Breathe rules",
  "input": "/* Breathe tweaks */\n.rst-content .section > dl > dd {\n   margin-left: 0;\n}\n.rst-content p.breathe-sectiondef-title {\n   font-size: 115%;\n   color: var(--link-color);\n}\n.rst-content dl:not(.docutils) dl:not(.rst-other-versions) dt {\n   background: var(--admonition-note-background-color) !important;\n   border-top: none !important;\n   border-left: none !important;\n}",
  "result": "-/* Breathe tweaks */\n-\n-.rst-content .section > dl > dd {\n-    margin-left: 0;\n-}\n-\n-.rst-content p.breathe-sectiondef-title {\n-    font-size: 115%;\n-    color: var(--link-color);\n-}\n-\n-.rst-content dl:not(.docutils) dl:not(.rst-other-versions) dt {\n-    background: var(--admonition-note-background-color) !important;\n-    border-top: none !important;\n-    border-left: none !important;\n-}\n-"
},{
  "instruction": "soc: nrf: Update systemoff sequence for nRF54L15",
  "input": "",
  "result": "+#if defined(CONFIG_SOC_SERIES_NRF54LX)\n+#include <helpers/nrfx_reset_reason.h>\n+#endif\n+#if defined(CONFIG_SOC_SERIES_NRF54LX)\n+\tnrfx_reset_reason_clear(UINT32_MAX);\n+#endif"
},{
  "instruction": "doc: _extensions: :zephyr-app:'s should be valid paths",
  "input": "",
  "result": "+from pathlib import Path\n+ZEPHYR_BASE = Path(__file__).parents[3]\n+\n+        if zephyr_app:\n+            # as folks might use \"<...>\" notation to indicate a variable portion of the path, we\n+            # deliberately don't check for the validity of such paths.\n+            if not any([x in zephyr_app for x in [\"<\", \">\"]]):\n+                app_path = ZEPHYR_BASE / zephyr_app\n+                if not app_path.is_dir():\n+                    raise self.error(\n+                        f\"zephyr-app: {zephyr_app} is not a valid folder in the zephyr tree.\"\n+                    )\n+\n-"
},{
  "instruction": "maintainers: add kartben as Documentation Infrastructure maintainer",
  "input": "   - kartben",
  "result": "+    - kartben\n-    - kartben"
},{
  "instruction": "boards: move stm32f103_mini to others",
  "input": "",
  "result": ""
},{
  "instruction": "doc: releases: migration-guide-4.0: note about stm32 boards flashing",
  "input": "",
  "result": "+STM32\n+=====\n+\n+* On all official STM32 boards, `west flash` selects STM32CubeProgrammer as the default west runner.\n+  If you want to enforce the selection of another runner like OpenOCD or pyOCD for flashing, you should\n+  specify it using the west `--runner` or `-r` option. (:github:`75284`)\n+"
},{
  "instruction": "flash: nrf_qspi_nor: wait for erase to complete",
  "input": "static int qspi_wait_while_writing(const struct device *dev)\n\t\trc = qspi_wait_while_writing(dev);",
  "result": "-static int qspi_wait_while_writing(const struct device *dev)\n+static int qspi_wait_while_writing(const struct device *dev, k_timeout_t poll_period)\n+\t\tk_sleep(poll_period);\n-\t\trc = qspi_wait_while_writing(dev);\n+\t\trc = qspi_wait_while_writing(dev, K_NO_WAIT);\n+\n+\t\t\t/* Erasing flash pages takes a significant period of time and the\n+\t\t\t * flash memory is unavailable to perform additional operations\n+\t\t\t * until done.\n+\t\t\t */\n+\t\t\trc = qspi_wait_while_writing(dev, K_MSEC(10));\n+\t\t\tif (rc < 0) {\n+\t\t\t\tLOG_ERR(\"wait error at 0x%lx size %zu\", (long)addr, size);\n+\t\t\t\tbreak;\n+\t\t\t}"
},{
  "instruction": "usb: cdc_acm: Fix tx false data drop logging",
  "input": "\t\tLOG_WRN(\"Device not configured or suspended, drop %d bytes\",\n\t\t\tlen);\n\tif (wrote < len) {\n\t\tLOG_WRN(\"Ring buffer full, drop %zd bytes\", len - wrote);\n\t}",
  "result": "-\t\tLOG_WRN(\"Device not configured or suspended, drop %d bytes\",\n-\t\t\tlen);\n+\t\tLOG_INF(\"Device suspended or not configured\");\n-\tif (wrote < len) {\n-\t\tLOG_WRN(\"Ring buffer full, drop %zd bytes\", len - wrote);\n-\t}\n+\tLOG_DBG(\"Wrote %zu of %d bytes to TX ringbuffer\", wrote, len);"
},{
  "instruction": "arch: riscv: fatal: make `cause_str` reusable",
  "input": "static char *cause_str(unsigned long cause)\n\tLOG_ERR(\" mcause: %ld, %s\", mcause, cause_str(mcause));",
  "result": "-static char *cause_str(unsigned long cause)\n+const char *z_riscv_mcause_str(unsigned long cause)\n-\tLOG_ERR(\" mcause: %ld, %s\", mcause, cause_str(mcause));\n+\tLOG_ERR(\" mcause: %ld, %s\", mcause, z_riscv_mcause_str(mcause));"
},{
  "instruction": "Bluetooth: HCI: Add definition for Bluetooth 6.0",
  "input": "",
  "result": "+#define BT_HCI_VERSION_6_0                      14"
},{
  "instruction": "Bluetooth: Host: Add decoding for Bluetooth HCI version 6.0",
  "input": "\t\t\"5.0\", \"5.1\", \"5.2\", \"5.3\", \"5.4\"",
  "result": "-\t\t\"5.0\", \"5.1\", \"5.2\", \"5.3\", \"5.4\"\n+\t\t\"5.0\", \"5.1\", \"5.2\", \"5.3\", \"5.4\", \"6.0\""
},{
  "instruction": "Bluetooth: shell: Use common HCI version decode function",
  "input": "static const char *ver_str(uint8_t ver)\n{\n\tconst char * const str[] = {\n\t\t\"1.0b\", \"1.1\", \"1.2\", \"2.0\", \"2.1\", \"3.0\", \"4.0\", \"4.1\", \"4.2\",\n\t\t\"5.0\", \"5.1\", \"5.2\", \"5.3\", \"5.4\"\n\t};\n\tif (ver < ARRAY_SIZE(str)) {\n\t\treturn str[ver];\n\t}\n\treturn \"unknown\";\n}\n\t\t\t    \"manufacturer 0x%04x\", ver_str(remote_info->version),",
  "result": "-static const char *ver_str(uint8_t ver)\n-{\n-\tconst char * const str[] = {\n-\t\t\"1.0b\", \"1.1\", \"1.2\", \"2.0\", \"2.1\", \"3.0\", \"4.0\", \"4.1\", \"4.2\",\n-\t\t\"5.0\", \"5.1\", \"5.2\", \"5.3\", \"5.4\"\n-\t};\n-\n-\tif (ver < ARRAY_SIZE(str)) {\n-\t\treturn str[ver];\n-\t}\n-\n-\treturn \"unknown\";\n-}\n-\n-\t\t\t    \"manufacturer 0x%04x\", ver_str(remote_info->version),\n+\t\t\t    \"manufacturer 0x%04x\", bt_hci_get_ver_str(remote_info->version),"
},{
  "instruction": "scripts: ci: check_compliance: Add MCUboot Kconfig",
  "input": "",
  "result": "+        \"BOOT_MAX_IMG_SECTORS_AUTO\", # Used in sysbuild"
},{
  "instruction": "tests: boot: mcuboot_data_sharing: Fix test",
  "input": "#define FLASH_RESERVED_SECTORS 1",
  "result": "-#define FLASH_RESERVED_SECTORS 1\n+#define FLASH_RESERVED_SECTORS 2\n+CONFIG_BOOT_MAX_IMG_SECTORS_AUTO=n"
},{
  "instruction": "arch: arm: select PLATFORM_RESET_HOOK if is PLATFORM_SPECIFIC_INIT set",
  "input": "\tselect SOC_RESET_HOOK",
  "result": "+\tdefault y if SOC_RESET_HOOK\n-\tselect SOC_RESET_HOOK"
},{
  "instruction": "docs: release notes: Mention GNSS periodic config APIs removed",
  "input": "* The u-blox M10 driver has been renamed to M8 as it only supports M8 based devices.\n  Existing devicetree compatibles should be updated to :dtcompatible:`u-blox,m8`, and Kconfig\n  symbols swapped to :kconfig:option:`CONFIG_GNSS_U_BLOX_M8`.",
  "result": "- * The u-blox M10 driver has been renamed to M8 as it only supports M8 based devices.\n-   Existing devicetree compatibles should be updated to :dtcompatible:`u-blox,m8`, and Kconfig\n-   symbols swapped to :kconfig:option:`CONFIG_GNSS_U_BLOX_M8`.\n+* The u-blox M10 driver has been renamed to M8 as it only supports M8 based devices.\n+  Existing devicetree compatibles should be updated to :dtcompatible:`u-blox,m8`, and Kconfig\n+  symbols swapped to :kconfig:option:`CONFIG_GNSS_U_BLOX_M8`.\n+\n+* The APIs :c:func:`gnss_set_periodic_config` and :c:func:`gnss_get_periodic_config` have\n+  been removed. (:github:`76392`)"
},{
  "instruction": "drivers: usb: udc_dwc2: Notify upper layer on failed TX",
  "input": "\t\tif (dwc2_tx_fifo_write(dev, cfg, buf)) {\n\t\t\tLOG_ERR(\"Failed to start write to TX FIFO, ep 0x%02x\",\n\t\t\t\tcfg->addr);",
  "result": "-\t\tif (dwc2_tx_fifo_write(dev, cfg, buf)) {\n-\t\t\tLOG_ERR(\"Failed to start write to TX FIFO, ep 0x%02x\",\n-\t\t\t\tcfg->addr);\n+\t\tint err = dwc2_tx_fifo_write(dev, cfg, buf);\n+\n+\t\tif (err) {\n+\t\t\tLOG_ERR(\"Failed to start write to TX FIFO, ep 0x%02x (err: %d)\",\n+\t\t\t\tcfg->addr, err);\n+\n+\t\t\tbuf = udc_buf_get(dev, cfg->addr);\n+\t\t\tif (udc_submit_ep_event(dev, buf, -ECONNREFUSED)) {\n+\t\t\t\tLOG_ERR(\"Failed to submit endpoint event\");\n+\t\t\t};\n+\n+\t\t\treturn;"
},{
  "instruction": "net: dhcpv6: Do not wait forever when allocating net_pkt",
  "input": "\t\t\t\t\tIPPROTO_UDP, K_FOREVER);",
  "result": "+#define PKT_WAIT_TIME K_MSEC(100)\n+\n-\t\t\t\t\tIPPROTO_UDP, K_FOREVER);\n+\t\t\t\t\tIPPROTO_UDP, PKT_WAIT_TIME);"
},{
  "instruction": "net: dhcpv4: Do not wait forever when allocating net_pkt",
  "input": "#define PKT_WAIT_TIME K_SECONDS(1)\n\t\t\t\t\tIPPROTO_UDP, K_FOREVER);",
  "result": "-#define PKT_WAIT_TIME K_SECONDS(1)\n+#define PKT_WAIT_TIME K_MSEC(100)\n-\t\t\t\t\tIPPROTO_UDP, K_FOREVER);\n+\t\t\t\t\tIPPROTO_UDP, PKT_WAIT_TIME);"
},{
  "instruction": "docs: don't show doc version admonition on main",
  "input": " {% else %}\n   <div class=\"wy-alert wy-alert-danger\" data-nosnippet>\n    This is the documentation for the latest (main) development branch of\n    Zephyr. If you are looking for the documentation of previous releases, use\n    the drop-down list at the bottom of the left panel and select the desired version.\n   </div>",
  "result": "-  {% else %}\n-    <div class=\"wy-alert wy-alert-danger\" data-nosnippet>\n-     This is the documentation for the latest (main) development branch of\n-     Zephyr. If you are looking for the documentation of previous releases, use\n-     the drop-down list at the bottom of the left panel and select the desired version.\n-    </div>"
},{
  "instruction": "boards: nordic: nrf54l15dk: enable HWFC",
  "input": "",
  "result": "+\thw-flow-control;\n+\thw-flow-control;"
},{
  "instruction": "doc: releases: migration-guide: 4.0: mention rename of net_buf header",
  "input": "",
  "result": "+* To facilitate use outside of the networking subsystem, the network buffer header file was renamed\n+  from :zephyr_file:`include/zephyr/net/buf.h` to :zephyr_file:`include/zephyr/net_buf.h` and the\n+  implementation moved to :zephyr_file:`lib/net_buf/`. (:github:`78009`)\n+"
},{
  "instruction": "doc: net_buf: move the network buffer documentation to services",
  "input": "Network Buffer Management\n  net_buf.rst\nNetwork Buffer\n##############",
  "result": "+    - doc/services/net_buf/\n-Network Buffer Management\n+Network Packet Management\n-   net_buf.rst\n+   net_buf/index.rst\n-Network Buffer\n-##############\n+Network Buffers\n+###############"
},{
  "instruction": "samples: sensor/mcux_lpcmp: Overlay for the QSPI variant of FRDM-MCXN947",
  "input": "",
  "result": "+/*\n+ * Copyright 2024 NXP\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+&lpcmp0 {\n+\tfunction-clock = \"CMP_CLOCK\";\n+};"
},{
  "instruction": "samples: dac: Add overlay for FRDM MCXN947 qspi variant",
  "input": "",
  "result": "+  - dac\n+/*\n+ * Copyright 2024 NXP\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+/ {\n+\n+\t/*\n+\t * Please note on the FRDM-MCXN947 board, DAC0 output signal port is J1-4.\n+\t */\n+\tzephyr,user {\n+\t\tdac = <&dac0>;\n+\t\tdac-channel-id = <0>;\n+\t\tdac-resolution = <12>;\n+\t};\n+};"
},{
  "instruction": "soc: mcx: Fix build errors when building for XIP from FlexSPI",
  "input": "if(CONFIG_FLASH_MCUX_FLEXSPI_NOR)",
  "result": "-if(CONFIG_FLASH_MCUX_FLEXSPI_NOR)\n+if(CONFIG_FLASH_MCUX_FLEXSPI_XIP OR CONFIG_FLASH_MCUX_FLEXSPI_NOR)"
},{
  "instruction": "west.yml: Update to the NXP HAL to get fixes to CACHE64 driver",
  "input": "     revision: 466000a80e6eb5bbcb691bae936ec5654a7796d4",
  "result": "-      revision: 466000a80e6eb5bbcb691bae936ec5654a7796d4\n+      revision: f90b09dea9a7f61e901afa6ce691e687900f5598"
},{
  "instruction": "net: vlan: Fix RX debug print",
  "input": "\t\t\t net_pkt_vlan_tag(pkt),\n\t\t\t net_if_get_by_iface(iface));",
  "result": "-\t\t\t net_pkt_vlan_tag(pkt),\n-\t\t\t net_if_get_by_iface(iface));\n+\t\t\t net_if_get_by_iface(iface),\n+\t\t\t net_pkt_vlan_tag(pkt));"
},{
  "instruction": "net: virtual: Pass status to caller when starting/stopping interface",
  "input": "\t\t\tvirt->start(net_if_get_device(iface));\n\t\treturn 0;\n\t\tvirt->stop(net_if_get_device(iface));\n\treturn 0;",
  "result": "+\tint ret = 0;\n-\t\t\tvirt->start(net_if_get_device(iface));\n+\t\t\tret = virt->start(net_if_get_device(iface));\n-\t\treturn 0;\n+\t\treturn ret;\n-\t\tvirt->stop(net_if_get_device(iface));\n+\t\tret = virt->stop(net_if_get_device(iface));\n-\treturn 0;\n+\treturn ret;"
},{
  "instruction": "uart: nrfx: fix config check",
  "input": "\t\tif (HW_RX_COUNTING_ENABLED(data)) {",
  "result": "-\t\tif (HW_RX_COUNTING_ENABLED(data)) {\n+\t\tif (HW_RX_COUNTING_ENABLED(config)) {"
},{
  "instruction": "arch: multilevel_irq: fix interrupt bits check",
  "input": "BUILD_ASSERT((CONFIG_NUM_2ND_LEVEL_AGGREGATORS * CONFIG_MAX_IRQ_PER_AGGREGATOR) <=\n\t\t     BIT(CONFIG_2ND_LEVEL_INTERRUPT_BITS),\n\t__ASSERT_NO_MSG(table_idx < IRQ_TABLE_SIZE);",
  "result": "-BUILD_ASSERT((CONFIG_NUM_2ND_LEVEL_AGGREGATORS * CONFIG_MAX_IRQ_PER_AGGREGATOR) <=\n-\t\t     BIT(CONFIG_2ND_LEVEL_INTERRUPT_BITS),\n+BUILD_ASSERT(CONFIG_MAX_IRQ_PER_AGGREGATOR < BIT(CONFIG_2ND_LEVEL_INTERRUPT_BITS),\n+#ifdef CONFIG_3RD_LEVEL_INTERRUPTS\n+BUILD_ASSERT(CONFIG_MAX_IRQ_PER_AGGREGATOR < BIT(CONFIG_3RD_LEVEL_INTERRUPT_BITS),\n+\t     \"L3 bits not enough to cover the number of L3 IRQs\");\n+#endif /* CONFIG_3RD_LEVEL_INTERRUPTS */\n-\t__ASSERT_NO_MSG(table_idx < IRQ_TABLE_SIZE);\n+\t__ASSERT(table_idx < IRQ_TABLE_SIZE, \"table_idx(%d) < IRQ_TABLE_SIZE(%d)\", table_idx,\n+\t\t IRQ_TABLE_SIZE);"
},{
  "instruction": "soc: qemu: riscv: update IRQ config",
  "input": "\tdefault 52\n\tdefault 1035",
  "result": "+config 2ND_LEVEL_INTERRUPT_BITS\n+\tdefault 11\n+\n-\tdefault 52\n+\tdefault 1024\n-\tdefault 1035\n+\tdefault 1036\n+      - CONFIG_MAX_IRQ_PER_AGGREGATOR=52\n+      - CONFIG_MAX_IRQ_PER_AGGREGATOR=52\n+      - CONFIG_MAX_IRQ_PER_AGGREGATOR=52"
},{
  "instruction": "drivers: wifi: esp_at: only log errors in active mode with full IPD",
  "input": "\t\t\tLOG_ERR(\"Failed to pull remote_ip\");\n\t\t\tLOG_ERR(\"Failed to pull port\");",
  "result": "-\t\t\tLOG_ERR(\"Failed to pull remote_ip\");\n+\t\t\tif (err == -EAGAIN && match_len >= MAX_IPD_LEN) {\n+\t\t\t\tLOG_ERR(\"Failed to pull remote_ip\");\n+\t\t\t\terr = -EBADMSG;\n+\t\t\t}\n-\t\t\tLOG_ERR(\"Failed to pull port\");\n+\t\t\tif (err == -EAGAIN && match_len >= MAX_IPD_LEN) {\n+\t\t\t\tLOG_ERR(\"Failed to pull port\");\n+\t\t\t\terr = -EBADMSG;\n+\t\t\t}"
},{
  "instruction": "dts: bindings: add vendor prefix of istech",
  "input": "",
  "result": "+istech\tIntegrated Solutions Technology Inc."
},{
  "instruction": "sys: atomic: Minor upates to atomic_test* function docs",
  "input": "* @brief Atomically test a bit.\n* This routine tests whether bit number @a bit of @a target is set or not.\n* @brief Atomically test and clear a bit.\n* @brief Atomically set a bit.",
  "result": "- * @brief Atomically test a bit.\n+ * @brief Atomically get and test a bit.\n- * This routine tests whether bit number @a bit of @a target is set or not.\n+ * Atomically get a value and then test whether bit number @a bit of @a target is set or not.\n- * @brief Atomically test and clear a bit.\n+ * @brief Atomically clear a bit and test it.\n- * @brief Atomically set a bit.\n+ * @brief Atomically set a bit and test it."
},{
  "instruction": "scripts: pylib: twister: Write version to testplan.json",
  "input": "       report.json_report(plan_file)\n       report.json_report(options.save_tests)",
  "result": "-        report.json_report(plan_file)\n+        report.json_report(plan_file, env.version)\n-        report.json_report(options.save_tests)\n+        report.json_report(options.save_tests, env.version)"
},{
  "instruction": "boards: nordic: nrf54h20dk: Add ETR buffer to the memory map",
  "input": "",
  "result": "+\t\tetr_buf_ram0x_region: memory@2f0be000 {\n+\t\t\tcompatible = \"nordic,owned-memory\";\n+\t\t\treg = <0x2f0be000 DT_SIZE_K(4)>;\n+\t\t\tstatus = \"disabled\";\n+\t\t\tperm-read;\n+\t\t\tperm-write;\n+\t\t\tperm-secure;\n+\t\t\t#address-cells = <1>;\n+\t\t\t#size-cells = <1>;\n+\t\t\tranges = <0x0 0x2f0be000 0x1000>;\n+\n+\t\t\t/* TODO In future move this region to cpuapp_ram0x_region. */\n+\t\t\tetr_buffer: memory@0 {\n+\t\t\t\treg = <0x0 DT_SIZE_K(4)>;\n+\t\t\t};\n+\t\t};\n+\n+&etr_buf_ram0x_region {\n+\tstatus = \"okay\";\n+};\n+"
},{
  "instruction": "soc: nordic: nrf54h: Add STM data flushing in pre_sleep",
  "input": "",
  "result": "+#ifdef CONFIG_LOG_FRONTEND_STMESP\n+#include <zephyr/logging/log_frontend_stmesp.h>\n+#endif\n+\n+#if defined(CONFIG_ARM_ON_ENTER_CPU_IDLE_HOOK)\n+bool z_arm_on_enter_cpu_idle(void)\n+{\n+#ifdef CONFIG_LOG_FRONTEND_STMESP\n+\tlog_frontend_stmesp_pre_sleep();\n+#endif\n+\n+\treturn true;\n+}\n+#endif\n+"
},{
  "instruction": "dts: nordic: nrf54h20: Add stmesp nodes",
  "input": "",
  "result": "+\n+\t\tstmesp: memory@a2000000 {\n+\t\t\tcompatible = \"arm,stmesp\";\n+\t\t\treg = <0xa2000000 0x1000000>;\n+\t\t};\n+\n+\t\tstmesp: memory@a3000000 {\n+\t\t\tcompatible = \"arm,stmesp\";\n+\t\t\treg = <0xa3000000 0x1000000>;\n+\t\t};\n+\n+\t\tstmesp: memory@ae000000 {\n+\t\t\tcompatible = \"arm,stmesp\";\n+\t\t\treg = <0xae000000 0x1000000>;\n+\t\t};"
},{
  "instruction": "dts: bindings: debug: Add binding for ARM STMESP",
  "input": "",
  "result": "+# Copyright 2024 Nordic Semiconductor ASA\n+# SPDX-License-Identifier: Apache-2.0\n+\n+# Common fields for ARM instrumentation System Trace Macrocell Extended Stimulus Port (STMESP)\n+\n+include: base.yaml"
},{
  "instruction": "logging: Move frontends to the dedicated directory",
  "input": " zephyr_sources_ifdef(\n   CONFIG_LOG_FRONTEND_DICT_UART\n   log_frontend_dict_uart.c\n )\nrsource \"Kconfig.frontends\"",
  "result": "-  zephyr_sources_ifdef(\n-    CONFIG_LOG_FRONTEND_DICT_UART\n-    log_frontend_dict_uart.c\n-  )\n-\n+  add_subdirectory(frontends)\n-rsource \"Kconfig.frontends\"\n+rsource \"frontends/Kconfig\"\n+# SPDX-License-Identifier: Apache-2.0\n+\n+zephyr_sources_ifdef(\n+  CONFIG_LOG_FRONTEND_DICT_UART\n+  log_frontend_dict_uart.c\n+)"
},{
  "instruction": "debug: mipi_stp_decoder: Align naming to 2.4 standard",
  "input": "\tSTP_DECODER_MASTER,\n\t_type == STP_DECODER_MASTER ? \"MASTER\" : (\\\n\t/** ID - used for master and channel. */\nstatic void master_cb(uint64_t id, uint64_t ts)\n\tcfg.cb(STP_DECODER_MASTER, data, NULL, false);\n\tSTP_ITEM(STP_M8, (0x1), 1, 2, false, master_cb),\n\tSTP_ITEM(STP_M16, (0xf1), 2, 4, false, master_cb),\nZTEST(mipi_stp_decoder_test, test_chunk_master)\n\tADD_ITEM(cnt, STP_DECODER_MASTER, UINT64_MAX, false, (uint8_t)0xab);\n\tADD_ITEM(cnt, STP_DECODER_MASTER, UINT64_MAX, false, (uint16_t)0x4321);\n\tADD_ITEM(cnt, STP_DECODER_MASTER, UINT64_MAX, false, (uint8_t)0xab);\n\tADD_ITEM(cnt, STP_DECODER_MASTER, UINT64_MAX, false, (uint8_t)0x0b);",
  "result": "-\tSTP_DECODER_MASTER,\n+\tSTP_DECODER_MAJOR,\n-\t_type == STP_DECODER_MASTER ? \"MASTER\" : (\\\n+\t_type == STP_DECODER_MAJOR ? \"MAJOR\" : (\\\n-\t/** ID - used for master and channel. */\n+\t/** ID - used for major and channel. */\n-static void master_cb(uint64_t id, uint64_t ts)\n+static void major_cb(uint64_t id, uint64_t ts)\n-\tcfg.cb(STP_DECODER_MASTER, data, NULL, false);\n+\tcfg.cb(STP_DECODER_MAJOR, data, NULL, false);\n-\tSTP_ITEM(STP_M8, (0x1), 1, 2, false, master_cb),\n+\tSTP_ITEM(STP_M8, (0x1), 1, 2, false, major_cb),\n-\tSTP_ITEM(STP_M16, (0xf1), 2, 4, false, master_cb),\n+\tSTP_ITEM(STP_M16, (0xf1), 2, 4, false, major_cb),\n-ZTEST(mipi_stp_decoder_test, test_chunk_master)\n+ZTEST(mipi_stp_decoder_test, test_chunk_major)\n-\tADD_ITEM(cnt, STP_DECODER_MASTER, UINT64_MAX, false, (uint8_t)0xab);\n+\tADD_ITEM(cnt, STP_DECODER_MAJOR, UINT64_MAX, false, (uint8_t)0xab);\n-\tADD_ITEM(cnt, STP_DECODER_MASTER, UINT64_MAX, false, (uint16_t)0x4321);\n+\tADD_ITEM(cnt, STP_DECODER_MAJOR, UINT64_MAX, false, (uint16_t)0x4321);\n-\tADD_ITEM(cnt, STP_DECODER_MASTER, UINT64_MAX, false, (uint8_t)0xab);\n+\tADD_ITEM(cnt, STP_DECODER_MAJOR, UINT64_MAX, false, (uint8_t)0xab);\n-\tADD_ITEM(cnt, STP_DECODER_MASTER, UINT64_MAX, false, (uint8_t)0x0b);\n+\tADD_ITEM(cnt, STP_DECODER_MAJOR, UINT64_MAX, false, (uint8_t)0x0b);"
},{
  "instruction": "logging: Fix string stripping Kconfig option dependency",
  "input": "\tdepends on LOG_DICTIONARY_SUPPORT",
  "result": "-\tdepends on LOG_DICTIONARY_SUPPORT\n+\tdepends on LOG_DICTIONARY_DB"
},{
  "instruction": "drivers: serial: uart_nrfx_uarte: Fix dropping flushed data",
  "input": "*\t      dropped.\n\t\tmemset(buf, dirty, len);\n\tif (!buf) {\n\t\treturn nrf_uarte_rx_amount_get(uarte);\n\t}\n\t\tif (buf[i] != dirty) {\n\t\t(void)rx_flush(dev, NULL, 0);",
  "result": "- *\t      dropped.\n+ *\t      dropped but we still want to get amount of data flushed.\n-\t\tmemset(buf, dirty, len);\n+\tmemset(flush_buf, dirty, flush_len);\n-\tif (!buf) {\n-\t\treturn nrf_uarte_rx_amount_get(uarte);\n-\t}\n-\n-\t\tif (buf[i] != dirty) {\n+\t\tif (flush_buf[i] != dirty) {\n+\t\tuint8_t flushed;\n+\n-\t\t(void)rx_flush(dev, NULL, 0);\n+\t\tflushed = rx_flush(dev, NULL, 0);\n+\t\tif (HW_RX_COUNTING_ENABLED(data)) {\n+\t\t\t/* It need to be included because TIMER+PPI got RXDRDY events\n+\t\t\t * and counted those flushed bytes.\n+\t\t\t */\n+\t\t\tdata->async->rx_total_user_byte_cnt += flushed;\n+\t\t}"
},{
  "instruction": "drivers: serial: uart_nrfx_uarte: Fix interrupt driven TX only mode",
  "input": "\tbool ready = !data->int_driven->disable_tx_irq &&\n\t\t     nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) &&\n\t\t     nrf_uarte_int_enable_check(uarte,\n\t\t\t\t\t\tNRF_UARTE_INT_TXSTOPPED_MASK);",
  "result": "+\tbool tx_irq_enabled;\n+\tdata->int_driven->tx_irq_enabled = true;\n+\tdata->int_driven->tx_irq_enabled = false;\n-\tbool ready = !data->int_driven->disable_tx_irq &&\n-\t\t     nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) &&\n-\t\t     nrf_uarte_int_enable_check(uarte,\n-\t\t\t\t\t\tNRF_UARTE_INT_TXSTOPPED_MASK);\n+\tbool ready = data->int_driven->tx_irq_enabled &&\n+\t\t     nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED);"
},{
  "instruction": "drivers: serial: uart_async_to_irq: Add RX error handling",
  "input": "\treturn z_uart_async_to_irq_irq_tx_ready(dev) || z_uart_async_to_irq_irq_rx_ready(dev);",
  "result": "+/* Error pending. */\n+#define A2I_ERR_PENDING\t\tBIT(5)\n+\n+\t\tatomic_or(&data->flags, A2I_ERR_PENDING);\n-\treturn z_uart_async_to_irq_irq_tx_ready(dev) || z_uart_async_to_irq_irq_rx_ready(dev);\n+\tbool tx_rdy = z_uart_async_to_irq_irq_tx_ready(dev);\n+\tbool rx_rdy = z_uart_async_to_irq_irq_rx_ready(dev);\n+\tstruct uart_async_to_irq_data *data = get_data(dev);\n+\tbool err_pending = atomic_and(&data->flags, ~A2I_ERR_PENDING) & A2I_ERR_PENDING;\n+\n+\treturn tx_rdy || rx_rdy || err_pending;"
},{
  "instruction": "drivers: serial: uart_nrfx_uarte2: Disable RX when error is reported",
  "input": "",
  "result": "+\t\tif (IS_ASYNC_API(dev)) {\n+\t\t\t(void)uart_rx_disable(dev);\n+\t\t}"
},{
  "instruction": "arch: arm: cortex_m: pm_s2ram: Minor typo fix",
  "input": "\t  this option allows custom implementation of functions which handles the marking.",
  "result": "-\t  this option allows custom implementation of functions which handles the marking.\n+\t  this option allows custom implementation of functions which handle the marking."
},{
  "instruction": "drivers: timer: nrf_grtc: Add GRTC fix for app and rad cores",
  "input": "#if defined(CONFIG_NRF_GRTC_SLEEP_ALLOWED)",
  "result": "-#if defined(CONFIG_NRF_GRTC_SLEEP_ALLOWED)\n+#if defined(CONFIG_NRF_GRTC_SLEEP_ALLOWED) && defined(CONFIG_NRF_GRTC_START_SYSCOUNTER)"
},{
  "instruction": "drivers: i3c: add ccc setaasa helper",
  "input": "",
  "result": "+\n+int i3c_ccc_do_setaasa_all(const struct device *controller)\n+{\n+\tstruct i3c_ccc_payload ccc_payload;\n+\n+\t__ASSERT_NO_MSG(controller != NULL);\n+\n+\tmemset(&ccc_payload, 0, sizeof(ccc_payload));\n+\tccc_payload.ccc.id = I3C_CCC_SETAASA;\n+\n+\treturn i3c_do_ccc(controller, &ccc_payload);\n+}\n+/**\n+ * @brief Broadcast SETAASA to set all target's dynamic address to their\n+ * static address.\n+ *\n+ * Helper function to set dynamic addresses of all connected targets to\n+ * their static address.\n+ *\n+ * @param[in] controller Pointer to the controller device driver instance.\n+ *\n+ * @return @see i3c_do_ccc\n+ */\n+int i3c_ccc_do_setaasa_all(const struct device *controller);\n+"
},{
  "instruction": "drivers: i3c: shell: include reattachment for setdasa",
  "input": "",
  "result": "+\tif (desc->dynamic_addr != desc->static_addr) {\n+\t\tret = i3c_reattach_i3c_device(desc, desc->static_addr);\n+\t\tif (ret < 0) {\n+\t\t\tshell_error(shell_ctx, \"I3C: unable to reattach device\");\n+\t\t\treturn ret;\n+\t\t}\n+\t}"
},{
  "instruction": "drivers: i3c: shell: fix info cmd display for max_read_turnaround",
  "input": "\t\t\t\t\t\t    \"\\tmax_read_turnaround: 0x%08x\\n\"\n\t\t\t\t\t    \"\\tmax_read_turnaround: 0x%08x\\n\"",
  "result": "-\t\t\t\t\t\t    \"\\tmax_read_turnaround: 0x%08x\\n\"\n+\t\t\t\t\t\t    \"\\tmax_read_turnaround: 0x%06x\\n\"\n-\t\t\t\t\t    \"\\tmax_read_turnaround: 0x%08x\\n\"\n+\t\t\t\t\t    \"\\tmax_read_turnaround: 0x%06x\\n\""
},{
  "instruction": "drivers: i3c: shell: remove bcr check for getcaps",
  "input": "\tif (!(desc->bcr & I3C_BCR_ADV_CAPABILITIES)) {\n\t\tshell_error(shell_ctx, \"I3C: Device %s does not support advanced capabilities\",\n\t\t\t    desc->dev->name);\n\t\treturn -ENOTSUP;\n\t}",
  "result": "-\tif (!(desc->bcr & I3C_BCR_ADV_CAPABILITIES)) {\n-\t\tshell_error(shell_ctx, \"I3C: Device %s does not support advanced capabilities\",\n-\t\t\t    desc->dev->name);\n-\t\treturn -ENOTSUP;\n-\t}\n-"
},{
  "instruction": "manifest: Update commit ID for hal_renesas",
  "input": "     revision: d17dc07ba2af3cedf869454c9cb9c293d8379fe4",
  "result": "-      revision: d17dc07ba2af3cedf869454c9cb9c293d8379fe4\n+      revision: 1ec88911defaba8aebe265d57497cacfbb6afeb8"
},{
  "instruction": "doc: extensions: application: add build_args",
  "input": "       # Create host_os array\n       # Create tools array\n       # Create snippet array\n       # Create shields array\n           'build_args': build_args,\n       content.append('west build -b {}{}{}{}{}{}{}'.\n                      format(board, west_args, snippet_args, shield_args, build_dst, src, cmake_args))",
  "result": "-        # Create host_os array\n+        # Prepare repeatable arguments\n-        # Create tools array\n-\n-        # Create snippet array\n+        build_args_list = build_args.split(' ') if build_args is not None else None\n-\n-        # Create shields array\n-            'build_args': build_args,\n+            'build_args': build_args_list,\n+        build_args = kwargs[\"build_args\"]\n+        build_args = \"\".join(f\" -o {b}\" for b in build_args) if build_args else \"\"\n-        content.append('west build -b {}{}{}{}{}{}{}'.\n-                       format(board, west_args, snippet_args, shield_args, build_dst, src, cmake_args))\n+        content.append(\n+            f\"west build -b {board}{build_args}{west_args}{snippet_args}\"\n+            f\"{shield_args}{build_dst}{src}{cmake_args}\"\n+        )"
},{
  "instruction": "boards: seeed: Configure QSPI CS pin as pull-up in sleep",
  "input": "\t\t\t\t<NRF_PSEL(QSPI_IO3, 0, 23)>,\n\t\t\t\t<NRF_PSEL(QSPI_CSN, 0, 25)>;",
  "result": "-\t\t\t\t<NRF_PSEL(QSPI_IO3, 0, 23)>,\n-\t\t\t\t<NRF_PSEL(QSPI_CSN, 0, 25)>;\n+\t\t\t\t<NRF_PSEL(QSPI_IO3, 0, 23)>;\n+\t\t\tlow-power-enable;\n+\t\t};\n+\t\tgroup2 {\n+\t\t\tpsels = <NRF_PSEL(QSPI_CSN, 0, 25)>;\n+\t\t\tbias-pull-up;"
},{
  "instruction": "tests: drivers.gpio.1pin: re-enable hifive1",
  "input": "     - hifive1  # see #69350",
  "result": "-      - hifive1  # see #69350"
},{
  "instruction": "drivers: clock_control: stm32: Default driver selection out of soc",
  "input": "config CLOCK_CONTROL_STM32_CUBE\n\tdefault y\n\tdepends on CLOCK_CONTROL\n\tselect CLOCK_CONTROL_STM32_CUBE if CLOCK_CONTROL\n\tselect CLOCK_CONTROL_STM32_CUBE if CLOCK_CONTROL",
  "result": "+\tdefault y\n-config CLOCK_CONTROL_STM32_CUBE\n-\tdefault y\n-\tdepends on CLOCK_CONTROL\n-\n-\tselect CLOCK_CONTROL_STM32_CUBE if CLOCK_CONTROL\n-\tselect CLOCK_CONTROL_STM32_CUBE if CLOCK_CONTROL"
},{
  "instruction": "soc: stm32: Select CLOCK_CONTROL by default for whole family",
  "input": "",
  "result": "+config CLOCK_CONTROL\n+\tdefault y\n+"
},{
  "instruction": "drivers: input: input_gt911: fix OOB buffer write to touch points array",
  "input": "\tfor (i = 0; i <= points; i++) {",
  "result": "+\t/*\n+\t * Note- since we program the max number of touch inputs during init,\n+\t * the controller won't report more than the maximum number of touch\n+\t * points we are configured to support\n+\t */\n-\tfor (i = 0; i <= points; i++) {\n+\tfor (i = 0; i < points; i++) {"
},{
  "instruction": "hostap: fix SAP UDP RX low throughput in 5GHz",
  "input": "",
  "result": "+\tconf->vht_capab |= VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MAX;"
},{
  "instruction": "soc: nordic: nrf52: fix used define for enabling DCDC converter",
  "input": "#if defined(CONFIG_SOC_DCDC_NRF52X) || \\\n\t(DT_PROP(DT_INST(0, nordic_nrf5x_regulator), regulator_initial_mode) == NRF_REG_MODE_DCDC)",
  "result": "-#if defined(CONFIG_SOC_DCDC_NRF52X) || \\\n-\t(DT_PROP(DT_INST(0, nordic_nrf5x_regulator), regulator_initial_mode) == NRF_REG_MODE_DCDC)\n+#if defined(CONFIG_SOC_DCDC_NRF52X) || (DT_PROP(DT_INST(0, nordic_nrf5x_regulator),                \\\n+\t\t\t\t\t\tregulator_initial_mode) == NRF5X_REG_MODE_DCDC)"
},{
  "instruction": "net: config: Fix sntp clock init Kconfig depends",
  "input": "\tdepends on SNTP && POSIX_CLOCK",
  "result": "-\tdepends on SNTP && POSIX_CLOCK\n+\tdepends on SNTP && POSIX_TIMERS"
},{
  "instruction": "drivers: usb_dc_rpi_pico: Fixed connected handling",
  "input": "\t\t\tUSB_DC_DISCONNECTED :\n\t\t\tUSB_DC_CONNECTED;",
  "result": "-\t\t\tUSB_DC_DISCONNECTED :\n-\t\t\tUSB_DC_CONNECTED;\n+\t\t\tUSB_DC_CONNECTED :\n+\t\t\tUSB_DC_DISCONNECTED;"
},{
  "instruction": "net: http_server: Clarify the host parameter in service define",
  "input": "* @note The @p _host parameter must be non-`NULL`. It is used to specify an IP address either in\n* IPv4 or IPv6 format a fully-qualified hostname or a virtual host.\n* @note The @p _host parameter must be non-`NULL`. It is used to specify an IP address either in\n* IPv4 or IPv6 format a fully-qualified hostname or a virtual host.\n* @note The @p _host parameter must be non-`NULL`. It is used to specify an IP address either in\n* IPv4 or IPv6 format a fully-qualified hostname or a virtual host.\n* @note The @p _host parameter must be non-`NULL`. It is used to specify an IP address either in\n* IPv4 or IPv6 format a fully-qualified hostname or a virtual host.",
  "result": "- * @note The @p _host parameter must be non-`NULL`. It is used to specify an IP address either in\n- * IPv4 or IPv6 format a fully-qualified hostname or a virtual host.\n+ * @note The @p _host parameter is used to specify an IP address either in\n+ * IPv4 or IPv6 format a fully-qualified hostname or a virtual host. If left NULL, the listening\n+ * port will listen on all addresses.\n- * @note The @p _host parameter must be non-`NULL`. It is used to specify an IP address either in\n- * IPv4 or IPv6 format a fully-qualified hostname or a virtual host.\n+ * @note The @p _host parameter is used to specify an IP address either in\n+ * IPv4 or IPv6 format a fully-qualified hostname or a virtual host. If left NULL, the listening\n+ * port will listen on all addresses.\n- * @note The @p _host parameter must be non-`NULL`. It is used to specify an IP address either in\n- * IPv4 or IPv6 format a fully-qualified hostname or a virtual host.\n+ * @note The @p _host parameter is used to specify an IP address either in\n+ * IPv4 or IPv6 format a fully-qualified hostname or a virtual host. If left NULL, the listening\n+ * port will listen on all addresses.\n- * @note The @p _host parameter must be non-`NULL`. It is used to specify an IP address either in\n- * IPv4 or IPv6 format a fully-qualified hostname or a virtual host.\n+ * @note The @p _host parameter is used to specify an IP address either in\n+ * IPv4 or IPv6 format a fully-qualified hostname or a virtual host. If left NULL, the listening\n+ * port will listen on all addresses."
},{
  "instruction": "samples: net: http_server: Create service binding to all addresses",
  "input": "HTTP_SERVICE_DEFINE(test_http_service, CONFIG_NET_CONFIG_MY_IPV4_ADDR, &test_http_service_port, 1,\nHTTPS_SERVICE_DEFINE(test_https_service, CONFIG_NET_CONFIG_MY_IPV4_ADDR,",
  "result": "-HTTP_SERVICE_DEFINE(test_http_service, CONFIG_NET_CONFIG_MY_IPV4_ADDR, &test_http_service_port, 1,\n+HTTP_SERVICE_DEFINE(test_http_service, NULL, &test_http_service_port, 1,\n-HTTPS_SERVICE_DEFINE(test_https_service, CONFIG_NET_CONFIG_MY_IPV4_ADDR,\n+HTTPS_SERVICE_DEFINE(test_https_service, NULL,"
},{
  "instruction": "net: http_server: Turn off V6ONLY if IPv4-to-IPv6 mapping is enabled",
  "input": "",
  "result": "+\t\t/* If IPv4-to-IPv6 mapping is enabled, then turn off V6ONLY option\n+\t\t * so that IPv6 socket can serve IPv4 connections.\n+\t\t */\n+\t\tif (IS_ENABLED(CONFIG_NET_IPV4_MAPPING_TO_IPV6)) {\n+\t\t\tint optval = 0;\n+\n+\t\t\t(void)setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY,\n+\t\t\t\t\t &optval, sizeof(optval));\n+\t\t}\n+"
},{
  "instruction": "net: http_server: Allow service to be created with NULL host",
  "input": "\t\tif (IS_ENABLED(CONFIG_NET_IPV6) &&\n\t\t} else if (IS_ENABLED(CONFIG_NET_IPV4) &&\n\t\tLOG_DBG(\"Initialized HTTP Service %s:%u\", svc->host, *svc->port);",
  "result": "-\t\tif (IS_ENABLED(CONFIG_NET_IPV6) &&\n+\t\tif (IS_ENABLED(CONFIG_NET_IPV6) && svc->host != NULL &&\n-\t\t} else if (IS_ENABLED(CONFIG_NET_IPV4) &&\n+\t\t} else if (IS_ENABLED(CONFIG_NET_IPV4) && svc->host != NULL &&\n-\t\tLOG_DBG(\"Initialized HTTP Service %s:%u\", svc->host, *svc->port);\n+\t\tLOG_DBG(\"Initialized HTTP Service %s:%u\",\n+\t\t\tsvc->host ? svc->host : \"<any>\", *svc->port);"
},{
  "instruction": "doc: generation: fix link to zephyr.tag",
  "input": "tag file exported at `zephyr.tag </doxygen/html/zephyr.tag>`_",
  "result": "-tag file exported at `zephyr.tag </doxygen/html/zephyr.tag>`_\n+tag file exported at `zephyr.tag <../../doxygen/html/zephyr.tag>`_"
},{
  "instruction": "SOC: Updated MAX IRQ num supported by Aglex5",
  "input": "# - include the UART interrupts 173 or 204\n\tdefault 205",
  "result": "-# - include the UART interrupts 173 or 204\n+# - include the UART interrupts 173 or 274\n-\tdefault 205\n+\tdefault 274"
},{
  "instruction": "CODEOWNERS: Updated coder owners file",
  "input": "",
  "result": "+/drivers/ethernet/dwc_xgmac               @Smale-12048867\n+/drivers/ethernet/dwc_xgmac/dwc_xgmac     @Smale-12048867"
},{
  "instruction": "doc: kernel: fix k_poll example",
  "input": "           } else if (events[1].state == K_POLL_STATE_FIFO_DATA_AVAILABLE) {\n           } else if (events[2].state == K_POLL_STATE_MSGQ_DATA_AVAILABLE) {\n           } else if (events[3].state == K_POLL_STATE_PIPE_DATA_AVAILABLE) {",
  "result": "-            } else if (events[1].state == K_POLL_STATE_FIFO_DATA_AVAILABLE) {\n+            }\n+            if (events[1].state == K_POLL_STATE_FIFO_DATA_AVAILABLE) {\n-            } else if (events[2].state == K_POLL_STATE_MSGQ_DATA_AVAILABLE) {\n+            }\n+            if (events[2].state == K_POLL_STATE_MSGQ_DATA_AVAILABLE) {\n-            } else if (events[3].state == K_POLL_STATE_PIPE_DATA_AVAILABLE) {\n+            }\n+            if (events[3].state == K_POLL_STATE_PIPE_DATA_AVAILABLE) {"
},{
  "instruction": "drivers: uart: Fix build error for lpuart without modem support",
  "input": "",
  "result": "+#if defined(FSL_FEATURE_LPUART_HAS_MODEM_SUPPORT) && \\\n+\tFSL_FEATURE_LPUART_HAS_MODEM_SUPPORT\n+#endif\n+"
},{
  "instruction": "include: dt-bindings: kinetis sim: Add clock sources definitions",
  "input": "",
  "result": "+#define KINETIS_SIM_OSCERCLK    8\n+#define KINETIS_SIM_MCGIRCLK    12\n+#define KINETIS_SIM_MCGPCLK     18"
},{
  "instruction": "dts: bindings: kinetis-ftfa: Add configuration properties",
  "input": "",
  "result": "+\n+properties:\n+  fsec:\n+    type: int\n+    description: |\n+      Configures the reset value of the FSEC register, which includes\n+      backdoor key access, mass erase, factory access, and flash security\n+      options.\n+\n+  fopt:\n+    type: int\n+    description: |\n+      Configures the reset value of the FOPT register, which includes boot,\n+      NMI, and EzPort options.\n+\n+  config-field-offset:\n+    type: int\n+    description: |\n+      Flash configuration field offset"
},{
  "instruction": "dts: bindings: nxp kinetis mcg: Add optional frequency dividers",
  "input": "",
  "result": "+  fcrdiv:\n+    type: int\n+    enum: [0, 1, 2, 3, 4, 5, 6, 7]\n+    description: |\n+      Internal Reference Clock Divider.\n+      Division factor is given as 2^fcrdiv.\n+\n+  lircdiv2:\n+    type: int\n+    enum: [0, 1, 2, 3, 4, 5, 6, 7]\n+    description: |\n+      Second Low-frequency Internal Reference Clock Divider.\n+      Division factor is given as 2^lircdiv2.\n+"
},{
  "instruction": "charger: bq25180: Add threshold voltage for precharge",
  "input": "",
  "result": "+#define BQ25180_VLOWV_SEL_2_8                   BIT(6)\n+#define BQ25180_VLOWV_SEL_3_0                   0x00\n+#define BQ25180_VLOWV_SEL_MSK                   BIT(6)\n+\tuint32_t precharge_threshold_voltage_microvolt;\n+\t/* Precharge threshold voltage */\n+\tif (cfg->precharge_threshold_voltage_microvolt <= 2800000) {\n+\t\tval = BQ25180_VLOWV_SEL_2_8;\n+\t} else {\n+\t\tval = BQ25180_VLOWV_SEL_3_0;\n+\t}\n+\n+\tret = i2c_reg_update_byte_dt(&cfg->i2c, BQ25180_IC_CTRL, BQ25180_VLOWV_SEL_MSK, val);\n+\tif (ret < 0) {\n+\t\treturn ret;\n+\t}\n+\n+\t\t.precharge_threshold_voltage_microvolt =                                           \\\n+\t\t\tDT_INST_PROP(inst, precharge_voltage_threshold_microvolt),                 \\\n+\n+  precharge-voltage-threshold-microvolt:\n+    type: int\n+    default: 3000000\n+    description: |\n+      Threshold at which voltage to switch to constant current charge.\n+      Must be either 3.0V or 2.8V"
},{
  "instruction": "charger: bq25180: add support for recharge voltage threshold",
  "input": "",
  "result": "+#define BQ25180_IC_CTRL_VRCH_100                0x00\n+#define BQ25180_IC_CTRL_VRCH_200                BIT(5)\n+#define BQ25180_IC_CTRL_VRCH_MSK                BIT(5)\n+\tuint32_t recharge_voltage_microvolt;\n+\tif (cfg->recharge_voltage_microvolt > 0) {\n+\t\tif ((cfg->max_voltage_microvolt - cfg->recharge_voltage_microvolt) > 100000) {\n+\t\t\tval = BQ25180_IC_CTRL_VRCH_200;\n+\t\t} else {\n+\t\t\tval = BQ25180_IC_CTRL_VRCH_100;\n+\t\t}\n+\n+\t\tret = i2c_reg_update_byte_dt(&cfg->i2c, BQ25180_IC_CTRL, BQ25180_IC_CTRL_VRCH_MSK,\n+\t\t\t\t\t     val);\n+\t\tif (ret < 0) {\n+\t\t\treturn ret;\n+\t\t}\n+\t}\n+\n+\t\t.recharge_voltage_microvolt =                                                      \\\n+\t\t\tDT_INST_PROP_OR(inst, re_charge_voltage_microvolt, 0),                     \\"
},{
  "instruction": "modem_cellular: adjust CMUX max frame size for LARA-R6",
  "input": "\t\t\t      MODEM_CHAT_SCRIPT_CMD_RESP(\"AT+CMUX=0,0,5,127\", ok_match));",
  "result": "+\tdefault 32 if DT_HAS_U_BLOX_LARA_R6_ENABLED\n+/* NOTE: For some reason, a CMUX max frame size of 127 causes FCS errors in\n+ * this modem; larger or smaller doesn't. The modem's default value is 31,\n+ * which works well\n+ */\n-\t\t\t      MODEM_CHAT_SCRIPT_CMD_RESP(\"AT+CMUX=0,0,5,127\", ok_match));\n+\t\t\t      MODEM_CHAT_SCRIPT_CMD_RESP(\"AT+CMUX=0,0,5,31\", ok_match));"
},{
  "instruction": "drivers: stm32: Make some config symbols menuconfig symbols",
  "input": "config SOC_FLASH_STM32\nconfig PINCTRL_STM32\n\tbool\nconfig SMBUS_STM32\nconfig IWDG_STM32",
  "result": "-config SOC_FLASH_STM32\n+menuconfig SOC_FLASH_STM32\n-config PINCTRL_STM32\n-\tbool\n+menuconfig PINCTRL_STM32\n+\tbool \"Pin controller driver for STM32 MCUs\"\n-config SMBUS_STM32\n+menuconfig SMBUS_STM32\n-config IWDG_STM32\n+menuconfig IWDG_STM32"
},{
  "instruction": "boards: rpi_pico: add usbd test feature",
  "input": "",
  "result": "+  - usbd"
},{
  "instruction": "dts: rp2040: fix USB controller base address",
  "input": "\t\tusbd: usbd@50100000 {\n\t\t\treg = <0x50100000 0x10000>;",
  "result": "-\t\tusbd: usbd@50100000 {\n+\t\tusbd: usbd@50110000 {\n-\t\t\treg = <0x50100000 0x10000>;\n+\t\t\treg = <0x50110000 0x10000>;"
},{
  "instruction": "dts: arm: st: stm32h5: fix spi 1-3 clocks",
  "input": "\t\t\tclocks = <&rcc STM32_CLOCK_BUS_APB2 0x00001000>;\n\t\t\tclocks = <&rcc STM32_CLOCK_BUS_APB1 0x00004000>;\n\t\t\tclocks = <&rcc STM32_CLOCK_BUS_APB1 0x00008000>;",
  "result": "-\t\t\tclocks = <&rcc STM32_CLOCK_BUS_APB2 0x00001000>;\n+\t\t\tclocks = <&rcc STM32_CLOCK_BUS_APB2 0x00001000>,\n+\t\t\t\t <&rcc STM32_SRC_PLL1_Q SPI1_SEL(0)>;\n-\t\t\tclocks = <&rcc STM32_CLOCK_BUS_APB1 0x00004000>;\n+\t\t\tclocks = <&rcc STM32_CLOCK_BUS_APB1 0x00004000>,\n+\t\t\t\t <&rcc STM32_SRC_PLL1_Q SPI2_SEL(0)>;\n-\t\t\tclocks = <&rcc STM32_CLOCK_BUS_APB1 0x00008000>;\n+\t\t\tclocks = <&rcc STM32_CLOCK_BUS_APB1 0x00008000>,\n+\t\t\t\t <&rcc STM32_SRC_PLL1_Q SPI3_SEL(0)>;"
},{
  "instruction": "soc: nordic: add enabled instances validation for nRF54L series",
  "input": "* nRF53 and nRF91 Series this limitation concerns UART peripherals as well).",
  "result": "+\t\t\t    IS_ENABLED(CONFIG_SOC_SERIES_NRF54LX) || \\\n- * nRF53 and nRF91 Series this limitation concerns UART peripherals as well).\n+ * nRF53, nRF54L and nRF91 Series this limitation concerns UART peripherals as well).\n+\tIF_ENABLED(CONFIG_SOC_SERIES_NRF54LX, (\", UARTE\"#idx)) \\\n+BUILD_ASSERT(CHECK(00), MSG(00));\n+BUILD_ASSERT(CHECK(20), MSG(20));\n+BUILD_ASSERT(CHECK(21), MSG(21));\n+BUILD_ASSERT(CHECK(22), MSG(22));\n+BUILD_ASSERT(CHECK(30), MSG(30));"
},{
  "instruction": "soc: intel_adsp: ace: Configurable SRAM retention mode and cleanup",
  "input": "#define DELAY_COUNT\t\t\t256\n\t\tHPSRAM_REGS(idx)->HSxRMCTL = 1;\n\t\tLPSRAM_REGS(idx)->USxRMCTL = 1;",
  "result": "+\n+config SRAM_RETENTION_MODE\n+\tbool \"SRAM retention mode during initialization\"\n+\tdefault y\n+\thelp\n+\t  When this option is enabled, the SRAM retention mode will be\n+\t  activated during the firmware boot-up process. If disabled,\n+\t  the retention mode will not be activated.\n-#define DELAY_COUNT\t\t\t256\n-\n-\t\tHPSRAM_REGS(idx)->HSxRMCTL = 1;\n+\t\tHPSRAM_REGS(idx)->HSxRMCTL = IS_ENABLED(CONFIG_SRAM_RETENTION_MODE);\n-\t\tLPSRAM_REGS(idx)->USxRMCTL = 1;\n+\t\tLPSRAM_REGS(idx)->USxRMCTL = IS_ENABLED(CONFIG_SRAM_RETENTION_MODE);"
},{
  "instruction": "doc: process for adding a maintainer if the candidate does not have a role",
  "input": ":ref:`maintainers_file` in the Zephyr repository.",
  "result": "-:ref:`maintainers_file` in the Zephyr repository.\n+:ref:`maintainers_file` in the Zephyr repository. Candidates who are neither\n+Contributors nor Collaborators must be approved by the TSC before they can\n+assume the role of Maintainer."
},{
  "instruction": "board: nrf54l15bsim: Disable native_posix entropy seeding",
  "input": "",
  "result": "+\n+CONFIG_FAKE_ENTROPY_NATIVE_POSIX_SEED_BY_DEFAULT=n"
},{
  "instruction": "entropy: native_posix: Add kconfig to not seed by default",
  "input": "\tentropy_native_seed(seed, seed_random);",
  "result": "+\n+config FAKE_ENTROPY_NATIVE_POSIX_SEED_BY_DEFAULT\n+\tbool \"Seed the generator by default\"\n+\tdefault y\n+\tdepends on FAKE_ENTROPY_NATIVE_POSIX\n+\thelp\n+\t  Apply a seed by default, even if the user does not request it through the command line.\n+\t  Disabling this feature allows some other component to seed the host standard library random\n+\t  generator without this component's default initialization interfering.\n+static bool seed_set;\n-\tentropy_native_seed(seed, seed_random);\n+\tif (seed_set || seed_random ||\n+\t    IS_ENABLED(CONFIG_FAKE_ENTROPY_NATIVE_POSIX_SEED_BY_DEFAULT)) {\n+\t\tentropy_native_seed(seed, seed_random);\n+\t}\n+static void seed_was_set(char *argv, int offset)\n+{\n+\tARG_UNUSED(argv);\n+\tARG_UNUSED(offset);\n+\tseed_set = true;\n+}\n+\n+\t\t\t.call_when_found = seed_was_set,"
},{
  "instruction": "Bluetooth: TBS: Fix issues with lookup_inst_by_uri_scheme",
  "input": "static struct tbs_service_inst *lookup_inst_by_uri_scheme(const char *uri,\n\t\t\t\t\t\t\t  uint8_t uri_len)\n\tfor (int i = 1; i < uri_len - 1; i++) {\n\tif (strlen(uri_scheme) == 0) {",
  "result": "-static struct tbs_service_inst *lookup_inst_by_uri_scheme(const char *uri,\n-\t\t\t\t\t\t\t  uint8_t uri_len)\n+static struct tbs_service_inst *lookup_inst_by_uri_scheme(const uint8_t *uri, uint8_t uri_len)\n+\tif (uri_len == 0) {\n+\t\treturn NULL;\n+\t}\n+\n-\tfor (int i = 1; i < uri_len - 1; i++) {\n+\tfor (uint8_t i = 1U; i < uri_len - 1U; i++) {\n+\t\t\tbreak;\n-\tif (strlen(uri_scheme) == 0) {\n+\tif (uri_scheme[0] == '\\0') {"
},{
  "instruction": "dts: arm: st: h7: remove unnecessary inclusions",
  "input": "#include <st/h7/stm32h7.dtsi>",
  "result": "-#include <st/h7/stm32h7.dtsi>"
},{
  "instruction": "i2c: nrf_twi: Add cast to const buffer pointers",
  "input": "\t\t\t\t\t\t   sqe->tiny_tx.buf, sqe->tiny_tx.buf_len,\n\t\t\t\t\t\t   dt_spec->addr);\n\t\t\t\t\t\t   sqe->tx.buf, sqe->tx.buf_len, dt_spec->addr);",
  "result": "-\t\t\t\t\t\t   sqe->tiny_tx.buf, sqe->tiny_tx.buf_len,\n-\t\t\t\t\t\t   dt_spec->addr);\n+\t\t\t\t\t\t   (uint8_t *)sqe->tiny_tx.buf,\n+\t\t\t\t\t\t   sqe->tiny_tx.buf_len, dt_spec->addr);\n-\t\t\t\t\t\t   sqe->tx.buf, sqe->tx.buf_len, dt_spec->addr);\n+\t\t\t\t\t\t   (uint8_t *)sqe->tx.buf,\n+\t\t\t\t\t\t   sqe->tx.buf_len, dt_spec->addr);"
},{
  "instruction": "docs: add information about main(int, char **)",
  "input": "``int``. Your ``main()`` must be defined as ``int main(void)``. Zephyr ignores\nthe return value from main, so applications should not return status\ninformation and should, instead, return zero.\nAn application-supplied :c:func:`main` function begins executing once\nto the function.\nThe following code outlines a trivial :c:func:`main` function.",
  "result": "-``int``. Your ``main()`` must be defined as ``int main(void)``. Zephyr ignores\n-the return value from main, so applications should not return status\n-information and should, instead, return zero.\n+``int``. Your ``main()`` must be defined as ``int main(void)`` or\n+``int main(int, char **)``. To use main with arguments the ``CONFIG_BOOTARGS`` option\n+has to be selected. Zephyr ignores the return value from main, so applications\n+should not return status information and should, instead, return zero.\n-An application-supplied :c:func:`main` function begins executing once\n+An application-supplied ``main()`` function begins executing once\n-to the function.\n+to the function, unless ``CONFIG_BOOTARGS`` is selected. In such case the\n+kernel passes arguments to it and ``main(int, char **)`` can be used.\n-The following code outlines a trivial :c:func:`main` function.\n+The following code outlines a trivial ``main(void)`` function."
},{
  "instruction": "zefi: include autoconf.h",
  "input": " -i ${ZEPHYR_BASE}/include\n -i ${ZEPHYR_BASE}/include\n -i ${ZEPHYR_BASE}/include\n -i ${ZEPHYR_BASE}/include\n -i ${ZEPHYR_BASE}/include\n -i ${ZEPHYR_BASE}/include",
  "result": "+#include <zephyr/autoconf.h>\n-  -i ${ZEPHYR_BASE}/include\n+  -i ${ZEPHYR_BASE}/include ${PROJECT_BINARY_DIR}/include/generated\n-  -i ${ZEPHYR_BASE}/include\n+  -i ${ZEPHYR_BASE}/include ${PROJECT_BINARY_DIR}/include/generated\n-  -i ${ZEPHYR_BASE}/include\n+  -i ${ZEPHYR_BASE}/include ${PROJECT_BINARY_DIR}/include/generated\n-  -i ${ZEPHYR_BASE}/include\n+  -i ${ZEPHYR_BASE}/include ${PROJECT_BINARY_DIR}/include/generated\n-  -i ${ZEPHYR_BASE}/include\n+  -i ${ZEPHYR_BASE}/include ${PROJECT_BINARY_DIR}/include/generated\n-  -i ${ZEPHYR_BASE}/include\n+  -i ${ZEPHYR_BASE}/include ${PROJECT_BINARY_DIR}/include/generated"
},{
  "instruction": "doc: optimization: link to sysbuild commands",
  "input": "",
  "result": "+If you are using :ref:`sysbuild`, see :ref:`sysbuild_dedicated_image_build_targets` instead.\n+If you are using :ref:`sysbuild`, see :ref:`sysbuild_dedicated_image_build_targets` instead.\n+If you are using :ref:`sysbuild`, see :ref:`sysbuild_dedicated_image_build_targets` instead.\n+If you are using :ref:`sysbuild`, see :ref:`sysbuild_dedicated_image_build_targets` instead."
},{
  "instruction": "tests: spi: loopback: Set ZTest thread priority to positive",
  "input": "",
  "result": "+CONFIG_ZTEST_THREAD_PRIORITY=1"
},{
  "instruction": "shell: kernel: do a cold reboot by standard",
  "input": "\tSHELL_CMD(reboot, &sub_kernel_reboot, \"Reboot.\", NULL),",
  "result": "-\tSHELL_CMD(reboot, &sub_kernel_reboot, \"Reboot.\", NULL),\n+\tSHELL_CMD(reboot, &sub_kernel_reboot, \"Reboot.\", cmd_kernel_reboot_cold),"
},{
  "instruction": "net: fix compiler warning -Wtype-limits",
  "input": "\tif (oper_state >= NET_IF_OPER_UNKNOWN && oper_state <= NET_IF_OPER_UP) {",
  "result": "-\tif (oper_state >= NET_IF_OPER_UNKNOWN && oper_state <= NET_IF_OPER_UP) {\n+\tBUILD_ASSERT((enum net_if_oper_state)(-1) > 0 && NET_IF_OPER_UNKNOWN == 0);\n+\tif (oper_state <= NET_IF_OPER_UP) {"
},{
  "instruction": "soc: st: stm32: add soc for stm32u073",
  "input": "",
  "result": "+    - name: stm32u073xx\n+# STMicroelectronics STM32U073XX MCU\n+\n+# Copyright (c) 2024 STMicroelectronics\n+# SPDX-License-Identifier: Apache-2.0\n+\n+if SOC_STM32U073XX\n+\n+config NUM_IRQS\n+\tdefault 32\n+\n+endif # SOC_STM32U073XX\n+config SOC_STM32U073XX\n+\tbool\n+\tselect SOC_SERIES_STM32U0X\n+\n+\tdefault \"stm32u073xx\" if SOC_STM32U073XX"
},{
  "instruction": "boards: adafruit: feather_m0_basic_proto: define feather_spi bus",
  "input": "",
  "result": "+feather_spi: &sercom4 {};"
},{
  "instruction": "Bluetooth: Host: Fix unable to start scanning after scan param failure",
  "input": "static uint32_t scan_check_if_state_allowed(enum bt_le_scan_user flag)\n\t} else {\n\t\t/* Check if it can be enabled */\n\t\terr = scan_check_if_state_allowed(flag);\n\t\tif (err) {\n\t\t\treturn err;\n\t\t}\n\t\tatomic_set_bit(scan_state.scan_flags, flag);\n\treturn scan_update();",
  "result": "-static uint32_t scan_check_if_state_allowed(enum bt_le_scan_user flag)\n+static int scan_check_if_state_allowed(enum bt_le_scan_user flag)\n-\t} else {\n-\t\t/* Check if it can be enabled */\n-\t\terr = scan_check_if_state_allowed(flag);\n-\t\tif (err) {\n-\t\t\treturn err;\n-\t\t}\n-\t\tatomic_set_bit(scan_state.scan_flags, flag);\n+\t\treturn scan_update();\n-\treturn scan_update();\n+\terr = scan_check_if_state_allowed(flag);\n+\tif (err) {\n+\t\treturn err;\n+\t}\n+\n+\tatomic_set_bit(scan_state.scan_flags, flag);\n+\n+\terr = scan_update();\n+\tif (err) {\n+\t\tatomic_clear_bit(scan_state.scan_flags, flag);\n+\t}\n+\n+\treturn err;"
},{
  "instruction": "manifest: update hal_nordic revision",
  "input": "     revision: 9717cc2845116ac1c4465b1eb8cc913513601e2a",
  "result": "-      revision: 9717cc2845116ac1c4465b1eb8cc913513601e2a\n+      revision: d1099d6c52fba81ed23f1ce6cb54f4387a88ccea"
},{
  "instruction": "Bluetooth: BAP: SD: Added missing bad code when using mod_src",
  "input": "\t\treturn;",
  "result": "+\n+\t\tif (state->encrypt_state == BT_BAP_BIG_ENC_STATE_BAD_CODE) {\n+\t\t\t(void)memcpy(state->bad_code, internal_state->broadcast_code,\n+\t\t\t\t     sizeof(internal_state->state.bad_code));\n+\t\t}\n+\n-\t\treturn;\n+\t\tif (memcmp(state->bad_code, INCORRECT_BROADCAST_CODE,\n+\t\t\t   BT_AUDIO_BROADCAST_CODE_SIZE) != 0) {\n+\t\t\tFAIL(\"Bad code is not what we sent\");\n+\t\t\treturn;\n+\t\t}"
},{
  "instruction": "Bluetooth: TBS: Fix type of uri in call_alloc",
  "input": "static struct bt_tbs_call *call_alloc(struct tbs_service_inst *inst, uint8_t state, const char *uri,\n\t\t\t\t      uint16_t uri_len)\n\tcall = call_alloc(service_inst, BT_TBS_CALL_STATE_INCOMING, from, strlen(from));",
  "result": "-static struct bt_tbs_call *call_alloc(struct tbs_service_inst *inst, uint8_t state, const char *uri,\n-\t\t\t\t      uint16_t uri_len)\n+static struct bt_tbs_call *call_alloc(struct tbs_service_inst *inst, uint8_t state,\n+\t\t\t\t      const uint8_t *uri, uint16_t uri_len)\n-\tcall = call_alloc(service_inst, BT_TBS_CALL_STATE_INCOMING, from, strlen(from));\n+\tcall = call_alloc(service_inst, BT_TBS_CALL_STATE_INCOMING, (uint8_t *)from, strlen(from));"
},{
  "instruction": "Bluetooth: TBS: Add UTF8 requirement to Kconfigs",
  "input": "",
  "result": "+\tdepends on UTF8\n+\tdepends on UTF8\n+\tdepends on UTF8"
},{
  "instruction": "Bluetooth: TBS: Fix type of uri in bt_tbs_valid_uri",
  "input": "\t} else if (!bt_tbs_valid_uri(remote_uri, strlen(remote_uri))) {\n\t} else if (!bt_tbs_valid_uri(to, strlen(to))) {\n\t} else if (!bt_tbs_valid_uri(from, strlen(from))) {\n* @brief Checks if a string contains a colon (':') followed by a printable\nstatic inline bool bt_tbs_valid_uri(const char *uri, size_t len)\n\tif (len > CONFIG_BT_TBS_MAX_URI_LENGTH ||\n\t    len < BT_TBS_MIN_URI_LEN) {\n\tfor (int i = 1; i < len; i++) {",
  "result": "-\t} else if (!bt_tbs_valid_uri(remote_uri, strlen(remote_uri))) {\n+\t} else if (!bt_tbs_valid_uri((uint8_t *)remote_uri, strlen(remote_uri))) {\n-\t} else if (!bt_tbs_valid_uri(to, strlen(to))) {\n+\t} else if (!bt_tbs_valid_uri((uint8_t *)to, strlen(to))) {\n-\t} else if (!bt_tbs_valid_uri(from, strlen(from))) {\n+\t} else if (!bt_tbs_valid_uri((uint8_t *)from, strlen(from))) {\n- * @brief Checks if a string contains a colon (':') followed by a printable\n+ * @brief Checks if @p uri contains a colon (':') followed by a printable\n-static inline bool bt_tbs_valid_uri(const char *uri, size_t len)\n+static inline bool bt_tbs_valid_uri(const uint8_t *uri, size_t uri_len)\n-\tif (len > CONFIG_BT_TBS_MAX_URI_LENGTH ||\n-\t    len < BT_TBS_MIN_URI_LEN) {\n+\tif (uri_len > CONFIG_BT_TBS_MAX_URI_LENGTH || uri_len < BT_TBS_MIN_URI_LEN) {\n-\tfor (int i = 1; i < len; i++) {\n+\tfor (size_t i = 1; i < uri_len; i++) {"
},{
  "instruction": "modules: hal_nordic: Enforce nrf-regtool exact version match",
  "input": " find_package(nrf-regtool 5.6.0",
  "result": "-  find_package(nrf-regtool 5.6.0\n+  find_package(nrf-regtool 5.6.0 REQUIRED"
},{
  "instruction": "drivers: i2s: Do not ignore the return value from queue_put.",
  "input": "\tqueue_put(&dev_data->tx.mem_block_queue, mem_block, size);\n\treturn 0;",
  "result": "-\tqueue_put(&dev_data->tx.mem_block_queue, mem_block, size);\n-\n-\treturn 0;\n+\treturn queue_put(&dev_data->tx.mem_block_queue, mem_block, size);"
},{
  "instruction": "drivers: i2s: Fix I2S channel count.",
  "input": "\tconst uint32_t num_channels = i2s_cfg->format & I2S_FMT_DATA_FORMAT_MASK\n\t\t\t\t      ? 2U : i2s_cfg->channels;",
  "result": "-\tconst uint32_t num_channels = i2s_cfg->format & I2S_FMT_DATA_FORMAT_MASK\n-\t\t\t\t      ? 2U : i2s_cfg->channels;\n+\tconst uint32_t num_channels =\n+\t\t((i2s_cfg->format & I2S_FMT_DATA_FORMAT_MASK) == I2S_FMT_DATA_FORMAT_I2S)\n+\t\t\t? 2U\n+\t\t\t: i2s_cfg->channels;"
},{
  "instruction": "manifest: mbedtls: update to 3.6.1",
  "input": "     revision: 2f24831ee13d399ce019c4632b0bcd440a713f7c",
  "result": "+  * Mbed TLS was updated to version 3.6.1. The release notes can be found at:\n+    https://github.com/Mbed-TLS/mbedtls/releases/tag/mbedtls-3.6.1\n+\n-      revision: 2f24831ee13d399ce019c4632b0bcd440a713f7c\n+      revision: fb36f3fe20f9f62e67b1a20c0cfe0a6788ec2bf6"
},{
  "instruction": "driver: wifi: esp_at: fix typo in CIPDINFO option",
  "input": "\t  Enable AT+CIPDINFO got get peer ip-address and port.",
  "result": "-\t  Enable AT+CIPDINFO got get peer ip-address and port.\n+\t  Enable AT+CIPDINFO to get peer ip-address and port."
},{
  "instruction": "cmake: remove spurious parenthese just added to xt-ld/linker_flags",
  "input": ")",
  "result": "-)\n+"
},{
  "instruction": "drivers: dma_xmc4xxx: Clear request before callback when overrun happens",
  "input": "\t\tif (dma_channel->cb && dma_channel->dlr_line != DLR_LINE_UNSET &&\n\t\t\tLOG_ERR(\"Overruns detected on channel %d\", i);\n\t\t\tdma_channel->cb(dev, dma_channel->user_data, i, -EIO);",
  "result": "-\t\tif (dma_channel->cb && dma_channel->dlr_line != DLR_LINE_UNSET &&\n+\t\tif (dma_channel->dlr_line != DLR_LINE_UNSET &&\n-\t\t\tLOG_ERR(\"Overruns detected on channel %d\", i);\n-\t\t\tdma_channel->cb(dev, dma_channel->user_data, i, -EIO);\n-\n+\n+\t\t\tLOG_ERR(\"Overruns detected on channel %d\", i);\n+\t\t\tif (dma_channel->cb != NULL) {\n+\t\t\t\tdma_channel->cb(dev, dma_channel->user_data, i, -EIO);\n+\t\t\t}"
},{
  "instruction": "logging: fix color for shell log backend",
  "input": "\t           || LOG_BACKEND_SWO || LOG_BACKEND_XTENSA_SIM",
  "result": "-\t           || LOG_BACKEND_SWO || LOG_BACKEND_XTENSA_SIM\n+\t           || LOG_BACKEND_SWO || LOG_BACKEND_XTENSA_SIM || SHELL_LOG_BACKEND"
},{
  "instruction": "scripts: pylib: twister: fix missing newlines at handler.log",
  "input": "               for sl in serial_line.decode('utf-8', 'ignore').splitlines():",
  "result": "-                for sl in serial_line.decode('utf-8', 'ignore').splitlines():\n+                for sl in serial_line.decode('utf-8', 'ignore').splitlines(keepends=True):"
},{
  "instruction": "kernel: userspace: Fix dynamic thread stack allocation for RISC-V",
  "input": "/* On ARM & ARC MPU we may have two different alignment requirement\n#if defined(CONFIG_ARM_MPU) || defined(CONFIG_ARC_MPU)\n#endif /* CONFIG_ARM_MPU || CONFIG_ARC_MPU */\n#ifndef CONFIG_MPU_STACK_GUARD\n\tZ_THREAD_STACK_OBJ_ALIGN(CONFIG_PRIVILEGED_STACK_SIZE)\n\tZ_THREAD_STACK_OBJ_ALIGN(CONFIG_DYNAMIC_THREAD_STACK_SIZE)\n#endif /* !CONFIG_MPU_STACK_GUARD */\n#if defined(CONFIG_ARM_MPU) || defined(CONFIG_ARC_MPU)\n#endif /* CONFIG_ARM_MPU || CONFIG_ARC_MPU */",
  "result": "-/* On ARM & ARC MPU we may have two different alignment requirement\n+/* On ARM & ARC MPU & RISC-V PMP we may have two different alignment requirement\n-#if defined(CONFIG_ARM_MPU) || defined(CONFIG_ARC_MPU)\n+#if defined(CONFIG_ARM_MPU) || defined(CONFIG_ARC_MPU) || defined(CONFIG_RISCV_PMP)\n-#endif /* CONFIG_ARM_MPU || CONFIG_ARC_MPU */\n+#endif /* CONFIG_ARM_MPU || CONFIG_ARC_MPU || CONFIG_RISCV_PMP */\n-#ifndef CONFIG_MPU_STACK_GUARD\n+#if defined(CONFIG_MPU_STACK_GUARD) || defined(CONFIG_PMP_STACK_GUARD)\n-\tZ_THREAD_STACK_OBJ_ALIGN(CONFIG_PRIVILEGED_STACK_SIZE)\n+\tZ_THREAD_STACK_OBJ_ALIGN(CONFIG_DYNAMIC_THREAD_STACK_SIZE)\n-\tZ_THREAD_STACK_OBJ_ALIGN(CONFIG_DYNAMIC_THREAD_STACK_SIZE)\n-#endif /* !CONFIG_MPU_STACK_GUARD */\n+\tZ_THREAD_STACK_OBJ_ALIGN(CONFIG_PRIVILEGED_STACK_SIZE)\n+#endif /* CONFIG_MPU_STACK_GUARD || CONFIG_PMP_STACK_GUARD */\n-#if defined(CONFIG_ARM_MPU) || defined(CONFIG_ARC_MPU)\n+#if defined(CONFIG_ARM_MPU) || defined(CONFIG_ARC_MPU) || defined(CONFIG_RISCV_PMP)\n-#endif /* CONFIG_ARM_MPU || CONFIG_ARC_MPU */\n+#endif /* CONFIG_ARM_MPU || CONFIG_ARC_MPU || CONFIG_RISCV_PMP */"
},{
  "instruction": "boards: adi: Enable ADC driver for MAX32680EVKIT",
  "input": "",
  "result": "+| ADC       | on-chip    | adc                                 |\n+  - adc"
},{
  "instruction": "boards: adi: Enable ADC driver for MAX32 boards",
  "input": "",
  "result": "+| ADC       | on-chip    | adc                                 |\n+  - adc\n+| ADC       | on-chip    | adc                                 |\n+  - adc\n+| ADC       | on-chip    | adc                                 |\n+  - adc\n+| ADC       | on-chip    | adc                                 |\n+  - adc\n+| ADC       | on-chip    | adc                                 |\n+  - adc\n+| ADC       | on-chip    | adc                                 |\n+  - adc\n+| ADC       | on-chip    | adc                                 |\n+  - adc\n+| ADC       | on-chip    | adc                                 |\n+  - adc"
},{
  "instruction": "manifest: Update hal_adi to fix ADC build warnings",
  "input": "     revision: 1a700a62511c96d8c3d8b4e29c9503855fec50c5",
  "result": "-      revision: 1a700a62511c96d8c3d8b4e29c9503855fec50c5\n+      revision: a9ea9646a354bddf678c3ea5e4748ed1e38da542"
},{
  "instruction": "drivers: led: lp5562: reuse engine already linked",
  "input": "\tret = lp5562_get_available_engine(dev, &engine);\n\tret = lp5562_set_led_source(dev, led, engine);\n\tif (ret) {\n\t\tLOG_ERR(\"Failed to set LED source.\");\n\t\treturn ret;",
  "result": "-\tret = lp5562_get_available_engine(dev, &engine);\n+\t/*\n+\t * Read current \"led\" source setting. This is to check\n+\t * whether the \"led\" is in PWM mode or using an Engine.\n+\t */\n+\tret = lp5562_get_led_source(dev, led, &engine);\n-\tret = lp5562_set_led_source(dev, led, engine);\n-\tif (ret) {\n-\t\tLOG_ERR(\"Failed to set LED source.\");\n-\t\treturn ret;\n+\t/* Find and assign new engine only if the \"led\" is not using any. */\n+\tif (engine == LP5562_SOURCE_PWM) {\n+\t\tret = lp5562_get_available_engine(dev, &engine);\n+\t\tif (ret) {\n+\t\t\treturn ret;\n+\t\t}\n+\n+\t\tret = lp5562_set_led_source(dev, led, engine);\n+\t\tif (ret) {\n+\t\t\tLOG_ERR(\"Failed to set LED source.\");\n+\t\t\treturn ret;\n+\t\t}"
},{
  "instruction": "tests: drivers: Allow configurable i2c speed for bme688 test",
  "input": "\tuint32_t i2c_config = I2C_SPEED_SET(I2C_SPEED_FAST) | I2C_MODE_CONTROLLER;\n\tuint32_t i2c_config = I2C_SPEED_SET(I2C_SPEED_STANDARD) | I2C_MODE_CONTROLLER;",
  "result": "+# I2C BME688 test configuration options\n+# Copyright (c) 2024 Nordic Semiconductor ASA\n+# SPDX-License-Identifier: Apache-2.0\n+\n+config TEST_I2C_SPEED\n+\tint \"Select I2C speed used during the test, selectable options are: I2C_SPEED_STANDARD (0x1U), I2C_SPEED_FAST (0x2U), I2C_SPEED_FAST_PLUS (0x3U)\"\n+\tdefault 1\n+\n+source \"Kconfig.zephyr\"\n-\tuint32_t i2c_config = I2C_SPEED_SET(I2C_SPEED_FAST) | I2C_MODE_CONTROLLER;\n+\tuint32_t i2c_config = I2C_SPEED_SET(CONFIG_TEST_I2C_SPEED) | I2C_MODE_CONTROLLER;\n+\tTC_PRINT(\"I2C speed setting: %d\\n\", CONFIG_TEST_I2C_SPEED);\n-\tuint32_t i2c_config = I2C_SPEED_SET(I2C_SPEED_STANDARD) | I2C_MODE_CONTROLLER;\n+\tuint32_t i2c_config = I2C_SPEED_SET(CONFIG_TEST_I2C_SPEED) | I2C_MODE_CONTROLLER;\n+\tTC_PRINT(\"I2C speed setting: %d\\n\", CONFIG_TEST_I2C_SPEED);"
},{
  "instruction": "sample: uart passthrough: fix filtering and twister file",
  "input": "sample:\n name: UART Passthrough\ntests:\n sample.drivers.uart:\n   integration_platforms:\n     - qemu_x86\n   tags:\n     - serial\n     - uart\n   filter: CONFIG_SERIAL and\n           CONFIG_UART_INTERRUPT_DRIVEN and\n           dt_chosen_enabled(\"zephyr,console\") and\n           dt_chosen_enabled(\"uart,passthrough\")\n   harness: keyboard",
  "result": "+sample:\n+  name: UART Passthrough\n+tests:\n+  sample.drivers.uart.passthrough:\n+    platform_allow:\n+      - nucleo_l476rg\n+    tags:\n+      - serial\n+      - uart\n+    harness: keyboard\n-sample:\n-  name: UART Passthrough\n-tests:\n-  sample.drivers.uart:\n-    integration_platforms:\n-      - qemu_x86\n-    tags:\n-      - serial\n-      - uart\n-    filter: CONFIG_SERIAL and\n-            CONFIG_UART_INTERRUPT_DRIVEN and\n-            dt_chosen_enabled(\"zephyr,console\") and\n-            dt_chosen_enabled(\"uart,passthrough\")\n-    harness: keyboard"
},{
  "instruction": "sample: sip_svc: fix filter and printk formatting",
  "input": "   tags: subsys\n     filter: CONFIG_ARM_SIP_SVC_HAS_INTEL_SDM_MAILBOX_FIFO\n   integration_platforms:\n     - intel_socfpga_agilex_socdk\n\t\tprintk(\"Got response of transaction id 0x%02x and voltage is %fv\\n\", trans_id,\n\t\t       voltage);",
  "result": "-    tags: subsys\n+    tags:\n+      - sipsvc\n+    platform_allow:\n+      - intel_socfpga_agilex_socdk\n+    integration_platforms:\n+      - intel_socfpga_agilex_socdk\n-      filter: CONFIG_ARM_SIP_SVC_HAS_INTEL_SDM_MAILBOX_FIFO\n-    integration_platforms:\n-      - intel_socfpga_agilex_socdk\n-\t\tprintk(\"Got response of transaction id 0x%02x and voltage is %fv\\n\", trans_id,\n-\t\t       voltage);\n+\t\tprintk(\"Got response of transaction id 0x%02x and voltage is %fv\\n\",\n+\t\t\ttrans_id, (double)voltage);"
},{
  "instruction": "drivers: sensor: mcux_acmp: update mcux_acmp drivers",
  "input": "* Copyright 2022 NXP\n* Copyright 2022 NXP",
  "result": "- * Copyright 2022 NXP\n+ * Copyright 2022, 2024 NXP\n+#if MCUX_ACMP_HAS_HYSTCTR\n+#endif /* MCUX_ACMP_HAS_HYSTCTR */\n+#if MCUX_ACMP_HAS_HYSTCTR\n+#endif /* MCUX_ACMP_HAS_HYSTCTR */\n- * Copyright 2022 NXP\n+ * Copyright 2022, 2024 NXP\n+#if defined(FSL_FEATURE_ACMP_HAS_C0_HYSTCTR_BIT) && (FSL_FEATURE_ACMP_HAS_C0_HYSTCTR_BIT == 1U)\n+#define MCUX_ACMP_HAS_HYSTCTR 1\n+#else\n+#define MCUX_ACMP_HAS_HYSTCTR 0\n+#endif\n+"
},{
  "instruction": "doc: net: qemu: minor fixes",
  "input": "  socat PTY,link=/tmp/slip.devMAIN UNIX-LISTEN:/tmp/slip.sockMAIN\n  $ZEPHYR_BASE/../net-tools/tunslip6 -t tapMAIN -T -s /tmp/slip.devMAIN \\\n       2001:db8::1/64\n  socat PTY,link=/tmp/slip.devOTHER UNIX-LISTEN:/tmp/slip.sockOTHER\n  $ZEPHYR_BASE/../net-tools/tunslip6 -t tapOTHER -T -s /tmp/slip.devOTHER \\\n       2001:db8::1/64",
  "result": "+   sudo apt install -y socat libpcap-dev\n-   socat PTY,link=/tmp/slip.devMAIN UNIX-LISTEN:/tmp/slip.sockMAIN\n-   $ZEPHYR_BASE/../net-tools/tunslip6 -t tapMAIN -T -s /tmp/slip.devMAIN \\\n-        2001:db8::1/64\n+   socat PTY,link=/tmp/slip.devMAIN UNIX-LISTEN:/tmp/slip.sockMAIN &\n+   sudo $ZEPHYR_BASE/../net-tools/tunslip6 -t tapMAIN -T -s /tmp/slip.devMAIN 2001:db8::1/64 &\n-   socat PTY,link=/tmp/slip.devOTHER UNIX-LISTEN:/tmp/slip.sockOTHER\n-   $ZEPHYR_BASE/../net-tools/tunslip6 -t tapOTHER -T -s /tmp/slip.devOTHER \\\n-        2001:db8::1/64\n+   socat PTY,link=/tmp/slip.devOTHER UNIX-LISTEN:/tmp/slip.sockOTHER &\n+   sudo $ZEPHYR_BASE/../net-tools/tunslip6 -t tapOTHER -T -s /tmp/slip.devOTHER 2001:db8::1/64 &"
},{
  "instruction": "cmake: support PROPERTY argument on zephyr_link_libraries.",
  "input": " target_link_libraries(zephyr_interface INTERFACE ${ARGV})",
  "result": "-  target_link_libraries(zephyr_interface INTERFACE ${ARGV})\n+  if(ARGV0 STREQUAL \"PROPERTY\")\n+    if(ARGC GREATER 2)\n+      message(FATAL_ERROR \"zephyr_link_libraries(PROPERTY <prop>) only allows a single property.\")\n+    endif()\n+    target_link_libraries(zephyr_interface INTERFACE $<TARGET_PROPERTY:linker,${ARGV1}>)\n+  else()\n+    target_link_libraries(zephyr_interface INTERFACE ${ARGV})\n+  endif()"
},{
  "instruction": "cmake: fix check_set_linker_property() function",
  "input": " set(option ${LINKER_PROPERTY_PROPERTY})\n string(MAKE_C_IDENTIFIER check${option} check)\n set(SAVED_CMAKE_REQUIRED_FLAGS ${CMAKE_REQUIRED_FLAGS})\n set(CMAKE_REQUIRED_FLAGS \"${CMAKE_REQUIRED_FLAGS} ${option}\")\n zephyr_check_compiler_flag(C \"\" ${check})\n set(CMAKE_REQUIRED_FLAGS ${SAVED_CMAKE_REQUIRED_FLAGS})\n if(${${check}})\n   set_property(TARGET ${LINKER_PROPERTY_TARGET} ${APPEND} PROPERTY ${property} ${option})\n endif()",
  "result": "-  set(option ${LINKER_PROPERTY_PROPERTY})\n-  string(MAKE_C_IDENTIFIER check${option} check)\n+  foreach(option ${LINKER_PROPERTY_PROPERTY})\n+    string(MAKE_C_IDENTIFIER check${option} check)\n-  set(SAVED_CMAKE_REQUIRED_FLAGS ${CMAKE_REQUIRED_FLAGS})\n-  set(CMAKE_REQUIRED_FLAGS \"${CMAKE_REQUIRED_FLAGS} ${option}\")\n-  zephyr_check_compiler_flag(C \"\" ${check})\n-  set(CMAKE_REQUIRED_FLAGS ${SAVED_CMAKE_REQUIRED_FLAGS})\n+    set(SAVED_CMAKE_REQUIRED_FLAGS ${CMAKE_REQUIRED_FLAGS})\n+    set(CMAKE_REQUIRED_FLAGS \"${CMAKE_REQUIRED_FLAGS} ${option}\")\n+    zephyr_check_compiler_flag(C \"\" ${check})\n+    set(CMAKE_REQUIRED_FLAGS ${SAVED_CMAKE_REQUIRED_FLAGS})\n-  if(${${check}})\n-    set_property(TARGET ${LINKER_PROPERTY_TARGET} ${APPEND} PROPERTY ${property} ${option})\n-  endif()\n+    if(${${check}})\n+      set_property(TARGET ${LINKER_PROPERTY_TARGET} ${APPEND} PROPERTY ${property} ${option})\n+      set(APPEND \"APPEND\")\n+    endif()\n+  endforeach()"
},{
  "instruction": "cmake: remove llvm runtime library selection from target_base.cmake",
  "input": " if (CONFIG_LLVM_USE_LD)\n   if(CONFIG_LIBGCC_RTLIB)\n     set(runtime_lib \"libgcc\")\n   elseif(CONFIG_COMPILER_RT_RTLIB)\n     set(runtime_lib \"compiler_rt\")\n   endif()\n   zephyr_link_libraries(\n     --config ${ZEPHYR_BASE}/cmake/toolchain/llvm/clang_${runtime_lib}.cfg\n   )\n endif()\n if(CONFIG_LIBGCC_RTLIB)\n   set(runtime_lib \"libgcc\")\n elseif(CONFIG_COMPILER_RT_RTLIB)\n   set(runtime_lib \"compiler_rt\")\n endif()\n zephyr_link_libraries(\n   --config ${ZEPHYR_BASE}/cmake/toolchain/llvm/clang_${runtime_lib}.cfg\n )",
  "result": "-  if (CONFIG_LLVM_USE_LD)\n-    if(CONFIG_LIBGCC_RTLIB)\n-      set(runtime_lib \"libgcc\")\n-    elseif(CONFIG_COMPILER_RT_RTLIB)\n-      set(runtime_lib \"compiler_rt\")\n-    endif()\n-\n-    zephyr_link_libraries(\n-      --config ${ZEPHYR_BASE}/cmake/toolchain/llvm/clang_${runtime_lib}.cfg\n-    )\n-  endif()\n-\n-\n-  if(CONFIG_LIBGCC_RTLIB)\n-    set(runtime_lib \"libgcc\")\n-  elseif(CONFIG_COMPILER_RT_RTLIB)\n-    set(runtime_lib \"compiler_rt\")\n-  endif()\n-\n-  zephyr_link_libraries(\n-    --config ${ZEPHYR_BASE}/cmake/toolchain/llvm/clang_${runtime_lib}.cfg\n-  )"
},{
  "instruction": "cmake: toolchain: remove obsolete and unused macros",
  "input": "# Load toolchain_cc-family macros\nmacro(toolchain_cc_nostdinc)\n if(NOT \"${ARCH}\" STREQUAL \"posix\")\n   zephyr_compile_options( -nostdinc)\n endif()\nendmacro()\n# Load toolchain_cc-family macros\nmacro(toolchain_cc_nostdinc)\n   zephyr_compile_options( -nostdinc)\nendmacro()",
  "result": "-\n-# Load toolchain_cc-family macros\n-\n-macro(toolchain_cc_nostdinc)\n-  if(NOT \"${ARCH}\" STREQUAL \"posix\")\n-    zephyr_compile_options( -nostdinc)\n-  endif()\n-endmacro()\n-# Load toolchain_cc-family macros\n-macro(toolchain_cc_nostdinc)\n-    zephyr_compile_options( -nostdinc)\n-endmacro()\n-"
},{
  "instruction": "cmake: cleanup newlib CMakeLists.txt file",
  "input": "# LIBC_*_DIR may or may not have been set by the toolchain. E.g. when\n# unable to, it will be up to the user to specify LIBC_*_DIR vars to\n# point to a newlib implementation.  Note that this does not change the\n# directory order if LIBC_INCLUDE_DIR is already a system header\n# directory.\nif(LIBC_INCLUDE_DIR)\n zephyr_include_directories(${LIBC_INCLUDE_DIR})\nendif()",
  "result": "-# LIBC_*_DIR may or may not have been set by the toolchain. E.g. when\n+# LIBC_LIBRARY_DIR may or may not have been set by the toolchain. E.g. when\n-# unable to, it will be up to the user to specify LIBC_*_DIR vars to\n-# point to a newlib implementation.  Note that this does not change the\n-# directory order if LIBC_INCLUDE_DIR is already a system header\n-# directory.\n-\n-if(LIBC_INCLUDE_DIR)\n-  zephyr_include_directories(${LIBC_INCLUDE_DIR})\n-endif()\n-\n+# unable to, it will be up to the user to specify LIBC_LIBRARY_DIR vars to\n+# point to a newlib implementation."
},{
  "instruction": "drivers: sensors: explorir_m: fix uart flush early termination",
  "input": "\tdo {\n\t\tuart_poll_in(uart_dev, &tmp);\n\t} while (tmp != EXPLORIR_M_END_CHAR &&\n\t\t k_uptime_get_32() - uptime < EXPLORIR_M_MAX_RESPONSE_DELAY);",
  "result": "-\tdo {\n-\t\tuart_poll_in(uart_dev, &tmp);\n-\t} while (tmp != EXPLORIR_M_END_CHAR &&\n-\t\t k_uptime_get_32() - uptime < EXPLORIR_M_MAX_RESPONSE_DELAY);\n+\twhile (k_uptime_get_32() - uptime < EXPLORIR_M_MAX_RESPONSE_DELAY) {\n+\t\tif (uart_poll_in(uart_dev, &tmp) == 0 && tmp == EXPLORIR_M_END_CHAR) {\n+\t\t\tbreak;\n+\t\t}\n+\t}"
},{
  "instruction": "mgmt: mcumgr: os_mgmt: fix millisecond return",
  "input": "\t\t\".%d\"",
  "result": "+    * Fixed formatting of milliseconds in :c:enum:`OS_MGMT_ID_DATETIME_STR` by adding\n+      leading zeros.\n-\t\t\".%d\"\n+\t\t\".%03d\""
},{
  "instruction": "usb: device_next: msc: Allow user to sort LUNs",
  "input": "#define USBD_DEFINE_MSC_LUN(disk_name, t10_vendor, t10_product, t10_revision)\t\\\n\tSTRUCT_SECTION_ITERABLE(usbd_msc_lun, usbd_msc_lun_##disk_name) = {\t\\\n\t\t.disk = STRINGIFY(disk_name),\t\t\t\t\t\\\n\t\t.vendor = t10_vendor,\t\t\t\t\t\t\\\n\t\t.product = t10_product,\t\t\t\t\t\t\\\n\t\t.revision = t10_revision,\t\t\t\t\t\\\nUSBD_DEFINE_MSC_LUN(RAM, \"Zephyr\", \"RAMDisk\", \"0.00\");\nUSBD_DEFINE_MSC_LUN(NAND, \"Zephyr\", \"FlashDisk\", \"0.00\");\nUSBD_DEFINE_MSC_LUN(SD, \"Zephyr\", \"SD\", \"0.00\");",
  "result": "+ * @param id Identifier by which the linker sorts registered LUNs\n-#define USBD_DEFINE_MSC_LUN(disk_name, t10_vendor, t10_product, t10_revision)\t\\\n-\tSTRUCT_SECTION_ITERABLE(usbd_msc_lun, usbd_msc_lun_##disk_name) = {\t\\\n-\t\t.disk = STRINGIFY(disk_name),\t\t\t\t\t\\\n-\t\t.vendor = t10_vendor,\t\t\t\t\t\t\\\n-\t\t.product = t10_product,\t\t\t\t\t\t\\\n-\t\t.revision = t10_revision,\t\t\t\t\t\\\n+#define USBD_DEFINE_MSC_LUN(id, disk_name, t10_vendor, t10_product, t10_revision)\t\\\n+\tstatic const STRUCT_SECTION_ITERABLE(usbd_msc_lun, usbd_msc_lun_##id) = {\t\\\n+\t\t.disk = disk_name,\t\t\t\t\t\t\t\\\n+\t\t.vendor = t10_vendor,\t\t\t\t\t\t\t\\\n+\t\t.product = t10_product,\t\t\t\t\t\t\t\\\n+\t\t.revision = t10_revision,\t\t\t\t\t\t\\\n-USBD_DEFINE_MSC_LUN(RAM, \"Zephyr\", \"RAMDisk\", \"0.00\");\n+USBD_DEFINE_MSC_LUN(ram, \"RAM\", \"Zephyr\", \"RAMDisk\", \"0.00\");\n-USBD_DEFINE_MSC_LUN(NAND, \"Zephyr\", \"FlashDisk\", \"0.00\");\n+USBD_DEFINE_MSC_LUN(nand, \"NAND\", \"Zephyr\", \"FlashDisk\", \"0.00\");\n-USBD_DEFINE_MSC_LUN(SD, \"Zephyr\", \"SD\", \"0.00\");\n+USBD_DEFINE_MSC_LUN(sd, \"SD\", \"Zephyr\", \"SD\", \"0.00\");"
},{
  "instruction": "tests: cpp: Exclude nRF54L20 platform from cpp98 test",
  "input": "",
  "result": "+      - nrf54l20pdk/nrf54l20/cpuapp"
},{
  "instruction": "doc: rpi_pico fix I2C1 default peripheral mapping",
  "input": "",
  "result": ""
},{
  "instruction": "drivers: serial: uart_nrfx_uarte: Patch RX init",
  "input": "\t/**\n\t * Stop any currently running RX operations. This can occur when a\n\t * bootloader sets up the UART hardware and does not clean it up\n\t * before jumping to the next application.\n\t */\n\tif (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_RXSTARTED)) {\n\t\tnrf_uarte_task_trigger(uarte, NRF_UARTE_TASK_STOPRX);\n\t\twhile (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_RXTO) &&\n\t\t       !nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ERROR)) {\n\t\t\t/* Busy wait for event to register */\n\t\t}\n\t\tnrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_RXSTARTED);\n\t\tnrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_ENDRX);\n\t\tnrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_RXTO);\n\t}\n\t\t\twhile (!nrf_uarte_event_check(uarte,\n\t\t\t\t\t\t      NRF_UARTE_EVENT_RXTO) &&\n\t\t\t       !nrf_uarte_event_check(uarte,\n\t\t\t\t\t\t      NRF_UARTE_EVENT_ERROR)) {",
  "result": "-\t/**\n-\t * Stop any currently running RX operations. This can occur when a\n-\t * bootloader sets up the UART hardware and does not clean it up\n-\t * before jumping to the next application.\n-\t */\n-\tif (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_RXSTARTED)) {\n-\t\tnrf_uarte_task_trigger(uarte, NRF_UARTE_TASK_STOPRX);\n-\t\twhile (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_RXTO) &&\n-\t\t       !nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ERROR)) {\n-\t\t\t/* Busy wait for event to register */\n-\t\t}\n-\t\tnrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_RXSTARTED);\n-\t\tnrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_ENDRX);\n-\t\tnrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_RXTO);\n-\t}\n-\n-\t\t\twhile (!nrf_uarte_event_check(uarte,\n-\t\t\t\t\t\t      NRF_UARTE_EVENT_RXTO) &&\n-\t\t\t       !nrf_uarte_event_check(uarte,\n-\t\t\t\t\t\t      NRF_UARTE_EVENT_ERROR)) {\n+\t\t\twhile (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_RXTO)) {\n+\t\t\tnrf_uarte_event_clear(uarte, NRF_UARTE_EVENT_ERROR);"
},{
  "instruction": "Bluetooth: Mesh: Logic fix for recvd unseg msgs",
  "input": "",
  "result": "+\n+\t\t/* Avoid further processing of unsegmented messages that are not a\n+\t\t * local match nor a Friend match, with the exception of ctl messages.\n+\t\t */\n+\t\tif (!rx->ctl && !rx->local_match && !rx->friend_match) {\n+\t\t\treturn 0;\n+\t\t}\n+"
},{
  "instruction": "tests: drivers: mbox: mbox_error_cases: Fix for BUS FAULT on nrf54l15",
  "input": "     - nrf54l15pdk/nrf54l15/cpuapp\nZTEST(mbox_error_cases, test_05d_mbox_set_enabled_on_already_disabled_rx_channel)",
  "result": "-      - nrf54l15pdk/nrf54l15/cpuapp\n+\n+  tests.drivers.mbox_error_cases.nrf54l:\n+    platform_allow:\n+      - nrf54l15pdk/nrf54l15/cpuapp\n+    integration_platforms:\n+      - nrf54l15pdk/nrf54l15/cpuapp\n+    extra_args: SNIPPET=nordic-flpr\n-ZTEST(mbox_error_cases, test_05d_mbox_set_enabled_on_already_disabled_rx_channel)\n+ZTEST(mbox_error_cases, test_05d_mbox_set_disable_on_already_disabled_rx_channel)"
},{
  "instruction": "tests: drivers: mbox: mbox_error_cases: Enable test on nRF54l15",
  "input": "",
  "result": "+/*\n+ * Copyright 2024 Nordic Semiconductor ASA\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+/ {\n+\tmbox-consumer {\n+\t\tcompatible = \"vnd,mbox-consumer\";\n+\t\tmboxes = <&cpuapp_vevif_tx 16>, <&cpuapp_vevif_tx 32>,\n+\t\t\t\t <&cpuapp_vevif_rx 15>, <&cpuapp_vevif_rx 32>;\n+\t\tmbox-names = \"remote_valid\", \"remote_incorrect\",\n+\t\t\t\t\t \"local_valid\", \"local_incorrect\";\n+\n+\t};\n+};\n+\n+&cpuapp_vevif_rx {\n+\tstatus = \"okay\";\n+};\n+\n+&cpuapp_vevif_tx {\n+\tstatus = \"okay\";\n+};\n+      - nrf54l15pdk/nrf54l15/cpuapp"
},{
  "instruction": "drivers: mbox: Fix error code in Nordic's implementation",
  "input": "\t\treturn -ENOTSUP;\n\t\treturn -ENOTSUP;\n\t\treturn -ENOTSUP;",
  "result": "-\t\treturn -ENOTSUP;\n+\t\treturn -EMSGSIZE;\n-\t\treturn -ENOTSUP;\n+\t\treturn -EMSGSIZE;\n-\t\treturn -ENOTSUP;\n+\t\treturn -EMSGSIZE;"
},{
  "instruction": "zbus: separate clang-format control comments",
  "input": "",
  "result": "+\n+\n+\n+\n+"
},{
  "instruction": "i2c: i2c_nrfx_twim: init semaphores in init function",
  "input": "\tstatic struct i2c_nrfx_twim_data twim_##idx##_data = {\t\t       \\\n\t\t.transfer_sync = Z_SEM_INITIALIZER(\t\t\t       \\\n\t\t\ttwim_##idx##_data.transfer_sync, 1, 1),\t\t       \\\n\t\t.completion_sync = Z_SEM_INITIALIZER(\t\t\t       \\\n\t\t\ttwim_##idx##_data.completion_sync, 0, 1),\t       \\\n\t};\t\t\t\t\t\t\t\t       \\",
  "result": "+\tk_sem_init(&dev_data->transfer_sync, 1, 1);\n+\tk_sem_init(&dev_data->completion_sync, 0, 1);\n+\n-\tstatic struct i2c_nrfx_twim_data twim_##idx##_data = {\t\t       \\\n-\t\t.transfer_sync = Z_SEM_INITIALIZER(\t\t\t       \\\n-\t\t\ttwim_##idx##_data.transfer_sync, 1, 1),\t\t       \\\n-\t\t.completion_sync = Z_SEM_INITIALIZER(\t\t\t       \\\n-\t\t\ttwim_##idx##_data.completion_sync, 0, 1),\t       \\\n-\t};\t\t\t\t\t\t\t\t       \\\n+\tstatic struct i2c_nrfx_twim_data twim_##idx##_data;\t\t       \\"
},{
  "instruction": "i2c: i2c_nrfx_twim: move `msg_buf` to config",
  "input": "\tuint8_t *msg_buf;\n\tuint8_t *msg_buf = dev_data->msg_buf;\n\t\tIF_ENABLED(USES_MSG_BUF(idx),\t\t\t\t       \\\n\t\t\t(.msg_buf = twim_##idx##_msg_buf,))\t\t       \\",
  "result": "-\tuint8_t *msg_buf;\n+\tuint8_t *msg_buf;\n-\tuint8_t *msg_buf = dev_data->msg_buf;\n+\tuint8_t *msg_buf = dev_config->msg_buf;\n-\t\tIF_ENABLED(USES_MSG_BUF(idx),\t\t\t\t       \\\n-\t\t\t(.msg_buf = twim_##idx##_msg_buf,))\t\t       \\\n+\t\tIF_ENABLED(USES_MSG_BUF(idx),\t\t\t\t       \\\n+\t\t\t(.msg_buf = twim_##idx##_msg_buf,))\t\t       \\"
},{
  "instruction": "fs: nvs: fix nvs static analysis error",
  "input": "\tuint8_t write_block_size = fs->flash_parameters->write_block_size;",
  "result": "-\tuint8_t write_block_size = fs->flash_parameters->write_block_size;\n+\tsize_t write_block_size = fs->flash_parameters->write_block_size;"
},{
  "instruction": "doc: remove unnecessary heading",
  "input": "Sections\n********",
  "result": "-Sections\n-********\n-"
},{
  "instruction": "doc: shorten descriptions of doc homepage grid items",
  "input": "   border-radius: 0.5rem;\n\t   <p>Introducing the Zephyr Project: overview, architecture, features, and licensing</p>\n\t   <p>Follow this guide to set up a Zephyr development environment on your\n\t       system, and then build and run a sample application.</p>\n\t   <p>As an open-source project, we welcome and encourage the community\n          to submit patches directly to the project.</p>\n\t   <p>A list of samples and demos that can run on a variety of boards supported\n\t       by Zephyr</p>\n\t   <p>Information about supported architectures, supported hardware and porting guides</p>\n\t   <p>Requirements, processes, and developer guidelines for ensuring security is addressed within the Zephyr project.</p>\n\t   <p>List of supported boards and platforms.</p>\n\t   <p>OS Services and guides how to use them with Zephyr</p>",
  "result": "-    border-radius: 0.5rem;\n+    border-radius: 1rem;\n+    font-weight: 200;\n+    margin-left: -0.9em;\n+    margin-right: -0.9em;\n+    line-height: 1.4rem;\n-\t   <p>Introducing the Zephyr Project: overview, architecture, features, and licensing</p>\n+\t   <p>Architecture, features &amp; licensing details</p>\n-\t   <p>Follow this guide to set up a Zephyr development environment on your\n-\t       system, and then build and run a sample application.</p>\n+\t   <p>Set up Zephyr, build &amp; run a sample application</p>\n-\t   <p>As an open-source project, we welcome and encourage the community\n-           to submit patches directly to the project.</p>\n+\t   <p>How to submit patches and contribute to Zephyr</p>\n-\t   <p>A list of samples and demos that can run on a variety of boards supported\n-\t       by Zephyr</p>\n+\t   <p>Explore samples and demos for various boards</p>\n-\t   <p>Information about supported architectures, supported hardware and porting guides</p>\n+\t   <p>Supported hardware and porting guides</p>\n-\t   <p>Requirements, processes, and developer guidelines for ensuring security is addressed within the Zephyr project.</p>\n+\t   <p>Security processes and guidelines</p>\n-\t   <p>List of supported boards and platforms.</p>\n+\t   <p>List of supported boards and platforms</p>\n-\t   <p>OS Services and guides how to use them with Zephyr</p>\n+\t   <p>OS Services and usage guides</p>"
},{
  "instruction": "cmake: emu: qemu: pkill monitor_15_4",
  "input": "     # TODO: Support cleanup of the monitor_15_4 process",
  "result": "+      COMMAND\n+      #Disable Ctrl-C to ensure that users won't accidentally exit\n+      #w/o killing the monitor.\n+      stty intr ^d\n-      # TODO: Support cleanup of the monitor_15_4 process\n+      )\n+    set(POST_QEMU_COMMANDS_FOR_server\n+      COMMAND\n+      # Kill the monitor_15_4 sub-process\n+      pkill -P $$$$\n+    ${POST_QEMU_COMMANDS_FOR_${target}}"
},{
  "instruction": "west.yml: MCUboot synchronization from upstream",
  "input": "     revision: fb2cf0ec3da3687b93f28e556ab682bdd4b85223",
  "result": "-      revision: fb2cf0ec3da3687b93f28e556ab682bdd4b85223\n+      revision: 52e2afc2f809c424b0f337f56059d1dfcc7e6d98"
},{
  "instruction": "west.yml: update hal_espressif",
  "input": "     revision: 8c2ae3b0017cadac3de1f57592e879a7bb6ef75d",
  "result": "-      revision: 8c2ae3b0017cadac3de1f57592e879a7bb6ef75d\n+      revision: e589b872d92d8515ce512b2d34f255d0bccb0e0f"
},{
  "instruction": "modules: trusted-firmware-m: pull in MCUboot fixes",
  "input": "     revision: 069455be098383bf96eab73e3ff8e0c66c60fa5a",
  "result": "-      revision: 069455be098383bf96eab73e3ff8e0c66c60fa5a\n+      revision: a11cd27905aecc4416cfc85552bfc3b997375056"
},{
  "instruction": "tests: rtc_api: Add conf files for xmc4(75)_relax_kit boards",
  "input": "",
  "result": "+CONFIG_RTC_UPDATE=y\n+CONFIG_RTC_ALARM=y\n+CONFIG_TEST_RTC_ALARM_TIME_MASK=63\n+CONFIG_RTC_UPDATE=y\n+CONFIG_RTC_ALARM=y\n+CONFIG_TEST_RTC_ALARM_TIME_MASK=63"
},{
  "instruction": "boards: infineon: Add RTC to xmc4(75)_relax_kit boards",
  "input": "",
  "result": "+| RTC       | on-chip    | rtc                   |\n+\t\trtc = &rtc;\n+\n+&rtc {\n+\tstatus = \"okay\";\n+};\n+  - rtc\n+| RTC       | on-chip    | rtc                   |\n+\t\trtc = &rtc;\n+&rtc {\n+\tstatus = \"okay\";\n+};\n+\n+  - rtc"
},{
  "instruction": "tests: drivers: rtc: Fix typos",
  "input": "\tzassert_true((datetime_get.tm_nsec > -1) && (datetime_get.tm_yday < 1000000000),\n\t\t     \"Invalid tm_yday\");",
  "result": "-\tzassert_true((datetime_get.tm_nsec > -1) && (datetime_get.tm_yday < 1000000000),\n-\t\t     \"Invalid tm_yday\");\n+\tzassert_true((datetime_get.tm_nsec > -1) && (datetime_get.tm_nsec < 1000000000),\n+\t\t     \"Invalid tm_nsec\");"
},{
  "instruction": "shell: backends: rtt: Set panic_mode flag",
  "input": "",
  "result": "+\t\tif (IS_ENABLED(CONFIG_LOG_MODE_DEFERRED) && IS_ENABLED(CONFIG_SHELL_LOG_BACKEND)) {\n+\t\t\tpanic_mode = true;\n+\t\t}"
},{
  "instruction": "include: cbprintf: drop deprecated CBPRINTF_PACKAGE_COPY_* macros",
  "input": "/** @deprecated Use @ref CBPRINTF_PACKAGE_CONVERT_RO_STR instead. */\n#define CBPRINTF_PACKAGE_COPY_RO_STR CBPRINTF_PACKAGE_CONVERT_RO_STR __DEPRECATED_MACRO\n/** @deprecated Use @ref CBPRINTF_PACKAGE_CONVERT_RW_STR instead. */\n#define CBPRINTF_PACKAGE_COPY_RW_STR CBPRINTF_PACKAGE_CONVERT_RW_STR __DEPRECATED_MACRO\n/** @deprecated Use @ref CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR instead. */\n#define CBPRINTF_PACKAGE_COPY_KEEP_RO_STR CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR __DEPRECATED_MACRO",
  "result": "+* ``CBPRINTF_PACKAGE_COPY_*`` macros, deprecated since Zephyr 3.5.0, have been removed.\n-/** @deprecated Use @ref CBPRINTF_PACKAGE_CONVERT_RO_STR instead. */\n-#define CBPRINTF_PACKAGE_COPY_RO_STR CBPRINTF_PACKAGE_CONVERT_RO_STR __DEPRECATED_MACRO\n-/** @deprecated Use @ref CBPRINTF_PACKAGE_CONVERT_RW_STR instead. */\n-#define CBPRINTF_PACKAGE_COPY_RW_STR CBPRINTF_PACKAGE_CONVERT_RW_STR __DEPRECATED_MACRO\n-/** @deprecated Use @ref CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR instead. */\n-#define CBPRINTF_PACKAGE_COPY_KEEP_RO_STR CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR __DEPRECATED_MACRO"
},{
  "instruction": "boards: ezurio: fix qspi definition",
  "input": "config NORDIC_QSPI_NOR\n\tdefault BOOTLOADER_MCUBOOT\n\tdefault 4096 if NORDIC_QSPI_NOR\nconfig NORDIC_QSPI_NOR\n\tdefault BOOTLOADER_MCUBOOT\n\tdefault 4096 if NORDIC_QSPI_NOR",
  "result": "-config NORDIC_QSPI_NOR\n-\tdefault BOOTLOADER_MCUBOOT\n-\n-\tdefault 4096 if NORDIC_QSPI_NOR\n+\tdefault 4096\n-config NORDIC_QSPI_NOR\n-\tdefault BOOTLOADER_MCUBOOT\n-\n-\tdefault 4096 if NORDIC_QSPI_NOR\n+\tdefault 4096"
},{
  "instruction": "xtensa: fix xtensa-sample-controller.ld to avoid .note.GNU-stack warnings",
  "input": "",
  "result": "+\n+  /DISCARD/ : { *(.note.GNU-stack) }"
},{
  "instruction": "soc: stm32 decrease ticks per sec if sysclock is not LPTIM",
  "input": "# Tick of 10000 is too high for a sysclock lower than 32MHz",
  "result": "-# Tick of 10000 is too high for a sysclock lower than 32MHz\n+# If sysclock is not LPTIM, tick of 10000 is too high for a frequency lower than 32MHz\n+\tdepends on !STM32_LPTIM_TIMER"
},{
  "instruction": "MAINTAINERS: hawkBit: remove ycsin from the collaborator",
  "input": " collaborators:\n   - ycsin",
  "result": "-  collaborators:\n-    - ycsin"
},{
  "instruction": "doc: Check redirect entries are valid",
  "input": "def create_redirect_pages(app, docname):",
  "result": "+from sphinx.util import logging\n+\n+logger = logging.getLogger(__name__)\n-def create_redirect_pages(app, docname):\n+def create_redirect_pages(app, exception):\n+        # check that new_url is a valid docname, or if not that it is at least\n+        # covered as the \"old\" part of another redirect rule\n+        if new_url not in app.env.all_docs and not any(\n+            old == new_url for (old, _) in app.config.html_redirect_pages\n+        ):\n+            logger.warning(\n+                f\"{new_url} is not a valid destination for a redirect.\"\n+                \"Check that both the source and destination are complete docnames.\"\n+            )\n+"
},{
  "instruction": "doc: release: 4.0: Add note about .elf flash support",
  "input": "",
  "result": "+* Added support for .elf files to the west flash command for jlink, pyocd and linkserver runners.\n+"
},{
  "instruction": "net: l2: ethernet: check if the dev->api not NULL",
  "input": "\tconst struct device *dev;\n\tconst struct ethernet_api *api;\n\tdev = net_if_get_device(iface);\n\tapi = dev->api;\n\tif (!(net_eth_get_hw_capabilities(iface) & ETHERNET_HW_FILTERING) || api->set_config == NULL) {",
  "result": "-\tconst struct device *dev;\n-\tconst struct ethernet_api *api;\n+\n+\tconst struct device *dev = net_if_get_device(iface);\n+\tconst struct ethernet_api *api = dev->api;\n-\tdev = net_if_get_device(iface);\n-\tapi = dev->api;\n+\tif (!(net_eth_get_hw_capabilities(iface) & ETHERNET_HW_FILTERING)) {\n+\t\treturn;\n+\t}\n-\tif (!(net_eth_get_hw_capabilities(iface) & ETHERNET_HW_FILTERING) || api->set_config == NULL) {\n+\tif (!api || !api->set_config) {"
},{
  "instruction": "net: l2: ethernet: check if the dev->api->send method not NULL",
  "input": "",
  "result": "+\tif (!api->send) {\n+\t\tret = -ENOTSUP;\n+\t\tgoto error;\n+\t}\n+"
},{
  "instruction": "net: l2: ethernet: check if the dev->api->get_capabilities method not NULL",
  "input": "\tconst struct ethernet_api *eth =\n\t\t(struct ethernet_api *)net_if_get_device(iface)->api;\n\tif (!eth->get_capabilities) {\n\treturn eth->get_capabilities(net_if_get_device(iface));\n\tconst struct device *dev = net_if_get_device(iface);\n\tconst struct ethernet_api *api = dev->api;\n\treturn (api->get_capabilities(dev) & ETHERNET_HW_VLAN_TAG_STRIP);\n\tif (!(api->get_capabilities(dev) & ETHERNET_HW_FILTERING) || api->set_config == NULL) {\n\tif (!(api->get_capabilities(dev) & ETHERNET_PTP)) {\n\tif (!api) {\n\treturn !!(api->get_capabilities(dev) & caps);",
  "result": "-\tconst struct ethernet_api *eth =\n-\t\t(struct ethernet_api *)net_if_get_device(iface)->api;\n+\tconst struct device *dev = net_if_get_device(iface);\n+\tconst struct ethernet_api *api = (struct ethernet_api *)dev->api;\n-\tif (!eth->get_capabilities) {\n+\tif (!api || !api->get_capabilities) {\n-\treturn eth->get_capabilities(net_if_get_device(iface));\n+\treturn api->get_capabilities(dev);\n-\tconst struct device *dev = net_if_get_device(iface);\n-\tconst struct ethernet_api *api = dev->api;\n-\n-\treturn (api->get_capabilities(dev) & ETHERNET_HW_VLAN_TAG_STRIP);\n+\treturn (net_eth_get_hw_capabilities(iface) & ETHERNET_HW_VLAN_TAG_STRIP);\n-\tif (!(api->get_capabilities(dev) & ETHERNET_HW_FILTERING) || api->set_config == NULL) {\n+\tif (!(net_eth_get_hw_capabilities(iface) & ETHERNET_HW_FILTERING) || api->set_config == NULL) {\n-\tif (!(api->get_capabilities(dev) & ETHERNET_PTP)) {\n+\tif (!(net_eth_get_hw_capabilities(iface) & ETHERNET_PTP)) {\n-\tif (!api) {\n+\tif (!api || !api->get_capabilities) {\n-\treturn !!(api->get_capabilities(dev) & caps);\n+\treturn ((api->get_capabilities(dev) & caps) != 0);"
},{
  "instruction": "drivers: wifi: nxp: link the library of hostap",
  "input": "",
  "result": "-\n+zephyr_library_link_libraries_ifdef(CONFIG_WIFI_NM_WPA_SUPPLICANT hostap)"
},{
  "instruction": "hostap: fix build error of common.h",
  "input": "zephyr_library()\n\t${HOSTAP_SRC_BASE}/utils/",
  "result": "-zephyr_library()\n+zephyr_interface_library_named(hostap)\n-\t${HOSTAP_SRC_BASE}/utils/\n+target_include_directories(hostap INTERFACE\n+\t${HOSTAP_SRC_BASE}/utils/\n+)\n+"
},{
  "instruction": "arm/gicv3: set routing affinity before enable IRQ",
  "input": "\tsys_write32(mask, ISENABLER(GET_DIST_BASE(intid), idx));",
  "result": "-\tsys_write32(mask, ISENABLER(GET_DIST_BASE(intid), idx));\n-\n+\n+\tsys_write32(mask, ISENABLER(GET_DIST_BASE(intid), idx));"
},{
  "instruction": "manifest: Update nRF hw models to latest",
  "input": "     revision: 6e70c2dc5d4c67c4da5913b2969c0774b27f0cd0",
  "result": "-      revision: 6e70c2dc5d4c67c4da5913b2969c0774b27f0cd0\n+      revision: 4b0b020e25dbf1a11ccccf7b7741d6ca991ba9e4"
},{
  "instruction": "boards: nrf54l15bsim: Compare it to the DK instead of the PDK",
  "input": "Just like for the nrf54l15pdk target,\nand will use the same drivers as the nrf54l15pdk targets for these.",
  "result": "-Just like for the nrf54l15pdk target,\n+Just like for the nrf54l15dk target,\n-and will use the same drivers as the nrf54l15pdk targets for these.\n+and will use the same drivers as the nrf54l15dk targets for these."
},{
  "instruction": "boards: nrf54l15_bsim: Update docs including AAR,CCM, ECB",
  "input": "  This target is experimental, and even though it includes models of the RADIO, it does not yet\n  include models of the AAR, CCM or ECB peripherals, so the BLE and 802.15.4 stacks can only be\n  run without encryption or privacy features so far.",
  "result": "-   This target is experimental, and even though it includes models of the RADIO, it does not yet\n-   include models of the AAR, CCM or ECB peripherals, so the BLE and 802.15.4 stacks can only be\n-   run without encryption or privacy features so far.\n+   This target is experimental.\n+* AAR (Accelerated Address Resolver)\n+* CCM (AES CCM mode encryption)\n+* ECB (AES electronic codebook mode encryption)"
},{
  "instruction": "boards: nrf54l15_bsim: Actively set psa-rng to disabled",
  "input": "",
  "result": "+\n+\tpsa_rng: psa-rng {\n+\t\tstatus = \"disabled\";\n+\t};"
},{
  "instruction": "board: imx93_evk: fix document introduced by hwmv2",
  "input": "  :board: mimx93_evk/mimx9352/a55\n  :goals: run\n   *** Booting Zephyr OS build zephyr-v3.2.0-8-g1613870534a0  ***\n   thread_a: Hello World from cpu 0 on mimx93_evk_a55!\n   thread_b: Hello World from cpu 0 on mimx93_evk_a55!\n   thread_a: Hello World from cpu 0 on mimx93_evk_a55!\n   thread_b: Hello World from cpu 0 on mimx93_evk_a55!",
  "result": "-   :board: mimx93_evk/mimx9352/a55\n-   :goals: run\n+   :board: imx93_evk/mimx9352/a55\n+   :goals: build\n-    *** Booting Zephyr OS build zephyr-v3.2.0-8-g1613870534a0  ***\n-    thread_a: Hello World from cpu 0 on mimx93_evk_a55!\n-    thread_b: Hello World from cpu 0 on mimx93_evk_a55!\n-    thread_a: Hello World from cpu 0 on mimx93_evk_a55!\n-    thread_b: Hello World from cpu 0 on mimx93_evk_a55!\n+    *** Booting Zephyr OS build Booting Zephyr OS build v3.7.0-2055-g630f27a5a867  ***\n+    thread_a: Hello World from cpu 0 on imx93_evk!\n+    thread_b: Hello World from cpu 0 on imx93_evk!\n+    thread_a: Hello World from cpu 0 on imx93_evk!\n+    thread_b: Hello World from cpu 0 on imx93_evk!"
},{
  "instruction": "boards: nrf54l15bsim: DTS cleanup",
  "input": "\t\t/delete-node/ spu@50003000;\n\t\t/delete-node/ gpiote@5000d000;\n\t\t/delete-node/ crypto@50844000;",
  "result": "-\t\t/delete-node/ spu@50003000;\n-\t\t/delete-node/ gpiote@5000d000;\n-\t\t/delete-node/ crypto@50844000;"
},{
  "instruction": "boards: xtensa/sample_controller: no HAL for xcc or xt-clang",
  "input": "\tselect XTENSA_HAL",
  "result": "-\tselect XTENSA_HAL\n+\tselect XTENSA_HAL if (\"$(ZEPHYR_TOOLCHAIN_VARIANT)\" != \"xcc\" && \"$(ZEPHYR_TOOLCHAIN_VARIANT)\" != \"xt-clang\")"
},{
  "instruction": "drivers: stm32: Select PINCTRL when required",
  "input": "\tbool \"Pin controller driver for STM32 MCUs\"",
  "result": "+\tselect PINCTRL\n+\tselect PINCTRL\n+\tselect PINCTRL\n+\tselect PINCTRL\n+\tselect PINCTRL\n+\tselect PINCTRL\n+\tselect PINCTRL\n+\tselect PINCTRL\n+\tselect PINCTRL\n+\tselect PINCTRL\n+\tselect PINCTRL\n+\tselect PINCTRL\n+\tselect PINCTRL\n-\tbool \"Pin controller driver for STM32 MCUs\"\n+\tbool\n+\tselect PINCTRL\n+\tselect PINCTRL\n+\tselect PINCTRL\n+\tselect PINCTRL\n+\tselect PINCTRL\n+\tselect PINCTRL\n+\tselect PINCTRL\n+\tselect PINCTRL\n+\tselect PINCTRL"
},{
  "instruction": "modules: hostap: Fix Kconfig parameters for build",
  "input": "",
  "result": "+\tselect MBEDTLS_MD5\n+\tselect MBEDTLS_TLS_VERSION_1_2"
},{
  "instruction": "modules: hostap: CRYPTO_MBEDTLS_PSA should not be default selected",
  "input": "\tdefault y if WIFI_NM_WPA_SUPPLICANT_CRYPTO_ALT",
  "result": "-\tdefault y if WIFI_NM_WPA_SUPPLICANT_CRYPTO_ALT"
},{
  "instruction": "modules: hostap: Set WIFI_NM_WPA_SUPPLICANT_CRYPTO_ALT as crypto",
  "input": "\tdefault WIFI_NM_WPA_SUPPLICANT_CRYPTO\n\t  WIFI_NM_WPA_SUPPLICANT_CRYPTO_ALT support enterprise\n\t  and DPP. And use Mbedtls PSA apis for HW acceleration.",
  "result": "-\tdefault WIFI_NM_WPA_SUPPLICANT_CRYPTO\n+\tdefault WIFI_NM_WPA_SUPPLICANT_CRYPTO_ALT\n-\t  WIFI_NM_WPA_SUPPLICANT_CRYPTO_ALT support enterprise\n-\t  and DPP. And use Mbedtls PSA apis for HW acceleration.\n+\t  WIFI_NM_WPA_SUPPLICANT_CRYPTO_ALT supports enterprise mode\n+\t  and DPP."
},{
  "instruction": "drivers: counter: nrfx_timer: Add barrier when reading CC",
  "input": "",
  "result": "+\tnrf_barrier_w();\n+\tnrf_barrier_r();"
},{
  "instruction": "tests: drivers: regulator: add test for mps mpm54304 driver",
  "input": "",
  "result": "+\n+mpm54304@7 {\n+\tcompatible = \"mps,mpm54304\";\n+\treg = <0x7>;\n+\n+\tBUCK1 {};\n+\tBUCK2 {};\n+\tBUCK3 {};\n+\tBUCK4 {};\n+};"
},{
  "instruction": "odroid_go: Enable CONFIG_ESP32_USE_UNSUPPORTED_REVISION",
  "input": "",
  "result": "+\n+CONFIG_ESP32_USE_UNSUPPORTED_REVISION=y"
},{
  "instruction": "fs: fatfs: Add CONFIG_FS_MULTI_PARTITION",
  "input": "",
  "result": "+#if defined(CONFIG_FS_FATFS_MULTI_PARTITION)\n+#undef FF_MULTI_PARTITION\n+#define FF_MULTI_PARTITION\tCONFIG_FS_FATFS_MULTI_PARTITION\n+#endif /* defined(CONFIG_FS_FATFS_MULTI_PARTITION) */\n+\n+config FS_FATFS_MULTI_PARTITION\n+\tbool \"Support for multiple volumes on the physical drive\"\n+\thelp\n+\t  When this function is enabled, each logical drive number can\n+\t  be bound to arbitrary physical drive and partition listed\n+\t  in the VolToPart[] of the fatfs module. The VolToPart[] is expected to be\n+\t  provided by Zephyr application.\n+\t  The mount points have to be numbered in this case.\n+\t  For example, 2 FAT partition on SD disk (3) in terms of Zephyr:\n+\t    {3, 1} - mount point \"/0:\"\n+\t    {3, 2} - mount point \"/1:\"\n+\t  When disabled (default), each logical drive number is bound to the same\n+\t  physical drive number and only an FAT volume found on the physical drive\n+\t  will be mounted.\n+"
},{
  "instruction": "fs: fatfs: Add CONFIG_FS_FATFS_LBA64",
  "input": "",
  "result": "+#if defined(CONFIG_FS_FATFS_LBA64)\n+#undef FF_LBA64\n+#define FF_LBA64\t\tCONFIG_FS_FATFS_LBA64\n+#endif /* defined(CONFIG_FS_FATFS_LBA64) */\n+\n+config FS_FATFS_LBA64\n+\tbool \"Support for 64-bit LBA\"\n+\tdepends on FS_FATFS_EXFAT\n+\thelp\n+\t  This option enables support for 64-bit LBA, which also\n+\t  enables GPT support.\n+"
},{
  "instruction": "dts: arm: st: correct npgios for all stm32 gpio controllers",
  "input": "include: [gpio-controller.yaml, base.yaml]",
  "result": "+\t\t\t\tngpios = <12>;\n+\t\t\t\tngpios = <5>;\n+\t\t\t\tngpios = <4>;\n-include: [gpio-controller.yaml, base.yaml]\n+include:\n+  - name: gpio-controller.yaml\n+    property-blocklist:\n+      - ngpios\n+  - name: base.yaml\n+  ngpios:\n+    type: int\n+    default: 16\n+    description: |\n+        This property indicates the number of in-use slots of available slots\n+        for GPIOs. The STM32 GPIO controller typically has all 16 possible port\n+        IO with few exceptions. It should only be necessary to explicitly set\n+        this property if the controller itself does not implement all 16 port\n+        IO register bits; for example PORTE in the STM32WB55xx series which only\n+        implements the first 5. Package restrictions on the number of exposed\n+        GPIO should not influence this property. For cases in which there might\n+        be holes in the slot range, this value should be the max slot number+1.\n+"
},{
  "instruction": "Bluetooth: CAP: Remove check for ep in valid_unicast_audio_start_param",
  "input": "\t\tCHECKIF(bap_stream->ep != NULL) {\n\t\t\tLOG_DBG(\"param->streams[%zu] is already started\", i);\n\t\t\treturn false;\n\t\t}",
  "result": "-\t\tCHECKIF(bap_stream->ep != NULL) {\n-\t\t\tLOG_DBG(\"param->streams[%zu] is already started\", i);\n-\t\t\treturn false;\n-\t\t}\n-"
},{
  "instruction": "soc: nordic: Use 31250 Hz as system tick rate for GRTC",
  "input": "\tdefault 10000  if NRF_GRTC_TIMER",
  "result": "-\tdefault 10000  if NRF_GRTC_TIMER\n+\tdefault 31250  if NRF_GRTC_TIMER"
},{
  "instruction": "Bluetooth: Fix the host side not setting sec_adv_max_skip",
  "input": "",
  "result": "+\tcp->sec_adv_max_skip = param->secondary_max_skip;\n+"
},{
  "instruction": "drivers: wifi/airoc: Update condition to enable NET_STATISTICS",
  "input": "#if defined(CONFIG_NET_STATISTICS_ETHERNET)",
  "result": "-#if defined(CONFIG_NET_STATISTICS_ETHERNET)\n+#if defined(CONFIG_NET_STATISTICS_WIFI)"
},{
  "instruction": "modules: hal_infineon: Remove dependency on IFX SOC for ABSTR_RTOS",
  "input": "config USE_INFINEON_ABSTRACTION_RTOS\n\tbool \"Abstraction RTOS component (Zephyr support)\"\n\thelp\n\t  Enable Abstraction RTOS component with Zephyr support",
  "result": "-config USE_INFINEON_ABSTRACTION_RTOS\n-\tbool \"Abstraction RTOS component (Zephyr support)\"\n-\thelp\n-\t  Enable Abstraction RTOS component with Zephyr support\n+\n+config USE_INFINEON_ABSTRACTION_RTOS\n+\tbool \"Abstraction RTOS component (Zephyr support)\"\n+\thelp\n+\t  Enable Abstraction RTOS component with Zephyr support"
},{
  "instruction": "bluetooth: host: Ignore HCI err 0xC when setting own addr when initiating",
  "input": "\t\tif (err) {",
  "result": "-\t\tif (err) {\n+\t\tif (err == -EACCES && (atomic_test_bit(bt_dev.flags, BT_DEV_SCANNING) ||\n+\t\t\t\t       atomic_test_bit(bt_dev.flags, BT_DEV_INITIATING))) {\n+\t\t\tLOG_WRN(\"Set random addr failure ignored in scan/init state\");\n+\n+\t\t\treturn 0;\n+\t\t} else if (err) {"
},{
  "instruction": "Bluetooth: Controller: Use BT_LLL_VENDOR_* to selectively build LLL",
  "input": " CONFIG_SOC_COMPATIBLE_NRF\n CONFIG_SOC_OPENISA_RV32M1\n CONFIG_SOC_COMPATIBLE_NRF\n CONFIG_SOC_OPENISA_RV32M1",
  "result": "-  CONFIG_SOC_COMPATIBLE_NRF\n+  CONFIG_BT_LLL_VENDOR_NORDIC\n-  CONFIG_SOC_OPENISA_RV32M1\n+  CONFIG_BT_LLL_VENDOR_OPENISA\n-  CONFIG_SOC_COMPATIBLE_NRF\n+  CONFIG_BT_LLL_VENDOR_NORDIC\n-  CONFIG_SOC_OPENISA_RV32M1\n+  CONFIG_BT_LLL_VENDOR_OPENISA"
},{
  "instruction": "drivers: dma: intel-adsp-hda: Report total_copied bytes on ACE2/3",
  "input": "",
  "result": "+\tuint32_t llp_l = 0;\n+\tuint32_t llp_u = 0;\n+#if CONFIG_SOC_INTEL_ACE20_LNL || CONFIG_SOC_INTEL_ACE30_PTL\n+\t/* Linear Link Position via HDA-DMA is only supported on ACE2 or newer */\n+\tif (cfg->direction == MEMORY_TO_PERIPHERAL || cfg->direction == PERIPHERAL_TO_MEMORY) {\n+\t\tuint32_t tmp;\n+\n+\t\ttmp = *DGLLLPL(cfg->base, cfg->regblock_size, channel);\n+\t\tllp_u = *DGLLLPU(cfg->base, cfg->regblock_size, channel);\n+\t\tllp_l = *DGLLLPL(cfg->base, cfg->regblock_size, channel);\n+\t\tif (tmp > llp_l) {\n+\t\t\t/* re-read the LLPU value, as LLPL just wrapped */\n+\t\t\tllp_u = *DGLLLPU(cfg->base, cfg->regblock_size, channel);\n+\t\t}\n+\t}\n+#endif\n+\tstat->total_copied = ((uint64_t)llp_u << 32) | llp_l;\n+\n+/* Gateway Linear Link Position registers (ACE2 and onwards */\n+#define DGLLLPL(base, regblock_size, stream) \\\n+\t((volatile uint32_t *)(HDA_ADDR(base, regblock_size, stream) + 0x20))\n+\n+#define DGLLLPU(base, regblock_size, stream) \\\n+\t((volatile uint32_t *)(HDA_ADDR(base, regblock_size, stream) + 0x24))\n+"
},{
  "instruction": "stepper: fix: introduce step count check in gpio stepper",
  "input": "\tstepper_motor_set_coil_charge(dev);\n\tupdate_coil_charge(dev);",
  "result": "-\tstepper_motor_set_coil_charge(dev);\n-\tupdate_coil_charge(dev);\n+\tstruct gpio_stepper_motor_controller_data *data = dev->data;\n+\n+\tif (data->step_count) {\n+\t\tstepper_motor_set_coil_charge(dev);\n+\t\tupdate_coil_charge(dev);\n+\t}"
},{
  "instruction": "drivers: eth: fix stm32_hal PHY address resolution",
  "input": "\t    DEVICE_DT_GET(DT_CHILD(DT_INST_CHILD(n, mdio), __CONCAT(ethernet_phy_, PHY_ADDR)))",
  "result": "-\t    DEVICE_DT_GET(DT_CHILD(DT_INST_CHILD(n, mdio), __CONCAT(ethernet_phy_, PHY_ADDR)))\n+\t    DEVICE_DT_GET(DT_CHILD(DT_INST_CHILD(n, mdio), _CONCAT(ethernet_phy_, PHY_ADDR)))"
},{
  "instruction": "Bluetooth: Mesh: Clarify log to run out of retransmission attempt",
  "input": "\t\tLOG_DBG(\"Ran out of retransmit attempts\");",
  "result": "-\t\tLOG_DBG(\"Ran out of retransmit attempts\");\n+\t\tLOG_DBG(\"Ran out of ack retransmit attempts\");"
},{
  "instruction": "twister: Pass device flash timeout to pytest-harness.",
  "input": "       self._flashing_timeout: float = self.base_timeout\n            'operations are finished in a finite amount of time (e.g. waiting '\n            'for flashing).'",
  "result": "-        self._flashing_timeout: float = self.base_timeout\n+        self._flashing_timeout: float = device_config.flash_timeout\n-             'operations are finished in a finite amount of time (e.g. waiting '\n-             'for flashing).'\n+             'operations are finished in a finite amount of time.'\n+    )\n+    twister_harness_group.addoption(\n+        '--flash-timeout',\n+        type=float,\n+        default=60.0,\n+        help='Set timeout for device flashing (in seconds).'\n+    flash_timeout: float = 60.0  # [s]\n+            flash_timeout=config.option.flash_timeout,\n+        if hardware.flash_timeout:\n+            command.append(f'--flash-timeout={hardware.flash_timeout}')\n+"
},{
  "instruction": "tests: mgmt: mcumgr: enum_mgmt: Fix removed zcbor function",
  "input": "\t\t\tZCBOR_MAP_DECODE_KEY_DECODER(\"end\", zcbor_simple_decode, &received_end),",
  "result": "-\t\t\tZCBOR_MAP_DECODE_KEY_DECODER(\"end\", zcbor_simple_decode, &received_end),\n+\t\t\tZCBOR_MAP_DECODE_KEY_DECODER(\"end\", zcbor_bool_decode, &received_end),"
},{
  "instruction": "arch: riscv: add an option for empty spurious interrupt handler",
  "input": "",
  "result": "+\tselect ARCH_SUPPORTS_EMPTY_IRQ_SPURIOUS\n+config EMPTY_IRQ_SPURIOUS\n+\tbool \"Create empty spurious interrupt handler\"\n+\tdepends on ARCH_SUPPORTS_EMPTY_IRQ_SPURIOUS\n+\thelp\n+\t  This option changes body of spurious interrupt handler. When enabled,\n+\t  handler contains only an infinite while loop, when disabled, handler\n+\t  contains the whole Zephyr fault handling procedure.\n+\n+config ARCH_SUPPORTS_EMPTY_IRQ_SPURIOUS\n+\tbool\n+\n+#ifdef CONFIG_EMPTY_IRQ_SPURIOUS\n+\twhile (1) {\n+\t}\n+\n+\tCODE_UNREACHABLE;\n+#else\n+#endif /* CONFIG_EMPTY_IRQ_SPURIOUS */"
},{
  "instruction": "samples: net: wifi: boards: rdrw612bga: Modify CONFIG_POSIX_MAX_FDS config.",
  "input": "CONFIG_POSIX_MAX_FDS=20",
  "result": "-CONFIG_POSIX_MAX_FDS=20\n+CONFIG_POSIX_MAX_FDS=30"
},{
  "instruction": "arch: riscv: stacktrace: undo the fp/sp alignment check in #76045",
  "input": "\tconst uintptr_t align =\n\t\tCOND_CODE_1(CONFIG_FRAME_POINTER, (ARCH_STACK_PTR_ALIGN), (sizeof(uintptr_t)));\n\tif (!IS_ALIGNED(addr, align)) {",
  "result": "-\tconst uintptr_t align =\n-\t\tCOND_CODE_1(CONFIG_FRAME_POINTER, (ARCH_STACK_PTR_ALIGN), (sizeof(uintptr_t)));\n-\n-\tif (!IS_ALIGNED(addr, align)) {\n+\tif (!IS_ALIGNED(addr, sizeof(uintptr_t))) {"
},{
  "instruction": "net: lib: http_server: prevent falsely matching HTTP headers",
  "input": "\t\t\tif (strncasecmp(ctx->header_buffer, \"Upgrade\",\n\t\t\t\t\tsizeof(\"Upgrade\") - 1) == 0) {\n\t\t\t} else if (strncasecmp(ctx->header_buffer,\n\t\t\t\t\t       \"Sec-WebSocket-Key\",\n\t\t\t\t\t       sizeof(\"Sec-WebSocket-Key\") - 1) == 0) {\n\t\t\t\tif (strncasecmp(ctx->header_buffer, \"h2c\",\n\t\t\t\t\t\tsizeof(\"h2c\") - 1) == 0) {\n\t\t\t\t} else if (strncasecmp(ctx->header_buffer,\n\t\t\t\t\t\t       \"websocket\",\n\t\t\t\t\t\t       sizeof(\"websocket\") - 1) == 0) {",
  "result": "-\t\t\tif (strncasecmp(ctx->header_buffer, \"Upgrade\",\n-\t\t\t\t\tsizeof(\"Upgrade\") - 1) == 0) {\n+\t\t\tif (strcasecmp(ctx->header_buffer, \"Upgrade\") == 0) {\n-\t\t\t} else if (strncasecmp(ctx->header_buffer,\n-\t\t\t\t\t       \"Sec-WebSocket-Key\",\n-\t\t\t\t\t       sizeof(\"Sec-WebSocket-Key\") - 1) == 0) {\n+\t\t\t} else if (strcasecmp(ctx->header_buffer, \"Sec-WebSocket-Key\") == 0) {\n-\t\t\t\tif (strncasecmp(ctx->header_buffer, \"h2c\",\n-\t\t\t\t\t\tsizeof(\"h2c\") - 1) == 0) {\n+\t\t\t\tif (strcasecmp(ctx->header_buffer, \"h2c\") == 0) {\n-\t\t\t\t} else if (strncasecmp(ctx->header_buffer,\n-\t\t\t\t\t\t       \"websocket\",\n-\t\t\t\t\t\t       sizeof(\"websocket\") - 1) == 0) {\n+\t\t\t\t} else if (strcasecmp(ctx->header_buffer, \"websocket\") == 0) {"
},{
  "instruction": "net: lwm2m: fix buffer size check for U16 resource",
  "input": "",
  "result": "+\tcase LWM2M_RES_TYPE_U16:"
},{
  "instruction": "west.yml: Update zcbor to 0.9.0",
  "input": "     revision: 75d088037eb237b18e7ec1f47c9ce494b9b95aab",
  "result": "-      revision: 75d088037eb237b18e7ec1f47c9ce494b9b95aab\n+      revision: 47f34dd7f5284e8750b5a715dee7f77c6c5bdc3f"
},{
  "instruction": "net: dns: Add more error codes to gai_strerror()",
  "input": "\tERR(EAI_SERVICE);",
  "result": "+\tERR(EAI_FAMILY);\n+\tERR(EAI_SOCKTYPE);\n+\tERR(EAI_SERVICE);\n+\tERR(EAI_ADDRFAMILY);\n-\tERR(EAI_SERVICE);\n+\tERR(EAI_OVERFLOW);\n+\tERR(EAI_INPROGRESS);\n+\tERR(EAI_CANCELED);\n+\tERR(EAI_NOTCANCELED);\n+\tERR(EAI_ALLDONE);\n+\tERR(EAI_IDN_ENCODE);"
},{
  "instruction": "net: Make sure net_buf data size is large enough for IPv6",
  "input": "",
  "result": "+/* Make sure net_buf data size is large enough that IPv6\n+ * and possible extensions fit to the network buffer.\n+ * The check is done using an arbitrarily chosen value 96 by monitoring\n+ * wireshark traffic to see what the typical header lengts are.\n+ * It is still recommended to use the default value 128 but allow smaller\n+ * value if really needed.\n+ */\n+#if defined(CONFIG_NET_BUF_FIXED_DATA_SIZE) && defined(CONFIG_NET_NATIVE_IPV6)\n+BUILD_ASSERT(CONFIG_NET_BUF_DATA_SIZE >= 96);\n+#endif /* CONFIG_NET_BUF_FIXED_DATA_SIZE */\n+"
},{
  "instruction": "llext: fix flag evaluation for section grouping",
  "input": "\t\t\tif (shdr->sh_flags != region->sh_flags) {\n\t\t\t\tLOG_ERR(\"Unsupported section flags for %s (region %d)\",",
  "result": "+#define SHF_BASIC_TYPE_MASK\t(SHF_WRITE | SHF_ALLOC | SHF_EXECINSTR)\n+\n-\t\t\tif (shdr->sh_flags != region->sh_flags) {\n-\t\t\t\tLOG_ERR(\"Unsupported section flags for %s (region %d)\",\n+\t\t\tif ((shdr->sh_flags & SHF_BASIC_TYPE_MASK) !=\n+\t\t\t    (region->sh_flags & SHF_BASIC_TYPE_MASK)) {\n+\t\t\t\tLOG_ERR(\"Unsupported section flags %#x / %#x for %s (region %d)\",\n+\t\t\t\t\t(uint32_t)shdr->sh_flags, (uint32_t)region->sh_flags,"
},{
  "instruction": "llext: export a symbol needed for immediate logging",
  "input": "",
  "result": "+EXPORT_SYMBOL(z_log_msg_runtime_vcreate);"
},{
  "instruction": "llext: remove an unused variable",
  "input": "\tunsigned int i;\n\tfor (node = sys_slist_peek_head(&_llext_list), i = 0;\n\t     node = sys_slist_peek_next(node), i++) {",
  "result": "-\tunsigned int i;\n-\tfor (node = sys_slist_peek_head(&_llext_list), i = 0;\n+\tfor (node = sys_slist_peek_head(&_llext_list);\n-\t     node = sys_slist_peek_next(node), i++) {\n+\t     node = sys_slist_peek_next(node)) {"
},{
  "instruction": "adc: adc_nrfx_saadc: support `ADC_ACQ_TIME_MAX`",
  "input": "",
  "result": "+\tcase ADC_ACQ_TIME_MAX:"
},{
  "instruction": "samples: wifi: Add nRF70 tests to twister",
  "input": "",
  "result": "+  sample.net.wifi.nrf70dk:\n+    extra_args: CONFIG_NRF_WIFI_BUILD_ONLY_MODE=y\n+    platform_allow:\n+      - nrf7002dk/nrf5340/cpuapp\n+      - nrf7002dk/nrf5340/cpuapp/ns\n+      - nrf7002dk/nrf5340/cpuapp/nrf7001\n+      - nrf7002dk/nrf5340/cpuapp/nrf7001/ns\n+    integration_platforms:\n+      - nrf7002dk/nrf5340/cpuapp\n+      - nrf7002dk/nrf5340/cpuapp/nrf7001\n+  sample.net.wifi.nrf7002ek:\n+    extra_args:\n+      - CONFIG_NRF_WIFI_BUILD_ONLY_MODE=y\n+      - SHIELD=nrf7002ek\n+    platform_allow:\n+      - nrf5340dk/nrf5340/cpuapp\n+      - nrf5340dk/nrf5340/cpuapp/ns\n+      - nucleo_h723zg\n+    integration_platforms:\n+      - nrf5340dk/nrf5340/cpuapp\n+      - nucleo_h723zg"
},{
  "instruction": "bluetooth: host: adv: Release buf if failed to set addr",
  "input": "",
  "result": "+\t\tnet_buf_unref(buf);"
},{
  "instruction": "tests: bluetooth: tester: Fix buffer sizes on nRF5340",
  "input": "CONFIG_BT_CTLR_DATA_LENGTH_MAX=100\nCONFIG_BT_BUF_ACL_RX_SIZE=100\nCONFIG_BT_MAX_PAIRED=3",
  "result": "+CONFIG_BT_BUF_ACL_TX_SIZE=251\n+CONFIG_BT_BUF_ACL_RX_SIZE=255\n-CONFIG_BT_CTLR_DATA_LENGTH_MAX=100\n-CONFIG_BT_BUF_ACL_RX_SIZE=100\n-CONFIG_BT_MAX_PAIRED=3"
},{
  "instruction": "soc: nordic: nrf54l15: add missing include",
  "input": "",
  "result": "+#include <zephyr/dt-bindings/regulator/nrf5x.h>"
},{
  "instruction": "scripts: ci: Fix crash when vendor list is malformed",
  "input": "               vendor, _ = line.split(\"\\t\", 2)\n               vendor_prefixes.append(vendor)",
  "result": "-                vendor, _ = line.split(\"\\t\", 2)\n-                vendor_prefixes.append(vendor)\n+                try:\n+                    vendor, _ = line.split(\"\\t\", 2)\n+                    vendor_prefixes.append(vendor)\n+                except ValueError:\n+                    self.error(f\"Invalid line in vendor-prefixes.txt:\\\"{line}\\\".\")\n+                    self.error(\"Did you forget the tab character?\")"
},{
  "instruction": "boards: shields: add NXP vendor name to shields",
  "input": "G1120B0MIPI MIPI Display\n##########################\nRK043FN02H-CT Parallel Display\n##############################\nRK043FN66HS-CTG Parallel Display\n################################\nRK055HDMIPI4M MIPI Display\n##########################\nRK055HDMIPI4MA0 MIPI Display\n############################",
  "result": "-G1120B0MIPI MIPI Display\n-##########################\n+NXP G1120B0MIPI MIPI Display\n+############################\n-RK043FN02H-CT Parallel Display\n-##############################\n+NXP RK043FN02H-CT Parallel Display\n+##################################\n-RK043FN66HS-CTG Parallel Display\n-################################\n+NXP RK043FN66HS-CTG Parallel Display\n+####################################\n-RK055HDMIPI4M MIPI Display\n-##########################\n+NXP RK055HDMIPI4M MIPI Display\n+##############################\n-RK055HDMIPI4MA0 MIPI Display\n-############################\n+NXP RK055HDMIPI4MA0 MIPI Display\n+################################"
},{
  "instruction": "driver/bluetooth / cyw208xx: enable CYW20829_BT_FW_TX10DBM_POWER",
  "input": "",
  "result": "+\tdefault y"
},{
  "instruction": "west.yml: Update CYW20829 Bluetooth LE fw for PAwR support",
  "input": "     revision: d48d38ce6c75b749df3c8210af9b39aab2ab6053",
  "result": "-      revision: d48d38ce6c75b749df3c8210af9b39aab2ab6053\n+      revision: 88d2529a3c5aee2e81947553bf6cbacb4671088c"
},{
  "instruction": "Bluetooth: Samples: periodical_adv_rps: Added sync wait delay",
  "input": "",
  "result": "+\t\t/* Adding delay (2ms * interval value, using 2ms intead of the 1.25ms\n+\t\t * used by controller) to ensure sync is established before\n+\t\t * disconnection.\n+\t\t */\n+\t\tk_sleep(K_MSEC(per_adv_params.interval_max * 2));\n+"
},{
  "instruction": "Bluetooth: Samples: update response_cb in periodical_adv_rps",
  "input": "\t} else {\n\t\tprintk(\"Failed to receive response: subevent %d, slot %d\\n\", info->subevent,\n\t\t       info->response_slot);",
  "result": "-\t} else {\n-\t\tprintk(\"Failed to receive response: subevent %d, slot %d\\n\", info->subevent,\n-\t\t       info->response_slot);"
},{
  "instruction": "driver/bluetooth / cyw208xx: update condition for select PAwR FW",
  "input": "\tdefault CYW20829_BT_FW_PAWR_TX10 if BT_PER_ADV_RSP &&  CYW20829_BT_FW_TX10DBM_POWER\n\tdefault CYW20829_BT_FW_PAWR_TX0  if BT_PER_ADV_RSP && !CYW20829_BT_FW_TX10DBM_POWER\n\tdepends on BT_AIROC_CUSTOM",
  "result": "-\tdefault CYW20829_BT_FW_PAWR_TX10 if BT_PER_ADV_RSP &&  CYW20829_BT_FW_TX10DBM_POWER\n-\tdefault CYW20829_BT_FW_PAWR_TX0  if BT_PER_ADV_RSP && !CYW20829_BT_FW_TX10DBM_POWER\n+\tdefault CYW20829_BT_FW_PAWR_TX10 if (BT_PER_ADV_RSP || BT_PER_ADV_SYNC_RSP) &&  CYW20829_BT_FW_TX10DBM_POWER\n+\tdefault CYW20829_BT_FW_PAWR_TX0  if (BT_PER_ADV_RSP || BT_PER_ADV_SYNC_RSP) && !CYW20829_BT_FW_TX10DBM_POWER\n-\tdepends on BT_AIROC_CUSTOM"
},{
  "instruction": "soc: infineon/cyw20829: Update SYS_CLOCK_HW_CYCLES_PER_SEC",
  "input": "\tdefault 48000000",
  "result": "-\tdefault 48000000\n+\tdefault 96000000"
},{
  "instruction": "dts: xtensa: intel_adsp: Set soft-off state as disabled",
  "input": "\t\t\t\tmin-residency-us = <2147483647>;",
  "result": "-\t\t\t\tmin-residency-us = <2147483647>;\n+\t\t\t\tmin-residency-us = <0>;\n+\t\t\t\tstatus = \"disabled\";"
},{
  "instruction": "soc: st: stm32: add soc for stm32u031",
  "input": "",
  "result": "+    - name: stm32u031xx\n+# STMicroelectronics STM32U031XX MCU\n+\n+# Copyright (c) 2024 STMicroelectronics\n+# SPDX-License-Identifier: Apache-2.0\n+\n+if SOC_STM32U031XX\n+\n+config NUM_IRQS\n+\tdefault 32\n+\n+endif # SOC_STM32U031XX\n+config SOC_STM32U031XX\n+\tbool\n+\tselect SOC_SERIES_STM32U0X\n+\n+\tdefault \"stm32u031xx\" if SOC_STM32U031XX"
},{
  "instruction": "samples: boards: stm32: backup_sram: add magic value",
  "input": "__stm32_backup_sram_section uint32_t backup_value;\n\tprintk(\"Current value in backup SRAM (%p): %d\\n\", &backup_value, backup_value);\n\tbackup_value++;\n\tSCB_CleanDCache_by_Addr(&backup_value, sizeof(backup_value));\n\tprintk(\"Next reported value should be: %d\\n\", backup_value);",
  "result": "+#define BACKUP_MAGIC 0x600DCE11\n+\n+struct backup_store {\n+\tuint32_t value;\n+\tuint32_t magic;\n+};\n+\n-__stm32_backup_sram_section uint32_t backup_value;\n+__stm32_backup_sram_section struct backup_store backup;\n-\tprintk(\"Current value in backup SRAM (%p): %d\\n\", &backup_value, backup_value);\n+\tif (backup.magic != BACKUP_MAGIC) {\n+\t\tbackup.magic = BACKUP_MAGIC;\n+\t\tbackup.value = 0;\n+\t\tprintk(\"Invalid magic in backup SRAM structure - resetting value.\\n\");\n+\t}\n+\n+\tprintk(\"Current value in backup SRAM (%p): %d\\n\", &backup.value, backup.value);\n-\tbackup_value++;\n+\tbackup.value++;\n-\tSCB_CleanDCache_by_Addr(&backup_value, sizeof(backup_value));\n+\tSCB_CleanDCache_by_Addr(&backup, sizeof(backup));\n-\tprintk(\"Next reported value should be: %d\\n\", backup_value);\n+\tprintk(\"Next reported value should be: %d\\n\", backup.value);"
},{
  "instruction": "dts: arm: st: stm32h5: add backup sram to all socs",
  "input": "\t\t\tcompatible = \"zephyr,memory-region\", \"st,stm32-backup-sram\";\n\t\t\tclocks = <&rcc STM32_CLOCK_BUS_AHB1 0x10000000>;\n\t\t\tzephyr,memory-region = \"BACKUP_SRAM\";\n\t\t\tstatus = \"disabled\";",
  "result": "+\t\tbackup_sram: memory@40036400 {\n+\t\t\tcompatible = \"zephyr,memory-region\", \"st,stm32-backup-sram\";\n+\t\t\treg = <0x40036400 DT_SIZE_K(2)>;\n+\t\t\tclocks = <&rcc STM32_CLOCK_BUS_AHB1 0x10000000>;\n+\t\t\tzephyr,memory-region = \"BACKUP_SRAM\";\n+\t\t\tstatus = \"disabled\";\n+\t\t};\n+\n-\t\t\tcompatible = \"zephyr,memory-region\", \"st,stm32-backup-sram\";\n-\t\t\tclocks = <&rcc STM32_CLOCK_BUS_AHB1 0x10000000>;\n-\t\t\tzephyr,memory-region = \"BACKUP_SRAM\";\n-\t\t\tstatus = \"disabled\";"
},{
  "instruction": "boards: st: Fix arduino_gpio support",
  "input": " - arduino_gpio",
  "result": "-  - arduino_gpio\n+#include \"arduino_r3_connector.dtsi\""
},{
  "instruction": "Bluetooth: Host: Minor doc and rename for LE remote feature exchange",
  "input": "\tif (!atomic_test_bit(conn->flags, BT_CONN_AUTO_FEATURE_EXCH) ||\n\tBT_CONN_AUTO_FEATURE_EXCH,            /* Auto-initiated LE Feat done */\n\tif (!atomic_test_bit(conn->flags, BT_CONN_AUTO_FEATURE_EXCH) &&\n\tatomic_set_bit(conn->flags, BT_CONN_AUTO_FEATURE_EXCH);",
  "result": "-\tif (!atomic_test_bit(conn->flags, BT_CONN_AUTO_FEATURE_EXCH) ||\n+\tif (!atomic_test_bit(conn->flags, BT_CONN_LE_FEATURES_EXCHANGED) ||\n-\tBT_CONN_AUTO_FEATURE_EXCH,            /* Auto-initiated LE Feat done */\n+\tBT_CONN_LE_FEATURES_EXCHANGED,        /* bt_conn.le.features is valid */\n+\t/** @brief Remote LE features\n+\t *\n+\t * Available after `atomic_test_bit(conn->flags, BT_CONN_LE_FEATURES_EXCHANGED)`.\n+\t * Signaled by bt_conn_cb.remote_info_available().\n+\t */\n+\t/* Results in BT_HCI_EVT_LE_REMOTE_FEAT_COMPLETE */\n-\tif (!atomic_test_bit(conn->flags, BT_CONN_AUTO_FEATURE_EXCH) &&\n+\tif (!atomic_test_bit(conn->flags, BT_CONN_LE_FEATURES_EXCHANGED) &&\n-\tatomic_set_bit(conn->flags, BT_CONN_AUTO_FEATURE_EXCH);\n+\tatomic_set_bit(conn->flags, BT_CONN_LE_FEATURES_EXCHANGED);"
},{
  "instruction": "drivers/espi: it8xxx2: Fix mask when SRAM size not the power of 2",
  "input": "#define IT8XXX2_ESPI_H2RAM_BASEADDR_MASK (KB(CONFIG_SRAM_SIZE) - 1)",
  "result": "-#define IT8XXX2_ESPI_H2RAM_BASEADDR_MASK (KB(CONFIG_SRAM_SIZE) - 1)\n+#define IT8XXX2_ESPI_H2RAM_BASEADDR_MASK GENMASK(19, 0)"
},{
  "instruction": "drivers: dma: intel_adsp_hda: change L1 exit defaults",
  "input": "\tdefault y if SOC_INTEL_ACE15_MTPM\n\tdefault y if SOC_INTEL_ACE20_LNL",
  "result": "-\tdefault y if SOC_INTEL_ACE15_MTPM\n-\tdefault y if SOC_INTEL_ACE20_LNL\n+\tdefault y if SOC_SERIES_INTEL_ADSP_ACE"
},{
  "instruction": "Drivers: Counter: Added flag for counting up",
  "input": "\t\t\t.flags = 0,\t\t\t\t\t\\\n\t\t\t.flags = 0,\t\t\t\t\t\\",
  "result": "-\t\t\t.flags = 0,\t\t\t\t\t\\\n+\t\t\t.flags = COUNTER_CONFIG_INFO_COUNT_UP,\t\t\\\n-\t\t\t.flags = 0,\t\t\t\t\t\\\n+\t\t\t.flags = COUNTER_CONFIG_INFO_COUNT_UP,\t\t\\"
},{
  "instruction": "boards: renesas: update xtal clock frequency on Renesas RA boards",
  "input": "\tclock-frequency = <DT_FREQ_M(20)>;\n providing precision 24.000 MHz and 32,768 Hz reference clock.",
  "result": "-\tclock-frequency = <DT_FREQ_M(20)>;\n+\tclock-frequency = <DT_FREQ_M(12)>;\n-  providing precision 24.000 MHz and 32,768 Hz reference clock.\n+  providing precision 12.000 MHz and 32,768 Hz reference clock."
},{
  "instruction": "Driver: hci_nxp_setup: Change log message to LOG_DBG",
  "input": "\t\t\t\t\tLOG_ERR(\"Error occurs %d\", fw_upload.error);\n\t\t\t\tLOG_ERR(\"Error occurs %d\", fw_upload.error);",
  "result": "-\t\t\t\t\tLOG_ERR(\"Error occurs %d\", fw_upload.error);\n+\t\t\t\t\tLOG_DBG(\"Error occurs %d\", fw_upload.error);\n-\t\t\t\tLOG_ERR(\"Error occurs %d\", fw_upload.error);\n+\t\t\t\tLOG_DBG(\"Error occurs %d\", fw_upload.error);"
},{
  "instruction": "MAINTAINERS: changes architecture area to be maintained",
  "input": " status: odd fixes\n collaborators:",
  "result": "-  status: odd fixes\n-  collaborators:\n+  status: maintained\n+  maintainers:"
},{
  "instruction": "arch: riscv: imply XIP config pushed to SoC level",
  "input": "\timply XIP",
  "result": "-\timply XIP\n+\timply XIP\n+\timply XIP\n+\timply XIP\n+\timply XIP\n+\timply XIP\n+\timply XIP\n+\timply XIP\n+\timply XIP\n+\timply XIP\n+\timply XIP\n+\timply XIP\n+\timply XIP\n+\n+\timply XIP\n+\timply XIP\n+\timply XIP\n+\timply XIP\n+\timply XIP\n+\timply XIP"
},{
  "instruction": "cmake: targets: usage: add missing custom targets",
  "input": "",
  "result": "+message(\"  pahole       - Report struct padding (requires the pahole program)\")\n+message(\"  puncover     - Local web server to view RAM, ROM and stack usage (requires puncover pip module)\")\n+message(\"  footprint    - Create JSON RAM/ROM usage report in the build directory\")"
},{
  "instruction": "doc: settings: misc fixes",
  "input": "option ``CONFIG_SETTINGS_FILE_PATH``.\nThe Settings subsystem APIs are provided by ``settings.h``:",
  "result": "-option ``CONFIG_SETTINGS_FILE_PATH``.\n+option :kconfig:option:`CONFIG_SETTINGS_FILE_PATH`.\n-The Settings subsystem APIs are provided by ``settings.h``:\n+The Settings subsystem APIs are provided by :zephyr_file:`include/zephyr/settings/settings.h`."
},{
  "instruction": "samples: modules: nanopb: display buffer content of correct size",
  "input": "\tfor (int i = 0; i < 8; ++i) {\n\t\tfor (int i = 0; i < 8; ++i) {",
  "result": "-\tfor (int i = 0; i < 8; ++i) {\n+\tfor (int i = 0; i < CONFIG_SAMPLE_BUFFER_SIZE; ++i) {\n-\t\tfor (int i = 0; i < 8; ++i) {\n+\t\tfor (int i = 0; i < CONFIG_SAMPLE_BUFFER_SIZE; ++i) {"
},{
  "instruction": "tests: bsim: Bluetooth: central_hr_peripheral_hr for nrf54l15bsim",
  "input": " -v=${verbosity_level} -s=${simulation_id} -d=0 -RealEncryption=1\n -v=${verbosity_level} -s=${simulation_id} -d=1 -RealEncryption=1 \\\n -v=${verbosity_level} -s=${simulation_id} -d=0 -RealEncryption=1\n -v=${verbosity_level} -s=${simulation_id} -d=1 -RealEncryption=1 \\\n -v=${verbosity_level} -s=${simulation_id} -d=0 -RealEncryption=1\n -v=${verbosity_level} -s=${simulation_id} -d=1 -RealEncryption=1 \\",
  "result": "+run_in_background ${ZEPHYR_BASE}/tests/bsim/bluetooth/samples/compile.sh\n+\n-  -v=${verbosity_level} -s=${simulation_id} -d=0 -RealEncryption=1\n+  -v=${verbosity_level} -s=${simulation_id} -d=0\n-  -v=${verbosity_level} -s=${simulation_id} -d=1 -RealEncryption=1 \\\n+  -v=${verbosity_level} -s=${simulation_id} -d=1 \\\n-  -v=${verbosity_level} -s=${simulation_id} -d=0 -RealEncryption=1\n+  -v=${verbosity_level} -s=${simulation_id} -d=0\n-  -v=${verbosity_level} -s=${simulation_id} -d=1 -RealEncryption=1 \\\n+  -v=${verbosity_level} -s=${simulation_id} -d=1 \\\n-  -v=${verbosity_level} -s=${simulation_id} -d=0 -RealEncryption=1\n+  -v=${verbosity_level} -s=${simulation_id} -d=0\n-  -v=${verbosity_level} -s=${simulation_id} -d=1 -RealEncryption=1 \\\n+  -v=${verbosity_level} -s=${simulation_id} -d=1 \\\n+tests/bsim/bluetooth/samples/central_hr_peripheral_hr/"
},{
  "instruction": "Bluetooth: Controller: nrf54L15bsim: Use NRF_GRTC",
  "input": "\tdepends on SOC_SERIES_NRF54LX",
  "result": "-\tdepends on SOC_SERIES_NRF54LX\n+\tdepends on SOC_COMPATIBLE_NRF54LX"
},{
  "instruction": "Bluetooth: Controller: nRF54Lx: Use SW_SWITCH_SINGLE_TIMER",
  "input": "\tdepends on SOC_COMPATIBLE_NRF52X || SOC_COMPATIBLE_NRF53X || SOC_SERIES_NRF54LX\n\tselect BT_CTLR_SW_SWITCH_SINGLE_TIMER if SOC_SERIES_NRF54LX\n\t\t\t\t\t  SOC_SERIES_NRF54LX)",
  "result": "-\tdepends on SOC_COMPATIBLE_NRF52X || SOC_COMPATIBLE_NRF53X || SOC_SERIES_NRF54LX\n-\tselect BT_CTLR_SW_SWITCH_SINGLE_TIMER if SOC_SERIES_NRF54LX\n+\tdepends on SOC_COMPATIBLE_NRF52X || SOC_COMPATIBLE_NRF53X || SOC_COMPATIBLE_NRF54LX\n+\tselect BT_CTLR_SW_SWITCH_SINGLE_TIMER if SOC_COMPATIBLE_NRF54LX\n-\t\t\t\t\t  SOC_SERIES_NRF54LX)\n+\t\t\t\t\t  SOC_COMPATIBLE_NRF54LX)"
},{
  "instruction": "Bluetooth: Controller: nRF54Lx: Use nrfx interface for bsim use (4/4)",
  "input": "\tNRF_GRTC->PUBLISH_COMPARE[HAL_CNTR_GRTC_CC_IDX_RADIO] =\n\t\t((HAL_EVENT_TIMER_START_PPI <<\n\t\t  GRTC_PUBLISH_COMPARE_CHIDX_Pos) &\n\t\t GRTC_PUBLISH_COMPARE_CHIDX_Msk) |\n\t\t((GRTC_PUBLISH_COMPARE_EN_Enabled <<\n\t\t  GRTC_PUBLISH_COMPARE_EN_Pos) &\n\t\t GRTC_PUBLISH_COMPARE_EN_Msk);\n\tNRF_DPPIC20->CHENSET = BIT(HAL_EVENT_TIMER_START_PPI);\n\tNRF_PPIB21->SUBSCRIBE_SEND[HAL_EVENT_TIMER_START_PPI] =\n\t\tBIT(HAL_EVENT_TIMER_START_PPI) | PPIB_SUBSCRIBE_SEND_EN_Msk;\n\tNRF_PPIB11->PUBLISH_RECEIVE[HAL_EVENT_TIMER_START_PPI] =\n\t\tBIT(HAL_EVENT_TIMER_START_PPI) | PPIB_PUBLISH_RECEIVE_EN_Msk;",
  "result": "-\tNRF_GRTC->PUBLISH_COMPARE[HAL_CNTR_GRTC_CC_IDX_RADIO] =\n-\t\t((HAL_EVENT_TIMER_START_PPI <<\n-\t\t  GRTC_PUBLISH_COMPARE_CHIDX_Pos) &\n-\t\t GRTC_PUBLISH_COMPARE_CHIDX_Msk) |\n-\t\t((GRTC_PUBLISH_COMPARE_EN_Enabled <<\n-\t\t  GRTC_PUBLISH_COMPARE_EN_Pos) &\n-\t\t GRTC_PUBLISH_COMPARE_EN_Msk);\n-\tNRF_DPPIC20->CHENSET = BIT(HAL_EVENT_TIMER_START_PPI);\n-\tNRF_PPIB21->SUBSCRIBE_SEND[HAL_EVENT_TIMER_START_PPI] =\n-\t\tBIT(HAL_EVENT_TIMER_START_PPI) | PPIB_SUBSCRIBE_SEND_EN_Msk;\n-\tNRF_PPIB11->PUBLISH_RECEIVE[HAL_EVENT_TIMER_START_PPI] =\n-\t\tBIT(HAL_EVENT_TIMER_START_PPI) | PPIB_PUBLISH_RECEIVE_EN_Msk;"
},{
  "instruction": "Bluetooth: Controller: nRF54Lx: Use nrfx interface for bsim use (3/4)",
  "input": "",
  "result": "+#include <hal/nrf_ppib.h>\n+\tnrf_grtc_publish_set(NRF_GRTC, HAL_CNTR_GRTC_EVENT_COMPARE_RADIO,\n+\t\t\t     HAL_EVENT_TIMER_START_PPI);\n+\tnrf_dppi_channels_enable(NRF_DPPIC20,\n+\t\t\t\t BIT(HAL_EVENT_TIMER_START_PPI));\n+\tnrf_ppib_subscribe_set(NRF_PPIB21, HAL_PPIB_SEND_EVENT_TIMER_START_PPI,\n+\t\t\t       HAL_EVENT_TIMER_START_PPI);\n+\tnrf_ppib_publish_set(NRF_PPIB11, HAL_PPIB_RECEIVE_EVENT_TIMER_START_PPI,\n+\t\t\t     HAL_EVENT_TIMER_START_PPI);\n+#define HAL_PPIB_SEND_EVENT_TIMER_START_PPI \\\n+\t_CONCAT(NRF_PPIB_TASK_SEND_, HAL_EVENT_TIMER_START_PPI)\n+#define HAL_PPIB_RECEIVE_EVENT_TIMER_START_PPI \\\n+\t_CONCAT(NRF_PPIB_EVENT_RECEIVE_, HAL_EVENT_TIMER_START_PPI)"
},{
  "instruction": "Bluetooth: Controller: nRF54Lx: Port for data whitening register use",
  "input": "",
  "result": "+#if defined(CONFIG_SOC_COMPATIBLE_NRF54LX)\n+#if defined(RADIO_DATAWHITEIV_DATAWHITEIV_Msk)\n+\tNRF_RADIO->DATAWHITEIV = HAL_RADIO_RESET_VALUE_DATAWHITE | iv;\n+#else /* !RADIO_DATAWHITEIV_DATAWHITEIV_Msk */\n+\tNRF_RADIO->DATAWHITE = HAL_RADIO_RESET_VALUE_DATAWHITE | iv;\n+#endif /* !RADIO_DATAWHITEIV_DATAWHITEIV_Msk */\n+#else /* !CONFIG_SOC_COMPATIBLE_NRF54LX */\n+#endif /* !CONFIG_SOC_COMPATIBLE_NRF54LX */\n+#define HAL_RADIO_RESET_VALUE_DATAWHITE     0x00890040UL"
},{
  "instruction": "Bluetooth: Controller: Remove redundant HAL_TICKER_CNTR_CLK_FREQ_HZ",
  "input": "#define HAL_TICKER_CNTR_CLK_FREQ_HZ   32768U\n#define HAL_TICKER_CNTR_CLK_FREQ_HZ   32768U",
  "result": "-#define HAL_TICKER_CNTR_CLK_FREQ_HZ   32768U\n-#define HAL_TICKER_CNTR_CLK_FREQ_HZ   32768U"
},{
  "instruction": "Bluetooth: Controller: Fix ext conn create when using single timer",
  "input": "",
  "result": "+uint32_t radio_is_tx_done(void)\n+{\n+\tif (IS_ENABLED(CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)) {\n+\t\treturn radio_is_done();\n+\t} else {\n+\t\treturn 1U;\n+\t}\n+}\n+\n+uint32_t radio_is_tx_done(void);\n+\t/* Call to ensure packet/event timer accumulates the elapsed time\n+\t * under single timer use.\n+\t */\n+\t(void)radio_is_tx_done();\n+"
},{
  "instruction": "Bluetooth: Controller: Fix BT_CTLR_EARLY_ABORT_PREVIOUS_PREPARE depends",
  "input": "",
  "result": "+\tdepends on !BT_CTLR_LOW_LAT"
},{
  "instruction": "boards: nxp: twr_ke18f: add vref-mv value",
  "input": "",
  "result": "+\tvref-mv = <3300>;"
},{
  "instruction": "boards: nxp: frdm_ke17z and frdm_ke17z512: add vref-mv value",
  "input": "",
  "result": "+\tvref-mv = <3300>;\n+\tvref-mv = <3300>;"
},{
  "instruction": "board: ucans32k1sic: Enable ADC on UCANS32K1SIC evb",
  "input": "",
  "result": "+ADC           on-chip     adc\n+\n+&adc0 {\n+\tsample-time = <65>;\n+\tvref-mv = <3300>;\n+\tstatus = \"okay\";\n+};\n+\n+&adc1 {\n+\tsample-time = <65>;\n+\tvref-mv = <3300>;\n+\tstatus = \"okay\";\n+};\n+  - adc"
},{
  "instruction": "drivers: adc: adc_mcux_adc12: add API internal reference",
  "input": "static const struct adc_driver_api mcux_adc12_driver_api = {\n\t.channel_setup = mcux_adc12_channel_setup,\n\t.read = mcux_adc12_read,\n#ifdef CONFIG_ADC_ASYNC\n\t.read_async = mcux_adc12_read_async,\n#endif\n};\n\t\t\t    &mcux_adc12_driver_api);\t\t\t\\",
  "result": "-static const struct adc_driver_api mcux_adc12_driver_api = {\n-\t.channel_setup = mcux_adc12_channel_setup,\n-\t.read = mcux_adc12_read,\n-#ifdef CONFIG_ADC_ASYNC\n-\t.read_async = mcux_adc12_read_async,\n-#endif\n-};\n-\n+#define ADC12_MCUX_DRIVER_API(n)\t\t\t\t\\\n+\tstatic const struct adc_driver_api mcux_adc12_driver_api_##n = {\t\\\n+\t\t.channel_setup = mcux_adc12_channel_setup,\t\\\n+\t\t.read = mcux_adc12_read,\t\\\n+\t\tIF_ENABLED(CONFIG_ADC_ASYNC, (.read_async = mcux_adc12_read_async,))\t\\\n+\t\t.ref_internal = DT_INST_PROP(n, vref_mv),\t\\\n+\t};\n+\n+\tADC12_MCUX_DRIVER_API(n);\t\t\t\t\t\\\n-\t\t\t    &mcux_adc12_driver_api);\t\t\t\\\n+\t\t\t    &mcux_adc12_driver_api_##n);\t\t\\"
},{
  "instruction": "drivers: adc: adc_mcux_adc12: set the vref as a property",
  "input": "",
  "result": "+  vref-mv:\n+    type: int\n+    required: true\n+    description: Indicates the reference voltage of the ADC in mV.\n+"
},{
  "instruction": "drivers: adc: adc_mcux_adc12: enable support for channel>=16 on S32K14X",
  "input": "",
  "result": "+#if defined(CONFIG_SOC_S32K146) || defined(CONFIG_SOC_S32K148)\n+\tif (data->channel_id >= 16) {\n+\t\t/*\n+\t\t * channels 16..31 are encoded as 100000b..101111b in\n+\t\t * SC1[ADCH] field\n+\t\t */\n+\t\tchannel_config.channelNumber += 16;\n+\t}\n+#endif"
},{
  "instruction": "soc: arm: nxp_s32: s32k1: add support for ADC",
  "input": "     revision: 00fd3f5a3b1b7fc3a715b1e96cb2d5036b5cc27e",
  "result": "+\n+\t\tadc0: adc@4003b000 {\n+\t\t\tcompatible = \"nxp,kinetis-adc12\";\n+\t\t\treg = <0x4003b000 0x1000>;\n+\t\t\tinterrupts = <39 0>;\n+\t\t\tclk-source = <0>;\n+\t\t\tclk-divider = <1>;\n+\t\t\tclocks = <&clock NXP_S32_ADC0_CLK>;\n+\t\t\t#io-channel-cells = <1>;\n+\t\t\tstatus = \"disabled\";\n+\t\t};\n+\n+\t\tadc1: adc@40027000 {\n+\t\t\tcompatible = \"nxp,kinetis-adc12\";\n+\t\t\treg = <0x40027000 0x1000>;\n+\t\t\tinterrupts = <40 0>;\n+\t\t\tclk-source = <0>;\n+\t\t\tclk-divider = <1>;\n+\t\t\tclocks = <&clock NXP_S32_ADC1_CLK>;\n+\t\t\t#io-channel-cells = <1>;\n+\t\t\tstatus = \"disabled\";\n+\t\t};\n+\tselect HAS_MCUX_ADC12\n-      revision: 00fd3f5a3b1b7fc3a715b1e96cb2d5036b5cc27e\n+      revision: 466000a80e6eb5bbcb691bae936ec5654a7796d4"
},{
  "instruction": "boards: ambiq: add adc to apollo4p boards",
  "input": "",
  "result": "+\tadc0_default: adc0_default{\n+\t\tgroup1 {\n+\t\t\tpinmux = <ADCSE4_P15>, <ADCSE7_P12>;\n+\t\t\tdrive-strength = \"0.1\";\n+\t\t};\n+\t};\n-\n+&adc0 {\n+compatible = \"ambiq,adc\";\n+\tpinctrl-0 = <&adc0_default>;\n+\tpinctrl-names = \"default\";\n+\tstatus = \"okay\";\n+};\n+\n+  - adc"
},{
  "instruction": "dts: arm: ambiq: add ambiq adc to dtsi file",
  "input": "",
  "result": "+#include <zephyr/dt-bindings/adc/adc.h>\n+\t\tadc0: adc@40038000 {\n+\t\t\treg = <0x40038000 0x400>;\n+\t\t\tinterrupts = <19 0>;\n+\t\t\tinterrupt-names = \"ADC\";\n+\t\t\tchannel-count = <10>;\n+\t\t\tinternal-vref-mv = <1190>;\n+\t\t\tstatus = \"disabled\";\n+\t\t\t#io-channel-cells = <1>;\n+\t\t\tambiq,pwrcfg = <&pwrcfg 0x4 0x2000>;\n+\t\t};\n+\n+config AMBIQ_HAL_USE_ADC\n+\tbool\n+\thelp\n+\t  Use the ADC driver from Ambiq HAL\n+"
},{
  "instruction": "twister: setup soc/arch roots based on module settings",
  "input": "       lb_args = Namespace(arch_roots=[Path(ZEPHYR_BASE)], soc_roots=[Path(ZEPHYR_BASE),\n                           Path(ZEPHYR_BASE) / 'subsys' / 'testsuite'],\n   env = mock.Mock(board_roots=[tmp_board_root_dir])",
  "result": "+\n+        self.soc_roots = [Path(ZEPHYR_BASE), Path(ZEPHYR_BASE) / 'subsys' / 'testsuite']\n+        self.dts_roots = [Path(ZEPHYR_BASE)]\n+        self.arch_roots = [Path(ZEPHYR_BASE)]\n+\n+        for module in modules:\n+            soc_root = module.meta.get(\"build\", {}).get(\"settings\", {}).get(\"soc_root\")\n+            if soc_root:\n+                self.soc_roots.append(os.path.join(module.project, soc_root))\n+            dts_root = module.meta.get(\"build\", {}).get(\"settings\", {}).get(\"dts_root\")\n+            if soc_root:\n+                self.dts_roots.append(os.path.join(module.project, dts_root))\n+            arch_root = module.meta.get(\"build\", {}).get(\"settings\", {}).get(\"arch_root\")\n+            if arch_root:\n+                self.arch_roots.append(os.path.join(module.project, arch_root))\n+\n-        lb_args = Namespace(arch_roots=[Path(ZEPHYR_BASE)], soc_roots=[Path(ZEPHYR_BASE),\n-                            Path(ZEPHYR_BASE) / 'subsys' / 'testsuite'],\n+        lb_args = Namespace(arch_roots=self.env.arch_roots, soc_roots=self.env.soc_roots,\n+\n-    env = mock.Mock(board_roots=[tmp_board_root_dir])\n+    env = mock.Mock(board_roots=[tmp_board_root_dir],soc_roots=[tmp_path], arch_roots=[tmp_path])"
},{
  "instruction": "tests: build_all: sensors: add bmp180@94, i2c.dtsi",
  "input": "",
  "result": "+\n+test_i2c_bmp180: bmp180@94 {\n+\tcompatible = \"bosch,bmp180\";\n+\treg = <0x94>;\n+\tosr-press = <0x01>;\n+};"
},{
  "instruction": "Bluetooth: drivers: Add module blobs dependencies to Kconfig",
  "input": "",
  "result": "+if(CONFIG_DT_HAS_ESPRESSIF_ESP32_BT_HCI_ENABLED)\n+  zephyr_blobs_verify(MODULE hal_espressif REQUIRED)\n+endif()\n+if(CONFIG_DT_HAS_ST_HCI_STM32WBA_ENABLED)\n+  zephyr_blobs_verify(MODULE hal_stm32 REQUIRED)\n+endif()\n+if(CONFIG_DT_HAS_SILABS_BT_HCI_ENABLED)\n+  zephyr_blobs_verify(MODULE hal_silabs REQUIRED)\n+endif()\n+if(CONFIG_DT_HAS_INFINEON_CAT1_BLESS_HCI_ENABLED)\n+  zephyr_blobs_verify(MODULE hal_infineon REQUIRED)\n+endif()\n+\tdepends on ZEPHYR_HAL_STM32_MODULE_BLOBS\n+\tdepends on ZEPHYR_HAL_SILABS_MODULE_BLOBS\n+\tdepends on ZEPHYR_HAL_ESPRESSIF_MODULE_BLOBS\n+\tdepends on ZEPHYR_HAL_INFINEON_MODULE_BLOBS"
},{
  "instruction": "ipc: icmsg: configure PBUF RX rx_buffer using kconfig",
  "input": "\tuint8_t rx_buffer[len];\n\tlen = pbuf_read(dev_data->rx_pb, rx_buffer, len);",
  "result": "+\n+if PBUF\n+\n+config PBUF_RX_READ_BUF_SIZE\n+\tint \"Size of PBUF read buffer in bytes\"\n+\tdefault 128\n+\n+endif # PBUF\n+\tuint8_t rx_buffer[CONFIG_PBUF_RX_READ_BUF_SIZE] __aligned(4);\n-\tuint8_t rx_buffer[len];\n+\t__ASSERT_NO_MSG(len <= sizeof(rx_buffer));\n-\tlen = pbuf_read(dev_data->rx_pb, rx_buffer, len);\n+\tif (sizeof(rx_buffer) < len) {\n+\t\treturn;\n+\t}\n+\n+\tlen = pbuf_read(dev_data->rx_pb, rx_buffer, sizeof(rx_buffer));"
},{
  "instruction": "bluetooth: mesh: Fix proxy client compilation",
  "input": "\t#if defined(CONFIG_BT_MESH_GATT_PROXY)",
  "result": "-\t#if defined(CONFIG_BT_MESH_GATT_PROXY)\n+\t#if defined(CONFIG_BT_MESH_GATT)"
},{
  "instruction": "Bluetooth: Controller: Initialize BIG info RFU field",
  "input": "",
  "result": "+\tbig_info->rfu = 0U;"
},{
  "instruction": "samples/llext/modules: sample.yaml fixes",
  "input": " arch_allow:\n   - arm\n   - xtensa\n platform_exclude:\n   # platforms with active issues\n   - apollo4p_evb            # See #73443\n   - apollo4p_blue_kxr_evb   # See #73443\n   - numaker_pfm_m487        # See #63167\n   - s32z2xxdc2/s32z270/rtu0 # See commit 18a0660\n   - s32z2xxdc2/s32z270/rtu1 # See commit 18a0660\n   # platforms that are always skipped by the runtime filter\n   - qemu_arc/qemu_arc_em\n   - qemu_arc/qemu_arc_hs\n   - qemu_arc/qemu_arc_hs/xip\n   - qemu_arc/qemu_arc_hs5x\n   - qemu_arc/qemu_arc_hs6x\n   - qemu_cortex_m0\n   - qemu_xtensa/dc233c/mmu\n integration_platforms:\n   filter: not CONFIG_MPU and not CONFIG_MMU and not CONFIG_SOC_SERIES_S32ZE",
  "result": "-  arch_allow:\n-    - arm\n-    - xtensa\n-  platform_exclude:\n-    # platforms with active issues\n-    - apollo4p_evb            # See #73443\n-    - apollo4p_blue_kxr_evb   # See #73443\n-    - numaker_pfm_m487        # See #63167\n-    - s32z2xxdc2/s32z270/rtu0 # See commit 18a0660\n-    - s32z2xxdc2/s32z270/rtu1 # See commit 18a0660\n-    # platforms that are always skipped by the runtime filter\n-    - qemu_arc/qemu_arc_em\n-    - qemu_arc/qemu_arc_hs\n-    - qemu_arc/qemu_arc_hs/xip\n-    - qemu_arc/qemu_arc_hs5x\n-    - qemu_arc/qemu_arc_hs6x\n-    - qemu_cortex_m0\n-    - qemu_xtensa/dc233c/mmu\n-  integration_platforms:\n+  platform_allow:\n+    - qemu_xtensa\n+  integration_platforms:\n+    - qemu_xtensa\n+    - mps2/an385\n-    filter: not CONFIG_MPU and not CONFIG_MMU and not CONFIG_SOC_SERIES_S32ZE"
},{
  "instruction": "manifest: Update bsim to version v2.3",
  "input": "     revision: 9351ae1ad44864a49c351f9704f65f43046abeb0\n     revision: 4bd907be0b2abec3b31a23fd8ca98db2a07209d2\n     revision: 93f5eba512c438b0c9ebc1b1a947517c865b3643\n     revision: a38d2d24b04a6f970a225d1316047256ebf5a539\n     revision: eed6d7038e839153e340bd333bc43541cb90ba64",
  "result": "-      revision: 9351ae1ad44864a49c351f9704f65f43046abeb0\n+      revision: 9ee22c707970f6621adba0375841c0a609e24628\n-      revision: 4bd907be0b2abec3b31a23fd8ca98db2a07209d2\n+      revision: a3dff9a57f334fb25daa9625841cd64cbfe56681\n-      revision: 93f5eba512c438b0c9ebc1b1a947517c865b3643\n+      revision: aa4951317cc7d84f24152ea38ac9ac21e6d78a76\n-      revision: a38d2d24b04a6f970a225d1316047256ebf5a539\n+      revision: 4d2379de510684cd4b1c3bbbb09bce7b5a20bc1f\n-      revision: eed6d7038e839153e340bd333bc43541cb90ba64\n+      revision: 236309584c90be32ef12848077bd6de54e9f4deb"
},{
  "instruction": "manifest: Update nRF hw models to latest",
  "input": "     revision: 3ede17158a9fe85c160e0384c0ad0306e24ee47e",
  "result": "-      revision: 3ede17158a9fe85c160e0384c0ad0306e24ee47e\n+      revision: 6e70c2dc5d4c67c4da5913b2969c0774b27f0cd0"
},{
  "instruction": "samples: Bluetooth: Add streaming callback for unicast server",
  "input": "",
  "result": "+CONFIG_BT_AUDIO_CODEC_CFG_MAX_METADATA_SIZE=10\n+\n+static void stream_started(struct bt_bap_stream *stream)\n+{\n+\tprintk(\"Audio Stream %p started\\n\", stream);\n+}\n+\t.started = stream_started,"
},{
  "instruction": "boards: st: nucleo_h745zi_q: Wire up SPI tests",
  "input": "",
  "result": "+  - spi\n+  - spi"
},{
  "instruction": "tests: drivers: Remove unnessesary include",
  "input": "#include <zephyr/dt-bindings/memory-attr/memory-attr-arm.h>\n#include <zephyr/dt-bindings/memory-attr/memory-attr-arm.h>",
  "result": "-#include <zephyr/dt-bindings/memory-attr/memory-attr-arm.h>\n-\n-#include <zephyr/dt-bindings/memory-attr/memory-attr-arm.h>\n-"
},{
  "instruction": "doc: fix links to wiki",
  "input": ".. _Zephyr Dev Meeting: https://github.com/zephyrproject-rtos/zephyr/wiki/Zephyr-Committee-and-Working-Group-Meetings#zephyr-dev-meeting\n.. _`Zephyr meetings`: https://github.com/zephyrproject-rtos/zephyr/wiki/Zephyr-Committee-and-Working-Group-Meetings\n      .. _`dev-review`: https://github.com/zephyrproject-rtos/zephyr/wiki/Zephyr-Committee-and-Working-Group-Meetings#zephyr-dev-meeting\n      .. _`TSC meeting`: https://github.com/zephyrproject-rtos/zephyr/wiki/Zephyr-Committee-and-Working-Group-Meetings#technical-steering-committee-tsc",
  "result": "-.. _Zephyr Dev Meeting: https://github.com/zephyrproject-rtos/zephyr/wiki/Zephyr-Committee-and-Working-Group-Meetings#zephyr-dev-meeting\n+.. _Zephyr Dev Meeting: https://github.com/zephyrproject-rtos/zephyr/wiki/Zephyr-Committee-and-Working-Groups#zephyr-dev-meeting\n-.. _`Zephyr meetings`: https://github.com/zephyrproject-rtos/zephyr/wiki/Zephyr-Committee-and-Working-Group-Meetings\n+.. _`Zephyr meetings`: https://github.com/zephyrproject-rtos/zephyr/wiki/Zephyr-Committee-and-Working-Groups\n-       .. _`dev-review`: https://github.com/zephyrproject-rtos/zephyr/wiki/Zephyr-Committee-and-Working-Group-Meetings#zephyr-dev-meeting\n+       .. _`dev-review`: https://github.com/zephyrproject-rtos/zephyr/wiki/Zephyr-Committee-and-Working-Groups#zephyr-dev-meeting\n-       .. _`TSC meeting`: https://github.com/zephyrproject-rtos/zephyr/wiki/Zephyr-Committee-and-Working-Group-Meetings#technical-steering-committee-tsc\n+       .. _`TSC meeting`: https://github.com/zephyrproject-rtos/zephyr/wiki/Technical-Steering-Committee-(TSC)"
},{
  "instruction": "boards: intel: ish: Set flasher to misc-flasher",
  "input": "",
  "result": "+# SPDX-License-Identifier: Apache-2.0\n+\n+board_set_flasher_ifnset(misc-flasher)\n+board_finalize_runner_args(misc-flasher)"
},{
  "instruction": "tests: rtio: test `rtio_sqe_prep_callback_no_cqe`",
  "input": "#define SQE_POOL_SIZE 4\n#define CQE_POOL_SIZE 4",
  "result": "-#define SQE_POOL_SIZE 4\n-#define CQE_POOL_SIZE 4\n+#define SQE_POOL_SIZE 5\n+#define CQE_POOL_SIZE 5\n+static bool cb_no_cqe_run;\n+void rtio_callback_chaining_cb_no_cqe(struct rtio *r, const struct rtio_sqe *sqe, void *arg0)\n+{\n+\tTC_PRINT(\"Chaining callback with userdata %p (No CQE)\\n\", arg0);\n+\tcb_no_cqe_run = true;\n+}\n+\n+\tsqe = rtio_sqe_acquire(r);\n+\tzassert_not_null(sqe, \"Expected a valid sqe\");\n+\trtio_sqe_prep_callback_no_cqe(sqe, &rtio_callback_chaining_cb_no_cqe, sqe, NULL);\n+\tsqe->flags |= RTIO_SQE_CHAINED;\n+\n+\tzassert_true(cb_no_cqe_run, \"Callback without CQE should have run\");"
},{
  "instruction": "rtio: add helper function `rtio_sqe_prep_callback_no_cqe`",
  "input": "",
  "result": "+/**\n+ * @brief Prepare a callback op submission that does not create a CQE\n+ *\n+ * Similar to @ref rtio_sqe_prep_callback, but the @ref RTIO_SQE_NO_RESPONSE\n+ * flag is set on the SQE to prevent the generation of a CQE upon completion.\n+ *\n+ * This can be useful when the callback is the last operation in a sequence\n+ * whose job is to clean up all the previous CQE's. Without @ref RTIO_SQE_NO_RESPONSE\n+ * the completion itself will result in a CQE that cannot be consumed in the callback.\n+ */\n+static inline void rtio_sqe_prep_callback_no_cqe(struct rtio_sqe *sqe,\n+\t\t\t\t\t\t rtio_callback_t callback,\n+\t\t\t\t\t\t void *arg0,\n+\t\t\t\t\t\t void *userdata)\n+{\n+\trtio_sqe_prep_callback(sqe, callback, arg0, userdata);\n+\tsqe->flags |= RTIO_SQE_NO_RESPONSE;\n+}\n+"
},{
  "instruction": "MAINTAINERS.yml: removing marc-hb",
  "input": "   - marc-hb\n   - marc-hb\n   - marc-hb",
  "result": "-    - marc-hb\n-    - marc-hb\n-    - marc-hb"
},{
  "instruction": "dt-bindings: usb: uac2: Add configuration speed selectors",
  "input": "",
  "result": "+  full-speed:\n+    type: boolean\n+    description: |\n+      True if this instance is allowed to operate at Full-Speed.\n+\n+  high-speed:\n+    type: boolean\n+    description: |\n+      True if this instance is allowed to operate at High-Speed.\n+"
},{
  "instruction": "boards: thingy53: define composite fuel gauge",
  "input": "",
  "result": "+#include <zephyr/dt-bindings/battery/battery.h>\n+\tfuel_gauge: fuel_gauge {\n+\t\tcompatible = \"zephyr,fuel-gauge-composite\";\n+\t\tbattery-voltage = <&vbatt>;\n+\t\tdevice-chemistry = \"lithium-ion-polymer\";\n+\t\tocv-capacity-table-0 = <BATTERY_OCV_CURVE_LITHIUM_ION_POLYMER_DEFAULT>;\n+\t\tcharge-full-design-microamp-hours = <1350000>;\n+\t};\n+"
},{
  "instruction": "tests: build_all: sensor: test composite fuel gauge",
  "input": "",
  "result": "+ #include <zephyr/dt-bindings/battery/battery.h>\n+\n+test_composite_fuel_gauge: composite_fuel_gauge {\n+\tcompatible = \"zephyr,fuel-gauge-composite\";\n+\tstatus = \"okay\";\n+\tbattery-voltage = <&test_voltage>;\n+\tbattery-current = <&test_current>;\n+\tdevice-chemistry = \"lithium-ion-polymer\";\n+\tocv-capacity-table-0 = <BATTERY_OCV_CURVE_LITHIUM_ION_POLYMER_DEFAULT>;\n+\tcharge-full-design-microamp-hours = <1000000>;\n+};\n+\n+CONFIG_FUEL_GAUGE=y"
},{
  "instruction": "drivers: dac: esp32: clock initialization fix",
  "input": "\tif (clock_control_on(cfg->clock_dev,\n\t\t(clock_control_subsys_t) &cfg->clock_subsys) != 0) {",
  "result": "-\tif (clock_control_on(cfg->clock_dev,\n-\t\t(clock_control_subsys_t) &cfg->clock_subsys) != 0) {\n+\tif (clock_control_on(cfg->clock_dev, (clock_control_subsys_t)cfg->clock_subsys) != 0) {"
},{
  "instruction": "drivers: i2s: i2s_ll_stm32: Handle single clock source",
  "input": "",
  "result": "+\t\t/* Handle multiple clock sources */\n+\t} else {\n+\t\t/* Handle single clock source */\n+\t\tif (clock_control_get_rate(DEVICE_DT_GET(STM32_CLOCK_CONTROL_NODE),\n+\t\t\t\t\t   (clock_control_subsys_t)&cfg->pclken[0],\n+\t\t\t\t\t   &freq_in) < 0) {\n+\t\t\tLOG_ERR(\"Failed call clock_control_get_rate(pclken[0])\");\n+\t\t\treturn -EIO;\n+\t\t}"
},{
  "instruction": "soc: nxp: rt1011: Fix RT1011 FCB offset",
  "input": "",
  "result": "+config FLEXSPI_CONFIG_BLOCK_OFFSET\n+\tdefault 0x400 if SOC_MIMXRT1011"
},{
  "instruction": "drivers: hwinfo: litex: depend on devicetree",
  "input": "",
  "result": "+\tdepends on DT_HAS_LITEX_DNA0_ENABLED"
},{
  "instruction": "hotfix: drivers: i2s: update esp32s3/c3 I2S dtsi",
  "input": "\t\t\tinterrupts = <I2S1_INTR_SOURCE>;\n\t\t\tinterrupts = <I2S0_INTR_SOURCE>;\n\t\t\tinterrupts = <I2S1_INTR_SOURCE>;",
  "result": "-\t\t\tinterrupts = <I2S1_INTR_SOURCE>;\n+\t\t\tinterrupts = <I2S1_INTR_SOURCE IRQ_DEFAULT_PRIORITY 0>;\n-\t\t\tinterrupts = <I2S0_INTR_SOURCE>;\n+\t\t\tinterrupts = <I2S0_INTR_SOURCE IRQ_DEFAULT_PRIORITY 0>;\n-\t\t\tinterrupts = <I2S1_INTR_SOURCE>;\n+\t\t\tinterrupts = <I2S1_INTR_SOURCE IRQ_DEFAULT_PRIORITY 0>;"
},{
  "instruction": "soc: nxp: rt11xx: Enable FlexIO",
  "input": "",
  "result": "+\t\tflexio1: flexio@400ac000 {\n+\t\t\tcompatible = \"nxp,flexio\";\n+\t\t\treg = <0x400ac000 0x4000>;\n+\t\t\tinterrupts = <110 0>;\n+\t\t\tclocks = <&ccm IMX_CCM_FLEXIO1_CLK 0 0>;\n+\t\t\tstatus = \"disabled\";\n+\t\t};\n+\n+\t\tflexio2: flexio@400b0000 {\n+\t\t\tcompatible = \"nxp,flexio\";\n+\t\t\treg = <0x400b0000 0x4000>;\n+\t\t\tinterrupts = <111 0>;\n+\t\t\tclocks = <&ccm IMX_CCM_FLEXIO2_CLK 0 0>;\n+\t\t\tstatus = \"disabled\";\n+\t\t};\n+"
},{
  "instruction": "clock: mcux_ccm: add flexio clock",
  "input": "",
  "result": "+#ifdef CONFIG_MCUX_FLEXIO\n+\tcase IMX_CCM_FLEXIO1_CLK:\n+\t\tclock_root = kCLOCK_Root_Flexio1;\n+\t\tbreak;\n+\tcase IMX_CCM_FLEXIO2_CLK:\n+\t\tclock_root = kCLOCK_Root_Flexio2;\n+\t\tbreak;\n+#endif\n+\n+/* FLEXIO */\n+#define IMX_CCM_FLEXIO_CLK             0x1700UL\n+#define IMX_CCM_FLEXIO1_CLK            0x1700UL\n+#define IMX_CCM_FLEXIO2_CLK            0x1701UL\n+"
},{
  "instruction": "tests: include drivers/watchdog/wdt_basic_api on it8xxx2_evb",
  "input": "     # excluded it8xxx2_evb because test can't be automate,\n     # and needs external reset, git issue #75389\n     - it8xxx2_evb",
  "result": "-      # excluded it8xxx2_evb because test can't be automate,\n-      # and needs external reset, git issue #75389\n-      - it8xxx2_evb"
},{
  "instruction": "tests/boot: Add nucleo_wba55cg as test target",
  "input": "",
  "result": "+      - nucleo_wba55cg\n+    - nucleo_wba55cg"
},{
  "instruction": "boards: nucleo_wb55cg: Set partition for swap f/w update method",
  "input": "\t\t\treg = <0x00010000 DT_SIZE_K(448)>;\n\t\tslot1_partition: partition@80000 {\n\t\t\treg = <0x00080000 DT_SIZE_K(448)>;\n\t\tscratch_partition: partition@f0000 {\n\t\t\tlabel = \"image-scratch\";\n\t\t\treg = <0x000f0000 DT_SIZE_K(16)>;\n\t\t};\n\t\tstorage_partition: partition@f4000 {\n\t\t\treg = <0x000f4000 DT_SIZE_K(48)>;",
  "result": "-\t\t\treg = <0x00010000 DT_SIZE_K(448)>;\n+\t\t\treg = <0x00010000 DT_SIZE_K(456)>;\n-\t\tslot1_partition: partition@80000 {\n+\t\tslot1_partition: partition@82000 {\n-\t\t\treg = <0x00080000 DT_SIZE_K(448)>;\n+\t\t\treg = <0x00082000 DT_SIZE_K(448)>;\n-\t\tscratch_partition: partition@f0000 {\n-\t\t\tlabel = \"image-scratch\";\n-\t\t\treg = <0x000f0000 DT_SIZE_K(16)>;\n-\t\t};\n-\t\tstorage_partition: partition@f4000 {\n+\t\tstorage_partition: partition@f2000 {\n-\t\t\treg = <0x000f4000 DT_SIZE_K(48)>;\n+\t\t\treg = <0x000f2000 DT_SIZE_K(56)>;"
},{
  "instruction": "drivers: wifi: nxp: change the dormant state",
  "input": "\t\tnet_eth_carrier_on(g_mlan.netif);\n\t\tnet_eth_carrier_off(g_mlan.netif);",
  "result": "-\t\tnet_eth_carrier_on(g_mlan.netif);\n+\tcase WLAN_REASON_ASSOC_SUCCESS:\n+\t\tnet_if_dormant_off(g_mlan.netif);\n+\t\tLOG_DBG(\"WLAN: associated to nxp_wlan_network\");\n+\t\tbreak;\n-\t\tnet_eth_carrier_off(g_mlan.netif);\n+\t\tnet_if_dormant_on(g_mlan.netif);\n+\tcase WLAN_REASON_DISCONNECTED:\n+\t\tnet_if_dormant_on(g_mlan.netif);\n+\t\tLOG_DBG(\"WLAN: deauth leaving\");\n+\t\tbreak;\n+\t/* Initialize device as dormant */\n+\tnet_if_dormant_on(g_mlan.netif);\n+\n+\t/* L1 network layer (physical layer) is up */\n+\tnet_eth_carrier_on(g_mlan.netif);\n+\n+CONFIG_NET_TC_SKIP_FOR_HIGH_PRIO=y\n+CONFIG_NET_CONTEXT_PRIORITY=y"
},{
  "instruction": "hostap: Add rts threshold set api support",
  "input": "",
  "result": "+int supplicant_set_rts_threshold(const struct device *dev, unsigned int rts_threshold)\n+{\n+\tconst struct wifi_mgmt_ops *const wifi_mgmt_api = get_wifi_mgmt_api(dev);\n+\n+\tif (!wifi_mgmt_api || !wifi_mgmt_api->set_rts_threshold) {\n+\t\twpa_printf(MSG_ERROR, \"Set RTS not supported\");\n+\t\treturn -ENOTSUP;\n+\t}\n+\n+\treturn wifi_mgmt_api->set_rts_threshold(dev, rts_threshold);\n+}\n+\n+/**\n+ * @brief Set Wi-Fi RTS threshold\n+ *\n+ * @param dev Wi-Fi interface handle to use\n+ * @param rts_threshold RTS threshold to set\n+ * @return 0 for OK; -1 for ERROR\n+ */\n+int supplicant_set_rts_threshold(const struct device *dev, unsigned int rts_threshold);\n+\n+\t.set_rts_threshold = supplicant_set_rts_threshold,"
},{
  "instruction": "drivers: adc: stm32h5x: Set option register for adc1/channel 0",
  "input": "",
  "result": "+#ifdef CONFIG_SOC_SERIES_STM32H5X\n+\tconst struct adc_stm32_cfg *config = (const struct adc_stm32_cfg *)dev->config;\n+\tADC_TypeDef *adc = config->base;\n+#endif\n+\n+#ifdef CONFIG_SOC_SERIES_STM32H5X\n+\tif (adc == ADC1) {\n+\t\tif (channel_cfg->channel_id == 0) {\n+\t\t\tLL_ADC_EnableChannel0_GPIO(adc);\n+\t\t}\n+\t}\n+#endif\n+"
},{
  "instruction": "ci: use latest docker image: v0.26.14",
  "input": "     image: ghcr.io/zephyrproject-rtos/ci-repo-cache:v0.26.13.20240601\n     image: ghcr.io/zephyrproject-rtos/ci-repo-cache:v0.26.13.20240601\n     image: ghcr.io/zephyrproject-rtos/ci-repo-cache:v0.26.13.20240601\n     image: ghcr.io/zephyrproject-rtos/ci-repo-cache:v0.26.13.20240601\n     image: ghcr.io/zephyrproject-rtos/ci-repo-cache:v0.26.13.20240601\n     image: ghcr.io/zephyrproject-rtos/ci-repo-cache:v0.26.13.20240601",
  "result": "-      image: ghcr.io/zephyrproject-rtos/ci-repo-cache:v0.26.13.20240601\n+      image: ghcr.io/zephyrproject-rtos/ci-repo-cache:v0.26.14.20240823\n-      image: ghcr.io/zephyrproject-rtos/ci-repo-cache:v0.26.13.20240601\n+      image: ghcr.io/zephyrproject-rtos/ci-repo-cache:v0.26.14.20240823\n-      image: ghcr.io/zephyrproject-rtos/ci-repo-cache:v0.26.13.20240601\n+      image: ghcr.io/zephyrproject-rtos/ci-repo-cache:v0.26.14.20240823\n-      image: ghcr.io/zephyrproject-rtos/ci-repo-cache:v0.26.13.20240601\n+      image: ghcr.io/zephyrproject-rtos/ci-repo-cache:v0.26.14.20240823\n-      image: ghcr.io/zephyrproject-rtos/ci-repo-cache:v0.26.13.20240601\n+      image: ghcr.io/zephyrproject-rtos/ci-repo-cache:v0.26.14.20240823\n-      image: ghcr.io/zephyrproject-rtos/ci-repo-cache:v0.26.13.20240601\n+      image: ghcr.io/zephyrproject-rtos/ci-repo-cache:v0.26.14.20240823"
},{
  "instruction": "bluetooth: BAS: add gatt notify for battery level status char",
  "input": "\t\t/* Notify/Indicate all connections */\n\t\t\tLOG_DBG(\"Failed to send ntf/ind to all connections (err %d)\\n\", err);",
  "result": "-\t\t/* Notify/Indicate all connections */\n+\t\t/* Indicate all connections */\n-\t\t\tLOG_DBG(\"Failed to send ntf/ind to all connections (err %d)\\n\", err);\n+\t\t\tLOG_DBG(\"Failed to send ind to all connections (err %d)\\n\", err);\n+\t\t}\n+\n+\t\t/* Notify all connections */\n+\t\terr = bt_gatt_notify(NULL, attr, &le_battery_level_status,\n+\t\t\t\t     sizeof(le_battery_level_status));\n+\t\tif (err) {\n+\t\t\tLOG_DBG(\"Failed to send ntf to all connections (err %d)\\n\", err);"
},{
  "instruction": "drivers: stepper: Fix missing _driver_api suffix",
  "input": "\tstatic const struct stepper_api gpio_stepper_api_##child = {                               \\\n__subsystem struct stepper_api {\n\tconst struct stepper_api *api = (const struct stepper_api *)dev->api;\n\tconst struct stepper_api *api = (const struct stepper_api *)dev->api;\n\tconst struct stepper_api *api = (const struct stepper_api *)dev->api;\n\tconst struct stepper_api *api = (const struct stepper_api *)dev->api;\n\tconst struct stepper_api *api = (const struct stepper_api *)dev->api;\n\tconst struct stepper_api *api = (const struct stepper_api *)dev->api;\n\tconst struct stepper_api *api = (const struct stepper_api *)dev->api;\n\tconst struct stepper_api *api = (const struct stepper_api *)dev->api;\n\tconst struct stepper_api *api = (const struct stepper_api *)dev->api;\n\tconst struct stepper_api *api = (const struct stepper_api *)dev->api;",
  "result": "-\tstatic const struct stepper_api gpio_stepper_api_##child = {                               \\\n+\tstatic const struct stepper_driver_api gpio_stepper_api_##child = {                        \\\n-__subsystem struct stepper_api {\n+__subsystem struct stepper_driver_api {\n-\tconst struct stepper_api *api = (const struct stepper_api *)dev->api;\n+\tconst struct stepper_driver_api *api = (const struct stepper_driver_api *)dev->api;\n-\tconst struct stepper_api *api = (const struct stepper_api *)dev->api;\n+\tconst struct stepper_driver_api *api = (const struct stepper_driver_api *)dev->api;\n-\tconst struct stepper_api *api = (const struct stepper_api *)dev->api;\n+\tconst struct stepper_driver_api *api = (const struct stepper_driver_api *)dev->api;\n-\tconst struct stepper_api *api = (const struct stepper_api *)dev->api;\n+\tconst struct stepper_driver_api *api = (const struct stepper_driver_api *)dev->api;\n-\tconst struct stepper_api *api = (const struct stepper_api *)dev->api;\n+\tconst struct stepper_driver_api *api = (const struct stepper_driver_api *)dev->api;\n-\tconst struct stepper_api *api = (const struct stepper_api *)dev->api;\n+\tconst struct stepper_driver_api *api = (const struct stepper_driver_api *)dev->api;\n-\tconst struct stepper_api *api = (const struct stepper_api *)dev->api;\n+\tconst struct stepper_driver_api *api = (const struct stepper_driver_api *)dev->api;\n-\tconst struct stepper_api *api = (const struct stepper_api *)dev->api;\n+\tconst struct stepper_driver_api *api = (const struct stepper_driver_api *)dev->api;\n-\tconst struct stepper_api *api = (const struct stepper_api *)dev->api;\n+\tconst struct stepper_driver_api *api = (const struct stepper_driver_api *)dev->api;\n-\tconst struct stepper_api *api = (const struct stepper_api *)dev->api;\n+\tconst struct stepper_driver_api *api = (const struct stepper_driver_api *)dev->api;"
},{
  "instruction": "manifest: Update EDTT to latest version",
  "input": "     revision: 8d7b543d4d2f2be0f78481e4e1d8d73a88024803",
  "result": "-      revision: 8d7b543d4d2f2be0f78481e4e1d8d73a88024803\n+      revision: b9ca3c7030518f07b7937dacf970d37a47865a76"
},{
  "instruction": "boards: nxp: mimxrt1064: enabled pit driver",
  "input": "",
  "result": "+&pit0 {\n+\tstatus = \"okay\";\n+};\n+\n+/*\n+ * Copyright 2024 NXP\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+&pit0_channel0 {\n+\tstatus = \"okay\";\n+};\n+\n+&pit0_channel1 {\n+\tstatus = \"okay\";\n+};\n+\n+/* channel 2 disabled to test disabled channel not breaking things */\n+\n+&pit0_channel3 {\n+\tstatus = \"okay\";\n+};"
},{
  "instruction": "soc: mimxrt595s/cm33, mimxrt685s/cm33: Add clock config for audio",
  "input": "",
  "result": "+#if (DT_NODE_HAS_COMPAT_STATUS(DT_NODELABEL(flexcomm0), nxp_lpc_i2s, okay) && CONFIG_I2S)\n+\t/* attach AUDIO PLL clock to FLEXCOMM1 (I2S_PDM) */\n+\tCLOCK_AttachClk(kAUDIO_PLL_to_FLEXCOMM0);\n+#endif\n+\n+\n+#if CONFIG_AUDIO_CODEC_WM8904\n+\t/* attach AUDIO PLL clock to MCLK */\n+\tCLOCK_AttachClk(kAUDIO_PLL_to_MCLK_CLK);\n+\tCLOCK_SetClkDiv(kCLOCK_DivMclkClk, 1);\n+\tSYSCTL1->MCLKPINDIR = SYSCTL1_MCLKPINDIR_MCLKPINDIR_MASK;\n+#endif\n+#if CONFIG_AUDIO_CODEC_WM8904\n+\t/* attach AUDIO PLL clock to MCLK */\n+\tCLOCK_AttachClk(kAUDIO_PLL_to_MCLK_CLK);\n+\tCLOCK_SetClkDiv(kCLOCK_DivMclkClk, 1);\n+\tSYSCTL1->MCLKPINDIR = SYSCTL1_MCLKPINDIR_MCLKPINDIR_MASK;\n+#endif\n+"
},{
  "instruction": "drivers: clock_control_mcux_syscon: Add I2S MCLK",
  "input": "",
  "result": "+\n+#if defined(CONFIG_I2S_MCUX_FLEXCOMM)\n+\tcase MCUX_AUDIO_MCLK:\n+\t\t*rate = CLOCK_GetMclkClkFreq();\n+\t\tbreak;\n+#endif /* defined(CONFIG_I2S_MCUX_FLEXCOMM) */\n+#define MCUX_AUDIO_MCLK\t\t\tMCUX_LPC_CLK_ID(0x12, 0x00)\n+"
},{
  "instruction": "tests: kernel: Add support for FLPR core in nRF54L15",
  "input": "#elif defined(CONFIG_SOC_NRF54L15_ENGA_CPUFLPR)",
  "result": "-#elif defined(CONFIG_SOC_NRF54L15_ENGA_CPUFLPR)\n+#elif defined(CONFIG_SOC_NRF54L15_ENGA_CPUFLPR) || defined(CONFIG_SOC_NRF54L15_CPUFLPR)"
},{
  "instruction": "drivers: misc: Add support for nRF54L15 SoC",
  "input": "#if defined(CONFIG_SOC_NRF54L15_ENGA_CPUAPP) && !defined(CONFIG_TRUSTED_EXECUTION_NONSECURE)\n#if defined(CONFIG_SOC_NRF54L15_ENGA_CPUAPP) && !defined(CONFIG_TRUSTED_EXECUTION_NONSECURE)",
  "result": "-#if defined(CONFIG_SOC_NRF54L15_ENGA_CPUAPP) && !defined(CONFIG_TRUSTED_EXECUTION_NONSECURE)\n+#if (defined(CONFIG_SOC_NRF54L15_ENGA_CPUAPP) || defined(CONFIG_SOC_NRF54L15_CPUAPP)) && \\\n+\t!defined(CONFIG_TRUSTED_EXECUTION_NONSECURE)\n-#if defined(CONFIG_SOC_NRF54L15_ENGA_CPUAPP) && !defined(CONFIG_TRUSTED_EXECUTION_NONSECURE)\n+#if (defined(CONFIG_SOC_NRF54L15_ENGA_CPUAPP) || defined(CONFIG_SOC_NRF54L15_CPUAPP)) && \\\n+\t!defined(CONFIG_TRUSTED_EXECUTION_NONSECURE)"
},{
  "instruction": "modules: Add support for nRF54L15 SoC",
  "input": "if(CONFIG_SOC_NRF54L15_ENGA_CPUAPP)",
  "result": "+zephyr_compile_definitions_ifdef(CONFIG_SOC_NRF54L15            NRF54L15_XXAA)\n+zephyr_compile_definitions_ifdef(CONFIG_SOC_NRF54L15_CPUAPP     NRF_APPLICATION)\n+zephyr_compile_definitions_ifdef(CONFIG_SOC_NRF54L15_CPUFLPR    NRF_FLPR)\n-if(CONFIG_SOC_NRF54L15_ENGA_CPUAPP)\n+if(CONFIG_SOC_NRF54L15_ENGA_CPUAPP OR CONFIG_SOC_NRF54L15_CPUAPP)\n+mdk_svd_ifdef(CONFIG_SOC_NRF54L15_CPUAPP      nrf54l15_application.svd)\n+mdk_svd_ifdef(CONFIG_SOC_NRF54L15_CPUFLPR     nrf54l15_flpr.svd)"
},{
  "instruction": "dts: Add missing PDM entries to nRF54L15 device",
  "input": "",
  "result": "+\t\t\tpdm20: pdm@d0000 {\n+\t\t\t\tcompatible = \"nordic,nrf-pdm\";\n+\t\t\t\tstatus = \"disabled\";\n+\t\t\t\treg = <0xd0000 0x1000>;\n+\t\t\t\tinterrupts = <208 NRF_DEFAULT_IRQ_PRIORITY>;\n+\t\t\t};\n+\n+\t\t\tpdm21: pdm@d1000 {\n+\t\t\t\tcompatible = \"nordic,nrf-pdm\";\n+\t\t\t\tstatus = \"disabled\";\n+\t\t\t\treg = <0xd1000 0x1000>;\n+\t\t\t\tinterrupts = <209 NRF_DEFAULT_IRQ_PRIORITY>;\n+\t\t\t};\n+"
},{
  "instruction": "boards: esp32c6_devkitc: Add entropy support",
  "input": "",
  "result": "+&trng0 {\n+\tstatus = \"okay\";\n+};\n+\n+  - entropy"
},{
  "instruction": "sys: timeutil: expose and use macro for base year",
  "input": "\tint64_t y = 1900 + (int64_t)tm->tm_year;",
  "result": "+/* Base Year value use in calculations in \"timeutil_timegm64\" API */\n+#define TIME_UTILS_BASE_YEAR 1900\n+\n-\tint64_t y = 1900 + (int64_t)tm->tm_year;\n+\tint64_t y = TIME_UTILS_BASE_YEAR + (int64_t)tm->tm_year;"
},{
  "instruction": "sys_clock.h: remove deprecated sys_clock_timeout_end_calc()",
  "input": "/**\n* @brief Provided for backward compatibility.\n*\n* This is deprecated. Consider `sys_timepoint_calc()` instead.\n*\n* @see sys_timepoint_calc()\n*/\n__deprecated\nstatic inline uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)\n{\n\tk_timepoint_t tp = sys_timepoint_calc(timeout);\n\treturn tp.tick;\n}",
  "result": "-/**\n- * @brief Provided for backward compatibility.\n- *\n- * This is deprecated. Consider `sys_timepoint_calc()` instead.\n- *\n- * @see sys_timepoint_calc()\n- */\n-__deprecated\n-static inline uint64_t sys_clock_timeout_end_calc(k_timeout_t timeout)\n-{\n-\tk_timepoint_t tp = sys_timepoint_calc(timeout);\n-\n-\treturn tp.tick;\n-}\n-"
},{
  "instruction": "Bluetooth: Classic: SDP: fix that record len is SEQ32",
  "input": "",
  "result": "+\t\tcase BT_SDP_SEQ32:\n+\t\t\t*total = net_buf_pull_be32(buf);\n+\t\t\tpulled += 4U;\n+\t\t\tbreak;\n+\tcase BT_SDP_SEQ32:\n+\t\tlen = net_buf_pull_be32(buf);\n+\t\tbreak;"
},{
  "instruction": "runners: linkserver: Add .elf support to the linkserver flash command",
  "input": "       # Use .hex or .bin, preferring .hex over .bin\n           err = 'Cannot flash; no hex ({}) or bin ({}) file found.'\n           raise ValueError(err.format(self.hex_name, self.bin_name))",
  "result": "-        # Use .hex or .bin, preferring .hex over .bin\n+        # Use hex, bin or elf file provided by the buildsystem.\n+        # Preferring .hex over .bin and .elf\n+        # Preferring .bin over .elf\n+        elif self.elf_name is not None and os.path.isfile(self.elf_name):\n+            flash_cmd = ([\"load\", self.elf_name])\n-            err = 'Cannot flash; no hex ({}) or bin ({}) file found.'\n-            raise ValueError(err.format(self.hex_name, self.bin_name))\n+            err = 'Cannot flash; no hex ({}), bin ({}) or elf ({}) files found.'\n+            raise ValueError(err.format(self.hex_name, self.bin_name, self.elf_name))"
},{
  "instruction": "include: zephyr: drivers: gpio: add include guard to gpio_intel.h",
  "input": "",
  "result": "+#ifndef ZEPHYR_INCLUDE_DRIVERS_GPIO_GPIO_INTEL_H_\n+#define ZEPHYR_INCLUDE_DRIVERS_GPIO_GPIO_INTEL_H_\n+\n+\n+#endif /* ZEPHYR_INCLUDE_DRIVERS_GPIO_GPIO_INTEL_H_ */"
},{
  "instruction": "boards: nucleo_wba55cg: Update blob fetch command",
  "input": "  west blobs fetch stm32",
  "result": "-   west blobs fetch stm32\n+   west blobs fetch hal_stm32\n+* STM32WBA: The command used for fetching blobs required to build ble applications is now\n+  `west blobs fetch hal_stm32` instead of `west blobs fetch stm32`.\n+"
},{
  "instruction": "west.yml: hal_stm32: Add name to module.yml",
  "input": "     revision: 484af4f994737bef9e6ccc3e267cc319b85da332",
  "result": "-      revision: 484af4f994737bef9e6ccc3e267cc319b85da332\n+      revision: 4c1adf8a2e2e9888f3b43374bf6521b0788aa82d"
},{
  "instruction": "tests: Bluetooth: Add missing host features to ICS",
  "input": "﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\r",
  "result": "-﻿<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n+      <item>\r\n+        <table>17b</table>\r\n+        <row>4</row>\r\n+      </item>\r\n+      <item>\r\n+        <table>20A</table>\r\n+        <row>6</row>\r\n+      </item>\r\n+      <item>\r\n+        <table>27</table>\r\n+        <row>7</row>\r\n+      </item>\r\n+      <item>\r\n+        <table>23</table>\r\n+        <row>7</row>\r\n+      </item>\r\n+      <item>\r\n+        <table>3</table>\r\n+        <row>16</row>\r\n+      </item>\r"
},{
  "instruction": "scripts: ci: Fix clang-format compliance for additions or removals",
  "input": "                       before = next(i for i,v in enumerate(hunk) if str(v).startswith('-'))\n                       after = next(i for i,v in enumerate(reversed(hunk)) if str(v).startswith('+'))",
  "result": "-                        before = next(i for i,v in enumerate(hunk) if str(v).startswith('-'))\n-                        after = next(i for i,v in enumerate(reversed(hunk)) if str(v).startswith('+'))\n+                        before = next(i for i,v in enumerate(hunk) if str(v).startswith(('-', '+')))\n+                        after = next(i for i,v in enumerate(reversed(hunk)) if str(v).startswith(('-', '+')))"
},{
  "instruction": "drivers: input: use generic touch report in ft5336",
  "input": "\t\tinput_report_abs(dev, INPUT_ABS_X, col, false, K_FOREVER);\n\t\tinput_report_abs(dev, INPUT_ABS_Y, row, false, K_FOREVER);\ninclude: i2c-device.yaml",
  "result": "+\tselect INPUT_TOUCH\n+#include <zephyr/input/input_touch.h>\n+\tstruct input_touchscreen_common_config common;\n+INPUT_TOUCH_STRUCT_CHECK(struct ft5336_config);\n+\n-\t\tinput_report_abs(dev, INPUT_ABS_X, col, false, K_FOREVER);\n-\t\tinput_report_abs(dev, INPUT_ABS_Y, row, false, K_FOREVER);\n+\t\tinput_touchscreen_report_pos(dev, col, row, K_FOREVER);\n+\t\t.common = INPUT_TOUCH_DT_INST_COMMON_CONFIG_INIT(index),\t\t\\\n-include: i2c-device.yaml\n+include: [i2c-device.yaml, touchscreen-common.yaml]"
},{
  "instruction": "doc: releases: mention change of MCP9808",
  "input": "",
  "result": "+* The existing driver for the Microchip MCP9808 temperature sensor transformed and renamed\n+  to support all JEDEC JC 42.4 compatible temperature sensors. It now uses the\n+  :dtcompatible:`jedec,jc-42.4-temp` compatible string instead to the ``microchip,mcp9808`` string.\n+\n+  * The existing driver for the Microchip MCP9808 temperature sensor transformed and renamed\n+    to support all JEDEC JC 42.4 compatible temperature sensors. It now uses the\n+    :dtcompatible:`jedec,jc-42.4-temp` compatible string instead to the ``microchip,mcp9808``\n+    string.\n+"
},{
  "instruction": "shell: modules: kernel: fix typo in `cmd_kernel_uptime()`",
  "input": "\t\tshell_error(sh, \"Usupported option: %s\", argv[1]);",
  "result": "-\t\tshell_error(sh, \"Usupported option: %s\", argv[1]);\n+\t\tshell_error(sh, \"Unsupported option: %s\", argv[1]);"
},{
  "instruction": "doc: updated release note & migration guide for the `kernel thread` cmd",
  "input": "",
  "result": "+Shell\n+=====\n+\n+* ``kernel threads`` and ``kernel stacks`` shell command have been renamed to\n+  ``kernel thread list`` & ``kernel thread stacks``\n+\n+* Shell:\n+\n+  * Reorganized the ``kernel threads`` and ``kernel stacks`` shell command under the\n+    L1 ``kernel thread`` shell command as ``kernel thread list`` & ``kernel thread stacks``\n+  * Added multiple shell command to configure the CPU mask affinity / pinning a thread in\n+    runtime, do ``kernel thread -h`` for more info.\n+"
},{
  "instruction": "shell: modules: kernel: add additional check in unwind cmd",
  "input": "\t\tthread = UINT_TO_POINTER(strtoll(argv[1], NULL, 16));",
  "result": "+\tint err = 0;\n-\t\tthread = UINT_TO_POINTER(strtoll(argv[1], NULL, 16));\n+\t\tthread = UINT_TO_POINTER(shell_strtoull(argv[1], 16, &err));\n+\t\tif (err != 0) {\n+\t\t\tshell_error(sh, \"Unable to parse thread ID %s (err %d)\", argv[1], err);\n+\t\t\treturn err;\n+\t\t}"
},{
  "instruction": "boards: silabs: Don't explicitly ignore bluetooth and net tags",
  "input": "testing:\n ignore_tags:\n   - net\n   - bluetooth\ntesting:\n ignore_tags:\n   - net\n   - bluetooth\n   - net\n   - bluetooth\ntesting:\n ignore_tags:\n   - net\n   - bluetooth\n   - net\n   - bluetooth",
  "result": "+  - bluetooth\n-testing:\n-  ignore_tags:\n-    - net\n-    - bluetooth\n+  - bluetooth\n-testing:\n-  ignore_tags:\n-    - net\n-    - bluetooth\n+  - bluetooth\n-    - net\n-    - bluetooth\n+  - bluetooth\n-testing:\n-  ignore_tags:\n-    - net\n-    - bluetooth\n+  - bluetooth\n-    - net\n-    - bluetooth"
},{
  "instruction": "boards: silabs: Disable Bluetooth for boards which lack binary blobs",
  "input": "\tchosen {\n\t\tzephyr,bt-hci = &bt_hci_silabs;\n\t};\n&bt_hci_silabs {\n\tstatus = \"okay\";\n};\n\tchosen {\n\t\tzephyr,bt-hci = &bt_hci_silabs;\n\t};\n&bt_hci_silabs {\n\tstatus = \"okay\";\n};\n\tchosen {\n\t\tzephyr,bt-hci = &bt_hci_silabs;\n\t};\n&bt_hci_silabs {\n\tstatus = \"okay\";\n};",
  "result": "-\n-\tchosen {\n-\t\tzephyr,bt-hci = &bt_hci_silabs;\n-\t};\n-\n-&bt_hci_silabs {\n-\tstatus = \"okay\";\n-};\n-\n-\tchosen {\n-\t\tzephyr,bt-hci = &bt_hci_silabs;\n-\t};\n-\n-&bt_hci_silabs {\n-\tstatus = \"okay\";\n-};\n-\n-\tchosen {\n-\t\tzephyr,bt-hci = &bt_hci_silabs;\n-\t};\n-\n-&bt_hci_silabs {\n-\tstatus = \"okay\";\n-};"
},{
  "instruction": "drivers: wifi: Add overrun count in statistics",
  "input": "",
  "result": "+\tzstats->overrun_count = stats.host.total_tx_drop_pkts + stats.host.total_rx_drop_pkts;"
},{
  "instruction": "hostap: Add currnet PHY rate to status",
  "input": "",
  "result": "+\n+\t\tret = wpa_drv_signal_poll(wpa_s, si);\n+\t\tif (!ret) {\n+\t\t\tstatus->current_phy_rate = si->current_txrate;\n+\t\t} else {\n+\t\t\twpa_printf(MSG_WARNING, \"%s: Failed to get signal info\\n\", __func__);\n+\t\t\tstatus->current_phy_rate = 0;\n+\t\t\tret = 0;\n+\t\t}"
},{
  "instruction": "drivers: dma: esp32: Handle Rx water mark interrupt",
  "input": "\tgdma_ll_rx_set_water_mark(data->hal.dev, dma_channel->channel_id, 24);",
  "result": "+#if defined(CONFIG_SOC_SERIES_ESP32S3)\n+\t} else if (intr_status == GDMA_LL_EVENT_RX_WATER_MARK) {\n+\t\tstatus = DMA_STATUS_BLOCK;\n+#endif\n-\tgdma_ll_rx_set_water_mark(data->hal.dev, dma_channel->channel_id, 24);"
},{
  "instruction": "ci: do not run twister on some script changes",
  "input": "",
  "result": "+scripts/ci/check_compliance.py\n+scripts/ci/errno.py\n+scripts/ci/upload_test_results_es.py"
},{
  "instruction": "manifest: Update hostap to latest",
  "input": "     revision: 77a4cad575c91f1b234c8d15630f87999881cde2",
  "result": "-      revision: 77a4cad575c91f1b234c8d15630f87999881cde2\n+      revision: 7761b17eea9a2442af6ea9df830904fa4ba7bbca"
},{
  "instruction": "net: l2: wifi: Fix issue command wifi connect fail.",
  "input": "\tstatic struct wifi_connect_req_params cnx_params;\n\t\t  2, 7),",
  "result": "-\tstatic struct wifi_connect_req_params cnx_params;\n+\tstruct wifi_connect_req_params cnx_params = {0};\n-\t\t  2, 7),\n+\t\t  2, 13),"
},{
  "instruction": "modules: hostap: Supports link mode of legacy STA.",
  "input": "",
  "result": "+#else\n+\t} else if (iface->freq > 4000) {\n+\t\treturn WIFI_2;\n+\t} else if (iface->freq > 2000) {\n+\t\treturn WIFI_3;"
},{
  "instruction": "net: l2: wifi: Increase max count of connected STA",
  "input": "\trange 1 5",
  "result": "-\trange 1 5\n+\trange 1 8"
},{
  "instruction": "modules: hostap: Enable CONFIG_IEEE80211AC flag for hostapd support.",
  "input": "",
  "result": "+\tCONFIG_IEEE80211AC"
},{
  "instruction": "driver: clock_control: renesas_ra: Use pclkblock's clock src defaultly",
  "input": "\t\t\t    {.clk_src = DT_PROP_OR(node_id, clk_src, RA_CLOCK_SOURCE_DISABLE),     \\",
  "result": "-\t\t\t    {.clk_src = DT_PROP_OR(node_id, clk_src, RA_CLOCK_SOURCE_DISABLE),     \\\n+\t\t\t    {.clk_src = DT_PROP_OR(node_id, clk_src,                               \\\n+\t\t\t\t\t\t   DT_PROP_OR(DT_PARENT(node_id), sysclock_src,    \\\n+\t\t\t\t\t\t\t      RA_CLOCK_SOURCE_DISABLE)),           \\"
},{
  "instruction": "boards: nxp: update pinctrl dtsi for ke17z",
  "input": "",
  "result": "+\tflexio_pwm_default: flexio_pwm_default {\n+\t\tgroup0 {\n+\t\t\tpinmux = <FXIO_D3_PTD5>,\n+\t\t\t\t<FXIO_D5_PTD3>;\n+\t\t\tdrive-strength = \"low\";\n+\t\t\tslew-rate = \"slow\";\n+\t\t};\n+\t};\n+\n+\n+\tflexio_pwm_default: flexio_pwm_default {\n+\t\tgroup0 {\n+\t\t\tpinmux = <FXIO_D3_PTD5>,\n+\t\t\t\t<FXIO_D5_PTD3>;\n+\t\t\tdrive-strength = \"low\";\n+\t\t\tslew-rate = \"slow\";\n+\t\t};\n+\t};"
},{
  "instruction": "soc: nxp: kinetis: ke1xz: update soc.c to add flexio clock",
  "input": "",
  "result": "+#if DT_NODE_HAS_STATUS(DT_NODELABEL(flexio), okay)\n+\tCLOCK_SetIpSrc(kCLOCK_Flexio0,\n+\t\t       DT_CLOCKS_CELL(DT_NODELABEL(flexio), ip_source));\n+#endif"
},{
  "instruction": "drivers: spi: update spi_mcux_flexio.c",
  "input": "",
  "result": "+ * Copyright 2024 NXP\n+#if defined(CONFIG_SOC_SERIES_KE1XZ)\n+\t/* Wait until data transfer complete. */\n+\tWAIT_FOR((0U == (FLEXIO_SPI_GetStatusFlags(config->flexio_spi)\n+\t\t& (uint32_t)kFLEXIO_SPI_TxBufferEmptyFlag)), 100, NULL);\n+#endif"
},{
  "instruction": "dts: arm: nxp: nxp_ke1xz.dtsi: add flexio information",
  "input": "",
  "result": "+\n+\t\tflexio: flexio@4005a000 {\n+\t\t\tcompatible = \"nxp,flexio\";\n+\t\t\treg = <0x4005a000 0x1000>;\n+\t\t\tstatus = \"disabled\";\n+\t\t\tinterrupts = <23 0>;\n+\t\t\tclocks = <&pcc 0x168 KINETIS_PCC_SRC_FIRC_ASYNC>;\n+\t\t};"
},{
  "instruction": "tests: thread_analyzer: test for privileged stacks usage",
  "input": "   - mps2/an385",
  "result": "-    - mps2/an385\n+    - qemu_x86\n+    - qemu_xtensa/dc233c/mmu\n+  debug.thread_analyzer.printk.userspace.priv_stack:\n+    filter: CONFIG_ARCH_HAS_USERSPACE\n+    extra_configs:\n+      - CONFIG_THREAD_ANALYZER_USE_PRINTK=y\n+      - CONFIG_THREAD_ANALYZER_PRIV_STACK_USAGE=y\n+      - CONFIG_USERSPACE=y\n+    platform_exclude:\n+      # These platforms do not yet have the necessary bits to determine\n+      # usage of privileged stacks.\n+      - mps2/an385\n+      - qemu_cortex_a53\n+    harness: console\n+    harness_config:\n+      type: multi_line\n+      regex:\n+        - \"(.*)0x([0-9a-fA-F]+)([ ]+) : STACK: unused [0-9]+ usage [0-9]+ / [0-9]+ (.*)\"\n+        - \"(.*)PRIV_STACK: unused [0-9]+ usage [0-9]+ / [0-9]+\"\n+        - \"(.*)ISR0([ ]+) : STACK: unused [0-9]+ usage [0-9]+ / [0-9]+ (.*)\""
},{
  "instruction": "tests: thread_analyzer: disable QEMU icount",
  "input": "",
  "result": "+  extra_configs:\n+    - CONFIG_QEMU_ICOUNT=n"
},{
  "instruction": "riscv: implements arch_thread_priv_stack_space_get",
  "input": "",
  "result": "+\tselect ARCH_HAS_THREAD_PRIV_STACK_SPACE_GET if USERSPACE\n+int arch_thread_priv_stack_space_get(const struct k_thread *thread, size_t *stack_size,\n+\t\t\t\t     size_t *unused_ptr)\n+{\n+\tif ((thread->base.user_options & K_USER) != K_USER) {\n+\t\treturn -EINVAL;\n+\t}\n+\n+\t*stack_size = Z_STACK_PTR_ALIGN(K_KERNEL_STACK_RESERVED + CONFIG_PRIVILEGED_STACK_SIZE);\n+\n+\treturn z_stack_space_get((void *)thread->arch.priv_stack_start, *stack_size, unused_ptr);\n+}\n+"
},{
  "instruction": "riscv: initialize privileged stack during thread init",
  "input": "",
  "result": "+#ifdef CONFIG_INIT_STACKS\n+\t/* Initialize the privileged stack */\n+\t(void)memset((void *)_current->arch.priv_stack_start, 0xaa,\n+\t\t     Z_STACK_PTR_ALIGN(K_KERNEL_STACK_RESERVED + CONFIG_PRIVILEGED_STACK_SIZE));\n+#endif /* CONFIG_INIT_STACKS */\n+"
},{
  "instruction": "xtensa: implements arch_thread_priv_stack_space_get",
  "input": "",
  "result": "+\tselect ARCH_HAS_THREAD_PRIV_STACK_SPACE_GET if USERSPACE\n+#include <errno.h>\n+\n+int arch_thread_priv_stack_space_get(const struct k_thread *thread, size_t *stack_size,\n+\t\t\t\t     size_t *unused_ptr)\n+{\n+\tstruct xtensa_thread_stack_header *hdr_stack_obj;\n+\n+\tif ((thread->base.user_options & K_USER) != K_USER) {\n+\t\treturn -EINVAL;\n+\t}\n+\n+\thdr_stack_obj = (struct xtensa_thread_stack_header *)thread->stack_obj;\n+\n+\treturn z_stack_space_get(&hdr_stack_obj->privilege_stack[0],\n+\t\t\t\t sizeof(hdr_stack_obj->privilege_stack),\n+\t\t\t\t unused_ptr);\n+}"
},{
  "instruction": "xtensa: initialize privileged stack during thread init",
  "input": "",
  "result": "+#ifdef CONFIG_INIT_STACKS\n+\t\t/* setup_thread_stack() does not initialize the architecture specific\n+\t\t * privileged stack. So we need to do it manually here as this function\n+\t\t * is called by arch_new_thread() via z_setup_new_thread() after\n+\t\t * setup_thread_stack() but before thread starts running.\n+\t\t *\n+\t\t * Note that only user threads have privileged stacks and kernel\n+\t\t * only threads do not.\n+\t\t */\n+\t\t(void)memset(&header->privilege_stack[0], 0xaa, sizeof(header->privilege_stack));\n+#endif\n+"
},{
  "instruction": "x86: implements arch_thread_priv_stack_space_get",
  "input": "",
  "result": "+\tselect ARCH_HAS_THREAD_PRIV_STACK_SPACE_GET if USERSPACE\n+#include <errno.h>\n+\n+\n+int arch_thread_priv_stack_space_get(const struct k_thread *thread, size_t *stack_size,\n+\t\t\t\t     size_t *unused_ptr)\n+{\n+\tstruct z_x86_thread_stack_header *hdr_stack_obj;\n+\n+\tif ((thread->base.user_options & K_USER) != K_USER) {\n+\t\treturn -EINVAL;\n+\t}\n+\n+\thdr_stack_obj = (struct z_x86_thread_stack_header *)thread->stack_obj;\n+\n+\treturn z_stack_space_get(&hdr_stack_obj->privilege_stack[0],\n+\t\t\t\t sizeof(hdr_stack_obj->privilege_stack),\n+\t\t\t\t unused_ptr);\n+}"
},{
  "instruction": "x86: initialize privileged stack during thread init",
  "input": "",
  "result": "+\n+#ifdef CONFIG_INIT_STACKS\n+\t\t/* setup_thread_stack() does not initialize the architecture specific\n+\t\t * privileged stack. So we need to do it manually here as this function\n+\t\t * is called by arch_new_thread() via z_setup_new_thread() after\n+\t\t * setup_thread_stack() but before thread starts running.\n+\t\t *\n+\t\t * Note that only user threads have privileged stacks and kernel\n+\t\t * only threads do not.\n+\t\t *\n+\t\t * Also note that this needs to be done before calling\n+\t\t * z_x86_userspace_enter() where it clears the user stack.\n+\t\t * That function requires using the privileged stack for\n+\t\t * code execution so we cannot clear that at the same time.\n+\t\t */\n+\t\tstruct z_x86_thread_stack_header *hdr_stack_obj =\n+\t\t\t(struct z_x86_thread_stack_header *)thread->stack_obj;\n+\n+\t\t(void)memset(&hdr_stack_obj->privilege_stack[0], 0xaa,\n+\t\t\t     sizeof(hdr_stack_obj->privilege_stack));\n+#endif\n+"
},{
  "instruction": "x86: only set psp pointer for thread stacks",
  "input": "\tstruct z_x86_thread_stack_header *header =\n\t\t(struct z_x86_thread_stack_header *)thread->stack_info.mapped.addr;\n\t\t(struct z_x86_thread_stack_header *)thread->stack_obj;\n\tthread->arch.psp =\n\t\theader->privilege_stack + sizeof(header->privilege_stack);",
  "result": "-\tstruct z_x86_thread_stack_header *header =\n+\tif (z_stack_is_user_capable(thread->stack_obj)) {\n+\t\tstruct z_x86_thread_stack_header *header =\n-\t\t(struct z_x86_thread_stack_header *)thread->stack_info.mapped.addr;\n+\t\t\t(struct z_x86_thread_stack_header *)thread->stack_info.mapped.addr;\n-\t\t(struct z_x86_thread_stack_header *)thread->stack_obj;\n+\t\t\t(struct z_x86_thread_stack_header *)thread->stack_obj;\n-\tthread->arch.psp =\n-\t\theader->privilege_stack + sizeof(header->privilege_stack);\n+\t\tthread->arch.psp = header->privilege_stack + sizeof(header->privilege_stack);\n+\t} else {\n+\t\tthread->arch.psp = NULL;\n+\t}"
},{
  "instruction": "debug: thread_analyzer: align output",
  "input": "\t\tTHREAD_ANALYZER_FMT(\"      : Total CPU cycles used: %llu\"),\n\t\tinfo->usage.total_cycles);\n\t\t\t\"         - Current Frame: %llu; Longest Frame: %llu; Average Frame: %llu\"),\n\t\tinfo->usage.current_cycles, info->usage.peak_cycles,",
  "result": "-\t\tTHREAD_ANALYZER_FMT(\"      : Total CPU cycles used: %llu\"),\n-\t\tinfo->usage.total_cycles);\n+\t\tTHREAD_ANALYZER_FMT(\" %-20s: Total CPU cycles used: %llu\"),\n+\t\t\" \", info->usage.total_cycles);\n-\t\t\t\"         - Current Frame: %llu; Longest Frame: %llu; Average Frame: %llu\"),\n-\t\tinfo->usage.current_cycles, info->usage.peak_cycles,\n+\t\t\t\" %-20s: Current Frame: %llu;\"\n+\t\t\t\" Longest Frame: %llu; Average Frame: %llu\"),\n+\t\t\" \", info->usage.current_cycles, info->usage.peak_cycles,"
},{
  "instruction": "samples: sockets: echo_server: fix IPPROTO_IPV6 on UDP sockets",
  "input": "\t\t(void)setsockopt(data->tcp.sock, IPPROTO_IPV6,\n\t\t(void)setsockopt(data->tcp.sock, IPPROTO_IPV6, IPV6_V6ONLY,",
  "result": "-\t\t(void)setsockopt(data->tcp.sock, IPPROTO_IPV6,\n+\t\t(void)setsockopt(data->udp.sock, IPPROTO_IPV6,\n-\t\t(void)setsockopt(data->tcp.sock, IPPROTO_IPV6, IPV6_V6ONLY,\n+\t\t(void)setsockopt(data->udp.sock, IPPROTO_IPV6, IPV6_V6ONLY,"
},{
  "instruction": "ci: github: bump tj-actions/changed-files version",
  "input": "       uses: tj-actions/changed-files@v44\n       uses: tj-actions/changed-files@v44\n       uses: tj-actions/changed-files@v44\n       uses: tj-actions/changed-files@v44\n     uses: tj-actions/changed-files@v44",
  "result": "-        uses: tj-actions/changed-files@v44\n+        uses: tj-actions/changed-files@v45\n-        uses: tj-actions/changed-files@v44\n+        uses: tj-actions/changed-files@v45\n-        uses: tj-actions/changed-files@v44\n+        uses: tj-actions/changed-files@v45\n-        uses: tj-actions/changed-files@v44\n+        uses: tj-actions/changed-files@v45\n-      uses: tj-actions/changed-files@v44\n+      uses: tj-actions/changed-files@v45"
},{
  "instruction": "ci: bsim tests: also run BabbleSim Tests on deleted files",
  "input": "         steps.check-bluetooth-files.outputs.any_changed == 'true'\n         || steps.check-networking-files.outputs.any_changed == 'true'\n         || steps.check-uart-files.outputs.any_changed == 'true'\n         || steps.check-common-files.outputs.any_changed == 'true'\n       if: steps.check-bluetooth-files.outputs.any_changed == 'true' || steps.check-common-files.outputs.any_changed == 'true'\n       if: steps.check-networking-files.outputs.any_changed == 'true' || steps.check-common-files.outputs.any_changed == 'true'\n       if: steps.check-uart-files.outputs.any_changed == 'true' || steps.check-common-files.outputs.any_changed == 'true'",
  "result": "-          steps.check-bluetooth-files.outputs.any_changed == 'true'\n-          || steps.check-networking-files.outputs.any_changed == 'true'\n-          || steps.check-uart-files.outputs.any_changed == 'true'\n-          || steps.check-common-files.outputs.any_changed == 'true'\n+          steps.check-bluetooth-files.outputs.any_modified == 'true'\n+          || steps.check-networking-files.outputs.any_modified == 'true'\n+          || steps.check-uart-files.outputs.any_modified == 'true'\n+          || steps.check-common-files.outputs.any_modified == 'true'\n-        if: steps.check-bluetooth-files.outputs.any_changed == 'true' || steps.check-common-files.outputs.any_changed == 'true'\n+        if: steps.check-bluetooth-files.outputs.any_modified == 'true' || steps.check-common-files.outputs.any_modified == 'true'\n-        if: steps.check-networking-files.outputs.any_changed == 'true' || steps.check-common-files.outputs.any_changed == 'true'\n+        if: steps.check-networking-files.outputs.any_modified == 'true' || steps.check-common-files.outputs.any_modified == 'true'\n-        if: steps.check-uart-files.outputs.any_changed == 'true' || steps.check-common-files.outputs.any_changed == 'true'\n+        if: steps.check-uart-files.outputs.any_modified == 'true' || steps.check-common-files.outputs.any_modified == 'true'"
},{
  "instruction": "ci: doc: build documentation in CI when files are deleted",
  "input": "     file_check: ${{ steps.check-doc-files.outputs.any_changed }}",
  "result": "-      file_check: ${{ steps.check-doc-files.outputs.any_changed }}\n+      file_check: ${{ steps.check-doc-files.outputs.any_modified }}"
},{
  "instruction": "ci: github: bump dawidd6/action-download-artifact from 3 to 6",
  "input": "       uses: dawidd6/action-download-artifact@v3\n     uses: dawidd6/action-download-artifact@v3\n     uses: dawidd6/action-download-artifact@v3",
  "result": "-        uses: dawidd6/action-download-artifact@v3\n+        uses: dawidd6/action-download-artifact@v6\n-      uses: dawidd6/action-download-artifact@v3\n+      uses: dawidd6/action-download-artifact@v6\n-      uses: dawidd6/action-download-artifact@v3\n+      uses: dawidd6/action-download-artifact@v6"
},{
  "instruction": "ci: github: bump actions/stale from 8 to 9",
  "input": "   - uses: actions/stale@v8",
  "result": "-    - uses: actions/stale@v8\n+    - uses: actions/stale@v9"
},{
  "instruction": "ci: github: bump fsfe/reuse-action from 1 to 4",
  "input": "       uses: fsfe/reuse-action@v1",
  "result": "-        uses: fsfe/reuse-action@v1\n+        uses: fsfe/reuse-action@v4"
},{
  "instruction": "boards: renesas: add entropy support for Renesas RA8 boards",
  "input": "",
  "result": "+| ENTROPY      | on-chip    | entropy          |\n+\t\tzephyr,entropy = &trng;\n+\n+&trng {\n+\tstatus = \"okay\";\n+};\n+| ENTROPY      | on-chip    | entropy              |\n+\t\tzephyr,entropy = &trng;\n+\n+&trng {\n+\tstatus = \"okay\";\n+};"
},{
  "instruction": "modules: percepio: Fix python executable name",
  "input": "     COMMAND python3 ${TRACERECORDER_DIR}/kernelports/Zephyr/scripts/tz_parse_syscalls.py ${CMAKE_BINARY_DIR} ${ZEPHYR_BASE}",
  "result": "-      COMMAND python3 ${TRACERECORDER_DIR}/kernelports/Zephyr/scripts/tz_parse_syscalls.py ${CMAKE_BINARY_DIR} ${ZEPHYR_BASE}\n+      COMMAND ${PYTHON_EXECUTABLE} ${TRACERECORDER_DIR}/kernelports/Zephyr/scripts/tz_parse_syscalls.py ${CMAKE_BINARY_DIR} ${ZEPHYR_BASE}"
},{
  "instruction": "boards: nxp: frdm_mcxn947: fix sysbuild mcuboot",
  "input": "",
  "result": "+# Copyright 2024 NXP\n+# SPDX-License-Identifier: Apache-2.0\n+\n+choice MCUBOOT_MODE\n+\tdefault MCUBOOT_MODE_OVERWRITE_ONLY\n+endchoice"
},{
  "instruction": "tests: boards: esp32: Use smh in cache coex test",
  "input": "CONFIG_ESP_HEAP_MIN_EXTRAM_THRESHOLD=2048\n\tmem = k_malloc(SPIRAM_ALLOC_SIZE);",
  "result": "-CONFIG_ESP_HEAP_MIN_EXTRAM_THRESHOLD=2048\n+#include <zephyr/multi_heap/shared_multi_heap.h>\n-\tmem = k_malloc(SPIRAM_ALLOC_SIZE);\n+\tmem = shared_multi_heap_aligned_alloc(SMH_REG_ATTR_EXTERNAL, 32, SPIRAM_ALLOC_SIZE);"
},{
  "instruction": "Tests: Shell: Take into account startup new line",
  "input": "",
  "result": "+\tuint8_t tx_content[SAMPLE_DATA_SIZE] = {0};\n+\t/* get the shell startup newline */\n+\tuart_emul_get_tx_data(fixture.dev, tx_content, SAMPLE_DATA_SIZE);\n+\tzassert_mem_equal(tx_content, \"\\r\\n\", strlen(\"\\r\\n\"));\n+"
},{
  "instruction": "Shell: Remove unnecessary new lines at startup",
  "input": "\tif (z_shell_strlen(sh->default_prompt) > 0) {\n\t\tz_shell_raw_fprintf(sh->fprintf_ctx, \"\\n\\n\");\n\t}",
  "result": "-\tif (z_shell_strlen(sh->default_prompt) > 0) {\n-\t\tz_shell_raw_fprintf(sh->fprintf_ctx, \"\\n\\n\");\n-\t}\n+\t/* print new line before printing the prompt to clear the line\n+\t * vt100 are not used here for compatibility reasons\n+\t */\n+\tz_cursor_next_line_move(sh);"
},{
  "instruction": "Shell: Make `full_line_cmd` return false on empty lines",
  "input": "\treturn ((sh->ctx->cmd_buff_len + z_shell_strlen(sh->ctx->prompt))\n\t\t\t% sh->ctx->vt100_ctx.cons.terminal_wid == 0U);",
  "result": "-\treturn ((sh->ctx->cmd_buff_len + z_shell_strlen(sh->ctx->prompt))\n-\t\t\t% sh->ctx->vt100_ctx.cons.terminal_wid == 0U);\n+\tsize_t line_length = sh->ctx->cmd_buff_len + z_shell_strlen(sh->ctx->prompt);\n+\n+\tif (line_length == 0) {\n+\t\treturn false;\n+\t}\n+\n+\treturn (line_length % sh->ctx->vt100_ctx.cons.terminal_wid == 0U);"
},{
  "instruction": "soc: microchip: mec172x: Add CPU barriers during low power entry/exit",
  "input": "\tuint32_t basepri = 0U;\n\tbasepri = __get_BASEPRI();\n\t__set_BASEPRI(basepri);",
  "result": "-\tuint32_t basepri = 0U;\n-\tbasepri = __get_BASEPRI();\n+\t__DSB();\n-\t__set_BASEPRI(basepri);\n-\n+\t__DSB();\n+\t__ISB();"
},{
  "instruction": "tests: logging/dictionary: limit allowed platforms",
  "input": " filter: CONFIG_LOG_BACKEND_UART and CONFIG_LOG_BACKEND_UART_OUTPUT_DICTIONARY\n         and CONFIG_LOG_BACKEND_UART_OUTPUT_DICTIONARY_HEX\n   integration_platforms:\n     - qemu_x86\n     - qemu_x86_64\n   integration_platforms:\n     - qemu_x86\n     - qemu_x86_64",
  "result": "-  filter: CONFIG_LOG_BACKEND_UART and CONFIG_LOG_BACKEND_UART_OUTPUT_DICTIONARY\n-          and CONFIG_LOG_BACKEND_UART_OUTPUT_DICTIONARY_HEX\n+  # So platform_allow list needs to limit to those platforms.\n+  platform_allow:\n+    - mps2/an385\n+    - qemu_cortex_a53\n+    - qemu_riscv32\n+    - qemu_riscv64\n+    - qemu_x86\n+    - qemu_x86_64\n+  integration_platforms:\n+    - qemu_x86\n+    - qemu_x86_64\n-    integration_platforms:\n-      - qemu_x86\n-      - qemu_x86_64\n-    integration_platforms:\n-      - qemu_x86\n-      - qemu_x86_64"
},{
  "instruction": "drivers: sensor: tmp116: Add ability to set operating mode of TMP116/7",
  "input": "\tswitch (attr) {",
  "result": "-\tswitch (attr) {\n+\tswitch ((int)attr) {\n+\tcase SENSOR_ATTR_TMP116_SHUTDOWN_MODE:\n+\t\treturn tmp116_write_config(dev, TMP116_CFGR_MODE, TMP116_MODE_SHUTDOWN);\n+\n+\tcase SENSOR_ATTR_TMP116_CONTINUOUS_CONVERSION_MODE:\n+\t\treturn tmp116_write_config(dev, TMP116_CFGR_MODE, TMP116_MODE_CONTINUOUS);\n+\n+\tcase SENSOR_ATTR_TMP116_ONE_SHOT_MODE:\n+\t\treturn tmp116_write_config(dev, TMP116_CFGR_MODE, TMP116_MODE_ONE_SHOT);\n+#define TMP116_CFGR_MODE\t\t(BIT(10) | BIT(11))\n+#define TMP116_MODE_CONTINUOUS\t0\n+#define TMP116_MODE_SHUTDOWN\tBIT(10)\n+#define TMP116_MODE_ONE_SHOT\t(BIT(10) | BIT(11))\n+#include <zephyr/drivers/sensor.h>\n+enum sensor_attribute_tmp_116 {\n+\t/** Turn on power saving/one shot mode */\n+\tSENSOR_ATTR_TMP116_ONE_SHOT_MODE = SENSOR_ATTR_PRIV_START,\n+\t/** Shutdown the sensor */\n+\tSENSOR_ATTR_TMP116_SHUTDOWN_MODE,\n+\t/** Turn on continuous conversion */\n+\tSENSOR_ATTR_TMP116_CONTINUOUS_CONVERSION_MODE,\n+};\n+"
},{
  "instruction": "twister: Group test plan reporting options",
  "input": "   case_select.add_argument(\n       help=\"Write a list of tests and platforms to be run to file.\")\n       help=\"Load a list of tests and platforms to be run from file.\")\n   case_select.add_argument(\"--list-tests\", action=\"store_true\",\n   case_select.add_argument(\"--test-tree\", action=\"store_true\",\n                            help=\"\"\"Output the test plan in a tree form\"\"\")\n   parser.add_argument(\"--list-tags\", action=\"store_true\",",
  "result": "+    test_plan_report = parser.add_argument_group(\n+        title=\"Test plan reporting\",\n+        description=\"Report the composed test plan details and exit (dry-run).\"\n+    )\n+\n+    test_plan_report_xor = test_plan_report.add_mutually_exclusive_group()\n+\n-    case_select.add_argument(\n+    test_plan_report_xor.add_argument(\n-        help=\"Write a list of tests and platforms to be run to file.\")\n+        help=\"Write a list of tests and platforms to be run to %(metavar)s file and stop execution. \"\n+             \"The resulting file will have the same content as 'testplan.json'.\")\n-        help=\"Load a list of tests and platforms to be run from file.\")\n+        help=\"Load a list of tests and platforms to be run from a JSON file ('testplan.json' schema).\")\n-    case_select.add_argument(\"--list-tests\", action=\"store_true\",\n+    test_plan_report_xor.add_argument(\"--list-tests\", action=\"store_true\",\n-    case_select.add_argument(\"--test-tree\", action=\"store_true\",\n-                             help=\"\"\"Output the test plan in a tree form\"\"\")\n+    test_plan_report_xor.add_argument(\"--test-tree\", action=\"store_true\",\n+                             help=\"\"\"Output the test plan in a tree form.\"\"\")\n-    parser.add_argument(\"--list-tags\", action=\"store_true\",\n+    test_plan_report_xor.add_argument(\"--list-tags\", action=\"store_true\","
},{
  "instruction": "samples: cpp: use zephyr:code-sample directive",
  "input": ".. _cpp_synchronization:\nC++ Synchronization\n###################\n.. _hello_cpp_world:\nHello C++ World\n###############",
  "result": "-.. _cpp_synchronization:\n+.. zephyr:code-sample:: cpp_synchronization\n+   :name: C++ synchronization\n-C++ Synchronization\n-###################\n+   Use Zephyr synchronization primitives from C++ code.\n-.. _hello_cpp_world:\n+.. zephyr:code-sample:: hello_cpp_world\n+   :name: Hello C++ world\n-Hello C++ World\n-###############\n+   Print \"Hello World\" to the console in C++."
},{
  "instruction": "samples: application_development: use zephyr:code-sample directive",
  "input": "A sample showcasing the NOCOPY flag is provided at\n``$ZEPHYR_BASE/samples/application_development/code_relocation_nocopy/``\n.. _code_relocation_nocopy:\nCode relocation nocopy\n######################\n.. _external_library:\nExternal Library\n#################",
  "result": "-A sample showcasing the NOCOPY flag is provided at\n-``$ZEPHYR_BASE/samples/application_development/code_relocation_nocopy/``\n+A sample showcasing the NOCOPY flag is provided here: :zephyr:code-sample:`code_relocation_nocopy`.\n-.. _code_relocation_nocopy:\n+.. zephyr:code-sample:: code_relocation_nocopy\n+   :name: Code relocation nocopy\n-Code relocation nocopy\n-######################\n+   Relocate code, data, or bss sections using a custom linker script.\n-.. _external_library:\n+.. zephyr:code-sample:: external_library\n+   :name: External Library\n-External Library\n-#################\n+   Include an external static library into the Zephyr build system."
},{
  "instruction": "tests: timer_behavior: align saleae package requirements",
  "input": "grpcio-tools>=1.63.0\nlogic2-automation",
  "result": "-grpcio-tools>=1.63.0\n-logic2-automation\n+protobuf>=5.27.2\n+grpcio-tools>=1.66.0\n+logic2-automation>=1.0.7"
},{
  "instruction": "maintainers: update gd32 platforms maintainer",
  "input": "   - cameled",
  "result": "-    - cameled\n+    - cameled"
},{
  "instruction": "ci: rerun issue check on PR edit",
  "input": "",
  "result": "+    types:\n+      - edited\n+      - opened\n+      - reopened\n+      - synchronize\n+    concurrency:\n+      group: backport-issue-check-${{ github.ref }}\n+      cancel-in-progress: true\n+.github/workflows/backport_issue_check.yml"
},{
  "instruction": "zbus: fix error on ZBUS_CHAN_DEFINE",
  "input": "\t\tIF_ENABLED(CONFIG_ZBUS_PRIORITY_BOOST, (                                  \\\n\t\t\t.highest_observer_priority = ZBUS_MIN_THREAD_PRIORITY,            \\\n\t\t))                                                                        \\",
  "result": "+\t\tIF_ENABLED(CONFIG_ZBUS_PRIORITY_BOOST, (                                  \\\n+\t\t\t.highest_observer_priority = ZBUS_MIN_THREAD_PRIORITY,            \\\n+\t\t))                                                                        \\\n-\t\tIF_ENABLED(CONFIG_ZBUS_PRIORITY_BOOST, (                                  \\\n-\t\t\t.highest_observer_priority = ZBUS_MIN_THREAD_PRIORITY,            \\\n-\t\t))                                                                        \\"
},{
  "instruction": "drivers: cc13xx_cc26xx: pwm: Add polarity flag support",
  "input": "\t/* TODO: Make PWM polarity configurable via DT PWM flag. */",
  "result": "+\tif (flags & PWM_POLARITY_INVERTED) {\n+\t\tHWREG(config->gpt_base + GPT_O_CTL) |= GPT_CTL_TBPWML_INVERTED;\n+\t} else {\n+\t\tHWREG(config->gpt_base + GPT_O_CTL) |= GPT_CTL_TBPWML_NORMAL;\n+\t}\n+\n-\t/* TODO: Make PWM polarity configurable via DT PWM flag. */"
},{
  "instruction": "drivers: dai: sai: don't crash on underrun/overrun",
  "input": "\t\tLOG_ERR(\"FIFO underrun detected\");\n\t\t/* TODO: this will crash the program and should be addressed as\n\t\t * mentioned in TODO list's 2).\n\t\t */\n\t\tz_irq_spurious(NULL);\n\t\tLOG_ERR(\"FIFO overrun detected\");\n\t\t/* TODO: this will crash the program and should be addressed as\n\t\t * mentioned in TODO list's 2).\n\t\t */\n\t\tz_irq_spurious(NULL);",
  "result": "-\t\tLOG_ERR(\"FIFO underrun detected\");\n-\t\t/* TODO: this will crash the program and should be addressed as\n-\t\t * mentioned in TODO list's 2).\n-\t\t */\n-\t\tz_irq_spurious(NULL);\n+\t\tLOG_WRN(\"FIFO underrun detected\");\n+\t\tSAI_TX_RX_STATUS_CLEAR(DAI_DIR_TX, data->regmap, kSAI_FIFOErrorFlag);\n-\t\tLOG_ERR(\"FIFO overrun detected\");\n-\t\t/* TODO: this will crash the program and should be addressed as\n-\t\t * mentioned in TODO list's 2).\n-\t\t */\n-\t\tz_irq_spurious(NULL);\n+\t\tLOG_WRN(\"FIFO overrun detected\");\n+\t\tSAI_TX_RX_STATUS_CLEAR(DAI_DIR_RX, data->regmap, kSAI_FIFOErrorFlag);\n+/* used to clear status flags */\n+#define SAI_TX_RX_STATUS_CLEAR(dir, regmap, which)\t\t\t\t\t\t\\\n+\t((dir) == DAI_DIR_RX ? SAI_RxClearStatusFlags(UINT_TO_I2S(regmap), which)\t\t\\\n+\t\t\t     : SAI_TxClearStatusFlags(UINT_TO_I2S(regmap), which))\n+"
},{
  "instruction": "drivers: intc: stm32: remove STM32_EXTI_LINE_NONE macro",
  "input": "#include <zephyr/drivers/interrupt_controller/exti_stm32.h>\n\t\tif (config->wakeup_line != STM32_EXTI_LINE_NONE) {\n\t\t\t(STM32_EXTI_LINE_NONE)),\n#define STM32_EXTI_LINE_NONE\t0xFFFFFFFFU",
  "result": "-#include <zephyr/drivers/interrupt_controller/exti_stm32.h>\n+#ifdef CONFIG_PM\n+/* Placeholder value when wakeup-line DT property is not defined */\n+#define STM32_WAKEUP_LINE_NONE\t0xFFFFFFFF\n+#endif\n+\n-\t\tif (config->wakeup_line != STM32_EXTI_LINE_NONE) {\n+\t\tif (config->wakeup_line != STM32_WAKEUP_LINE_NONE) {\n-\t\t\t(STM32_EXTI_LINE_NONE)),\n+\t\t\t(STM32_WAKEUP_LINE_NONE)),\n-#define STM32_EXTI_LINE_NONE\t0xFFFFFFFFU\n-"
},{
  "instruction": "docs: gptp: add mention ClockSourceTime interface is supported",
  "input": "Only two Application Interfaces as defined in section 9 of the standard",
  "result": "-Only two Application Interfaces as defined in section 9 of the standard\n+The following Application Interfaces as defined in section 9 of the standard"
},{
  "instruction": "scripts: handle auto defined ZEPHYR_<name>_MODULE settings in compliance",
  "input": "       if self.no_modules:\n           with open(modules_file, 'w') as fp_module_file:\n               fp_module_file.write(\"# Empty\\n\")\n           return",
  "result": "-        if self.no_modules:\n-            with open(modules_file, 'w') as fp_module_file:\n-                fp_module_file.write(\"# Empty\\n\")\n-            return\n-\n+        if self.no_modules:\n+            module_define_content = \"\"\n+            module_definition = re.compile('config ZEPHYR_.*_MODULE.*').search\n+            with open(modules_file, 'r+') as fp_module_file:\n+                for line in fp_module_file:\n+                    if module_definition(line):\n+                        module_define_content += line\n+                        module_define_content += \"\\tbool\\n\"\n+                fp_module_file.seek(0)\n+                fp_module_file.write(module_define_content)\n+                fp_module_file.truncate()\n+"
},{
  "instruction": "drivers: serial: UART PL011 Ambiq PM Fix",
  "input": "",
  "result": "+\tPM_DEVICE_DT_INST_DEFINE(n, uart_ambiq_pm_action);                                         \\"
},{
  "instruction": "MAINTAINERS: Exclude BT ISO from BT Host",
  "input": "",
  "result": "+    - subsys/bluetooth/host/iso.c\n+    - subsys/bluetooth/host/iso_internal.h\n+    - subsys/bluetooth/host/iso.c\n+    - subsys/bluetooth/host/iso_internal.h"
},{
  "instruction": "scripts: RISCV instruction SEPC",
  "input": "sepc||spec",
  "result": "-sepc||spec"
},{
  "instruction": "tests: kernel.common.stack_sentinel: exclude `m2gl025_miv`",
  "input": "",
  "result": "+      - m2gl025_miv    # FIXME: See issue #66070"
},{
  "instruction": "flash: spi_nor: handle SPI bus power",
  "input": "",
  "result": "+\tconst struct spi_nor_config *cfg = dev->config;\n+\n+\n+\t(void)pm_device_runtime_get(cfg->spi.bus);\n+\tconst struct spi_nor_config *cfg = dev->config;\n+\n+\t(void)pm_device_runtime_put(cfg->spi.bus);\n+"
},{
  "instruction": "bluetooth: gatt: Fix ATT Read By Type by DB change unaware client",
  "input": "",
  "result": "+\t/* Reading Database Hash is special as it may be used to make client change aware\n+\t * (Core Specification 5.4 Vol 3. Part G. 2.5.2.1 Robust Caching).\n+\t *\n+\t * GATT client shall always use GATT Read Using Characteristic UUID sub-procedure for\n+\t * reading Database Hash\n+\t * (Core Specification 5.4 Vol 3. Part G. 7.3 Databse Hash)\n+\t */\n+\tif (bt_uuid_cmp(&u.uuid, BT_UUID_GATT_DB_HASH) != 0) {\n+\t\tif (!bt_gatt_change_aware(chan->att->conn, true)) {\n+\t\t\tif (!atomic_test_and_set_bit(chan->flags, ATT_OUT_OF_SYNC_SENT)) {\n+\t\t\t\treturn BT_ATT_ERR_DB_OUT_OF_SYNC;\n+\t\t\t} else {\n+\t\t\t\treturn 0;\n+\t\t\t}\n+\t\t}\n+\t}\n+"
},{
  "instruction": "boards: nxp: mimxrt1180_evk: Set GPT2 status as ok",
  "input": "The mimxrt1180_evk board configuration supports the hardware features listed\nbelow.  For additional features not yet supported, please also refer to the\n:ref:`mimxrt1170_evk` , which is the superset board in NXP's i.MX RT11xx family.\nNXP prioritizes enabling the superset board with NXP's Full Platform Support for\nZephyr.  Therefore, the mimxrt1170_evk board may have additional features\nalready supported, which can also be re-used on this mimxrt1180_evk board:\n| COUNTER   | on-chip    | counter                             |",
  "result": "-The mimxrt1180_evk board configuration supports the hardware features listed\n-below.  For additional features not yet supported, please also refer to the\n-:ref:`mimxrt1170_evk` , which is the superset board in NXP's i.MX RT11xx family.\n-NXP prioritizes enabling the superset board with NXP's Full Platform Support for\n-Zephyr.  Therefore, the mimxrt1170_evk board may have additional features\n-already supported, which can also be re-used on this mimxrt1180_evk board:\n+NXP considers the MIMXRT1180-EVK as the superset board for the i.MX RT118x\n+family of MCUs.  This board is a focus for NXP's Full Platform Support for\n+Zephyr, to better enable the entire RT118x family.  NXP prioritizes enabling\n+this board with new support for Zephyr features.  The mimxrt1180_evk board\n+configuration supports the following hardware features:\n-| COUNTER   | on-chip    | counter                             |\n+| GPT       | on-chip    | counter                             |\n+\n+&gpt2 {\n+\tstatus = \"okay\";\n+};\n+  - counter\n-\n+\n+&gpt2 {\n+\tstatus = \"okay\";\n+};\n+  - counter"
},{
  "instruction": "mipi_dbi: stm32: use proper type for timeout argument",
  "input": "static int mipi_dbi_stm32_fmc_reset(const struct device *dev, uint32_t delay)\n\tk_msleep(delay);",
  "result": "-static int mipi_dbi_stm32_fmc_reset(const struct device *dev, uint32_t delay)\n+static int mipi_dbi_stm32_fmc_reset(const struct device *dev, k_timeout_t delay)\n-\tk_msleep(delay);\n+\tk_sleep(delay);"
},{
  "instruction": "usb: device_next: Respect granularity in UDC buf pool define",
  "input": "\t\tnet_buf_data_##pname[count][size];\t\t\t\t\\\n\t\t.max_alloc_size = size,\t\t\t\t\t\t\\",
  "result": "+\tBUILD_ASSERT((UDC_BUF_GRANULARITY) % (UDC_BUF_ALIGN) == 0,\t\t\\\n+\t\t     \"Code assumes granurality is multiple of alignment\");\t\\\n-\t\tnet_buf_data_##pname[count][size];\t\t\t\t\\\n+\t\tnet_buf_data_##pname[count][ROUND_UP(size, UDC_BUF_GRANULARITY)];\\\n-\t\t.max_alloc_size = size,\t\t\t\t\t\t\\\n+\t\t.max_alloc_size = ROUND_UP(size, UDC_BUF_GRANULARITY),\t\t\\"
},{
  "instruction": "drivers: udc_dwc2: Allow not-multiple-of-4 mps in DMA mode",
  "input": "\tif (priv->bufferdma && (udc_mps_ep_size(cfg) % 4)) {\n\t\t/* TODO: In Buffer DMA mode, DMA will insert padding bytes in\n\t\t * between packets if endpoint Max Packet Size is not multiple\n\t\t * of 4 (DWORD) and single transfer spans across multiple\n\t\t * packets.\n\t\t *\n\t\t * In order to support such Max Packet Sizes, the driver would\n\t\t * have to remove the padding in between the packets. Besides\n\t\t * just driver shuffling the data, the buffers would have to be\n\t\t * large enough to temporarily hold the paddings.\n\t\t *\n\t\t * For the time being just error out early.\n\t\t */\n\t\tLOG_ERR(\"Driver requires MPS to be multiple of 4\");\n\t\treturn -EINVAL;\n\t}",
  "result": "-\tif (priv->bufferdma && (udc_mps_ep_size(cfg) % 4)) {\n-\t\t/* TODO: In Buffer DMA mode, DMA will insert padding bytes in\n-\t\t * between packets if endpoint Max Packet Size is not multiple\n-\t\t * of 4 (DWORD) and single transfer spans across multiple\n-\t\t * packets.\n-\t\t *\n-\t\t * In order to support such Max Packet Sizes, the driver would\n-\t\t * have to remove the padding in between the packets. Besides\n-\t\t * just driver shuffling the data, the buffers would have to be\n-\t\t * large enough to temporarily hold the paddings.\n-\t\t *\n-\t\t * For the time being just error out early.\n-\t\t */\n-\t\tLOG_ERR(\"Driver requires MPS to be multiple of 4\");\n-\t\treturn -EINVAL;\n-\t}\n-"
},{
  "instruction": "drivers: udc_dwc2: Do not enable inactive endpoint",
  "input": "",
  "result": "+\tif (!(diepctl & USB_DWC2_DEPCTL_USBACTEP)) {\n+\t\t/* Do not attempt to write data on inactive endpoint, because\n+\t\t * no fifo is assigned to inactive endpoint and therefore it is\n+\t\t * possible that the write will corrupt other endpoint fifo.\n+\t\t */\n+\t\tirq_unlock(key);\n+\t\treturn -ENOENT;\n+\t}\n+"
},{
  "instruction": "drivers: udc_dwc2: Pass fifo number to tx fifo flush",
  "input": "static void dwc2_flush_tx_fifo(const struct device *dev, const uint8_t idx)\n\t/* TODO: use dwc2_get_dxepctl_reg() */\n\tmem_addr_t diepctl_reg = (mem_addr_t)&base->in_ep[idx].diepctl;\n\tuint32_t fnum;\n\tfnum = usb_dwc2_get_depctl_txfnum(sys_read32(diepctl_reg));\n\t\tdwc2_flush_tx_fifo(dev, ep_idx);",
  "result": "-static void dwc2_flush_tx_fifo(const struct device *dev, const uint8_t idx)\n+static void dwc2_flush_tx_fifo(const struct device *dev, const uint8_t fnum)\n-\t/* TODO: use dwc2_get_dxepctl_reg() */\n-\tmem_addr_t diepctl_reg = (mem_addr_t)&base->in_ep[idx].diepctl;\n-\tuint32_t fnum;\n-\tfnum = usb_dwc2_get_depctl_txfnum(sys_read32(diepctl_reg));\n-\t\tdwc2_flush_tx_fifo(dev, ep_idx);\n+\t\tdwc2_flush_tx_fifo(dev, usb_dwc2_get_depctl_txfnum(dxepctl));"
},{
  "instruction": "manifest: hal_nordic: Pull fix for FW blobs path",
  "input": "     revision: 91654ddc7ce0da523eb4d6be2171208ae2b8fb35",
  "result": "-      revision: 91654ddc7ce0da523eb4d6be2171208ae2b8fb35\n+      revision: 9717cc2845116ac1c4465b1eb8cc913513601e2a"
},{
  "instruction": "scripts: ci: Fix clang-format notice at file beginning/end",
  "input": "                       msg = \"\".join([str(l) for l in hunk[3:-3]])\n                                         file, line=hunk.source_start + hunk.source_length - 3,",
  "result": "-                        msg = \"\".join([str(l) for l in hunk[3:-3]])\n+                        before = next(i for i,v in enumerate(hunk) if str(v).startswith('-'))\n+                        after = next(i for i,v in enumerate(reversed(hunk)) if str(v).startswith('+'))\n+                        msg = \"\".join([str(l) for l in hunk[before:-after or None]])\n+\n-                                          file, line=hunk.source_start + hunk.source_length - 3,\n+                                          file, line=hunk.source_start + hunk.source_length - after,"
},{
  "instruction": "runners: pyocd: Add support for .elf files to the pyocd flash command",
  "input": "           self.logger.warning(\n               'hex file ({}) does not exist; falling back on .bin ({}). '.\n               format(self.hex_name, self.bin_name) +\n               'Consider enabling CONFIG_BUILD_OUTPUT_HEX.')\n               'Cannot flash; no hex ({}) or bin ({}) files found. '.format(\n                   self.hex_name, self.bin_name))",
  "result": "+        # Use hex, bin or elf file provided by the buildsystem.\n+        # Preferring .hex over .bin and .elf\n+        # Preferring .bin over .elf\n-            self.logger.warning(\n-                'hex file ({}) does not exist; falling back on .bin ({}). '.\n-                format(self.hex_name, self.bin_name) +\n-                'Consider enabling CONFIG_BUILD_OUTPUT_HEX.')\n+        elif self.elf_name is not None and os.path.isfile(self.elf_name):\n+            fname = self.elf_name\n-                'Cannot flash; no hex ({}) or bin ({}) files found. '.format(\n-                    self.hex_name, self.bin_name))\n+                'Cannot flash; no hex ({}), bin ({}) or elf ({}) files found. '.format(\n+                    self.hex_name, self.bin_name, self.elf_name))"
},{
  "instruction": "shell: shell_help: fix width for subcommands help text",
  "input": "\tconst uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;",
  "result": "-\tconst uint16_t offset = 2 * strlen(tabulator) + item_name_width + 1;\n+\tstatic const char sub_cmd_sep[] = \": \"; /* subcommands separator */\n+\tconst uint16_t offset = 2 * strlen(tabulator) + item_name_width + strlen(sub_cmd_sep);"
},{
  "instruction": "shell: devmem: minor optimizations",
  "input": "\tif (argc < 2 || argc > 4) {\n\t\treturn -EINVAL;\n\t}\nSHELL_CMD_REGISTER(devmem, &sub_devmem,\n\t\t   \"devmem address [width]\\n\"\n\t\t   \"devmem address <width> <value>\",\n\t\t   cmd_devmem);",
  "result": "-\tif (argc < 2 || argc > 4) {\n-\t\treturn -EINVAL;\n-\t}\n-\n-SHELL_CMD_REGISTER(devmem, &sub_devmem,\n+SHELL_CMD_ARG_REGISTER(devmem, &sub_devmem,\n-\t\t   \"devmem address [width]\\n\"\n+\t\t   \"devmem <address> [<width>]\\n\"\n-\t\t   \"devmem address <width> <value>\",\n-\t\t   cmd_devmem);\n+\t\t   \"devmem <address> <width> <value>\",\n+\t\t   cmd_devmem, 2, 2);"
},{
  "instruction": "drivers: mipi_dbi: nxp_lcdic: calculate reset delay correctly",
  "input": "\tuint32_t delay_ms = k_ticks_to_ms_ceil32(delay);",
  "result": "+\tuint32_t delay_ms = k_ticks_to_ms_ceil32(delay.ticks);\n-\tuint32_t delay_ms = k_ticks_to_ms_ceil32(delay);"
},{
  "instruction": "tests: net: wifi: exclude RW612 based boards",
  "input": "",
  "result": "+      - frdm_rw612 # Requires binary blobs to build\n+      - rd_rw612_bga # Requires binary blobs to build"
},{
  "instruction": "MAINTAINERS: add maintainer for stepper api and driver",
  "input": "",
  "result": "+\"Drivers: Stepper\":\n+  status: maintained\n+  maintainers:\n+    - jilaypandya\n+  files:\n+    - drivers/stepper/\n+    - include/zephyr/drivers/stepper.h\n+    - dts/bindings/stepper/\n+    - doc/hardware/peripherals/stepper.rst\n+    - tests/drivers/build_all/stepper/\n+  labels:\n+    - \"area: Stepper\"\n+  tests:\n+    - drivers.stepper\n+"
},{
  "instruction": "doc: stepper: Add Stepper motor controller documentation",
  "input": "",
  "result": "+   stepper.rst\n+.. _stepper_api:\n+\n+Stepper API\n+###########\n+\n+Overview\n+********\n+\n+The Stepper API provides a set of functions for controlling and configuring stepper motors.\n+It supports a variety of operations, including enabling/disabling the controller, setting the\n+target position of the motor and thereby setting the motor in motion, setting/getting the actual\n+position of the motor and so on.\n+\n+Configuration Options\n+*********************\n+\n+Related configuration options:\n+\n+* :kconfig:option:`CONFIG_STEPPER_INIT_PRIORITY`\n+\n+API Reference\n+*************\n+\n+.. doxygengroup:: stepper_interface"
},{
  "instruction": "usb: fix wrong capacity report for USB mass storage device",
  "input": "\tuint8_t capacity[8];",
  "result": "-\tuint8_t capacity[8];\n+\tstatic uint8_t capacity[8];"
},{
  "instruction": "serial: bluetooth: Print warning once when ring buffer is full",
  "input": "\t\t\tLOG_INF(\"Ring buffer full, discard %c\", c);",
  "result": "-\t\t\tLOG_INF(\"Ring buffer full, discard %c\", c);\n+\t\t\tLOG_WRN_ONCE(\"Ring buffer full, discard %c\", c);"
},{
  "instruction": "input: kbd: add power management support to all keyboard scan drivers",
  "input": "\tDEVICE_DT_INST_DEFINE(n, gpio_kbd_matrix_init, NULL,\t\t\t\t\t\\\nDEVICE_DT_INST_DEFINE(0, &it8xxx2_kbd_init, NULL,\nDEVICE_DT_INST_DEFINE(0, npcx_kbd_init, NULL,",
  "result": "-\tDEVICE_DT_INST_DEFINE(n, gpio_kbd_matrix_init, NULL,\t\t\t\t\t\\\n+\tPM_DEVICE_DT_INST_DEFINE(n, input_kbd_matrix_pm_action);\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\t\t\t\\\n+\tDEVICE_DT_INST_DEFINE(n, gpio_kbd_matrix_init, PM_DEVICE_DT_INST_GET(n),\t\t\\\n-DEVICE_DT_INST_DEFINE(0, &it8xxx2_kbd_init, NULL,\n+PM_DEVICE_DT_INST_DEFINE(0, input_kbd_matrix_pm_action);\n+\n+DEVICE_DT_INST_DEFINE(0, &it8xxx2_kbd_init, PM_DEVICE_DT_INST_GET(0),\n+BUILD_ASSERT(!IS_ENABLED(CONFIG_PM_DEVICE_SYSTEM_MANAGED) ||\n+\t     IS_ENABLED(CONFIG_PM_DEVICE_RUNTIME),\n+\t     \"CONFIG_PM_DEVICE_RUNTIME must be enabled when using CONFIG_PM_DEVICE_SYSTEM_MANAGED\");\n+\n-DEVICE_DT_INST_DEFINE(0, npcx_kbd_init, NULL,\n+PM_DEVICE_DT_INST_DEFINE(0, input_kbd_matrix_pm_action);\n+\n+DEVICE_DT_INST_DEFINE(0, npcx_kbd_init, PM_DEVICE_DT_INST_GET(0),\n+BUILD_ASSERT(!IS_ENABLED(CONFIG_PM_DEVICE_SYSTEM_MANAGED) ||\n+\t     IS_ENABLED(CONFIG_PM_DEVICE_RUNTIME),\n+\t     \"CONFIG_PM_DEVICE_RUNTIME must be enabled when using CONFIG_PM_DEVICE_SYSTEM_MANAGED\");\n+\n+\tret = input_kbd_matrix_pm_action(dev, action);\n+\tif (ret < 0) {\n+\t\treturn ret;\n+\t}\n+"
},{
  "instruction": "doc: releases: update changes about `arch_stack_walk()`",
  "input": "",
  "result": "+  * Added initial support for :c:func:`arch_stack_walk` that supports unwinding via esf only\n+\n+  * The stack traces upon fatal exception now prints the address of stack pointer (sp) or frame\n+    pointer (fp) depending on the build configuration.\n+\n+* x86\n+\n+  * Added initial support for :c:func:`arch_stack_walk` that supports unwinding via esf only\n+"
},{
  "instruction": "subsys/debug: remove `CONFIG_EXCEPTION_STACK_TRACE_SYMTAB`",
  "input": "#ifdef CONFIG_EXCEPTION_STACK_TRACE_SYMTAB\n#endif /* CONFIG_EXCEPTION_STACK_TRACE_SYMTAB */\n#ifdef CONFIG_EXCEPTION_STACK_TRACE_SYMTAB\n#endif\nconfig EXCEPTION_STACK_TRACE_SYMTAB\n\tbool \"Print function names in the stack trace\"\n\tselect SYMTAB\n\tdepends on EXCEPTION_STACK_TRACE\n\thelp\n\t  Enable this if you want to print the function names in the\n\t  stack trace output. This will generate the symtab and\n\t  can consume a lot of ROM if there's a lot of functions.\n     - CONFIG_EXCEPTION_STACK_TRACE_SYMTAB=y",
  "result": "-#ifdef CONFIG_EXCEPTION_STACK_TRACE_SYMTAB\n+#ifdef CONFIG_SYMTAB\n-#endif /* CONFIG_EXCEPTION_STACK_TRACE_SYMTAB */\n+#endif /* CONFIG_SYMTAB */\n-#ifdef CONFIG_EXCEPTION_STACK_TRACE_SYMTAB\n+#ifdef CONFIG_SYMTAB\n-#endif\n+#endif /* CONFIG_SYMTAB */\n-config EXCEPTION_STACK_TRACE_SYMTAB\n-\tbool \"Print function names in the stack trace\"\n-\tselect SYMTAB\n-\tdepends on EXCEPTION_STACK_TRACE\n-\thelp\n-\t  Enable this if you want to print the function names in the\n-\t  stack trace output. This will generate the symtab and\n-\t  can consume a lot of ROM if there's a lot of functions.\n-\n-      - CONFIG_EXCEPTION_STACK_TRACE_SYMTAB=y\n+      - CONFIG_SYMTAB=y"
},{
  "instruction": "arch: document `arch_stack_walk()`",
  "input": "",
  "result": "+/**\n+ * @defgroup arch-stackwalk Architecture-specific Stack Walk APIs\n+ * @ingroup arch-interface\n+ *\n+ * To add API support to an architecture, `arch_stack_walk()` should be implemented and a non-user\n+ * configurable Kconfig `ARCH_HAS_STACKWALK` that is default to `y` should be created in the\n+ * architecture's top level Kconfig, with all the relevant dependencies.\n+ *\n+ * @{\n+ */\n+\n+/**\n+ * arch-stackwalk\n+ * @}\n+ */\n+"
},{
  "instruction": "boards: doc: esp8684_devkitm: Update with wifi support",
  "input": "",
  "result": "+| Wi-Fi      | on-chip    |                                     |"
},{
  "instruction": "west.yml: Update for ESP32C2 wifi support",
  "input": "     revision: 2e3fea844bc09ff09e05ea4807e736352a0dde8c",
  "result": "-      revision: 2e3fea844bc09ff09e05ea4807e736352a0dde8c\n+      revision: 8c2ae3b0017cadac3de1f57592e879a7bb6ef75d"
},{
  "instruction": "scripts: Minimum clang-format version",
  "input": "clang-format",
  "result": "-clang-format\n+clang-format>=15.0.0"
},{
  "instruction": "MAINTAINERS: Add SiM3U maintainer and collaborators",
  "input": "",
  "result": "+Silabs SiM3U Platforms:\n+  status: maintained\n+  maintainers:\n+    - rettichschnidi\n+  collaborators:\n+    - M1cha\n+    - asmellby\n+    - jerome-pouiller\n+    - jhedberg\n+  files:\n+    - boards/silabs/dev_kits/sim3u1xx_dk/\n+    - drivers/*/*_si32*\n+    - drivers/*/Kconfig.si32\n+    - dts/arm/silabs/sim3u*\n+    - dts/bindings/*/*silabs,si32*\n+    - soc/silabs/silabs_sim3/\n+  labels:\n+    - \"platform: Silabs SiM3U\"\n+  description: >-\n+    SiM3U SoCs, dts files, and related drivers. Boards based on SiM3U SoCs.\n+\n+    - rettichschnidi"
},{
  "instruction": "dts: bindings: Add Si32 UART",
  "input": "",
  "result": "+# Copyright (c) 2024 GARDENA GmbH\n+#\n+# SPDX-License-Identifier: Apache-2.0\n+\n+description: Si32 USART\n+\n+compatible: \"silabs,si32-usart\"\n+\n+include: [uart-controller.yaml, pinctrl-device.yaml]\n+\n+properties:\n+  reg:\n+    required: true\n+\n+  interrupts:\n+    required: true\n+\n+  clocks:\n+    required: true"
},{
  "instruction": "dts: bindings: Add Si32 GPIO",
  "input": "",
  "result": "+# Copyright (c) 2024 GARDENA GmbH\n+#\n+# SPDX-License-Identifier: Apache-2.0\n+\n+description: Si32 GPIO node\n+\n+compatible: \"silabs,si32-gpio\"\n+\n+include: [gpio-controller.yaml, base.yaml]\n+\n+properties:\n+  reg:\n+    required: true\n+\n+  \"#gpio-cells\":\n+    const: 2\n+\n+  disable-pullups:\n+    type: boolean\n+\n+gpio-cells:\n+  - pin\n+  - flags"
},{
  "instruction": "dts: bindings: Add Si32 flash controller",
  "input": "",
  "result": "+# Copyright (c) 2024 GARDENA GmbH\n+#\n+# SPDX-License-Identifier: Apache-2.0\n+\n+compatible: \"silabs,si32-flash-controller\"\n+\n+description: Silabs Si32 flash controller\n+\n+include: flash-controller.yaml"
},{
  "instruction": "manifest: hal_silabs: Update HAL version",
  "input": "     revision: a09dd1b82b24aa3060e162c0dfa40026c0dba450",
  "result": "-      revision: a09dd1b82b24aa3060e162c0dfa40026c0dba450\n+      revision: 4c813a1f6c0bba03dec45a3878ba06cfb385565d"
},{
  "instruction": "soc: silabs: Simplify logic",
  "input": "if SOC_FAMILY_SILABS_S0 || SOC_FAMILY_SILABS_S1 || SOC_FAMILY_SILABS_S2\nif SOC_FAMILY_SILABS_S0\nif SOC_FAMILY_SILABS_S1\nif SOC_FAMILY_SILABS_S2",
  "result": "-if SOC_FAMILY_SILABS_S0 || SOC_FAMILY_SILABS_S1 || SOC_FAMILY_SILABS_S2\n-\n+if SOC_FAMILY_SILABS_S0 || SOC_FAMILY_SILABS_S1 || SOC_FAMILY_SILABS_S2\n+\n+if SOC_FAMILY_SILABS_S0\n+\n-if SOC_FAMILY_SILABS_S0\n-\n+if SOC_FAMILY_SILABS_S1\n+\n-if SOC_FAMILY_SILABS_S1\n-\n+if SOC_FAMILY_SILABS_S2\n+\n-if SOC_FAMILY_SILABS_S2\n-"
},{
  "instruction": "tests: Bluetooth: disable optimizations in unit test",
  "input": "",
  "result": "+\n+# Enabling optimizations will make the test fail.\n+# Reason is (at the time of writing) unknown.\n+CONFIG_NO_OPTIMIZATIONS=y"
},{
  "instruction": "Bluetooth: Host: Fix incorrect build assert",
  "input": "BUILD_ASSERT(sizeof(struct closure) < CONFIG_BT_CONN_TX_USER_DATA_SIZE);",
  "result": "-BUILD_ASSERT(sizeof(struct closure) < CONFIG_BT_CONN_TX_USER_DATA_SIZE);\n+BUILD_ASSERT(sizeof(struct closure) <= CONFIG_BT_CONN_TX_USER_DATA_SIZE);"
},{
  "instruction": "drivers: clock_control: Add stm32u0 clock control support",
  "input": " zephyr_library_sources_ifdef(CONFIG_SOC_SERIES_STM32G0X clock_stm32g0.c)",
  "result": "-  zephyr_library_sources_ifdef(CONFIG_SOC_SERIES_STM32G0X clock_stm32g0.c)\n+  zephyr_library_sources_ifdef(CONFIG_SOC_SERIES_STM32G0X clock_stm32g0_u0.c)\n+  zephyr_library_sources_ifdef(CONFIG_SOC_SERIES_STM32U0X clock_stm32g0_u0.c)"
},{
  "instruction": "drivers: flash: flash_stm32: Fix log warning",
  "input": "\t\t\tFLASH_STM32_REGS(dev)->FLASH_STM32_SR &",
  "result": "-\t\t\tFLASH_STM32_REGS(dev)->FLASH_STM32_SR &\n+\t\t\t(unsigned long)FLASH_STM32_REGS(dev)->FLASH_STM32_SR &"
},{
  "instruction": "drivers: hwinfo: stm32u0: Clear standby and stop flags",
  "input": "",
  "result": "+#elif defined(CONFIG_SOC_SERIES_STM32U0X) && defined(PWR_FLAG_SB)\n+\tLL_PWR_ClearFlag_CSB();"
},{
  "instruction": "west.yml: hal_stm32: Add STM32Cube package of the familly stm32u0",
  "input": "     revision: f1317150eac951fdd8259337a47cbbc4c2e6d335",
  "result": "-      revision: f1317150eac951fdd8259337a47cbbc4c2e6d335\n+      revision: 484af4f994737bef9e6ccc3e267cc319b85da332"
},{
  "instruction": "samples: subsys: nvs: Print rc on errors",
  "input": "\t\tprintk(\"Unable to get page info\\n\");\n\t\tprintk(\"Flash Init failed\\n\");",
  "result": "-\t\tprintk(\"Unable to get page info\\n\");\n+\t\tprintk(\"Unable to get page info, rc=%d\\n\", rc);\n-\t\tprintk(\"Flash Init failed\\n\");\n+\t\tprintk(\"Flash Init failed, rc=%d\\n\", rc);"
},{
  "instruction": "net: fix handle unaligned memory access in net_context_bind()",
  "input": "\t\t} else if (addr4->sin_addr.s_addr == INADDR_ANY) {",
  "result": "-\t\t} else if (addr4->sin_addr.s_addr == INADDR_ANY) {\n+\t\t} else if (UNALIGNED_GET(&addr4->sin_addr.s_addr) == INADDR_ANY) {"
},{
  "instruction": "net: ipv6: Do not print error for non-erros for incoming NS",
  "input": "\t\t\t\t\tgoto drop;\n\t\tgoto drop;\n\t\t\tgoto drop;\n\t\t\tgoto drop;\n\t\tgoto drop;\n\t\tgoto drop;",
  "result": "-\t\t\t\t\tgoto drop;\n+\t\t\t\t\tgoto silent_drop;\n-\t\tgoto drop;\n+\t\tgoto silent_drop;\n-\t\t\tgoto drop;\n+\t\t\tgoto silent_drop;\n-\t\t\tgoto drop;\n+\t\t\tgoto silent_drop;\n-\t\tgoto drop;\n+\t\tgoto silent_drop;\n-\t\tgoto drop;\n+\t\tgoto silent_drop;\n+\n+silent_drop:\n+\t/* If the event is not really an error then just ignore it and\n+\t * return 0 so that icmpv6 module will not complain about it.\n+\t */\n+\tnet_stats_update_ipv6_nd_drop(net_pkt_iface(pkt));\n+\n+\treturn 0;"
},{
  "instruction": "net: ipv6: Allow incoming DAD NS message",
  "input": "\t\tNET_DBG(\"DROP: src addr is %s\", \"unspecified\");\n\t\tgoto drop;",
  "result": "-\t\tNET_DBG(\"DROP: src addr is %s\", \"unspecified\");\n-\t\tgoto drop;\n+\t\t/* If this is a possible DAD message, let it pass. Extra checks\n+\t\t * are done in duplicate address detection code to verify that\n+\t\t * the packet is ok.\n+\t\t */\n+\t\tif (!(IS_ENABLED(CONFIG_NET_IPV6_DAD) &&\n+\t\t      net_ipv6_is_addr_solicited_node((struct in6_addr *)hdr->dst))) {\n+\t\t\tNET_DBG(\"DROP: src addr is %s\", \"unspecified\");\n+\t\t\tgoto drop;\n+\t\t}"
},{
  "instruction": "twister: runner: j-link: Fix parameter passing",
  "input": "               base_args.append(f'--dev-id {board_id}')\n       '--dev-id p_id'",
  "result": "-                base_args.append(f'--dev-id {board_id}')\n+                base_args.append('--dev-id')\n+                base_args.append(board_id)\n-        '--dev-id p_id'\n+        '--dev-id', 'p_id'"
},{
  "instruction": "doc: fix issue with keydown/keyup being ignored",
  "input": "",
  "result": "+  setSearchEngineSettingsMenuVisibility(false);"
},{
  "instruction": "doc: esp32: Update board identifier",
  "input": "  :board: esp32_ethernet_kit",
  "result": "-   :board: esp32_ethernet_kit\n+   :board: esp32_ethernet_kit/esp32/procpu"
},{
  "instruction": "net: capture: enable capturing of IPv6/v4 only",
  "input": "\tif (ctx->local.sa_family == AF_INET) {\n\t} else if (ctx->local.sa_family == AF_INET6) {\n\tif (ctx->local.sa_family == AF_INET) {\n\t} else {\n\tif (ctx->local.sa_family == AF_INET) {\n\t} else {",
  "result": "-\tif (ctx->local.sa_family == AF_INET) {\n+\tif (IS_ENABLED(CONFIG_NET_IPV4) && ctx->local.sa_family == AF_INET) {\n-\t} else if (ctx->local.sa_family == AF_INET6) {\n+\t} else if (IS_ENABLED(CONFIG_NET_IPV6) && ctx->local.sa_family == AF_INET6) {\n-\tif (ctx->local.sa_family == AF_INET) {\n+\tif (IS_ENABLED(CONFIG_NET_IPV4) && ctx->local.sa_family == AF_INET) {\n-\t} else {\n+\t} else if (IS_ENABLED(CONFIG_NET_IPV6) && ctx->local.sa_family == AF_INET6) {\n+\t} else {\n+\t\tCODE_UNREACHABLE;\n-\tif (ctx->local.sa_family == AF_INET) {\n+\tif (IS_ENABLED(CONFIG_NET_IPV4) && ctx->local.sa_family == AF_INET) {\n-\t} else {\n+\t} else if (IS_ENABLED(CONFIG_NET_IPV6) && ctx->local.sa_family == AF_INET6) {\n+\t} else {\n+\t\tCODE_UNREACHABLE;"
},{
  "instruction": "net: l2: ieee802154: 6lo_fragment: improved error message",
  "input": "\t\tNET_ERR(\"could not get IPv6 header\");\n\t\t\tNET_ERR(\"could not get UDP header\");\n\t\t\tNET_ERR(\"Could not get a cache entry\");\n\t\t\t/* in case pkt == fcache->pkt, we don't want\n\t\t\tNET_ERR(\"Invalid fragmented packet\");\n\t\t\tNET_ERR(\"Could not uncompress. Bogus packet?\");\n\t\tNET_ERR(\"Nothing to reassemble\");\n\t\tNET_ERR(\"Could not uncompress. Bogus packet?\");",
  "result": "-\t\tNET_ERR(\"could not get IPv6 header\");\n+\t\tNET_ERR(\"Could not get IPv6 header\");\n-\t\t\tNET_ERR(\"could not get UDP header\");\n+\t\t\tNET_ERR(\"Could not get UDP header\");\n+\t\tNET_ERR(\"Fragment too short (%u): fragment dropped\", frag->len);\n-\t\t\tNET_ERR(\"Could not get a cache entry\");\n+\t\t\tNET_ERR(\"Could not allocate fragment cache, consider increasing \"\n+\t\t\t\t\"CONFIG_NET_L2_IEEE802154_FRAGMENT_REASS_CACHE_SIZE: packet \"\n+\t\t\t\t\"dropped\");\n+\t\t/* All fragments received - reassemble packet. */\n+\n-\t\t\t/* in case pkt == fcache->pkt, we don't want\n+\t\t\t/* In case pkt == fcache->pkt, we don't want\n-\t\t\tNET_ERR(\"Invalid fragmented packet\");\n+\t\t\tNET_ERR(\"Invalid fragment type: packet dropped\");\n-\t\t\tNET_ERR(\"Could not uncompress. Bogus packet?\");\n+\t\t\tNET_ERR(\"Invalid 6LoWPAN header: packet dropped\");\n-\t\tNET_ERR(\"Nothing to reassemble\");\n+\t\tNET_WARN(\"Empty payload: packet dropped\");\n-\t\tNET_ERR(\"Could not uncompress. Bogus packet?\");\n+\t\tNET_ERR(\"Invalid header: packet dropped\");"
},{
  "instruction": "samples: net: http_client/server: add logging boilerplate",
  "input": "CONFIG_LOG_MODE_IMMEDIATE=y\nCONFIG_NET_HTTP_LOG_LEVEL_DBG=y",
  "result": "-CONFIG_LOG_MODE_IMMEDIATE=y\n-CONFIG_NET_HTTP_LOG_LEVEL_DBG=y\n+CONFIG_NET_HTTP_LOG_LEVEL_DBG=n\n+CONFIG_NET_IPV6_LOG_LEVEL_DBG=n\n+CONFIG_NET_IPV6_ND_LOG_LEVEL_DBG=n\n+\n+# Network debug config\n+CONFIG_NET_SOCKETS_LOG_LEVEL_DBG=n\n+CONFIG_NET_HTTP_LOG_LEVEL_DBG=n\n+CONFIG_NET_IPV6_LOG_LEVEL_DBG=n\n+CONFIG_NET_IPV6_ND_LOG_LEVEL_DBG=n"
},{
  "instruction": "samples: net: http_client: increase resource requirements",
  "input": "CONFIG_MAIN_STACK_SIZE=2048",
  "result": "+# General config\n+CONFIG_MAIN_STACK_SIZE=3072\n+CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE=2048\n+\n+# Network buffers\n+CONFIG_NET_PKT_RX_COUNT=16\n+CONFIG_NET_PKT_TX_COUNT=16\n+CONFIG_NET_BUF_RX_COUNT=128\n+CONFIG_NET_BUF_TX_COUNT=128\n+CONFIG_NET_CONTEXT_NET_PKT_POOL=y\n+\n-\n-CONFIG_MAIN_STACK_SIZE=2048"
},{
  "instruction": "drivers: video: ov2640: Add 240x240 video format",
  "input": "",
  "result": "+\tOV2640_VIDEO_FORMAT_CAP(240, 240, VIDEO_PIX_FMT_RGB565),   /* 240x240 */"
},{
  "instruction": "drivers: interrupt_controller: nuclei_eclic: support vector mode setting",
  "input": "",
  "result": "+\tselect CLIC_SMCLICSHV_EXT if RISCV_VECTORED_MODE\n+/**\n+ * @brief Set vector mode of interrupt\n+ */\n+void riscv_clic_irq_vector_set(uint32_t irq)\n+{\n+\t/* Set Selective Hardware Vectoring. */\n+\tunion CLICINTATTR intattr = ECLIC_CTRL[irq].INTATTR;\n+\n+\tintattr.b.shv = 1;\n+\tECLIC_CTRL[irq].INTATTR = intattr;\n+}\n+"
},{
  "instruction": "soc: common: riscv-privileged: add riscv_clic_irq_vector_set() for clic",
  "input": "",
  "result": "+config CLIC_SMCLICSHV_EXT\n+\tbool\n+\thelp\n+\t  The selective hardware vectoring extension gives users the flexibility\n+\t  to select the behavior for each interrupt. The CLIC driver needs to\n+\t  implement the riscv_clic_irq_vector_set() function.\n+\n+/**\n+ * @brief Set vector mode of interrupt\n+ *\n+ * @param irq interrupt ID\n+ */\n+void riscv_clic_irq_vector_set(uint32_t irq);\n+\n+void z_riscv_irq_vector_set(unsigned int irq)\n+{\n+#if defined(CONFIG_CLIC_SMCLICSHV_EXT)\n+\triscv_clic_irq_vector_set(irq);\n+#else\n+\tARG_UNUSED(irq);\n+#endif\n+}\n+"
},{
  "instruction": "arch: riscv: add z_riscv_irq_vector_set() to set vector ISR",
  "input": "",
  "result": "+#ifdef CONFIG_RISCV_HAS_CLIC\n+extern void z_riscv_irq_vector_set(unsigned int irq);\n+#else\n+#define z_riscv_irq_vector_set(i) /* Nothing */\n+#endif /* CONFIG_RISCV_HAS_CLIC */\n+\n+\tz_riscv_irq_vector_set(irq_p); \\"
},{
  "instruction": "doc: conf.py: build directory from environment",
  "input": "from sphinx.cmd.build import get_parser\nargs = get_parser().parse_args()\nZEPHYR_BUILD = Path(args.outputdir).resolve()",
  "result": "+  DOCS_HTML_DIR=${CMAKE_CURRENT_BINARY_DIR}/html\n-from sphinx.cmd.build import get_parser\n-\n-args = get_parser().parse_args()\n-ZEPHYR_BUILD = Path(args.outputdir).resolve()\n+ZEPHYR_BUILD = Path(os.environ.get(\"DOCS_HTML_DIR\")).resolve()"
},{
  "instruction": "doc: release: 4.0: Add note on new MCUmgr enum mgmt group",
  "input": "",
  "result": "+  * MCUmgr\n+\n+    * Added support for :ref:`mcumgr_smp_group_10`, which allows for listing information on\n+      supported groups.\n+"
},{
  "instruction": "mgmt: mcumgr: grp: Add names to groups when Kconfig is enabled",
  "input": "",
  "result": "+#ifdef CONFIG_MCUMGR_GRP_ENUM_DETAILS_NAME\n+\t.mg_group_name = \"fs mgmt\",\n+#endif\n+#ifdef CONFIG_MCUMGR_GRP_ENUM_DETAILS_NAME\n+\t.mg_group_name = \"img mgmt\",\n+#endif\n+#ifdef CONFIG_MCUMGR_GRP_ENUM_DETAILS_NAME\n+\t.mg_group_name = \"os mgmt\",\n+#endif\n+#ifdef CONFIG_MCUMGR_GRP_ENUM_DETAILS_NAME\n+\t.mg_group_name = \"settings mgmt\",\n+#endif\n+#ifdef CONFIG_MCUMGR_GRP_ENUM_DETAILS_NAME\n+\t.mg_group_name = \"shell mgmt\",\n+#endif\n+#ifdef CONFIG_MCUMGR_GRP_ENUM_DETAILS_NAME\n+\t.mg_group_name = \"stat mgmt\",\n+#endif\n+#ifdef CONFIG_MCUMGR_GRP_ENUM_DETAILS_NAME\n+\t.mg_group_name = \"zephyr basic mgmt\",\n+#endif"
},{
  "instruction": "drivers: clock_control: esp32c6: Fix for USB/JTAG port",
  "input": "",
  "result": "+#if CONFIG_SERIAL_ESP32_USB\n+#endif"
},{
  "instruction": "drivers: bluetooth: hci: Remove prompt on non user selectable symbols",
  "input": "\tbool \"[REMOVED] HCI using RPMsg\"\n\tbool \"HCI using the IPC subsystem\"\n\tbool \"IPM HCI\"\n\tbool \"STM32WBA HCI driver\"\n\tbool \"Silicon Labs Bluetooth interface\"\n\tbool \"HCI User Channel based driver\"\n\tbool \"ESP32 HCI driver\"\n\tbool \"PSOC6 BLESS driver\"\n\tbool \"DA1469x HCI driver\"\n\tbool \"NXP HCI driver\"\n\tbool \"CYW208XX BLE driver\"\n\tbool \"AMBIQ BT HCI driver\"",
  "result": "-\tbool \"[REMOVED] HCI using RPMsg\"\n+\tbool\n-\tbool \"HCI using the IPC subsystem\"\n+\tbool\n-\tbool \"IPM HCI\"\n+\tbool\n-\tbool \"STM32WBA HCI driver\"\n+\tbool\n-\tbool \"Silicon Labs Bluetooth interface\"\n+\tbool\n-\tbool \"HCI User Channel based driver\"\n+\tbool\n-\tbool \"ESP32 HCI driver\"\n+\tbool\n-\tbool \"PSOC6 BLESS driver\"\n+\tbool\n-\tbool \"DA1469x HCI driver\"\n+\tbool\n-\tbool \"NXP HCI driver\"\n+\tbool\n-\tbool \"CYW208XX BLE driver\"\n+\tbool\n-\tbool \"AMBIQ BT HCI driver\"\n+\tbool"
},{
  "instruction": "mbedtls: remove stray uses of MBEDTLS_ZEPHYR_ENTROPY",
  "input": "CONFIG_MBEDTLS_ZEPHYR_ENTROPY=y",
  "result": "-CONFIG_MBEDTLS_ZEPHYR_ENTROPY=y\n+CONFIG_MBEDTLS_ENTROPY_POLL_ZEPHYR=y"
},{
  "instruction": "mbedtls: remove stray uses MBEDTLS_ENTROPY_ENABLED",
  "input": "\tselect MBEDTLS_ENTROPY_ENABLED\nCONFIG_MBEDTLS_ENTROPY_ENABLED=y",
  "result": "-\tselect MBEDTLS_ENTROPY_ENABLED\n+\tselect MBEDTLS_ENTROPY_C\n-CONFIG_MBEDTLS_ENTROPY_ENABLED=y\n+CONFIG_MBEDTLS_ENTROPY_C=y"
},{
  "instruction": "samples: sockets: echo_server: test on native_sim/native/64",
  "input": "",
  "result": "+      - native_sim/native/64"
},{
  "instruction": "soc: imxrtxxx: Fix flexspi boot issue",
  "input": "",
  "result": "+config FLEXSPI_CONFIG_BLOCK_OFFSET\n+\tdefault 0x400\n+\n+config CODE_DATA_RELOCATION_SRAM\n+\tdefault y if FLASH_MCUX_FLEXSPI_XIP\n+\n+config FLEXSPI_CONFIG_BLOCK_OFFSET\n+\tdefault 0x400\n+\n+config CODE_DATA_RELOCATION_SRAM\n+\tdefault y if FLASH_MCUX_FLEXSPI_XIP\n+"
},{
  "instruction": "intel_adsp: debug_window: Add slot type for debug-stream transport",
  "input": "",
  "result": "+#define ADSP_DW_SLOT_DEBUG_STREAM\t0x53523134"
},{
  "instruction": "tests: kernel: add missing test call argument",
  "input": "#define ztest_run_test_suite(suite, shuffle, suite_iter, case_iter) \\\n\tz_ztest_run_test_suite(STRINGIFY(suite), shuffle, suite_iter, case_iter)\n\tztest_run_test_suite(timer_jitter_drift, false, 1, 1);\n\tztest_run_test_suite(timer_tick_train, false, 1, 1);",
  "result": "+ * @param param Test parameter\n-#define ztest_run_test_suite(suite, shuffle, suite_iter, case_iter) \\\n-\tz_ztest_run_test_suite(STRINGIFY(suite), shuffle, suite_iter, case_iter)\n+#define ztest_run_test_suite(suite, shuffle, suite_iter, case_iter, param) \\\n+\tz_ztest_run_test_suite(STRINGIFY(suite), shuffle, suite_iter, case_iter, param)\n-\tztest_run_test_suite(timer_jitter_drift, false, 1, 1);\n+\tztest_run_test_suite(timer_jitter_drift, false, 1, 1, NULL);\n-\tztest_run_test_suite(timer_tick_train, false, 1, 1);\n+\tztest_run_test_suite(timer_tick_train, false, 1, 1, NULL);"
},{
  "instruction": "drivers: video: allow to specify individual ep with ID >= 0",
  "input": "\tVIDEO_EP_NONE,\n\tVIDEO_EP_ANY,\n\tVIDEO_EP_IN,\n\tVIDEO_EP_OUT,\n\tvideo_flush(dev, VIDEO_EP_ANY, true);",
  "result": "-\tVIDEO_EP_NONE,\n-\tVIDEO_EP_ANY,\n-\tVIDEO_EP_IN,\n-\tVIDEO_EP_OUT,\n+\t/** Targets some part of the video device not bound to an endpoint */\n+\tVIDEO_EP_NONE = -1,\n+\t/** Targets all input or output endpoints of the device */\n+\tVIDEO_EP_ALL = -2,\n+\t/** Targets all input endpoints of the device: those consuming data */\n+\tVIDEO_EP_IN = -3,\n+\t/** Targets all output endpoints of the device: those producing data */\n+\tVIDEO_EP_OUT = -4,\n-\tvideo_flush(dev, VIDEO_EP_ANY, true);\n+\tvideo_flush(dev, VIDEO_EP_ALL, true);"
},{
  "instruction": "mbedtls: improve description of PSA random number generators",
  "input": "\t  Use cryptographically secure random generator to provide random data\n\t  instead of legacy MbedTLS modules (ENTROPY + CTR_DRBG/HMAC_DRBG).\n\t  Use legacy MbedTLS modules (ENTROPY + CTR_DRBG/HMAC_DRBG) as random\n\t  source generators.",
  "result": "-\t  Use cryptographically secure random generator to provide random data\n-\t  instead of legacy MbedTLS modules (ENTROPY + CTR_DRBG/HMAC_DRBG).\n+\t  Use a cryptographically secure random generator to provide random data\n+\t  instead of legacy Mbed TLS modules. This has a smaller footprint\n+\t  than its legacy counterpart MBEDTLS_PSA_CRYPTO_LEGACY_RNG, but it\n+\t  requires a cryptographically secure random number generator (CSPRNG)\n+\t  to be available in the system. If no CSPRNG is available:\n+\t  - there is no fallback to weak entropy random generators.\n+\t  - the initialization of PSA crypto will fail and none of its API\n+\t    will be available.\n-\t  Use legacy MbedTLS modules (ENTROPY + CTR_DRBG/HMAC_DRBG) as random\n-\t  source generators.\n+\t  Use legacy Mbed TLS modules to generate random data. In this\n+\t  configuration the entropy module is used to gather some data and then\n+\t  either ctr_drbg or hmac_drbg are applied on top of it to improve\n+\t  the randomness.\n+\t  Security level in this case really depends on the type of entropy\n+\t  sources which are enabled in the system: if weak entropy sources are\n+\t  used, then the generated data will only be pseudo random. Strong\n+\t  entropy sources are strongly recommended (if possible) to have real\n+\t  random data.\n+\t  Another difference betwen this implementation and the\n+\t  MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG counterpart is the memory footprint:\n+\t  this implementation brings in legacy modules which are not required\n+\t  in the \"external\" version, so the footprint is larger."
},{
  "instruction": "mbedtls: rename MBEDTLS_ENTROPY_ENABLED as MBEDTLS_ENTROPY_C",
  "input": "\tselect MBEDTLS_ENTROPY_ENABLED\nconfig MBEDTLS_ENTROPY_ENABLED\n\tbool \"MbedTLS generic entropy pool\"\n\tselect MBEDTLS_ENTROPY_ENABLED\n#if defined(CONFIG_MBEDTLS_ENTROPY_ENABLED)\nCONFIG_MBEDTLS_ENTROPY_ENABLED=y\n\tselect MBEDTLS_ENTROPY_ENABLED",
  "result": "-\tselect MBEDTLS_ENTROPY_ENABLED\n+\tselect MBEDTLS_ENTROPY_C\n-config MBEDTLS_ENTROPY_ENABLED\n-\tbool \"MbedTLS generic entropy pool\"\n+config MBEDTLS_ENTROPY_C\n+\tbool \"Mbed TLS entropy accumulator\"\n+\thelp\n+\t  This module gathers entropy data from enabled entropy sources. It's\n+\t  mostly used in conjunction with CTR_DRBG or HMAC_DRBG to create\n+\t  a deterministic random number generator.\n-\tselect MBEDTLS_ENTROPY_ENABLED\n+\tselect MBEDTLS_ENTROPY_C\n-#if defined(CONFIG_MBEDTLS_ENTROPY_ENABLED)\n+#if defined(CONFIG_MBEDTLS_ENTROPY_C)\n-CONFIG_MBEDTLS_ENTROPY_ENABLED=y\n+CONFIG_MBEDTLS_ENTROPY_C=y\n-\tselect MBEDTLS_ENTROPY_ENABLED\n+\tselect MBEDTLS_ENTROPY_C"
},{
  "instruction": "kernel: remove deprecated macro K_THREAD_STACK_MEMBER",
  "input": "#define K_THREAD_STACK_MEMBER\t\tK_KERNEL_STACK_MEMBER\n/**\n* @brief Define an embedded stack memory region\n*\n* Used for stacks embedded within other data structures. Use is highly\n* discouraged but in some cases necessary. For memory protection scenarios,\n* it is very important that any RAM preceding this member not be writable\n* by threads else a stack overflow will lead to silent corruption. In other\n* words, the containing data structure should live in RAM owned by the kernel.\n*\n* A user thread can only be started with a stack defined in this way if\n* the thread starting it is in supervisor mode.\n*\n* @deprecated This is now deprecated, as stacks defined in this way are not\n*             usable from user mode. Use K_KERNEL_STACK_MEMBER.\n*\n* @param sym Thread stack symbol name\n* @param size Size of the stack memory region\n*/\n#define K_THREAD_STACK_MEMBER(sym, size) __DEPRECATED_MACRO \\\n\tZ_THREAD_STACK_DEFINE_IN(sym, size,)",
  "result": "+* Macro ``K_THREAD_STACK_MEMBER``, deprecated since v3.5.0, has been removed.\n+  Use :c:macro:`K_KERNEL_STACK_MEMBER` instead.\n+\n-#define K_THREAD_STACK_MEMBER\t\tK_KERNEL_STACK_MEMBER\n-/**\n- * @brief Define an embedded stack memory region\n- *\n- * Used for stacks embedded within other data structures. Use is highly\n- * discouraged but in some cases necessary. For memory protection scenarios,\n- * it is very important that any RAM preceding this member not be writable\n- * by threads else a stack overflow will lead to silent corruption. In other\n- * words, the containing data structure should live in RAM owned by the kernel.\n- *\n- * A user thread can only be started with a stack defined in this way if\n- * the thread starting it is in supervisor mode.\n- *\n- * @deprecated This is now deprecated, as stacks defined in this way are not\n- *             usable from user mode. Use K_KERNEL_STACK_MEMBER.\n- *\n- * @param sym Thread stack symbol name\n- * @param size Size of the stack memory region\n- */\n-#define K_THREAD_STACK_MEMBER(sym, size) __DEPRECATED_MACRO \\\n-\tZ_THREAD_STACK_DEFINE_IN(sym, size,)\n-"
},{
  "instruction": "modules: mbedtls: Enable PEM writing when PEM cert format is selected",
  "input": "",
  "result": "+#define MBEDTLS_PEM_WRITE_C"
},{
  "instruction": "boards: nxp: mimxrt1180_evk: change to use hyperram as RAM region",
  "input": "\t\tzephyr,sram = &dtcm;",
  "result": "+    if(CONFIG_EXTERNAL_MEM_CONFIG_DATA AND CONFIG_NXP_IMX_EXTERNAL_HYPERRAM)\n+    zephyr_compile_definitions(USE_HYPERRAM)\n+    endif()\n+# Use External Memory Configuration Data (XMCD) by default when booting primary core (M33)\n+config EXTERNAL_MEM_CONFIG_DATA\n+\tdefault y if CPU_CORTEX_M33\n+\n+config NXP_IMX_EXTERNAL_HYPERRAM\n+\tdefault y if CPU_CORTEX_M33\n+\n-\t\tzephyr,sram = &dtcm;\n+\t\tzephyr,sram = &hyperram0;\n+\t\tzephyr,dtcm = &dtcm;\n+\t\tzephyr,itcm = &itcm;\n+\n+\thyperram0: memory@14000000 {\n+\t\t/* Winbond W957A8MFYA5K */\n+\t\tdevice_type = \"memory\";\n+\t\treg = <0x14000000 DT_SIZE_M(8)>;\n+\t};"
},{
  "instruction": "dts: arm: nxp: add ITCM/DTCM region into linker",
  "input": "\t\t\tcompatible = \"nxp,imx-itcm\";\n\t\t\tcompatible = \"nxp,imx-dtcm\";\n\t\t\tcompatible = \"nxp,imx-itcm\";\n\t\t\tcompatible = \"nxp,imx-dtcm\";",
  "result": "-\t\t\tcompatible = \"nxp,imx-itcm\";\n+\t\t\tcompatible = \"zephyr,memory-region\", \"nxp,imx-itcm\";\n+\t\t\tzephyr,memory-region = \"ITCM\";\n-\t\t\tcompatible = \"nxp,imx-dtcm\";\n+\t\t\tcompatible = \"zephyr,memory-region\", \"nxp,imx-dtcm\";\n+\t\t\tzephyr,memory-region = \"DTCM\";\n-\t\t\tcompatible = \"nxp,imx-itcm\";\n+\t\t\tcompatible = \"zephyr,memory-region\", \"nxp,imx-itcm\";\n+\t\t\tzephyr,memory-region = \"ITCM\";\n-\t\t\tcompatible = \"nxp,imx-dtcm\";\n+\t\t\tcompatible = \"zephyr,memory-region\", \"nxp,imx-dtcm\";\n+\t\t\tzephyr,memory-region = \"DTCM\";"
},{
  "instruction": "doc: kernel: fix doxygen for K_FP_REGS",
  "input": "#define K_FP_IDX 1",
  "result": "+#define K_FP_IDX 1\n-#define K_FP_IDX 1"
},{
  "instruction": "soc: esp32: kconfig: add unsupported revision config",
  "input": "     revision: e05b24f5caee741e0f3b43123bf2082e8cc908e7",
  "result": "+config ESP32_USE_UNSUPPORTED_REVISION\n+\tbool \"Use unsupported ESP32 revision (Rev 0/1)\"\n+\thelp\n+\t  ESP32 SoC has multiple revisions, some of which are not supported by the current\n+\t  implementation, as such as REV0 and REV1. In case those revisions are required,\n+\t  set this option to enable support for them. Note that this is not recommended and\n+\t  may lead to unexpected behavior.\n+\n+\tdefault n if ESP32_USE_UNSUPPORTED_REVISION && SOC_SERIES_ESP32\n-      revision: e05b24f5caee741e0f3b43123bf2082e8cc908e7\n+      revision: 2e3fea844bc09ff09e05ea4807e736352a0dde8c"
},{
  "instruction": "twister: tests: Add unit test for readline method in handler",
  "input": "",
  "result": "+def test_devicehandler_monitor_serial_splitlines(mocked_instance):\n+    halt_event = mock.Mock(is_set=mock.Mock(return_value=False))\n+    ser = mock.Mock(\n+        isOpen=mock.Mock(side_effect=[True, True, False]),\n+        in_waiting=mock.Mock(return_value=False),\n+        readline=mock.Mock(return_value='\\nline1\\nline2\\n'.encode('utf-8'))\n+    )\n+    harness = mock.Mock(status=TwisterStatus.PASS)\n+\n+    handler = DeviceHandler(mocked_instance, 'build')\n+    handler.options = mock.Mock(enable_coverage=False)\n+\n+    with mock.patch('builtins.open', mock.mock_open(read_data='')):\n+        handler.monitor_serial(ser, halt_event, harness)\n+\n+    assert harness.handle.call_count == 2\n+\n+"
},{
  "instruction": "twister: scripts: Split lines before processing",
  "input": "               sl = serial_line.decode('utf-8', 'ignore').lstrip()\n               logger.debug(\"DEVICE: {0}\".format(sl.rstrip()))\n               log_out_fp.write(strip_ansi_sequences(sl).encode('utf-8'))\n               log_out_fp.flush()\n               harness.handle(sl.rstrip())",
  "result": "-                sl = serial_line.decode('utf-8', 'ignore').lstrip()\n-                logger.debug(\"DEVICE: {0}\".format(sl.rstrip()))\n-\n-                log_out_fp.write(strip_ansi_sequences(sl).encode('utf-8'))\n-                log_out_fp.flush()\n-                harness.handle(sl.rstrip())\n+                # can be more lines in serial_line so split them before handling\n+                for sl in serial_line.decode('utf-8', 'ignore').splitlines():\n+                    log_out_fp.write(strip_ansi_sequences(sl).encode('utf-8'))\n+                    log_out_fp.flush()\n+                    if sl := sl.strip():\n+                        logger.debug(\"DEVICE: {0}\".format(sl))\n+                        harness.handle(sl)"
},{
  "instruction": "doc: clean ENABLED_SECTION option for doxygen",
  "input": "ENABLED_SECTIONS       = YES",
  "result": "-ENABLED_SECTIONS       = YES\n+ENABLED_SECTIONS       ="
},{
  "instruction": "sys/poweroff: remove extra doxygen group ending command",
  "input": "/** @} */",
  "result": "-/** @} */\n-"
},{
  "instruction": "serial: fix doxygen tag typo",
  "input": "/** @briref Data associated with the asynchronous to the interrupt driven API adaptation layer. */",
  "result": "-/** @briref Data associated with the asynchronous to the interrupt driven API adaptation layer. */\n+/** @brief Data associated with the asynchronous to the interrupt driven API adaptation layer. */"
},{
  "instruction": "regulator: fix doxygen ref tag typo.",
  "input": "\t/** Flags (@reg REGULATOR_FLAGS). */",
  "result": "-\t/** Flags (@reg REGULATOR_FLAGS). */\n+\t/** Flags (@ref REGULATOR_FLAGS). */"
},{
  "instruction": "mbox: fix param typo in mbox_set_enabled_t",
  "input": "* @param enables Set to 0 to disable and to nonzero to enable.",
  "result": "- * @param enables Set to 0 to disable and to nonzero to enable.\n+ * @param enabled Set to 0 to disable and to nonzero to enable."
},{
  "instruction": "drivers: dma: esp32: Add psram support",
  "input": "\tif (!esp_ptr_dma_capable((uint32_t *)block->dest_address)) {\n\tif (!esp_ptr_dma_capable((uint32_t *)block->source_address)) {",
  "result": "-\tif (!esp_ptr_dma_capable((uint32_t *)block->dest_address)) {\n+\tif (!esp_ptr_dma_capable((uint32_t *)block->dest_address)\n+#if defined(CONFIG_ESP_SPIRAM)\n+\t&& !esp_ptr_dma_ext_capable((uint32_t *)block->dest_address)\n+#endif\n+\t) {\n+\tgdma_ll_rx_set_water_mark(data->hal.dev, dma_channel->channel_id, 24);\n-\tif (!esp_ptr_dma_capable((uint32_t *)block->source_address)) {\n+\tif (!esp_ptr_dma_capable((uint32_t *)block->source_address)\n+#if defined(CONFIG_ESP_SPIRAM)\n+\t&& !esp_ptr_dma_ext_capable((uint32_t *)block->source_address)\n+#endif\n+\t) {"
},{
  "instruction": "net: shell: cm: Fix snprintf warnings on NEWLIBC",
  "input": "\tsnprintf(buf, len, \"%d (%p - %s - %s)\", net_if_get_by_iface(iface), iface, name,\n\tsnprintf(buf, len, \"%d (%p - %s)\", net_if_get_by_iface(iface), iface,",
  "result": "-\tsnprintf(buf, len, \"%d (%p - %s - %s)\", net_if_get_by_iface(iface), iface, name,\n+\tsnprintk(buf, len, \"%d (%p - %s - %s)\", net_if_get_by_iface(iface), iface, name,\n-\tsnprintf(buf, len, \"%d (%p - %s)\", net_if_get_by_iface(iface), iface,\n+\tsnprintk(buf, len, \"%d (%p - %s)\", net_if_get_by_iface(iface), iface,"
},{
  "instruction": "devicetree: Reduce LoRa SPI frequency to allow reliable communciation",
  "input": "\t\tspi-max-frequency = <16000000>;",
  "result": "-\t\tspi-max-frequency = <16000000>;\n+\t\tspi-max-frequency = <4000000>;"
},{
  "instruction": "shell: modules: kernel: print cpu_mask when available",
  "input": "",
  "result": "+#ifdef CONFIG_SCHED_CPU_MASK\n+\tshell_print(sh, \"\\tcpu_mask: 0x%x\", thread->base.cpu_mask);\n+#endif /* CONFIG_SCHED_CPU_MASK */\n+"
},{
  "instruction": "boards: dts: esp_rust: enable bluetooth peripheral",
  "input": "",
  "result": "+&esp32_bt_hci {\n+\tstatus = \"okay\";\n+};\n+"
},{
  "instruction": "tests: net: socket: udp: clear control data buffer before recvmsg",
  "input": "",
  "result": "+\tmemset(cmsgbuf, 0, cmsgbuf_len);\n+\tmemset(cmsgbuf, 0, cmsgbuf_len);\n+\tmemset(cmsgbuf, 0, cmsgbuf_len);"
},{
  "instruction": "twister: pytest: Change the order or pytest-args",
  "input": "       command.extend(pytest_args_yaml)",
  "result": "+        command.extend(pytest_args_yaml)\n+\n-        command.extend(pytest_args_yaml)\n-\n+    assert command.index(pytest_args_from_yaml) < command.index(pytest_args_from_cmd[1])"
},{
  "instruction": "drivers: spi: esp32: fix exception in mode 3 & soft-ctrld CS",
  "input": "\tdata->dfs = spi_esp32_get_frame_size(spi_cfg);",
  "result": "+\tdata->dfs = spi_esp32_get_frame_size(spi_cfg);\n+\n-\tdata->dfs = spi_esp32_get_frame_size(spi_cfg);\n-"
},{
  "instruction": "drivers: led: lp5569: add charge pump configuration",
  "input": "\t\t\t\t    LP5569_POWERSAVE_EN);",
  "result": "+  * lp5569: added ``charge-pump-mode`` property to configure the charge pump of the lp5569.\n+\n+#define LP5569_CP_MODE_SHIFT\t\t3\n+\tconst uint8_t cp_mode;\n-\t\t\t\t    LP5569_POWERSAVE_EN);\n+\t\t\t\t    LP5569_POWERSAVE_EN |\n+\t\t\t\t    (config->cp_mode << LP5569_CP_MODE_SHIFT));\n+\t\t.cp_mode = DT_ENUM_IDX(DT_DRV_INST(id), charge_pump_mode),\t\\\n+\n+properties:\n+  charge-pump-mode:\n+    type: string\n+    default: \"disabled\"\n+    enum:\n+      - \"disabled\"\n+      - \"1x\"\n+      - \"1x5\"\n+      - \"auto\"\n+    description: |\n+      If provided, configures the internal charge-pump mode in the MISC\n+      register. This can be useful to supply a higher voltage to the LEDs, than\n+      what the lp5569 is being supplied.\n+      The default corresponds to the reset value of the register."
},{
  "instruction": "posix: procN: add missing alias for getpid()",
  "input": "",
  "result": "+#ifdef CONFIG_POSIX_MULTI_PROCESS_ALIAS_GETPID\n+FUNC_ALIAS(getpid, _getpid, pid_t);\n+#endif /* CONFIG_POSIX_MULTI_PROCESS_ALIAS_GETPID */"
},{
  "instruction": "logging: fix log buffer pending while it is definitely full",
  "input": "",
  "result": "+\tk_spinlock_key_t key = k_spin_lock(&buffer->lock);\n+\tk_spin_unlock(&buffer->lock, key);"
},{
  "instruction": "MAINTAINERS: Add Espressif collaborators",
  "input": "",
  "result": "+    - raffarost\n+    - wmrsouza"
},{
  "instruction": "i2c: nrfx_twi: fix RTIO utility functions",
  "input": "\t\t(void)i2c_rtio_recover(ctx);\n\t.configure   = i2c_nrfx_twi_configure,\n\t.recover_bus = i2c_nrfx_twi_recover_bus,",
  "result": "-\t\t(void)i2c_rtio_recover(ctx);\n+\t\t(void)i2c_nrfx_twi_recover_bus(dev);\n+static int i2c_nrfx_twi_rtio_configure(const struct device *dev, uint32_t i2c_config)\n+{\n+\tstruct i2c_rtio *const ctx = ((struct i2c_nrfx_twi_rtio_data *)\n+\t\tdev->data)->ctx;\n+\n+\treturn i2c_rtio_configure(ctx, i2c_config);\n+}\n+\n+static int i2c_nrfx_twi_rtio_recover_bus(const struct device *dev)\n+{\n+\tstruct i2c_rtio *const ctx = ((struct i2c_nrfx_twi_rtio_data *)\n+\t\tdev->data)->ctx;\n+\n+\treturn i2c_rtio_recover(ctx);\n+}\n+\n-\t.configure   = i2c_nrfx_twi_configure,\n+\t.configure   = i2c_nrfx_twi_rtio_configure,\n-\t.recover_bus = i2c_nrfx_twi_recover_bus,\n+\t.recover_bus = i2c_nrfx_twi_rtio_recover_bus,"
},{
  "instruction": "drivers: sensor: st: vl53l1x: add return to attr_set and attr_get",
  "input": "\t\tvl53l1x_get_mode(dev, val);\n\t\tvl53l1x_get_roi(dev, val);\n\treturn 0;\n\t\tvl53l1x_set_mode(dev, val);\n\t\tvl53l1x_set_roi(dev, val);\n\treturn 0;",
  "result": "+\tint ret;\n+\n-\t\tvl53l1x_get_mode(dev, val);\n+\t\tret = vl53l1x_get_mode(dev, val);\n-\t\tvl53l1x_get_roi(dev, val);\n+\t\tret = vl53l1x_get_roi(dev, val);\n-\treturn 0;\n+\treturn ret;\n+\tint ret;\n+\n-\t\tvl53l1x_set_mode(dev, val);\n+\t\tret = vl53l1x_set_mode(dev, val);\n-\t\tvl53l1x_set_roi(dev, val);\n+\t\tret = vl53l1x_set_roi(dev, val);\n-\treturn 0;\n+\treturn ret;"
},{
  "instruction": "cmake: add check_arguments_... macro to facilitate function writing",
  "input": "",
  "result": "+#\n+# Helper macro for verifying that at least one of the required arguments has\n+# been provided by the caller. Arguments with empty values are allowed.\n+#\n+# A FATAL_ERROR will be raised if not one of the required arguments has been\n+# passed by the caller.\n+#\n+# Usage:\n+#   zephyr_check_arguments_required_allow_empty(<function_name> <prefix> <arg1> [<arg2> ...])\n+#\n+macro(zephyr_check_arguments_required_allow_empty function prefix)\n+  set(check_defined DEFINED)\n+  set(allow_empty TRUE)\n+  zephyr_check_flags_required(${function} ${prefix} ${ARGN})\n+  set(allow_empty)\n+  set(check_defined)\n+endmacro()\n+\n+    elseif(\"${allow_empty}\" AND ${required} IN_LIST ${prefix}_KEYWORDS_MISSING_VALUES)\n+      set(required_found TRUE)"
},{
  "instruction": "firmware: scmi: transport.h: switch to including kernel.h",
  "input": "#include <zephyr/sys/mutex.h>",
  "result": "-#include <zephyr/sys/mutex.h>\n+#include <zephyr/kernel.h>"
},{
  "instruction": "tests: bluetooth: hci_uart_async: Set thread name after creation",
  "input": "\tk_thread_name_set(&hci_uart_thread, \"hci_uart_main\");",
  "result": "-\tk_thread_name_set(&hci_uart_thread, \"hci_uart_main\");\n+\tk_thread_name_set(&hci_uart_thread, \"hci_uart_main\");"
},{
  "instruction": "xtensa: include xtensa-types.h for xt-clang",
  "input": "",
  "result": "+#if defined(__XT_CLANG__)\n+#include <xtensa/xtensa-types.h>\n+#endif\n+"
},{
  "instruction": "drivers: sensor: Fix adxl345 sample fetch return value",
  "input": "\treturn samples_count;",
  "result": "-\treturn samples_count;\n+\treturn 0;"
},{
  "instruction": "Bluetooth: Mesh: Fix uninitialized field when cancelling transfer blob",
  "input": "",
  "result": "+\tmemset(srv->block.missing, 0, sizeof(srv->block.missing));"
},{
  "instruction": "soc: rt11xx: Fix dual core ENET PLL",
  "input": "",
  "result": "+#ifndef CONFIG_SECOND_CORE_MCUX\n+#endif"
},{
  "instruction": "boards: frdm_rw612: support latest linkserver",
  "input": "board_runner_args(linkserver  \"--device=RW612:RDRW612\")",
  "result": "-board_runner_args(linkserver  \"--device=RW612:RDRW612\")\n+board_runner_args(linkserver  \"--device=RW612:FRDM-RW612\")"
},{
  "instruction": "doc: posix: mark rmdir and remove as supported",
  "input": "   remove(),\n   rmdir(),",
  "result": "-    remove(),\n+    remove(), yes\n-    rmdir(),\n+    rmdir(), yes"
},{
  "instruction": "lib: posix: fs: add rmdir support",
  "input": "",
  "result": "+int rmdir(const char *path);\n+\n+/**\n+ * @brief Remove a directory.\n+ *\n+ * See IEEE 1003.1\n+ */\n+int rmdir(const char *path)\n+{\n+\treturn unlink(path);\n+}"
},{
  "instruction": "soc: mp: esp32: Added IRQ priority and flags config",
  "input": "\tesp_intr_alloc(DT_IRQN(DT_NODELABEL(ipi0)),\n\t\tESP_INTR_FLAG_IRAM,\n\tesp_intr_alloc(DT_IRQN(DT_NODELABEL(ipi1)),\n\t\tESP_INTR_FLAG_IRAM,",
  "result": "-\tesp_intr_alloc(DT_IRQN(DT_NODELABEL(ipi0)),\n-\t\tESP_INTR_FLAG_IRAM,\n+\tesp_intr_alloc(DT_IRQ_BY_IDX(DT_NODELABEL(ipi0), 0, irq),\n+\t\tESP_PRIO_TO_FLAGS(DT_IRQ_BY_IDX(DT_NODELABEL(ipi0), 0, priority)) |\n+\t\tESP_INT_FLAGS_CHECK(DT_IRQ_BY_IDX(DT_NODELABEL(ipi0), 0, flags)) |\n+\t\t\tESP_INTR_FLAG_IRAM,\n-\tesp_intr_alloc(DT_IRQN(DT_NODELABEL(ipi1)),\n-\t\tESP_INTR_FLAG_IRAM,\n+\tesp_intr_alloc(DT_IRQ_BY_IDX(DT_NODELABEL(ipi1), 0, irq),\n+\t\tESP_PRIO_TO_FLAGS(DT_IRQ_BY_IDX(DT_NODELABEL(ipi1), 0, priority)) |\n+\t\tESP_INT_FLAGS_CHECK(DT_IRQ_BY_IDX(DT_NODELABEL(ipi1), 0, flags)) |\n+\t\t\tESP_INTR_FLAG_IRAM,"
},{
  "instruction": "drivers: intc: esp32: Macros for DT input validation",
  "input": "",
  "result": "+/*\n+ * Get the interrupt flags from the supplied priority.\n+ */\n+#define ESP_PRIO_TO_FLAGS(priority) \\\n+\t((priority) > 0 ? ((1 << (priority)) & ESP_INTR_FLAG_LEVELMASK) : 0)\n+\n+/*\n+ * Check interrupt flags from input and filter unallowed values.\n+ */\n+#define ESP_INT_FLAGS_CHECK(int_flags) ((int_flags) & ESP_INTR_FLAG_SHARED)\n+\n-\n+/*\n+ * Get the interrupt flags from the supplied priority.\n+ */\n+#define ESP_PRIO_TO_FLAGS(priority) \\\n+\t((priority) > 0 ? ((1 << (priority)) & ESP_INTR_FLAG_LEVELMASK) : 0)\n+\n+/*\n+ * Check interrupt flags from input and filter unallowed values.\n+ */\n+#define ESP_INT_FLAGS_CHECK(int_flags) ((int_flags) & ESP_INTR_FLAG_SHARED)\n+\n+"
},{
  "instruction": "tests: dma/chan_blen_transfer: move buffer to DMA-accessible memory",
  "input": "CONFIG_DMA_LOOP_TRANSFER_RELOCATE_SECTION=\"ITCM\"\n&itcm {\nCONFIG_DMA_LOOP_TRANSFER_RELOCATE_SECTION=\"ITCM\"\n&itcm {\nCONFIG_DMA_LOOP_TRANSFER_RELOCATE_SECTION=\"ITCM\"\n&itcm {\nCONFIG_DMA_LOOP_TRANSFER_RELOCATE_SECTION=\"ITCM\"\n&itcm {",
  "result": "-CONFIG_DMA_LOOP_TRANSFER_RELOCATE_SECTION=\"ITCM\"\n+CONFIG_DMA_LOOP_TRANSFER_RELOCATE_SECTION=\"DTCM\"\n-&itcm {\n+&dtcm {\n-CONFIG_DMA_LOOP_TRANSFER_RELOCATE_SECTION=\"ITCM\"\n+CONFIG_DMA_LOOP_TRANSFER_RELOCATE_SECTION=\"DTCM\"\n-&itcm {\n+&dtcm {\n-CONFIG_DMA_LOOP_TRANSFER_RELOCATE_SECTION=\"ITCM\"\n+CONFIG_DMA_LOOP_TRANSFER_RELOCATE_SECTION=\"DTCM\"\n-&itcm {\n+&dtcm {\n-CONFIG_DMA_LOOP_TRANSFER_RELOCATE_SECTION=\"ITCM\"\n+CONFIG_DMA_LOOP_TRANSFER_RELOCATE_SECTION=\"DTCM\"\n-&itcm {\n+&dtcm {"
},{
  "instruction": "tests: arch: arm: arm_irq_vector_table: fix compilation for nRF9280",
  "input": "#elif defined(CONFIG_SOC_SERIES_NRF54HX)\n/* For nRF54H Series, use BELLBOARD_0-2 interrupt lines. */\n#elif defined(CONFIG_SOC_SERIES_NRF54HX)\n#elif defined(CONFIG_SOC_SERIES_NRF54LX) || defined(CONFIG_SOC_SERIES_NRF54HX)",
  "result": "-#elif defined(CONFIG_SOC_SERIES_NRF54HX)\n-/* For nRF54H Series, use BELLBOARD_0-2 interrupt lines. */\n+#elif defined(CONFIG_SOC_SERIES_NRF54HX) || defined(CONFIG_SOC_SERIES_NRF92X)\n+/* For nRF54H and nRF92 Series, use BELLBOARD_0-2 interrupt lines. */\n-#elif defined(CONFIG_SOC_SERIES_NRF54HX)\n+#elif defined(CONFIG_SOC_SERIES_NRF54HX) || defined(CONFIG_SOC_SERIES_NRF92X)\n-#elif defined(CONFIG_SOC_SERIES_NRF54LX) || defined(CONFIG_SOC_SERIES_NRF54HX)\n+#elif defined(CONFIG_SOC_SERIES_NRF54LX) || defined(CONFIG_SOC_SERIES_NRF54HX) || \\\n+\tdefined(CONFIG_SOC_SERIES_NRF92X)"
},{
  "instruction": "tests: drivers: watchdog: wdt_basic_api: fix compilation for nRF9280",
  "input": "",
  "result": "+/*\n+ * Copyright 2024 Nordic Semiconductor ASA\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+&wdt010 {\n+\tstatus = \"okay\";\n+};\n+/*\n+ * Copyright 2024 Nordic Semiconductor ASA\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+&wdt010 {\n+\tstatus = \"okay\";\n+};"
},{
  "instruction": "tests: lib: cpp: cxx: add nRF9280 to exclusion list",
  "input": "   # Exclude nRF54L15 and nRF54H20 as Nordic HAL is not compatible with C++98.",
  "result": "-    # Exclude nRF54L15 and nRF54H20 as Nordic HAL is not compatible with C++98.\n+    # Exclude nRF54L15, nRF54H20 and nRF9280 as Nordic HAL is not compatible with C++98.\n+      - nrf9280pdk/nrf9280/cpuapp\n+      - nrf9280pdk/nrf9280/cpurad"
},{
  "instruction": "samples: drivers: watchdog: add overlay file for nRF9280 cpuapp",
  "input": "",
  "result": "+/*\n+ * Copyright 2024 Nordic Semiconductor ASA\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+&wdt010 {\n+\tstatus = \"okay\";\n+};"
},{
  "instruction": "drivers: adc: nrf: Update adc driver to support nRF9280",
  "input": "#if defined(CONFIG_SOC_NRF54H20)\n#ifdef CONFIG_SOC_NRF54H20\n/* nRF54H20 always uses bounce buffers in RAM */\n#endif /* CONFIG_SOC_NRF54H20 */\n#elif defined(CONFIG_SOC_NRF54H20)",
  "result": "-#if defined(CONFIG_SOC_NRF54H20)\n+#if defined(CONFIG_SOC_NRF54H20) || defined(CONFIG_SOC_NRF9280)\n-#ifdef CONFIG_SOC_NRF54H20\n+#if defined(CONFIG_SOC_NRF54H20) || defined(CONFIG_SOC_NRF9280)\n-/* nRF54H20 always uses bounce buffers in RAM */\n+/* nRF54H20 and nRF9280 always use bounce buffers in RAM */\n-#endif /* CONFIG_SOC_NRF54H20 */\n+#endif /* defined(CONFIG_SOC_NRF54H20) || defined(CONFIG_SOC_NRF9280) */\n-#elif defined(CONFIG_SOC_NRF54H20)\n+#elif defined(CONFIG_SOC_NRF54H20) || defined(CONFIG_SOC_NRF9280)"
},{
  "instruction": "modules: hal_nordic: nrf: add nRF9280 support",
  "input": "\tselect NRFS_LOCAL_DOMAIN if (SOC_NRF54H20_CPUAPP || SOC_NRF54H20_CPURAD)\n\tdefault y if SOC_NRF54H20_CPUAPP\n#ifdef CONFIG_SOC_NRF54H20_CPUAPP",
  "result": "-\tselect NRFS_LOCAL_DOMAIN if (SOC_NRF54H20_CPUAPP || SOC_NRF54H20_CPURAD)\n+\tselect NRFS_LOCAL_DOMAIN if (SOC_NRF54H20_CPUAPP || SOC_NRF54H20_CPURAD || SOC_NRF9280_CPUAPP || SOC_NRF9280_CPURAD)\n-\tdefault y if SOC_NRF54H20_CPUAPP\n+\tdefault y if SOC_NRF54H20_CPUAPP || SOC_NRF9280_CPUAPP\n-#ifdef CONFIG_SOC_NRF54H20_CPUAPP\n+#if defined(CONFIG_SOC_NRF54H20_CPUAPP) || defined(CONFIG_SOC_NRF9280_CPUAPP)"
},{
  "instruction": "scripts: west: runners: add initial nRF92 support",
  "input": "                                    'NRF54H', 'NRF91'],\n       if self.family in ('NRF53_FAMILY', 'NRF54H_FAMILY'):\n       if self.family in ('NRF53_FAMILY', 'NRF54H_FAMILY'):\n       if self.family == 'NRF54H_FAMILY':\n               if not self.build_conf.getboolean('CONFIG_SOC_NRF54H20_CPUAPP') and self.sysbuild_conf.get('SB_CONFIG_SUIT_ENVELOPE'):\n           if self.build_conf.getboolean('CONFIG_SOC_NRF54H20_CPUAPP'):\n           elif self.build_conf.getboolean('CONFIG_SOC_NRF54H20_CPURAD'):",
  "result": "-                                     'NRF54H', 'NRF91'],\n+                                     'NRF54H', 'NRF91', 'NRF92'],\n+        elif self.build_conf.getboolean('CONFIG_SOC_SERIES_NRF92X'):\n+            self.family = 'NRF92_FAMILY'\n-        if self.family in ('NRF53_FAMILY', 'NRF54H_FAMILY'):\n+        if self.family in ('NRF53_FAMILY', 'NRF54H_FAMILY', 'NRF92_FAMILY'):\n-        if self.family in ('NRF53_FAMILY', 'NRF54H_FAMILY'):\n+        if self.family in ('NRF53_FAMILY', 'NRF54H_FAMILY', 'NRF92_FAMILY'):\n-        if self.family == 'NRF54H_FAMILY':\n+        if self.family in ('NRF54H_FAMILY', 'NRF92_FAMILY'):\n+            cpuapp = self.build_conf.getboolean('CONFIG_SOC_NRF54H20_CPUAPP') or self.build_conf.getboolean('CONFIG_SOC_NRF9280_CPUAPP')\n+            cpurad = self.build_conf.getboolean('CONFIG_SOC_NRF54H20_CPURAD') or self.build_conf.getboolean('CONFIG_SOC_NRF9280_CPURAD')\n+\n-                if not self.build_conf.getboolean('CONFIG_SOC_NRF54H20_CPUAPP') and self.sysbuild_conf.get('SB_CONFIG_SUIT_ENVELOPE'):\n+                if not cpuapp and self.sysbuild_conf.get('SB_CONFIG_SUIT_ENVELOPE'):\n-            if self.build_conf.getboolean('CONFIG_SOC_NRF54H20_CPUAPP'):\n+            if cpuapp:\n-            elif self.build_conf.getboolean('CONFIG_SOC_NRF54H20_CPURAD'):\n+            elif cpurad:"
},{
  "instruction": "drivers: serial: nrf: disable legacy shim for nRF92",
  "input": "\tdepends on RISCV || !SOC_SERIES_NRF54HX",
  "result": "-\tdepends on RISCV || !SOC_SERIES_NRF54HX\n+\tdepends on !SOC_SERIES_NRF54HX || RISCV\n+\tdepends on !SOC_SERIES_NRF92X || RISCV"
},{
  "instruction": "drivers: cache: nrf: enable CACHE_NRF_PATCH_LINEADDR for nRF92",
  "input": "\tdefault y if SOC_NRF54H20",
  "result": "-\tdefault y if SOC_NRF54H20\n+\tdefault y if SOC_NRF54H20 || SOC_NRF9280"
},{
  "instruction": "soc: nordic: common: add CAN121 to nrf54hx_nrf92x_mpu_regions.c",
  "input": "",
  "result": "+#define CAN121_BASE\tDT_REG_ADDR_BY_NAME(DT_NODELABEL(can121), message_ram)\n+#define CAN121_SIZE\tDT_REG_SIZE_BY_NAME(DT_NODELABEL(can121), message_ram) + \\\n+\t\t\tDT_REG_SIZE_BY_NAME(DT_NODELABEL(can121), m_can)\n+\n+#if DT_NODE_HAS_STATUS(DT_NODELABEL(can121), okay)\n+\tMPU_REGION_ENTRY(\"CAN121_MCAN\", CAN121_BASE,\n+\t\t\t REGION_RAM_NOCACHE_ATTR(CAN121_BASE, CAN121_SIZE)),\n+#endif"
},{
  "instruction": "soc: nordic: move mpu_regions.c to common folder and rename",
  "input": "zephyr_library_sources_ifdef(CONFIG_CPU_HAS_CUSTOM_FIXED_SOC_MPU_REGIONS mpu_regions.c)",
  "result": "+if((CONFIG_SOC_SERIES_NRF54HX OR CONFIG_SOC_SERIES_NRF92X) AND CONFIG_CPU_HAS_CUSTOM_FIXED_SOC_MPU_REGIONS)\n+  zephyr_library_sources(nrf54hx_nrf92x_mpu_regions.c)\n+endif()\n+\n-zephyr_library_sources_ifdef(CONFIG_CPU_HAS_CUSTOM_FIXED_SOC_MPU_REGIONS mpu_regions.c)\n-"
},{
  "instruction": "drivers: wifi: Fix AP mode build",
  "input": "",
  "result": "+zephyr_compile_definitions_ifdef(CONFIG_NRF70_AP_MODE\n+  -DNRF70_AP_MODE\n+)\n+"
},{
  "instruction": "drivers: wifi: Fix monitor mode handling",
  "input": "zephyr_library_sources_ifdef(CONFIG_NRF70_SYSTEM_MODE",
  "result": "-zephyr_library_sources_ifdef(CONFIG_NRF70_SYSTEM_MODE\n+zephyr_library_sources_ifdef(CONFIG_NRF70_SYSTEM_MODE_COMMON\n+config NRF70_SYSTEM_MODE_COMMON\n+\tbool\n+\tdefault y if NRF70_SYSTEM_MODE || NRF70_SYSTEM_WITH_RAW_MODES\n+"
},{
  "instruction": "drivers: wifi: Fix duplicate file inclusion",
  "input": "zephyr_library_sources_ifdef(CONFIG_NRF70_SCAN_ONLY\n src/wifi_mgmt_scan.c\n)",
  "result": "-zephyr_library_sources_ifdef(CONFIG_NRF70_SCAN_ONLY\n-  src/wifi_mgmt_scan.c\n-)\n-"
},{
  "instruction": "maintainers: Add colloborators for nRF Wi-Fi",
  "input": "",
  "result": "+  collaborators:\n+    - sachinthegreen\n+    - krish2718\n+    - sachinthegreen\n+    - udaynordic\n+    - rajb9\n+    - srkanordic"
},{
  "instruction": "drivers: wifi: Wait for clock divider to take effect",
  "input": "",
  "result": "+/* After the base clock divider is changed, some time is needed for the new\n+ * setting to take effect. This value specifies the delay (in microseconds)\n+ * to be applied to ensure that the clock is ready when the QSPI operation\n+ * starts. It was measured with a logic analyzer (unfortunately, the nRF5340\n+ * specification does not provide any numbers in this regard).\n+ */\n+#define BASE_CLOCK_SWITCH_DELAY_US 7\n+\n+\tk_busy_wait(BASE_CLOCK_SWITCH_DELAY_US);\n+\tk_busy_wait(BASE_CLOCK_SWITCH_DELAY_US);\n+\n+\tk_busy_wait(BASE_CLOCK_SWITCH_DELAY_US);\n+\tk_busy_wait(BASE_CLOCK_SWITCH_DELAY_US);"
},{
  "instruction": "drivers: wifi: Add tx packets drop count calculation",
  "input": "\t\t\t\t\t\t      net_pkt_to_nbuf(pkt));\n\t\t\t\t\t       net_pkt_to_nbuf(pkt));",
  "result": "+\tstruct nrf_wifi_fmac_dev_ctx_def *def_dev_ctx = NULL;\n+\tstruct rpu_host_stats *host_stats = NULL;\n+\tvoid *nbuf = NULL;\n+\tdef_dev_ctx = wifi_dev_priv(rpu_ctx_zep->rpu_ctx);\n+\thost_stats = &def_dev_ctx->host_stats;\n+\tnbuf = net_pkt_to_nbuf(pkt);\n+\tif (!nbuf) {\n+\t\tLOG_DBG(\"Failed to allocate net_pkt\");\n+\t\thost_stats->total_tx_drop_pkts++;\n+\t\tgoto out;\n+\t}\n+\n-\t\t\t\t\t\t      net_pkt_to_nbuf(pkt));\n+\t\t\t\t\t\t      nbuf);\n-\t\t\t\t\t       net_pkt_to_nbuf(pkt));\n+\t\t\t\t\t       nbuf);"
},{
  "instruction": "drivers: wifi: Option for PS data retrieval",
  "input": "",
  "result": "+choice NRF_WIFI_PS_DATA_RETRIEVAL_MECHANISM\n+\tprompt \"Power save data retrieval mechanism\"\n+\tdefault NRF_WIFI_PS_POLL_BASED_RETRIEVAL\n+\thelp\n+\t  Select the mechanism to retrieve buffered data from AP.\n+\n+config NRF_WIFI_PS_POLL_BASED_RETRIEVAL\n+\tbool \"PS-Poll frame based mechanism to retrieve buffered data from AP\"\n+\thelp\n+\t  When AP notifies about availability of buffered data, the STA stays in power save\n+\t  and retrieves the frames one-by-one, this conserved more power but adds latency\n+\t  to the traffic. Ideal for minimum number of frames.\n+\n+config NRF_WIFI_QOS_NULL_BASED_RETRIEVAL\n+\tbool \"QoS null frame based mechanism to retrieve buffered data from AP\"\n+\thelp\n+\t  When AP notifies about availability of buffered data, the STA comes out of\n+\t  power save and then AP can deliver all buffered frames without any additional\n+\t  overhead or latency, but STA enters power save after a delay costing more power\n+\t  depending on the delay. Ideal for heavy buffered traffic.\n+\n+endchoice\n+"
},{
  "instruction": "drivers: wifi: Add kconfig option to disable WMM feature",
  "input": "static const unsigned char wmm = 1;\n\tdata_config.wmm = wmm;",
  "result": "+config NRF_WIFI_FEAT_WMM\n+\tbool \"WMM/QoS support\"\n+\tdefault y\n+\thelp\n+\t  This option controls disable/enable of the WMM(Wireless Multi-Media) feature.\n+\n-static const unsigned char wmm = 1;\n-\tdata_config.wmm = wmm;\n+\tdata_config.wmm = IS_ENABLED(CONFIG_NRF_WIFI_FEAT_WMM);"
},{
  "instruction": "manifest: hal_nordic: Pull latest Wi-Fi OSAL",
  "input": "     revision: 0b6040d9b440b769a65f25c6fd9320eeff88ee94",
  "result": "-      revision: 0b6040d9b440b769a65f25c6fd9320eeff88ee94\n+      revision: 91654ddc7ce0da523eb4d6be2171208ae2b8fb35"
},{
  "instruction": "tests: bluetooth: tester: Fix BTP_BAP_BROADCAST_SINK_BIS_SYNC command",
  "input": "\tif (cp->requested_bis_sync == BT_BAP_BIS_SYNC_NO_PREF) {\n\t\tbroadcaster->requested_bis_sync = sys_le32_to_cpu(cp->requested_bis_sync);\n\t} else {\n\t\t/* For semantic purposes Zephyr API uses BIS Index bitfield\n\t\t * where BIT(1) means BIS Index 1\n\t\t */\n\t\tbroadcaster->requested_bis_sync = sys_le32_to_cpu(cp->requested_bis_sync) << 1;\n\t}",
  "result": "-\tif (cp->requested_bis_sync == BT_BAP_BIS_SYNC_NO_PREF) {\n-\t\tbroadcaster->requested_bis_sync = sys_le32_to_cpu(cp->requested_bis_sync);\n-\t} else {\n-\t\t/* For semantic purposes Zephyr API uses BIS Index bitfield\n-\t\t * where BIT(1) means BIS Index 1\n-\t\t */\n-\t\tbroadcaster->requested_bis_sync = sys_le32_to_cpu(cp->requested_bis_sync) << 1;\n-\t}\n+\tbroadcaster->requested_bis_sync = sys_le32_to_cpu(cp->requested_bis_sync);"
},{
  "instruction": "MAINTAINERS: Add pdgendt as West collaborator",
  "input": "",
  "result": "+    - pdgendt"
},{
  "instruction": "scripts: coccinelle: add errno as a reserved name",
  "input": "",
  "result": "+errno"
},{
  "instruction": "drivers: rtc: off-by-one error in RV-8263-C8 driver",
  "input": "\tregs[6] = bin2bcd(timeptr->tm_mon) & MONTHS_BITS;\n\ttimeptr->tm_mon = bcd2bin(regs[5] & MONTHS_BITS);\n\t\tLOG_ERR(\"Error while setting alarm time! Error: %i\", < err);",
  "result": "-\tregs[6] = bin2bcd(timeptr->tm_mon) & MONTHS_BITS;\n+\tregs[6] = (bin2bcd(timeptr->tm_mon) & MONTHS_BITS) + 1;\n-\ttimeptr->tm_mon = bcd2bin(regs[5] & MONTHS_BITS);\n+\ttimeptr->tm_mon = bcd2bin(regs[5] & MONTHS_BITS) - 1;\n-\t\tLOG_ERR(\"Error while setting alarm time! Error: %i\", < err);\n+\t\tLOG_ERR(\"Error while setting alarm time! Error: %i\", err);"
},{
  "instruction": "drivers: clock_control: support new i2c clock model",
  "input": "",
  "result": "+#if defined(CONFIG_SOC_SERIES_IMXRT118X)\n+\tcase IMX_CCM_LPI2C0102_CLK:\n+\t\tclock_root = kCLOCK_Root_Lpi2c0102 + instance;\n+\t\tbreak;\n+#else\n+#endif\n+#define IMX_CCM_LPI2C0102_CLK          0x400UL\n+#define IMX_CCM_LPI2C0304_CLK          0x401UL\n+#define IMX_CCM_LPI2C0506_CLK          0x402UL\n+#define IMX_CCM_LPI2C0708_CLK          0x403UL"
},{
  "instruction": "soc: nxp: imxrt: imxrt118x: Enable lpi2c0102/0304/0506 clock",
  "input": "",
  "result": "+#if defined(CONFIG_I2C_MCUX_LPI2C) && \\\n+\t(DT_NODE_HAS_STATUS(DT_NODELABEL(lpi2c3), okay) \\\n+\t|| DT_NODE_HAS_STATUS(DT_NODELABEL(lpi2c4), okay))\n+\t/* Configure LPI2C0304 using SYS_PLL3_DIV2_CLK */\n+\trootCfg.mux = kCLOCK_LPI2C0304_ClockRoot_MuxSysPll3Div2;\n+\trootCfg.div = 4;\n+\tCLOCK_SetRootClock(kCLOCK_Root_Lpi2c0304, &rootCfg);\n+#endif\n+\n+#if defined(CONFIG_I2C_MCUX_LPI2C) && \\\n+\t(DT_NODE_HAS_STATUS(DT_NODELABEL(lpi2c5), okay) \\\n+\t|| DT_NODE_HAS_STATUS(DT_NODELABEL(lpi2c6), okay))\n+\t/* Configure LPI2C0506 using SYS_PLL3_DIV2_CLK */\n+\trootCfg.mux = kCLOCK_LPI2C0506_ClockRoot_MuxSysPll3Div2;\n+\trootCfg.div = 4;\n+\tCLOCK_SetRootClock(kCLOCK_Root_Lpi2c0506, &rootCfg);\n+#endif\n+"
},{
  "instruction": "arch: arm: cortex_m: pm_s2ram: save system_off before s2ram marking",
  "input": "\tblx\tr0\n\tpush\t{r0}\n\tpop\t{r0}\n\tpush    {lr}\n\tpop     {lr}",
  "result": "+\n+\t/* Move system_off to protected register. */\n+\tmov \tr4, r0\n+\n+\t/* Store CPU context */\n-\tblx\tr0\n+\tblx\tr4\n-\tpush\t{r0}\n-\tpop\t{r0}\n+\n+\t/* Move system_off back to r0 as return value */\n+\tmov\tr0, r4\n+\t * Store LR to ensure we can continue boot when we are not suspended\n+\t * to RAM. In addition to LR, R0 is pushed too, to ensure \"SP mod 8 = 0\",\n+\t * as stated by ARM rule 6.2.1.2 for AAPCS32.\n-\tpush    {lr}\n+\tpush    {r0, lr}\n-\tpop     {lr}\n+\tpop     {r0, lr}"
},{
  "instruction": "ci: compliance: in case of too many errors, send as a single failure",
  "input": "",
  "result": "+\n+            # add a guard here for excessive number of errors, do not try and\n+            # process each one of them and instead push this as one failure.\n+            if len(matches) > 500:\n+                self.failure(output)\n+                return\n+"
},{
  "instruction": "soc: rt11xx: Fix bus clocking",
  "input": "#if CONFIG_ETH_MCUX || CONFIG_ETH_NXP_ENET\n\tCLOCK_InitPfd(kCLOCK_PllSys2, kCLOCK_Pfd3, 24);\n#else\n#endif\n\t/* Configure BUS using SYS_PLL3_CLK */\n#if CONFIG_ETH_MCUX || CONFIG_ETH_NXP_ENET\n\t/* Configure root bus clock at 198M */\n\trootCfg.mux = kCLOCK_BUS_ClockRoot_MuxSysPll2Pfd3;\n\trootCfg.div = 2;\n\tCLOCK_SetRootClock(kCLOCK_Root_Bus, &rootCfg);\n#elif defined(CONFIG_SOC_MIMXRT1176_CM7) || defined(CONFIG_SOC_MIMXRT1166_CM7)",
  "result": "-#if CONFIG_ETH_MCUX || CONFIG_ETH_NXP_ENET\n-\tCLOCK_InitPfd(kCLOCK_PllSys2, kCLOCK_Pfd3, 24);\n-#else\n-#endif\n-\t/* Configure BUS using SYS_PLL3_CLK */\n-#if CONFIG_ETH_MCUX || CONFIG_ETH_NXP_ENET\n-\t/* Configure root bus clock at 198M */\n-\trootCfg.mux = kCLOCK_BUS_ClockRoot_MuxSysPll2Pfd3;\n-\trootCfg.div = 2;\n-\tCLOCK_SetRootClock(kCLOCK_Root_Bus, &rootCfg);\n-#elif defined(CONFIG_SOC_MIMXRT1176_CM7) || defined(CONFIG_SOC_MIMXRT1166_CM7)\n+#if CONFIG_SOC_MIMXRT1176_CM7\n+#elif defined(CONFIG_SOC_MIMXRT1166_CM7)\n+\t/* Configure root bus clock at 200M */\n+\trootCfg.mux = kCLOCK_BUS_ClockRoot_MuxSysPll1Div5;\n+\trootCfg.div = 1;\n+\tCLOCK_SetRootClock(kCLOCK_Root_Bus, &rootCfg);"
},{
  "instruction": "doc: releases: migration-guide-4.0: document change to USDHC card detect",
  "input": "",
  "result": "+SDHC\n+====\n+\n+* The NXP USDHC driver now assumes a card is present if no card detect method\n+  is configured, instead of using the peripheral's internal card detect signal\n+  to check for card presence. To use the internal card detect signal, the\n+  devicetree property ``detect-cd`` should be added to the USDHC node in use.\n+"
},{
  "instruction": "drivers: sdhc: imx_usdhc: assume card is present if no detection method",
  "input": "\t\tdata->card_present = USDHC_DetectCardInsert(cfg->base);",
  "result": "+\tbool detect_cd;\n+\t} else if (cfg->detect_cd) {\n+\t\t/*\n+\t\t * Detect the card via the USDHC_CD signal internal to\n+\t\t * the peripheral\n+\t\t */\n+\t\tdata->card_present = USDHC_DetectCardInsert(cfg->base);\n-\t\tdata->card_present = USDHC_DetectCardInsert(cfg->base);\n+\t\tLOG_WRN(\"No card detection method configured, assuming card \"\n+\t\t\t\"is present\");\n+\t\tdata->card_present = true;\n+\t\t.detect_cd = DT_INST_PROP(n, detect_cd),\t\t\t\\\n+\n+  detect-cd:\n+    type: boolean\n+    description: |\n+      Use the host's internal card detect signal (USDHC_CD) to detect the SD\n+      card. This signal is available as an alternative to card detect via GPIO,\n+      and should be connected to the SD slot's detect pin if used."
},{
  "instruction": "Coverage Analysis: Update Test Case Status",
  "input": "                       if testcase['status'] is None:",
  "result": "-                        if testcase['status'] is None:\n+                        if testcase['status'] == 'None':"
},{
  "instruction": "drivers: pinctrl_imx: support i.MX93 M33 core",
  "input": "#ifdef CONFIG_SOC_MIMX9352_A55",
  "result": "-#ifdef CONFIG_SOC_MIMX9352_A55\n+#ifdef CONFIG_SOC_MIMX9352"
},{
  "instruction": "drivers: clock_control_mcux_ccm_rev2: support i.MX93 M33 core",
  "input": "#ifdef CONFIG_SOC_MIMX9352_A55\n#ifdef CONFIG_SOC_MIMX9352_A55\n#if defined(CONFIG_SOC_MIMX9352_A55) && defined(CONFIG_DAI_NXP_SAI)\n#ifdef CONFIG_SOC_MIMX9352_A55",
  "result": "-#ifdef CONFIG_SOC_MIMX9352_A55\n+#ifdef CONFIG_SOC_MIMX9352\n-#ifdef CONFIG_SOC_MIMX9352_A55\n+#ifdef CONFIG_SOC_MIMX9352\n-#if defined(CONFIG_SOC_MIMX9352_A55) && defined(CONFIG_DAI_NXP_SAI)\n+#if defined(CONFIG_SOC_MIMX9352) && defined(CONFIG_DAI_NXP_SAI)\n-#ifdef CONFIG_SOC_MIMX9352_A55\n+#ifdef CONFIG_SOC_MIMX9352"
},{
  "instruction": "soc: rw: Consolidate clock cycle kconfig.",
  "input": "if MCUX_OS_TIMER\nconfig SYS_CLOCK_HW_CYCLES_PER_SEC\n\tdefault 1000000\nendif # MCUX_OS_TIMER\nif CORTEX_M_SYSTICK\n\tdefault 260000000\nendif # CORTEX_M_SYSTICK",
  "result": "-if MCUX_OS_TIMER\n-\n-config SYS_CLOCK_HW_CYCLES_PER_SEC\n-\tdefault 1000000\n-\n-endif # MCUX_OS_TIMER\n-\n-if CORTEX_M_SYSTICK\n-\n-\tdefault 260000000\n-\n-endif # CORTEX_M_SYSTICK\n+\tdefault 1000000 if MCUX_OS_TIMER\n+\tdefault 260000000 if CORTEX_M_SYSTICK"
},{
  "instruction": "soc: nxp: rw: Delete unused configs",
  "input": "\tselect INIT_SYS_PLL\nconfig INIT_SYS_PLL\n\tbool \"Initialize SYS PLL\"\nchoice BOOT_DEVICE\n\tprompt \"Boot device selection\"\n\tdefault BOOT_FLEXSPI_NOR\nconfig BOOT_FLEXSPI_NOR\n\tbool \"FlexSPI serial NOR\"\nendchoice",
  "result": "-\tselect INIT_SYS_PLL\n-config INIT_SYS_PLL\n-\tbool \"Initialize SYS PLL\"\n-\n-choice BOOT_DEVICE\n-\tprompt \"Boot device selection\"\n-\tdefault BOOT_FLEXSPI_NOR\n-\n-config BOOT_FLEXSPI_NOR\n-\tbool \"FlexSPI serial NOR\"\n-\n-endchoice\n-"
},{
  "instruction": "drivers: flash/memc: Source logging kconfig last",
  "input": "module = FLASH\nmodule-str = flash\nsource \"subsys/logging/Kconfig.template.log_config\"\nmodule = MEMC\nmodule-str = memc\nsource \"subsys/logging/Kconfig.template.log_config\"",
  "result": "-module = FLASH\n-module-str = flash\n-source \"subsys/logging/Kconfig.template.log_config\"\n-\n+module = FLASH\n+module-str = flash\n+source \"subsys/logging/Kconfig.template.log_config\"\n+\n-module = MEMC\n-module-str = memc\n-source \"subsys/logging/Kconfig.template.log_config\"\n-\n+module = MEMC\n+module-str = memc\n+source \"subsys/logging/Kconfig.template.log_config\"\n+"
},{
  "instruction": "soc: nxp: Do not change driver init priorities",
  "input": "config SERIAL_INIT_PRIORITY\n\tdefault 55 if SERIAL\n\tdepends on SERIAL\nconfig SERIAL_INIT_PRIORITY\n\tdefault 55\n\tdepends on SERIAL\nconfig ADC_INIT_PRIORITY\n\tdefault 80 if ADC_MCUX_ADC16_ENABLE_EDMA\n\tdepends on ADC\nconfig SERIAL_INIT_PRIORITY\n\tdefault 55 if SERIAL\nconfig SERIAL_INIT_PRIORITY\n\tdefault 55\n\tdepends on SERIAL",
  "result": "-config SERIAL_INIT_PRIORITY\n-\tdefault 55 if SERIAL\n-\tdepends on SERIAL\n-\n-config SERIAL_INIT_PRIORITY\n-\tdefault 55\n-\tdepends on SERIAL\n-\n-config ADC_INIT_PRIORITY\n-\tdefault 80 if ADC_MCUX_ADC16_ENABLE_EDMA\n-\tdepends on ADC\n-\n-config SERIAL_INIT_PRIORITY\n-\tdefault 55 if SERIAL\n-\n-config SERIAL_INIT_PRIORITY\n-\tdefault 55\n-\tdepends on SERIAL\n-"
},{
  "instruction": "i2c: Fix build failure with i2c_mcux_rtio driver",
  "input": "\t\t\t\t      sqe->rx.buf, sqe->rx.buf_len, dt_spec->addr);\n\t\t\t\t      sqe->tiny_tx.buf, sqe->tiny_tx.buf_len, dt_spec->addr);\n\t\t\t\t      sqe->tx.buf, sqe->tx.buf_len, dt_spec->addr);",
  "result": "-\t\t\t\t      sqe->rx.buf, sqe->rx.buf_len, dt_spec->addr);\n+\t\t\t\t\t    sqe->rx.buf, sqe->rx.buf_len, dt_spec->addr);\n-\t\t\t\t      sqe->tiny_tx.buf, sqe->tiny_tx.buf_len, dt_spec->addr);\n+\t\t\t\t\t    (uint8_t *)sqe->tiny_tx.buf, sqe->tiny_tx.buf_len,\n+\t\t\t\t\t    dt_spec->addr);\n-\t\t\t\t      sqe->tx.buf, sqe->tx.buf_len, dt_spec->addr);\n+\t\t\t\t\t    (uint8_t *)sqe->tx.buf, sqe->tx.buf_len,\n+\t\t\t\t\t    dt_spec->addr);"
},{
  "instruction": "drivers: dai: esai: don't reset ESAI on init",
  "input": "\tESAI_Reset(UINT_TO_ESAI(data->regmap));",
  "result": "-\tESAI_Reset(UINT_TO_ESAI(data->regmap));\n-"
},{
  "instruction": "input: pmw3610: add soft reset when no reset pin is available",
  "input": "",
  "result": "+#define POWER_UP_RESET 0x5a\n+\t\tk_sleep(K_MSEC(RESET_DELAY_MS));\n+\t} else {\n+\t\tret = pmw3610_write_reg(dev, PMW3610_POWER_UP_RESET, POWER_UP_RESET);\n+\t\tif (ret < 0) {\n+\t\t\treturn ret;\n+\t\t}\n+"
},{
  "instruction": "doc: security: Disclose CVE-2024-4785",
  "input": "Under embargo until 2024-08-07",
  "result": "-Under embargo until 2024-08-07\n+Bluetooth: Missing Check in LL_CONNECTION_UPDATE_IND Packet Leads to Division by Zero\n+\n+  <https://github.com/zephyrproject-rtos/zephyr/security/advisories/GHSA-xcr5-5g98-mchp>`_\n+\n+This has been fixed in main for v3.7.0\n+\n+  <https://github.com/zephyrproject-rtos/zephyr/pull/72608>`_"
},{
  "instruction": "lib: posix: update option group of `readdir_r()`",
  "input": "#ifdef CONFIG_POSIX_THREAD_SAFE_FUNCTIONS\n#endif /* CONFIG_POSIX_THREAD_SAFE_FUNCTIONS */",
  "result": "+config POSIX_FILE_SYSTEM_R\n+\tbool \"Thread-Safe File System\"\n+\thelp\n+\t  Select 'y' here and Zephyr will provide an implementation of the POSIX_FILE_SYSTEM_R\n+\t  Option Group, consisting of readdir_r().\n+\n+\t  For more informnation, please see\n+\t  https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_subprofiles.html\n+\n+\tselect POSIX_FILE_SYSTEM_R if POSIX_FILE_SYSTEM\n-#ifdef CONFIG_POSIX_THREAD_SAFE_FUNCTIONS\n+#ifdef CONFIG_POSIX_FILE_SYSTEM_R\n-#endif /* CONFIG_POSIX_THREAD_SAFE_FUNCTIONS */\n+#endif /* CONFIG_POSIX_FILE_SYSTEM_R */"
},{
  "instruction": "scripts: west_commands: completion: zsh: Add minimum support for `sdk`",
  "input": "",
  "result": "+  'sdk[manage SDKs]'"
},{
  "instruction": "scripts: west_commands: completion: fash: Add support for `west sdk`",
  "input": "                   \"blobs\" \"work with binary blobs\"",
  "result": "-                    \"blobs\" \"work with binary blobs\"\n+                    \"blobs\" \"work with binary blobs\" \\\n+                    \"sdk\" \"manage SDKs\"\n+\n+# sdk\n+complete -c west -n \"__zephyr_west_use_subcommand; and __zephyr_west_check_if_in_workspace\" -ra sdk -d \"manage SDKs\"\n+complete -c west -n \"__zephyr_west_seen_subcommand_from sdk; and not __fish_seen_subcommand_from list install\" -ra \"list\\t'list installed SDKs' install\\t'install SDK'\"\n+complete -c west -n \"__zephyr_west_seen_subcommand_from sdk; and __fish_seen_subcommand_from install\" -l version -d \"version of the Zephyr SDK to install\"\n+complete -c west -n \"__zephyr_west_seen_subcommand_from sdk; and __fish_seen_subcommand_from install\" -o b -l install-base -d \"SDK isntall base directory\"\n+complete -c west -n \"__zephyr_west_seen_subcommand_from sdk; and __fish_seen_subcommand_from install\" -o d -l install-dir -d \"SDK isntall destination directory\"\n+complete -c west -n \"__zephyr_west_seen_subcommand_from sdk; and __fish_seen_subcommand_from install\" -o i -l interactive -d \"interactive\"\n+complete -c west -n \"__zephyr_west_seen_subcommand_from sdk; and __fish_seen_subcommand_from install\" -o t -l toolchains -d \"toolchain(s) to install\"\n+complete -c west -n \"__zephyr_west_seen_subcommand_from sdk; and __fish_seen_subcommand_from install\" -o T -l no-toolchains -d \"do not install toolchains\"\n+complete -c west -n \"__zephyr_west_seen_subcommand_from sdk; and __fish_seen_subcommand_from install\" -o H -l no-hosttools -d \"do not install host-tools\"\n+complete -c west -n \"__zephyr_west_seen_subcommand_from sdk; and __fish_seen_subcommand_from install\" -l personal-access-token -d \"GitHub personal access token\"\n+complete -c west -n \"__zephyr_west_seen_subcommand_from sdk; and __fish_seen_subcommand_from install\" -l api-url -d \"GitHub releases API endpoint URL\""
},{
  "instruction": "drivers: rtc: rv3028: adjust timing of EEPROM requests",
  "input": "#define RV3028_EEBUSY_POLL_US           10000\nstatic int rv3028_eeprom_wait_busy(const struct device *dev)\n\t\tk_busy_wait(RV3028_EEBUSY_POLL_US);\n\tret = rv3028_eeprom_wait_busy(dev);\n\terr = rv3028_eeprom_wait_busy(dev);\n\terr = rv3028_eeprom_wait_busy(dev);\n\tint err = 0;",
  "result": "-#define RV3028_EEBUSY_POLL_US           10000\n+#define RV3028_EEBUSY_READ_POLL_MS      1\n+#define RV3028_EEBUSY_WRITE_POLL_MS     10\n-static int rv3028_eeprom_wait_busy(const struct device *dev)\n+static int rv3028_eeprom_wait_busy(const struct device *dev, int poll_ms)\n-\t\tk_busy_wait(RV3028_EEBUSY_POLL_US);\n+\t\tk_msleep(poll_ms);\n-\tret = rv3028_eeprom_wait_busy(dev);\n+\tret = rv3028_eeprom_wait_busy(dev, RV3028_EEBUSY_WRITE_POLL_MS);\n-\terr = rv3028_eeprom_wait_busy(dev);\n+\terr = rv3028_eeprom_wait_busy(dev, RV3028_EEBUSY_WRITE_POLL_MS);\n-\terr = rv3028_eeprom_wait_busy(dev);\n+\terr = rv3028_eeprom_wait_busy(dev, RV3028_EEBUSY_READ_POLL_MS);\n-\tint err = 0;\n+\tint err;"
},{
  "instruction": "drivers: rtc: rv3028: fix minutes alarm",
  "input": "\tdate[3] = bin2bcd(timeptr->tm_wday) & RV3028_WEEKDAY_MASK;\n\ttimeptr->tm_wday = bcd2bin(date[3] & RV3028_WEEKDAY_MASK);\n\t\tregs[0] = RTC_ALARM_TIME_MASK_MINUTE;",
  "result": "-\tdate[3] = bin2bcd(timeptr->tm_wday) & RV3028_WEEKDAY_MASK;\n+\tdate[3] = timeptr->tm_wday & RV3028_WEEKDAY_MASK;\n-\ttimeptr->tm_wday = bcd2bin(date[3] & RV3028_WEEKDAY_MASK);\n+\ttimeptr->tm_wday = date[3] & RV3028_WEEKDAY_MASK;\n-\t\tregs[0] = RTC_ALARM_TIME_MASK_MINUTE;\n+\t\tregs[0] = RV3028_ALARM_MINUTES_AE_M;"
},{
  "instruction": "Bluetooth: OTS: Use proper kconfig log option",
  "input": "LOG_MODULE_REGISTER(bt_ots, CONFIG_BT_OTS_LOG_LEVEL);",
  "result": "-LOG_MODULE_REGISTER(bt_ots, CONFIG_BT_OTS_LOG_LEVEL);\n+LOG_MODULE_REGISTER(bt_ots, CONFIG_BT_OTS_CLIENT_LOG_LEVEL);"
},{
  "instruction": "net: config: add missing include",
  "input": "",
  "result": "+#include <zephyr/net/net_if.h>"
},{
  "instruction": "doc: Coding guidelines: use fixed title for reference to Bluetooth APIs",
  "input": "  * - :ref:`bluetooth_api`",
  "result": "-   * - :ref:`bluetooth_api`\n+   * - :ref:`Bluetooth <bluetooth_api>`"
},{
  "instruction": "scripts: ci: Fix clang-format compliance on Windows",
  "input": "               subprocess.run(('clang-format-diff.py', '-p1'),",
  "result": "+import platform\n+        exe = f\"clang-format-diff.{'exe' if platform.system() == 'Windows' else 'py'}\"\n+\n-                subprocess.run(('clang-format-diff.py', '-p1'),\n+                subprocess.run((exe, '-p1'),"
},{
  "instruction": "tests: bluetooth: tester: Fix user_data size in pools",
  "input": "\t\t\t  BT_ISO_SDU_BUF_SIZE(CONFIG_BT_ISO_TX_MTU), 8, NULL);\nNET_BUF_POOL_FIXED_DEFINE(data_pool, CHANNELS, DATA_BUF_SIZE, 8, NULL);",
  "result": "-\t\t\t  BT_ISO_SDU_BUF_SIZE(CONFIG_BT_ISO_TX_MTU), 8, NULL);\n+\t\t\t  BT_ISO_SDU_BUF_SIZE(CONFIG_BT_ISO_TX_MTU),\n+\t\t\t  CONFIG_BT_CONN_TX_USER_DATA_SIZE, NULL);\n-NET_BUF_POOL_FIXED_DEFINE(data_pool, CHANNELS, DATA_BUF_SIZE, 8, NULL);\n+NET_BUF_POOL_FIXED_DEFINE(data_pool, CHANNELS, DATA_BUF_SIZE, CONFIG_BT_CONN_TX_USER_DATA_SIZE,\n+\t\t\t  NULL);"
},{
  "instruction": "modules/hal_st: Align sensor drivers to stmemsc HAL i/f v2.6",
  "input": "\t\t/* not sure what \"5Hz2\" is about, datasheet says PM=0b100 is 2Hz\n\t\t * https://github.com/STMicroelectronics/STMems_Standard_C_drivers/issues/162\n\t\t */\n\t\todr_reg = IIS328DQ_ODR_5Hz2;\n\tlis2dux12_md_t mode;\n\tif (lis2dux12_outt_data_get(ctx, &mode, &temp_data) < 0) {\n     revision: b77157f6bc4395e398d90ab02a7d2cbc01ab2ce7",
  "result": "-\t\t/* not sure what \"5Hz2\" is about, datasheet says PM=0b100 is 2Hz\n-\t\t * https://github.com/STMicroelectronics/STMems_Standard_C_drivers/issues/162\n-\t\t */\n-\t\todr_reg = IIS328DQ_ODR_5Hz2;\n+\t\todr_reg = IIS328DQ_ODR_2Hz;\n-\tlis2dux12_md_t mode;\n-\tif (lis2dux12_outt_data_get(ctx, &mode, &temp_data) < 0) {\n+\tif (lis2dux12_outt_data_get(ctx, &temp_data) < 0) {\n-      revision: b77157f6bc4395e398d90ab02a7d2cbc01ab2ce7\n+      revision: b2f548fe672f24122c7f92027b2c9eeea8a0483a"
},{
  "instruction": "net: shell: Move bridge shell under net shell",
  "input": "\tselect SHELL\nSHELL_CMD_REGISTER(bridge, &bridge_commands, \"Ethernet Bridge commands\", NULL);",
  "result": "+* The Ethernet bridge shell is moved under network shell. This is done so that\n+  all the network shell activities can be found under ``net`` shell command.\n+  After this change the bridge shell is used by ``net bridge`` command.\n+\n-\tselect SHELL\n+\tselect NET_SHELL\n-SHELL_CMD_REGISTER(bridge, &bridge_commands, \"Ethernet Bridge commands\", NULL);\n+SHELL_SUBCMD_ADD((net), bridge, &bridge_commands,\n+\t\t \"Ethernet bridge commands.\",\n+\t\t cmd_bridge_show, 1, 1);"
}]
  