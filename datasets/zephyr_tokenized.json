[{
  "instruction": "There is an issue in the following code. It relates to lib: libc: errno: remove non-existing c_std_lib doxygen group\n\nSome groups were being added to a non-existing group: c_std_lib Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|ZEPHYR_LIB_LIBC_ARMSTDC_INCLUDE_ERRNO_H_\nend_define\n\nbegin_comment\ncomment|/**  * @brief System error numbers  *        Error codes returned by functions.  *        Includes a list of those defined by IEEE Std 1003.1-2017.  *  *        This file is supposed to be used together with ARMClang and  *        #define _AEABI_PORTABILITY_LEVEL 1  *        or  *        -D_AEABI_PORTABILITY_LEVEL=1  *  *        For details, please refer to the document:  *        'C Library ABI for the ArmÂ® Architecture, 2021Q1'  *  * @defgroup system_errno Error numbers  * @ingroup c_std_lib  * @{  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nbegin_comment\ncomment|/*  * Copyright (c) 2021 Nordic Semiconductor ASA  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_comment\ncomment|/**  * @brief System error numbers  *        Error codes returned by functions.  *        Includes a list of those defined by IEEE Std 1003.1-2017.  *  *        This file is supposed to be used together with ARMClang and  *        #define _AEABI_PORTABILITY_LEVEL 1  *        or  *        -D_AEABI_PORTABILITY_LEVEL=1  *  *        For details, please refer to the document:  *        'C Library ABI for the ArmÂ® Architecture, 2021Q1'  *  * @defgroup system_errno Error numbers  * @ingroup c_std_lib  * @{  */\nend_comment\n\nbegin_decl_stmt\nDECL|variable|__aeabi_EDOM\nspecifier|const\ndirective|define\nname|ZEPHYR_LIB_LIBC_MINIMAL_INCLUDE_ERRNO_H_\nend_define\n\nbegin_comment\ncomment|/**  * @brief System error numbers  *        Error codes returned by functions.  *        Includes a list of those defined by IEEE Std 1003.1-2017.  * @defgroup system_errno Error numbers  * @ingroup c_std_lib  * @{  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/**  * @brief System error numbers  *        Error codes returned by functions.  *        Includes a list of those defined by IEEE Std 1003.1-2017.  *  *        This file is supposed to be used together with ARMClang and  *        #define _AEABI_PORTABILITY_LEVEL 1  *        or  *        -D_AEABI_PORTABILITY_LEVEL=1  *  *        For details, please refer to the document:  *        'C Library ABI for the ArmÂ® Architecture, 2021Q1'  *  * @defgroup system_errno Error numbers  * @ingroup c_std_lib  * @{  */\n+comment|/**  * @brief System error numbers  *        Error codes returned by functions.  *        Includes a list of those defined by IEEE Std 1003.1-2017.  *  *        This file is supposed to be used together with ARMClang and  *        #define _AEABI_PORTABILITY_LEVEL 1  *        or  *        -D_AEABI_PORTABILITY_LEVEL=1  *  *        For details, please refer to the document:  *        'C Library ABI for the ArmÂ® Architecture, 2021Q1'  *  * @defgroup system_errno Error numbers  * @{  */\n-comment|/**  * @brief System error numbers  *        Error codes returned by functions.  *        Includes a list of those defined by IEEE Std 1003.1-2017.  *  *        This file is supposed to be used together with ARMClang and  *        #define _AEABI_PORTABILITY_LEVEL 1  *        or  *        -D_AEABI_PORTABILITY_LEVEL=1  *  *        For details, please refer to the document:  *        'C Library ABI for the ArmÂ® Architecture, 2021Q1'  *  * @defgroup system_errno Error numbers  * @ingroup c_std_lib  * @{  */\n+comment|/**  * @brief System error numbers  *        Error codes returned by functions.  *        Includes a list of those defined by IEEE Std 1003.1-2017.  *  *        This file is supposed to be used together with ARMClang and  *        #define _AEABI_PORTABILITY_LEVEL 1  *        or  *        -D_AEABI_PORTABILITY_LEVEL=1  *  *        For details, please refer to the document:  *        'C Library ABI for the ArmÂ® Architecture, 2021Q1'  *  * @defgroup system_errno Error numbers  * @{  */\n-comment|/**  * @brief System error numbers  *        Error codes returned by functions.  *        Includes a list of those defined by IEEE Std 1003.1-2017.  * @defgroup system_errno Error numbers  * @ingroup c_std_lib  * @{  */\n+comment|/**  * @brief System error numbers  *        Error codes returned by functions.  *        Includes a list of those defined by IEEE Std 1003.1-2017.  * @defgroup system_errno Error numbers  * @{  */\nThe issue was with: lib: libc: errno: remove non-existing c_std_lib doxygen group\n\nSome groups were being added to a non-existing group: c_std_lib"
},{
  "instruction": "There is an issue in the following code. It relates to tests: uart_elementary: Correct typos\n\nCorrect typos in uart_elementary test Please fix this issue.",
  "input": "Faulty tokenized code:\nThe purpose of this test is to validate basic UART driver functions,\nthat are not tested elsewhere.\nUART interrupt mode is used for the tests purpose.\n\nHardware setup required for these tests:\nFor single uart conviguration - UART0 TX connected to RX and CTS to RTS\nFor dual uart configuratiom - UART0 and UART1 TXs and RXs cross-connected\n\nThese test cases cover:\n- UART configuration,\n- UART error check,\nname|test_pattern\nindex|[\nname|index\nindex|]\nargument_list|,\nliteral|\"Recieived data byte %d does not match pattern 0x%x != 0x%x\"\nargument_list|,\nname|index\nargument_list|,\nname|test_buffer\nindex|[\nname|test_pattern\nindex|[\nname|index\nindex|]\nargument_list|,\nliteral|\"UART0 recieived data byte %d does not match pattern 0x%x != 0x%x\"\nargument_list|,\nname|index\nargument_list|,\nname|test_buffer\nindex|[\nname|test_pattern\nindex|[\nname|index\nindex|]\nargument_list|,\nliteral|\"UART1 recieived data byte %d does not match pattern 0x%x != 0x%x\"\nargument_list|,\nname|index\nargument_list|,\nname|test_buffer_aux\nindex|[",
  "result": "I corrected the issue in the code by changing the following tokens:\n-For single uart conviguration - UART0 TX connected to RX and CTS to RTS\n+For single uart configuration - UART0 TX connected to RX and CTS to RTS\n-literal|\"Recieived data byte %d does not match pattern 0x%x != 0x%x\"\n+literal|\"Received data byte %d does not match pattern 0x%x != 0x%x\"\n-literal|\"UART0 recieived data byte %d does not match pattern 0x%x != 0x%x\"\n+literal|\"UART0 received data byte %d does not match pattern 0x%x != 0x%x\"\n-literal|\"UART1 recieived data byte %d does not match pattern 0x%x != 0x%x\"\n+literal|\"UART1 received data byte %d does not match pattern 0x%x != 0x%x\"\nThe issue was with: tests: uart_elementary: Correct typos\n\nCorrect typos in uart_elementary test"
},{
  "instruction": "There is an issue in the following code. It relates to rtio: workq: Initialize Work item before using it\n\nAs the items come from the memory slab, their initialization state\ncan't be guaranteed. This is causing some devices triggering an assert\nin p4wq where the item's thread is not null (not zero). Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nreturn|return\nname|NULL\nreturn|;\nblock|}\noperator|(\nname|void\noperator|)\nname|k_sem_init\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/** Initialize work item before using it as it comes \t * from a Memory slab (no-init region). \t */\n+name|req\n+operator|->\n+name|work\n+operator|.\n+name|thread\n+operator|=\n+name|NULL\n+expr_stmt|;\nThe issue was with: rtio: workq: Initialize Work item before using it\n\nAs the items come from the memory slab, their initialization state\ncan't be guaranteed. This is causing some devices triggering an assert\nin p4wq where the item's thread is not null (not zero)."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: host: Use correct user_data size for hci_rx_pool\n\n`struct acl_data` is used even when Host flow control is not enabled.\nIt is written to through the `acl(buf)` accessor in `conn.c:hci_acl()`.\n\nHopefully no netbufs were harmed by that :/ Please fix this issue.",
  "input": "Faulty tokenized code:\nname|BT_BUF_RX_SIZE\nargument_list|,\nsizeof|sizeof\nargument_list|(\nexpr|struct\nname|bt_buf_data\nargument_list|)\nargument_list|,\nname|NULL\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|bt_buf_data\n+name|acl_data\nThe issue was with: Bluetooth: host: Use correct user_data size for hci_rx_pool\n\n`struct acl_data` is used even when Host flow control is not enabled.\nIt is written to through the `acl(buf)` accessor in `conn.c:hci_acl()`.\n\nHopefully no netbufs were harmed by that :/"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: voltage_divider: revert patch\n\nA patch was added to the voltage divider to handle an erroneous\nnegative voltage reading for the nrfx_saadc which could return\nnegative voltages even though the ADC mode was single ended.\n\nThis has now been patched in the ADC driver. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|data\noperator|->\nname|raw\nexpr_stmt|;\nblock|}\nif|else if\ncondition|(\nname|config\noperator|->\nname|voltage\noperator|.\nname|port\noperator|.\nname|resolution\noperator|<\nliteral|16\ncondition|)\nblock|{\ncomment|/* Can be removed when issue #71119 is resolved */\nname|raw_val\noperator|=\noperator|(\nname|int16_t\noperator|)\nname|data\noperator|->\nname|raw\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\nname|raw_val\noperator|=\nname|data",
  "result": "I corrected the issue in the code by changing the following tokens:\n-if|else if\n-condition|(\n-name|config\n-operator|->\n-name|voltage\n-operator|.\n-name|port\n-operator|.\n-name|resolution\n-operator|<\n-literal|16\n-condition|)\n-block|{\n-comment|/* Can be removed when issue #71119 is resolved */\n-name|raw_val\n-operator|=\n-operator|(\n-name|int16_t\n-operator|)\n-name|data\n-operator|->\n-name|raw\n-expr_stmt|;\n-block|}\nThe issue was with: drivers: sensor: voltage_divider: revert patch\n\nA patch was added to the voltage divider to handle an erroneous\nnegative voltage reading for the nrfx_saadc which could return\nnegative voltages even though the ADC mode was single ended.\n\nThis has now been patched in the ADC driver."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: adc: adc_nrfx_saadc: remove redundant code\n\nRemove redundant copy of error code and 0 initialization of static\nm_data struct. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|.\nname|samples_buffer\noperator|=\nname|adc_samples_buffer\nblock|,\noperator|.\nname|user_buffer\noperator|=\nname|NULL\nblock|,\noperator|.\nname|active_channels\noperator|=\nliteral|0\nblock|,\nendif|#\ndirective|endif\nblock|}\ndecl_stmt|;\nend_decl_stmt\nname|ctx\nargument_list|,\nname|sequence\nargument_list|)\nexpr_stmt|;\nname|error\noperator|=\nname|adc_context_wait_for_completion\nargument_list|(\noperator|&\nname|m_data\noperator|.\nname|ctx\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|error\nreturn|;\nblock|}\nend_function\n\nbegin_comment",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|.\n-name|user_buffer\n-operator|=\n-name|NULL\n-block|,\n-operator|.\n-name|active_channels\n-operator|=\n-literal|0\n-block|,\n-name|error\n-operator|=\n+return|return\n-expr_stmt|;\n-return|return\n-name|error\nThe issue was with: drivers: adc: adc_nrfx_saadc: remove redundant code\n\nRemove redundant copy of error code and 0 initialization of static\nm_data struct."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: usb_dc_rpi_pico: set AVAILABLE bit separately\n\nThe DPSRAM ports can run at different clocks, this is the default\nconfiguration, follow the advice in the datasheet and wait 3 nop\ninstructions before setting the AVAILABLE bit.\n\nIt can be observed that when the controller is continuously sending data\nto the host, it rarely has a 0-byte transaction instead of a short\npacket. The reason for this is not easy to find, it also seems to depend\non the runtime of individual components. This may fix the problem, but\nthere is no sure proof that this is the solution. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|udc_rpi_start_xfer (uint8_t ep,const void * data,size_t len)\nspecifier|static\nname|int\nname|udc_rpi_start_xfer\nparameter_list|(\nname|uint8_t\nspecifier|const\nname|void\nmodifier|*\nname|data\nparameter_list|,\nname|size_t\nname|len\nparameter_list|)\nblock|{\nname|struct\ndecl_stmt|;\nname|uint32_t\nname|val\ninit|=\nname|len\noperator||\nname|USB_BUF_CTRL_AVAIL\ndecl_stmt|;\nif|if\ncondition|(\noperator|*\nname|ep_state\noperator|->\nname|buf_ctl\noperator|=\nname|val\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|udc_rpi_start_xfer (uint8_t ep,const void * data,size_t len)\n+DECL|function|udc_rpi_start_xfer (uint8_t ep,const void * data,const size_t len)\n+specifier|const\n-operator||\n-name|USB_BUF_CTRL_AVAIL\n+comment|/* \t * By default, clk_sys runs at 125MHz, wait 3 nop instructions before \t * setting the AVAILABLE bit. See 4.1.2.5.1. Concurrent access. \t */\n+name|arch_nop\n+argument_list|()\n+expr_stmt|;\n+name|arch_nop\n+argument_list|()\n+expr_stmt|;\n+name|arch_nop\n+argument_list|()\n+expr_stmt|;\n+operator|*\n+name|ep_state\n+operator|->\n+name|buf_ctl\n+operator|=\n+name|val\n+operator||\n+name|USB_BUF_CTRL_AVAIL\n+expr_stmt|;\nThe issue was with: drivers: usb_dc_rpi_pico: set AVAILABLE bit separately\n\nThe DPSRAM ports can run at different clocks, this is the default\nconfiguration, follow the advice in the datasheet and wait 3 nop\ninstructions before setting the AVAILABLE bit.\n\nIt can be observed that when the controller is continuously sending data\nto the host, it rarely has a 0-byte transaction instead of a short\npacket. The reason for this is not easy to find, it also seems to depend\non the runtime of individual components. This may fix the problem, but\nthere is no sure proof that this is the solution."
},{
  "instruction": "There is an issue in the following code. It relates to net: l2: fix typo\n\nUtilize a code spell-checking tool to scan for and correct spelling errors\nin all files within the `subsys/net/l2` directory. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|=\nliteral|0U\nexpr_stmt|;\nreturn|return;\nblock|}\ncomment|/* NSEC_PER_SEC is between 2^30 and 2^31, seconds is less thant 2^16, \t * thus the computation will be less than 2^63. \t */\nname|interval\noperator|->\nname|low\noperator|=\noperator|(\nname|NULL\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\ncomment|/* in case pkt == fcache->pkt, we don't want \t\t\t * to unref it while clearing the cach. \t\t\t */\nname|fcache\noperator|->\nname|pkt\noperator|=\nname|NULL\nparameter_list|)\nfunction_decl|;\nend_function_decl\n\nbegin_comment\ncomment|/**  * @brief Checks whether the given packet requires acknowledgment, and if so, prepares ACK  *        reception on the TX path, i.e. sets up the necessary internal state before a transmission.  *  *        This function has side effects and must be called before each individual transmission  *        attempt.  *  *        This function checks for and supports both, software and hardware acknowlegement,  *        depending on driver capabilities.  *  *        See sections 6.7.4.1 through 6.7.4.3.  *  * @param iface A valid pointer on the network the packet will be transmitted to  * @param pkt A valid pointer on a packet to send  * @param frag The fragment that needs to be acknowledged  *  * @return true if the given packet requires acknowlegement, false otherwise.  */\nend_comment\n\nbegin_function_decl\nname|bool\nname|ieee802154_prepare_for_ack\nparameter_list|)\nfunction_decl|;\nend_function_decl\n\nbegin_comment\ncomment|/**  * @brief Waits for ACK reception on the TX path with standard compliant timeout settings, i.e.  * listens for incoming packages with the correct attributes and sequence number, see  * section 6.7.4.4 (retransmissions).  *  * This function has side effects and must be called after each transmission attempt if (and only  * if) @ref ieee802154_prepare_for_ack() had been called before.  *  * This function checks for and supports both, software and hardware acknowlegement, depending on  * driver capabilities.  *  * @param iface A valid pointer on the network the packet was transmitted to  * @param ack_required The return value from the corresponding call to  *        @ref ieee802154_prepare_for_ack()  *  * @return 0 if no ACK was required or the exected ACK was received in time, -EIO if the expected  *         ACK was not received within the standard compliant timeout.  */\nend_comment\n\nbegin_function_decl\nname|int\nname|ieee802154_wait_for_ack",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* NSEC_PER_SEC is between 2^30 and 2^31, seconds is less thant 2^16, \t * thus the computation will be less than 2^63. \t */\n+comment|/* NSEC_PER_SEC is between 2^30 and 2^31, seconds is less than 2^16, \t * thus the computation will be less than 2^63. \t */\n-comment|/* in case pkt == fcache->pkt, we don't want \t\t\t * to unref it while clearing the cach. \t\t\t */\n+comment|/* in case pkt == fcache->pkt, we don't want \t\t\t * to unref it while clearing the cache. \t\t\t */\n-comment|/**  * @brief Checks whether the given packet requires acknowledgment, and if so, prepares ACK  *        reception on the TX path, i.e. sets up the necessary internal state before a transmission.  *  *        This function has side effects and must be called before each individual transmission  *        attempt.  *  *        This function checks for and supports both, software and hardware acknowlegement,  *        depending on driver capabilities.  *  *        See sections 6.7.4.1 through 6.7.4.3.  *  * @param iface A valid pointer on the network the packet will be transmitted to  * @param pkt A valid pointer on a packet to send  * @param frag The fragment that needs to be acknowledged  *  * @return true if the given packet requires acknowlegement, false otherwise.  */\n+comment|/**  * @brief Checks whether the given packet requires acknowledgment, and if so, prepares ACK  *        reception on the TX path, i.e. sets up the necessary internal state before a transmission.  *  *        This function has side effects and must be called before each individual transmission  *        attempt.  *  *        This function checks for and supports both, software and hardware acknowledgement,  *        depending on driver capabilities.  *  *        See sections 6.7.4.1 through 6.7.4.3.  *  * @param iface A valid pointer on the network the packet will be transmitted to  * @param pkt A valid pointer on a packet to send  * @param frag The fragment that needs to be acknowledged  *  * @return true if the given packet requires acknowledgement, false otherwise.  */\n-comment|/**  * @brief Waits for ACK reception on the TX path with standard compliant timeout settings, i.e.  * listens for incoming packages with the correct attributes and sequence number, see  * section 6.7.4.4 (retransmissions).  *  * This function has side effects and must be called after each transmission attempt if (and only  * if) @ref ieee802154_prepare_for_ack() had been called before.  *  * This function checks for and supports both, software and hardware acknowlegement, depending on  * driver capabilities.  *  * @param iface A valid pointer on the network the packet was transmitted to  * @param ack_required The return value from the corresponding call to  *        @ref ieee802154_prepare_for_ack()  *  * @return 0 if no ACK was required or the exected ACK was received in time, -EIO if the expected  *         ACK was not received within the standard compliant timeout.  */\n+comment|/**  * @brief Waits for ACK reception on the TX path with standard compliant timeout settings, i.e.  * listens for incoming packages with the correct attributes and sequence number, see  * section 6.7.4.4 (retransmissions).  *  * This function has side effects and must be called after each transmission attempt if (and only  * if) @ref ieee802154_prepare_for_ack() had been called before.  *  * This function checks for and supports both, software and hardware acknowledgement, depending on  * driver capabilities.  *  * @param iface A valid pointer on the network the packet was transmitted to  * @param ack_required The return value from the corresponding call to  *        @ref ieee802154_prepare_for_ack()  *  * @return 0 if no ACK was required or the expected ACK was received in time, -EIO if the expected  *         ACK was not received within the standard compliant timeout.  */\nThe issue was with: net: l2: fix typo\n\nUtilize a code spell-checking tool to scan for and correct spelling errors\nin all files within the `subsys/net/l2` directory."
},{
  "instruction": "There is an issue in the following code. It relates to samples: ipc: icmsg: fix unbalanced nRF53 cpunet enable calls\n\nIt looks like sample called nrf53_cpunet_enable(false) before any\nnrf53_cpunet_enable(true), resulting in asserts due to unbalanced calls\n(error propagated from onoff service). Please fix this issue.",
  "input": "Faulty tokenized code:\nname|LOG_INF\nargument_list|(\nliteral|\"IPC-service HOST demo started\"\nargument_list|)\nexpr_stmt|;\nname|ipc0_instance\noperator|=\nname|DEVICE_DT_GET\nargument_list|(\nname|DT_NODELABEL",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|#\n+directive|if\n+name|defined\n+argument_list|(\n+name|CONFIG_SOC_NRF5340_CPUAPP\n+argument_list|)\n+name|LOG_INF\n+argument_list|(\n+literal|\"Run network core\"\n+argument_list|)\n+expr_stmt|;\n+name|nrf53_cpunet_enable\n+argument_list|(\n+name|true\n+argument_list|)\n+expr_stmt|;\n+endif|#\n+directive|endif\nThe issue was with: samples: ipc: icmsg: fix unbalanced nRF53 cpunet enable calls\n\nIt looks like sample called nrf53_cpunet_enable(false) before any\nnrf53_cpunet_enable(true), resulting in asserts due to unbalanced calls\n(error propagated from onoff service)."
},{
  "instruction": "There is an issue in the following code. It relates to usb: device_next: fix typo in property name\n\nUse rx-fifo-size to set RX ringbuffer size. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|USBD_CDC_ACM_DT_DEVICE_DEFINE\nparameter_list|(\nname|n\nparameter_list|)\ndefine|\\\nvalue|BUILD_ASSERT(DT_INST_ON_BUS(n, usb),\t\t\t\t\t\\ \t\t     \"node \" DT_NODE_PATH(DT_DRV_INST(n))\t\t\t\\ \t\t     \" is not assigned to a USB device controller\");\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tCDC_ACM_DEFINE_DESCRIPTOR(n);\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tUSBD_DEFINE_CLASS(cdc_acm_##n,\t\t\t\t\t\t\\&usbd_cdc_acm_api,\t\t\t\t\t\\ \t\t\t  (void *)DEVICE_DT_GET(DT_DRV_INST(n)), NULL);\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tRING_BUF_DECLARE(cdc_acm_rb_rx_##n, DT_INST_PROP(n, tx_fifo_size));\t\\ \tRING_BUF_DECLARE(cdc_acm_rb_tx_##n, DT_INST_PROP(n, tx_fifo_size));\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic struct cdc_acm_uart_data uart_data_##n = {\t\t\t\\ \t\t.line_coding = CDC_ACM_DEFAULT_LINECODING,\t\t\t\\ \t\t.c_data =&cdc_acm_##n,\t\t\t\t\t\t\\ \t\t.rx_fifo.rb =&cdc_acm_rb_rx_##n,\t\t\t\t\\ \t\t.tx_fifo.rb =&cdc_acm_rb_tx_##n,\t\t\t\t\\ \t\t.notif_sem = Z_SEM_INITIALIZER(uart_data_##n.notif_sem, 0, 1),\t\\ \t\t.desc =&cdc_acm_desc_##n,\t\t\t\t\t\\ \t\t.fs_desc = cdc_acm_fs_desc_##n,\t\t\t\t\t\\ \t\t.hs_desc = cdc_acm_hs_desc_##n,\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n, usbd_cdc_acm_preinit, NULL,\t\t\t\\&uart_data_##n, NULL,\t\t\t\t\t\t\\ \t\tPRE_KERNEL_1, CONFIG_SERIAL_INIT_PRIORITY,\t\t\t\\&cdc_acm_uart_api);\nend_define\n\nbegin_expr_stmt\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|BUILD_ASSERT(DT_INST_ON_BUS(n, usb),\t\t\t\t\t\\ \t\t     \"node \" DT_NODE_PATH(DT_DRV_INST(n))\t\t\t\\ \t\t     \" is not assigned to a USB device controller\");\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tCDC_ACM_DEFINE_DESCRIPTOR(n);\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tUSBD_DEFINE_CLASS(cdc_acm_##n,\t\t\t\t\t\t\\&usbd_cdc_acm_api,\t\t\t\t\t\\ \t\t\t  (void *)DEVICE_DT_GET(DT_DRV_INST(n)), NULL);\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tRING_BUF_DECLARE(cdc_acm_rb_rx_##n, DT_INST_PROP(n, tx_fifo_size));\t\\ \tRING_BUF_DECLARE(cdc_acm_rb_tx_##n, DT_INST_PROP(n, tx_fifo_size));\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic struct cdc_acm_uart_data uart_data_##n = {\t\t\t\\ \t\t.line_coding = CDC_ACM_DEFAULT_LINECODING,\t\t\t\\ \t\t.c_data =&cdc_acm_##n,\t\t\t\t\t\t\\ \t\t.rx_fifo.rb =&cdc_acm_rb_rx_##n,\t\t\t\t\\ \t\t.tx_fifo.rb =&cdc_acm_rb_tx_##n,\t\t\t\t\\ \t\t.notif_sem = Z_SEM_INITIALIZER(uart_data_##n.notif_sem, 0, 1),\t\\ \t\t.desc =&cdc_acm_desc_##n,\t\t\t\t\t\\ \t\t.fs_desc = cdc_acm_fs_desc_##n,\t\t\t\t\t\\ \t\t.hs_desc = cdc_acm_hs_desc_##n,\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n, usbd_cdc_acm_preinit, NULL,\t\t\t\\&uart_data_##n, NULL,\t\t\t\t\t\t\\ \t\tPRE_KERNEL_1, CONFIG_SERIAL_INIT_PRIORITY,\t\t\t\\&cdc_acm_uart_api);\n+value|BUILD_ASSERT(DT_INST_ON_BUS(n, usb),\t\t\t\t\t\\ \t\t     \"node \" DT_NODE_PATH(DT_DRV_INST(n))\t\t\t\\ \t\t     \" is not assigned to a USB device controller\");\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tCDC_ACM_DEFINE_DESCRIPTOR(n);\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tUSBD_DEFINE_CLASS(cdc_acm_##n,\t\t\t\t\t\t\\&usbd_cdc_acm_api,\t\t\t\t\t\\ \t\t\t  (void *)DEVICE_DT_GET(DT_DRV_INST(n)), NULL);\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tRING_BUF_DECLARE(cdc_acm_rb_rx_##n, DT_INST_PROP(n, rx_fifo_size));\t\\ \tRING_BUF_DECLARE(cdc_acm_rb_tx_##n, DT_INST_PROP(n, tx_fifo_size));\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic struct cdc_acm_uart_data uart_data_##n = {\t\t\t\\ \t\t.line_coding = CDC_ACM_DEFAULT_LINECODING,\t\t\t\\ \t\t.c_data =&cdc_acm_##n,\t\t\t\t\t\t\\ \t\t.rx_fifo.rb =&cdc_acm_rb_rx_##n,\t\t\t\t\\ \t\t.tx_fifo.rb =&cdc_acm_rb_tx_##n,\t\t\t\t\\ \t\t.notif_sem = Z_SEM_INITIALIZER(uart_data_##n.notif_sem, 0, 1),\t\\ \t\t.desc =&cdc_acm_desc_##n,\t\t\t\t\t\\ \t\t.fs_desc = cdc_acm_fs_desc_##n,\t\t\t\t\t\\ \t\t.hs_desc = cdc_acm_hs_desc_##n,\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n, usbd_cdc_acm_preinit, NULL,\t\t\t\\&uart_data_##n, NULL,\t\t\t\t\t\t\\ \t\tPRE_KERNEL_1, CONFIG_SERIAL_INIT_PRIORITY,\t\t\t\\&cdc_acm_uart_api);\nThe issue was with: usb: device_next: fix typo in property name\n\nUse rx-fifo-size to set RX ringbuffer size."
},{
  "instruction": "There is an issue in the following code. It relates to spi: shell: add missing newline character\n\nAdd missing newline in help string. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|&\nname|dsub_device_name\nargument_list|,\nliteral|\"Configure SPI\\n\"\nliteral|\"Usage: spi conf<device><frequency> [<settings>]\\n\"\nliteral|\"<settings> - any sequence of letters:\"\nliteral|\"o - SPI_MODE_CPOL\\n\"\nliteral|\"h - SPI_MODE_CPHA\\n\"\nliteral|\"l - SPI_TRANSFER_LSB\\n\"\nliteral|\"T - SPI_FRAME_FORMAT_TI\\n\"\nliteral|\"example: spi conf spi1 1000000 ol\"",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"<settings> - any sequence of letters:\"\n+literal|\"<settings> - any sequence of letters:\\n\"\nThe issue was with: spi: shell: add missing newline character\n\nAdd missing newline in help string."
},{
  "instruction": "There is an issue in the following code. It relates to sensor: coverity-fix: Simplify unsigned comparison\n\n- VEML7700 - Coverity CID 363733, GH: #74759.\n- VEML7700 - CID 363719, GH: #74755. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nstruct|;\nend_struct\n\nbegin_function\nDECL|function|is_veml7700_gain_in_range (int32_t gain_selection)\nspecifier|static\nname|bool\nname|is_veml7700_gain_in_range\nparameter_list|(\nname|int32_t\nname|gain_selection\nparameter_list|)\nblock|{\nreturn|return\noperator|(\noperator|(\nname|gain_selection\noperator|>=\nliteral|0U\noperator|)\noperator|&&\noperator|(\nname|gain_selection\noperator|<\nname|VEML7700_ALS_GAIN_ELEM_COUNT\noperator|)\noperator|)\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|is_veml7700_it_in_range (int32_t it_selection)\nspecifier|static\nname|bool\nname|is_veml7700_it_in_range\nparameter_list|(\nname|int32_t\nname|it_selection\nparameter_list|)\nblock|{\nreturn|return\noperator|(\noperator|(\nname|it_selection\noperator|>=\nliteral|0U\noperator|)\noperator|&&\noperator|(\nname|it_selection\noperator|<\nname|VEML7700_ALS_IT_ELEM_COUNT\noperator|)\noperator|)\nreturn|;\nblock|}\nend_function\n\nbegin_comment",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|is_veml7700_gain_in_range (int32_t gain_selection)\n+DECL|function|is_veml7700_gain_in_range (uint32_t gain_selection)\n-name|int32_t\n+name|uint32_t\n-operator|(\n-name|gain_selection\n-operator|>=\n-literal|0U\n-operator|)\n-operator|&&\n-operator|(\n-operator|)\n-DECL|function|is_veml7700_it_in_range (int32_t it_selection)\n+DECL|function|is_veml7700_it_in_range (uint32_t it_selection)\n-name|int32_t\n+name|uint32_t\n-operator|(\n-name|it_selection\n-operator|>=\n-literal|0U\n-operator|)\n-operator|&&\n-operator|(\n-operator|)\nThe issue was with: sensor: coverity-fix: Simplify unsigned comparison\n\n- VEML7700 - Coverity CID 363733, GH: #74759.\n- VEML7700 - CID 363719, GH: #74755."
},{
  "instruction": "There is an issue in the following code. It relates to build: Prefix missed generated syscall includes\n\nPR #63973 namespaced generated headers with zephyr/, including generated\nsyscall headers.\n\nSince then, some new generated syscall header includes have been added\nwithout the zephyr/ prefix, breaking builds when\nCONFIG_LEGACY_GENERATED_INCLUDE_PATH is disabled.\n\nThis commit adds the zephyr/ prefix to includes for generated syscall\nheaders where it has been missed. Please fix this issue.",
  "input": "Faulty tokenized code:\nend_function\n\nbegin_include\ninclude|#\ndirective|include\nfile|<syscalls/flash_fill_mrsh.c>\nend_include\n\nbegin_function\nDECL|function|z_vrfy_flash_flatten (const struct device * dev,off_t offset,size_t size)\nname|int\nend_function\n\nbegin_include\ninclude|#\ndirective|include\nfile|<syscalls/flash_flatten_mrsh.c>\nend_include\n\nbegin_ifdef\nifdef|#\ndirective|ifdef\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nfile|<syscalls/mspi.h>\nend_include\n\nbegin_endif\nendif|#\ndirective|endif\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nfile|<syscalls/tee.h>\nend_include\n\nbegin_endif\nendif|#\ndirective|endif\nend_function\n\nbegin_include\ninclude|#\ndirective|include\nfile|<syscalls/device_get_by_dt_nodelabel_mrsh.c>\nend_include\n\nbegin_endif\nendif|#\ndirective|endif",
  "result": "I corrected the issue in the code by changing the following tokens:\n-file|<syscalls/flash_fill_mrsh.c>\n+file|<zephyr/syscalls/flash_fill_mrsh.c>\n-file|<syscalls/flash_flatten_mrsh.c>\n+file|<zephyr/syscalls/flash_flatten_mrsh.c>\n-file|<syscalls/mspi.h>\n+file|<zephyr/syscalls/mspi.h>\n-file|<syscalls/tee.h>\n+file|<zephyr/syscalls/tee.h>\n-file|<syscalls/device_get_by_dt_nodelabel_mrsh.c>\n+file|<zephyr/syscalls/device_get_by_dt_nodelabel_mrsh.c>\nThe issue was with: build: Prefix missed generated syscall includes\n\nPR #63973 namespaced generated headers with zephyr/, including generated\nsyscall headers.\n\nSince then, some new generated syscall header includes have been added\nwithout the zephyr/ prefix, breaking builds when\nCONFIG_LEGACY_GENERATED_INCLUDE_PATH is disabled.\n\nThis commit adds the zephyr/ prefix to includes for generated syscall\nheaders where it has been missed."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: A2DP: Fix mistake parameter\n\nAfter configuration, the stream instance is valid and stream's\nlocal_ep valid. bt_a2dp_stream_establish's parameter is stream\ntoo. So in bt_a2dp_stream_establish, stream->local_ep should be\nused to tell lower level (AVDTP) the sep.\nset_config_param is used by copy-paste mistake. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|open_param\noperator|.\nname|sep\noperator|=\nname|a2dp\noperator|->\nname|set_config_param\noperator|.\nname|sep\nexpr_stmt|;\nreturn|return\nname|bt_avdtp_open\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|a2dp\n+operator|&\n+name|stream\n+operator|->\n+name|local_ep\n-name|set_config_param\n-operator|.\nThe issue was with: Bluetooth: A2DP: Fix mistake parameter\n\nAfter configuration, the stream instance is valid and stream's\nlocal_ep valid. bt_a2dp_stream_establish's parameter is stream\ntoo. So in bt_a2dp_stream_establish, stream->local_ep should be\nused to tell lower level (AVDTP) the sep.\nset_config_param is used by copy-paste mistake."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: BAP: Scan delegator: Add log if actionable CBs are not set\n\nIf the callbacks are not set, then we cannot do the requested actions\nfrom the broadcast assistant. Since this is a significant issue,\nthat may prevent the role from working as intended,\nLOG_WRN is used other LOG_DBG. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|requested_bis_sync\nargument_list|)\nexpr_stmt|;\nblock|}\nblock|}\nend_function\n\nbegin_function\nDECL|function|scan_delegator_disconnected (struct bt_conn * conn,uint8_t reason)\nargument_list|,\nname|pa_interval\nargument_list|)\nexpr_stmt|;\nblock|}\nreturn|return\nname|err\nreturn|;\nblock|}\nend_function\nargument_list|,\nname|state\nargument_list|)\nexpr_stmt|;\nblock|}\nreturn|return\nname|err\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+else|else\n+block|{\n+name|LOG_WRN\n+argument_list|(\n+literal|\"bis_sync_req callback is missing\"\n+argument_list|)\n+expr_stmt|;\n+block|}\n+else|else\n+block|{\n+name|LOG_WRN\n+argument_list|(\n+literal|\"pa_sync_req callback is missing, rejecting PA sync request\"\n+argument_list|)\n+expr_stmt|;\n+block|}\n+else|else\n+block|{\n+name|LOG_WRN\n+argument_list|(\n+literal|\"pa_sync_term_req callback is missing, rejecting PA sync term request\"\n+argument_list|)\n+expr_stmt|;\n+block|}\nThe issue was with: Bluetooth: BAP: Scan delegator: Add log if actionable CBs are not set\n\nIf the callbacks are not set, then we cannot do the requested actions\nfrom the broadcast assistant. Since this is a significant issue,\nthat may prevent the role from working as intended,\nLOG_WRN is used other LOG_DBG."
},{
  "instruction": "There is an issue in the following code. It relates to mgmt: mcumgr: smp: Initialise variable\n\nSeemingly newer versions of gcc wrongly detect a variable is used\nwhen it is not set, this is not the case the compiler is wrong,\nadd a default set to null to prevent the fake warning appearing\nas an error in CI Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|)\nblock|{\nname|struct\nname|smp_hdr\nname|req_hdr\ndecl_stmt|;\nname|void\nmodifier|*\nname|rsp\ndecl_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+init|=\n+block|{\n+literal|0\n+block|}\nThe issue was with: mgmt: mcumgr: smp: Initialise variable\n\nSeemingly newer versions of gcc wrongly detect a variable is used\nwhen it is not set, this is not the case the compiler is wrong,\nadd a default set to null to prevent the fake warning appearing\nas an error in CI"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: dac: dac_ad569x: Add bit shift for 14/12-bit variants\n\nThe 14/12-bit variants (AD5692R/AD5691R) require the data to be in the\nupper bits of the two byte data field of the write command. See table 12\nand the associated footnotes in the AD5693R/AD5692R/AD5691R/AD5693\ndatasheet. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}\nreturn|return\nname|ad569x_write\nargument_list|(\nname|dev\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|value\n+operator|<<=\n+literal|16\n+operator|-\n+name|config\n+operator|->\n+name|resolution\n+expr_stmt|;\nThe issue was with: drivers: dac: dac_ad569x: Add bit shift for 14/12-bit variants\n\nThe 14/12-bit variants (AD5692R/AD5691R) require the data to be in the\nupper bits of the two byte data field of the write command. See table 12\nand the associated footnotes in the AD5693R/AD5692R/AD5691R/AD5693\ndatasheet."
},{
  "instruction": "There is an issue in the following code. It relates to drivers/spi/spi_xlnx_axi_quadspi: Build fix w CONFIG_SPI_ASYNC\n\nFix a build error when CONFIG_SPI_ASYNC is set.\nThe issue was detected by CI\n\n```\nspi_xlnx_axi_quadspi.c: In function 'xlnx_quadspi_isr':\nspi_xlnx_axi_quadspi.c:489:21: error: 'ctx' undeclared\n  489 |                 if (ctx->asynchronous) {\n      |                     ^~~\n``` Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\ncomment|/** \t\t * For async mode, we need to read the RX FIFO and refill the TX FIFO \t\t * if needed here. \t\t * For sync mode, we do this in the caller's context to avoid doing too much \t\t * work in the ISR, so just post the event. \t\t */\nifdef|#\ndirective|ifdef\nname|CONFIG_SPI_ASYNC\nif|if\ncondition|(\nname|ctx\noperator|->\nname|asynchronous",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|struct\n+name|spi_context\n+modifier|*\n+name|ctx\n+init|=\n+operator|&\n+name|data\n+operator|->\n+name|ctx\n+decl_stmt|;\nThe issue was with: drivers/spi/spi_xlnx_axi_quadspi: Build fix w CONFIG_SPI_ASYNC\n\nFix a build error when CONFIG_SPI_ASYNC is set.\nThe issue was detected by CI\n\n```\nspi_xlnx_axi_quadspi.c: In function 'xlnx_quadspi_isr':\nspi_xlnx_axi_quadspi.c:489:21: error: 'ctx' undeclared\n  489 |                 if (ctx->asynchronous) {\n      |                     ^~~\n```"
},{
  "instruction": "There is an issue in the following code. It relates to arch: arm: cortex_m: add ip & lr to the clobber list\n\nCalls to other function may clobber ip & lr too so these register need to\nbe added to the clobberlist.\nr3 is not actually used in z_arm_switch_to_main_no_multithreading so it is\nalso removed from the clobber list. Please fix this issue.",
  "input": "Faulty tokenized code:\ncomment|/* arch_irq_unlock(0) */\nasm|\"ldr   r3, =arch_irq_unlock_outlined\\n\" \t\"blx   r3\\n\"  \t\"mov   r0, r4\\n\"\ncomment|/* z_thread_entry(_main, NULL, NULL, NULL) */\nasm|\"mov   r1, #0\\n\" \t\"mov   r2, #0\\n\" \t\"mov   r3, #0\\n\" \t\"ldr   r4, =z_thread_entry\\n\" \t\"bx    r4\\n\"\ncomment|/* We donât intend to return, so there is no need to link. */\nasm|: \"+r\" (_main) \t: \"r\" (stack_ptr) \t: \"r0\", \"r1\", \"r2\", \"r3\", \"r4\");\nname|CODE_UNREACHABLE\nexpr_stmt|;\nblock|}\nend_function\n\ndirective|ifdef\nname|CONFIG_BUILTIN_STACK_GUARD\nasm|, [_psplim]\"r\" (psplim)\nendif|#\ndirective|endif\nasm|: \"r0\", \"r1\", \"r2\", \"r3\" \t);\nname|CODE_UNREACHABLE\nexpr_stmt|;\ncomment|/* LCOV_EXCL_LINE */\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-asm|: \"+r\" (_main) \t: \"r\" (stack_ptr) \t: \"r0\", \"r1\", \"r2\", \"r3\", \"r4\");\n+asm|: \"+r\" (_main) \t: \"r\" (stack_ptr) \t: \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"ip\", \"lr\");\n-asm|: \"r0\", \"r1\", \"r2\", \"r3\" \t);\n+asm|: \"r0\", \"r1\", \"r2\", \"ip\", \"lr\" \t);\nThe issue was with: arch: arm: cortex_m: add ip & lr to the clobber list\n\nCalls to other function may clobber ip & lr too so these register need to\nbe added to the clobberlist.\nr3 is not actually used in z_arm_switch_to_main_no_multithreading so it is\nalso removed from the clobber list."
},{
  "instruction": "There is an issue in the following code. It relates to posix: shm: fix build error with minimal libc\n\nIn `lib/posix/options/shm.c` we don't include stdio.h\nheader but use standard SEEK_xxx definitions (i.e. `SEEK_SET`)\nwhich cause build issues (if the minimal libc is used).\n\nFix that. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<string.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<kernel_arch_interface.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<stdio.h>\n+end_include\n+\nThe issue was with: posix: shm: fix build error with minimal libc\n\nIn `lib/posix/options/shm.c` we don't include stdio.h\nheader but use standard SEEK_xxx definitions (i.e. `SEEK_SET`)\nwhich cause build issues (if the minimal libc is used).\n\nFix that."
},{
  "instruction": "There is an issue in the following code. It relates to watchdog: cmsdk_apb: validate timeout window\n\nValidate the maximum timeout window, as required by the API tests. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ARG_UNUSED\nargument_list|(\nname|dev\nargument_list|)\nexpr_stmt|;\ncomment|/* Reload value */\nname|reload_cycles\noperator|=\nname|config\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|config\n+operator|->\n+name|window\n+operator|.\n+name|max\n+operator|==\n+literal|0\n+condition|)\n+block|{\n+return|return\n+operator|-\n+name|EINVAL\n+return|;\n+block|}\nThe issue was with: watchdog: cmsdk_apb: validate timeout window\n\nValidate the maximum timeout window, as required by the API tests."
},{
  "instruction": "There is an issue in the following code. It relates to boards: beagle: beagleconnect_freedom: Fix formatting\n\n- Fix formatting in board_antenna.c by using the standard config in\n  Zephyr.\n- Reduce diff with cc1352p1_launchxl/board_antenna.c as much as possible Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/* SPDX-License-Identifier: Apache-2.0  *  * Copyright (c) 2021 Florin Stancu  * Copyright (c) 2021 Jason Kridner, BeagleBoard.org Foundation  * Copyright (c) 2024 Ayush Singh<ayush@beagleboard.org>  *  */\nend_comment\n\nbegin_comment\ncomment|/*  * Implements the RF driver callback to configure the on-board antenna  * switch.  */\nend_comment\noperator|.\nname|commandNo\ncondition|)\nblock|{\ncase|case\noperator|(\nname|CMD_RADIO_SETUP\noperator|)\ncase|:\ncase|case\noperator|(\nname|CMD_BLE5_RADIO_SETUP\noperator|)\ncase|:\nname|loDivider\noperator|=\nname|RF_LODIVIDER_MASK\noperator|&\noperator|.\nname|loDivider\nexpr_stmt|;\nbreak|break;\ncase|case\noperator|(\nname|CMD_PROP_RADIO_DIV_SETUP\noperator|)\ncase|:\nname|loDivider\noperator|=\nname|RF_LODIVIDER_MASK\noperator|&",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* SPDX-License-Identifier: Apache-2.0  *  * Copyright (c) 2021 Florin Stancu  * Copyright (c) 2021 Jason Kridner, BeagleBoard.org Foundation  * Copyright (c) 2024 Ayush Singh<ayush@beagleboard.org>  *  */\n+comment|/*  * Copyright (c) 2021 Florin Stancu  * Copyright (c) 2021 Jason Kridner, BeagleBoard.org Foundation  * Copyright (c) 2024 Ayush Singh<ayush@beagleboard.org>  *  * SPDX-License-Identifier: Apache-2.0  */\n-operator|(\n-operator|)\n-operator|(\n-operator|)\n-operator|(\n-operator|)\nThe issue was with: boards: beagle: beagleconnect_freedom: Fix formatting\n\n- Fix formatting in board_antenna.c by using the standard config in\n  Zephyr.\n- Reduce diff with cc1352p1_launchxl/board_antenna.c as much as possible"
},{
  "instruction": "There is an issue in the following code. It relates to samples: net: cellular_modem: fix division by zero in sample_echo_packet\n\nA hard fault occurs when the `sample_echo_packet` function attempts\nto print the average time per successful echo and no packets have\nbeen sent, resulting in a division by zero error. This fix adds a check\nto ensure that `packets_sent` is greater than 0 before performing\nthe division. This prevents the system from halting due to a usage fault. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|packets_sent\nargument_list|,\nname|SAMPLE_TEST_ECHO_PACKETS\nargument_list|)\nexpr_stmt|;\nname|printk\nargument_list|(\nliteral|\"Average time per successful echo: %u ms\\n\"\nargument_list|,\nname|accumulated_ms\noperator|/\nname|packets_sent\nargument_list|)\nexpr_stmt|;\nname|printk\nargument_list|(\nliteral|\"Close UDP socket\\n\"\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|packets_sent\n+operator|>\n+literal|0\n+condition|)\n+block|{\n+block|}\nThe issue was with: samples: net: cellular_modem: fix division by zero in sample_echo_packet\n\nA hard fault occurs when the `sample_echo_packet` function attempts\nto print the average time per successful echo and no packets have\nbeen sent, resulting in a division by zero error. This fix adds a check\nto ensure that `packets_sent` is greater than 0 before performing\nthe division. This prevents the system from halting due to a usage fault."
},{
  "instruction": "There is an issue in the following code. It relates to Samples: max17048: added units to output\n\npresent sample output does not contain units.\r\nadded units to sample output\r\n\r Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nelse|else\nblock|{\nname|printk\nargument_list|(\nliteral|\"Time to empty %d\\n\"\nargument_list|,\nname|vals\nindex|[\nliteral|0\nindex|]\nname|runtime_to_empty\nargument_list|)\nexpr_stmt|;\nname|printk\nargument_list|(\nliteral|\"Time to full %d\\n\"\nargument_list|,\nname|vals\nindex|[\nliteral|1\nindex|]\nname|relative_state_of_charge\nargument_list|)\nexpr_stmt|;\nname|printk\nargument_list|(\nliteral|\"Voltage %d\\n\"\nargument_list|,\nname|vals\nindex|[\nliteral|3\nindex|]",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"Time to empty %d\\n\"\n+literal|\"Time to empty %d minutes\\n\"\n-literal|\"Time to full %d\\n\"\n+literal|\"Time to full %d minutes\\n\"\n-literal|\"Voltage %d\\n\"\n+literal|\"Voltage %d\\n uV\"\nThe issue was with: Samples: max17048: added units to output\n\npresent sample output does not contain units.\r\nadded units to sample output\r\n\r"
},{
  "instruction": "There is an issue in the following code. It relates to net: ethernet: check vlan iface existence\n\nDrop a packet, if it has a VLAN tag, for\nthat we don't have a VLAN interface. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|pkt\nargument_list|)\nargument_list|)\nargument_list|)\nexpr_stmt|;\ncomment|/* We could call VLAN interface directly but then the \t\t\t * interface statistics would not get updated so route \t\t\t * the call via Virtual L2 layer. \t\t\t */\nif|if\ncondition|(\nname|net_if_l2\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* If we receive a packet with a VLAN tag, for that we don't \t\t\t * have a VLAN interface, drop the packet. \t\t\t */\n+if|if\n+condition|(\n+name|net_if_l2\n+argument_list|(\n+name|net_pkt_iface\n+argument_list|(\n+name|pkt\n+argument_list|)\n+argument_list|)\n+operator|==\n+name|NULL\n+condition|)\n+block|{\n+goto|goto\n+name|drop\n+goto|;\n+block|}\nThe issue was with: net: ethernet: check vlan iface existence\n\nDrop a packet, if it has a VLAN tag, for\nthat we don't have a VLAN interface."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: dac: dac_ad569x: Fix reset error return\n\nThe intention here appears to be to return an error. Use an early return\nto implement this. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|LOG_ERR\nargument_list|(\nliteral|\"failed to reset DAC output\"\nargument_list|)\nexpr_stmt|;\nname|ret\noperator|=\noperator|-\nname|EIO\nexpr_stmt|;\nblock|}\nreturn|return\nliteral|0\nreturn|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|ret\n-operator|=\n+return|return\n-expr_stmt|;\n+return|;\nThe issue was with: drivers: dac: dac_ad569x: Fix reset error return\n\nThe intention here appears to be to return an error. Use an early return\nto implement this."
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: adc_api: use proper printf format\n\nThis commit changes the adc_api test to use the proper printf\nformat specifier when printing the ADC samplings. This ensures\nthat all values are printed on 16-bit. Without this specifier,\nnegative values are sign-extended and printed on full integer\nsize (e.g., 0x8000 -> \\\"0xFFFF8000\\\"). Please fix this issue.",
  "input": "Faulty tokenized code:\nname|i\nindex|]\ndecl_stmt|;\nname|TC_PRINT\nargument_list|(\nliteral|\"0x%04x \"\nargument_list|,\nname|sample_value\nargument_list|)\nexpr_stmt|;\nif|if",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"0x%04x \"\n+literal|\"0x%04hx \"\nThe issue was with: tests: drivers: adc_api: use proper printf format\n\nThis commit changes the adc_api test to use the proper printf\nformat specifier when printing the ADC samplings. This ensures\nthat all values are printed on 16-bit. Without this specifier,\nnegative values are sign-extended and printed on full integer\nsize (e.g., 0x8000 -> \\\"0xFFFF8000\\\")."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: cc13xx_cc26xx: pwm: enable pwm(gpt) in sleep/deepsleep mode\n\n- enabled GPT(PWM) peripheral for sleep/deepsleep mode in init_pwm()\n- Fixed: undefined behaviour when using k_sleep() Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|config\nargument_list|)\nargument_list|)\nexpr_stmt|;\ncomment|/* Load PRCM settings. */\nname|PRCMLoadSet\nargument_list|()\nexpr_stmt|;\nwhile|while",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|PRCMPeripheralSleepEnable\n+argument_list|(\n+name|get_timer_peripheral\n+argument_list|(\n+name|config\n+argument_list|)\n+argument_list|)\n+expr_stmt|;\n+name|PRCMPeripheralDeepSleepEnable\n+argument_list|(\n+name|get_timer_peripheral\n+argument_list|(\n+name|config\n+argument_list|)\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: cc13xx_cc26xx: pwm: enable pwm(gpt) in sleep/deepsleep mode\n\n- enabled GPT(PWM) peripheral for sleep/deepsleep mode in init_pwm()\n- Fixed: undefined behaviour when using k_sleep()"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: ptp_clock_nxp_enet: add module_dev to driver config\n\nd2ddccda19db3 [formerly c8d8dce7555bf] introduced a regression whereby driver config should hold\nmodule device pointer, except it didn't.\nThis commit adds module_dev to the driver config. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|PTP_CLOCK_NXP_ENET_INIT\nparameter_list|(\nname|n\nparameter_list|)\ndefine|\\\nvalue|static void nxp_enet_ptp_clock_##n##_irq_config_func(void)\t\t\\ \t{\t\t\t\t\t\t\t\t\t\\ \t\tIRQ_CONNECT(DT_INST_IRQ_BY_IDX(n, 0, irq),\t\t\t\\ \t\t\t\tDT_INST_IRQ_BY_IDX(n, 0, priority),\t\t\\ \t\t\t\tptp_clock_nxp_enet_isr,\t\t\t\t\\ \t\t\t\tDEVICE_DT_INST_GET(n),\t\t\t\t\\ \t\t\t\t0);\t\t\t\t\t\t\\ \t\tirq_enable(DT_INST_IRQ_BY_IDX(n, 0, irq));\t\t\t\\ \t}\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tPINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct ptp_clock_nxp_enet_config\t\t\t\t\\ \t\tptp_clock_nxp_enet_##n##_config = {\t\t\t\t\\ \t\t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\\ \t\t\t.port = DEVICE_DT_INST_GET(n),\t\t\t\t\\ \t\t\t.clock_dev = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(n)),\t\\ \t\t\t.clock_subsys = (void *)\t\t\t\t\\ \t\t\t\t\tDT_INST_CLOCKS_CELL_BY_IDX(n, 0, name),\t\\ \t\t\t.irq_config_func =\t\t\t\t\t\\ \t\t\t\tnxp_enet_ptp_clock_##n##_irq_config_func,\t\\ \t\t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic struct ptp_clock_nxp_enet_data ptp_clock_nxp_enet_##n##_data;\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n,&ptp_clock_nxp_enet_init, NULL,\t\t\\&ptp_clock_nxp_enet_##n##_data,\t\t\t\\&ptp_clock_nxp_enet_##n##_config,\t\t\\ \t\t\t\tPOST_KERNEL, CONFIG_PTP_CLOCK_INIT_PRIORITY,\t\\&ptp_clock_nxp_enet_api);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|static void nxp_enet_ptp_clock_##n##_irq_config_func(void)\t\t\\ \t{\t\t\t\t\t\t\t\t\t\\ \t\tIRQ_CONNECT(DT_INST_IRQ_BY_IDX(n, 0, irq),\t\t\t\\ \t\t\t\tDT_INST_IRQ_BY_IDX(n, 0, priority),\t\t\\ \t\t\t\tptp_clock_nxp_enet_isr,\t\t\t\t\\ \t\t\t\tDEVICE_DT_INST_GET(n),\t\t\t\t\\ \t\t\t\t0);\t\t\t\t\t\t\\ \t\tirq_enable(DT_INST_IRQ_BY_IDX(n, 0, irq));\t\t\t\\ \t}\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tPINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct ptp_clock_nxp_enet_config\t\t\t\t\\ \t\tptp_clock_nxp_enet_##n##_config = {\t\t\t\t\\ \t\t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\\ \t\t\t.port = DEVICE_DT_INST_GET(n),\t\t\t\t\\ \t\t\t.clock_dev = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(n)),\t\\ \t\t\t.clock_subsys = (void *)\t\t\t\t\\ \t\t\t\t\tDT_INST_CLOCKS_CELL_BY_IDX(n, 0, name),\t\\ \t\t\t.irq_config_func =\t\t\t\t\t\\ \t\t\t\tnxp_enet_ptp_clock_##n##_irq_config_func,\t\\ \t\t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic struct ptp_clock_nxp_enet_data ptp_clock_nxp_enet_##n##_data;\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n,&ptp_clock_nxp_enet_init, NULL,\t\t\\&ptp_clock_nxp_enet_##n##_data,\t\t\t\\&ptp_clock_nxp_enet_##n##_config,\t\t\\ \t\t\t\tPOST_KERNEL, CONFIG_PTP_CLOCK_INIT_PRIORITY,\t\\&ptp_clock_nxp_enet_api);\n+value|static void nxp_enet_ptp_clock_##n##_irq_config_func(void)\t\t\\ \t{\t\t\t\t\t\t\t\t\t\\ \t\tIRQ_CONNECT(DT_INST_IRQ_BY_IDX(n, 0, irq),\t\t\t\\ \t\t\t\tDT_INST_IRQ_BY_IDX(n, 0, priority),\t\t\\ \t\t\t\tptp_clock_nxp_enet_isr,\t\t\t\t\\ \t\t\t\tDEVICE_DT_INST_GET(n),\t\t\t\t\\ \t\t\t\t0);\t\t\t\t\t\t\\ \t\tirq_enable(DT_INST_IRQ_BY_IDX(n, 0, irq));\t\t\t\\ \t}\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tPINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct ptp_clock_nxp_enet_config\t\t\t\t\\ \t\tptp_clock_nxp_enet_##n##_config = {\t\t\t\t\\ \t\t\t.module_dev = DEVICE_DT_GET(DT_INST_PARENT(n)),\t\t\\ \t\t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\\ \t\t\t.port = DEVICE_DT_INST_GET(n),\t\t\t\t\\ \t\t\t.clock_dev = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(n)),\t\\ \t\t\t.clock_subsys = (void *)\t\t\t\t\\ \t\t\t\t\tDT_INST_CLOCKS_CELL_BY_IDX(n, 0, name),\t\\ \t\t\t.irq_config_func =\t\t\t\t\t\\ \t\t\t\tnxp_enet_ptp_clock_##n##_irq_config_func,\t\\ \t\t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic struct ptp_clock_nxp_enet_data ptp_clock_nxp_enet_##n##_data;\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n,&ptp_clock_nxp_enet_init, NULL,\t\t\\&ptp_clock_nxp_enet_##n##_data,\t\t\t\\&ptp_clock_nxp_enet_##n##_config,\t\t\\ \t\t\t\tPOST_KERNEL, CONFIG_PTP_CLOCK_INIT_PRIORITY,\t\\&ptp_clock_nxp_enet_api);\nThe issue was with: drivers: ptp_clock_nxp_enet: add module_dev to driver config\n\nd2ddccda19db3 [formerly c8d8dce7555bf] introduced a regression whereby driver config should hold\nmodule device pointer, except it didn't.\nThis commit adds module_dev to the driver config."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: dac: dac_ad56xx: Fix channel range check\n\nAn off by one error in the channel range check results in an out of\nbound access to the channel lookup array. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|;\nblock|}\nif|if\ncondition|(\nname|channel\noperator|>\nname|config\noperator|->\nname|channel_count\ncondition|)\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|>\n+operator|>=\nThe issue was with: drivers: dac: dac_ad56xx: Fix channel range check\n\nAn off by one error in the channel range check results in an out of\nbound access to the channel lookup array."
},{
  "instruction": "There is an issue in the following code. It relates to config: esp32: configurable UART FIFO thresholds\n\nThe existing configuration of the ESP32 UART FIFO thresholds\nwas fixed, leading to inefficiencies in handling\nModbus RTU packages exceeding this size.\nThis commit introduces two new Kconfig options,\nallowing users to adjust the esp32 fifo thresholds as needed.\nfixes #74311\n\n\nconfig: esp32:  configurable UART FIFO thresholds\n\nThe existing configuration of the ESP32 UART FIFO thresholds\nwas fixed, leading to inefficiencies in handling\nModbus RTU packages exceeding this size.\nThis commit introduces two new Kconfig options,\nallowing users to adjust the esp32 fifo thresholds as needed.\nfixes #74311 Please fix this issue.",
  "input": "Faulty tokenized code:\n\t  This driver uses the peripheral called USB Serial/JTAG Controller\n\t  (USB_SERIAL_JTAG), which acts as a CDC-ACM interface towards the\n\t  USB host. The USB stack is built into the chip and accessed\n\t  by the firmware through a simplified API similar to a \"normal\"\n\t  UART peripheral.\nbegin_define\nDECL|macro|UART_TX_FIFO_THRESH\ndefine|#\ndirective|define\nname|UART_TX_FIFO_THRESH\nvalue|0x1\nend_define\n\nbegin_define\nDECL|macro|UART_RX_FIFO_THRESH\ndefine|#\ndirective|define\nname|UART_RX_FIFO_THRESH\nvalue|0x16\nend_define\n\nbegin_if\nif|#\ndirective|if",
  "result": "I corrected the issue in the code by changing the following tokens:\n+\n+config UART_ESP32_TX_FIFO_THRESH\n+\thex \"ESP32 UART TX FIFO Threshold\"\n+\tdepends on UART_ESP32\n+\tdefault 0x1\n+\trange 1 127\n+\thelp\n+\t  Configure the TX FIFO threshold for ESP32 UART driver.\n+\n+config UART_ESP32_RX_FIFO_THRESH\n+\thex \"ESP32 UART RX FIFO Threshold\"\n+\tdepends on UART_ESP32\n+\tdefault 0x16\n+\trange 1 127\n+\thelp\n+\t  Configure the RX FIFO threshold for ESP32 UART driver.\n-value|0x1\n+value|(CONFIG_UART_ESP32_TX_FIFO_THRESH)\n-value|0x16\n+value|(CONFIG_UART_ESP32_RX_FIFO_THRESH)\nThe issue was with: config: esp32: configurable UART FIFO thresholds\n\nThe existing configuration of the ESP32 UART FIFO thresholds\nwas fixed, leading to inefficiencies in handling\nModbus RTU packages exceeding this size.\nThis commit introduces two new Kconfig options,\nallowing users to adjust the esp32 fifo thresholds as needed.\nfixes #74311\n\n\nconfig: esp32:  configurable UART FIFO thresholds\n\nThe existing configuration of the ESP32 UART FIFO thresholds\nwas fixed, leading to inefficiencies in handling\nModbus RTU packages exceeding this size.\nThis commit introduces two new Kconfig options,\nallowing users to adjust the esp32 fifo thresholds as needed.\nfixes #74311"
},{
  "instruction": "There is an issue in the following code. It relates to modules: hostap: Fix interface addition\n\nWPA supplicant as a network manager monitors interface events and\nregisters to the Wi-Fi NM module, so, adding a check for NM type before\nregistering the interface is wrong. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nreturn|return;\nblock|}\nif|if\ncondition|(\nname|wifi_nm_get_type_iface\nargument_list|(\nname|iface\nargument_list|)\noperator|!=\noperator|(\nliteral|1\noperator|<<\nname|WIFI_TYPE_STA\noperator|)\ncondition|)\nblock|{\nreturn|return;\nblock|}\nif|if\ncondition|(\noperator|!\nname|net_if_is_admin_up\nargument_list|(\nname|iface\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|wifi_nm_get_type_iface\n-argument_list|(\n-name|iface\n-argument_list|)\n-operator|!=\n-operator|(\n-literal|1\n-operator|<<\n-name|WIFI_TYPE_STA\n-operator|)\n-condition|)\n-block|{\n-return|return;\n-block|}\n-if|if\n-condition|(\nThe issue was with: modules: hostap: Fix interface addition\n\nWPA supplicant as a network manager monitors interface events and\nregisters to the Wi-Fi NM module, so, adding a check for NM type before\nregistering the interface is wrong."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: TBS: Remove BT_TBS_TECHNOLOGY_IP\n\nBT_TBS_TECHNOLOGY_IP is not a valid technology value\nfor TBS since it's not defined by the spec. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|BT_TBS_TECHNOLOGY_WCDMA\nvalue|0x09\nend_define\n\nbegin_define\nDECL|macro|BT_TBS_TECHNOLOGY_IP\ndefine|#\ndirective|define\nname|BT_TBS_TECHNOLOGY_IP\nvalue|0x0a\nend_define\n\nbegin_comment\ncomment|/**  * @brief The GTBS index denotes whenever a callback is from a  * Generic Telephone Bearer Service (GTBS) instance, or  * whenever the client should perform on action on the GTBS instance of the  * server, rather than any of the specific Telephone Bearer Service instances.  */\nend_comment\n\nbegin_define\nargument_list|<\nname|BT_TBS_TECHNOLOGY_3G\noperator|||\nname|new_technology\nargument_list|>\nname|BT_TBS_TECHNOLOGY_IP\ncondition|)\nblock|{\nreturn|return\noperator|-\nname|EINVAL\nname|BT_TBS_TECHNOLOGY_WCDMA\ncase|:\nreturn|return\nliteral|\"WCDMA\"\nreturn|;\ncase|case\nname|BT_TBS_TECHNOLOGY_IP\ncase|:\nreturn|return\nliteral|\"IP\"\nreturn|;\ndefault|default:\nreturn|return\nliteral|\"unknown technology\"\nreturn|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_define\n-DECL|macro|BT_TBS_TECHNOLOGY_IP\n-define|#\n-directive|define\n-name|BT_TBS_TECHNOLOGY_IP\n-value|0x0a\n-end_define\n-\n-name|BT_TBS_TECHNOLOGY_IP\n+name|BT_TBS_TECHNOLOGY_WCDMA\n-case|case\n-name|BT_TBS_TECHNOLOGY_IP\n-case|:\n-return|return\n-literal|\"IP\"\n-return|;\nThe issue was with: Bluetooth: TBS: Remove BT_TBS_TECHNOLOGY_IP\n\nBT_TBS_TECHNOLOGY_IP is not a valid technology value\nfor TBS since it's not defined by the spec."
},{
  "instruction": "There is an issue in the following code. It relates to sensor: lis2dux12: fix: CID 363712: Initialize mode-fs\n\nFollowing the same pattern used in `lis2dux12_sample_fetch_accel`. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|lis2dux12_xl_data_t\nname|xldata\ndecl_stmt|;\nname|lis2dux12_md_t\nname|mode\ndecl_stmt|;\nname|int\nname|ret\ndecl_stmt|;\nif|if",
  "result": "I corrected the issue in the code by changing the following tokens:\n+init|=\n+block|{\n+operator|.\n+name|fs\n+operator|=\n+name|cfg\n+operator|->\n+name|range\n+block|}\nThe issue was with: sensor: lis2dux12: fix: CID 363712: Initialize mode-fs\n\nFollowing the same pattern used in `lis2dux12_sample_fetch_accel`."
},{
  "instruction": "There is an issue in the following code. It relates to llext: harmonize error codes\n\nThis patch changes the error codes returned by the ELF subsystem to be\nmore consistent with the standard error descriptions. In particular:\n\n- issues with the ELF file are now reported as -ENOEXEC;\n- valid but unsupported edge cases are reported as -ENOTSUP;\n- failures in searching for an entry are reported as -ENOENT. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|NULL\ncondition|)\nblock|{\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}\nname|fn\nargument_list|()\nexpr_stmt|;\nname|load_bias\nparameter_list|)\nblock|{\nreturn|return\noperator|-\nname|EOPNOTSUPP\nreturn|;\nblock|}\nend_function\n\nbegin_function\nliteral|\"Invalid ELF, magic does not match\"\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}\nswitch|switch\ncondition|(\nname|ldr\nname|e_type\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}\ncomment|/* \t * Read all ELF section headers and initialize maps.  Buffers allocated \t * below are freed when leaving do_llext_load(), so don't count them in \t * alloc_size. \t */\nif|if\ncondition|(\nname|e_shentsize\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}\nname|ldr\noperator|->\nname|sect_cnt\nliteral|\"Some sections are missing or present multiple times!\"\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|ENOENT\nreturn|;\nblock|}\nreturn|return\nliteral|0\nreturn|;\nliteral|\"Multiple SHT_NOBITS sections are not supported\"\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|ENOEXEC\nreturn|;\nblock|}\nif|if\ncondition|(\nname|ldr\nname|sect\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|EOPNOTSUPP\nreturn|;\nblock|}\nblock|}\nif|if\ncondition|(\nindex|]\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}\nname|shell_print\nargument_list|(\nname|sh\nindex|]\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}\nname|llext_unload\nargument_list|(\noperator|&\nindex|]\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}\nname|llext_call_fn\nargument_list|(\nname|ext",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|EINVAL\n+name|ENOENT\n-name|EOPNOTSUPP\n+name|ENOTSUP\n-name|EINVAL\n+name|ENOEXEC\n-name|EINVAL\n+name|ENOEXEC\n-name|EINVAL\n+name|ENOEXEC\n-name|ENOENT\n+name|ENOEXEC\n-name|ENOEXEC\n+name|ENOTSUP\n-name|EOPNOTSUPP\n+name|ENOTSUP\n-name|EINVAL\n+name|ENOENT\n-name|EINVAL\n+name|ENOENT\n-name|EINVAL\n+name|ENOENT\nThe issue was with: llext: harmonize error codes\n\nThis patch changes the error codes returned by the ELF subsystem to be\nmore consistent with the standard error descriptions. In particular:\n\n- issues with the ELF file are now reported as -ENOEXEC;\n- valid but unsupported edge cases are reported as -ENOTSUP;\n- failures in searching for an entry are reported as -ENOENT."
},{
  "instruction": "There is an issue in the following code. It relates to llext: fix table count check\n\nllext_load() included a check to ensure that the ELF file contains all\nthe necessary tables, but it was not functional. Add the missing check\nand rename the variable to avoid confusion with the total section count. Please fix this issue.",
  "input": "Faulty tokenized code:\nmodifier|*\nname|ldr\nparameter_list|)\nblock|{\nname|int\nname|sect_cnt\ndecl_stmt|,\nname|i\ndecl_stmt|;\nname|memset\nargument_list|(\ncontrol|(\nname|i\noperator|=\nliteral|0\noperator|,\nname|sect_cnt\noperator|=\nliteral|0\ninit|;\nname|i\noperator|<\nname|ldr\noperator|->\nname|sect_cnt\ncondition|;\noperator|++\nname|i\ncontrol|)\nblock|{\noperator|.\nname|mem_idx\noperator|=\nname|LLEXT_MEM_SYMTAB\nexpr_stmt|;\nname|sect_cnt\noperator|++\nexpr_stmt|;\nbreak|break;\ncase|case\nname|SHT_STRTAB\nname|mem_idx\noperator|=\nname|LLEXT_MEM_STRTAB\nexpr_stmt|;\nblock|}\nname|sect_cnt\noperator|++\nexpr_stmt|;\nbreak|break;\ndefault|default:\nbreak|break;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|sect_cnt\n+name|table_cnt\n-name|sect_cnt\n+name|table_cnt\n+operator|&&\n+name|table_cnt\n+operator|<\n+literal|3\n-name|sect_cnt\n+name|table_cnt\n-name|sect_cnt\n+name|table_cnt\nThe issue was with: llext: fix table count check\n\nllext_load() included a check to ensure that the ELF file contains all\nthe necessary tables, but it was not functional. Add the missing check\nand rename the variable to avoid confusion with the total section count."
},{
  "instruction": "There is an issue in the following code. It relates to tests: kernel: timer: timer_behavior: Tweak expected std deviation\n\nIf frequency of the system clock is lower then deviation may exceed\ndefault value (10us). Instead of adjusting the default value, test is\nrounding up expected standard deviation to a single clock cycle. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|-\nname|expected_time_us\noperator|-\nname|expected_time_drift_us\ndecl_stmt|;\nname|TC_PRINT\nargument_list|(\nliteral|\"timer clock rate %d, kernel tick rate %d\\n\"\nargument_list|,\nname|sys_clock_hw_cycles_per_sec\nliteral|\", \\\"sys_clock_hw_cycles_per_sec\\\":%d\"\nliteral|\", \\\"CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC\\\":%d\"\nliteral|\", \\\"CONFIG_SYS_CLOCK_TICKS_PER_SEC\\\":%d\"\nliteral|\", \\\"CONFIG_TIMER_TEST_PERIOD\\\":%d\"\nliteral|\", \\\"CONFIG_TIMER_TEST_SAMPLES\\\":%d\"\nliteral|\", \\\"CONFIG_TIMER_TEST_MAX_STDDEV\\\":%d\"\nliteral|\"}\\n\"\nargument_list|,\nname|mechanism\nargument_list|,\nname|CONFIG_TIMER_TEST_SAMPLES\nargument_list|,\nname|CONFIG_TIMER_TEST_PERIOD\nargument_list|,\nname|CONFIG_TIMER_TEST_SAMPLES\nargument_list|,\nname|CONFIG_TIMER_TEST_MAX_STDDEV\nargument_list|)\nexpr_stmt|;\ncomment|/* Validate the maximum/minimum timer period is off by no more than 10% */\nname|double\nname|test_period\nname|stddev_us\noperator|<\noperator|(\nname|double\noperator|)\nname|CONFIG_TIMER_TEST_MAX_STDDEV\nargument_list|,\nliteral|\"Standard deviation (in microseconds) outside expected bound\"\nargument_list|)\nexpr_stmt|;\ncomment|/* Validate the timer drift (accuracy over time) is within a configurable bound */",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* If max stddev is lower than a single clock cycle then round it up. */\n+name|uint32_t\n+name|max_stddev\n+init|=\n+name|MAX\n+argument_list|(\n+name|k_cyc_to_us_ceil32\n+argument_list|(\n+literal|1\n+argument_list|)\n+argument_list|,\n+name|CONFIG_TIMER_TEST_MAX_STDDEV\n+argument_list|)\n+decl_stmt|;\n-literal|\", \\\"CONFIG_TIMER_TEST_MAX_STDDEV\\\":%d\"\n+literal|\", \\\"MAX STD DEV\\\":%d\"\n-name|CONFIG_TIMER_TEST_MAX_STDDEV\n+name|max_stddev\n-name|CONFIG_TIMER_TEST_MAX_STDDEV\n+name|max_stddev\nThe issue was with: tests: kernel: timer: timer_behavior: Tweak expected std deviation\n\nIf frequency of the system clock is lower then deviation may exceed\ndefault value (10us). Instead of adjusting the default value, test is\nrounding up expected standard deviation to a single clock cycle."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: can: loopback: set TX thread name\n\nSet TX thread name to aid in debugging. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|return\noperator|-\nliteral|1\nreturn|;\nblock|}\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|k_thread_name_set\n+argument_list|(\n+name|tx_tid\n+argument_list|,\n+name|dev\n+operator|->\n+name|name\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: can: loopback: set TX thread name\n\nSet TX thread name to aid in debugging."
},{
  "instruction": "There is an issue in the following code. It relates to logging: Fix runtime filtering when frontend and userspace is used\n\nWhen userspace is used and frontend was used for logging then runtime\nfiltering was failing because in user context filtering data was\naccessed and filtering data is in the kernel space. Fixing that and\nadding runtime filtering to the pre frontend function which is\nalready executed in the kernel space and filter data can be\naccessed. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|,\nmodifier|...\nparameter_list|)\nvalue|do { \\ \tif (!Z_LOG_CONST_LEVEL_CHECK(_level)) { \\ \t\tbreak; \\ \t} \\ \tif (IS_ENABLED(CONFIG_LOG_MODE_MINIMAL)) { \\ \t\tZ_LOG_TO_PRINTK(_level, __VA_ARGS__); \\ \t\tbreak; \\ \t} \\\ncomment|/* For instance logging check instance specific static level */\nvalue|\\ \tif (_inst != 0&& !IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING)) { \\ \t\tif (_level> ((struct log_source_const_data *)_source)->level) { \\ \t\t\tbreak; \\ \t\t} \\ \t} \\ \t\\ \tbool is_user_context = k_is_user_context(); \\ \tif (!IS_ENABLED(CONFIG_LOG_FRONTEND)&& IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING)&& \\ \t    !is_user_context&& _level> Z_LOG_RUNTIME_FILTER((_dsource)->filters)) { \\ \t\tbreak; \\ \t} \\ \tint _mode; \\ \tvoid *_src = IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) ? \\ \t\t(void *)(_dsource) : (void *)(_source); \\ \tbool string_ok; \\ \tLOG_POINTERS_VALIDATE(string_ok, __VA_ARGS__); \\ \tif (!string_ok) { \\ \t\tLOG_STRING_WARNING(_mode, _src, __VA_ARGS__); \\ \t\tbreak; \\ \t} \\ \tZ_LOG_MSG_CREATE(UTIL_NOT(IS_ENABLED(CONFIG_USERSPACE)), _mode, \\ \t\t\t\t  Z_LOG_LOCAL_DOMAIN_ID, _src, _level, NULL,\\ \t\t\t  0, __VA_ARGS__); \\ \t(void)_mode; \\ \tif (false) { \\\ncomment|/* Arguments checker present but never evaluated.*/\nvalue|\\\ncomment|/* Placed here to ensure that __VA_ARGS__ are*/\nvalue|\\\ncomment|/* evaluated once when log is enabled.*/\nparameter_list|,\nmodifier|...\nparameter_list|)\nvalue|do { \\ \tconst char *_str = GET_ARG_N(1, __VA_ARGS__); \\ \tif (!Z_LOG_CONST_LEVEL_CHECK(_level)) {\t\\ \t\tbreak; \\ \t} \\\ncomment|/* For instance logging check instance specific static level */\nvalue|\\ \tif (_inst&& !IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING)) { \\ \t\tif (_level> ((struct log_source_const_data *)_source)->level) { \\ \t\t\tbreak; \\ \t\t} \\ \t} \\ \tbool is_user_context = k_is_user_context(); \\ \tuint32_t filters = IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) ? \\ \t\t\t\t\t\t(_dsource)->filters : 0;\\ \t\\ \tif (IS_ENABLED(CONFIG_LOG_MODE_MINIMAL)) { \\ \t\tZ_LOG_TO_PRINTK(_level, \"%s\", _str); \\ \t\tz_log_minimal_hexdump_print((_level), \\ \t\t\t\t\t    (const char *)(_data), (_len));\\ \t\tbreak; \\ \t} \\ \tif (!IS_ENABLED(CONFIG_LOG_FRONTEND)&& IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING)&& \\ \t    !is_user_context&& (_level)> Z_LOG_RUNTIME_FILTER(filters)) { \\ \t\tbreak; \\ \t} \\ \tint mode; \\ \tvoid *_src = IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) ? \\ \t\t(void *)(_dsource) : (void *)(_source); \\ \tZ_LOG_MSG_CREATE(UTIL_NOT(IS_ENABLED(CONFIG_USERSPACE)), mode, \\ \t\t\t\t  Z_LOG_LOCAL_DOMAIN_ID, _src, _level, \\ \t\t\t  _data, _len, \\ \t\t\tCOND_CODE_0(NUM_VA_ARGS_LESS_1(_, ##__VA_ARGS__), \\ \t\t\t\t(), \\ \t\t\t  (COND_CODE_0(NUM_VA_ARGS_LESS_1(__VA_ARGS__), \\ \t\t\t\t  (\"%s\", __VA_ARGS__), (__VA_ARGS__)))));\\ } while (false)\nDECL|macro|Z_LOG_HEXDUMP (_level,_data,_length,...)\ndefine|#\ndirective|define\nname|Z_LOG_HEXDUMP\nparameter_list|(\nblock|{\nreturn|return\nname|true\nreturn|;\nblock|}\ncomment|/* If only frontend is used and log got here it means that it was accepted. */\nif|if\ncondition|(\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_LOG_FRONTEND_ONLY\nargument_list|)\ncondition|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|\\ \tif (_inst != 0&& !IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING)) { \\ \t\tif (_level> ((struct log_source_const_data *)_source)->level) { \\ \t\t\tbreak; \\ \t\t} \\ \t} \\ \t\\ \tbool is_user_context = k_is_user_context(); \\ \tif (!IS_ENABLED(CONFIG_LOG_FRONTEND)&& IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING)&& \\ \t    !is_user_context&& _level> Z_LOG_RUNTIME_FILTER((_dsource)->filters)) { \\ \t\tbreak; \\ \t} \\ \tint _mode; \\ \tvoid *_src = IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) ? \\ \t\t(void *)(_dsource) : (void *)(_source); \\ \tbool string_ok; \\ \tLOG_POINTERS_VALIDATE(string_ok, __VA_ARGS__); \\ \tif (!string_ok) { \\ \t\tLOG_STRING_WARNING(_mode, _src, __VA_ARGS__); \\ \t\tbreak; \\ \t} \\ \tZ_LOG_MSG_CREATE(UTIL_NOT(IS_ENABLED(CONFIG_USERSPACE)), _mode, \\ \t\t\t\t  Z_LOG_LOCAL_DOMAIN_ID, _src, _level, NULL,\\ \t\t\t  0, __VA_ARGS__); \\ \t(void)_mode; \\ \tif (false) { \\\n+value|\\ \tif (_inst != 0&& !IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING)) { \\ \t\tif (_level> ((struct log_source_const_data *)_source)->level) { \\ \t\t\tbreak; \\ \t\t} \\ \t} \\ \t\\ \tbool is_user_context = k_is_user_context(); \\ \tif (IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING)&& \\ \t    !is_user_context&& _level> Z_LOG_RUNTIME_FILTER((_dsource)->filters)) { \\ \t\tbreak; \\ \t} \\ \tint _mode; \\ \tvoid *_src = IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) ? \\ \t\t(void *)(_dsource) : (void *)(_source); \\ \tbool string_ok; \\ \tLOG_POINTERS_VALIDATE(string_ok, __VA_ARGS__); \\ \tif (!string_ok) { \\ \t\tLOG_STRING_WARNING(_mode, _src, __VA_ARGS__); \\ \t\tbreak; \\ \t} \\ \tZ_LOG_MSG_CREATE(UTIL_NOT(IS_ENABLED(CONFIG_USERSPACE)), _mode, \\ \t\t\t\t  Z_LOG_LOCAL_DOMAIN_ID, _src, _level, NULL,\\ \t\t\t  0, __VA_ARGS__); \\ \t(void)_mode; \\ \tif (false) { \\\n-value|\\ \tif (_inst&& !IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING)) { \\ \t\tif (_level> ((struct log_source_const_data *)_source)->level) { \\ \t\t\tbreak; \\ \t\t} \\ \t} \\ \tbool is_user_context = k_is_user_context(); \\ \tuint32_t filters = IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) ? \\ \t\t\t\t\t\t(_dsource)->filters : 0;\\ \t\\ \tif (IS_ENABLED(CONFIG_LOG_MODE_MINIMAL)) { \\ \t\tZ_LOG_TO_PRINTK(_level, \"%s\", _str); \\ \t\tz_log_minimal_hexdump_print((_level), \\ \t\t\t\t\t    (const char *)(_data), (_len));\\ \t\tbreak; \\ \t} \\ \tif (!IS_ENABLED(CONFIG_LOG_FRONTEND)&& IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING)&& \\ \t    !is_user_context&& (_level)> Z_LOG_RUNTIME_FILTER(filters)) { \\ \t\tbreak; \\ \t} \\ \tint mode; \\ \tvoid *_src = IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) ? \\ \t\t(void *)(_dsource) : (void *)(_source); \\ \tZ_LOG_MSG_CREATE(UTIL_NOT(IS_ENABLED(CONFIG_USERSPACE)), mode, \\ \t\t\t\t  Z_LOG_LOCAL_DOMAIN_ID, _src, _level, \\ \t\t\t  _data, _len, \\ \t\t\tCOND_CODE_0(NUM_VA_ARGS_LESS_1(_, ##__VA_ARGS__), \\ \t\t\t\t(), \\ \t\t\t  (COND_CODE_0(NUM_VA_ARGS_LESS_1(__VA_ARGS__), \\ \t\t\t\t  (\"%s\", __VA_ARGS__), (__VA_ARGS__)))));\\ } while (false)\n+value|\\ \tif (_inst&& !IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING)) { \\ \t\tif (_level> ((struct log_source_const_data *)_source)->level) { \\ \t\t\tbreak; \\ \t\t} \\ \t} \\ \tbool is_user_context = k_is_user_context(); \\ \tuint32_t filters = IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) ? \\ \t\t\t\t\t\t(_dsource)->filters : 0;\\ \t\\ \tif (IS_ENABLED(CONFIG_LOG_MODE_MINIMAL)) { \\ \t\tZ_LOG_TO_PRINTK(_level, \"%s\", _str); \\ \t\tz_log_minimal_hexdump_print((_level), \\ \t\t\t\t\t    (const char *)(_data), (_len));\\ \t\tbreak; \\ \t} \\ \tif (IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING)&& \\ \t    !is_user_context&& (_level)> Z_LOG_RUNTIME_FILTER(filters)) { \\ \t\tbreak; \\ \t} \\ \tint mode; \\ \tvoid *_src = IS_ENABLED(CONFIG_LOG_RUNTIME_FILTERING) ? \\ \t\t(void *)(_dsource) : (void *)(_source); \\ \tZ_LOG_MSG_CREATE(UTIL_NOT(IS_ENABLED(CONFIG_USERSPACE)), mode, \\ \t\t\t\t  Z_LOG_LOCAL_DOMAIN_ID, _src, _level, \\ \t\t\t  _data, _len, \\ \t\t\tCOND_CODE_0(NUM_VA_ARGS_LESS_1(_, ##__VA_ARGS__), \\ \t\t\t\t(), \\ \t\t\t  (COND_CODE_0(NUM_VA_ARGS_LESS_1(__VA_ARGS__), \\ \t\t\t\t  (\"%s\", __VA_ARGS__), (__VA_ARGS__)))));\\ } while (false)\n-comment|/* If only frontend is used and log got here it means that it was accepted. */\n+comment|/* If only frontend is used and log got here it means that it was accepted \t * unless userspace is enabled then runtime filtering is done here. \t */\n+operator|!\n+name|IS_ENABLED\n+argument_list|(\n+name|CONFIG_USERSPACE\n+argument_list|)\n+operator|&&\nThe issue was with: logging: Fix runtime filtering when frontend and userspace is used\n\nWhen userspace is used and frontend was used for logging then runtime\nfiltering was failing because in user context filtering data was\naccessed and filtering data is in the kernel space. Fixing that and\nadding runtime filtering to the pre frontend function which is\nalready executed in the kernel space and filter data can be\naccessed."
},{
  "instruction": "There is an issue in the following code. It relates to llext: add explicit cast to fix Coverity CID: 392507\n\nFrom https://mails.dpdk.org/archives/dev/2021-December/231212.html:\n\n    Downcasting a void* to struct aesni_gcm_session* caused the session\n    data to be treated as tainted. Removing the void* temporary variable\n    and adding a cast avoids this issue.\n\nTry the same approach here to prevent the ldr->sect_hdrs pointer from\nbeing treated as tainted.\n\nMay fix #74817. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nname|ldr\noperator|->\nname|sect_hdrs\noperator|=\nname|llext_peek\nargument_list|(\nname|ldr\nargument_list|,\nname|ldr",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+name|elf_shdr_t\n+operator|*\n+operator|)\nThe issue was with: llext: add explicit cast to fix Coverity CID: 392507\n\nFrom https://mails.dpdk.org/archives/dev/2021-December/231212.html:\n\n    Downcasting a void* to struct aesni_gcm_session* caused the session\n    data to be treated as tainted. Removing the void* temporary variable\n    and adding a cast avoids this issue.\n\nTry the same approach here to prevent the ldr->sect_hdrs pointer from\nbeing treated as tainted.\n\nMay fix #74817."
},{
  "instruction": "There is an issue in the following code. It relates to sensor: lps22hh: Prevent overwriting values that weren't overwritten\n\nPreviously both temperature and pressure were updated regardless of\nwhich one was requested.\n\nFixes CID: 392519, GH: 74779.\nFixes CID: 392497, GH: 74777. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|return\noperator|-\nname|ENOTSUP\nreturn|;\nblock|}\nname|data\noperator|->\nname|sample_press\noperator|=\nname|raw_press\nexpr_stmt|;\nname|data\noperator|->\nname|sample_temp\noperator|=\nname|raw_temp\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/** Prevent overwriting values that weren't fetched */\n+if|if\n+condition|(\n+name|chan\n+operator|==\n+name|SENSOR_CHAN_PRESS\n+operator|||\n+name|chan\n+operator|==\n+name|SENSOR_CHAN_ALL\n+condition|)\n+block|{\n+block|}\n+if|if\n+condition|(\n+name|chan\n+operator|==\n+name|SENSOR_CHAN_AMBIENT_TEMP\n+operator|||\n+name|chan\n+operator|==\n+name|SENSOR_CHAN_ALL\n+condition|)\n+block|{\n+block|}\nThe issue was with: sensor: lps22hh: Prevent overwriting values that weren't overwritten\n\nPreviously both temperature and pressure were updated regardless of\nwhich one was requested.\n\nFixes CID: 392519, GH: 74779.\nFixes CID: 392497, GH: 74777."
},{
  "instruction": "There is an issue in the following code. It relates to net: mgmt: Fix build error when event direct enabled without event info\n\nIf CONFIG_NET_MGMT_EVENT_DIRECT is enabled and CONFIG_NET_MGMT_EVENT_INFO\ndisabled it does not build because mgmt_push_event writes to non existing\nstruct members Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|,\nname|size_t\nname|length\nparameter_list|)\nblock|{\nspecifier|const\nname|struct\nname|mgmt_event_entry\nname|mgmt_event\ninit|=\nblock|{\noperator|.\nname|info\noperator|=\nname|info\nblock|,\noperator|.\nname|info_length\noperator|=\nname|length\nblock|,\noperator|.\nname|event\noperator|=\nname|event\nblock|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n+ifndef|#\n+directive|ifndef\n+name|CONFIG_NET_MGMT_EVENT_INFO\n+name|ARG_UNUSED\n+argument_list|(\n+name|info\n+argument_list|)\n+expr_stmt|;\n+name|ARG_UNUSED\n+argument_list|(\n+name|length\n+argument_list|)\n+expr_stmt|;\n+endif|#\n+directive|endif\n+comment|/* CONFIG_NET_MGMT_EVENT_INFO */\n+if|#\n+directive|if\n+name|defined\n+argument_list|(\n+name|CONFIG_NET_MGMT_EVENT_INFO\n+argument_list|)\n+endif|#\n+directive|endif\n+comment|/* CONFIG_NET_MGMT_EVENT_INFO */\nThe issue was with: net: mgmt: Fix build error when event direct enabled without event info\n\nIf CONFIG_NET_MGMT_EVENT_DIRECT is enabled and CONFIG_NET_MGMT_EVENT_INFO\ndisabled it does not build because mgmt_push_event writes to non existing\nstruct members"
},{
  "instruction": "There is an issue in the following code. It relates to net: mgmt: prevent event_work_handler from blocking\n\nFix system workqueue block caused by mgmt_event_work_handler\nwhen CONFIG_NET_MGMT_EVENT_SYSTEM_WORKQUEUE is enabled. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|event_msgq\nargument_list|,\noperator|&\nname|mgmt_event\nargument_list|,\nname|K_FOREVER\nargument_list|)\noperator|==\nliteral|0\ncondition|)\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|K_FOREVER\n+name|K_NO_WAIT\nThe issue was with: net: mgmt: prevent event_work_handler from blocking\n\nFix system workqueue block caused by mgmt_event_work_handler\nwhen CONFIG_NET_MGMT_EVENT_SYSTEM_WORKQUEUE is enabled."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: wsen_itds: fix device ID mismatch return value\n\nDuring initialization, zero is returned if an unexpected device ID is\nread because the returned variable is not written to after a previous\nnon-zero check. Return -EIO instead to indicate an error occurred.\n\nDetected with the following Coccinelle script:\n\n        @@\n        identifier I;\n        @@\n\n        *if (I) {\n             ...\n             return ...;\n         }\n\n         if (...) {\n             ... when != I\n                 when any\n        *    return I;\n         } Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|rval\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|ret\nreturn|;\nblock|}\nname|ret\noperator|=\nname|i2c_reg_update_byte_dt",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|ret\n+operator|-\n+name|EIO\nThe issue was with: drivers: sensor: wsen_itds: fix device ID mismatch return value\n\nDuring initialization, zero is returned if an unexpected device ID is\nread because the returned variable is not written to after a previous\nnon-zero check. Return -EIO instead to indicate an error occurred.\n\nDetected with the following Coccinelle script:\n\n        @@\n        identifier I;\n        @@\n\n        *if (I) {\n             ...\n             return ...;\n         }\n\n         if (...) {\n             ... when != I\n                 when any\n        *    return I;\n         }"
},{
  "instruction": "There is an issue in the following code. It relates to tests: logging: fix build error\n\nCurrently we get the build error when building\n'tests/subsys/logging/log_backend_uart':\n\nerror: static_assert expression is not an integral constant expression\nBUILD_ASSERT(strlen(TEST_DATA) < SAMPLE_DATA_SIZE);\n~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIt can be easily workarounded by using sizeof instead of strlen\nto calculate string size. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|TEST_DATA\nvalue|\"0123456789ABCDEF\"\nend_define\n\nbegin_expr_stmt\nname|BUILD_ASSERT\nargument_list|(\nname|strlen\nargument_list|(\nname|TEST_DATA\nargument_list|)\noperator|<\nname|SAMPLE_DATA_SIZE\nargument_list|)\nexpr_stmt|;\nend_expr_stmt",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_comment\n+comment|/* Assert that size of the test string (without '\\0') fits in the SAMPLE_DATA_SIZE */\n+end_comment\n+\n-name|strlen\n+operator|(\n+sizeof|sizeof\n+operator|-\n+literal|1\n+operator|)\nThe issue was with: tests: logging: fix build error\n\nCurrently we get the build error when building\n'tests/subsys/logging/log_backend_uart':\n\nerror: static_assert expression is not an integral constant expression\nBUILD_ASSERT(strlen(TEST_DATA) < SAMPLE_DATA_SIZE);\n~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIt can be easily workarounded by using sizeof instead of strlen\nto calculate string size."
},{
  "instruction": "There is an issue in the following code. It relates to test: logging: dictionary: fix build error\n\nIn `tests/subsys/logging/dictionary` we don't include stdio.h\nheader but use standard stream definitions (i.e. `stdout`)\nwhich cause build issues (if the minimal libc is used).\n\nFix that. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<string.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/sys/printk.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<stdio.h>\n+end_include\n+\nThe issue was with: test: logging: dictionary: fix build error\n\nIn `tests/subsys/logging/dictionary` we don't include stdio.h\nheader but use standard stream definitions (i.e. `stdout`)\nwhich cause build issues (if the minimal libc is used).\n\nFix that."
},{
  "instruction": "There is an issue in the following code. It relates to wifi: esp32: fix memory leak\n\nIn case where the system is overloaded, net stack buffer\ncould fail to allocate next packet. That scenario requires\nwifi internal Wi-Fi driver to free current rx buffer. This is\ncurrently not being called. This fixes it by making sure\nesp_wifi_internal_free_rx_buffer() is called in all scenarios.\n\nFixes #63043 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|esp32_wifi_iface\noperator|==\nname|NULL\ncondition|)\nblock|{\nname|LOG_ERR\nargument_list|(\nliteral|\"network interface unavailable\"\nargument_list|)\nexpr_stmt|;\nname|pkt\ncondition|)\nblock|{\nname|LOG_ERR\nargument_list|(\nliteral|\"Failed to get net buffer\"\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|EIO\nliteral|0\ncondition|)\nblock|{\nname|LOG_ERR\nargument_list|(\nliteral|\"Failed to write pkt\"\nargument_list|)\nexpr_stmt|;\ngoto|goto\nname|pkt_unref\ngoto|;\nreturn|return\nliteral|0\nreturn|;\nname|pkt_unref\nlabel|:\nname|net_pkt_unref\nargument_list|(\nname|pkt\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|esp_wifi_internal_free_rx_buffer\n+argument_list|(\n+name|eb\n+argument_list|)\n+expr_stmt|;\n-literal|\"Failed to get net buffer\"\n+literal|\"Failed to allocate net buffer\"\n+argument_list|)\n+expr_stmt|;\n+name|esp_wifi_internal_free_rx_buffer\n+argument_list|(\n+name|eb\n-literal|\"Failed to write pkt\"\n+literal|\"Failed to write to net buffer\"\n+name|esp_wifi_internal_free_rx_buffer\n+argument_list|(\n+name|eb\n+argument_list|)\n+expr_stmt|;\nThe issue was with: wifi: esp32: fix memory leak\n\nIn case where the system is overloaded, net stack buffer\ncould fail to allocate next packet. That scenario requires\nwifi internal Wi-Fi driver to free current rx buffer. This is\ncurrently not being called. This fixes it by making sure\nesp_wifi_internal_free_rx_buffer() is called in all scenarios.\n\nFixes #63043"
},{
  "instruction": "There is an issue in the following code. It relates to Driver: i2c_ll_stm32_v2: Remove log msg on boot\n\nConverts the `<inf> i2c_ll_stm32_v2: I2C TIMING` message\ndisplayed by the driver to a LOG_DBG. Also makes an actual\nerror message a LOG_ERR instead of a LOG_DBG. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|presc\noperator|>=\nliteral|16U\ncondition|)\nblock|{\nname|LOG_DBG\nargument_list|(\nliteral|\"I2C:failed to find prescaler value\"\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}\nname|LOG_INF\nargument_list|(\nliteral|\"I2C TIMING = 0x%x\"\nargument_list|,\nname|timing\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|LOG_DBG\n+name|LOG_ERR\n-name|LOG_INF\n+name|LOG_DBG\nThe issue was with: Driver: i2c_ll_stm32_v2: Remove log msg on boot\n\nConverts the `<inf> i2c_ll_stm32_v2: I2C TIMING` message\ndisplayed by the driver to a LOG_DBG. Also makes an actual\nerror message a LOG_ERR instead of a LOG_DBG."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: eth: esp32: fix build to enable statistics\n\nWhen CONFIG_NET_STATISTICS=y is enabled, build fails\ndue to wrong interface pointer.\n\nFixes #75515 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|NULL\ncondition|)\nblock|{\nname|eth_stats_update_errors_rx\nargument_list|(\nname|ctx\noperator|->\nname|iface\nargument_list|)\nexpr_stmt|;\nname|LOG_ERR\nliteral|\"Unable to write frame into the pkt\"\nargument_list|)\nexpr_stmt|;\nname|eth_stats_update_errors_rx\nargument_list|(\nname|ctx\noperator|->\nname|iface\nargument_list|)\nexpr_stmt|;\nname|net_pkt_unref",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|ctx\n+name|dev_data\n-name|ctx\n+name|dev_data\nThe issue was with: drivers: eth: esp32: fix build to enable statistics\n\nWhen CONFIG_NET_STATISTICS=y is enabled, build fails\ndue to wrong interface pointer.\n\nFixes #75515"
},{
  "instruction": "There is an issue in the following code. It relates to fs: nvs: Add more strict checks to determine if an ATE is valid\n\nMake sure that the ATE metadata does not overflow the sector size.\nTake into account the data length and also the mandatory reserved ATEs\nin each sector. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|;\nblock|}\nend_function\n\nbegin_comment\ncomment|/* nvs_ate_valid validates an ate:  *     return 1 if crc8 and offset valid,  *            0 otherwise  */\nend_comment\n\nbegin_function\nDECL|function|nvs_ate_valid (struct nvs_fs * fs,const struct nvs_ate * entry)\nspecifier|static\nparameter_list|)\nblock|{\nname|size_t\nname|ate_size\ndecl_stmt|;\nname|ate_size\noperator|=\nname|nvs_al_size\nargument_list|(\nname|fs\nexpr|struct\nname|nvs_ate\nargument_list|)\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\noperator|(\nname|nvs_ate_crc8_check\nargument_list|(\nname|entry\nargument_list|)\noperator|)\noperator|||\noperator|(\nname|entry\noperator|->\nname|offset\noperator|>=\noperator|(\nname|fs\noperator|->\nname|sector_size",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* nvs_ate_valid validates an ate:  *     return 1 if crc8 and offset valid,  *            0 otherwise  */\n+comment|/* nvs_ate_valid validates an ate:  *     return 1 if crc8, offset and length are valid,  *            0 otherwise  */\n+name|uint32_t\n+name|position\n+decl_stmt|;\n+name|position\n+operator|=\n+name|entry\n+operator|->\n+name|offset\n+operator|+\n+name|entry\n+operator|->\n+name|len\n+expr_stmt|;\n-name|entry\n-operator|->\n-name|offset\n+name|position\nThe issue was with: fs: nvs: Add more strict checks to determine if an ATE is valid\n\nMake sure that the ATE metadata does not overflow the sector size.\nTake into account the data length and also the mandatory reserved ATEs\nin each sector."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth samples: Broadcast code handling\n\nThe broadcast sink sample no longer treats the broadcast_code_received\nsemaphore as a boolean.\n\nFixes #75469 Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_struct\nDECL|struct|find_valid_bis_data\nstruct|struct\nname|find_valid_bis_data\nblock|{\nDECL|struct|__anon28807a050108\nstruct|struct\nblock|{\nDECL|member|index\nname|uint8_t\nname|index\nname|biginfo\noperator|->\nname|encryption\ncondition|)\nblock|{\ncomment|/* Use the semaphore as a boolean */\nname|k_sem_reset\nargument_list|(\noperator|&\nname|sem_broadcast_code_received\nargument_list|)\nexpr_stmt|;\nname|k_sem_give\nargument_list|(\noperator|&\nname|sem_broadcast_code_received\nargument_list|)\nname|broadcast_code\nargument_list|,\nname|BT_AUDIO_BROADCAST_CODE_SIZE\nargument_list|)\nexpr_stmt|;\ncomment|/* Use the semaphore as a boolean */\nname|k_sem_reset\nargument_list|(\noperator|&\nname|sem_broadcast_code_received\nargument_list|)\nexpr_stmt|;\nname|k_sem_give\nargument_list|(\noperator|&\nname|sem_broadcast_code_received\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon28807a050108\n+DECL|struct|__anon2c78a8250108\n-comment|/* Use the semaphore as a boolean */\n-name|k_sem_reset\n-argument_list|(\n-operator|&\n-name|sem_broadcast_code_received\n-argument_list|)\n-expr_stmt|;\n-comment|/* Use the semaphore as a boolean */\n-name|k_sem_reset\n-argument_list|(\n-operator|&\n-name|sem_broadcast_code_received\n-argument_list|)\n-expr_stmt|;\nThe issue was with: Bluetooth samples: Broadcast code handling\n\nThe broadcast sink sample no longer treats the broadcast_code_received\nsemaphore as a boolean.\n\nFixes #75469"
},{
  "instruction": "There is an issue in the following code. It relates to modules: lvgl: fix initialization macro syntax\n\nAdding a semicolon after the do-while loop in the LV_DEV_INIT()\nmacro also supports multiple instantiation. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|node_id\nparameter_list|,\nname|init_fn\nparameter_list|)\ndefine|\\\nvalue|do {                                                                                       \\ \t\tint ret = init_fn(DEVICE_DT_GET(node_id));                                         \\ \t\tif (ret) {                                                                         \\ \t\t\treturn ret;                                                                \\ \t\t}                                                                                  \\ \t} while (0)\nend_define\n\nbegin_function\nDECL|function|lvgl_init_input_devices (void)\nname|int",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|do {                                                                                       \\ \t\tint ret = init_fn(DEVICE_DT_GET(node_id));                                         \\ \t\tif (ret) {                                                                         \\ \t\t\treturn ret;                                                                \\ \t\t}                                                                                  \\ \t} while (0)\n+value|do {                                                                                       \\ \t\tint ret = init_fn(DEVICE_DT_GET(node_id));                                         \\ \t\tif (ret) {                                                                         \\ \t\t\treturn ret;                                                                \\ \t\t}                                                                                  \\ \t} while (0);\nThe issue was with: modules: lvgl: fix initialization macro syntax\n\nAdding a semicolon after the do-while loop in the LV_DEV_INIT()\nmacro also supports multiple instantiation."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: fix typo\n\nUtilize a code spell-checking tool to scan for and correct spelling errors\nin all files within the `kernel` directory. Please fix this issue.",
  "input": "Faulty tokenized code:\n\tprompt \"Preferred dynamic thread allocator\"\n\tdefault DYNAMIC_THREAD_PREFER_POOL\n\thelp\n\t  If both CONFIG_DYNAMIC_THREAD_ALLOC=y and\n\t  CONFIG_DYNAMIC_THREAD_POOL_SIZE > 0, then the user may\n\t  specify the order in which allocation is attmpted.\n\nconfig DYNAMIC_THREAD_PREFER_ALLOC\n\tbool \"Prefer heap-based allocation\"\n\tdepends on DYNAMIC_THREAD_ALLOC\n\thelp\n\t  a thread newly made ready for execution. This increases the\n\t  computation required at every scheduler operation by a value that is\n\t  O(N) in the number of CPUs, and in exchange reduces the number of\n\t  interrupts delivered. Which to choose is going to depend on\n\t  application behavior. If the architecture also supports directing\n\t  IPIs to specific CPUs then this has the potential to signficantly\n\t  reduce the number of IPIs (and consequently ISRs) processed by the\n\t  system as the number of CPUs increases. If not, the only benefit\n\t  would be to not issue any IPIs if the newly readied thread is of\n\t  lower priority than all the threads currently executing on other CPUs.\n\nname|k_thread_stack_t\nmodifier|*\nname|stack\nparameter_list|)\nblock|{\ncomment|/* The thread stack object must not be in initialized state. \t * \t * Thread stack objects are initialized when the thread is created \t * and de-initialized whent the thread is destroyed. Since we can't \t * free a stack that is in use, we have to check that the caller \t * has access to the object but that it is not in use anymore. \t */\nname|K_OOPS\nargument_list|(\nname|K_SYSCALL_OBJ_NEVER_INIT\nargument_list|(\nname|stack\nparameter_list|)\nfunction_decl|;\nend_function_decl\n\nbegin_comment\ncomment|/** @brief Halt thread cycle usage accounting.  *  * Halts the accumulation of thread cycle usage and adds the current  * total to the thread's counter.  Called on context switch.  *  * Note that this function is idempotent.  The core kernel code calls  * it at the end of interrupt handlers (because that is where we have  * a portable hook) where we are context switching, which will include  * any cycles spent in the ISR in the per-thread accounting.  But  * architecture code can also call it earlier out of interrupt entry  * to improve measurement fidelity.  *  * This function assumes local interrupts are masked (so that the  * current CPU pointer and current thread are safe to modify), but  * requires no other synchronizaton.  Architecture layers don't need  * to do anything more.  */\nend_comment\n\nbegin_function_decl\nname|void\nname|z_sched_usage_stop\nif|if\ncondition|(\nname|is_anon\ncondition|)\nblock|{\ncomment|/* Mapping from annoymous memory */\nname|VIRT_FOREACH\nargument_list|(\nargument|dst\nargument_list|,\nargument|size\noperator|!=\noperator|&\nname|_sched_spinlock\nargument_list|)\nexpr_stmt|;\ncomment|/* We do a \"lock swap\" prior to calling z_swap(), such that \t * the caller's lock gets released as desired.  But we ensure \t * that we hold the scheduler lock and leave local interrupts \t * masked until we reach the context swich.  z_swap() itself \t * has similar code; the duplication is because it's a legacy \t * API that doesn't expect to be called with scheduler lock \t * held. \t */\noperator|(\nname|void\noperator|)\nname|k_spin_lock\nargument_list|(\nargument_list|(\noperator|&\nname|timeout_lock\nargument_list|)\ndecl_stmt|;\ncomment|/* We release the lock around the callbacks below, so on SMP \t * systems someone might be already running the loop.  Don't \t * race (which will cause paralllel execution of \"sequential\" \t * timeouts and confuse apps), just increment the tick count \t * and return. \t */\nif|if\ncondition|(\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_SMP",
  "result": "I corrected the issue in the code by changing the following tokens:\n-\t  specify the order in which allocation is attmpted.\n+\t  specify the order in which allocation is attempted.\n-\t  IPIs to specific CPUs then this has the potential to signficantly\n+\t  IPIs to specific CPUs then this has the potential to significantly\n-comment|/* The thread stack object must not be in initialized state. \t * \t * Thread stack objects are initialized when the thread is created \t * and de-initialized whent the thread is destroyed. Since we can't \t * free a stack that is in use, we have to check that the caller \t * has access to the object but that it is not in use anymore. \t */\n+comment|/* The thread stack object must not be in initialized state. \t * \t * Thread stack objects are initialized when the thread is created \t * and de-initialized when the thread is destroyed. Since we can't \t * free a stack that is in use, we have to check that the caller \t * has access to the object but that it is not in use anymore. \t */\n-comment|/** @brief Halt thread cycle usage accounting.  *  * Halts the accumulation of thread cycle usage and adds the current  * total to the thread's counter.  Called on context switch.  *  * Note that this function is idempotent.  The core kernel code calls  * it at the end of interrupt handlers (because that is where we have  * a portable hook) where we are context switching, which will include  * any cycles spent in the ISR in the per-thread accounting.  But  * architecture code can also call it earlier out of interrupt entry  * to improve measurement fidelity.  *  * This function assumes local interrupts are masked (so that the  * current CPU pointer and current thread are safe to modify), but  * requires no other synchronizaton.  Architecture layers don't need  * to do anything more.  */\n+comment|/** @brief Halt thread cycle usage accounting.  *  * Halts the accumulation of thread cycle usage and adds the current  * total to the thread's counter.  Called on context switch.  *  * Note that this function is idempotent.  The core kernel code calls  * it at the end of interrupt handlers (because that is where we have  * a portable hook) where we are context switching, which will include  * any cycles spent in the ISR in the per-thread accounting.  But  * architecture code can also call it earlier out of interrupt entry  * to improve measurement fidelity.  *  * This function assumes local interrupts are masked (so that the  * current CPU pointer and current thread are safe to modify), but  * requires no other synchronization.  Architecture layers don't need  * to do anything more.  */\n-comment|/* Mapping from annoymous memory */\n+comment|/* Mapping from anonymous memory */\n-comment|/* We do a \"lock swap\" prior to calling z_swap(), such that \t * the caller's lock gets released as desired.  But we ensure \t * that we hold the scheduler lock and leave local interrupts \t * masked until we reach the context swich.  z_swap() itself \t * has similar code; the duplication is because it's a legacy \t * API that doesn't expect to be called with scheduler lock \t * held. \t */\n+comment|/* We do a \"lock swap\" prior to calling z_swap(), such that \t * the caller's lock gets released as desired.  But we ensure \t * that we hold the scheduler lock and leave local interrupts \t * masked until we reach the context switch.  z_swap() itself \t * has similar code; the duplication is because it's a legacy \t * API that doesn't expect to be called with scheduler lock \t * held. \t */\n-comment|/* We release the lock around the callbacks below, so on SMP \t * systems someone might be already running the loop.  Don't \t * race (which will cause paralllel execution of \"sequential\" \t * timeouts and confuse apps), just increment the tick count \t * and return. \t */\n+comment|/* We release the lock around the callbacks below, so on SMP \t * systems someone might be already running the loop.  Don't \t * race (which will cause parallel execution of \"sequential\" \t * timeouts and confuse apps), just increment the tick count \t * and return. \t */\nThe issue was with: kernel: fix typo\n\nUtilize a code spell-checking tool to scan for and correct spelling errors\nin all files within the `kernel` directory."
},{
  "instruction": "There is an issue in the following code. It relates to driver: spi: psoc6: fix build error in driver\n\nfix build error related to pinctrl. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<errno.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/drivers/spi.h>\nend_include\nname|PINCTRL_STATE_DEFAULT\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|ret\noperator|<\nliteral|0\ncondition|)\nblock|{\nreturn|return\nname|ret\nreturn|;\nblock|}\nname|Cy_SysClk_PeriphAssignDivider\nargument_list|(\nname|config",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/drivers/pinctrl.h>\n+end_include\n+\n-name|ret\n+name|err\n-name|ret\n+name|err\nThe issue was with: driver: spi: psoc6: fix build error in driver\n\nfix build error related to pinctrl."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: gpio: imx rt11xx: fix wrong gpio pull disable mask\n\nFixes: #75390\nA wrong bit mask (wrong: IOMUXC_SW_PAD_CTL_PAD_PUS_MASK = 0x8) was used.\nThat bit mask is for PUE/PUS-type gpio registers, but this is the\nsection for registers with alternative PULL (PDRV) type layout.\nRight bit mask: IOMUXC_SW_PAD_CTL_PAD_PULL_MASK Please fix this issue.",
  "input": "Faulty tokenized code:\nelse|else\nblock|{\ncomment|/* Set pin to no pull */\nname|reg\noperator||=\nname|IOMUXC_SW_PAD_CTL_PAD_PUS_MASK\nexpr_stmt|;\nblock|}\ncomment|/* PDRV/SNVS/LPSR reg have different ODE bits */\nif|if\ncondition|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|IOMUXC_SW_PAD_CTL_PAD_PUS_MASK\n+name|IOMUXC_SW_PAD_CTL_PAD_PULL_MASK\nThe issue was with: drivers: gpio: imx rt11xx: fix wrong gpio pull disable mask\n\nFixes: #75390\nA wrong bit mask (wrong: IOMUXC_SW_PAD_CTL_PAD_PUS_MASK = 0x8) was used.\nThat bit mask is for PUE/PUS-type gpio registers, but this is the\nsection for registers with alternative PULL (PDRV) type layout.\nRight bit mask: IOMUXC_SW_PAD_CTL_PAD_PULL_MASK"
},{
  "instruction": "There is an issue in the following code. It relates to watchdog: wdt_nrfx: don't zero init static\n\nDon't zero initialise the static data structure, as statics are\nexplicitly initialised to 0 per the C standard, and checkpatch normally\ncomplains about the pattern. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|WDT_NRFX_WDT_DEVICE\nparameter_list|(\nname|idx\nparameter_list|)\ndefine|\\\nvalue|static void wdt_##idx##_event_handler(nrf_wdt_event_t event_type,      \\ \t\t\t\t\t      uint32_t requests,\t       \\ \t\t\t\t\t      void *p_context)\t\t       \\ \t{\t\t\t\t\t\t\t\t       \\ \t\twdt_event_handler(DEVICE_DT_GET(WDT(idx)), event_type,         \\ \t\t\t\t  requests, p_context);\t\t\t       \\ \t}\t\t\t\t\t\t\t\t       \\ \tstatic int wdt_##idx##_init(const struct device *dev)\t\t       \\ \t{\t\t\t\t\t\t\t\t       \\ \t\tconst struct wdt_nrfx_config *config = dev->config;\t       \\ \t\tnrfx_err_t err_code;\t\t\t\t\t       \\ \t\tIRQ_CONNECT(DT_IRQN(WDT(idx)), DT_IRQ(WDT(idx), priority),     \\ \t\t\t    nrfx_isr, nrfx_wdt_##idx##_irq_handler, 0);\t       \\ \t\terr_code = nrfx_wdt_init(&config->wdt,\t\t\t       \\ \t\t\t\t\t NULL,\t\t\t\t       \\ \t\t\t\t\t wdt_##idx##_event_handler,\t       \\ \t\t\t\t\t NULL);\t\t\t\t       \\ \t\tif (err_code != NRFX_SUCCESS) {\t\t\t\t       \\ \t\t\treturn -EBUSY;\t\t\t\t\t       \\ \t\t}\t\t\t\t\t\t\t       \\ \t\treturn 0;\t\t\t\t\t\t       \\ \t}\t\t\t\t\t\t\t\t       \\ \tstatic struct wdt_nrfx_data wdt_##idx##_data = {\t\t       \\ \t\t.m_timeout = 0,\t\t\t\t\t\t       \\ \t\t.m_allocated_channels = 0,\t\t\t\t       \\ \t};\t\t\t\t\t\t\t\t       \\ \tstatic const struct wdt_nrfx_config wdt_##idx##z_config = {\t       \\ \t\t.wdt = NRFX_WDT_INSTANCE(idx),\t\t\t\t       \\ \t};\t\t\t\t\t\t\t\t       \\ \tDEVICE_DT_DEFINE(WDT(idx),\t\t\t\t\t       \\ \t\t\t    wdt_##idx##_init,\t\t\t\t       \\ \t\t\t    NULL,\t\t\t\t\t       \\&wdt_##idx##_data,\t\t\t\t       \\&wdt_##idx##z_config,\t\t\t       \\ \t\t\t    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,  \\&wdt_nrfx_driver_api)\nend_define\n\nbegin_ifdef\nifdef|#\ndirective|ifdef",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|static void wdt_##idx##_event_handler(nrf_wdt_event_t event_type,      \\ \t\t\t\t\t      uint32_t requests,\t       \\ \t\t\t\t\t      void *p_context)\t\t       \\ \t{\t\t\t\t\t\t\t\t       \\ \t\twdt_event_handler(DEVICE_DT_GET(WDT(idx)), event_type,         \\ \t\t\t\t  requests, p_context);\t\t\t       \\ \t}\t\t\t\t\t\t\t\t       \\ \tstatic int wdt_##idx##_init(const struct device *dev)\t\t       \\ \t{\t\t\t\t\t\t\t\t       \\ \t\tconst struct wdt_nrfx_config *config = dev->config;\t       \\ \t\tnrfx_err_t err_code;\t\t\t\t\t       \\ \t\tIRQ_CONNECT(DT_IRQN(WDT(idx)), DT_IRQ(WDT(idx), priority),     \\ \t\t\t    nrfx_isr, nrfx_wdt_##idx##_irq_handler, 0);\t       \\ \t\terr_code = nrfx_wdt_init(&config->wdt,\t\t\t       \\ \t\t\t\t\t NULL,\t\t\t\t       \\ \t\t\t\t\t wdt_##idx##_event_handler,\t       \\ \t\t\t\t\t NULL);\t\t\t\t       \\ \t\tif (err_code != NRFX_SUCCESS) {\t\t\t\t       \\ \t\t\treturn -EBUSY;\t\t\t\t\t       \\ \t\t}\t\t\t\t\t\t\t       \\ \t\treturn 0;\t\t\t\t\t\t       \\ \t}\t\t\t\t\t\t\t\t       \\ \tstatic struct wdt_nrfx_data wdt_##idx##_data = {\t\t       \\ \t\t.m_timeout = 0,\t\t\t\t\t\t       \\ \t\t.m_allocated_channels = 0,\t\t\t\t       \\ \t};\t\t\t\t\t\t\t\t       \\ \tstatic const struct wdt_nrfx_config wdt_##idx##z_config = {\t       \\ \t\t.wdt = NRFX_WDT_INSTANCE(idx),\t\t\t\t       \\ \t};\t\t\t\t\t\t\t\t       \\ \tDEVICE_DT_DEFINE(WDT(idx),\t\t\t\t\t       \\ \t\t\t    wdt_##idx##_init,\t\t\t\t       \\ \t\t\t    NULL,\t\t\t\t\t       \\&wdt_##idx##_data,\t\t\t\t       \\&wdt_##idx##z_config,\t\t\t       \\ \t\t\t    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,  \\&wdt_nrfx_driver_api)\n+value|static void wdt_##idx##_event_handler(nrf_wdt_event_t event_type,      \\ \t\t\t\t\t      uint32_t requests,\t       \\ \t\t\t\t\t      void *p_context)\t\t       \\ \t{\t\t\t\t\t\t\t\t       \\ \t\twdt_event_handler(DEVICE_DT_GET(WDT(idx)), event_type,         \\ \t\t\t\t  requests, p_context);\t\t\t       \\ \t}\t\t\t\t\t\t\t\t       \\ \tstatic int wdt_##idx##_init(const struct device *dev)\t\t       \\ \t{\t\t\t\t\t\t\t\t       \\ \t\tconst struct wdt_nrfx_config *config = dev->config;\t       \\ \t\tnrfx_err_t err_code;\t\t\t\t\t       \\ \t\tIRQ_CONNECT(DT_IRQN(WDT(idx)), DT_IRQ(WDT(idx), priority),     \\ \t\t\t    nrfx_isr, nrfx_wdt_##idx##_irq_handler, 0);\t       \\ \t\terr_code = nrfx_wdt_init(&config->wdt,\t\t\t       \\ \t\t\t\t\t NULL,\t\t\t\t       \\ \t\t\t\t\t wdt_##idx##_event_handler,\t       \\ \t\t\t\t\t NULL);\t\t\t\t       \\ \t\tif (err_code != NRFX_SUCCESS) {\t\t\t\t       \\ \t\t\treturn -EBUSY;\t\t\t\t\t       \\ \t\t}\t\t\t\t\t\t\t       \\ \t\treturn 0;\t\t\t\t\t\t       \\ \t}\t\t\t\t\t\t\t\t       \\ \tstatic struct wdt_nrfx_data wdt_##idx##_data;\t\t\t       \\ \tstatic const struct wdt_nrfx_config wdt_##idx##z_config = {\t       \\ \t\t.wdt = NRFX_WDT_INSTANCE(idx),\t\t\t\t       \\ \t};\t\t\t\t\t\t\t\t       \\ \tDEVICE_DT_DEFINE(WDT(idx),\t\t\t\t\t       \\ \t\t\t    wdt_##idx##_init,\t\t\t\t       \\ \t\t\t    NULL,\t\t\t\t\t       \\&wdt_##idx##_data,\t\t\t\t       \\&wdt_##idx##z_config,\t\t\t       \\ \t\t\t    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,  \\&wdt_nrfx_driver_api)\nThe issue was with: watchdog: wdt_nrfx: don't zero init static\n\nDon't zero initialise the static data structure, as statics are\nexplicitly initialised to 0 per the C standard, and checkpatch normally\ncomplains about the pattern."
},{
  "instruction": "There is an issue in the following code. It relates to watchdog: wdt_nrfx: `install` return error if enabled\n\nReturn the documented error if `wdt_install_timeout` is called after\n`wdt_setup`, instead of triggering the state assertion inside of\n`nrfx_wdt_channel_alloc`. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|nrfx_wdt_channel_id\nname|channel_id\ndecl_stmt|;\nif|if\ncondition|(\nname|cfg\noperator|->\nname|flags\noperator|!=\nname|WDT_FLAG_RESET_SOC",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|data\n+operator|->\n+name|enabled\n+condition|)\n+block|{\n+return|return\n+operator|-\n+name|EBUSY\n+return|;\n+block|}\n+if|if\n+condition|(\nThe issue was with: watchdog: wdt_nrfx: `install` return error if enabled\n\nReturn the documented error if `wdt_install_timeout` is called after\n`wdt_setup`, instead of triggering the state assertion inside of\n`nrfx_wdt_channel_alloc`."
},{
  "instruction": "There is an issue in the following code. It relates to boards: nrfbsim: Fix testargs with non host libC\n\nEnsure that we call the host libC when allocating space\nfor a possible set of test arguments even if we are\nbuilding Zephyr with an embedded libC. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|\"nsi_cpu_ctrl.h\"\nend_include\n\nbegin_comment\ncomment|/*  * These hooks are to be named nsif_cpu<cpu_number>_<hook_name>, for example nsif_cpu0_boot  */\nend_comment\n\nbegin_define\nname|TESTCASAE_ARGV_ALLOCSIZE\nvalue|128\nend_define\n\nbegin_struct\nDECL|struct|__anon2a4cd8de0108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|test_case_argv\nname|char\nexpr_stmt|;\nname|test_args\noperator|.\nname|test_case_argv\noperator|=\nname|realloc\nargument_list|(\nname|test_args\noperator|.\nname|test_case_argv\nargument_list|,\nname|test_args\noperator|.\nname|test_case_argv\ncondition|)\nblock|{\nname|free\nargument_list|(\nname|test_args\noperator|.\nname|test_case_argv\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|\"nsi_host_trampolines.h\"\n+end_include\n+\n-DECL|struct|__anon2a4cd8de0108\n+DECL|struct|__anon2c1a6ff00108\n-name|realloc\n+name|nsi_host_realloc\n-name|free\n+name|nsi_host_free\nThe issue was with: boards: nrfbsim: Fix testargs with non host libC\n\nEnsure that we call the host libC when allocating space\nfor a possible set of test arguments even if we are\nbuilding Zephyr with an embedded libC."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: wifi: esp_at: check if MAC address was parsed successfully\n\nLog an error when MAC address was not parsed successfully. Please fix this issue.",
  "input": "Faulty tokenized code:\ndecl_stmt|;\nname|char\nmodifier|*\nname|mac\ndecl_stmt|;\nname|mac\noperator|=\nname|str_unquote\nargument_list|(\nname|argv\nindex|[\nliteral|0\nindex|]\nargument_list|)\nexpr_stmt|;\nname|net_bytes_from_str\nargument_list|(\nname|dev\noperator|->\nname|mac_addr\nargument_list|)\nargument_list|,\nname|mac\nargument_list|)\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_block",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|int\n+name|err\n+decl_stmt|;\n+name|err\n+operator|=\n+if|if\n+condition|(\n+name|err\n+condition|)\n+block|{\n+name|LOG_ERR\n+argument_list|(\n+literal|\"Failed to parse MAC address\"\n+argument_list|)\n+expr_stmt|;\n+block|}\nThe issue was with: drivers: wifi: esp_at: check if MAC address was parsed successfully\n\nLog an error when MAC address was not parsed successfully."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: nsos: fix resource leak in nsos_adapt_accept() error path\n\nClose file descriptor returned by accept() in error path of\nnsos_adapt_accept(), so that file descriptor is not leaked. Please fix this issue.",
  "input": "Faulty tokenized code:\nif|if\ncondition|(\nname|err\ncondition|)\nblock|{\nreturn|return\nname|err\nreturn|;\nblock|}\nreturn|return",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|close\n+argument_list|(\n+name|ret\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: nsos: fix resource leak in nsos_adapt_accept() error path\n\nClose file descriptor returned by accept() in error path of\nnsos_adapt_accept(), so that file descriptor is not leaked."
},{
  "instruction": "There is an issue in the following code. It relates to fb: cfb: Fix CID 394240\n\nThis is a simple deletion of unnecessary processing. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|fb\ninit|=\noperator|&\nname|char_fb\ndecl_stmt|;\nif|if\ncondition|(\noperator|!\nname|fb\ncondition|)\nblock|{\nreturn|return\noperator|-\nname|ENODEV\nreturn|;\nblock|}\nname|fb\noperator|->\nname|inverted\noperator|=\noperator|!",
  "result": "I corrected the issue in the code by changing the following tokens:\n-if|if\n-condition|(\n-operator|!\n-name|fb\n-condition|)\n-block|{\n-return|return\n-operator|-\n-name|ENODEV\n-return|;\n-block|}\nThe issue was with: fb: cfb: Fix CID 394240\n\nThis is a simple deletion of unnecessary processing."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: A2DP: Check the pointer before using\n\nCheck the pointer `sep` before using it.\n\nFixes #74734. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|*\nname|errcode\noperator|=\nliteral|0\nexpr_stmt|;\nname|ep\noperator|=\nname|CONTAINER_OF\nargument_list|(\nname|sep\nname|bt_a2dp_ep\nargument_list|,\nname|sep\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|ep\noperator|==\nname|NULL\ncondition|)\nblock|{\noperator|*\nname|errcode\noperator|=\nname|BT_AVDTP_BAD_ACP_SEID\nexpr_stmt|;\nreturn|return\noperator|-\nliteral|1\nreturn|;\nblock|}\ncomment|/* parse the configuration */\nname|codec_info_element_len\noperator|=\nliteral|4U\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|__ASSERT\n+argument_list|(\n+name|sep\n+argument_list|,\n+literal|\"Invalid sep\"\n+argument_list|)\n+expr_stmt|;\n-if|if\n-condition|(\n-name|ep\n-operator|==\n-name|NULL\n-condition|)\n-block|{\n-operator|*\n-name|errcode\n-operator|=\n-name|BT_AVDTP_BAD_ACP_SEID\n-expr_stmt|;\n-return|return\n-operator|-\n-literal|1\n-return|;\n-block|}\nThe issue was with: Bluetooth: A2DP: Check the pointer before using\n\nCheck the pointer `sep` before using it.\n\nFixes #74734."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: A2DP: Fix NULL pointer references issue\n\nThe opposite logic is used to determine if a\npointer is valid.\n\nCorrect the judgment logic.\n\nFixes #74728. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|acp_stream_ep_id\noperator|=\nname|stream\noperator|->\nname|remote_ep\noperator|==\nname|NULL\ncondition|?\nname|stream\noperator|->\nname|remote_ep",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|==\n+operator|!=\nThe issue was with: Bluetooth: A2DP: Fix NULL pointer references issue\n\nThe opposite logic is used to determine if a\npointer is valid.\n\nCorrect the judgment logic.\n\nFixes #74728."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: A2DP: Fix NULL pointer references issue\n\nThe opposite logic is used to determine if a\npointer is valid.\n\nCorrect the judgment logic.\n\nFixes #74732. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|acp_stream_ep_id\noperator|=\nname|stream\noperator|->\nname|remote_ep\noperator|==\nname|NULL\ncondition|?\nname|stream\noperator|->\nname|remote_ep",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|==\n+operator|!=\nThe issue was with: Bluetooth: A2DP: Fix NULL pointer references issue\n\nThe opposite logic is used to determine if a\npointer is valid.\n\nCorrect the judgment logic.\n\nFixes #74732."
},{
  "instruction": "There is an issue in the following code. It relates to net: mqtt: Fix possible socket leak with websocket transport\n\nIn case underlying TCP/TLS connection is already down, the\nwebsocket_disconnect() call is expected to fail, as it involves\ncommunication. Therefore, mqtt_client_websocket_disconnect() should not\nquit early in such cases, as it could lead to an underlying socket leak. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ret\noperator|<\nliteral|0\ncondition|)\nblock|{\nname|NET_ERR\nargument_list|(\nliteral|\"Websocket disconnect failed (%d)\"\nargument_list|,\nname|ret\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|ret\nreturn|;\nblock|}\nif|if\ncondition|(\nname|client\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|NET_ERR\n+name|NET_DBG\n-return|return\n-name|ret\n-return|;\nThe issue was with: net: mqtt: Fix possible socket leak with websocket transport\n\nIn case underlying TCP/TLS connection is already down, the\nwebsocket_disconnect() call is expected to fail, as it involves\ncommunication. Therefore, mqtt_client_websocket_disconnect() should not\nquit early in such cases, as it could lead to an underlying socket leak."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: A2DP: Access pointer if it is valid\n\nOnly access if the pointer `stream` is valid.\n\nFixes #74735\nFixes #74740 Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|stream\noperator|=\nname|stream\nexpr_stmt|;\nblock|}\nblock|}\nname|ops\noperator|=\nname|stream\noperator|->\nname|ops\nexpr_stmt|;\nif|if\ncondition|(\noperator|*\nname|errcode\noperator|==\nliteral|0\ncondition|)\nblock|{\nif|if\ncondition|(\noperator|(\nname|ops\noperator|!=\nname|NULL\noperator|)\noperator|&&\noperator|(\nname|stream\noperator|->\nname|ops\noperator|->\nname|configured\noperator|!=\nname|NULL\noperator|)\ncondition|)\nblock|{\nname|stream\noperator|->\nname|ops\noperator|->\nname|configured\nargument_list|(\nname|stream\nargument_list|)\nexpr_stmt|;\nblock|}\nblock|}\nreturn|return\noperator|(\noperator|*\nname|errcode\noperator|==",
  "result": "I corrected the issue in the code by changing the following tokens:\n-block|}\n-block|}\n-operator|*\n-name|errcode\n-operator|==\n-literal|0\n-condition|)\n-block|{\n-if|if\n-condition|(\n-name|stream\n-operator|->\n-name|stream\n-operator|->\n+block|}\nThe issue was with: Bluetooth: A2DP: Access pointer if it is valid\n\nOnly access if the pointer `stream` is valid.\n\nFixes #74735\nFixes #74740"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: ISO: Tone down some dbg logs\n\nSeveral log statements were using the regualar LOG_DBG,\nbut when ISO is actually used, those were called every TX\nwhich at 10ms SDU intervals would fill up the log really fast\nand not provided much value outside of some specific debugging.\n\nModified those logs to use BT_ISO_DATA_DBG which is another\nlog level for ISO data. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_BT_ISO_TX\nargument_list|)\nname|LOG_DBG\nargument_list|(\nliteral|\"conn %p amount %d\"\nargument_list|,\nname|conn\nargument_list|,\ncondition|(\noperator|!\nname|frag\ncondition|)\nblock|{\nname|LOG_DBG\nargument_list|(\nliteral|\"signaled ready but no frag available\"\nargument_list|)\nexpr_stmt|;\ncomment|/* Service other connections */\nname|txq\nargument_list|,\nname|K_NO_WAIT\nargument_list|)\ndecl_stmt|;\nname|LOG_DBG\nargument_list|(\nliteral|\"last frag, pop buf\"\nargument_list|)\nexpr_stmt|;\nname|__ASSERT_NO_MSG\nname|txq\nargument_list|,\nname|buf\nargument_list|)\nexpr_stmt|;\nname|LOG_DBG\nargument_list|(\nliteral|\"%p put on list\"\nargument_list|,\nname|buf\nargument_list|)\noperator|=\nname|chan\noperator|->\nname|iso\nexpr_stmt|;\nname|LOG_DBG\nargument_list|(\nliteral|\"send-iso (no ts)\"\nargument_list|)\nexpr_stmt|;\nreturn|return",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|LOG_DBG\n+name|BT_ISO_DATA_DBG\n-name|LOG_DBG\n+name|BT_ISO_DATA_DBG\n-name|LOG_DBG\n+name|BT_ISO_DATA_DBG\n-name|LOG_DBG\n+name|BT_ISO_DATA_DBG\n-name|LOG_DBG\n+name|BT_ISO_DATA_DBG\nThe issue was with: Bluetooth: ISO: Tone down some dbg logs\n\nSeveral log statements were using the regualar LOG_DBG,\nbut when ISO is actually used, those were called every TX\nwhich at 10ms SDU intervals would fill up the log really fast\nand not provided much value outside of some specific debugging.\n\nModified those logs to use BT_ISO_DATA_DBG which is another\nlog level for ISO data."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: eeprom: emulator: correct improper exponentiation\n\nThe top-level driver comment states that a uint16_t is used to store\nchanges if the EEPROM size is smaller than 64kB, or uint32_t otherwise.\nHowever, the 64kB threshold is represented as 2^16 in the actual code,\nwhich is a bitwise XOR instead of an exponent. This causes a uint16_t\nto be used only if the size is less than or equal to 18 bytes. Correct\nthis by using KB(64) instead of 2^16. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|(\nname|part\nparameter_list|,\nname|size\nparameter_list|)\nvalue|(PART_WBS(part)< 4) ? \\ \t((size> (2^16)) ? 8 : 4) : PART_WBS(part)\nend_define\n\nbegin_define\nDECL|macro|PART_DEV_ID (part)\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|(PART_WBS(part)< 4) ? \\ \t((size> (2^16)) ? 8 : 4) : PART_WBS(part)\n+value|(PART_WBS(part)< 4) ? \\ \t((size> KB(64)) ? 8 : 4) : PART_WBS(part)\nThe issue was with: drivers: eeprom: emulator: correct improper exponentiation\n\nThe top-level driver comment states that a uint16_t is used to store\nchanges if the EEPROM size is smaller than 64kB, or uint32_t otherwise.\nHowever, the 64kB threshold is represented as 2^16 in the actual code,\nwhich is a bitwise XOR instead of an exponent. This causes a uint16_t\nto be used only if the size is less than or equal to 18 bytes. Correct\nthis by using KB(64) instead of 2^16."
},{
  "instruction": "There is an issue in the following code. It relates to arch: arm: cortex_a_r: Set XPSR endianness bit\n\nWhen this bit is not set, it defaults to 0 (little endian). This\ncauses issues for big-endian devices, as data will be accessed using\nlittle endian. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_COMPILER_ISA_THUMB2\nargument_list|)\nname|iframe\noperator|->\nname|xpsr\ndirective|define\nname|MODE_MASK\nvalue|0x1f\nend_define\n\nbegin_define\nDECL|macro|A_BIT\ndefine|#\ndirective|define\nname|A_BIT",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|CONFIG_BIG_ENDIAN\n+argument_list|)\n+name|iframe\n+operator|->\n+name|xpsr\n+operator||=\n+name|E_BIT\n+expr_stmt|;\n+endif|#\n+directive|endif\n+comment|/* CONFIG_BIG_ENDIAN */\n+if|#\n+directive|if\n+name|defined\n+argument_list|(\n+begin_define\n+DECL|macro|E_BIT\n+define|#\n+directive|define\n+name|E_BIT\n+value|(1<< 9)\n+end_define\n+\nThe issue was with: arch: arm: cortex_a_r: Set XPSR endianness bit\n\nWhen this bit is not set, it defaults to 0 (little endian). This\ncauses issues for big-endian devices, as data will be accessed using\nlittle endian."
},{
  "instruction": "There is an issue in the following code. It relates to drivers/sensor/st: ism330dhcx: fix odr setting\n\nLoop inside the odr array until we find the first\nvalue which is \\\"<=\\\" (amd not \\\"==\\\") the argument. Please fix this issue.",
  "input": "Faulty tokenized code:\ncontrol|)\nblock|{\nif|if\ncondition|(\nname|freq\noperator|==\nname|ism330dhcx_odr_map\nindex|[\nname|i\nindex|]\ncondition|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|==\n+operator|<=\nThe issue was with: drivers/sensor/st: ism330dhcx: fix odr setting\n\nLoop inside the odr array until we find the first\nvalue which is \\\"<=\\\" (amd not \\\"==\\\") the argument."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: uart_max32: Fixing bugs and code optimizations\n\n- Defined 'api_configure' function outside of\n'CONFIG_UART_USE_RUNTIME_CONFIGURE' macro because it is the only\nconfiguration function and used in device initialization function.\n- Removed unnecessary 'IF_ENABLED' part. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|err\nreturn|;\nblock|}\nend_function\n\nbegin_ifdef\nifdef|#\ndirective|ifdef\nname|CONFIG_UART_USE_RUNTIME_CONFIGURE\nend_ifdef\n\nbegin_function\nDECL|function|api_configure (const struct device * dev,const struct uart_config * uart_cfg)\nspecifier|static\nname|int\nname|api_configure\nliteral|0\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|api_config_get (const struct device * dev,struct uart_config * uart_cfg)\nspecifier|static\nname|int\nname|api_config_get\nname|MAX32_UART_INIT\nparameter_list|(\nname|_num\nparameter_list|)\ndefine|\\\nvalue|PINCTRL_DT_INST_DEFINE(_num);                                                              \\ \tIF_ENABLED(CONFIG_UART_INTERRUPT_DRIVEN,                                                   \\ \t\t   (static void uart_max32_irq_init_##_num(const struct device *dev)               \\ \t\t   {                                                                               \\ \t\t\t   IF_ENABLED(                                                             \\ \t\t\t\t   CONFIG_UART_INTERRUPT_DRIVEN,                                   \\ \t\t\t\t   (IRQ_CONNECT(DT_INST_IRQN(_num), DT_INST_IRQ(_num, priority),   \\ \t\t\t\t\t\tuart_max32_isr, DEVICE_DT_INST_GET(_num), 0);      \\ \t\t\t\t    irq_enable(DT_INST_IRQN(_num))));                              \\ \t\t   }));                                                                            \\ \tstatic const struct max32_uart_config max32_uart_config_##_num = {                         \\ \t\t.regs = (mxc_uart_regs_t *)DT_INST_REG_ADDR(_num),                                 \\ \t\t.pctrl = PINCTRL_DT_INST_DEV_CONFIG_GET(_num),                                     \\ \t\t.clock = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(_num)),                                 \\ \t\t.perclk.bus = DT_INST_CLOCKS_CELL(_num, offset),                                   \\ \t\t.perclk.bit = DT_INST_CLOCKS_CELL(_num, bit),                                      \\ \t\t.perclk.clk_src =                                                                  \\ \t\t\tDT_INST_PROP_OR(_num, clock_source, ADI_MAX32_PRPH_CLK_SRC_PCLK),          \\ \t\t.uart_conf.baudrate = DT_INST_PROP_OR(_num, current_speed, 115200),                \\ \t\t.uart_conf.parity = DT_INST_ENUM_IDX_OR(_num, parity, UART_CFG_PARITY_NONE),       \\ \t\t.uart_conf.data_bits = DT_INST_ENUM_IDX_OR(_num, data_bits, UART_CFG_DATA_BITS_8), \\ \t\t.uart_conf.stop_bits = DT_INST_ENUM_IDX_OR(_num, stop_bits, UART_CFG_STOP_BITS_1), \\ \t\t.uart_conf.flow_ctrl =                                                             \\ \t\t\tDT_INST_PROP_OR(_num, hw_flow_control, UART_CFG_FLOW_CTRL_NONE),           \\ \t\tIF_ENABLED(CONFIG_UART_INTERRUPT_DRIVEN,                                           \\ \t\t\t   (.irq_config_func = uart_max32_irq_init_##_num,))};                     \\ \tstatic struct max32_uart_data max32_uart_data##_num = {                                    \\ \t\tIF_ENABLED(CONFIG_UART_INTERRUPT_DRIVEN, (.cb = NULL,))};                          \\ \tDEVICE_DT_INST_DEFINE(_num, uart_max32_init, NULL,&max32_uart_data##_num,                 \\&max32_uart_config_##_num, PRE_KERNEL_1,                             \\ \t\t\t      CONFIG_SERIAL_INIT_PRIORITY, (void *)&uart_max32_driver_api);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_ifdef\n-ifdef|#\n-directive|ifdef\n-name|CONFIG_UART_USE_RUNTIME_CONFIGURE\n-end_ifdef\n-\n+begin_ifdef\n+ifdef|#\n+directive|ifdef\n+name|CONFIG_UART_USE_RUNTIME_CONFIGURE\n+end_ifdef\n+\n-value|PINCTRL_DT_INST_DEFINE(_num);                                                              \\ \tIF_ENABLED(CONFIG_UART_INTERRUPT_DRIVEN,                                                   \\ \t\t   (static void uart_max32_irq_init_##_num(const struct device *dev)               \\ \t\t   {                                                                               \\ \t\t\t   IF_ENABLED(                                                             \\ \t\t\t\t   CONFIG_UART_INTERRUPT_DRIVEN,                                   \\ \t\t\t\t   (IRQ_CONNECT(DT_INST_IRQN(_num), DT_INST_IRQ(_num, priority),   \\ \t\t\t\t\t\tuart_max32_isr, DEVICE_DT_INST_GET(_num), 0);      \\ \t\t\t\t    irq_enable(DT_INST_IRQN(_num))));                              \\ \t\t   }));                                                                            \\ \tstatic const struct max32_uart_config max32_uart_config_##_num = {                         \\ \t\t.regs = (mxc_uart_regs_t *)DT_INST_REG_ADDR(_num),                                 \\ \t\t.pctrl = PINCTRL_DT_INST_DEV_CONFIG_GET(_num),                                     \\ \t\t.clock = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(_num)),                                 \\ \t\t.perclk.bus = DT_INST_CLOCKS_CELL(_num, offset),                                   \\ \t\t.perclk.bit = DT_INST_CLOCKS_CELL(_num, bit),                                      \\ \t\t.perclk.clk_src =                                                                  \\ \t\t\tDT_INST_PROP_OR(_num, clock_source, ADI_MAX32_PRPH_CLK_SRC_PCLK),          \\ \t\t.uart_conf.baudrate = DT_INST_PROP_OR(_num, current_speed, 115200),                \\ \t\t.uart_conf.parity = DT_INST_ENUM_IDX_OR(_num, parity, UART_CFG_PARITY_NONE),       \\ \t\t.uart_conf.data_bits = DT_INST_ENUM_IDX_OR(_num, data_bits, UART_CFG_DATA_BITS_8), \\ \t\t.uart_conf.stop_bits = DT_INST_ENUM_IDX_OR(_num, stop_bits, UART_CFG_STOP_BITS_1), \\ \t\t.uart_conf.flow_ctrl =                                                             \\ \t\t\tDT_INST_PROP_OR(_num, hw_flow_control, UART_CFG_FLOW_CTRL_NONE),           \\ \t\tIF_ENABLED(CONFIG_UART_INTERRUPT_DRIVEN,                                           \\ \t\t\t   (.irq_config_func = uart_max32_irq_init_##_num,))};                     \\ \tstatic struct max32_uart_data max32_uart_data##_num = {                                    \\ \t\tIF_ENABLED(CONFIG_UART_INTERRUPT_DRIVEN, (.cb = NULL,))};                          \\ \tDEVICE_DT_INST_DEFINE(_num, uart_max32_init, NULL,&max32_uart_data##_num,                 \\&max32_uart_config_##_num, PRE_KERNEL_1,                             \\ \t\t\t      CONFIG_SERIAL_INIT_PRIORITY, (void *)&uart_max32_driver_api);\n+value|PINCTRL_DT_INST_DEFINE(_num);                                                              \\ \tIF_ENABLED(CONFIG_UART_INTERRUPT_DRIVEN,                                                   \\ \t\t   (static void uart_max32_irq_init_##_num(const struct device *dev) \\ \t\t   {             \\ \t\t\t   IRQ_CONNECT(DT_INST_IRQN(_num), DT_INST_IRQ(_num, priority),            \\ \t\t\t\t       uart_max32_isr, DEVICE_DT_INST_GET(_num), 0);               \\ \t\t\t   irq_enable(DT_INST_IRQN(_num));                                         \\ \t\t   }));                                                                            \\ \tstatic const struct max32_uart_config max32_uart_config_##_num = {                         \\ \t\t.regs = (mxc_uart_regs_t *)DT_INST_REG_ADDR(_num),                                 \\ \t\t.pctrl = PINCTRL_DT_INST_DEV_CONFIG_GET(_num),                                     \\ \t\t.clock = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(_num)),                                 \\ \t\t.perclk.bus = DT_INST_CLOCKS_CELL(_num, offset),                                   \\ \t\t.perclk.bit = DT_INST_CLOCKS_CELL(_num, bit),                                      \\ \t\t.perclk.clk_src =                                                                  \\ \t\t\tDT_INST_PROP_OR(_num, clock_source, ADI_MAX32_PRPH_CLK_SRC_PCLK),          \\ \t\t.uart_conf.baudrate = DT_INST_PROP_OR(_num, current_speed, 115200),                \\ \t\t.uart_conf.parity = DT_INST_ENUM_IDX_OR(_num, parity, UART_CFG_PARITY_NONE),       \\ \t\t.uart_conf.data_bits = DT_INST_ENUM_IDX_OR(_num, data_bits, UART_CFG_DATA_BITS_8), \\ \t\t.uart_conf.stop_bits = DT_INST_ENUM_IDX_OR(_num, stop_bits, UART_CFG_STOP_BITS_1), \\ \t\t.uart_conf.flow_ctrl =                                                             \\ \t\t\tDT_INST_PROP_OR(_num, hw_flow_control, UART_CFG_FLOW_CTRL_NONE),           \\ \t\tIF_ENABLED(CONFIG_UART_INTERRUPT_DRIVEN,                                           \\ \t\t\t   (.irq_config_func = uart_max32_irq_init_##_num,))};                     \\ \tstatic struct max32_uart_data max32_uart_data##_num = {                                    \\ \t\tIF_ENABLED(CONFIG_UART_INTERRUPT_DRIVEN, (.cb = NULL,))};                          \\ \tDEVICE_DT_INST_DEFINE(_num, uart_max32_init, NULL,&max32_uart_data##_num,                 \\&max32_uart_config_##_num, PRE_KERNEL_1,                             \\ \t\t\t      CONFIG_SERIAL_INIT_PRIORITY, (void *)&uart_max32_driver_api);\nThe issue was with: drivers: serial: uart_max32: Fixing bugs and code optimizations\n\n- Defined 'api_configure' function outside of\n'CONFIG_UART_USE_RUNTIME_CONFIGURE' macro because it is the only\nconfiguration function and used in device initialization function.\n- Removed unnecessary 'IF_ENABLED' part."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: nsos: add missing 'break' in switch statements\n\nThere are 2-level switch statements (one switch inside another) which were\nnot properly terminated with 'break' statements, leading to implicit\nfallthrough. Fix that. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|nsos_mid_optlen\nargument_list|)\nreturn|;\nblock|}\ncase|case\nname|NSOS_MID_IPPROTO_TCP\ncase|:\nswitch|switch\ncondition|(\nargument_list|,\nname|nsos_mid_optlen\nargument_list|)\nreturn|;\nblock|}\ncase|case\nname|NSOS_MID_IPPROTO_IPV6\ncase|:\nswitch|switch\ncondition|(\nargument_list|,\nname|nsos_mid_optlen\nargument_list|)\nreturn|;\nblock|}\nblock|}\nreturn|return\noperator|-\nname|NSOS_MID_EOPNOTSUPP\nreturn|;\nargument_list|,\nname|nsos_mid_optlen\nargument_list|)\nreturn|;\nblock|}\ncase|case\nname|NSOS_MID_IPPROTO_TCP\ncase|:\nswitch|switch\ncondition|(\nargument_list|,\nname|nsos_mid_optlen\nargument_list|)\nreturn|;\nblock|}\ncase|case\nname|NSOS_MID_IPPROTO_IPV6\ncase|:\nswitch|switch\ncondition|(\nargument_list|,\nname|nsos_mid_optlen\nargument_list|)\nreturn|;\nblock|}\nblock|}\nreturn|return\noperator|-\nname|NSOS_MID_EOPNOTSUPP\nreturn|;\nargument_list|,\nname|optlen\nargument_list|)\nreturn|;\nblock|}\ncase|case\nname|IPPROTO_TCP\ncase|:\nswitch|switch\ncondition|(\nargument_list|,\nname|optlen\nargument_list|)\nreturn|;\nblock|}\ncase|case\nname|IPPROTO_IPV6\ncase|:\nswitch|switch\ncondition|(\nargument_list|,\nname|optlen\nargument_list|)\nreturn|;\nblock|}\nblock|}\nname|errno\noperator|=\nname|EOPNOTSUPP\nexpr_stmt|;\nargument_list|,\nname|optlen\nargument_list|)\nreturn|;\nblock|}\ncase|case\nname|IPPROTO_TCP\ncase|:\nswitch|switch\ncondition|(\nargument_list|,\nname|optlen\nargument_list|)\nreturn|;\nblock|}\ncase|case\nname|IPPROTO_IPV6\ncase|:\nswitch|switch\ncondition|(\nargument_list|,\nname|optlen\nargument_list|)\nreturn|;\nblock|}\nblock|}\nname|errno\noperator|=\nname|EOPNOTSUPP\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+break|break;\n+break|break;\n+break|break;\n+break|break;\n+break|break;\n+break|break;\n+break|break;\n+break|break;\n+break|break;\n+break|break;\n+break|break;\n+break|break;\nThe issue was with: drivers: nsos: add missing 'break' in switch statements\n\nThere are 2-level switch statements (one switch inside another) which were\nnot properly terminated with 'break' statements, leading to implicit\nfallthrough. Fix that."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: wifi/airoc: Update cb_search to check SSID length\n\nIssue:\nWhen there are two similar SSIDs (e.g. MySSID and MySSID_Guest),\nthe current implementation may use the wrong (truncated) SSID\nfor the connection. See issue#74910 for details.\n\nFix:\nUpdated airoc_wifi_scan_cb_search to filter all SSID where\nlength is different than the user-entered SSID. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|)\noperator|.\nname|SSID\noperator|.\nname|length\noperator|>\nliteral|0\noperator|)\ncondition|)\nblock|{\nif|if\ncondition|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|>\n-literal|0\n+operator|==\n+operator|(\n+operator|(\n+name|whd_scan_result_t\n+operator|*\n+operator|)\n+name|user_data\n+operator|)\n+operator|->\n+name|SSID\n+operator|.\n+name|length\nThe issue was with: drivers: wifi/airoc: Update cb_search to check SSID length\n\nIssue:\nWhen there are two similar SSIDs (e.g. MySSID and MySSID_Guest),\nthe current implementation may use the wrong (truncated) SSID\nfor the connection. See issue#74910 for details.\n\nFix:\nUpdated airoc_wifi_scan_cb_search to filter all SSID where\nlength is different than the user-entered SSID."
},{
  "instruction": "There is an issue in the following code. It relates to modules: hostap: Fix check for iface up\n\nWe only need the interface to be administratively up, the operationl\nstatus is managed by the WPA supplicant. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|return;\nblock|}\nif|if\ncondition|(\noperator|!\nname|net_if_is_up\nargument_list|(\nname|iface\nargument_list|)\ncondition|)\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|net_if_is_up\n+name|net_if_is_admin_up\nThe issue was with: modules: hostap: Fix check for iface up\n\nWe only need the interface to be administratively up, the operationl\nstatus is managed by the WPA supplicant."
},{
  "instruction": "There is an issue in the following code. It relates to intel_adsp/ace: power: fix firmware panic on MTL\n\nThe power_down() function attempts to lock the hpsram_mask on-stack\nvariable in data cache, which causes an exception. Moving it to .bss\nby making it static fixes it. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\ncomment|/* CONFIG_ADSP_IMR_CONTEXT_SAVE */\nname|uint32_t\nname|hpsram_mask\ninit|=\nliteral|0\ndecl_stmt|;\nifdef|#\ndirective|ifdef\nname|CONFIG_ADSP_POWER_DOWN_HPSRAM\ncomment|/* turn off all HPSRAM banks - get a full bitmap */\n\tipfl pfl_reg, 0\n\tipfl pfl_reg, 64\n\tipfl pfl_reg, 128\n\tipfl pfl_reg, 192\n\n\tmov  pfl_reg, pu32_hpsram_mask\n\tdpfl pfl_reg, 0\n\t/* move some values to registries before switching off whole memory */\n\t/* load address of DIPCTDR register */\n\tmovi p_ipc_regs, IPC_HOST_BASE",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* This assumes a single HPSRAM segment */\n+specifier|static\n-init|=\n-literal|0\n+\t/*\n+\t * This assumes a single HPSRAM segment although the code below is\n+\t * generic and uses MAX_MEMORY_SEGMENTS for their number\n+\t */\nThe issue was with: intel_adsp/ace: power: fix firmware panic on MTL\n\nThe power_down() function attempts to lock the hpsram_mask on-stack\nvariable in data cache, which causes an exception. Moving it to .bss\nby making it static fixes it."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: adc: lmp90xxx: fix checksum mismatch return value\n\nDuring channel reads, zero is returned on CRC mismatches: the returned\nerror variable is not written to after a previous non-zero check. Return\n-EIO to mirror other drivers' checksum validation behaviors. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|crc\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|err\nreturn|;\nblock|}\nblock|}\ncomment|/* Read result, get rid of CRC, and sign extend result */\noperator|*",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|err\n+operator|-\n+name|EIO\nThe issue was with: drivers: adc: lmp90xxx: fix checksum mismatch return value\n\nDuring channel reads, zero is returned on CRC mismatches: the returned\nerror variable is not written to after a previous non-zero check. Return\n-EIO to mirror other drivers' checksum validation behaviors."
},{
  "instruction": "There is an issue in the following code. It relates to tests: dma/chan_blen_transfer: place TX buf in RAM\n\nThis commit removes the const qualifier from TX (source) buffer\nof the chan_blen_transfer DMA test to ensure it gets placed in\nRAM rather than flash. This ensures the test can pass on hardware\nwhere the DMA controller is unable to access flash.\n\nFixes #75125. Please fix this issue.",
  "input": "Faulty tokenized code:\nspecifier|static\nname|__aligned\nargument_list|(\nliteral|32\nargument_list|)\nspecifier|const\nname|char\nname|tx_data\nindex|[]\noperator|=\nliteral|\"It is harder to be kind than to be wise........\"",
  "result": "I corrected the issue in the code by changing the following tokens:\n-specifier|const\nThe issue was with: tests: dma/chan_blen_transfer: place TX buf in RAM\n\nThis commit removes the const qualifier from TX (source) buffer\nof the chan_blen_transfer DMA test to ensure it gets placed in\nRAM rather than flash. This ensures the test can pass on hardware\nwhere the DMA controller is unable to access flash.\n\nFixes #75125."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: udc_stm32: only check for HS_SPEED if defined\n\nSeems like not all stm32 devices define USBD_HS_SPEED in the HAL, only\ncheck for USBD_HS_SPEED if defined. Fixes a build failure with the new\nstack on F1 MCUs. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|udc_get_private\nargument_list|(\nname|dev\nargument_list|)\ndecl_stmt|;\nif|if\ncondition|(\nname|priv\noperator|->\nname|pcd\nblock|{\nreturn|return\nname|UDC_BUS_SPEED_HS\nreturn|;\nblock|}\nif|if\ncondition|(\nname|priv\noperator|->\nname|pcd",
  "result": "I corrected the issue in the code by changing the following tokens:\n+ifdef|#\n+directive|ifdef\n+name|USBD_HS_SPEED\n+endif|#\n+directive|endif\nThe issue was with: drivers: udc_stm32: only check for HS_SPEED if defined\n\nSeems like not all stm32 devices define USBD_HS_SPEED in the HAL, only\ncheck for USBD_HS_SPEED if defined. Fixes a build failure with the new\nstack on F1 MCUs."
},{
  "instruction": "There is an issue in the following code. It relates to net: dns: Avoid superfluous error message\n\nIf we have configured the DNS dispatcher to be only as a\nresponder but receive a query response, or if we are only\nas a resolver but receive a query, then the dispatcher just\nignores the packet and returns -ENOENT.\n\nUnfortunately we print an error message in this case\n\n[00:10:18.818,000] <err> net_dns_dispatcher: DNS recv error (-2)\n\nwhich is totally unnecessary and causes confusion so do not\nprint an error message in this case. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|0\noperator|&&\nname|ret\noperator|!=\nname|DNS_EAI_ALLDONE\ncondition|)\nblock|{\nname|NET_ERR\nargument_list|(\nliteral|\"DNS recv error (%d)\"",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|&&\n+name|ret\n+operator|!=\n+operator|-\n+name|ENOENT\nThe issue was with: net: dns: Avoid superfluous error message\n\nIf we have configured the DNS dispatcher to be only as a\nresponder but receive a query response, or if we are only\nas a resolver but receive a query, then the dispatcher just\nignores the packet and returns -ENOENT.\n\nUnfortunately we print an error message in this case\n\n[00:10:18.818,000] <err> net_dns_dispatcher: DNS recv error (-2)\n\nwhich is totally unnecessary and causes confusion so do not\nprint an error message in this case."
},{
  "instruction": "There is an issue in the following code. It relates to tests: arm_irq_vector_table: Fix RT/WXXX\n\nFix preprocessor expression for custom vector table due\nto OS timer isr being needed. The parentheses are missing.\nAlso add RW6xx to the list which has the same isr needed for ostimer. Please fix this issue.",
  "input": "Faulty tokenized code:\nend_decl_stmt\n\nbegin_elif\nelif|#\ndirective|elif\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_IMXRT6XX\nargument_list|)\noperator|||\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_IMXRT5XX\nargument_list|)\noperator|&&\nexpr|\\\nname|defined\nargument_list|(\nname|CONFIG_MCUX_OS_TIMER",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+operator|||\n+expr|\\\n+name|defined\n+argument_list|(\n+name|CONFIG_SOC_SERIES_RW6XX\n+argument_list|)\n+operator|)\nThe issue was with: tests: arm_irq_vector_table: Fix RT/WXXX\n\nFix preprocessor expression for custom vector table due\nto OS timer isr being needed. The parentheses are missing.\nAlso add RW6xx to the list which has the same isr needed for ostimer."
},{
  "instruction": "There is an issue in the following code. It relates to lib: smf: use `while (true)` in `get_child_of` for better clarity\n\nReplace the condition-less `for` loop (`;;`) in `get_child_of` with\na `while (true)` loop and remove the redundant `return NULL;`\nat the end, which is never reached.\n\nThis change aims to enhance readability since `while (true)` is better\nsuited for this scenario. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|smf_state\nmodifier|*\nname|parent\nparameter_list|)\nblock|{\nfor|for\ncontrol|(\nspecifier|const\nname|struct\nname|smf_state\nmodifier|*\nname|tmp\ninit|=\nname|states\ninit|;\ncondition|;\nname|tmp\noperator|=\nname|tmp\noperator|->\nname|parent\ncontrol|)\nblock|{\nif|if\ncondition|(\nname|tmp\noperator|->\nblock|{\nreturn|return\nname|NULL\nreturn|;\nblock|}\nblock|}\nreturn|return\nname|NULL\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|get_last_of (const struct smf_state * states)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-for|for\n-control|(\n-init|;\n-condition|;\n-name|tmp\n-operator|=\n-name|tmp\n-operator|->\n-name|parent\n-control|)\n+decl_stmt|;\n+while|while\n+condition|(\n+name|true\n+condition|)\n+name|tmp\n+operator|=\n+name|tmp\n+operator|->\n+name|parent\n+expr_stmt|;\n-return|return\n-name|NULL\n-return|;\nThe issue was with: lib: smf: use `while (true)` in `get_child_of` for better clarity\n\nReplace the condition-less `for` loop (`;;`) in `get_child_of` with\na `while (true)` loop and remove the redundant `return NULL;`\nat the end, which is never reached.\n\nThis change aims to enhance readability since `while (true)` is better\nsuited for this scenario."
},{
  "instruction": "There is an issue in the following code. It relates to net: ptp: fix incorrect req_timestamp decoding\n\nRemoved incorrect use of ntoh to decode Delay_Req timestamp Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|.\nname|_sec\noperator|.\nname|high\noperator|=\nname|ntohs\nargument_list|(\nname|pkt\noperator|->\nname|timestamp\noperator|.\nname|_sec\noperator|.\nname|high\nargument_list|)\nexpr_stmt|;\nname|req\noperator|->\nname|timestamp\noperator|.\noperator|.\nname|_sec\noperator|.\nname|low\noperator|=\nname|ntohl\nargument_list|(\nname|pkt\noperator|->\nname|timestamp\noperator|.\nname|_sec\noperator|.\nname|low\nargument_list|)\nexpr_stmt|;\nname|req\noperator|->\nname|timestamp\noperator|.\nname|host\noperator|.\nname|nanosecond\noperator|=\nname|ntohl\nargument_list|(\nname|pkt\noperator|->\nname|timestamp\noperator|.\nname|nanosecond\nargument_list|)\nexpr_stmt|;\nname|LOG_DBG\nargument_list|(\nliteral|\"Port %d registered timestamp for %d Delay_Req\"\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|ntohs\n-argument_list|(\n-argument_list|)\n-name|ntohl\n-argument_list|(\n-argument_list|)\n-name|ntohl\n-argument_list|(\n-argument_list|)\nThe issue was with: net: ptp: fix incorrect req_timestamp decoding\n\nRemoved incorrect use of ntoh to decode Delay_Req timestamp"
},{
  "instruction": "There is an issue in the following code. It relates to net: ptp: fix offset check by adding missing int64_t cast\n\nAdd cast to NSEC_PER_SEC macro to correctly check offset.\nPrior to this commit, the would eval to true incorrectly. Please fix this issue.",
  "input": "Faulty tokenized code:\ndecl_stmt|;\nDECL|member|time_src\nname|uint8_t\nname|time_src\ndecl_stmt|;\nDECL|struct|__anon2bc1febb0108\nstruct|struct\nblock|{\nDECL|member|t1\nname|uint64_t\nname|t1\nname|delay\nexpr_stmt|;\ncomment|/* If diff is too big, ptp_clk needs to be set first. */\nif|if\ncondition|(\nname|offset\noperator|>\nname|NSEC_PER_SEC\noperator|||\nname|offset\noperator|<\noperator|-\nname|NSEC_PER_SEC\ncondition|)\nblock|{\nname|struct\nname|net_ptp_time\nname|current",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2bc1febb0108\n+DECL|struct|__anon2b8880430108\n+operator|(\n+operator|(\n+name|int64_t\n+operator|)\n+operator|)\n+operator|(\n+operator|(\n+name|int64_t\n+operator|)\n+operator|)\nThe issue was with: net: ptp: fix offset check by adding missing int64_t cast\n\nAdd cast to NSEC_PER_SEC macro to correctly check offset.\nPrior to this commit, the would eval to true incorrectly."
},{
  "instruction": "There is an issue in the following code. It relates to drivers/input: it8xxx2: Add critical section to prevent race conditions\n\nThe KBS_KSOH1 register contains both keyboard and GPIO output settings.\nNot all bits are for the keyboard will be driven, so a critical section\nis needed to prevent race conditions. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|0xff\ndecl_stmt|;\nname|uint32_t\nname|kso_val\ndecl_stmt|;\ncomment|/* Tri-state all outputs */\nif|if\ncondition|(\nname|col\noperator|==\nname|kso_val\noperator|&\nname|ksol_mask\noperator|)\nexpr_stmt|;\nname|inst\noperator|->\nname|KBS_KSOH1\noperator|=\noperator|(\noperator|)\noperator|&\nname|ksoh1_mask\noperator|)\nexpr_stmt|;\nif|if\ncondition|(\nname|common\noperator|->\nname|col_size",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|unsigned\n+name|int\n+name|key\n+decl_stmt|;\n+comment|/* \t * Disable global interrupts for critical section \t * The KBS_KSOH1 register contains both keyboard and GPIO output settings. \t * Not all bits are for the keyboard will be driven, so a critical section \t * is needed to avoid race conditions. \t */\n+name|key\n+operator|=\n+name|irq_lock\n+argument_list|()\n+expr_stmt|;\n+comment|/* Restore interrupts */\n+name|irq_unlock\n+argument_list|(\n+name|key\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers/input: it8xxx2: Add critical section to prevent race conditions\n\nThe KBS_KSOH1 register contains both keyboard and GPIO output settings.\nNot all bits are for the keyboard will be driven, so a critical section\nis needed to prevent race conditions."
},{
  "instruction": "There is an issue in the following code. It relates to driver: spi: gd32: fix spi reg clear wrong flag\n\nSPI DMATEN and DMAREN flags are in SPI_CTL1 register. fixed wrong register. Please fix this issue.",
  "input": "Faulty tokenized code:\nifdef|#\ndirective|ifdef\nname|CONFIG_SPI_GD32_DMA\nname|dma_error\nlabel|:\nendif|#\ndirective|endif\nname|spi_context_cs_control\nargument_list|(\noperator|&\nargument_list|)\noperator|&=\noperator|~\noperator|(\nname|SPI_CTL0_SPIEN\noperator||\nname|SPI_CTL1_DMATEN\noperator||\nname|SPI_CTL1_DMAREN\noperator|)\nexpr_stmt|;\nname|error\nlabel|:\nname|spi_context_release",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|SPI_CTL1\n+argument_list|(\n+name|cfg\n+operator|->\n+name|reg\n+argument_list|)\n+operator|&=\n+operator|~\n+operator|(\n+name|SPI_CTL1_DMATEN\n+operator||\n+name|SPI_CTL1_DMAREN\n+operator|)\n+expr_stmt|;\n-operator||\n-name|SPI_CTL1_DMATEN\n-operator||\n-name|SPI_CTL1_DMAREN\nThe issue was with: driver: spi: gd32: fix spi reg clear wrong flag\n\nSPI DMATEN and DMAREN flags are in SPI_CTL1 register. fixed wrong register."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: gnss: gnss_u_blox_m10: fix compiler warning\n\nFix warning on implicit declaration of function 'malloc' when compiling\r\ngnss_u_blox_m10.c.\r\n\r Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<string.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|\"gnss_nmea0183.h\"\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<stdlib.h>\n+end_include\n+\nThe issue was with: drivers: gnss: gnss_u_blox_m10: fix compiler warning\n\nFix warning on implicit declaration of function 'malloc' when compiling\r\ngnss_u_blox_m10.c.\r\n\r"
},{
  "instruction": "There is an issue in the following code. It relates to bluetooth: host/classic: Fix possible buffer overflow\n\nFix possible buffer overflow in rfcomm. Check the buffer len\nbefore read it. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|pf\noperator|==\nname|BT_RFCOMM_PF_UIH_CREDIT\ncondition|)\nblock|{\nname|rfcomm_dlc_tx_give_credits\nargument_list|(\nname|dlc\nargument_list|,\nname|net_buf_pull_u8",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|buf\n+operator|->\n+name|len\n+operator|==\n+literal|0\n+condition|)\n+block|{\n+name|LOG_WRN\n+argument_list|(\n+literal|\"Data recvd is invalid\"\n+argument_list|)\n+expr_stmt|;\n+return|return;\n+block|}\nThe issue was with: bluetooth: host/classic: Fix possible buffer overflow\n\nFix possible buffer overflow in rfcomm. Check the buffer len\nbefore read it."
},{
  "instruction": "There is an issue in the following code. It relates to samples: net: txtime: The option type should be int\n\nWhen setting boolean options using setsockopt(), the option\ntype should be int as the size of the option type is checked\nand only int is accepted. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|io_vector\nindex|[\nliteral|1\nindex|]\ndecl_stmt|;\nDECL|union|__anon29d9fd98010a\nunion|union\nblock|{\nDECL|member|hdr\nname|struct\nname|cmsghdr\nname|local\ndecl_stmt|;\nname|socklen_t\nname|addrlen\ndecl_stmt|;\nname|bool\nname|optval\ndecl_stmt|;\nname|uint8_t\nname|priority\ndecl_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon29d9fd98010a\n+DECL|union|__anon2b39784d010a\n-name|bool\n+name|int\nThe issue was with: samples: net: txtime: The option type should be int\n\nWhen setting boolean options using setsockopt(), the option\ntype should be int as the size of the option type is checked\nand only int is accepted."
},{
  "instruction": "There is an issue in the following code. It relates to lib/posix: Get uptime in ticks instead of cycles\n\n__z_clock_nanosleep function was getting current time in cycles, via\nk_cycle_get_32(), to perform its time calculations. However, when calling\nk_sleep() to actually sleep, times are measured in ticks.\n\nThis causes a problem when there's a big skew between the uptime\nmeasured in cycles vs uptime measured in ticks: in some platforms, the\nsystem clock maybe up for a long time already when Zephyr starts\ncounting ticks, for instance, while downloading an image via PXE. In\nthis case, the calculations done inside __z_clock_nanosleep end up\nmeasuring a much bigger current time than expected, thus sleeping too\nmuch, basically all the time since system clock initialization.\n\nThis patch fixes that by avoiding the cycle trip: stick to ticks,\ninstead. They start counting from Zephyr initialization instead, which\nis the expected uptime.\n\nFixes #69608 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|tv_nsec\nexpr_stmt|;\nblock|}\nname|uptime_ns\noperator|=\nname|k_cyc_to_ns_ceil64\nargument_list|(\nname|k_cycle_get_32\nargument_list|()\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|k_cyc_to_ns_ceil64\n+name|k_ticks_to_ns_ceil64\n-name|k_cycle_get_32\n+name|sys_clock_tick_get\nThe issue was with: lib/posix: Get uptime in ticks instead of cycles\n\n__z_clock_nanosleep function was getting current time in cycles, via\nk_cycle_get_32(), to perform its time calculations. However, when calling\nk_sleep() to actually sleep, times are measured in ticks.\n\nThis causes a problem when there's a big skew between the uptime\nmeasured in cycles vs uptime measured in ticks: in some platforms, the\nsystem clock maybe up for a long time already when Zephyr starts\ncounting ticks, for instance, while downloading an image via PXE. In\nthis case, the calculations done inside __z_clock_nanosleep end up\nmeasuring a much bigger current time than expected, thus sleeping too\nmuch, basically all the time since system clock initialization.\n\nThis patch fixes that by avoiding the cycle trip: stick to ticks,\ninstead. They start counting from Zephyr initialization instead, which\nis the expected uptime.\n\nFixes #69608"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: udc_kinetis: add missing return statement\n\nAdd the missing return statement to the branch where no slabs are\navailable. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_struct\nDECL|struct|usbfsotg_bd\nstruct|struct\nname|usbfsotg_bd\nblock|{\nDECL|union|__anon279f3877010a\nunion|union\nblock|{\nDECL|member|bd_fields\nname|uint32_t\nname|bd_fields\ndecl_stmt|;\nDECL|struct|__anon279f38770208\nstruct|struct\nblock|{\nDECL|member|reserved_1_0\nname|uint32_t\nname|reserved_1_0\nDECL|member|__packed\nblock|}\nname|get\nname|__packed\nstruct|;\nDECL|struct|__anon279f38770308\nstruct|struct\nblock|{\nDECL|member|reserved_1_0\nname|uint32_t\nname|reserved_1_0\nname|UDC_EVT_ERROR\nargument_list|,\nname|ret\nargument_list|)\nexpr_stmt|;\nblock|}\nname|ev\noperator|->\nname|dev\noperator|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon279f3877010a\n+DECL|union|__anon29f2efde010a\n-DECL|struct|__anon279f38770208\n+DECL|struct|__anon29f2efde0208\n-DECL|struct|__anon279f38770308\n+DECL|struct|__anon29f2efde0308\n+name|LOG_ERR\n+argument_list|(\n+literal|\"Failed to allocate slab\"\n+argument_list|)\n+expr_stmt|;\n+return|return;\nThe issue was with: drivers: udc_kinetis: add missing return statement\n\nAdd the missing return statement to the branch where no slabs are\navailable."
},{
  "instruction": "There is an issue in the following code. It relates to xtensa: mmu: clear ZSR_DEPC_SAVE at boot\n\nZSR_DEPC_SAVE is being used to determine whether we are faulting\ninside double exception if this is not zero. It is possible that\nthe boot ROM or custom startup code leaves this non-zero, which\nwould result in a fake triple fault. So clear it at boot. Note\nthat the zeroing is done in MMU init code as these triple\nfaults are not actual hardware ones but only semantics, and will\noccur once MMU is enabled.\n\nFixes #75194 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|xtensa_init_paging\nargument_list|(\nname|xtensa_kernel_ptables\nargument_list|)\nexpr_stmt|;\nname|arch_xtensa_mmu_post_init\nargument_list|(\nname|_current_cpu\noperator|->\nname|id",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* \t * This is used to determine whether we are faulting inside double \t * exception if this is not zero. Sometimes SoC starts with this not \t * being set to zero. So clear it during boot. \t */\n+name|XTENSA_WSR\n+argument_list|(\n+name|ZSR_DEPC_SAVE_STR\n+argument_list|,\n+literal|0\n+argument_list|)\n+expr_stmt|;\nThe issue was with: xtensa: mmu: clear ZSR_DEPC_SAVE at boot\n\nZSR_DEPC_SAVE is being used to determine whether we are faulting\ninside double exception if this is not zero. It is possible that\nthe boot ROM or custom startup code leaves this non-zero, which\nwould result in a fake triple fault. So clear it at boot. Note\nthat the zeroing is done in MMU init code as these triple\nfaults are not actual hardware ones but only semantics, and will\noccur once MMU is enabled.\n\nFixes #75194"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: spi: gecko: propagate spi config error\n\nThis commit catch the return code of the spi_config function and\nearly returns on error so that high level spi transfer api gets\nthe error too. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|uint16_t\nname|control\ninit|=\nliteral|0\ndecl_stmt|;\nname|spi_config\nargument_list|(\nname|dev\nargument_list|,\nname|config\nargument_list|,\noperator|&\nname|control\nargument_list|)\nexpr_stmt|;\nname|spi_context_buffers_setup\nargument_list|(\noperator|&\nname|data\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|int\n+name|ret\n+decl_stmt|;\n+name|ret\n+operator|=\n+if|if\n+condition|(\n+name|ret\n+operator|<\n+literal|0\n+condition|)\n+block|{\n+return|return\n+name|ret\n+return|;\n+block|}\nThe issue was with: drivers: spi: gecko: propagate spi config error\n\nThis commit catch the return code of the spi_config function and\nearly returns on error so that high level spi transfer api gets\nthe error too."
},{
  "instruction": "There is an issue in the following code. It relates to debug: no UNALIGNED_ACCESS_SUPPORTED for cortex M0 or M0plus\n\nSet the UNALIGNED_ACCESS_SUPPORTED only for MCU with cortex M\nthat are neither M0 nor M0plus\nCortex M0 or M0plus mcus do not support un-aligned address access Please fix this issue.",
  "input": "Faulty tokenized code:\nname|defined\nargument_list|(\nname|CONFIG_CPU_CORTEX_M\nargument_list|)\noperator|&&\noperator|!\nname|defined\nargument_list|(\nname|CONFIG_CPU_CORTEX_M0\nargument_list|)\nend_if\n\nbegin_define\nDECL|macro|UNALIGNED_ACCESS_SUPPORTED\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n+expr|\\\n+operator|&&\n+expr|\\\n+operator|!\n+name|defined\n+argument_list|(\n+name|CONFIG_CPU_CORTEX_M0PLUS\n+argument_list|)\nThe issue was with: debug: no UNALIGNED_ACCESS_SUPPORTED for cortex M0 or M0plus\n\nSet the UNALIGNED_ACCESS_SUPPORTED only for MCU with cortex M\nthat are neither M0 nor M0plus\nCortex M0 or M0plus mcus do not support un-aligned address access"
},{
  "instruction": "There is an issue in the following code. It relates to tests: lib: cmsis_nn: add missing filter dimension\n\nSpecify the missing filter dimension that was the reason for the v6.0.0\nversion bump. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|.\nname|h\noperator|=\nname|CONV_4_FILTER_Y\nexpr_stmt|;\nname|output_dims\noperator|.\nname|w\noperator|=\nname|CONV_4_OUTPUT_W",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|filter_dims\n+operator|.\n+name|c\n+operator|=\n+name|CONV_4_IN_CH\n+expr_stmt|;\nThe issue was with: tests: lib: cmsis_nn: add missing filter dimension\n\nSpecify the missing filter dimension that was the reason for the v6.0.0\nversion bump."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: udc_dwc: remove rwup flag\n\nThe driver does not implement host_wakeup, remove rwup capability flag. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nname|data\noperator|->\nname|caps\noperator|.\nname|rwup\noperator|=\nname|true\nexpr_stmt|;\nname|data\noperator|->\nname|caps\noperator|.\nname|addr_before_status\noperator|=\nname|true\nexpr_stmt|;\nname|data",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|rwup\n-operator|=\n-name|true\n-expr_stmt|;\n-name|data\n-operator|->\n-name|caps\n-operator|.\nThe issue was with: drivers: udc_dwc: remove rwup flag\n\nThe driver does not implement host_wakeup, remove rwup capability flag."
},{
  "instruction": "There is an issue in the following code. It relates to logging: avoid overflow of package length in log_msg\n\nCheck if the calculated package length exceeds the maximum possible\nvalue.\nFixes #75015 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|plen\noperator|=\nliteral|0\nexpr_stmt|;\nblock|}\nname|size_t\nname|msg_wlen\ninit|=\nname|Z_LOG_MSG_ALIGNED_WLEN\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|plen\n+operator|>\n+name|Z_LOG_MSG_MAX_PACKAGE\n+condition|)\n+block|{\n+name|LOG_WRN\n+argument_list|(\n+literal|\"Message dropped because it exceeds size limitation (%u)\"\n+argument_list|,\n+operator|(\n+name|uint32_t\n+operator|)\n+name|Z_LOG_MSG_MAX_PACKAGE\n+argument_list|)\n+expr_stmt|;\n+return|return;\n+block|}\nThe issue was with: logging: avoid overflow of package length in log_msg\n\nCheck if the calculated package length exceeds the maximum possible\nvalue.\nFixes #75015"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: i2c: stm32: remove redundant new line\n\nLOG_* adds \\\"\\n\\\" by itself.\n\nFixes redundant lines during startup:\n\n```\n[00:00:00.100,000] <inf> i2c_ll_stm32_v2: I2C TIMING = 0xb0f6343d\n\n[00:00:00.100,000] <inf> i2c_ll_stm32_v2: I2C TIMING = 0xb0f6343d\n\n[00:00:00.100,000] <inf> i2c_ll_stm32_v2: I2C TIMING = 0xb0f6343d\n\n[00:00:00.100,000] <inf> i2c_ll_stm32_v2: I2C TIMING = 0xb0f6343d\n\n[00:00:00.100,000] <inf> flash_stm32_qspi: Reading SFDP\n``` Please fix this issue.",
  "input": "Faulty tokenized code:\nname|EINVAL\nreturn|;\nblock|}\nname|LOG_INF\nargument_list|(\nliteral|\"I2C TIMING = 0x%x\\n\"\nargument_list|,\nname|timing\nargument_list|)\nexpr_stmt|;\nname|LL_I2C_SetTiming",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"I2C TIMING = 0x%x\\n\"\n+literal|\"I2C TIMING = 0x%x\"\nThe issue was with: drivers: i2c: stm32: remove redundant new line\n\nLOG_* adds \\\"\\n\\\" by itself.\n\nFixes redundant lines during startup:\n\n```\n[00:00:00.100,000] <inf> i2c_ll_stm32_v2: I2C TIMING = 0xb0f6343d\n\n[00:00:00.100,000] <inf> i2c_ll_stm32_v2: I2C TIMING = 0xb0f6343d\n\n[00:00:00.100,000] <inf> i2c_ll_stm32_v2: I2C TIMING = 0xb0f6343d\n\n[00:00:00.100,000] <inf> i2c_ll_stm32_v2: I2C TIMING = 0xb0f6343d\n\n[00:00:00.100,000] <inf> flash_stm32_qspi: Reading SFDP\n```"
},{
  "instruction": "There is an issue in the following code. It relates to arch: x86: corrected parameter names\n\n- applied the exact parameter names of the interface to implementation Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/*  * N.B.: the API docs don't say anything about returning error values, but  * this function returns -1 if a vector at the specific priority can't be  * allocated. Whether it should simply __ASSERT instead is up for debate.  */\nend_comment\n\nbegin_function\nDECL|function|arch_irq_connect_dynamic (unsigned int irq,unsigned int priority,void (* func)(const void * arg),const void * arg,uint32_t flags)\nname|int\nname|arch_irq_connect_dynamic\nparameter_list|(\nname|unsigned\nname|int\nname|priority\nparameter_list|,\nname|void\nfunction_decl|(\nmodifier|*\nname|func\nfunction_decl|)\nparameter_list|(\nspecifier|const\nname|void\nmodifier|*\nname|arg\nparameter_list|)\nparameter_list|,\nspecifier|const\nname|void\nmodifier|*\nname|arg\nparameter_list|,\nname|uint32_t\nname|flags\nparameter_list|)\nblock|{\nargument_list|(\nname|irq\nargument_list|,\nname|vector\nargument_list|,\nname|func\nargument_list|,\nname|arg\nargument_list|)\nexpr_stmt|;\nblock|}\nname|irq_unlock\nargument_list|(\ncomment|/*  * Map of IRQ numbers to their assigned vectors. On IA32, this is generated  * at build time and defined via the linker script. On Intel64, it's an array.  */\nspecifier|extern\nname|unsigned\nname|char\nname|_irq_to_interrupt_vector\nindex|[]\ndecl_stmt|;\nDECL|macro|Z_IRQ_TO_INTERRUPT_VECTOR (irq)\ndefine|#\ndirective|define\nname|Z_IRQ_TO_INTERRUPT_VECTOR\nname|z_tsc_read\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nDECL|union|__anon2b02656e010a\nunion|union\nblock|{\nDECL|struct|__anon2b02656e0208\nstruct|struct\nblock|{\nDECL|member|lo\nname|uint32_t\nname|lo",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|arch_irq_connect_dynamic (unsigned int irq,unsigned int priority,void (* func)(const void * arg),const void * arg,uint32_t flags)\n+DECL|function|arch_irq_connect_dynamic (unsigned int irq,unsigned int priority,void (* routine)(const void * parameter),const void * parameter,uint32_t flags)\n-name|func\n+name|routine\n-name|arg\n+name|parameter\n-name|arg\n+name|parameter\n-name|func\n+name|routine\n-name|arg\n+name|parameter\n-index|[]\n+index|[\n+name|CONFIG_MAX_IRQ_LINES\n+index|]\n-DECL|union|__anon2b02656e010a\n+DECL|union|__anon2a3470cf010a\n-DECL|struct|__anon2b02656e0208\n+DECL|struct|__anon2a3470cf0208\nThe issue was with: arch: x86: corrected parameter names\n\n- applied the exact parameter names of the interface to implementation"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Tester: Fix issue with initializing adv_params\n\nThe macro was changed to return a const pointer, but the\nBTP use the returned pointer in a non-const way.\n\nModify the usage so that the macro is used to initialize\nthe adv_param instead, and then provide a non-const pointer\nto tester_gap_create_adv_instance. Please fix this issue.",
  "input": "Faulty tokenized code:\ninit|=\nname|rsp\ndecl_stmt|;\nname|struct\nname|bt_le_adv_param\nmodifier|*\nname|param\ninit|=\nname|BT_LE_EXT_ADV_NCONN\ndecl_stmt|;\ncomment|/* Only one local source/BIG supported for now */\nname|struct\nname|btp_bap_broadcast_local_source\nexpr_stmt|;\nname|err\noperator|=\nname|tester_gap_create_adv_instance\nargument_list|(\nname|param\nargument_list|,\nname|BTP_GAP_ADDR_TYPE_IDENTITY\nargument_list|,\nname|base_ad\nname|int\nname|err\ndecl_stmt|;\nname|struct\nname|bt_le_adv_param\nmodifier|*\nname|param\ninit|=\nname|BT_LE_EXT_ADV_NCONN\ndecl_stmt|;\nname|NET_BUF_SIMPLE_DEFINE\nargument_list|(\nname|ad_buf\nexpr_stmt|;\nname|err\noperator|=\nname|tester_gap_create_adv_instance\nargument_list|(\nname|param\nargument_list|,\nname|BTP_GAP_ADDR_TYPE_IDENTITY\nargument_list|,\nname|base_ad",
  "result": "I corrected the issue in the code by changing the following tokens:\n-modifier|*\n+operator|*\n+operator|&\n-modifier|*\n+operator|*\n+operator|&\nThe issue was with: Bluetooth: Tester: Fix issue with initializing adv_params\n\nThe macro was changed to return a const pointer, but the\nBTP use the returned pointer in a non-const way.\n\nModify the usage so that the macro is used to initialize\nthe adv_param instead, and then provide a non-const pointer\nto tester_gap_create_adv_instance."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: spi: litex: add missing include\n\nadd missing include of `soc.h`. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<stdbool.h>\nend_include\n\nbegin_comment\ncomment|/* Helper Functions */\nend_comment\n\nbegin_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<soc.h>\n+end_include\n+\nThe issue was with: drivers: spi: litex: add missing include\n\nadd missing include of `soc.h`."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: spi: mcux_flexcomm: fix invalid dma config for last tx packets.\n\nfixes an incorrect dma configuration. When lpc dma driver was extended\nwith gather/scatter support the spi dma driver stopped working. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|spi_cfg\nargument_list|)\nexpr_stmt|;\nname|blk_cfg\noperator|->\nname|source_gather_en\noperator|=\nliteral|1\nexpr_stmt|;\nname|blk_cfg\noperator|->\nname|source_address\noperator|=\noperator|(\nname|uint32_t\noperator|)\noperator|)\ncondition|)\nblock|{\nname|blk_cfg\noperator|->\nname|source_gather_en\noperator|=\nliteral|1\nexpr_stmt|;\nname|blk_cfg\noperator|->\nname|source_address\noperator|=\noperator|(\nname|uint32_t\noperator|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|source_gather_en\n-operator|=\n-literal|1\n-expr_stmt|;\n-name|blk_cfg\n-operator|->\n-name|source_gather_en\n-operator|=\n-literal|1\n-expr_stmt|;\n-name|blk_cfg\n-operator|->\nThe issue was with: drivers: spi: mcux_flexcomm: fix invalid dma config for last tx packets.\n\nfixes an incorrect dma configuration. When lpc dma driver was extended\nwith gather/scatter support the spi dma driver stopped working."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Audio: Dereference null return value in cap_initiator.c\n\nNull pointer dereferences in functions:\n  bt_cap_initiator_unicast_audio_update (Line 1478)\n  bt_cap_initiator_unicast_audio_stop (Line 1693)\n\nFixes #74729 and #74739 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|get_next_proc_param\nargument_list|(\nname|active_proc\nargument_list|)\nexpr_stmt|;\nname|bap_stream\noperator|=\noperator|&\nname|proc_param\noperator|->\nname|get_next_proc_param\nargument_list|(\nname|active_proc\nargument_list|)\nexpr_stmt|;\nname|bap_stream\noperator|=\noperator|&\nname|proc_param\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|__ASSERT\n+argument_list|(\n+name|proc_param\n+operator|!=\n+name|NULL\n+argument_list|,\n+literal|\"proc is not done, but could not get next proc_param\"\n+argument_list|)\n+expr_stmt|;\n+name|__ASSERT\n+argument_list|(\n+name|proc_param\n+operator|!=\n+name|NULL\n+argument_list|,\n+literal|\"proc is not done, but could not get next proc_param\"\n+argument_list|)\n+expr_stmt|;\nThe issue was with: Bluetooth: Audio: Dereference null return value in cap_initiator.c\n\nNull pointer dereferences in functions:\n  bt_cap_initiator_unicast_audio_update (Line 1478)\n  bt_cap_initiator_unicast_audio_stop (Line 1693)\n\nFixes #74729 and #74739"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Classic: HF_AG: Fix unexpected return\n\nWhen `buf->len` is 0, the function of the while-loop\nwill be returned with error code `-ENOTSUP`.\nThe code block after while-loop cannot be reached\nevent though it is a correct command.\n\nUse `buf->len` as the end condition of the while-loop.\n\nFixes #74730. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nstruct|;\nend_struct\n\nbegin_struct\nDECL|struct|__anon2c752b790108\nspecifier|static\nspecifier|const\nstruct|struct\nblock|{\nDECL|member|name\nname|ag\nargument_list|)\nexpr_stmt|;\nwhile|while\ncondition|(\nname|err\noperator|==\nliteral|0\ncondition|)\nblock|{\nname|err\noperator|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2c752b790108\n+DECL|struct|__anon27af47d40108\n-name|err\n-operator|==\n+name|buf\n+operator|->\n+name|len\n+operator|>\nThe issue was with: Bluetooth: Classic: HF_AG: Fix unexpected return\n\nWhen `buf->len` is 0, the function of the while-loop\nwill be returned with error code `-ENOTSUP`.\nThe code block after while-loop cannot be reached\nevent though it is a correct command.\n\nUse `buf->len` as the end condition of the while-loop.\n\nFixes #74730."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Classic: HF_AG: Fix incorrect status judgment\n\nWrong condition of AG status is used for status\nchecking.\n\nFixes #74727. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nstruct|;\nend_struct\n\nbegin_struct\nDECL|struct|__anon2c87445d0108\nspecifier|static\nspecifier|const\nstruct|struct\nblock|{\nDECL|member|name\noperator|->\nname|call_state\noperator|!=\nname|BT_HFP_CALL_ACTIVE\noperator|)\noperator|||\noperator|(\nname|ag\noperator|->\nname|call_state\noperator|!=",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2c87445d0108\n+DECL|struct|__anon2c752b790108\n-operator|||\n+operator|&&\nThe issue was with: Bluetooth: Classic: HF_AG: Fix incorrect status judgment\n\nWrong condition of AG status is used for status\nchecking.\n\nFixes #74727."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Classic: HF_AG: Fix incorrect status judgment\n\nWrong condition of AG status is used for status\nchecking.\n\nFixes #74726. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nstruct|;\nend_struct\n\nbegin_struct\nDECL|struct|__anon28ed627d0108\nspecifier|static\nspecifier|const\nstruct|struct\nblock|{\nDECL|member|name\noperator|->\nname|call_state\noperator|!=\nname|BT_HFP_CALL_ACTIVE\noperator|)\noperator|||\noperator|(\nname|ag\noperator|->\nname|call_state\noperator|!=",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon28ed627d0108\n+DECL|struct|__anon2c87445d0108\n-operator|||\n+operator|&&\nThe issue was with: Bluetooth: Classic: HF_AG: Fix incorrect status judgment\n\nWrong condition of AG status is used for status\nchecking.\n\nFixes #74726."
},{
  "instruction": "There is an issue in the following code. It relates to drivers/flash/spi_nor: Fix missing check for return value\n\nAdd check for returned value from the call to spi_nor_cmd_write\nin spi_nor_write.\n\nFixes #74775 Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|flag_access_32bit\noperator|)\noperator|)\ndecl_stmt|;\nDECL|union|__anon2946cdc4010a\nunion|union\nblock|{\nDECL|member|u32\nname|uint32_t\nname|u32\noperator|%\nname|page_size\noperator|)\nexpr_stmt|;\nblock|}\nname|spi_nor_cmd_write\nargument_list|(\nname|dev\nargument_list|,\nname|SPI_NOR_CMD_WREN\nargument_list|)\nexpr_stmt|;\nname|ret\noperator|=\nname|spi_nor_cmd_addr_write\nargument_list|(\nname|dev\nname|uint8_t\nname|decl_nph\ninit|=\nliteral|2\ndecl_stmt|;\nDECL|union|__anon2946cdc4020a\nunion|union\nblock|{\ncomment|/* We only process BFP so use one parameter block */\nDECL|member|raw\nname|uint8_t\nname|id\noperator|==\nname|JESD216_SFDP_PARAM_ID_BFP\ncondition|)\nblock|{\nDECL|union|__anon2946cdc4030a\nunion|union\nblock|{\nDECL|member|dw\nname|uint32_t\nname|dw",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon2946cdc4010a\n+DECL|union|__anon2aea0045010a\n+name|ret\n+operator|=\n+if|if\n+condition|(\n+name|ret\n+operator|!=\n+literal|0\n+condition|)\n+block|{\n+break|break;\n+block|}\n-DECL|union|__anon2946cdc4020a\n+DECL|union|__anon2aea0045020a\n-DECL|union|__anon2946cdc4030a\n+DECL|union|__anon2aea0045030a\nThe issue was with: drivers/flash/spi_nor: Fix missing check for return value\n\nAdd check for returned value from the call to spi_nor_cmd_write\nin spi_nor_write.\n\nFixes #74775"
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: tee: Fix normal_call behaviour in tests\n\nDuring SMC_RPC_FUNC_ALLOC call optee driver puts new shm object to a4\nand a5 variables and then expects this object to be in a1 and a2 from\nOP-TEE OS. Fixed behaviour so normal_call callback will act the same\nway as OP-TEE OS Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nname|res\noperator|->\nname|a1\noperator|=\nname|a1\nexpr_stmt|;\nname|res\noperator|->\nname|a2\noperator|=\nname|a2\nexpr_stmt|;\nname|res\noperator|->\nname|a3\noperator|=\nexpr_stmt|;\nname|res\noperator|->\nname|a4\noperator|=\nname|a4\nexpr_stmt|;\nname|res\noperator|->\nname|a5\noperator|=\nname|a5\nexpr_stmt|;\nbreak|break;\ncase|case\nliteral|1\ncase|:",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|a1\n+name|a4\n-name|a2\n+name|a5\n-name|a4\n+literal|0\n-name|a5\n+literal|0\nThe issue was with: tests: drivers: tee: Fix normal_call behaviour in tests\n\nDuring SMC_RPC_FUNC_ALLOC call optee driver puts new shm object to a4\nand a5 variables and then expects this object to be in a1 and a2 from\nOP-TEE OS. Fixed behaviour so normal_call callback will act the same\nway as OP-TEE OS"
},{
  "instruction": "There is an issue in the following code. It relates to modules: mbedtls: Fix init hang issue\n\nIn device init phase, it will call _mbedtls_init before malloc_prepare\nas mbedtls has higher priority defined in SYS_INIT..\n_mbedtls_init() will call psa_crypto_init() and malloc buffer,\nbut z_malloc_heap is not initialized, which will cause device hang.\nShould call malloc_prepare() before _mbedtls_init to fix this issue,\nso decrease the priority of mbedtls to default 40. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|option\noperator|.\nexpr|\"\nend_expr\n\nunit|#endif  static unsigned char _mbedtls_heap[CONFIG_MBEDTLS_HEAP_SIZE];  static void init_heap(void) { \tmbedtls_memory_buffer_alloc_init(_mbedtls_heap, sizeof(_mbedtls_heap)); } #else #define init_heap(...) #endif /* CONFIG_MBEDTLS_ENABLE_HEAP&& MBEDTLS_MEMORY_BUFFER_ALLOC_C */  #if defined(CONFIG_MBEDTLS_ZEPHYR_ENTROPY) static const struct device *const entropy_dev = \t\t\tDEVICE_DT_GET_OR_NULL(DT_CHOSEN(zephyr_entropy));  int mbedtls_hardware_poll(void *data, unsigned char *output, size_t len, \t\t\t  size_t *olen) { \tint ret; \tuint16_t request_len = len> UINT16_MAX ? UINT16_MAX : len;  \tARG_UNUSED(data);  \tif (output == NULL || olen == NULL || len == 0) { \t\treturn MBEDTLS_ERR_ENTROPY_SOURCE_FAILED; \t}  \tif (!IS_ENABLED(CONFIG_ENTROPY_HAS_DRIVER)) { \t\tsys_rand_get(output, len); \t\t*olen = len;  \t\treturn 0; \t}  \tif (!device_is_ready(entropy_dev)) { \t\treturn MBEDTLS_ERR_ENTROPY_SOURCE_FAILED; \t}  \tret = entropy_get_entropy(entropy_dev, (uint8_t *)output, request_len); \tif (ret< 0) { \t\treturn MBEDTLS_ERR_ENTROPY_SOURCE_FAILED; \t}  \t*olen = request_len;  \treturn 0; } #endif /* CONFIG_MBEDTLS_ZEPHYR_ENTROPY */  static int _mbedtls_init(void) {  \tinit_heap();  #if defined(CONFIG_MBEDTLS_DEBUG_LEVEL) \tmbedtls_debug_set_threshold(CONFIG_MBEDTLS_DEBUG_LEVEL); #endif  #if defined(CONFIG_MBEDTLS_PSA_CRYPTO_CLIENT) \tif (psa_crypto_init() != PSA_SUCCESS) { \t\treturn -EIO; \t} #endif  \treturn 0; }  #if defined(CONFIG_MBEDTLS_INIT) SYS_INIT(_mbedtls_init, POST_KERNEL, 0); #endif  /* if CONFIG_MBEDTLS_INIT is not defined then this function  * should be called by the platform before any mbedtls functionality  * is used  */ int mbedtls_init(void) { \treturn _mbedtls_init(); }  /* TLS 1.3 ticket lifetime needs a timing interface */ mbedtls_ms_time_t mbedtls_ms_time(void) { \treturn (mbedtls_ms_time_t)k_uptime_get(); }  #if defined(CONFIG_MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG) /* MBEDTLS_PSA_CRYPTO_C requires a random generator to work and this can  * be achieved through either legacy MbedTLS modules  * (ENTROPY + CTR_DRBG/HMAC_DRBG) or provided externally by enabling the  * CONFIG_MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG. In the latter case the following  * callback functions needs to be defined.  */ psa_status_t mbedtls_psa_external_get_random( \tmbedtls_psa_external_random_context_t *context, \tuint8_t *output, size_t output_size, size_t *output_length) { \t(void) context;  \tif (sys_csrand_get(output, output_size) != 0) { \t\treturn PSA_ERROR_GENERIC_ERROR; \t}  \t*output_length = output_size;  \treturn PSA_SUCCESS; } #endif\nend_unit\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n-unit|#endif  static unsigned char _mbedtls_heap[CONFIG_MBEDTLS_HEAP_SIZE];  static void init_heap(void) { \tmbedtls_memory_buffer_alloc_init(_mbedtls_heap, sizeof(_mbedtls_heap)); } #else #define init_heap(...) #endif /* CONFIG_MBEDTLS_ENABLE_HEAP&& MBEDTLS_MEMORY_BUFFER_ALLOC_C */  #if defined(CONFIG_MBEDTLS_ZEPHYR_ENTROPY) static const struct device *const entropy_dev = \t\t\tDEVICE_DT_GET_OR_NULL(DT_CHOSEN(zephyr_entropy));  int mbedtls_hardware_poll(void *data, unsigned char *output, size_t len, \t\t\t  size_t *olen) { \tint ret; \tuint16_t request_len = len> UINT16_MAX ? UINT16_MAX : len;  \tARG_UNUSED(data);  \tif (output == NULL || olen == NULL || len == 0) { \t\treturn MBEDTLS_ERR_ENTROPY_SOURCE_FAILED; \t}  \tif (!IS_ENABLED(CONFIG_ENTROPY_HAS_DRIVER)) { \t\tsys_rand_get(output, len); \t\t*olen = len;  \t\treturn 0; \t}  \tif (!device_is_ready(entropy_dev)) { \t\treturn MBEDTLS_ERR_ENTROPY_SOURCE_FAILED; \t}  \tret = entropy_get_entropy(entropy_dev, (uint8_t *)output, request_len); \tif (ret< 0) { \t\treturn MBEDTLS_ERR_ENTROPY_SOURCE_FAILED; \t}  \t*olen = request_len;  \treturn 0; } #endif /* CONFIG_MBEDTLS_ZEPHYR_ENTROPY */  static int _mbedtls_init(void) {  \tinit_heap();  #if defined(CONFIG_MBEDTLS_DEBUG_LEVEL) \tmbedtls_debug_set_threshold(CONFIG_MBEDTLS_DEBUG_LEVEL); #endif  #if defined(CONFIG_MBEDTLS_PSA_CRYPTO_CLIENT) \tif (psa_crypto_init() != PSA_SUCCESS) { \t\treturn -EIO; \t} #endif  \treturn 0; }  #if defined(CONFIG_MBEDTLS_INIT) SYS_INIT(_mbedtls_init, POST_KERNEL, 0); #endif  /* if CONFIG_MBEDTLS_INIT is not defined then this function  * should be called by the platform before any mbedtls functionality  * is used  */ int mbedtls_init(void) { \treturn _mbedtls_init(); }  /* TLS 1.3 ticket lifetime needs a timing interface */ mbedtls_ms_time_t mbedtls_ms_time(void) { \treturn (mbedtls_ms_time_t)k_uptime_get(); }  #if defined(CONFIG_MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG) /* MBEDTLS_PSA_CRYPTO_C requires a random generator to work and this can  * be achieved through either legacy MbedTLS modules  * (ENTROPY + CTR_DRBG/HMAC_DRBG) or provided externally by enabling the  * CONFIG_MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG. In the latter case the following  * callback functions needs to be defined.  */ psa_status_t mbedtls_psa_external_get_random( \tmbedtls_psa_external_random_context_t *context, \tuint8_t *output, size_t output_size, size_t *output_length) { \t(void) context;  \tif (sys_csrand_get(output, output_size) != 0) { \t\treturn PSA_ERROR_GENERIC_ERROR; \t}  \t*output_length = output_size;  \treturn PSA_SUCCESS; } #endif\n+unit|#endif  static unsigned char _mbedtls_heap[CONFIG_MBEDTLS_HEAP_SIZE];  static void init_heap(void) { \tmbedtls_memory_buffer_alloc_init(_mbedtls_heap, sizeof(_mbedtls_heap)); } #else #define init_heap(...) #endif /* CONFIG_MBEDTLS_ENABLE_HEAP&& MBEDTLS_MEMORY_BUFFER_ALLOC_C */  #if defined(CONFIG_MBEDTLS_ZEPHYR_ENTROPY) static const struct device *const entropy_dev = \t\t\tDEVICE_DT_GET_OR_NULL(DT_CHOSEN(zephyr_entropy));  int mbedtls_hardware_poll(void *data, unsigned char *output, size_t len, \t\t\t  size_t *olen) { \tint ret; \tuint16_t request_len = len> UINT16_MAX ? UINT16_MAX : len;  \tARG_UNUSED(data);  \tif (output == NULL || olen == NULL || len == 0) { \t\treturn MBEDTLS_ERR_ENTROPY_SOURCE_FAILED; \t}  \tif (!IS_ENABLED(CONFIG_ENTROPY_HAS_DRIVER)) { \t\tsys_rand_get(output, len); \t\t*olen = len;  \t\treturn 0; \t}  \tif (!device_is_ready(entropy_dev)) { \t\treturn MBEDTLS_ERR_ENTROPY_SOURCE_FAILED; \t}  \tret = entropy_get_entropy(entropy_dev, (uint8_t *)output, request_len); \tif (ret< 0) { \t\treturn MBEDTLS_ERR_ENTROPY_SOURCE_FAILED; \t}  \t*olen = request_len;  \treturn 0; } #endif /* CONFIG_MBEDTLS_ZEPHYR_ENTROPY */  static int _mbedtls_init(void) {  \tinit_heap();  #if defined(CONFIG_MBEDTLS_DEBUG_LEVEL) \tmbedtls_debug_set_threshold(CONFIG_MBEDTLS_DEBUG_LEVEL); #endif  #if defined(CONFIG_MBEDTLS_PSA_CRYPTO_CLIENT) \tif (psa_crypto_init() != PSA_SUCCESS) { \t\treturn -EIO; \t} #endif  \treturn 0; }  #if defined(CONFIG_MBEDTLS_INIT) SYS_INIT(_mbedtls_init, POST_KERNEL, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT); #endif  /* if CONFIG_MBEDTLS_INIT is not defined then this function  * should be called by the platform before any mbedtls functionality  * is used  */ int mbedtls_init(void) { \treturn _mbedtls_init(); }  /* TLS 1.3 ticket lifetime needs a timing interface */ mbedtls_ms_time_t mbedtls_ms_time(void) { \treturn (mbedtls_ms_time_t)k_uptime_get(); }  #if defined(CONFIG_MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG) /* MBEDTLS_PSA_CRYPTO_C requires a random generator to work and this can  * be achieved through either legacy MbedTLS modules  * (ENTROPY + CTR_DRBG/HMAC_DRBG) or provided externally by enabling the  * CONFIG_MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG. In the latter case the following  * callback functions needs to be defined.  */ psa_status_t mbedtls_psa_external_get_random( \tmbedtls_psa_external_random_context_t *context, \tuint8_t *output, size_t output_size, size_t *output_length) { \t(void) context;  \tif (sys_csrand_get(output, output_size) != 0) { \t\treturn PSA_ERROR_GENERIC_ERROR; \t}  \t*output_length = output_size;  \treturn PSA_SUCCESS; } #endif\nThe issue was with: modules: mbedtls: Fix init hang issue\n\nIn device init phase, it will call _mbedtls_init before malloc_prepare\nas mbedtls has higher priority defined in SYS_INIT..\n_mbedtls_init() will call psa_crypto_init() and malloc buffer,\nbut z_malloc_heap is not initialized, which will cause device hang.\nShould call malloc_prepare() before _mbedtls_init to fix this issue,\nso decrease the priority of mbedtls to default 40."
},{
  "instruction": "There is an issue in the following code. It relates to libc: common: Fix init hang issue\n\nIn device init phase, it will call _mbedtls_init before malloc_prepare\nas mbedtls has higher priority defined in SYS_INIT..\n_mbedtls_init() will call psa_crypto_init() and malloc buffer,\nbut z_malloc_heap is not initialized, which will cause device hang.\nShould call malloc_prepare() before _mbedtls_init to fix this issue,\nso add new Kconfig to increase the priority of libc to deafult 30. Please fix this issue.",
  "input": "Faulty tokenized code:\n\thelp\n\t  Kernel objects use this priority for initialization. This\n\t  priority needs to be higher than minimal default initialization\n\t  priority.\n\nconfig KERNEL_INIT_PRIORITY_DEFAULT\n\tint \"Default init priority\"\n\tdefault 40\n\thelp\n\t  Default minimal init priority for each init level.\nargument_list|(\nname|malloc_prepare\nargument_list|,\nname|POST_KERNEL\nargument_list|,\nname|CONFIG_KERNEL_INIT_PRIORITY_DEFAULT\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_else\nargument_list|(\nname|malloc_prepare\nargument_list|,\nname|POST_KERNEL\nargument_list|,\nname|CONFIG_KERNEL_INIT_PRIORITY_DEFAULT\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_comment",
  "result": "I corrected the issue in the code by changing the following tokens:\n+config KERNEL_INIT_PRIORITY_LIBC\n+\tint \"LIBC initialization priority\"\n+\tdefault 35\n+\thelp\n+\t  LIBC uses this priority for initialization. This\n+\t  priority needs to be higher than minimal default initialization\n+\t  priority.\n+\n-name|CONFIG_KERNEL_INIT_PRIORITY_DEFAULT\n+name|CONFIG_KERNEL_INIT_PRIORITY_LIBC\n-name|CONFIG_KERNEL_INIT_PRIORITY_DEFAULT\n+name|CONFIG_KERNEL_INIT_PRIORITY_LIBC\nThe issue was with: libc: common: Fix init hang issue\n\nIn device init phase, it will call _mbedtls_init before malloc_prepare\nas mbedtls has higher priority defined in SYS_INIT..\n_mbedtls_init() will call psa_crypto_init() and malloc buffer,\nbut z_malloc_heap is not initialized, which will cause device hang.\nShould call malloc_prepare() before _mbedtls_init to fix this issue,\nso add new Kconfig to increase the priority of libc to deafult 30."
},{
  "instruction": "There is an issue in the following code. It relates to posix: pthread: correct log info of new stack address\n\nWhen a new stack is allocated successfully in pthread_attr_setstacksize,\nthe new address should be printed not the original one. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|+\nname|attr\noperator|->\nname|guardsize\nargument_list|,\nname|attr\noperator|->\nname|stack\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|attr",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|attr\n-operator|->\n-name|stack\n+name|new_stack\nThe issue was with: posix: pthread: correct log info of new stack address\n\nWhen a new stack is allocated successfully in pthread_attr_setstacksize,\nthe new address should be printed not the original one."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: nxp_enet: Fix CID 363724\n\nThis addresses the coverity issue ID 363724.\nThis issue seems to have been a false positive, but the root complaint\nfrom coverity was that within the callstack of ENET_Up, some functions\nuse the buffer config pointer as an array, whereas in the zephyr driver\nit is declared as a singleton. Address it by redeclaring this as an\narray of size 1 instead of a singleton. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|pincfg\ndecl_stmt|;\nDECL|member|buffer_config\nname|enet_buffer_config_t\nname|buffer_config\ndecl_stmt|;\nDECL|member|phy_mode\nname|uint8_t\nname|phy_mode\ndecl_stmt|;\nname|enet_handle\nargument_list|,\noperator|&\nname|enet_config\nargument_list|,\noperator|&\nname|config\noperator|->\nname|buffer_config\nargument_list|,\nname|data\nname|NXP_ENET_MAC_INIT\nparameter_list|(\nname|n\nparameter_list|)\ndefine|\\\nvalue|NXP_ENET_NODE_HAS_MAC_ADDR_CHECK(n)\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tNXP_ENET_NODE_PHY_MODE_CHECK(n)\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tPINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tNXP_ENET_FRAMEINFO_ARRAY(n)\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstatic void nxp_enet_##n##_irq_config_func(void)\t\t\t\\ \t\t{\t\t\t\t\t\t\t\t\t\\ \t\t\tDT_INST_FOREACH_PROP_ELEM(n, interrupt_names,\t\t\t\\ \t\t\t\t\t\tNXP_ENET_CONNECT_IRQ);\t\t\t\\ \t\t}\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tvolatile static __aligned(ENET_BUFF_ALIGNMENT)\t\t\t\t\\ \t\t\t_nxp_enet_dma_desc_section\t\t\t\t\t\\ \t\t\tenet_rx_bd_struct_t\t\t\t\t\t\t\\ \t\t\tnxp_enet_##n##_rx_buffer_desc[CONFIG_ETH_NXP_ENET_RX_BUFFERS];\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tvolatile static __aligned(ENET_BUFF_ALIGNMENT)\t\t\t\t\\ \t\t\t_nxp_enet_dma_desc_section\t\t\t\t\t\\ \t\t\tenet_tx_bd_struct_t\t\t\t\t\t\t\\ \t\t\tnxp_enet_##n##_tx_buffer_desc[CONFIG_ETH_NXP_ENET_TX_BUFFERS];\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstatic uint8_t __aligned(ENET_BUFF_ALIGNMENT)\t\t\t\t\\ \t\t\t_nxp_enet_dma_buffer_section\t\t\t\t\t\\ \t\t\tnxp_enet_##n##_rx_buffer[CONFIG_ETH_NXP_ENET_RX_BUFFERS]\t\\ \t\t\t\t\t\t[ETH_NXP_ENET_BUFFER_SIZE];\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstatic uint8_t __aligned(ENET_BUFF_ALIGNMENT)\t\t\t\t\\ \t\t\t_nxp_enet_dma_buffer_section\t\t\t\t\t\\ \t\t\tnxp_enet_##n##_tx_buffer[CONFIG_ETH_NXP_ENET_TX_BUFFERS]\t\\ \t\t\t\t\t\t[ETH_NXP_ENET_BUFFER_SIZE];\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tconst struct nxp_enet_mac_config nxp_enet_##n##_config = {\t\t\\ \t\t\t.irq_config_func = nxp_enet_##n##_irq_config_func,\t\t\\ \t\t\t.module_dev = DEVICE_DT_GET(DT_INST_PARENT(n)),\t\t\t\\ \t\t\t.clock_dev = DEVICE_DT_GET(DT_CLOCKS_CTLR(DT_INST_PARENT(n))),\t\\ \t\t\t.clock_subsys = (void *)DT_CLOCKS_CELL_BY_IDX(\t\t\t\\ \t\t\t\t\t\tDT_INST_PARENT(n), 0, name),\t\t\\ \t\t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\t\\ \t\t\t.buffer_config = {\t\t\t\t\t\t\\ \t\t\t\t.rxBdNumber = CONFIG_ETH_NXP_ENET_RX_BUFFERS,\t\t\\ \t\t\t\t.txBdNumber = CONFIG_ETH_NXP_ENET_TX_BUFFERS,\t\t\\ \t\t\t\t.rxBuffSizeAlign = ETH_NXP_ENET_BUFFER_SIZE,\t\t\\ \t\t\t\t.txBuffSizeAlign = ETH_NXP_ENET_BUFFER_SIZE,\t\t\\ \t\t\t\t.rxBdStartAddrAlign = nxp_enet_##n##_rx_buffer_desc,\t\\ \t\t\t\t.txBdStartAddrAlign = nxp_enet_##n##_tx_buffer_desc,\t\\ \t\t\t\t.rxBufferAlign = nxp_enet_##n##_rx_buffer[0],\t\t\\ \t\t\t\t.txBufferAlign = nxp_enet_##n##_tx_buffer[0],\t\t\\ \t\t\t\t.rxMaintainEnable = driver_cache_maintain,\t\t\\ \t\t\t\t.txMaintainEnable = driver_cache_maintain,\t\t\\ \t\t\t\tNXP_ENET_FRAMEINFO(n)\t\t\t\t\t\\ \t\t\t},\t\t\t\t\t\t\t\t\\ \t\t\t.phy_mode = NXP_ENET_PHY_MODE(DT_DRV_INST(n)),\t\t\t\\ \t\t\t.phy_dev = DEVICE_DT_GET(DT_INST_PHANDLE(n, phy_handle)),\t\\ \t\t\t.mdio = DEVICE_DT_GET(DT_INST_PHANDLE(n, nxp_mdio)),\t\t\\ \t\t\tNXP_ENET_PTP_DEV(n)\t\t\t\t\t\t\\ \t\t\t.mac_addr_source = NXP_ENET_MAC_ADDR_SOURCE(n),\t\t\t\\ \t\t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstatic _nxp_enet_driver_buffer_section uint8_t\t\t\t\t\\ \t\t\tnxp_enet_##n##_tx_frame_buf[NET_ETH_MAX_FRAME_SIZE];\t\t\\ \t\tstatic _nxp_enet_driver_buffer_section uint8_t\t\t\t\t\\ \t\t\tnxp_enet_##n##_rx_frame_buf[NET_ETH_MAX_FRAME_SIZE];\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstruct nxp_enet_mac_data nxp_enet_##n##_data = {\t\t\t\\ \t\t\t.tx_frame_buf = nxp_enet_##n##_tx_frame_buf,\t\t\t\\ \t\t\t.rx_frame_buf = nxp_enet_##n##_rx_frame_buf,\t\t\t\\ \t\t\t.dev = DEVICE_DT_INST_GET(n),\t\t\t\t\t\\ \t\t\t.mac_addr = DT_INST_PROP_OR(n, local_mac_address, {0}),\t\t\\ \t\t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tETH_NXP_ENET_PM_DEVICE_INIT(n)\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tETH_NET_DEVICE_DT_INST_DEFINE(n, eth_nxp_enet_init,\t\t\t\\ \t\t\t\t\tETH_NXP_ENET_PM_DEVICE_GET(n),\t\t\t\\&nxp_enet_##n##_data,&nxp_enet_##n##_config,\t\\ \t\t\t\t\tCONFIG_ETH_INIT_PRIORITY,\t\t\t\\&api_funcs, NET_ETH_MTU);\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(\nargument|NXP_ENET_MAC_INIT\nargument_list|)\nDECL|struct|nxp_enet_mod_config",
  "result": "I corrected the issue in the code by changing the following tokens:\n+index|[\n+literal|1\n+index|]\n-operator|&\n-value|NXP_ENET_NODE_HAS_MAC_ADDR_CHECK(n)\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tNXP_ENET_NODE_PHY_MODE_CHECK(n)\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tPINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tNXP_ENET_FRAMEINFO_ARRAY(n)\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstatic void nxp_enet_##n##_irq_config_func(void)\t\t\t\\ \t\t{\t\t\t\t\t\t\t\t\t\\ \t\t\tDT_INST_FOREACH_PROP_ELEM(n, interrupt_names,\t\t\t\\ \t\t\t\t\t\tNXP_ENET_CONNECT_IRQ);\t\t\t\\ \t\t}\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tvolatile static __aligned(ENET_BUFF_ALIGNMENT)\t\t\t\t\\ \t\t\t_nxp_enet_dma_desc_section\t\t\t\t\t\\ \t\t\tenet_rx_bd_struct_t\t\t\t\t\t\t\\ \t\t\tnxp_enet_##n##_rx_buffer_desc[CONFIG_ETH_NXP_ENET_RX_BUFFERS];\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tvolatile static __aligned(ENET_BUFF_ALIGNMENT)\t\t\t\t\\ \t\t\t_nxp_enet_dma_desc_section\t\t\t\t\t\\ \t\t\tenet_tx_bd_struct_t\t\t\t\t\t\t\\ \t\t\tnxp_enet_##n##_tx_buffer_desc[CONFIG_ETH_NXP_ENET_TX_BUFFERS];\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstatic uint8_t __aligned(ENET_BUFF_ALIGNMENT)\t\t\t\t\\ \t\t\t_nxp_enet_dma_buffer_section\t\t\t\t\t\\ \t\t\tnxp_enet_##n##_rx_buffer[CONFIG_ETH_NXP_ENET_RX_BUFFERS]\t\\ \t\t\t\t\t\t[ETH_NXP_ENET_BUFFER_SIZE];\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstatic uint8_t __aligned(ENET_BUFF_ALIGNMENT)\t\t\t\t\\ \t\t\t_nxp_enet_dma_buffer_section\t\t\t\t\t\\ \t\t\tnxp_enet_##n##_tx_buffer[CONFIG_ETH_NXP_ENET_TX_BUFFERS]\t\\ \t\t\t\t\t\t[ETH_NXP_ENET_BUFFER_SIZE];\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tconst struct nxp_enet_mac_config nxp_enet_##n##_config = {\t\t\\ \t\t\t.irq_config_func = nxp_enet_##n##_irq_config_func,\t\t\\ \t\t\t.module_dev = DEVICE_DT_GET(DT_INST_PARENT(n)),\t\t\t\\ \t\t\t.clock_dev = DEVICE_DT_GET(DT_CLOCKS_CTLR(DT_INST_PARENT(n))),\t\\ \t\t\t.clock_subsys = (void *)DT_CLOCKS_CELL_BY_IDX(\t\t\t\\ \t\t\t\t\t\tDT_INST_PARENT(n), 0, name),\t\t\\ \t\t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\t\\ \t\t\t.buffer_config = {\t\t\t\t\t\t\\ \t\t\t\t.rxBdNumber = CONFIG_ETH_NXP_ENET_RX_BUFFERS,\t\t\\ \t\t\t\t.txBdNumber = CONFIG_ETH_NXP_ENET_TX_BUFFERS,\t\t\\ \t\t\t\t.rxBuffSizeAlign = ETH_NXP_ENET_BUFFER_SIZE,\t\t\\ \t\t\t\t.txBuffSizeAlign = ETH_NXP_ENET_BUFFER_SIZE,\t\t\\ \t\t\t\t.rxBdStartAddrAlign = nxp_enet_##n##_rx_buffer_desc,\t\\ \t\t\t\t.txBdStartAddrAlign = nxp_enet_##n##_tx_buffer_desc,\t\\ \t\t\t\t.rxBufferAlign = nxp_enet_##n##_rx_buffer[0],\t\t\\ \t\t\t\t.txBufferAlign = nxp_enet_##n##_tx_buffer[0],\t\t\\ \t\t\t\t.rxMaintainEnable = driver_cache_maintain,\t\t\\ \t\t\t\t.txMaintainEnable = driver_cache_maintain,\t\t\\ \t\t\t\tNXP_ENET_FRAMEINFO(n)\t\t\t\t\t\\ \t\t\t},\t\t\t\t\t\t\t\t\\ \t\t\t.phy_mode = NXP_ENET_PHY_MODE(DT_DRV_INST(n)),\t\t\t\\ \t\t\t.phy_dev = DEVICE_DT_GET(DT_INST_PHANDLE(n, phy_handle)),\t\\ \t\t\t.mdio = DEVICE_DT_GET(DT_INST_PHANDLE(n, nxp_mdio)),\t\t\\ \t\t\tNXP_ENET_PTP_DEV(n)\t\t\t\t\t\t\\ \t\t\t.mac_addr_source = NXP_ENET_MAC_ADDR_SOURCE(n),\t\t\t\\ \t\t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstatic _nxp_enet_driver_buffer_section uint8_t\t\t\t\t\\ \t\t\tnxp_enet_##n##_tx_frame_buf[NET_ETH_MAX_FRAME_SIZE];\t\t\\ \t\tstatic _nxp_enet_driver_buffer_section uint8_t\t\t\t\t\\ \t\t\tnxp_enet_##n##_rx_frame_buf[NET_ETH_MAX_FRAME_SIZE];\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstruct nxp_enet_mac_data nxp_enet_##n##_data = {\t\t\t\\ \t\t\t.tx_frame_buf = nxp_enet_##n##_tx_frame_buf,\t\t\t\\ \t\t\t.rx_frame_buf = nxp_enet_##n##_rx_frame_buf,\t\t\t\\ \t\t\t.dev = DEVICE_DT_INST_GET(n),\t\t\t\t\t\\ \t\t\t.mac_addr = DT_INST_PROP_OR(n, local_mac_address, {0}),\t\t\\ \t\t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tETH_NXP_ENET_PM_DEVICE_INIT(n)\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tETH_NET_DEVICE_DT_INST_DEFINE(n, eth_nxp_enet_init,\t\t\t\\ \t\t\t\t\tETH_NXP_ENET_PM_DEVICE_GET(n),\t\t\t\\&nxp_enet_##n##_data,&nxp_enet_##n##_config,\t\\ \t\t\t\t\tCONFIG_ETH_INIT_PRIORITY,\t\t\t\\&api_funcs, NET_ETH_MTU);\n+value|NXP_ENET_NODE_HAS_MAC_ADDR_CHECK(n)\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tNXP_ENET_NODE_PHY_MODE_CHECK(n)\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tPINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tNXP_ENET_FRAMEINFO_ARRAY(n)\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstatic void nxp_enet_##n##_irq_config_func(void)\t\t\t\\ \t\t{\t\t\t\t\t\t\t\t\t\\ \t\t\tDT_INST_FOREACH_PROP_ELEM(n, interrupt_names,\t\t\t\\ \t\t\t\t\t\tNXP_ENET_CONNECT_IRQ);\t\t\t\\ \t\t}\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tvolatile static __aligned(ENET_BUFF_ALIGNMENT)\t\t\t\t\\ \t\t\t_nxp_enet_dma_desc_section\t\t\t\t\t\\ \t\t\tenet_rx_bd_struct_t\t\t\t\t\t\t\\ \t\t\tnxp_enet_##n##_rx_buffer_desc[CONFIG_ETH_NXP_ENET_RX_BUFFERS];\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tvolatile static __aligned(ENET_BUFF_ALIGNMENT)\t\t\t\t\\ \t\t\t_nxp_enet_dma_desc_section\t\t\t\t\t\\ \t\t\tenet_tx_bd_struct_t\t\t\t\t\t\t\\ \t\t\tnxp_enet_##n##_tx_buffer_desc[CONFIG_ETH_NXP_ENET_TX_BUFFERS];\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstatic uint8_t __aligned(ENET_BUFF_ALIGNMENT)\t\t\t\t\\ \t\t\t_nxp_enet_dma_buffer_section\t\t\t\t\t\\ \t\t\tnxp_enet_##n##_rx_buffer[CONFIG_ETH_NXP_ENET_RX_BUFFERS]\t\\ \t\t\t\t\t\t[ETH_NXP_ENET_BUFFER_SIZE];\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstatic uint8_t __aligned(ENET_BUFF_ALIGNMENT)\t\t\t\t\\ \t\t\t_nxp_enet_dma_buffer_section\t\t\t\t\t\\ \t\t\tnxp_enet_##n##_tx_buffer[CONFIG_ETH_NXP_ENET_TX_BUFFERS]\t\\ \t\t\t\t\t\t[ETH_NXP_ENET_BUFFER_SIZE];\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tconst struct nxp_enet_mac_config nxp_enet_##n##_config = {\t\t\\ \t\t\t.irq_config_func = nxp_enet_##n##_irq_config_func,\t\t\\ \t\t\t.module_dev = DEVICE_DT_GET(DT_INST_PARENT(n)),\t\t\t\\ \t\t\t.clock_dev = DEVICE_DT_GET(DT_CLOCKS_CTLR(DT_INST_PARENT(n))),\t\\ \t\t\t.clock_subsys = (void *)DT_CLOCKS_CELL_BY_IDX(\t\t\t\\ \t\t\t\t\t\tDT_INST_PARENT(n), 0, name),\t\t\\ \t\t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\t\\ \t\t\t.buffer_config = {{\t\t\t\t\t\t\\ \t\t\t\t.rxBdNumber = CONFIG_ETH_NXP_ENET_RX_BUFFERS,\t\t\\ \t\t\t\t.txBdNumber = CONFIG_ETH_NXP_ENET_TX_BUFFERS,\t\t\\ \t\t\t\t.rxBuffSizeAlign = ETH_NXP_ENET_BUFFER_SIZE,\t\t\\ \t\t\t\t.txBuffSizeAlign = ETH_NXP_ENET_BUFFER_SIZE,\t\t\\ \t\t\t\t.rxBdStartAddrAlign = nxp_enet_##n##_rx_buffer_desc,\t\\ \t\t\t\t.txBdStartAddrAlign = nxp_enet_##n##_tx_buffer_desc,\t\\ \t\t\t\t.rxBufferAlign = nxp_enet_##n##_rx_buffer[0],\t\t\\ \t\t\t\t.txBufferAlign = nxp_enet_##n##_tx_buffer[0],\t\t\\ \t\t\t\t.rxMaintainEnable = driver_cache_maintain,\t\t\\ \t\t\t\t.txMaintainEnable = driver_cache_maintain,\t\t\\ \t\t\t\tNXP_ENET_FRAMEINFO(n)\t\t\t\t\t\\ \t\t\t}},\t\t\t\t\t\t\t\t\\ \t\t\t.phy_mode = NXP_ENET_PHY_MODE(DT_DRV_INST(n)),\t\t\t\\ \t\t\t.phy_dev = DEVICE_DT_GET(DT_INST_PHANDLE(n, phy_handle)),\t\\ \t\t\t.mdio = DEVICE_DT_GET(DT_INST_PHANDLE(n, nxp_mdio)),\t\t\\ \t\t\tNXP_ENET_PTP_DEV(n)\t\t\t\t\t\t\\ \t\t\t.mac_addr_source = NXP_ENET_MAC_ADDR_SOURCE(n),\t\t\t\\ \t\t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstatic _nxp_enet_driver_buffer_section uint8_t\t\t\t\t\\ \t\t\tnxp_enet_##n##_tx_frame_buf[NET_ETH_MAX_FRAME_SIZE];\t\t\\ \t\tstatic _nxp_enet_driver_buffer_section uint8_t\t\t\t\t\\ \t\t\tnxp_enet_##n##_rx_frame_buf[NET_ETH_MAX_FRAME_SIZE];\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstruct nxp_enet_mac_data nxp_enet_##n##_data = {\t\t\t\\ \t\t\t.tx_frame_buf = nxp_enet_##n##_tx_frame_buf,\t\t\t\\ \t\t\t.rx_frame_buf = nxp_enet_##n##_rx_frame_buf,\t\t\t\\ \t\t\t.dev = DEVICE_DT_INST_GET(n),\t\t\t\t\t\\ \t\t\t.mac_addr = DT_INST_PROP_OR(n, local_mac_address, {0}),\t\t\\ \t\t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tETH_NXP_ENET_PM_DEVICE_INIT(n)\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tETH_NET_DEVICE_DT_INST_DEFINE(n, eth_nxp_enet_init,\t\t\t\\ \t\t\t\t\tETH_NXP_ENET_PM_DEVICE_GET(n),\t\t\t\\&nxp_enet_##n##_data,&nxp_enet_##n##_config,\t\\ \t\t\t\t\tCONFIG_ETH_INIT_PRIORITY,\t\t\t\\&api_funcs, NET_ETH_MTU);\nThe issue was with: drivers: nxp_enet: Fix CID 363724\n\nThis addresses the coverity issue ID 363724.\nThis issue seems to have been a false positive, but the root complaint\nfrom coverity was that within the callstack of ENET_Up, some functions\nuse the buffer config pointer as an array, whereas in the zephyr driver\nit is declared as a singleton. Address it by redeclaring this as an\narray of size 1 instead of a singleton."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: nxp_enet: Fix CID 392512\n\nThis commit fixes coverity issue 392512.\nThe issue was that the return value of clock_control_on was not being\nchecked. Fix by checking the return value. Please fix this issue.",
  "input": "Faulty tokenized code:\ninit|=\nname|dev\noperator|->\nname|config\ndecl_stmt|;\nname|clock_control_on\nargument_list|(\nname|config\noperator|->\nname|clock_dev\nname|config\noperator|->\nname|clock_subsys\nargument_list|)\nexpr_stmt|;\nname|DEVICE_MMIO_MAP\nargument_list|(\nname|dev\nargument_list|,\nname|K_MEM_CACHE_NONE",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|int\n+name|ret\n+decl_stmt|;\n+name|ret\n+operator|=\n+if|if\n+condition|(\n+name|ret\n+condition|)\n+block|{\n+name|LOG_ERR\n+argument_list|(\n+literal|\"ENET module clock error\"\n+argument_list|)\n+expr_stmt|;\n+return|return\n+name|ret\n+return|;\n+block|}\nThe issue was with: drivers: nxp_enet: Fix CID 392512\n\nThis commit fixes coverity issue 392512.\nThe issue was that the return value of clock_control_on was not being\nchecked. Fix by checking the return value."
},{
  "instruction": "There is an issue in the following code. It relates to bluetooth: `bt_le_ext_adv_start_param` is const\n\n`bt_le_ext_adv_start` does not modify the `param` argument, which can\ntherefore be marked as `const`. This allows the struct to exist purely\nin ROM. Please fix this issue.",
  "input": "Faulty tokenized code:\nmodifier|*\nname|output\nparameter_list|)\nfunction_decl|;\ncomment|/** Advertising options */\nDECL|enum|__anon2b1eae440103\nenum|enum\nblock|{\ncomment|/** Convenience value when no options are specified. */\nDECL|enumerator|BT_LE_ADV_OPT_NONE\nname|BT_LE_ADV_OPT_NONE\nname|peer\ndecl_stmt|;\nblock|}\nstruct|;\ncomment|/** Periodic Advertising options */\nDECL|enum|__anon2b1eae440203\nenum|enum\nblock|{\ncomment|/** Convenience value when no options are specified. */\nDECL|enumerator|BT_LE_PER_ADV_OPT_NONE\nname|BT_LE_PER_ADV_OPT_NONE\nname|struct\nname|bt_le_ext_adv\nmodifier|*\nname|adv\nparameter_list|,\nname|struct\nname|bt_le_ext_adv_start_param\nmodifier|*\nname|param\nparameter_list|)\nname|node\ndecl_stmt|;\nblock|}\nstruct|;\ncomment|/** Periodic advertising sync options */\nDECL|enum|__anon2b1eae440303\nenum|enum\nblock|{\ncomment|/** Convenience value when no options are specified. */\nDECL|enumerator|BT_LE_PER_ADV_SYNC_OPT_NONE\nname|BT_LE_PER_ADV_SYNC_OPT_NONE\nmodifier|*\nname|per_adv_sync\nparameter_list|)\nfunction_decl|;\ncomment|/** Periodic Advertising Sync Transfer options */\nDECL|enum|__anon2b1eae440403\nenum|enum\nblock|{\ncomment|/** Convenience value when no options are specified. */\nDECL|enumerator|BT_LE_PER_ADV_SYNC_TRANSFER_OPT_NONE\nname|BT_LE_PER_ADV_SYNC_TRANSFER_OPT_NONE\nname|bt_le_per_adv_list_clear\nparameter_list|(\nname|void\nparameter_list|)\nfunction_decl|;\nDECL|enum|__anon2b1eae440503\nenum|enum\nblock|{\ncomment|/** Convenience value when no options are specified. */\nDECL|enumerator|BT_LE_SCAN_OPT_NONE\nname|BT_LE_SCAN_OPT_NONE\nDECL|macro|BT_LE_SCAN_OPT_FILTER_WHITELIST\ndefine|#\ndirective|define\nname|BT_LE_SCAN_OPT_FILTER_WHITELIST\nvalue|__DEPRECATED_MACRO BT_LE_SCAN_OPT_FILTER_ACCEPT_LIST\nDECL|enum|__anon2b1eae440603\nenum|enum\nblock|{\ncomment|/** Scan without requesting additional information from advertisers. */\nDECL|enumerator|BT_LE_SCAN_TYPE_PASSIVE\nname|BT_LE_SCAN_TYPE_PASSIVE\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|bt_le_ext_adv_start (struct bt_le_ext_adv * adv,struct bt_le_ext_adv_start_param * param)\nname|int\nname|bt_le_ext_adv_start\nparameter_list|(\nname|struct\nname|bt_le_ext_adv\nmodifier|*\nname|adv\nparameter_list|,\nname|struct\nname|bt_le_ext_adv_start_param\nmodifier|*\nname|param\nparameter_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon2b1eae440103\n+DECL|enum|__anon2b908b670103\n-DECL|enum|__anon2b1eae440203\n+DECL|enum|__anon2b908b670203\n+specifier|const\n-DECL|enum|__anon2b1eae440303\n+DECL|enum|__anon2b908b670303\n-DECL|enum|__anon2b1eae440403\n+DECL|enum|__anon2b908b670403\n-DECL|enum|__anon2b1eae440503\n+DECL|enum|__anon2b908b670503\n-DECL|enum|__anon2b1eae440603\n+DECL|enum|__anon2b908b670603\n-DECL|function|bt_le_ext_adv_start (struct bt_le_ext_adv * adv,struct bt_le_ext_adv_start_param * param)\n+DECL|function|bt_le_ext_adv_start (struct bt_le_ext_adv * adv,const struct bt_le_ext_adv_start_param * param)\n+specifier|const\nThe issue was with: bluetooth: `bt_le_ext_adv_start_param` is const\n\n`bt_le_ext_adv_start` does not modify the `param` argument, which can\ntherefore be marked as `const`. This allows the struct to exist purely\nin ROM."
},{
  "instruction": "There is an issue in the following code. It relates to net: dns: Do not fail if cache flush bit is set in class\n\nMask the DNS_CLASS_FLUSH value when checking if the DNS_CLASS_IN\nis set when unpacking a query.\n\nFixes #74829 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|end_of_label\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|query_class\noperator|!=\nname|DNS_CLASS_IN\ncondition|)\nblock|{\nreturn|return",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+operator|&\n+name|DNS_CLASS_IN\n+operator|)\nThe issue was with: net: dns: Do not fail if cache flush bit is set in class\n\nMask the DNS_CLASS_FLUSH value when checking if the DNS_CLASS_IN\nis set when unpacking a query.\n\nFixes #74829"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: usb: device: Fix disable sequece\n\nThis commit should deal with\nfixing the way USB_MCTLR_REG\nis zeroed in order to disable\nthe USB controller along with\nits tranceiver. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|(\nname|reg\nparameter_list|,\nname|field\nparameter_list|)\nvalue|USB->reg |= USB_ ## reg ## _ ## field ## _Msk\nend_define\n\nbegin_define\nDECL|macro|REG_CLR_BIT (reg,field)\ndefine|#\nparameter_list|(\nname|reg\nparameter_list|,\nname|field\nparameter_list|)\nvalue|USB->reg&= ~USB_ ## reg ## _ ## field ## _Msk\nend_define\n\nbegin_define\nDECL|macro|REG_SET_VAL (reg,field,val)\ndefine|#\nname|field\nparameter_list|,\nname|val\nparameter_list|)\ndefine|\\\nvalue|USB->reg = (USB->reg& ~USB_##reg##_##field##_Msk) |               \\ \t\t   (val<< USB_##reg##_##field##_Pos)\nend_define\n\nbegin_function\nDECL|function|usb_smartbond_dma_validate (void)\nspecifier|static\noperator|.\nname|vbus_present\noperator|=\nname|vbus_present\nexpr_stmt|;\nname|USB\noperator|->\nname|USB_MCTRL_REG\noperator|=\nliteral|0",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|USB->reg |= USB_ ## reg ## _ ## field ## _Msk\n+value|(USB->reg |= USB_ ## reg ## _ ## field ## _Msk)\n-value|USB->reg&= ~USB_ ## reg ## _ ## field ## _Msk\n+value|(USB->reg&= ~USB_ ## reg ## _ ## field ## _Msk)\n-value|USB->reg = (USB->reg& ~USB_##reg##_##field##_Msk) |               \\ \t\t   (val<< USB_##reg##_##field##_Pos)\n+value|(USB->reg = (USB->reg& ~USB_##reg##_##field##_Msk) |\t\\ \t\t   (val<< USB_##reg##_##field##_Pos))\n+comment|/* \t\t * It's imperative that USB_NAT bit-field is updated with the \t\t * USBEN bit-field being set. As such, zeroing the control \t\t * register at once will result in leaving the USB tranceivers \t\t * in a floating state. Such an action, will induce incorect \t\t * behavior for subsequent charger detection operations and given \t\t * that the device does not enter the sleep state (thus powering off \t\t * PD_SYS and resetting the controller along with its tranceivers). \t\t */\n+name|REG_CLR_BIT\n+argument_list|(\n+name|USB_MCTRL_REG\n+argument_list|,\n+name|USB_NAT\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: usb: device: Fix disable sequece\n\nThis commit should deal with\nfixing the way USB_MCTLR_REG\nis zeroed in order to disable\nthe USB controller along with\nits tranceiver."
},{
  "instruction": "There is an issue in the following code. It relates to drivers/sensor: lis2mdl: use common SPI duplex option\n\nDriver used a custom SPI duplex option. Replaced with the common one\nfound in spi-device.yaml. Please fix this issue.",
  "input": "Faulty tokenized code:\n\tcs-gpios = <&gpioa 15 GPIO_ACTIVE_LOW>;\n\n\tlis2mdl: lis2mdl@0 {\n\t\tcompatible = \"st,lis2mdl\";\n\t\tspi-max-frequency = <1000000>;\n\t\tspi-full-duplex;\n\t\treg = <0>;\n\t};\n};\n\nzephyr_udc0: &usbotg_fs {\n            pwm-controller;\n            #pwm-cells = <2>;\n        };\n    };\n\nAnalog-to-Digital Converter (ADC)\n=================================\n\nBluetooth HCI\n=============\nbegin_define\nDECL|macro|LIS2MDL_SPI_OPERATION\ndefine|#\ndirective|define\nname|LIS2MDL_SPI_OPERATION\nvalue|(SPI_WORD_SET(8) |\t\t\t\\ \t\t\t\tSPI_OP_MODE_MASTER |\t\t\t\\ \t\t\t\tSPI_MODE_CPOL |\t\t\t\t\\ \t\t\t\tSPI_MODE_CPHA)\t\t\t\t\\  #define LIS2MDL_CONFIG_SPI(inst)\t\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\\ \t\tSTMEMSC_CTX_SPI(&lis2mdl_config_##inst.stmemsc_cfg),\t\\ \t\t.stmemsc_cfg = {\t\t\t\t\t\\ \t\t\t.spi = SPI_DT_SPEC_INST_GET(inst,\t\t\\ \t\t\t\t\t   LIS2MDL_SPI_OPERATION,\t\\ \t\t\t\t\t   0),\t\t\t\t\\ \t\t},\t\t\t\t\t\t\t\\ \t\t.spi_4wires = DT_INST_PROP(inst, spi_full_duplex),\t\\ \t\tLIS2MDL_CONFIG_COMMON(inst)\t\t\t\t\\ \t}\nend_define\n\nbegin_comment\ncomment|/*  * Instantiation macros used when a device is on an I2C bus.  */\nend_comment\n  cancel-offset:\n    type: boolean\n    description: |\n      Set to enable the offset cancellation. Otherwise it would be\n      disabled as default.\n\n spi-full-duplex:\n   type: boolean\n   description: |\n     Enable SPI 4wires mode with separated MISO and MOSI lines",
  "result": "I corrected the issue in the code by changing the following tokens:\n-\t\tspi-full-duplex;\n+* `st,lis2mdl` property `spi-full-duplex` changed to `duplex =\n+  SPI_FULL_DUPLEX`. Full duplex is now the default.\n+\n-value|(SPI_WORD_SET(8) |\t\t\t\\ \t\t\t\tSPI_OP_MODE_MASTER |\t\t\t\\ \t\t\t\tSPI_MODE_CPOL |\t\t\t\t\\ \t\t\t\tSPI_MODE_CPHA)\t\t\t\t\\  #define LIS2MDL_CONFIG_SPI(inst)\t\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\\ \t\tSTMEMSC_CTX_SPI(&lis2mdl_config_##inst.stmemsc_cfg),\t\\ \t\t.stmemsc_cfg = {\t\t\t\t\t\\ \t\t\t.spi = SPI_DT_SPEC_INST_GET(inst,\t\t\\ \t\t\t\t\t   LIS2MDL_SPI_OPERATION,\t\\ \t\t\t\t\t   0),\t\t\t\t\\ \t\t},\t\t\t\t\t\t\t\\ \t\t.spi_4wires = DT_INST_PROP(inst, spi_full_duplex),\t\\ \t\tLIS2MDL_CONFIG_COMMON(inst)\t\t\t\t\\ \t}\n+value|(SPI_WORD_SET(8) |\t\t\t\\ \t\t\t\tSPI_OP_MODE_MASTER |\t\t\t\\ \t\t\t\tSPI_MODE_CPOL |\t\t\t\t\\ \t\t\t\tSPI_MODE_CPHA)\t\t\t\t\\  #define LIS2MDL_CONFIG_SPI(inst)\t\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\\ \t\tSTMEMSC_CTX_SPI(&lis2mdl_config_##inst.stmemsc_cfg),\t\\ \t\t.stmemsc_cfg = {\t\t\t\t\t\\ \t\t\t.spi = SPI_DT_SPEC_INST_GET(inst,\t\t\\ \t\t\t\t\t\tLIS2MDL_SPI_OPERATION,\t\\ \t\t\t\t\t\t0),\t\t\t\\ \t\t},\t\t\t\t\t\t\t\\ \t\t.spi_4wires = DT_INST_PROP(inst, duplex) ==\t\t\\ \t\t\t\t\t\tSPI_FULL_DUPLEX,\t\\ \t\tLIS2MDL_CONFIG_COMMON(inst)\t\t\t\t\\ \t}\n-\n-  spi-full-duplex:\n-    type: boolean\n-    description: |\n-      Enable SPI 4wires mode with separated MISO and MOSI lines\nThe issue was with: drivers/sensor: lis2mdl: use common SPI duplex option\n\nDriver used a custom SPI duplex option. Replaced with the common one\nfound in spi-device.yaml."
},{
  "instruction": "There is an issue in the following code. It relates to libc: minimal: Removed unnecessary casts\n\nRemove two casts since the type was already the same.\nOtherwise, the casts caused a warning with IAR tools. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|z_impl_zephyr_fwrite\nargument_list|(\noperator|(\nspecifier|const\nname|void\noperator|*\nname|ZRESTRICT\noperator|)\nname|ptr\nargument_list|,\nname|size\nargument_list|,\nname|nitems\nargument_list|,\noperator|(\nname|FILE\noperator|*\nname|ZRESTRICT\noperator|)\nname|stream\nargument_list|)\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|(\n-specifier|const\n-name|void\n-operator|*\n-name|ZRESTRICT\n-operator|)\n-operator|(\n-name|FILE\n-operator|*\n-name|ZRESTRICT\n-operator|)\nThe issue was with: libc: minimal: Removed unnecessary casts\n\nRemove two casts since the type was already the same.\nOtherwise, the casts caused a warning with IAR tools."
},{
  "instruction": "There is an issue in the following code. It relates to net: lib: lwm2m: Fix expected block calculation\n\nCoverity reported that a formula used to calculate the next expected\nblock in case the block size from the request differs our own block size\nhas a bug. The expression used to calculate the block size diff would\nevaluate to an unsigned integer, giving (wrongly) enormous results in\ncase block size from the request is smaller than the Zephyr's default.\n\nIt turns out however, that this formula is no longer needed at all.\nSince commit 177ac691593b40ca437ad7647c2947e2172b853d [formerly d3081e2f30fd17a1e737db378d1b1e3cecf53fb2], Zephyr's LwM2M\nimplementation will no longer negotiate the block size in case of write\noperation, but simply comply with the block size included in the\nrequest. This means that calculating the diff makes no longer sense and\ncan be safely removed - the next expected block number should be simply\nincreased by 1. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|last_block\noperator|=\nname|last_block\nexpr_stmt|;\ncomment|/* Initial block sent by the server might be larger or smaller than \t\t * our block size, therefore it is needed to take this into account \t\t * when calculating next expected block number. \t\t */\nname|block_ctx\noperator|->\nname|expected\noperator|+=\nliteral|1\noperator|<<\nname|MAX\nargument_list|(\nliteral|0\nargument_list|,\nname|GET_BLOCK_SIZE\nargument_list|(\nname|block_opt\nargument_list|)\noperator|-\nname|block_ctx\noperator|->\nname|ctx\noperator|.\nname|block_size\nargument_list|)\nexpr_stmt|;\nblock|}\nname|r\noperator|=\nname|do_write_op",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* Initial block sent by the server might be larger or smaller than \t\t * our block size, therefore it is needed to take this into account \t\t * when calculating next expected block number. \t\t */\n-operator|+=\n-literal|1\n-operator|<<\n-name|MAX\n-argument_list|(\n-literal|0\n-argument_list|,\n-name|GET_BLOCK_SIZE\n-argument_list|(\n-name|block_opt\n-argument_list|)\n-operator|-\n-name|block_ctx\n-operator|->\n-name|ctx\n-operator|.\n-name|block_size\n-argument_list|)\n+operator|++\nThe issue was with: net: lib: lwm2m: Fix expected block calculation\n\nCoverity reported that a formula used to calculate the next expected\nblock in case the block size from the request differs our own block size\nhas a bug. The expression used to calculate the block size diff would\nevaluate to an unsigned integer, giving (wrongly) enormous results in\ncase block size from the request is smaller than the Zephyr's default.\n\nIt turns out however, that this formula is no longer needed at all.\nSince commit 177ac691593b40ca437ad7647c2947e2172b853d [formerly d3081e2f30fd17a1e737db378d1b1e3cecf53fb2], Zephyr's LwM2M\nimplementation will no longer negotiate the block size in case of write\noperation, but simply comply with the block size included in the\nrequest. This means that calculating the diff makes no longer sense and\ncan be safely removed - the next expected block number should be simply\nincreased by 1."
},{
  "instruction": "There is an issue in the following code. It relates to net: shell: udp: Check net_pkt_read_u8 result\n\nIn case packet read fails for any reason, there's no point proceeding or\nprinting the byte, just break the loop in such case. Please fix this issue.",
  "input": "Faulty tokenized code:\ncondition|;\noperator|++\nname|i\ncontrol|)\nblock|{\nname|net_pkt_read_u8\nargument_list|(\nname|pkt\nargument_list|,\noperator|&\nname|byte\nargument_list|)\nexpr_stmt|;\nname|PR_SHELL\nargument_list|(\nname|udp_shell\nargument_list|,\nliteral|\"%02x \"",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n-expr_stmt|;\n+operator|<\n+literal|0\n+condition|)\n+block|{\n+break|break;\n+block|}\nThe issue was with: net: shell: udp: Check net_pkt_read_u8 result\n\nIn case packet read fails for any reason, there's no point proceeding or\nprinting the byte, just break the loop in such case."
},{
  "instruction": "There is an issue in the following code. It relates to net: sockets: tls: Fix iov_len comparison in sendmsg()\n\nvec->iov_len is of type size_t, so the comparison was always true.\nAdditionally, doing the memcpy() when iov_len was 0 did not really make\nsense, so do it only when the actual length is larger than 0. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|k_mutex\nmodifier|*\nname|lock\ndecl_stmt|;\ncomment|/** TLS specific option values. */\nDECL|struct|__anon2b53560f0108\nstruct|struct\nblock|{\ncomment|/** Select which credentials to use with TLS. */\nDECL|member|sec_tag_list\nname|struct\nif|if\ncondition|(\nname|vec\noperator|->\nname|iov_len\noperator|>=\nliteral|0\ncondition|)\nblock|{\nif|if\ncondition|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2b53560f0108\n+DECL|struct|__anon297c8a910108\n-operator|>=\n+operator|>\nThe issue was with: net: sockets: tls: Fix iov_len comparison in sendmsg()\n\nvec->iov_len is of type size_t, so the comparison was always true.\nAdditionally, doing the memcpy() when iov_len was 0 did not really make\nsense, so do it only when the actual length is larger than 0."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: shell: Fix missing check for buffer allocation\n\nIn practice this allocation is very unlikely to fail, however being\nconsistent with checking for a failure keeps Coverity happy. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|CONFIG_BT_BROADCASTER\nargument_list|)\nend_if\n\nbegin_enum\nDECL|enum|__anon2b8a96a20103\nenum|enum\nblock|{\nDECL|enumerator|SHELL_ADV_OPT_CONNECTABLE\nname|SHELL_ADV_OPT_CONNECTABLE\nblock|,\nargument_list|)\nargument_list|,\nname|len\nargument_list|)\nexpr_stmt|;\nname|net_buf_add_mem\nargument_list|(\nname|buf\nargument_list|,\nname|hex_data",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon2b8a96a20103\n+DECL|enum|__anon2ad3a0fc0103\n+if|if\n+condition|(\n+name|buf\n+operator|==\n+name|NULL\n+condition|)\n+block|{\n+name|shell_error\n+argument_list|(\n+name|sh\n+argument_list|,\n+literal|\"Unable to allocate HCI buffer\"\n+argument_list|)\n+expr_stmt|;\n+return|return\n+operator|-\n+name|ENOMEM\n+return|;\n+block|}\nThe issue was with: Bluetooth: shell: Fix missing check for buffer allocation\n\nIn practice this allocation is very unlikely to fail, however being\nconsistent with checking for a failure keeps Coverity happy."
},{
  "instruction": "There is an issue in the following code. It relates to net: lib: dhcpv4_server: Fix client ID bug\n\nFirst byte of client ID should be htype, followed by the client address.\nSee: https://datatracker.ietf.org/doc/html/rfc1533#section-9.12 Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|=\nname|msg\noperator|->\nname|htype\nexpr_stmt|;\nname|client_id\noperator|->\nname|buf\nindex|[\nliteral|1\nindex|]\noperator|=\nname|msg\noperator|->\nname|hlen\nexpr_stmt|;\nname|memcpy\nargument_list|(\nname|client_id\noperator|->\nname|buf\noperator|+\nliteral|2\nargument_list|,\nname|msg\noperator|->\nname|chaddr\nargument_list|,\noperator|=\nname|msg\noperator|->\nname|hlen\noperator|+\nliteral|2\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|client_id\n-operator|->\n-name|buf\n-index|[\n-literal|1\n-index|]\n-operator|=\n-name|msg\n-operator|->\n-name|hlen\n-expr_stmt|;\n-literal|2\n+literal|1\n-literal|2\n+literal|1\nThe issue was with: net: lib: dhcpv4_server: Fix client ID bug\n\nFirst byte of client ID should be htype, followed by the client address.\nSee: https://datatracker.ietf.org/doc/html/rfc1533#section-9.12"
},{
  "instruction": "There is an issue in the following code. It relates to net: tcp: Fix peer pointer use in net_tcp_endpoint_copy()\n\nnet_tcp_endpoint_copy() used wrong pointer to copy peer address. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|NULL\ncondition|)\nblock|{\nname|memcpy\nargument_list|(\nname|local\nargument_list|,\noperator|&\nname|conn\noperator|->\nname|dst\nparameter_list|,\nname|uint16_t\nname|dport\nparameter_list|)\nblock|{\nDECL|struct|__anon2af366520108\nstruct|struct\nblock|{\nDECL|member|key\nname|uint8_t\nname|key\nparameter_list|,\nname|uint16_t\nname|dport\nparameter_list|)\nblock|{\nDECL|struct|__anon2af366520208\nstruct|struct\nblock|{\nDECL|member|key\nname|uint8_t\nname|key",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|local\n+name|peer\n-DECL|struct|__anon2af366520108\n+DECL|struct|__anon296ecf660108\n-DECL|struct|__anon2af366520208\n+DECL|struct|__anon296ecf660208\nThe issue was with: net: tcp: Fix peer pointer use in net_tcp_endpoint_copy()\n\nnet_tcp_endpoint_copy() used wrong pointer to copy peer address."
},{
  "instruction": "There is an issue in the following code. It relates to posix: signal: use the provided argument in the macros\n\nThe `SIGNO_WORD_IDX` & `SIGNO_WORD_BIT` macros should have\nused its own argument `_signo` instead of `signo`. It didn't\ncause and error because the function's argument has `signo`. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|SIGNO_WORD_IDX\nparameter_list|(\nname|_signo\nparameter_list|)\nvalue|(signo / BITS_PER_LONG)\nend_define\n\nbegin_define\nDECL|macro|SIGNO_WORD_BIT (_signo)\ndefine|#\ndirective|define\nname|SIGNO_WORD_BIT\nparameter_list|(\nname|_signo\nparameter_list|)\nvalue|(signo& BIT_MASK(LOG2(BITS_PER_LONG)))\nend_define\n\nbegin_expr_stmt\nname|BUILD_ASSERT\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|(signo / BITS_PER_LONG)\n+value|(_signo / BITS_PER_LONG)\n-value|(signo& BIT_MASK(LOG2(BITS_PER_LONG)))\n+value|(_signo& BIT_MASK(LOG2(BITS_PER_LONG)))\nThe issue was with: posix: signal: use the provided argument in the macros\n\nThe `SIGNO_WORD_IDX` & `SIGNO_WORD_BIT` macros should have\nused its own argument `_signo` instead of `signo`. It didn't\ncause and error because the function's argument has `signo`."
},{
  "instruction": "There is an issue in the following code. It relates to intel_adsp/ace: power: Use MMU reinit API on core context restore\n\nReplace the MMU initialization call with the new MMU re-initialization\nAPI during the core context restore process in the ACE power management\ncode.\n\nThe previous code was directly calling `xtensa_mmu_init()` upon\nrestoring the core context, which is not appropriate when the MMU\ncontext may have been preserved during low-power states. The new\n`xtensa_mmu_reinit()` API is designed to re-establish the MMU context\nwithout overwriting the existing page table, ensuring that any runtime\nchanges to the MMU configuration are retained.\n\nChanges made in this patch:\n- Removed the call to `xtensa_mmu_init()` from the\n  `_restore_core_context()` function.\n- Added a call to `xtensa_mmu_reinit()` after restoring the\n  miscellaneous registers.\n\nThis update aligns the ACE power management code with the correct MMU\nhandling procedures when recovering from low-power states, as per the\nrecent changes in the Xtensa MMU support. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|core_id\ninit|=\nname|arch_proc_id\nargument_list|()\ndecl_stmt|;\nifdef|#\ndirective|ifdef\nname|CONFIG_XTENSA_MMU\nname|xtensa_mmu_init\nargument_list|()\nexpr_stmt|;\nendif|#\ndirective|endif\nname|XTENSA_WSR\nargument_list|(\nliteral|\"PS\"\nargument_list|,\nname|core_desc\nindex|]\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\nasm|__asm__\nspecifier|volatile\nasm|(\"mov a0, %0\" :: \"r\"(core_desc[core_id].a0));\nasm|__asm__\nspecifier|volatile",
  "result": "I corrected the issue in the code by changing the following tokens:\n-ifdef|#\n-directive|ifdef\n-name|CONFIG_XTENSA_MMU\n-name|xtensa_mmu_init\n-argument_list|()\n-expr_stmt|;\n-endif|#\n-directive|endif\n+ifdef|#\n+directive|ifdef\n+name|CONFIG_XTENSA_MMU\n+name|xtensa_mmu_reinit\n+argument_list|()\n+expr_stmt|;\n+endif|#\n+directive|endif\nThe issue was with: intel_adsp/ace: power: Use MMU reinit API on core context restore\n\nReplace the MMU initialization call with the new MMU re-initialization\nAPI during the core context restore process in the ACE power management\ncode.\n\nThe previous code was directly calling `xtensa_mmu_init()` upon\nrestoring the core context, which is not appropriate when the MMU\ncontext may have been preserved during low-power states. The new\n`xtensa_mmu_reinit()` API is designed to re-establish the MMU context\nwithout overwriting the existing page table, ensuring that any runtime\nchanges to the MMU configuration are retained.\n\nChanges made in this patch:\n- Removed the call to `xtensa_mmu_init()` from the\n  `_restore_core_context()` function.\n- Added a call to `xtensa_mmu_reinit()` after restoring the\n  miscellaneous registers.\n\nThis update aligns the ACE power management code with the correct MMU\nhandling procedures when recovering from low-power states, as per the\nrecent changes in the Xtensa MMU support."
},{
  "instruction": "There is an issue in the following code. It relates to samples: net: sockets: echo_client/server: Bump ZVFS_OPEN_MAX config\n\nRecent POSIX changes caused that 3 file descriptors are now preallocated\nfor stdin/out/err. This caused file descriptor shortage in all-in TLS\nconfiguration of the sample, hence increase the maximum FD count.\n\nIn the server sample this manifested itself as an accept() error. This\ntriggered a busy loop though in the sample, as in case of accept()\nerrors it'd just try again w/o any delay. This made this issue hard to\ninvestigate, so to avoid such cases in the future, make the accept()\nfailure fatal in the echo_server sample. Please fix this issue.",
  "input": "Faulty tokenized code:\n\nCONFIG_NET_SOCKETS_SOCKOPT_TLS=y\nCONFIG_NET_SOCKETS_TLS_MAX_CONTEXTS=4\nCONFIG_NET_SOCKETS_ENABLE_DTLS=y\nCONFIG_NET_SOCKETS_DTLS_MAX_FRAGMENT_LENGTH=2048\nCONFIG_ZVFS_OPEN_MAX=8\nCONFIG_NET_SOCKETS_SOCKOPT_TLS=y\nCONFIG_NET_SOCKETS_TLS_MAX_CONTEXTS=6\nCONFIG_NET_SOCKETS_ENABLE_DTLS=y\nCONFIG_NET_SOCKETS_DTLS_TIMEOUT=30000\nCONFIG_NET_SOCKETS_DTLS_MAX_FRAGMENT_LENGTH=2048\nCONFIG_ZVFS_OPEN_MAX=16\noperator|-\nname|errno\nargument_list|)\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}\nname|slot\noperator|=\nname|get_free_slot",
  "result": "I corrected the issue in the code by changing the following tokens:\n-CONFIG_ZVFS_OPEN_MAX=8\n+CONFIG_ZVFS_OPEN_MAX=12\n-CONFIG_ZVFS_OPEN_MAX=16\n+CONFIG_ZVFS_OPEN_MAX=20\n-literal|0\n+operator|-\n+name|errno\nThe issue was with: samples: net: sockets: echo_client/server: Bump ZVFS_OPEN_MAX config\n\nRecent POSIX changes caused that 3 file descriptors are now preallocated\nfor stdin/out/err. This caused file descriptor shortage in all-in TLS\nconfiguration of the sample, hence increase the maximum FD count.\n\nIn the server sample this manifested itself as an accept() error. This\ntriggered a busy loop though in the sample, as in case of accept()\nerrors it'd just try again w/o any delay. This made this issue hard to\ninvestigate, so to avoid such cases in the future, make the accept()\nfailure fatal in the echo_server sample."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: modem: cellular: correct user DLCI channels\n\nThe supported modems don't have the same number or assignment\nof DLCI channels. For example, the NRF91_SLM only has DLCI\nchannel 3 assigned to GNSS tunneling, where the ublox sara r5\nhas DLCI 3 assigned to an additional AT channel, and DLCI 4\nassigned to GNSS tunneling.\n\nThis commit updates the creation and assignment of DLCI\nchannels and pipelinks to match the capabilties of each modem. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|MODEM_CELLULAR_DEVICE_QUECTEL_BG95\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 64);                 \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\",                                                            \\ \t\t.chat_filter = \"\\n\",                                                               \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tgnss_pipe,                                                                         \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_0,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_1,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, gnss_pipe, 3),                                 \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_0, 4),                               \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_1, 5),                               \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.power_pulse_duration_ms = 1500,                                                   \\ \t\t.reset_pulse_duration_ms = 100,                                                    \\ \t\t.startup_time_ms = 10000,                                                          \\ \t\t.shutdown_time_ms = 5000,                                                          \\ \t\t.init_chat_script =&quectel_bg95_init_chat_script,                                \\ \t\t.dial_chat_script =&quectel_bg95_dial_chat_script,                                \\ \t\t.periodic_chat_script =&_CONCAT(DT_DRV_COMPAT, _periodic_chat_script),            \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\nend_define\n\nbegin_define\nDECL|macro|MODEM_CELLULAR_DEVICE_QUECTEL_EG25_G (inst)\ndefine|#\nname|MODEM_CELLULAR_DEVICE_QUECTEL_EG25_G\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 64);                 \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\",                                                            \\ \t\t.chat_filter = \"\\n\",                                                               \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tgnss_pipe,                                                                         \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_0,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_1,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, gnss_pipe, 3),                                 \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_0, 4),                               \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_1, 5),                               \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.power_pulse_duration_ms = 1500,                                                   \\ \t\t.reset_pulse_duration_ms = 500,                                                    \\ \t\t.startup_time_ms = 15000,                                                          \\ \t\t.shutdown_time_ms = 5000,                                                          \\ \t\t.init_chat_script =&quectel_eg25_g_init_chat_script,                              \\ \t\t.dial_chat_script =&quectel_eg25_g_dial_chat_script,                              \\ \t\t.periodic_chat_script =&_CONCAT(DT_DRV_COMPAT, _periodic_chat_script),            \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\nend_define\n\nbegin_define\nDECL|macro|MODEM_CELLULAR_DEVICE_SIMCOM_SIM7080 (inst)\ndefine|#\nname|MODEM_CELLULAR_DEVICE_SIMCOM_SIM7080\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 64);                 \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\",                                                            \\ \t\t.chat_filter = \"\\n\",                                                               \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tgnss_pipe,                                                                         \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_0,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_1,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, gnss_pipe, 3),                                 \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_0, 4),                               \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_1, 5),                               \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.power_pulse_duration_ms = 1500,                                                   \\ \t\t.reset_pulse_duration_ms = 100,                                                    \\ \t\t.startup_time_ms = 10000,                                                          \\ \t\t.shutdown_time_ms = 5000,                                                          \\ \t\t.init_chat_script =&simcom_sim7080_init_chat_script,                              \\ \t\t.dial_chat_script =&simcom_sim7080_dial_chat_script,                              \\ \t\t.periodic_chat_script =&simcom_sim7080_periodic_chat_script,                      \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\nend_define\n\nbegin_define\nDECL|macro|MODEM_CELLULAR_DEVICE_U_BLOX_SARA_R4 (inst)\ndefine|#\nname|MODEM_CELLULAR_DEVICE_U_BLOX_SARA_R4\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 64);                 \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\",                                                            \\ \t\t.chat_filter = \"\\n\",                                                               \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tgnss_pipe,                                                                         \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_0,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_1,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, gnss_pipe, 3),                                 \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_0, 4),                               \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_1, 5),                               \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.power_pulse_duration_ms = 1500,                                                   \\ \t\t.reset_pulse_duration_ms = 100,                                                    \\ \t\t.startup_time_ms = 10000,                                                          \\ \t\t.shutdown_time_ms = 5000,                                                          \\ \t\t.init_chat_script =&u_blox_sara_r4_init_chat_script,                              \\ \t\t.dial_chat_script =&u_blox_sara_r4_dial_chat_script,                              \\ \t\t.periodic_chat_script =&u_blox_sara_r4_periodic_chat_script,                      \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\nend_define\n\nbegin_define\nDECL|macro|MODEM_CELLULAR_DEVICE_U_BLOX_SARA_R5 (inst)\ndefine|#\nname|MODEM_CELLULAR_DEVICE_U_BLOX_SARA_R5\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 64);                 \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\",                                                            \\ \t\t.chat_filter = \"\\n\",                                                               \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tgnss_pipe,                                                                         \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_0,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_1,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, gnss_pipe, 3),                                 \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_0, 4),                               \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_1, 5),                               \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.autostarts = true,                                                                \\ \t\t.power_pulse_duration_ms = 1500,                                                   \\ \t\t.reset_pulse_duration_ms = 100,                                                    \\ \t\t.startup_time_ms = 1500,                                                           \\ \t\t.shutdown_time_ms = 13000,                                                         \\ \t\t.init_chat_script =&u_blox_sara_r5_init_chat_script,                              \\ \t\t.dial_chat_script =&u_blox_sara_r5_dial_chat_script,                              \\ \t\t.periodic_chat_script =&u_blox_sara_r5_periodic_chat_script,                      \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\nend_define\n\nbegin_define\nDECL|macro|MODEM_CELLULAR_DEVICE_SWIR_HL7800 (inst)\ndefine|#\nname|MODEM_CELLULAR_DEVICE_SWIR_HL7800\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 64);                 \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\",                                                            \\ \t\t.chat_filter = \"\\n\",                                                               \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tgnss_pipe,                                                                         \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_0,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_1,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, gnss_pipe, 3),                                 \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_0, 4),                               \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_1, 5),                               \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.power_pulse_duration_ms = 1500,                                                   \\ \t\t.reset_pulse_duration_ms = 100,                                                    \\ \t\t.startup_time_ms = 10000,                                                          \\ \t\t.shutdown_time_ms = 5000,                                                          \\ \t\t.init_chat_script =&swir_hl7800_init_chat_script,                                 \\ \t\t.dial_chat_script =&swir_hl7800_dial_chat_script,                                 \\ \t\t.periodic_chat_script =&swir_hl7800_periodic_chat_script,                         \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\nend_define\n\nbegin_define\nDECL|macro|MODEM_CELLULAR_DEVICE_TELIT_ME910G1 (inst)\ndefine|#\nname|MODEM_CELLULAR_DEVICE_TELIT_ME910G1\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 64);                 \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\",                                                            \\ \t\t.chat_filter = \"\\n\",                                                               \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tgnss_pipe,                                                                         \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_0,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_1,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, gnss_pipe, 3),                                 \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_0, 4),                               \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_1, 5),                               \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.power_pulse_duration_ms = 5050,                                                   \\ \t\t.reset_pulse_duration_ms = 250,                                                    \\ \t\t.startup_time_ms = 15000,                                                          \\ \t\t.shutdown_time_ms = 5000,                                                          \\ \t\t.init_chat_script =&telit_me910g1_init_chat_script,                               \\ \t\t.dial_chat_script =&telit_me910g1_dial_chat_script,                               \\ \t\t.periodic_chat_script =&telit_me910g1_periodic_chat_script,                       \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\nend_define\n\nbegin_define\nDECL|macro|MODEM_CELLULAR_DEVICE_NORDIC_NRF91_SLM (inst)\ndefine|#\nname|MODEM_CELLULAR_DEVICE_NORDIC_NRF91_SLM\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 1500);               \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\\n\",                                                          \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tgnss_pipe,                                                                         \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_0,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_1,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, gnss_pipe, 3),                                 \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_0, 4),                               \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_1, 5),                               \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.power_pulse_duration_ms = 100,                                                    \\ \t\t.reset_pulse_duration_ms = 100,                                                    \\ \t\t.startup_time_ms = 2000,                                                           \\ \t\t.shutdown_time_ms = 10000,                                                         \\ \t\t.init_chat_script =&nordic_nrf91_slm_init_chat_script,                            \\ \t\t.dial_chat_script =&nordic_nrf91_slm_dial_chat_script,                            \\ \t\t.periodic_chat_script =&nordic_nrf91_slm_periodic_chat_script,                    \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\nend_define\n\nbegin_define\nDECL|macro|MODEM_CELLULAR_DEVICE_SQN_GM02S (inst)\ndefine|#\nname|MODEM_CELLULAR_DEVICE_SQN_GM02S\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 64);                 \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\",                                                            \\ \t\t.chat_filter = \"\\n\",                                                               \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tgnss_pipe,                                                                         \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_0,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_1,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, gnss_pipe, 3),                                 \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_0, 4),                               \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_1, 5),                               \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.autostarts = true,                                                                \\ \t\t.power_pulse_duration_ms = 1500,                                                   \\ \t\t.reset_pulse_duration_ms = 100,                                                    \\ \t\t.startup_time_ms = 2000,                                                           \\ \t\t.shutdown_time_ms = 5000,                                                          \\ \t\t.init_chat_script =&sqn_gm02s_init_chat_script,                                   \\ \t\t.dial_chat_script =&sqn_gm02s_dial_chat_script,                                   \\ \t\t.periodic_chat_script =&sqn_gm02s_periodic_chat_script,                           \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\nend_define\n\nbegin_define\nDECL|macro|DT_DRV_COMPAT\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 64);                 \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\",                                                            \\ \t\t.chat_filter = \"\\n\",                                                               \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tgnss_pipe,                                                                         \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_0,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_1,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, gnss_pipe, 3),                                 \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_0, 4),                               \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_1, 5),                               \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.power_pulse_duration_ms = 1500,                                                   \\ \t\t.reset_pulse_duration_ms = 100,                                                    \\ \t\t.startup_time_ms = 10000,                                                          \\ \t\t.shutdown_time_ms = 5000,                                                          \\ \t\t.init_chat_script =&quectel_bg95_init_chat_script,                                \\ \t\t.dial_chat_script =&quectel_bg95_dial_chat_script,                                \\ \t\t.periodic_chat_script =&_CONCAT(DT_DRV_COMPAT, _periodic_chat_script),            \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\n+value|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 64);                 \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\",                                                            \\ \t\t.chat_filter = \"\\n\",                                                               \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_0,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_1,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_0, 3),                               \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_1, 4),                               \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.power_pulse_duration_ms = 1500,                                                   \\ \t\t.reset_pulse_duration_ms = 100,                                                    \\ \t\t.startup_time_ms = 10000,                                                          \\ \t\t.shutdown_time_ms = 5000,                                                          \\ \t\t.init_chat_script =&quectel_bg95_init_chat_script,                                \\ \t\t.dial_chat_script =&quectel_bg95_dial_chat_script,                                \\ \t\t.periodic_chat_script =&_CONCAT(DT_DRV_COMPAT, _periodic_chat_script),            \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\n-value|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 64);                 \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\",                                                            \\ \t\t.chat_filter = \"\\n\",                                                               \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tgnss_pipe,                                                                         \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_0,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_1,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, gnss_pipe, 3),                                 \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_0, 4),                               \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_1, 5),                               \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.power_pulse_duration_ms = 1500,                                                   \\ \t\t.reset_pulse_duration_ms = 500,                                                    \\ \t\t.startup_time_ms = 15000,                                                          \\ \t\t.shutdown_time_ms = 5000,                                                          \\ \t\t.init_chat_script =&quectel_eg25_g_init_chat_script,                              \\ \t\t.dial_chat_script =&quectel_eg25_g_dial_chat_script,                              \\ \t\t.periodic_chat_script =&_CONCAT(DT_DRV_COMPAT, _periodic_chat_script),            \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\n+value|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 64);                 \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\",                                                            \\ \t\t.chat_filter = \"\\n\",                                                               \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_0,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_1,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_0, 3),                               \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_1, 4),                               \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.power_pulse_duration_ms = 1500,                                                   \\ \t\t.reset_pulse_duration_ms = 500,                                                    \\ \t\t.startup_time_ms = 15000,                                                          \\ \t\t.shutdown_time_ms = 5000,                                                          \\ \t\t.init_chat_script =&quectel_eg25_g_init_chat_script,                              \\ \t\t.dial_chat_script =&quectel_eg25_g_dial_chat_script,                              \\ \t\t.periodic_chat_script =&_CONCAT(DT_DRV_COMPAT, _periodic_chat_script),            \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\n-value|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 64);                 \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\",                                                            \\ \t\t.chat_filter = \"\\n\",                                                               \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tgnss_pipe,                                                                         \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_0,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_1,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, gnss_pipe, 3),                                 \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_0, 4),                               \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_1, 5),                               \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.power_pulse_duration_ms = 1500,                                                   \\ \t\t.reset_pulse_duration_ms = 100,                                                    \\ \t\t.startup_time_ms = 10000,                                                          \\ \t\t.shutdown_time_ms = 5000,                                                          \\ \t\t.init_chat_script =&simcom_sim7080_init_chat_script,                              \\ \t\t.dial_chat_script =&simcom_sim7080_dial_chat_script,                              \\ \t\t.periodic_chat_script =&simcom_sim7080_periodic_chat_script,                      \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\n+value|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 64);                 \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\",                                                            \\ \t\t.chat_filter = \"\\n\",                                                               \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_0,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_1,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_0, 3),                               \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_1, 4),                               \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.power_pulse_duration_ms = 1500,                                                   \\ \t\t.reset_pulse_duration_ms = 100,                                                    \\ \t\t.startup_time_ms = 10000,                                                          \\ \t\t.shutdown_time_ms = 5000,                                                          \\ \t\t.init_chat_script =&simcom_sim7080_init_chat_script,                              \\ \t\t.dial_chat_script =&simcom_sim7080_dial_chat_script,                              \\ \t\t.periodic_chat_script =&simcom_sim7080_periodic_chat_script,                      \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\n-value|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 64);                 \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\",                                                            \\ \t\t.chat_filter = \"\\n\",                                                               \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tgnss_pipe,                                                                         \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_0,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_1,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, gnss_pipe, 3),                                 \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_0, 4),                               \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_1, 5),                               \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.power_pulse_duration_ms = 1500,                                                   \\ \t\t.reset_pulse_duration_ms = 100,                                                    \\ \t\t.startup_time_ms = 10000,                                                          \\ \t\t.shutdown_time_ms = 5000,                                                          \\ \t\t.init_chat_script =&u_blox_sara_r4_init_chat_script,                              \\ \t\t.dial_chat_script =&u_blox_sara_r4_dial_chat_script,                              \\ \t\t.periodic_chat_script =&u_blox_sara_r4_periodic_chat_script,                      \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\n+value|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 64);                 \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\",                                                            \\ \t\t.chat_filter = \"\\n\",                                                               \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tgnss_pipe,                                                                         \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_0,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, gnss_pipe, 3),                                 \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_0, 4),                               \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.power_pulse_duration_ms = 1500,                                                   \\ \t\t.reset_pulse_duration_ms = 100,                                                    \\ \t\t.startup_time_ms = 10000,                                                          \\ \t\t.shutdown_time_ms = 5000,                                                          \\ \t\t.init_chat_script =&u_blox_sara_r4_init_chat_script,                              \\ \t\t.dial_chat_script =&u_blox_sara_r4_dial_chat_script,                              \\ \t\t.periodic_chat_script =&u_blox_sara_r4_periodic_chat_script,                      \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\n-value|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 64);                 \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\",                                                            \\ \t\t.chat_filter = \"\\n\",                                                               \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tgnss_pipe,                                                                         \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_0,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_1,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, gnss_pipe, 3),                                 \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_0, 4),                               \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_1, 5),                               \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.autostarts = true,                                                                \\ \t\t.power_pulse_duration_ms = 1500,                                                   \\ \t\t.reset_pulse_duration_ms = 100,                                                    \\ \t\t.startup_time_ms = 1500,                                                           \\ \t\t.shutdown_time_ms = 13000,                                                         \\ \t\t.init_chat_script =&u_blox_sara_r5_init_chat_script,                              \\ \t\t.dial_chat_script =&u_blox_sara_r5_dial_chat_script,                              \\ \t\t.periodic_chat_script =&u_blox_sara_r5_periodic_chat_script,                      \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\n+value|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 64);                 \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\",                                                            \\ \t\t.chat_filter = \"\\n\",                                                               \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tgnss_pipe,                                                                         \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_0,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, gnss_pipe, 4),                                 \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_0, 3),                               \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.autostarts = true,                                                                \\ \t\t.power_pulse_duration_ms = 1500,                                                   \\ \t\t.reset_pulse_duration_ms = 100,                                                    \\ \t\t.startup_time_ms = 1500,                                                           \\ \t\t.shutdown_time_ms = 13000,                                                         \\ \t\t.init_chat_script =&u_blox_sara_r5_init_chat_script,                              \\ \t\t.dial_chat_script =&u_blox_sara_r5_dial_chat_script,                              \\ \t\t.periodic_chat_script =&u_blox_sara_r5_periodic_chat_script,                      \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\n-value|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 64);                 \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\",                                                            \\ \t\t.chat_filter = \"\\n\",                                                               \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tgnss_pipe,                                                                         \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_0,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_1,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, gnss_pipe, 3),                                 \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_0, 4),                               \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_1, 5),                               \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.power_pulse_duration_ms = 1500,                                                   \\ \t\t.reset_pulse_duration_ms = 100,                                                    \\ \t\t.startup_time_ms = 10000,                                                          \\ \t\t.shutdown_time_ms = 5000,                                                          \\ \t\t.init_chat_script =&swir_hl7800_init_chat_script,                                 \\ \t\t.dial_chat_script =&swir_hl7800_dial_chat_script,                                 \\ \t\t.periodic_chat_script =&swir_hl7800_periodic_chat_script,                         \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\n+value|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 64);                 \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\",                                                            \\ \t\t.chat_filter = \"\\n\",                                                               \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_0,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_1,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_0, 3),                               \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_1, 4),                               \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.power_pulse_duration_ms = 1500,                                                   \\ \t\t.reset_pulse_duration_ms = 100,                                                    \\ \t\t.startup_time_ms = 10000,                                                          \\ \t\t.shutdown_time_ms = 5000,                                                          \\ \t\t.init_chat_script =&swir_hl7800_init_chat_script,                                 \\ \t\t.dial_chat_script =&swir_hl7800_dial_chat_script,                                 \\ \t\t.periodic_chat_script =&swir_hl7800_periodic_chat_script,                         \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\n-value|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 64);                 \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\",                                                            \\ \t\t.chat_filter = \"\\n\",                                                               \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tgnss_pipe,                                                                         \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_0,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_1,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, gnss_pipe, 3),                                 \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_0, 4),                               \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_1, 5),                               \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.power_pulse_duration_ms = 5050,                                                   \\ \t\t.reset_pulse_duration_ms = 250,                                                    \\ \t\t.startup_time_ms = 15000,                                                          \\ \t\t.shutdown_time_ms = 5000,                                                          \\ \t\t.init_chat_script =&telit_me910g1_init_chat_script,                               \\ \t\t.dial_chat_script =&telit_me910g1_dial_chat_script,                               \\ \t\t.periodic_chat_script =&telit_me910g1_periodic_chat_script,                       \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\n+value|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 64);                 \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\",                                                            \\ \t\t.chat_filter = \"\\n\",                                                               \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_0,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_0, 3),                               \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.power_pulse_duration_ms = 5050,                                                   \\ \t\t.reset_pulse_duration_ms = 250,                                                    \\ \t\t.startup_time_ms = 15000,                                                          \\ \t\t.shutdown_time_ms = 5000,                                                          \\ \t\t.init_chat_script =&telit_me910g1_init_chat_script,                               \\ \t\t.dial_chat_script =&telit_me910g1_dial_chat_script,                               \\ \t\t.periodic_chat_script =&telit_me910g1_periodic_chat_script,                       \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\n-value|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 1500);               \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\\n\",                                                          \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tgnss_pipe,                                                                         \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_0,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_1,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, gnss_pipe, 3),                                 \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_0, 4),                               \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_1, 5),                               \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.power_pulse_duration_ms = 100,                                                    \\ \t\t.reset_pulse_duration_ms = 100,                                                    \\ \t\t.startup_time_ms = 2000,                                                           \\ \t\t.shutdown_time_ms = 10000,                                                         \\ \t\t.init_chat_script =&nordic_nrf91_slm_init_chat_script,                            \\ \t\t.dial_chat_script =&nordic_nrf91_slm_dial_chat_script,                            \\ \t\t.periodic_chat_script =&nordic_nrf91_slm_periodic_chat_script,                    \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\n+value|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 1500);               \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\\n\",                                                          \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tgnss_pipe,                                                                         \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, gnss_pipe, 3),                                 \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.power_pulse_duration_ms = 100,                                                    \\ \t\t.reset_pulse_duration_ms = 100,                                                    \\ \t\t.startup_time_ms = 2000,                                                           \\ \t\t.shutdown_time_ms = 10000,                                                         \\ \t\t.init_chat_script =&nordic_nrf91_slm_init_chat_script,                            \\ \t\t.dial_chat_script =&nordic_nrf91_slm_dial_chat_script,                            \\ \t\t.periodic_chat_script =&nordic_nrf91_slm_periodic_chat_script,                    \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\n-value|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 64);                 \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\",                                                            \\ \t\t.chat_filter = \"\\n\",                                                               \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tgnss_pipe,                                                                         \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_0,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_1,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, gnss_pipe, 3),                                 \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_0, 4),                               \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_1, 5),                               \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.autostarts = true,                                                                \\ \t\t.power_pulse_duration_ms = 1500,                                                   \\ \t\t.reset_pulse_duration_ms = 100,                                                    \\ \t\t.startup_time_ms = 2000,                                                           \\ \t\t.shutdown_time_ms = 5000,                                                          \\ \t\t.init_chat_script =&sqn_gm02s_init_chat_script,                                   \\ \t\t.dial_chat_script =&sqn_gm02s_dial_chat_script,                                   \\ \t\t.periodic_chat_script =&sqn_gm02s_periodic_chat_script,                           \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\n+value|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 64);                 \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\",                                                            \\ \t\t.chat_filter = \"\\n\",                                                               \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_0,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPE_DATA(                                                      \\ \t\tinst,                                                                              \\ \t\tuser_pipe_1,                                                                       \\ \t\tCONFIG_MODEM_CELLULAR_USER_PIPE_BUFFER_SIZES                                       \\ \t);                                                                                         \\                                                                                                    \\ \tMODEM_CELLULAR_DEFINE_USER_PIPES(                                                          \\ \t\tinst,                                                                              \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_0, 3),                               \\ \t\tMODEM_CELLULAR_INIT_USER_PIPE(inst, user_pipe_1, 4),                               \\ \t);                                                                                         \\                                                                                                    \\ \tstatic const struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {       \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.autostarts = true,                                                                \\ \t\t.power_pulse_duration_ms = 1500,                                                   \\ \t\t.reset_pulse_duration_ms = 100,                                                    \\ \t\t.startup_time_ms = 2000,                                                           \\ \t\t.shutdown_time_ms = 5000,                                                          \\ \t\t.init_chat_script =&sqn_gm02s_init_chat_script,                                   \\ \t\t.dial_chat_script =&sqn_gm02s_dial_chat_script,                                   \\ \t\t.periodic_chat_script =&sqn_gm02s_periodic_chat_script,                           \\ \t\t.user_pipes = MODEM_CELLULAR_GET_USER_PIPES(inst),                                 \\ \t\t.user_pipes_size = ARRAY_SIZE(MODEM_CELLULAR_GET_USER_PIPES(inst)),                \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\nThe issue was with: drivers: modem: cellular: correct user DLCI channels\n\nThe supported modems don't have the same number or assignment\nof DLCI channels. For example, the NRF91_SLM only has DLCI\nchannel 3 assigned to GNSS tunneling, where the ublox sara r5\nhas DLCI 3 assigned to an additional AT channel, and DLCI 4\nassigned to GNSS tunneling.\n\nThis commit updates the creation and assignment of DLCI\nchannels and pipelinks to match the capabilties of each modem."
},{
  "instruction": "There is an issue in the following code. It relates to bluetooth: fix typo in (common, crypto, services, shell)\n\nUtilize a code spell-checking tool to scan for and correct spelling errors\nin all files within the subsys/bluetooth/(common, crypto, service, shell). Please fix this issue.",
  "input": "Faulty tokenized code:\n\nconfig BT_HCI_VS_FATAL_ERROR\n\tbool \"Allow vendor specific HCI event Zephyr Fatal Error\"\n\tdepends on BT_HCI_VS\n\thelp\n\t  Enable emiting HCI Vendor-Specific events for system and Controller\n\t  errors that are unrecoverable.\n\nconfig BT_HCI_VS_EXT_DETECT\n\tbool \"Use heuristics to guess HCI vendor extensions support in advance\"\n\tdepends on BT_HCI_VS && !BT_CTLR\nparameter_list|)\nfunction_decl|;\nend_function_decl\n\nbegin_comment\ncomment|/**  * @brief Cryptograhic Toolbox function h8  *  * Defined in Core Vol. 6, part E 1.1.1.  *  * @note This function is purely a shorthand for the calculation. The parameters  * are therefore intentionally not assigned meaning.  *  * Pseudocode: `aes_cmac(key=aes_cmac(key=s, plaintext=k), plaintext=key_id)`  *  * @param[in] k (128-bit number in big endian)  * @param[in] s (128-bit number in big endian)  * @param[in] key_id (32-bit number in big endian)  * @param[out] res (128-bit number in big endian)  *  * @retval 0 Computation was successful. @p res contains the result.  * @retval -EIO Computation failed.  */\nend_comment\n\nbegin_function_decl\nname|int\nname|bt_crypto_h8\ncomment|/* ID */\nname|len\noperator|+=\nname|BT_OTS_OBJ_ID_SIZE\nexpr_stmt|;\ncomment|/* Name length (single octect is used for the name length) */\nname|len\noperator|+=\nsizeof|sizeof\nargument_list|(\nname|uint8_t\nname|CONFIG_BT_BROADCASTER\nargument_list|)\nend_if\n\nbegin_enum\nDECL|enum|__anon274d712e0103\nenum|enum\nblock|{\nDECL|enumerator|SHELL_ADV_OPT_CONNECTABLE\nname|SHELL_ADV_OPT_CONNECTABLE\nblock|,\nblock|{\nname|shell_print\nargument_list|(\nname|sh\nargument_list|,\nliteral|\"Commad returned error error %d\"\nargument_list|,\nname|err\nargument_list|)\nexpr_stmt|;\nreturn|return",
  "result": "I corrected the issue in the code by changing the following tokens:\n-\t  Enable emiting HCI Vendor-Specific events for system and Controller\n+\t  Enable emitting HCI Vendor-Specific events for system and Controller\n-comment|/**  * @brief Cryptograhic Toolbox function h8  *  * Defined in Core Vol. 6, part E 1.1.1.  *  * @note This function is purely a shorthand for the calculation. The parameters  * are therefore intentionally not assigned meaning.  *  * Pseudocode: `aes_cmac(key=aes_cmac(key=s, plaintext=k), plaintext=key_id)`  *  * @param[in] k (128-bit number in big endian)  * @param[in] s (128-bit number in big endian)  * @param[in] key_id (32-bit number in big endian)  * @param[out] res (128-bit number in big endian)  *  * @retval 0 Computation was successful. @p res contains the result.  * @retval -EIO Computation failed.  */\n+comment|/**  * @brief Cryptographic Toolbox function h8  *  * Defined in Core Vol. 6, part E 1.1.1.  *  * @note This function is purely a shorthand for the calculation. The parameters  * are therefore intentionally not assigned meaning.  *  * Pseudocode: `aes_cmac(key=aes_cmac(key=s, plaintext=k), plaintext=key_id)`  *  * @param[in] k (128-bit number in big endian)  * @param[in] s (128-bit number in big endian)  * @param[in] key_id (32-bit number in big endian)  * @param[out] res (128-bit number in big endian)  *  * @retval 0 Computation was successful. @p res contains the result.  * @retval -EIO Computation failed.  */\n-comment|/* Name length (single octect is used for the name length) */\n+comment|/* Name length (single octet is used for the name length) */\n-DECL|enum|__anon274d712e0103\n+DECL|enum|__anon2b8a96a20103\n-literal|\"Commad returned error error %d\"\n+literal|\"Command returned error error %d\"\nThe issue was with: bluetooth: fix typo in (common, crypto, services, shell)\n\nUtilize a code spell-checking tool to scan for and correct spelling errors\nin all files within the subsys/bluetooth/(common, crypto, service, shell)."
},{
  "instruction": "There is an issue in the following code. It relates to drivers/gpio/gpio_rzt2m: Handle trig == GPIO_INT_TRIG_WAKE\n\nFix a build warning due to the enumerate for the trigger\npolarity possibly being (from the point of the compiler)\nalso GPIO_INT_TRIG_WAKE.\nWe fix it by simply returning a not valid argument error\nwhich is what most other drivers do if they do something\nsmart enough. Please fix this issue.",
  "input": "Faulty tokenized code:\ncase|:\nname|md_mode\noperator|=\nname|INT_BOTH_EDGE\nexpr_stmt|;\nblock|}\nname|rzt2m_gpio_unlock\nargument_list|()\nexpr_stmt|;\nname|uint32_t",
  "result": "I corrected the issue in the code by changing the following tokens:\n+break|break;\n+default|default:\n+return|return\n+operator|-\n+name|EINVAL\n+return|;\nThe issue was with: drivers/gpio/gpio_rzt2m: Handle trig == GPIO_INT_TRIG_WAKE\n\nFix a build warning due to the enumerate for the trigger\npolarity possibly being (from the point of the compiler)\nalso GPIO_INT_TRIG_WAKE.\nWe fix it by simply returning a not valid argument error\nwhich is what most other drivers do if they do something\nsmart enough."
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: counter: fix skip tests check\n\nWhen running this test with multiple counter instances enabled that\nsupport different capabilities, if one of the instances does not\nsupport the test required capabilities, the test will be\nimmediately skipped not giving the chance to run to the subsequent\ninstances.\n\nFix this by marking the test as skipped, only of all counter instances\nunder test were skipped.\n\nFixes #74358 Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|,\nname|counter_capability_func_t\nname|capability_check\nparameter_list|)\nblock|{\nname|zassert_true\nargument_list|(\nname|ARRAY_SIZE\nargument_list|(\nname|devices\nindex|]\noperator|->\nname|name\nargument_list|)\nexpr_stmt|;\nname|ztest_test_skip\nargument_list|()\nexpr_stmt|;\nblock|}\nname|counter_tear_down_instance\nargument_list|(\nname|devices\nliteral|100\nargument_list|)\nargument_list|)\nexpr_stmt|;\nblock|}\nblock|}\nend_function\n\nbegin_function\nDECL|function|set_top_value_capable (const struct device * dev)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|int\n+name|devices_skipped\n+init|=\n+literal|0\n+decl_stmt|;\n-name|ztest_test_skip\n-argument_list|()\n+name|devices_skipped\n+operator|++\n+if|if\n+condition|(\n+name|devices_skipped\n+operator|==\n+name|ARRAY_SIZE\n+argument_list|(\n+name|devices\n+argument_list|)\n+condition|)\n+block|{\n+name|ztest_test_skip\n+argument_list|()\n+expr_stmt|;\n+block|}\nThe issue was with: tests: drivers: counter: fix skip tests check\n\nWhen running this test with multiple counter instances enabled that\nsupport different capabilities, if one of the instances does not\nsupport the test required capabilities, the test will be\nimmediately skipped not giving the chance to run to the subsequent\ninstances.\n\nFix this by marking the test as skipped, only of all counter instances\nunder test were skipped.\n\nFixes #74358"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: adc: saadc: Disable burst mode on unused channels\n\nBurst mode enabled on an unused channel causes a freeze during a\nconversion consisting of several channels (not including the one with\nburst mode enabled).\n\nDiscovered on nRF52832 (nRF52-DK) using the following approach:\n  channels 0-3 are used for application purposes as a sequence\n  channel 4 is used for battery measurements with oversampling\n\nAfter few successful conversions the sequence (channels 0-3) freezes the\nthread while waiting for semaphore to end the conversion. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|active_channels\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\nname|nrf_saadc_channel_pos_input_set\nargument_list|(\nname|NRF_SAADC\nargument_list|,\nname|channel_id",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|nrf_saadc_burst_set\n+argument_list|(\n+name|NRF_SAADC\n+argument_list|,\n+name|channel_id\n+argument_list|,\n+name|NRF_SAADC_BURST_DISABLED\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: adc: saadc: Disable burst mode on unused channels\n\nBurst mode enabled on an unused channel causes a freeze during a\nconversion consisting of several channels (not including the one with\nburst mode enabled).\n\nDiscovered on nRF52832 (nRF52-DK) using the following approach:\n  channels 0-3 are used for application purposes as a sequence\n  channel 4 is used for battery measurements with oversampling\n\nAfter few successful conversions the sequence (channels 0-3) freezes the\nthread while waiting for semaphore to end the conversion."
},{
  "instruction": "There is an issue in the following code. It relates to i3c: ccc: fix missing break in switch in _do__getcaps()\n\nIn i3c_ccc_do_getcaps(), there is a missing break statement\nin the switch case for GETCAPS_FORMAT_2_CRCAPS. Add it.\n\nFixes #74764 Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\noperator|-\nname|len\nargument_list|)\nexpr_stmt|;\ncase|case\nname|GETCAPS_FORMAT_2_VTCAPS\ncase|:\nname|memcpy\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+break|break;\nThe issue was with: i3c: ccc: fix missing break in switch in _do__getcaps()\n\nIn i3c_ccc_do_getcaps(), there is a missing break statement\nin the switch case for GETCAPS_FORMAT_2_CRCAPS. Add it.\n\nFixes #74764"
},{
  "instruction": "There is an issue in the following code. It relates to Lib: SMF: Add test for stuck handled bit\n\nUpdate test_lib_self_transition_smf.c to detect the bug that was in\nsmf_set_handled().\n\nAlso delete unneeded test state STATE_D_ENTRY Please fix this issue.",
  "input": "Faulty tokenized code:\nname|BIT\nargument_list|(\nname|PARENT_AB_RUN\nargument_list|)\nexpr_stmt|;\nname|smf_set_state\nargument_list|(\nname|SMF_CTX\nargument_list|(\nname|obj",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* \t * You should not call smf_set_handled() in the same code path as smf_set_state(). \t * There was a bug that did not reset the handled bit if both were called, \t * so check it's still fixed: \t */\n+name|smf_set_handled\n+argument_list|(\n+name|SMF_CTX\n+argument_list|(\n+name|obj\n+argument_list|)\n+argument_list|)\n+expr_stmt|;\nThe issue was with: Lib: SMF: Add test for stuck handled bit\n\nUpdate test_lib_self_transition_smf.c to detect the bug that was in\nsmf_set_handled().\n\nAlso delete unneeded test state STATE_D_ENTRY"
},{
  "instruction": "There is an issue in the following code. It relates to driver: eth_esp32: fix shared clock check\n\nBoth MDIO and Ethernet drivers share the same clock subsystem.\nAfter clock control update in #73807, clock_control_on()\nnow returns -EALREADY for already initialized clock subsystem.\nAs a result, ethernet driver won't initialize as needed.\n\nFixes #74440 Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nargument_list|,\nname|offset\nargument_list|)\ndecl_stmt|;\nname|res\noperator|=\nname|clock_control_on\nargument_list|(\nname|clock_dev\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|res\noperator|!=\nliteral|0\ncondition|)\nblock|{\ngoto|goto\nname|err\ngoto|;\nargument_list|)\nargument_list|,\nname|offset\nargument_list|)\ndecl_stmt|;\nname|res\noperator|=\nname|clock_control_on\nargument_list|(\nname|clock_dev\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|res\noperator|!=\nliteral|0\ncondition|)\nblock|{\ngoto|goto\nname|err\ngoto|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* clock is shared, so do not bail out if already enabled */\n-operator|!=\n+operator|<\n+operator|&&\n+name|res\n+operator|!=\n+operator|-\n+name|EALREADY\n+comment|/* clock is shared, so do not bail out if already enabled */\n-operator|!=\n+operator|<\n+operator|&&\n+name|res\n+operator|!=\n+operator|-\n+name|EALREADY\nThe issue was with: driver: eth_esp32: fix shared clock check\n\nBoth MDIO and Ethernet drivers share the same clock subsystem.\nAfter clock control update in #73807, clock_control_on()\nnow returns -EALREADY for already initialized clock subsystem.\nAs a result, ethernet driver won't initialize as needed.\n\nFixes #74440"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Host: Fix HCI command timeout usage\n\nFix Bluetooth initialization problem caused by PR#72090\nfor at least ST boards that are using BlueNRG BLE modules.\n\nFor more information, please refer to issue #74528. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|hci_vs_init\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nDECL|union|__anon274fb4ca010a\nunion|union\nblock|{\nDECL|member|info\nname|struct\nname|bt_hci_rp_vs_read_version_info\noperator|&\nname|bt_dev\noperator|.\nname|ncmd_sem\nargument_list|,\nname|K_NO_WAIT\nargument_list|)\noperator|==\nliteral|0\ncondition|)\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon274fb4ca010a\n+DECL|union|__anon28e95dd7010a\n-name|K_NO_WAIT\n+name|timeout\nThe issue was with: Bluetooth: Host: Fix HCI command timeout usage\n\nFix Bluetooth initialization problem caused by PR#72090\nfor at least ST boards that are using BlueNRG BLE modules.\n\nFor more information, please refer to issue #74528."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: rtc: rtc_ll_stm32: coverity 368806 fix\n\nReplace DIV_ROUND_CLOSEST() with a normal division to simplify\noperation and avoid redundant handling of signed integer rounding\nas the temp value is an unsigned value. The temp value is in nano\nprecision, so rounding is largely inconsequencial anyway compared\nto the comparatively low precision sync prescaler. Please fix this issue.",
  "input": "Faulty tokenized code:\ndecl_stmt|;\nname|timeptr\noperator|->\nname|tm_nsec\noperator|=\nname|DIV_ROUND_CLOSEST\nargument_list|(\nname|temp\nargument_list|,\nname|cfg\noperator|->\nname|sync_prescaler\noperator|+\nliteral|1\nargument_list|)\nexpr_stmt|;\nelse|#\ndirective|else\nname|timeptr\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|DIV_ROUND_CLOSEST\n-argument_list|(\n-argument_list|,\n+operator|/\n+operator|(\n-argument_list|)\n+operator|)\nThe issue was with: drivers: rtc: rtc_ll_stm32: coverity 368806 fix\n\nReplace DIV_ROUND_CLOSEST() with a normal division to simplify\noperation and avoid redundant handling of signed integer rounding\nas the temp value is an unsigned value. The temp value is in nano\nprecision, so rounding is largely inconsequencial anyway compared\nto the comparatively low precision sync prescaler."
},{
  "instruction": "There is an issue in the following code. It relates to net: dns: mdns_responder: Interface name might miss terminating null\n\nThe network interface name that is copied to if_req struct might\nbe missing terminating null.\n\nFixes #74795\nCoverity-CID: 368797 Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|if_req\noperator|.\nname|ifr_name\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|ret\noperator|=\nname|zsock_setsockopt",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|-\n+literal|1\nThe issue was with: net: dns: mdns_responder: Interface name might miss terminating null\n\nThe network interface name that is copied to if_req struct might\nbe missing terminating null.\n\nFixes #74795\nCoverity-CID: 368797"
},{
  "instruction": "There is an issue in the following code. It relates to net: websocket: Remove dead code\n\nThe zsock_close() is not needed as the fd is always <0 so\nthe close is never called.\n\nFixes #74791\nCoverity-CID: 366273 Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|return\nname|fd\nreturn|;\nname|out\nlabel|:\nif|if\ncondition|(\nname|fd\noperator|>=\nliteral|0\ncondition|)\nblock|{\noperator|(\nname|void\noperator|)\nname|zsock_close\nargument_list|(\nname|fd\nargument_list|)\nexpr_stmt|;\nblock|}\nname|websocket_context_unref\nargument_list|(\nname|ctx\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-if|if\n-condition|(\n-name|fd\n-operator|>=\n-literal|0\n-condition|)\n-block|{\n-operator|(\n-name|void\n-operator|)\n-name|zsock_close\n-argument_list|(\n-name|fd\n-argument_list|)\n-expr_stmt|;\n-block|}\nThe issue was with: net: websocket: Remove dead code\n\nThe zsock_close() is not needed as the fd is always <0 so\nthe close is never called.\n\nFixes #74791\nCoverity-CID: 366273"
},{
  "instruction": "There is an issue in the following code. It relates to shell: backend: uart: Fix POSIX name conflict\n\nIf CONFIG_POSIX_API is enabled, the read() and write() function\nnames will conflict. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|write (const struct shell_transport * transport,const void * data,size_t length,size_t * cnt)\nspecifier|static\nname|int\nname|write\nparameter_list|(\nspecifier|const\nname|struct\nname|shell_transport\nmodifier|*\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|read (const struct shell_transport * transport,void * data,size_t length,size_t * cnt)\nspecifier|static\nname|int\nname|read\nparameter_list|(\nspecifier|const\nname|struct\nname|shell_transport\nmodifier|*\nname|enable\nblock|,\noperator|.\nname|write\noperator|=\nname|write\nblock|,\noperator|.\nname|read\noperator|=\nname|read\nblock|,\nifdef|#\ndirective|ifdef\nname|CONFIG_MCUMGR_TRANSPORT_SHELL\noperator|.",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|write (const struct shell_transport * transport,const void * data,size_t length,size_t * cnt)\n+DECL|function|write_uart (const struct shell_transport * transport,const void * data,size_t length,size_t * cnt)\n-name|write\n+name|write_uart\n-DECL|function|read (const struct shell_transport * transport,void * data,size_t length,size_t * cnt)\n+DECL|function|read_uart (const struct shell_transport * transport,void * data,size_t length,size_t * cnt)\n-name|read\n+name|read_uart\n-name|write\n+name|write_uart\n-name|read\n+name|read_uart\nThe issue was with: shell: backend: uart: Fix POSIX name conflict\n\nIf CONFIG_POSIX_API is enabled, the read() and write() function\nnames will conflict."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: ethernet: adin2111: minor code style correction\n\nUse tabs instead of spaces. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ifaces\nparameter_list|,\nname|name\nparameter_list|)\ndefine|\\\nvalue|ADIN2111_DEF_BUF(name##_buffer_##inst, CONFIG_ETH_ADIN2111_BUFFER_SIZE);\t\t\\ \tCOND_CODE_1(DT_INST_PROP(inst, spi_oa),\t\t\t\t\t\t\t\\ \t(\t\t\t\t\t\t\t\t\t\t\t\\ \t\tADIN2111_DEF_BUF(name##_oa_tx_buf_##inst, ADIN2111_OA_BUF_SZ);\t\t\t\\ \t\tADIN2111_DEF_BUF(name##_oa_rx_buf_##inst, ADIN2111_OA_BUF_SZ);\t\t\t\\ \t), ())\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct adin2111_config name##_config_##inst = {\t\t\t\t\\ \t\t.id = dev_id,\t\t\t\t\t\t\t\t\t\\ \t\t.spi = SPI_DT_SPEC_INST_GET(inst, ADIN2111_SPI_OPERATION, 0),\t\t\t\\ \t\t.interrupt = GPIO_DT_SPEC_INST_GET(inst, int_gpios),\t\t\t\t\\ \t\t.reset = GPIO_DT_SPEC_INST_GET_OR(inst, reset_gpios, { 0 }),\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct adin2111_data name##_data_##inst = {\t\t\t\t\t\\ \t\t.ifaces_left_to_init = ifaces,\t\t\t\t\t\t\t\\ \t\t.port = {},\t\t\t\t\t\t\t\t\t\\ \t\t.offload_sem = Z_SEM_INITIALIZER(name##_data_##inst.offload_sem, 0, 1),         \\ \t\t.lock = Z_MUTEX_INITIALIZER(name##_data_##inst.lock),\t\t\t\t\\ \t\t.buf = name##_buffer_##inst,\t\t\t\t\t\t\t\\ \t\t.oa = DT_INST_PROP(inst, spi_oa),\t\t\t\t\t\t\\ \t\t.oa_prot = DT_INST_PROP(inst, spi_oa_protection),\t\t\t\t\\ \t\t.oa_cps = 64,\t\t\t\t\t\t\t\t\t\\ \t\t.oa_tx_buf = COND_CODE_1(DT_INST_PROP(inst, spi_oa),\t\t\t\t\\ \t\t\t\t\t (name##_oa_tx_buf_##inst), (NULL)),\t\t\t\\ \t\t.oa_rx_buf = COND_CODE_1(DT_INST_PROP(inst, spi_oa),\t\t\t\t\\ \t\t\t\t\t (name##_oa_rx_buf_##inst), (NULL)),\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\\ncomment|/* adin */\nvalue|\\ \tDEVICE_DT_DEFINE(DT_DRV_INST(inst), adin2111_init, NULL,\t\t\t\t\\&name##_data_##inst,&name##_config_##inst,\t\t\t\t\\ \t\t\t POST_KERNEL, CONFIG_ETH_INIT_PRIORITY,\t\t\t\t\t\\ \t\t\t NULL);\nend_define\n\nbegin_define",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|ADIN2111_DEF_BUF(name##_buffer_##inst, CONFIG_ETH_ADIN2111_BUFFER_SIZE);\t\t\\ \tCOND_CODE_1(DT_INST_PROP(inst, spi_oa),\t\t\t\t\t\t\t\\ \t(\t\t\t\t\t\t\t\t\t\t\t\\ \t\tADIN2111_DEF_BUF(name##_oa_tx_buf_##inst, ADIN2111_OA_BUF_SZ);\t\t\t\\ \t\tADIN2111_DEF_BUF(name##_oa_rx_buf_##inst, ADIN2111_OA_BUF_SZ);\t\t\t\\ \t), ())\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct adin2111_config name##_config_##inst = {\t\t\t\t\\ \t\t.id = dev_id,\t\t\t\t\t\t\t\t\t\\ \t\t.spi = SPI_DT_SPEC_INST_GET(inst, ADIN2111_SPI_OPERATION, 0),\t\t\t\\ \t\t.interrupt = GPIO_DT_SPEC_INST_GET(inst, int_gpios),\t\t\t\t\\ \t\t.reset = GPIO_DT_SPEC_INST_GET_OR(inst, reset_gpios, { 0 }),\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct adin2111_data name##_data_##inst = {\t\t\t\t\t\\ \t\t.ifaces_left_to_init = ifaces,\t\t\t\t\t\t\t\\ \t\t.port = {},\t\t\t\t\t\t\t\t\t\\ \t\t.offload_sem = Z_SEM_INITIALIZER(name##_data_##inst.offload_sem, 0, 1),         \\ \t\t.lock = Z_MUTEX_INITIALIZER(name##_data_##inst.lock),\t\t\t\t\\ \t\t.buf = name##_buffer_##inst,\t\t\t\t\t\t\t\\ \t\t.oa = DT_INST_PROP(inst, spi_oa),\t\t\t\t\t\t\\ \t\t.oa_prot = DT_INST_PROP(inst, spi_oa_protection),\t\t\t\t\\ \t\t.oa_cps = 64,\t\t\t\t\t\t\t\t\t\\ \t\t.oa_tx_buf = COND_CODE_1(DT_INST_PROP(inst, spi_oa),\t\t\t\t\\ \t\t\t\t\t (name##_oa_tx_buf_##inst), (NULL)),\t\t\t\\ \t\t.oa_rx_buf = COND_CODE_1(DT_INST_PROP(inst, spi_oa),\t\t\t\t\\ \t\t\t\t\t (name##_oa_rx_buf_##inst), (NULL)),\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\\n+value|ADIN2111_DEF_BUF(name##_buffer_##inst, CONFIG_ETH_ADIN2111_BUFFER_SIZE);\t\t\\ \tCOND_CODE_1(DT_INST_PROP(inst, spi_oa),\t\t\t\t\t\t\t\\ \t(\t\t\t\t\t\t\t\t\t\t\t\\ \t\tADIN2111_DEF_BUF(name##_oa_tx_buf_##inst, ADIN2111_OA_BUF_SZ);\t\t\t\\ \t\tADIN2111_DEF_BUF(name##_oa_rx_buf_##inst, ADIN2111_OA_BUF_SZ);\t\t\t\\ \t), ())\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct adin2111_config name##_config_##inst = {\t\t\t\t\\ \t\t.id = dev_id,\t\t\t\t\t\t\t\t\t\\ \t\t.spi = SPI_DT_SPEC_INST_GET(inst, ADIN2111_SPI_OPERATION, 0),\t\t\t\\ \t\t.interrupt = GPIO_DT_SPEC_INST_GET(inst, int_gpios),\t\t\t\t\\ \t\t.reset = GPIO_DT_SPEC_INST_GET_OR(inst, reset_gpios, { 0 }),\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct adin2111_data name##_data_##inst = {\t\t\t\t\t\\ \t\t.ifaces_left_to_init = ifaces,\t\t\t\t\t\t\t\\ \t\t.port = {},\t\t\t\t\t\t\t\t\t\\ \t\t.offload_sem = Z_SEM_INITIALIZER(name##_data_##inst.offload_sem, 0, 1),\t\t\\ \t\t.lock = Z_MUTEX_INITIALIZER(name##_data_##inst.lock),\t\t\t\t\\ \t\t.buf = name##_buffer_##inst,\t\t\t\t\t\t\t\\ \t\t.oa = DT_INST_PROP(inst, spi_oa),\t\t\t\t\t\t\\ \t\t.oa_prot = DT_INST_PROP(inst, spi_oa_protection),\t\t\t\t\\ \t\t.oa_cps = 64,\t\t\t\t\t\t\t\t\t\\ \t\t.oa_tx_buf = COND_CODE_1(DT_INST_PROP(inst, spi_oa),\t\t\t\t\\ \t\t\t\t\t (name##_oa_tx_buf_##inst), (NULL)),\t\t\t\\ \t\t.oa_rx_buf = COND_CODE_1(DT_INST_PROP(inst, spi_oa),\t\t\t\t\\ \t\t\t\t\t (name##_oa_rx_buf_##inst), (NULL)),\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\\nThe issue was with: drivers: ethernet: adin2111: minor code style correction\n\nUse tabs instead of spaces."
},{
  "instruction": "There is an issue in the following code. It relates to driver/bluetooth/hci/hci_ifx_psoc6_bless: fix long bt startup time\n\nAdded force unblock psoc6 bless rx thread to process controller\nevents (at the end of psoc6_bless_send function)\n\nInternal case: SWINTEGRAT-1767 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|net_buf_unref\nargument_list|(\nname|buf\nargument_list|)\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Unblock psoc6 bless rx thread to process controller events \t * (by calling Cy_BLE_ProcessEvents function) \t */\n+name|k_sem_give\n+argument_list|(\n+operator|&\n+name|psoc6_bless_rx_sem\n+argument_list|)\n+expr_stmt|;\nThe issue was with: driver/bluetooth/hci/hci_ifx_psoc6_bless: fix long bt startup time\n\nAdded force unblock psoc6 bless rx thread to process controller\nevents (at the end of psoc6_bless_send function)\n\nInternal case: SWINTEGRAT-1767"
},{
  "instruction": "There is an issue in the following code. It relates to samples: sensor: qdec: verify position value\n\nAt least for nrf boards, the emulation timer settings generate\nreading around -60 degrees. Verify that value with some threshold.\n\nDelay the first reading to prevent 0 at the beginning. Please fix this issue.",
  "input": "Faulty tokenized code:\n      fixture: gpio_loopback\n      type: multi_line\n      ordered: true\n      regex:\n        - \"Quadrature decoder sensor test\"\n       - \"Position = (.*) degrees\"\noperator|++\ncontrol|)\nblock|{\nendif|#\ndirective|endif\nname|rc\noperator|=\nname|sensor_sample_fetch\nargument_list|(\nname|dev\nname|val\noperator|.\nname|val1\nargument_list|)\nexpr_stmt|;\nname|k_msleep\nargument_list|(\nliteral|1000\nargument_list|)\nexpr_stmt|;\nblock|}\nreturn|return\nliteral|0\nreturn|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n-        - \"Position = (.*) degrees\"\n+        - \"Position = -[45678]\\\\d degrees\"\n+comment|/* sleep first to gather position from first period */\n+name|k_msleep\n+argument_list|(\n+literal|1000\n+argument_list|)\n+expr_stmt|;\n-name|k_msleep\n-argument_list|(\n-literal|1000\n-argument_list|)\n-expr_stmt|;\nThe issue was with: samples: sensor: qdec: verify position value\n\nAt least for nrf boards, the emulation timer settings generate\nreading around -60 degrees. Verify that value with some threshold.\n\nDelay the first reading to prevent 0 at the beginning."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: mipi_dbi: smartbond: Unused symbol\n\nSuppress warning thrown when\nthe reset line is not used. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|device\nmodifier|*\nname|dev\nparameter_list|)\nblock|{\nspecifier|const\nname|struct\nname|mipi_dbi_smartbond_config\nmodifier|*\nname|config\ninit|=\nname|dev\noperator|->\nname|config\ndecl_stmt|;\nname|struct\nname|mipi_dbi_smartbond_data\nmodifier|*\nname|data\ninit|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|__unused\n-name|struct\n+expr|struct\n-modifier|*\n+operator|*\n-init|=\n+operator|=\n-decl_stmt|;\n+expr_stmt|;\nThe issue was with: drivers: mipi_dbi: smartbond: Unused symbol\n\nSuppress warning thrown when\nthe reset line is not used."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: dma: smartbond: Fix pending length\n\nThis commit should deal with fixing\nthe pending length value returned\nupon requesting the status of a channel. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|stat\noperator|->\nname|pending_length\noperator|=\noperator|(\noperator|(\nname|dma_len_reg\noperator|+\nliteral|1\noperator|)\noperator|-\nname|dma_idx_reg\noperator|)\noperator|*\nname|bus_width",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|(\n-operator|+\n-literal|1\n-operator|)\nThe issue was with: drivers: dma: smartbond: Fix pending length\n\nThis commit should deal with fixing\nthe pending length value returned\nupon requesting the status of a channel."
},{
  "instruction": "There is an issue in the following code. It relates to samples: net: sockets: big_http_download: Fix build with TLS enabled\n\nAfter enabled POSIX_API in the sample, not all headers were included in\nthe build due to #ifdefs around header inclusions. This commit fixes\nthis. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<netdb.h>\nend_include\n\nbegin_else\nelse|#\ndirective|else\nend_else\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/net/socket.h>",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_else\n-else|#\n-directive|else\n-end_else\n+begin_endif\n+endif|#\n+directive|endif\n+end_endif\n+\n+begin_if\n+if|#\n+directive|if\n+name|defined\n+argument_list|(\n+name|__ZEPHYR__\n+argument_list|)\n+end_if\nThe issue was with: samples: net: sockets: big_http_download: Fix build with TLS enabled\n\nAfter enabled POSIX_API in the sample, not all headers were included in\nthe build due to #ifdefs around header inclusions. This commit fixes\nthis."
},{
  "instruction": "There is an issue in the following code. It relates to net: lib: dns_sd: Fix buffer sizes on query processing\n\nA few issues were identified with DNS_SD segment buffers, making it work\n\\\"by chance\\\" (depending on memory layout):\n\n- size check in dns_sd_query_extract() did not take NULL termination\n  into account, and in result could overflow provided buffer\n- the proto_buf in send_sd_response() can either be used to parse\n  protocol or domain, depending on number of segments in the query.\n  It should therefore be large enough to hold either.\n- Similarily, instance_buf should be able to hold\n  DNS_SD_INSTANCE_MAX_SIZE, not DNS_SD_SERVICE_MAX_SIZE. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|;\nblock|}\nif|if\ncondition|(\nname|qsize\noperator|>\nname|size\nindex|[\nname|i\nindex|]\ncondition|)\nblock|{\nname|NET_DBG\nargument_list|(\nliteral|\"qsize %zu> size[%zu] %zu\"\nargument_list|,\nname|qsize\nargument_list|,\nname|i\nargument_list|,\nname|NULL\ndecl_stmt|;\nname|char\nname|instance_buf\nindex|[\nname|DNS_SD_SERVICE_MAX_SIZE\noperator|+\nliteral|1\nindex|]\ndecl_stmt|;\nname|char\nname|DNS_SD_SERVICE_MAX_SIZE\noperator|+\nliteral|1\nindex|]\ndecl_stmt|;\nname|char\nname|proto_buf\nindex|[\nname|DNS_SD_PROTO_SIZE\noperator|+\nliteral|1\nindex|]\ndecl_stmt|;\nname|char",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|>\n+operator|>=\n-literal|\"qsize %zu> size[%zu] %zu\"\n+literal|\"qsize %zu>= size[%zu] %zu\"\n-name|DNS_SD_SERVICE_MAX_SIZE\n+name|DNS_SD_INSTANCE_MAX_SIZE\n+comment|/* Depending on segment count in the query, third buffer could hold \t * either protocol or domain, use larger size. \t */\n-name|DNS_SD_PROTO_SIZE\n+name|DNS_SD_DOMAIN_MAX_SIZE\nThe issue was with: net: lib: dns_sd: Fix buffer sizes on query processing\n\nA few issues were identified with DNS_SD segment buffers, making it work\n\\\"by chance\\\" (depending on memory layout):\n\n- size check in dns_sd_query_extract() did not take NULL termination\n  into account, and in result could overflow provided buffer\n- the proto_buf in send_sd_response() can either be used to parse\n  protocol or domain, depending on number of segments in the query.\n  It should therefore be large enough to hold either.\n- Similarily, instance_buf should be able to hold\n  DNS_SD_INSTANCE_MAX_SIZE, not DNS_SD_SERVICE_MAX_SIZE."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Mesh: rename deprected key refresh field\n\nCommit renames deprecated key refresh field.\nIt still has to exist to allow backward compatibility\nwith previous versions when data are restored from\nthe persistent memory. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_struct\nDECL|struct|net_key_val\nstruct|struct\nname|net_key_val\nblock|{\nDECL|member|kr_flag\nname|uint8_t\nname|kr_flag\nrange|:\nliteral|1\ndecl_stmt|,\nDECL|member|kr_phase\nname|kr_phase\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|key\noperator|.\nname|kr_flag\noperator|=\nliteral|0U\nexpr_stmt|;\ncomment|/* Deprecated */\nname|key\noperator|.\nname|kr_phase\noperator|=\nname|sub",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|member|kr_flag\n+DECL|member|unused\n-name|kr_flag\n+name|unused\n-name|kr_flag\n+name|unused\n-comment|/* Deprecated */\nThe issue was with: Bluetooth: Mesh: rename deprected key refresh field\n\nCommit renames deprecated key refresh field.\nIt still has to exist to allow backward compatibility\nwith previous versions when data are restored from\nthe persistent memory."
},{
  "instruction": "There is an issue in the following code. It relates to net: lib: dhcpv4: Fix typo in logs\n\nDHCPv4 was misspelled in logs. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|timeout\nparameter_list|)\nblock|{\nname|NET_DBG\nargument_list|(\nliteral|\"sched timeout dhcvp4=%p timeout=%us\"\nargument_list|,\nname|dhcpv4\nargument_list|,\nname|timeout\nargument_list|)\nname|int64_t\nname|timeout_ms\ndecl_stmt|;\nname|NET_DBG\nargument_list|(\nliteral|\"sched timeout dhcvp4=%p timeout=%us\"\nargument_list|,\nname|dhcpv4\nargument_list|,\nname|timeout\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"sched timeout dhcvp4=%p timeout=%us\"\n+literal|\"sched timeout dhcpv4=%p timeout=%us\"\n-literal|\"sched timeout dhcvp4=%p timeout=%us\"\n+literal|\"sched timeout dhcpv4=%p timeout=%us\"\nThe issue was with: net: lib: dhcpv4: Fix typo in logs\n\nDHCPv4 was misspelled in logs."
},{
  "instruction": "There is an issue in the following code. It relates to net: lib: http_server: Fix possible NULL pointer dereference\n\nFix possible NULL pointer dereference in http_hpack_decode_header(). Please fix this issue.",
  "input": "Faulty tokenized code:\nname|header\nparameter_list|)\nblock|{\nname|uint8_t\nname|prefix\ninit|=\noperator|*\nname|buf\ndecl_stmt|;\nname|int\nname|ret\ndecl_stmt|;\nif|if\nreturn|return\noperator|-\nname|EAGAIN\nreturn|;\nblock|}\nif|if\ncondition|(\noperator|(\nname|prefix\noperator|&",
  "result": "I corrected the issue in the code by changing the following tokens:\n-init|=\n-operator|*\n-name|buf\n+name|prefix\n+operator|=\n+operator|*\n+name|buf\n+expr_stmt|;\nThe issue was with: net: lib: http_server: Fix possible NULL pointer dereference\n\nFix possible NULL pointer dereference in http_hpack_decode_header()."
},{
  "instruction": "There is an issue in the following code. It relates to net: dns: llmnr_responder: Fix uinit variable\n\nThe family variable was not initialized and could potentially\nbe left like that. This could only affect error printout.\n\nFixes #74796\nCoverity-CID: 368799 Please fix this issue.",
  "input": "Faulty tokenized code:\ndecl_stmt|;\nname|int\nname|ret\ndecl_stmt|,\nname|family\ndecl_stmt|,\nname|sock_error\ndecl_stmt|,\nname|len\ndecl_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+init|=\n+name|AF_UNSPEC\nThe issue was with: net: dns: llmnr_responder: Fix uinit variable\n\nThe family variable was not initialized and could potentially\nbe left like that. This could only affect error printout.\n\nFixes #74796\nCoverity-CID: 368799"
},{
  "instruction": "There is an issue in the following code. It relates to tests: bluetooth: fix missing net_buf_ref(rsp)\n\nRemove unused rsp. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nend_macro\n\nbegin_block\nblock|{\nname|struct\nname|net_buf\nmodifier|*\nname|rsp\ndecl_stmt|;\nname|int\nname|err\ndecl_stmt|;\ncomment|/* Initialize bluetooth subsystem */\nname|bt_enable\nargument_list|(\nname|BT_HCI_OP_READ_CODECS\nargument_list|,\nname|NULL\nargument_list|,\noperator|&\nname|rsp\nargument_list|)\nexpr_stmt|;\nname|zassert_not_equal\nargument_list|(\nname|err",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|struct\n-name|net_buf\n-modifier|*\n-name|rsp\n-decl_stmt|;\n-operator|&\n-name|rsp\n+name|NULL\nThe issue was with: tests: bluetooth: fix missing net_buf_ref(rsp)\n\nRemove unused rsp."
},{
  "instruction": "There is an issue in the following code. It relates to modem: ppp: coverity 330618: explicitly ignore retval\n\nExplicitly ignore the return value of net_pkt_read_u8() as the\nnet_pkt is validated before being queued for transmit within\nmodem_ppp_ppp_api_send() Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|;\ncomment|/* Writing data */\ncase|case\nname|MODEM_PPP_TRANSMIT_STATE_DATA\ncase|:\nname|net_pkt_read_u8\nargument_list|(\nname|ppp\noperator|->\nname|tx_pkt",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+name|void\n+operator|)\nThe issue was with: modem: ppp: coverity 330618: explicitly ignore retval\n\nExplicitly ignore the return value of net_pkt_read_u8() as the\nnet_pkt is validated before being queued for transmit within\nmodem_ppp_ppp_api_send()"
},{
  "instruction": "There is an issue in the following code. It relates to subsys/net/lib/http: Set feature macro as required\n\nThis file uses strnlen() but the C library\nis not require to expose its prototype unless\n_POSIX_C_SOURCE is defined.\nSo let's define it to avoid an implicit function\ndeclaration warning. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright (c) 2023, Emna Rekik  * Copyright (c) 2024 Nordic Semiconductor ASA  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nfile|<errno.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_undef\n+undef|#\n+directive|undef\n+name|_POSIX_C_SOURCE\n+end_undef\n+\n+begin_define\n+DECL|macro|_POSIX_C_SOURCE\n+define|#\n+directive|define\n+name|_POSIX_C_SOURCE\n+value|200809L\n+end_define\n+\n+begin_comment\n+DECL|macro|_POSIX_C_SOURCE\n+comment|/* Required for strnlen() */\n+end_comment\n+\nThe issue was with: subsys/net/lib/http: Set feature macro as required\n\nThis file uses strnlen() but the C library\nis not require to expose its prototype unless\n_POSIX_C_SOURCE is defined.\nSo let's define it to avoid an implicit function\ndeclaration warning."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: esp32_usb: fix interrupt-enable race condition\n\nAfter enabling interrupts, serial_esp32_usb_irq_tx_enable() calls the\ninterrupt handler to handle any old events that occurred while interrupts\nwere disabled.  However, this happens in the callers context, so if an\ninterrupt arrives during the call, it will call the interrupt handler again\nresulting in corruption if the interrupt handler is not reentrant.\n\nFixes #74569 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|irq_cb\noperator|!=\nname|NULL\ncondition|)\nblock|{\nname|data\noperator|->\nname|irq_cb\nargument_list|(\nname|dev\nname|data\noperator|->\nname|irq_cb_data\nargument_list|)\nexpr_stmt|;\nblock|}\nblock|}\nend_function\n\nbegin_function\noperator|->\nname|data\ndecl_stmt|;\nname|data\noperator|->\nname|irq_cb\noperator|=\nname|cb\nexpr_stmt|;\nname|data\noperator|->\nname|irq_cb_data\noperator|=\nname|cb_data\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|unsigned\n+name|int\n+name|key\n+init|=\n+name|irq_lock\n+argument_list|()\n+decl_stmt|;\n+name|arch_irq_unlock\n+argument_list|(\n+name|key\n+argument_list|)\n+expr_stmt|;\n-name|irq_cb\n+name|irq_cb_data\n-name|cb\n+name|cb_data\n-name|irq_cb_data\n+name|irq_cb\n-name|cb_data\n+name|cb\nThe issue was with: drivers: serial: esp32_usb: fix interrupt-enable race condition\n\nAfter enabling interrupts, serial_esp32_usb_irq_tx_enable() calls the\ninterrupt handler to handle any old events that occurred while interrupts\nwere disabled.  However, this happens in the callers context, so if an\ninterrupt arrives during the call, it will call the interrupt handler again\nresulting in corruption if the interrupt handler is not reentrant.\n\nFixes #74569"
},{
  "instruction": "There is an issue in the following code. It relates to driver/bluetooth/h4_ifx_cyw43xxx: Allow CBUCK regulator to discharge\n\nProblem:\nre-plug USB (e.g cy8cproto_062_4343w kit) can cause that\nCY43xx device become unresponsive (cy8cproto_062_4343w).\nAs result we catch ASSERTION FAIL (timeout) on HCI_Reset command.\n\nFix: added delay (BT_POWER_CBUCK_DISCHARGE_TIME_MS) to be sure\nthat BT CBUCK regulator to discharge.\n\nTested on:\ncy8cproto_062_4343w, cy8ckit_062s2_ai and cy8ckit_062s2_43012 kits. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|BT_POWER_ON_SETTLING_TIME_MS\nvalue|(500u)\nend_define\n\nbegin_comment\ncomment|/* Stabilization delay after FW loading */\nend_comment\n\nbegin_define\nname|brcm_patch_ram_length\ndecl_stmt|;\nend_decl_stmt\n\nbegin_enum\nDECL|enum|__anon29d6af930103\nenum|enum\nblock|{\nDECL|enumerator|BT_HCI_VND_OP_DOWNLOAD_MINIDRIVER\nname|BT_HCI_VND_OP_DOWNLOAD_MINIDRIVER\ninit|=\nname|gpio_pin_configure_dt\nargument_list|(\noperator|&\nname|bt_reg_on\nargument_list|,\nname|GPIO_OUTPUT\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|err\nexpr_stmt|;\nreturn|return\nname|err\nreturn|;\nblock|}\nname|err\noperator|=\nname|gpio_pin_set_dt\nargument_list|(\noperator|&",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_define\n+DECL|macro|BT_POWER_CBUCK_DISCHARGE_TIME_MS\n+define|#\n+directive|define\n+name|BT_POWER_CBUCK_DISCHARGE_TIME_MS\n+value|(300u)\n+end_define\n+\n-DECL|enum|__anon29d6af930103\n+DECL|enum|__anon27d42a310103\n-name|GPIO_OUTPUT\n+name|GPIO_OUTPUT_LOW\n+comment|/* Allow BT CBUCK regulator to discharge */\n+operator|(\n+name|void\n+operator|)\n+name|k_msleep\n+argument_list|(\n+name|BT_POWER_CBUCK_DISCHARGE_TIME_MS\n+argument_list|)\n+expr_stmt|;\nThe issue was with: driver/bluetooth/h4_ifx_cyw43xxx: Allow CBUCK regulator to discharge\n\nProblem:\nre-plug USB (e.g cy8cproto_062_4343w kit) can cause that\nCY43xx device become unresponsive (cy8cproto_062_4343w).\nAs result we catch ASSERTION FAIL (timeout) on HCI_Reset command.\n\nFix: added delay (BT_POWER_CBUCK_DISCHARGE_TIME_MS) to be sure\nthat BT CBUCK regulator to discharge.\n\nTested on:\ncy8cproto_062_4343w, cy8ckit_062s2_ai and cy8ckit_062s2_43012 kits."
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: counter: support STM32 w/o RTC\n\nThis commit adds a missing #ifdef check which prevents building the\n'counter_basic_api' test for boards under the following conditions:\n * RTC node is defined in device tree (compatible = \\\"st,stm32-rtc\\\")\n * RTC node is disabled in device tree (status = \\\"disabled\\\")\n * Kconfig \\\"CONFIG_COUNTER_RTC_STM32=n\\\" is specified\n\nThis check matches the ones done a few lines above for NXP MCUs.\n\nWithout this check, building the test under the conditions listed above\nfailed with the infamous `undefined reference to '__device_dts_ord_N'`\nlinker error, because the test attempts to obtain RTC's `struct device`\ndespite CONFIG_COUNTER_RTC_STM32=n, which ultimately fails because the\nRTC driver is not built unless there is an enabled RTC node in DT. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nargument|nxp_lpc_rtc\nargument_list|)\nendif|#\ndirective|endif\nname|DEVS_FOR_DT_COMPAT\nargument_list|(\nargument|st_stm32_rtc\nargument_list|)\nblock|}\ndecl_stmt|;\nend_decl_stmt\n\nbegin_typedef",
  "result": "I corrected the issue in the code by changing the following tokens:\n+ifdef|#\n+directive|ifdef\n+name|CONFIG_COUNTER_RTC_STM32\n+endif|#\n+directive|endif\nThe issue was with: tests: drivers: counter: support STM32 w/o RTC\n\nThis commit adds a missing #ifdef check which prevents building the\n'counter_basic_api' test for boards under the following conditions:\n * RTC node is defined in device tree (compatible = \\\"st,stm32-rtc\\\")\n * RTC node is disabled in device tree (status = \\\"disabled\\\")\n * Kconfig \\\"CONFIG_COUNTER_RTC_STM32=n\\\" is specified\n\nThis check matches the ones done a few lines above for NXP MCUs.\n\nWithout this check, building the test under the conditions listed above\nfailed with the infamous `undefined reference to '__device_dts_ord_N'`\nlinker error, because the test attempts to obtain RTC's `struct device`\ndespite CONFIG_COUNTER_RTC_STM32=n, which ultimately fails because the\nRTC driver is not built unless there is an enabled RTC node in DT."
},{
  "instruction": "There is an issue in the following code. It relates to samples: subsys: display: lvgl: Remove kscan pointer check\n\nRemoves the check for whether or not the kscan kconfig option is set to\nchange the GUI accordingly. Please fix this issue.",
  "input": "Faulty tokenized code:\ncomment|/* CONFIG_LV_Z_KEYPAD_INPUT */\nif|if\ncondition|(\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_LV_Z_POINTER_KSCAN\nargument_list|)\noperator|||\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_LV_Z_POINTER_INPUT\nargument_list|)\ncondition|)\nblock|{\nname|lv_obj_t",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_LV_Z_POINTER_KSCAN\n-argument_list|)\n-operator|||\n-name|IS_ENABLED\n-argument_list|(\nThe issue was with: samples: subsys: display: lvgl: Remove kscan pointer check\n\nRemoves the check for whether or not the kscan kconfig option is set to\nchange the GUI accordingly."
},{
  "instruction": "There is an issue in the following code. It relates to Revert \\\"soc: intel_adsp: only implement FW_STATUS boot protocol for cavs\\\"\n\nThis breaks SOF load on MTL devices.  See SOF bug for details:\nhttps://github.com/thesofproject/sof/issues/9243\n\nThis reverts commit 85b9668f7f027dae5a63311cfbc19880858ca87a [formerly fa798ce2d5be6deb8a3b0cde307a0a1dc5e88dde]. Please fix this issue.",
  "input": "Faulty tokenized code:\n\nzephyr_library_sources(\n    sram.c\n    power.c\n    power_down_cavs.S\n   boot_complete.c\n    )\n\nif(CONFIG_SMP OR CONFIG_MP_MAX_NUM_CPUS GREATER 1)\n    zephyr_library_sources(multiprocessing.c)\nendif()\nzephyr_library_sources(\n    rimage_modules.c\n    boot.c\n    soc.c\n    mem_window.c\n    )\n\nzephyr_library_sources_ifdef(CONFIG_ADSP_CLOCK clk.c)\n\nif(CONFIG_SMP OR CONFIG_MP_MAX_NUM_CPUS GREATER 1)\nsimilarity index 100%\nrename from soc/intel/intel_adsp/cavs/boot_complete.c\nrename to soc/intel/intel_adsp/common/boot_complete.c",
  "result": "I corrected the issue in the code by changing the following tokens:\n-    boot_complete.c\n+    boot_complete.c\nThe issue was with: Revert \\\"soc: intel_adsp: only implement FW_STATUS boot protocol for cavs\\\"\n\nThis breaks SOF load on MTL devices.  See SOF bug for details:\nhttps://github.com/thesofproject/sof/issues/9243\n\nThis reverts commit 85b9668f7f027dae5a63311cfbc19880858ca87a [formerly fa798ce2d5be6deb8a3b0cde307a0a1dc5e88dde]."
},{
  "instruction": "There is an issue in the following code. It relates to bluetooth: host: Use K_WORK replace delayable\n\nUse K_WORK defined. This delayed work is never used with any\nother timeout than K_NO_WAIT, so the \\\"delayed\\\" part of it\nis never actually needed Please fix this issue.",
  "input": "Faulty tokenized code:\nname|hci_vs_init\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nDECL|union|__anon2745dde9010a\nunion|union\nblock|{\nDECL|member|info\nname|struct\nname|bt_hci_rp_vs_read_version_info\nname|bt_conn_tx_processor\nargument_list|()\nexpr_stmt|;\nblock|}\nblock|}\nname|K_WORK_DELAYABLE_DEFINE\nargument_list|(\nname|tx_work\nargument_list|,\nname|tx_processor\nargument_list|)\nname|LOG_DBG\nargument_list|(\nliteral|\"kick TX\"\nargument_list|)\nexpr_stmt|;\nname|k_work_reschedule\nargument_list|(\noperator|&\nname|tx_work\nargument_list|,\nname|K_NO_WAIT\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon2745dde9010a\n+DECL|union|__anon2bb157b8010a\n-name|K_WORK_DELAYABLE_DEFINE\n+specifier|static\n+name|K_WORK_DEFINE\n-name|k_work_reschedule\n+name|k_work_submit\n-argument_list|,\n-name|K_NO_WAIT\nThe issue was with: bluetooth: host: Use K_WORK replace delayable\n\nUse K_WORK defined. This delayed work is never used with any\nother timeout than K_NO_WAIT, so the \\\"delayed\\\" part of it\nis never actually needed"
},{
  "instruction": "There is an issue in the following code. It relates to net: lib: zperf: Fix socket leak during asynchronous TCP upload\n\nIn case of TCP upload error, zperf would leak a socket when running in\nasynchronous mode. The upload work have to release the socket it\nallocated in any case, regardless of the session result. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|upload_ctx\noperator|->\nname|user_data\nargument_list|)\nexpr_stmt|;\nreturn|return;\nblock|}\nname|upload_ctx\noperator|->\nname|callback\nargument_list|(\nname|upload_ctx\noperator|->\nname|user_data\nargument_list|)\nexpr_stmt|;\nreturn|return;\nblock|}\nblock|}\nname|upload_ctx\noperator|->\nname|callback\nname|upload_ctx\noperator|->\nname|user_data\nargument_list|)\nexpr_stmt|;\nname|zsock_close\nargument_list|(\nname|sock\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-return|return;\n+goto|goto\n+name|cleanup\n+goto|;\n-return|return;\n+goto|goto\n+name|cleanup\n+goto|;\n+name|cleanup\n+label|:\nThe issue was with: net: lib: zperf: Fix socket leak during asynchronous TCP upload\n\nIn case of TCP upload error, zperf would leak a socket when running in\nasynchronous mode. The upload work have to release the socket it\nallocated in any case, regardless of the session result."
},{
  "instruction": "There is an issue in the following code. It relates to usb: cdc_acm: Update log level only if UART log backend is enabled\n\nChange updates log level only if UART log backend is enabled in Kconfig\nconfiguration. The log level update is not needed in case logs are\nprovided over other backend (e.g. RTT).\n\nChange affects both USB stacks. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr|\\\noperator|&&\nname|defined\nargument_list|(\nname|CONFIG_USB_CDC_ACM_LOG_LEVEL\nargument_list|)\nexpr|\\\noperator|&&\nname|CONFIG_USB_CDC_ACM_LOG_LEVEL\nargument_list|)\nexpr|\\\noperator|&&\nname|defined\nargument_list|(\nname|CONFIG_USBD_CDC_ACM_LOG_LEVEL\nargument_list|)\nexpr|\\\noperator|&&\nname|CONFIG_USBD_CDC_ACM_LOG_LEVEL",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|CONFIG_LOG_BACKEND_UART\n+argument_list|)\n+expr|\\\n+operator|&&\n+name|defined\n+argument_list|(\n+name|CONFIG_LOG_BACKEND_UART\n+argument_list|)\n+expr|\\\n+operator|&&\n+name|defined\n+argument_list|(\nThe issue was with: usb: cdc_acm: Update log level only if UART log backend is enabled\n\nChange updates log level only if UART log backend is enabled in Kconfig\nconfiguration. The log level update is not needed in case logs are\nprovided over other backend (e.g. RTT).\n\nChange affects both USB stacks."
},{
  "instruction": "There is an issue in the following code. It relates to net: lib: dns: Fix error code returned when socket creation failed\n\nWe should return the errno value in such case, as ret will always be -1\non failure, which might misleading, as it does not give any hint on what\nfailed.\n\nAlso bump the log level of the error message, so the failure is visible\nw/o needing to enable debug logs. Such a failure is fatal for the DNS\nsubsystem, so error level is justified here. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ret\noperator|<\nliteral|0\ncondition|)\nblock|{\nname|NET_DBG\nargument_list|(\nliteral|\"Cannot get socket (%d)\"\nargument_list|,\nname|ret\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|NET_DBG\n+name|ret\n+operator|=\n+operator|-\n+name|errno\n+expr_stmt|;\n+name|NET_ERR\nThe issue was with: net: lib: dns: Fix error code returned when socket creation failed\n\nWe should return the errno value in such case, as ret will always be -1\non failure, which might misleading, as it does not give any hint on what\nfailed.\n\nAlso bump the log level of the error message, so the failure is visible\nw/o needing to enable debug logs. Such a failure is fatal for the DNS\nsubsystem, so error level is justified here."
},{
  "instruction": "There is an issue in the following code. It relates to net: lib: dns: Fix DNS dispatcher double net buf unref\n\nThe `dns_data` buffer, allocated by the DNS dispatcher was dereferenced\ntwice - once in registered DNS handler, second time in the dispatcher\nitself.\n\nSince the buffer was allocated by the dispatcher, and it's not really\nguaranteed that the buffer will be freed in the registered handler (this\ndepends on the processing outcome, the function may return early w/o\nfreeing the net buf in case of errors), it makes most sense for the\ndispatcher to keep ownership of the buffer. Hence, the registered\nhandlers will no longer release the buffer provided in any case, and the\ndispatcher will free it on exit. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|ret\nargument_list|)\nexpr_stmt|;\nblock|}\nname|net_buf_unref\nargument_list|(\nname|dns_data\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|ret\nreturn|;\nblock|}\nend_function\nexpr_stmt|;\nname|free_buf\nlabel|:\nif|if\ncondition|(\nname|dns_data\ncondition|)\nblock|{\nname|net_buf_unref\nargument_list|(\nname|dns_data\nargument_list|)\nexpr_stmt|;\nblock|}\nif|if\ncondition|(\nname|dns_cname\ncondition|)\nblock|{\nname|net_buf_unref\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|net_buf_unref\n-argument_list|(\n-name|dns_data\n-argument_list|)\n-expr_stmt|;\n-name|dns_data\n-condition|)\n-block|{\n-name|net_buf_unref\n-argument_list|(\n-name|dns_data\n-argument_list|)\n-expr_stmt|;\n-block|}\n-if|if\n-condition|(\nThe issue was with: net: lib: dns: Fix DNS dispatcher double net buf unref\n\nThe `dns_data` buffer, allocated by the DNS dispatcher was dereferenced\ntwice - once in registered DNS handler, second time in the dispatcher\nitself.\n\nSince the buffer was allocated by the dispatcher, and it's not really\nguaranteed that the buffer will be freed in the registered handler (this\ndepends on the processing outcome, the function may return early w/o\nfreeing the net buf in case of errors), it makes most sense for the\ndispatcher to keep ownership of the buffer. Hence, the registered\nhandlers will no longer release the buffer provided in any case, and the\ndispatcher will free it on exit."
},{
  "instruction": "There is an issue in the following code. It relates to driver: bbram: npcx: fix the way to clear bbram status\n\nBits in the BBRAM status register (BKUP_STS) are write-1-to-clear bits.\nThe current driver writes 0 to clear those bits, which is incorrect.\nFix it in this commit. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|dev\nargument_list|)\noperator|&\nname|mask\ndecl_stmt|;\ncomment|/* Clear the bit(s) */\nname|DRV_STATUS\nargument_list|(\nname|dev\nargument_list|)\noperator|&=\noperator|~\nname|mask\nexpr_stmt|;\nreturn|return\nname|result\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* Clear the bit(s) */\n+comment|/* \t * Clear the bit(s): \t *   For emulator, write 0 to clear status bit(s). \t *   For real chip, write 1 to clear status bit(s). \t */\n+ifdef|#\n+directive|ifdef\n+name|CONFIG_BBRAM_NPCX_EMUL\n+else|#\n+directive|else\n+name|DRV_STATUS\n+argument_list|(\n+name|dev\n+argument_list|)\n+operator|=\n+name|mask\n+expr_stmt|;\n+endif|#\n+directive|endif\nThe issue was with: driver: bbram: npcx: fix the way to clear bbram status\n\nBits in the BBRAM status register (BKUP_STS) are write-1-to-clear bits.\nThe current driver writes 0 to clear those bits, which is incorrect.\nFix it in this commit."
},{
  "instruction": "There is an issue in the following code. It relates to xtensa: separate FATAL EXCEPTION printout into two\n\nIt is observed that during logging in fatal exception,\nit prints \\\"FATAL EXCEPTION(null)\\\". Exact reason is unknown\nas debugging through GDB would make it all work again. So\nseparating it into two log statements to avoid this situation. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|pc\nexpr_stmt|;\nasm|__asm__\nspecifier|volatile\nasm|(\"rsr.excvaddr %0\" : \"=r\"(vaddr));\nname|LOG_ERR\nargument_list|(\nliteral|\" ** FATAL EXCEPTION%s\"\nargument_list|,\noperator|(\nname|is_dblexc\ncondition|?\nliteral|\" (DOUBLE)\"\nelse|:\nliteral|\"\"\noperator|)\nargument_list|)\nexpr_stmt|;\nname|LOG_ERR\nargument_list|(\nliteral|\" ** CPU %d EXCCAUSE %d (%s)\"\nargument_list|,\nname|arch_curr_cpu",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|is_dblexc\n+condition|)\n+block|{\n-literal|\" ** FATAL EXCEPTION%s\"\n-argument_list|,\n-operator|(\n-name|is_dblexc\n-condition|?\n-literal|\" (DOUBLE)\"\n-else|:\n-literal|\"\"\n-operator|)\n+literal|\" ** FATAL EXCEPTION (DOUBLE)\"\n+block|}\n+else|else\n+block|{\n+name|LOG_ERR\n+argument_list|(\n+literal|\" ** FATAL EXCEPTION\"\n+argument_list|)\n+expr_stmt|;\n+block|}\nThe issue was with: xtensa: separate FATAL EXCEPTION printout into two\n\nIt is observed that during logging in fatal exception,\nit prints \\\"FATAL EXCEPTION(null)\\\". Exact reason is unknown\nas debugging through GDB would make it all work again. So\nseparating it into two log statements to avoid this situation."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: bmm150: Fix setting of attributes\n\nSome functions in the bmm150 driver were depending on a define\nthat was never used. Changed it to the one that is actually defined. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_struct\nDECL|struct|__anon2798605f0108\nspecifier|static\nspecifier|const\nstruct|struct\nblock|{\nDECL|member|freq\nbegin_if\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|BMM150_SET_ATTR\nargument_list|)\nend_if\n\nbegin_function\nDECL|function|bmm150_read_rep_xy (const struct device * dev)\nbegin_if\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|BMM150_SET_ATTR\nargument_list|)\nend_if\n\nbegin_function\nDECL|function|bmm150_attr_set (const struct device * dev,enum sensor_channel chan,enum sensor_attribute attr,const struct sensor_value * val)\nblock|{\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|BMM150_SET_ATTR\nargument_list|)\noperator|.\nname|attr_set\noperator|=\nname|bmm150_attr_set",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2798605f0108\n+DECL|struct|__anon28db83ce0108\n-name|BMM150_SET_ATTR\n+name|BMM150_SET_ATTR_REP\n-name|BMM150_SET_ATTR\n+name|BMM150_SET_ATTR_REP\n-name|BMM150_SET_ATTR\n+name|BMM150_SET_ATTR_REP\nThe issue was with: drivers: sensor: bmm150: Fix setting of attributes\n\nSome functions in the bmm150 driver were depending on a define\nthat was never used. Changed it to the one that is actually defined."
},{
  "instruction": "There is an issue in the following code. It relates to sensor: vcnl36825t: Scrub redundant scaling on meas_timeout_us\n\nConfirming the Proximity Integration is an integer, we don't need to\npre-apply the Scaling factor to then be accounted for when the actual\nmeas_timeout_us is calculated. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|data\noperator|->\nname|meas_timeout_us\noperator|*=\nliteral|1\noperator|*\nname|VCNL36825T_FORCED_FACTOR_SCALE\nexpr_stmt|;\nbreak|break;\ncase|case\nname|VCNL36825T_PROXIMITY_INTEGRATION_2T\ncase|:\nname|data\noperator|->\nname|meas_timeout_us\noperator|*=\nliteral|2\noperator|*\nname|VCNL36825T_FORCED_FACTOR_SCALE\nexpr_stmt|;\nbreak|break;\ncase|case\nname|VCNL36825T_PROXIMITY_INTEGRATION_4T\ncase|:\nname|data\noperator|->\nname|meas_timeout_us\noperator|*=\nliteral|4\noperator|*\nname|VCNL36825T_FORCED_FACTOR_SCALE\nexpr_stmt|;\nbreak|break;\ncase|case\nname|VCNL36825T_PROXIMITY_INTEGRATION_8T\ncase|:\nname|data\noperator|->\nname|meas_timeout_us\noperator|*=\nliteral|8\noperator|*\nname|VCNL36825T_FORCED_FACTOR_SCALE\nexpr_stmt|;\nbreak|break;\nblock|}\nswitch|switch\ncondition|(\nname|VCNL36825T_FORCED_FACTOR_SUM\noperator|)\noperator|/\noperator|(\nname|VCNL36825T_FORCED_FACTOR_SCALE\noperator|*\nname|VCNL36825T_FORCED_FACTOR_SCALE\noperator|)\noperator|+\nliteral|1\nexpr_stmt|;\nreturn|return",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|*\n-name|VCNL36825T_FORCED_FACTOR_SCALE\n-operator|*\n-name|VCNL36825T_FORCED_FACTOR_SCALE\n-operator|*\n-name|VCNL36825T_FORCED_FACTOR_SCALE\n-operator|*\n-name|VCNL36825T_FORCED_FACTOR_SCALE\n-operator|*\n-name|VCNL36825T_FORCED_FACTOR_SCALE\nThe issue was with: sensor: vcnl36825t: Scrub redundant scaling on meas_timeout_us\n\nConfirming the Proximity Integration is an integer, we don't need to\npre-apply the Scaling factor to then be accounted for when the actual\nmeas_timeout_us is calculated."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: fix cfg.baudrate may be used uninitialized\n\ndrivers/serial/uart_async_to_irq.c: In function 'get_rx_timeout':\ndrivers/serial/uart_async_to_irq.c:51:26:\nwarning: 'cfg.baudrate' may be used uninitialized\n   51 |                 baudrate = cfg.baudrate;\n      |                 ~~~~~~~~~^~~~~~~~~~~~~~\ndrivers/serial/uart_async_to_irq.c:45:28: note: 'cfg' declared here\n   45 |         struct uart_config cfg; Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|)\nblock|{\nname|struct\nname|uart_config\nname|cfg\ndecl_stmt|;\nname|int\nname|err\ndecl_stmt|;\nname|uint32_t",
  "result": "I corrected the issue in the code by changing the following tokens:\n+init|=\n+block|{\n+literal|0\n+block|}\nThe issue was with: drivers: serial: fix cfg.baudrate may be used uninitialized\n\ndrivers/serial/uart_async_to_irq.c: In function 'get_rx_timeout':\ndrivers/serial/uart_async_to_irq.c:51:26:\nwarning: 'cfg.baudrate' may be used uninitialized\n   51 |                 baudrate = cfg.baudrate;\n      |                 ~~~~~~~~~^~~~~~~~~~~~~~\ndrivers/serial/uart_async_to_irq.c:45:28: note: 'cfg' declared here\n   45 |         struct uart_config cfg;"
},{
  "instruction": "There is an issue in the following code. It relates to net: ethernet: Fix EAPol packet length changed wrongly\n\nIn ethernet_recv(), it will call ethernet_update_length() to check for\nipv4 or ipv6 packet if it needs to get rid of the padding in the\npackets. But for EAPOL packets, no need to do this, which may modify\nthe packet length of EAP type packet wrongly and leads to EAPoL\npackets dropped in supplicant. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|pkt\nargument_list|)\nreturn|;\nblock|}\nname|ethernet_update_length\nargument_list|(\nname|iface\nargument_list|,\nname|pkt\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|NET_CONTINUE\nreturn|;\nname|drop\nlabel|:",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|type\n+operator|!=\n+name|NET_ETH_PTYPE_EAPOL\n+condition|)\n+block|{\n+block|}\nThe issue was with: net: ethernet: Fix EAPol packet length changed wrongly\n\nIn ethernet_recv(), it will call ethernet_update_length() to check for\nipv4 or ipv6 packet if it needs to get rid of the padding in the\npackets. But for EAPOL packets, no need to do this, which may modify\nthe packet length of EAP type packet wrongly and leads to EAPoL\npackets dropped in supplicant."
},{
  "instruction": "There is an issue in the following code. It relates to hostap: fix wifi sta connection not triggerred issue\n\nUse select_network instead of enable_network, then can trigger sta\nconnection mutiple times. Also update the configuration in\nadd_interface(). Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\ngoto|goto\nname|out\ngoto|;\nblock|}\nreturn|return\nliteral|0\nreturn|;\nname|rem_net\nlabel|:",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+operator|!\n+name|wpa_cli_cmd_v\n+argument_list|(\n+literal|\"select_network %d\"\n+argument_list|,\n+name|resp\n+operator|.\n+name|network_id\n+argument_list|)\n+condition|)\n+block|{\n+goto|goto\n+name|out\n+goto|;\n+block|}\nThe issue was with: hostap: fix wifi sta connection not triggerred issue\n\nUse select_network instead of enable_network, then can trigger sta\nconnection mutiple times. Also update the configuration in\nadd_interface()."
},{
  "instruction": "There is an issue in the following code. It relates to Drivers: DAI: Intel: Remove trace from dai_dmic_update_bits()\n\nThe dai_dmic_update_bits() function is used in start trigger\ncode dai_dmic_start() and in capture runtime to control DMIC\nIP in unmute sequence. Especially the start sequence is timing\ncritical so it's better not produce additional delay in this\nfunction. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|reg_base\noperator|+\nname|reg\ndecl_stmt|;\nname|LOG_INF\nargument_list|(\nliteral|\"%s base %x, reg %x, mask %x, value %x\"\nargument_list|,\nname|__func__\nargument_list|,\nname|dmic\noperator|->\nname|reg_base\nargument_list|,\nname|reg\nargument_list|,\nname|mask\nargument_list|,\nname|val\nargument_list|)\nexpr_stmt|;\nname|sys_write32\nargument_list|(\noperator|(\nname|sys_read32\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|LOG_INF\n-argument_list|(\n-literal|\"%s base %x, reg %x, mask %x, value %x\"\n-argument_list|,\n-name|__func__\n-argument_list|,\n-name|dmic\n-operator|->\n-name|reg_base\n-argument_list|,\n-name|reg\n-argument_list|,\n-name|mask\n-argument_list|,\n-name|val\n-argument_list|)\n-expr_stmt|;\nThe issue was with: Drivers: DAI: Intel: Remove trace from dai_dmic_update_bits()\n\nThe dai_dmic_update_bits() function is used in start trigger\ncode dai_dmic_start() and in capture runtime to control DMIC\nIP in unmute sequence. Especially the start sequence is timing\ncritical so it's better not produce additional delay in this\nfunction."
},{
  "instruction": "There is an issue in the following code. It relates to net: lib: http_server: Fix dynamic HTTP post zero 0 length reply\n\nFix issue in http server that a http post\nwas unable to send a 0 length reply. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|crlf\nargument_list|,\nliteral|2\nargument_list|)\nexpr_stmt|;\nname|offset\noperator|+=\nname|copy_len\nexpr_stmt|;\nname|remaining\noperator|-=\nname|copy_len\nexpr_stmt|;\nblock|}\nname|copy_len\noperator|=\nname|MIN\nargument_list|(\nname|remaining",
  "result": "I corrected the issue in the code by changing the following tokens:\n+block|}\n-block|}\nThe issue was with: net: lib: http_server: Fix dynamic HTTP post zero 0 length reply\n\nFix issue in http server that a http post\nwas unable to send a 0 length reply."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: usb_device: smartbond: Fix EP OUT after resume\n\nWhen device was resumed from sleep OUT endpoints were most\nlikely not enabled due to condition that checked pending transfer.\nConfigured OUT endpoints should be enabled (ready for RX)\nif they were enabled by interfaces.\n\nNow separate bit field enabled is added and check to\nsee if OUT endpoint should be ready for reception after\nsleep is done. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|iso\nrange|:\nliteral|1\ndecl_stmt|;\ncomment|/** ISO endpoint */\nDECL|member|ep_addr\nname|uint8_t\nname|ep_addr\ndecl_stmt|;\ncomment|/** EP address */\nexpr_stmt|;\nif|if\ncondition|(\nname|ep_state\noperator|->\nname|total_len\noperator|>\nname|ep_state\noperator|->\nname|transferred\ncondition|)\nblock|{\nname|start_rx_packet\nargument_list|(\nname|ep_state\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}\nif|if\ncondition|(\nname|ep_state\noperator|->\nname|ep_addr\nname|epc_in\noperator||=\nname|USB_USB_EPC2_REG_USB_EP_EN_Msk\nexpr_stmt|;\nblock|}\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+DECL|member|enabled\n+name|uint8_t\n+name|enabled\n+range|:\n+literal|1\n+decl_stmt|;\n+comment|/** Endpoint is enabled */\n-name|total_len\n-operator|>\n-name|ep_state\n-operator|->\n-name|transferred\n+name|enabled\n+name|ep_state\n+operator|->\n+name|enabled\n+operator|=\n+literal|0\n+expr_stmt|;\n+name|ep_state\n+operator|->\n+name|enabled\n+operator|=\n+literal|1\n+expr_stmt|;\nThe issue was with: drivers: usb_device: smartbond: Fix EP OUT after resume\n\nWhen device was resumed from sleep OUT endpoints were most\nlikely not enabled due to condition that checked pending transfer.\nConfigured OUT endpoints should be enabled (ready for RX)\nif they were enabled by interfaces.\n\nNow separate bit field enabled is added and check to\nsee if OUT endpoint should be ready for reception after\nsleep is done."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: usb_device: smartbond: Fix unnecessary flush\n\nSwitching from write to read on EP0 is done when data is\ntransmitted.\nAdditionally receiver is enabled when NAK is created in\nresponse to OUT token. This may happen when host sent\nZLP before everything was transmitted.\nThis case flushed receiver FIFO which could lead to\nsetup packet corruption. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|USB_USB_EP0_NAK_REG_USB_EP0_OUTNAK\nargument_list|)\ncondition|)\nblock|{\ncomment|/* NAK over EP0 was sent, transmit should conclude */\nname|USB\noperator|->\nname|USB_TXC0_REG\noperator|=\nname|USB_USB_TXC0_REG_USB_FLUSH_Msk\nexpr_stmt|;\nname|REG_SET_BIT\nargument_list|(\nname|USB_RXC0_REG\nargument_list|,\nname|USB_FLUSH\nargument_list|)\nexpr_stmt|;\nname|REG_SET_BIT\nargument_list|(\nname|USB_RXC0_REG\nargument_list|,\nname|USB_RX_EN\nargument_list|)\nexpr_stmt|;\nname|REG_CLR_BIT\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* NAK over EP0 was sent, transmit should conclude */\n+comment|/* NAK over EP0 was sent, receive should conclude */\n-name|USB_FLUSH\n-argument_list|)\n-expr_stmt|;\n-name|REG_SET_BIT\n-argument_list|(\n-name|USB_RXC0_REG\n-argument_list|,\nThe issue was with: drivers: usb_device: smartbond: Fix unnecessary flush\n\nSwitching from write to read on EP0 is done when data is\ntransmitted.\nAdditionally receiver is enabled when NAK is created in\nresponse to OUT token. This may happen when host sent\nZLP before everything was transmitted.\nThis case flushed receiver FIFO which could lead to\nsetup packet corruption."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: usb_device: smartbond: Fix reenable of EP0\n\nWhen EP0 was disabled EP0 was setup to ignore setup and\nout packets.\nIn usb_dc_ep_enable() function mask was never cleared.\nIt resulted in USB stop functioning after application\ndisabled endpoint (usb_disable()) and then tried\nto enable usb again. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|USB_MAMSK_REG\noperator||=\nname|USB_USB_MAMSK_REG_USB_M_EP0_RX_Msk\nexpr_stmt|;\nname|ep_state\noperator|->\nname|last_packet_size\noperator|=\nliteral|0",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Clear USB_IGN_SETUP and USB_IGN_OUT */\n+name|USB\n+operator|->\n+name|USB_RXC0_REG\n+operator|=\n+literal|0\n+expr_stmt|;\nThe issue was with: drivers: usb_device: smartbond: Fix reenable of EP0\n\nWhen EP0 was disabled EP0 was setup to ignore setup and\nout packets.\nIn usb_dc_ep_enable() function mask was never cleared.\nIt resulted in USB stop functioning after application\ndisabled endpoint (usb_disable()) and then tried\nto enable usb again."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: usb_device: smartbond: Fix VBUS interrupt enable\n\nCode was enabling USB_IRQn twice. One of the calls clearly\nshould be enabling VBUS_IRQn. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator||\nname|CRG_TOP_VBUS_IRQ_MASK_REG_VBUS_IRQ_EN_RISE_Msk\nexpr_stmt|;\nname|irq_enable\nargument_list|(\nname|USB_IRQn\nargument_list|)\nexpr_stmt|;\nname|IRQ_CONNECT\nargument_list|(\nname|USB_IRQ",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|USB_IRQn\n+name|VBUS_IRQn\nThe issue was with: drivers: usb_device: smartbond: Fix VBUS interrupt enable\n\nCode was enabling USB_IRQn twice. One of the calls clearly\nshould be enabling VBUS_IRQn."
},{
  "instruction": "There is an issue in the following code. It relates to tests: fs: nvs: add `mps2/an385` support\n\nAdd support for running the test with the simulated `mps2/an385` board. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/*  * Copyright (c) 2019 Nordic Semiconductor ASA  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_comment\ncomment|/*  * This test is designed to be run using flash-simulator which provide  * functionality for flash property customization and emulating errors in  * flash operation in parallel to regular flash API.  * Test should be run on qemu_x86 or native_sim target.  */\nend_comment\n\nbegin_if\nif|#\ndirective|if\noperator|!\nname|defined\nargument_list|(\nname|CONFIG_ARCH_POSIX\nargument_list|)\nend_if\n\nbegin_error\nerror|#\ndirective|error\nliteral|\"Run only on qemu_x86 or a posix architecture based target (for ex. native_sim)\"\nend_error\n\nbegin_endif\nendif|#\ndirective|endif\ncommon:\n  tags: nvs\ntests:\n  filesystem.nvs:\n   platform_allow: qemu_x86\n  filesystem.nvs.0x00:\n    extra_args: DTC_OVERLAY_FILE=boards/qemu_x86_ev_0x00.overlay\n    platform_allow: qemu_x86\n  filesystem.nvs.sim.no_erase:\n    extra_args: CONFIG_FLASH_SIMULATOR_EXPLICIT_ERASE=n",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/*  * This test is designed to be run using flash-simulator which provide  * functionality for flash property customization and emulating errors in  * flash operation in parallel to regular flash API.  * Test should be run on qemu_x86 or native_sim target.  */\n+comment|/*  * This test is designed to be run using flash-simulator which provide  * functionality for flash property customization and emulating errors in  * flash operation in parallel to regular flash API.  * Test should be run on qemu_x86, mps2_an385 or native_sim target.  */\n+operator|&&\n+expr|\\\n+operator|!\n+name|defined\n+argument_list|(\n+name|CONFIG_BOARD_MPS2_AN385\n+argument_list|)\n-literal|\"Run only on qemu_x86 or a posix architecture based target (for ex. native_sim)\"\n+literal|\"Run only on qemu_x86, mps2_an385, or a posix architecture based target (for ex. native_sim)\"\n-    platform_allow: qemu_x86\n+    platform_allow:\n+      - qemu_x86\n+      - mps2/an385\nThe issue was with: tests: fs: nvs: add `mps2/an385` support\n\nAdd support for running the test with the simulated `mps2/an385` board."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: intc_gic: Return GICC_IAR without mask\n\nThe documentation recommends to read and then write-back the entire\nregister, when ending interrupts. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|arm_gic_get_active\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nname|int\nname|irq\ndecl_stmt|;\nname|irq\noperator|=\nname|sys_read32\nargument_list|(\nname|GICC_IAR\nargument_list|)\noperator|&\nliteral|0x3ff\nexpr_stmt|;\nreturn|return\nname|irq\nreturn|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|unsigned\n+comment|/* \t * \"ARM Generic Interrupt Controller Architecture version 2.0\" states that \t * [4.4.5 End of Interrupt Register, GICC_EOIR)]: \t * \"\"\" \t * For compatibility with possible extensions to the GIC architecture \t * specification, ARM recommends that software preserves the entire register \t * value read from the GICC_IAR when it acknowledges the interrupt, and uses \t * that entire value for its corresponding write to the GICC_EOIR. \t * \"\"\" \t * Because of that, we read the entire value here, to be later written back to GICC_EOIR \t */\n-operator|&\n-literal|0x3ff\nThe issue was with: drivers: intc_gic: Return GICC_IAR without mask\n\nThe documentation recommends to read and then write-back the entire\nregister, when ending interrupts."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: rtc: rv3028: fix RTC time mask\n\nCorrect the RTC time mask to validate all supported fields. Please fix this issue.",
  "input": "Faulty tokenized code:\nDECL|macro|RV3028_RTC_TIME_MASK\ndefine|#\ndirective|define\nname|RV3028_RTC_TIME_MASK\ndefine|\\\nvalue|(RTC_ALARM_TIME_MASK_SECOND | RTC_ALARM_TIME_MASK_MINUTE | RTC_ALARM_TIME_MASK_HOUR |      \\ \t RTC_ALARM_TIME_MASK_MONTH | RTC_ALARM_TIME_MASK_YEAR)\nend_define\n\nbegin_comment\ncomment|/* Helper macro to guard int-gpios related code */\nend_comment",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|(RTC_ALARM_TIME_MASK_SECOND | RTC_ALARM_TIME_MASK_MINUTE | RTC_ALARM_TIME_MASK_HOUR |      \\ \t RTC_ALARM_TIME_MASK_MONTH | RTC_ALARM_TIME_MASK_YEAR)\n+value|(RTC_ALARM_TIME_MASK_SECOND | RTC_ALARM_TIME_MASK_MINUTE | RTC_ALARM_TIME_MASK_HOUR |      \\ \t RTC_ALARM_TIME_MASK_MONTH | RTC_ALARM_TIME_MASK_MONTHDAY | RTC_ALARM_TIME_MASK_YEAR |     \\ \t RTC_ALARM_TIME_MASK_WEEKDAY)\nThe issue was with: drivers: rtc: rv3028: fix RTC time mask\n\nCorrect the RTC time mask to validate all supported fields."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: rtc: pcf8563: check if the node has an interrupt pin\n\nVerify if the int1_gpios property exists for the specific node. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|int\nname|ret\ndecl_stmt|;\nif|if\ncondition|(\nname|id\noperator|!=\nliteral|0\ncondition|)\nblock|{\nname|name\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}\ncomment|/* Check if it's alive. */\nname|ret\noperator|=\nname|ret\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|EIO\nreturn|;\nblock|}\nname|LOG_INF\nargument_list|(\nliteral|\"%s is initialized!\"",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|config\n+operator|->\n+name|int1\n+operator|.\n+name|port\n+operator|==\n+name|NULL\n+condition|)\n+block|{\n+return|return\n+operator|-\n+name|ENOTSUP\n+return|;\n+block|}\n+if|if\n+condition|(\n-name|EINVAL\n+name|ENODEV\n-name|EIO\n+name|ENODEV\nThe issue was with: drivers: rtc: pcf8563: check if the node has an interrupt pin\n\nVerify if the int1_gpios property exists for the specific node."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: l2cap: service as much TX channels as possible\n\nSimilar to ISO connections, ACL connections are not serviced as fast as\npossible. Change this, and try to send as much as we have resources for. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|\"no channel conn %p\"\nargument_list|,\nname|conn\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|NULL\nreturn|;\nblock|}\ncomment|/* Leave the PDU buffer in the queue until we have sent all its \t * fragments. \t * \t * For SDUs we do the same, we keep it in the queue until all the \t * segments have been sent, adding the PDU headers just-in-time. \t */\ncondition|(\noperator|!\nname|pdu\ncondition|)\nblock|{\nreturn|return\nname|NULL\nreturn|;\nblock|}\ncomment|/* __ASSERT(pdu, \"signaled ready but no PDUs in the TX queue\"); */",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|bt_tx_irq_raise\n+argument_list|()\n+expr_stmt|;\n+name|bt_tx_irq_raise\n+argument_list|()\n+expr_stmt|;\nThe issue was with: Bluetooth: l2cap: service as much TX channels as possible\n\nSimilar to ISO connections, ACL connections are not serviced as fast as\npossible. Change this, and try to send as much as we have resources for."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: iso: make TX path service all connections\n\nISO connections that were in the TX queue were not getting serviced in\ntime. This happens because `iso_data_pull()` returns `NULL` when that\nparticular connection (`conn`) is done sending.\n\nBut it doesn't trigger the TX processor again to process other channels in\nthe queue. This patch fixes that by calling `bt_tx_irq_raise()`.\n\nWe can't do this from `conn.c` as we don't know if the `NULL` returned is\nbecause the current channel is out of data or because it has data but it\ncan't send it (e.g. the current buf is being \\\"viewed\\\" already).\n\nFixes https://github.com/zephyrproject-rtos/zephyr/issues/74321 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|LOG_DBG\nargument_list|(\nliteral|\"signaled ready but no frag available\"\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|NULL\nreturn|;\nblock|}\nif|if\nname|b\noperator|==\nname|frag\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|NULL\nreturn|;\nblock|}\nif|if",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Service other connections */\n+name|bt_tx_irq_raise\n+argument_list|()\n+expr_stmt|;\n+comment|/* Service other connections */\n+name|bt_tx_irq_raise\n+argument_list|()\n+expr_stmt|;\nThe issue was with: Bluetooth: iso: make TX path service all connections\n\nISO connections that were in the TX queue were not getting serviced in\ntime. This happens because `iso_data_pull()` returns `NULL` when that\nparticular connection (`conn`) is done sending.\n\nBut it doesn't trigger the TX processor again to process other channels in\nthe queue. This patch fixes that by calling `bt_tx_irq_raise()`.\n\nWe can't do this from `conn.c` as we don't know if the `NULL` returned is\nbecause the current channel is out of data or because it has data but it\ncan't send it (e.g. the current buf is being \\\"viewed\\\" already).\n\nFixes https://github.com/zephyrproject-rtos/zephyr/issues/74321"
},{
  "instruction": "There is an issue in the following code. It relates to drivers/flash: Fix flash_fill write chunk calculation\n\nFix incorrect last chunk calculation. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|filler\nargument_list|)\nargument_list|,\nname|size\nargument_list|)\ndecl_stmt|;\nname|rc\noperator|=\nname|api",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|-\n+name|stored\nThe issue was with: drivers/flash: Fix flash_fill write chunk calculation\n\nFix incorrect last chunk calculation."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Host: Add log entry for connection creation timeout\n\nThis makes it more clear what is happening when the host cancels\nconnection creation where the controller raises\nthe connection complete event with status set to\n\\\"UNKNOWN CONNECTION IDENTIFIER (0x02)\\\".\n\nThis is especially useful for developers not familiar with this\ndetail in the spec.\n\nSee also: Core_v5.4, Vol 4, Part E, Section 7.8.13,\nLE Create Connection Cancel command. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|K_WORK_DELAYED\noperator|)\noperator|)\ncondition|)\nblock|{\ncomment|/* Connection initiation timeout triggered. */\nname|conn\noperator|->\nname|err\noperator|=\nname|err\nname|hci_vs_init\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nDECL|union|__anon2acf1391010a\nunion|union\nblock|{\nDECL|member|info\nname|struct\nname|bt_hci_rp_vs_read_version_info",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* Connection initiation timeout triggered. */\n+name|LOG_WRN\n+argument_list|(\n+literal|\"Connection creation timeout triggered\"\n+argument_list|)\n+expr_stmt|;\n-DECL|union|__anon2acf1391010a\n+DECL|union|__anon2745dde9010a\nThe issue was with: Bluetooth: Host: Add log entry for connection creation timeout\n\nThis makes it more clear what is happening when the host cancels\nconnection creation where the controller raises\nthe connection complete event with status set to\n\\\"UNKNOWN CONNECTION IDENTIFIER (0x02)\\\".\n\nThis is especially useful for developers not familiar with this\ndetail in the spec.\n\nSee also: Core_v5.4, Vol 4, Part E, Section 7.8.13,\nLE Create Connection Cancel command."
},{
  "instruction": "There is an issue in the following code. It relates to fdtable: lseek's returned offset should start from 0\n\nAn offset of `>= 0` is valid from a `lseek` call, fix it. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|res\noperator|>\nliteral|0\ncondition|)\nblock|{\nswitch|switch\ncondition|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|>\n+operator|>=\nThe issue was with: fdtable: lseek's returned offset should start from 0\n\nAn offset of `>= 0` is valid from a `lseek` call, fix it."
},{
  "instruction": "There is an issue in the following code. It relates to posix: shm: offset should compare with the shm size\n\nThe read/write offset should have compared with the size of\nthe shm object, not the size of the buffer. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nif|if\ncondition|(\nname|offset\noperator|>=\nname|size\ncondition|)\nblock|{\nname|size\noperator|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|shm\n+operator|->\nThe issue was with: posix: shm: offset should compare with the shm size\n\nThe read/write offset should have compared with the size of\nthe shm object, not the size of the buffer."
},{
  "instruction": "There is an issue in the following code. It relates to i2c_smartbond: Introcude TX_FIFO_DEPTH macro\n\nIntrocude TX_FIFO_DEPTH macro to avoid \\\"magic\\\"\nnumbers. Please fix this issue.",
  "input": "Faulty tokenized code:\nifdef|#\ndirective|ifdef\nname|CONFIG_I2C_CALLBACK\nend_ifdef\n\nbegin_function\nDECL|function|i2c_smartbond_enable_msg_interrupts (const struct i2c_smartbond_cfg * const config,struct i2c_smartbond_data * data)\nspecifier|static\nname|int\nname|i2c_smartbond_enable_msg_interrupts\nname|receive_cnt\ndecl_stmt|;\nname|uint32_t\nname|tx_space\ninit|=\nliteral|32\noperator|-\nname|config\noperator|->\nname|regs\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_define\n+DECL|macro|TX_FIFO_DEPTH\n+define|#\n+directive|define\n+name|TX_FIFO_DEPTH\n+value|32\n+end_define\n+\n-literal|32\n+name|TX_FIFO_DEPTH\nThe issue was with: i2c_smartbond: Introcude TX_FIFO_DEPTH macro\n\nIntrocude TX_FIFO_DEPTH macro to avoid \\\"magic\\\"\nnumbers."
},{
  "instruction": "There is an issue in the following code. It relates to spi_smartbond: check that DMA controllers were provided\n\nCheck that DMA controllers were provided in\nspi_smartbond_dma_deconfig() Please fix this issue.",
  "input": "Faulty tokenized code:\ninit|=\nname|dev\noperator|->\nname|config\ndecl_stmt|;\nname|dma_stop\nargument_list|(\nname|config\noperator|->\nname|rx_dma_ctrl\nargument_list|(\nname|dev\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_endif\nendif|#\ndirective|endif",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|config\n+operator|->\n+name|rx_dma_ctrl\n+operator|&&\n+name|config\n+operator|->\n+name|tx_dma_ctrl\n+condition|)\n+block|{\n+block|}\nThe issue was with: spi_smartbond: check that DMA controllers were provided\n\nCheck that DMA controllers were provided in\nspi_smartbond_dma_deconfig()"
},{
  "instruction": "There is an issue in the following code. It relates to fs: open: fix zfp flags not set when calling truncate\n\nIf filesystem relies on zfp flags being set after open, this can lead to\ninconsistency with the current implementation of FS_O_TRUNC.\nMove the assignment of zfp->flags before any other call to fs api to avoid\nsuch issues. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nreturn|return\nname|rc\nreturn|;\nblock|}\nif|if\ncondition|(\nname|truncate_file\ncondition|)\nblock|{\nreturn|return\nname|rc\nreturn|;\nblock|}\nblock|}\ncomment|/* Copy flags to zfp for use with other fs_ API calls */\nname|zfp\noperator|->\nname|flags\noperator|=\nname|flags\nexpr_stmt|;\nreturn|return\nname|rc\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Copy flags to zfp for use with other fs_ API calls */\n+name|zfp\n+operator|->\n+name|flags\n+operator|=\n+name|flags\n+expr_stmt|;\n-comment|/* Copy flags to zfp for use with other fs_ API calls */\n-name|zfp\n-operator|->\n-name|flags\n-operator|=\n-name|flags\n-expr_stmt|;\nThe issue was with: fs: open: fix zfp flags not set when calling truncate\n\nIf filesystem relies on zfp flags being set after open, this can lead to\ninconsistency with the current implementation of FS_O_TRUNC.\nMove the assignment of zfp->flags before any other call to fs api to avoid\nsuch issues."
},{
  "instruction": "There is an issue in the following code. It relates to log: remove CONFIG_LOG_DOMAIN_ID\n\n`CONFIG_LOG_DOMAIN_ID` has been deprecated for years and\nshouldn't be used according to its documentation, remove it. Please fix this issue.",
  "input": "Faulty tokenized code:\n# Copyright (c) 2021 Nordic Semiconductor ASA\n# SPDX-License-Identifier: Apache-2.0\n\nmenu \"Misc\"\n\nconfig LOG_DOMAIN_ID\n\tint \"Domain ID [DEPRECATED]\"\n\tdepends on !LOG_MODE_MINIMAL\n\tdefault 0\n\trange 0 7\n\thelp\n\t  Deprecated. It is not used in the code.\n\nconfig LOG_CMDS\n\tbool \"Shell commands\"\n\tdepends on SHELL\n\tdepends on !LOG_FRONTEND_ONLY && !LOG_MODE_MINIMAL\n\noperator|&\nname|backend1\nargument_list|,\nliteral|0\nargument_list|,\nname|CONFIG_LOG_DOMAIN_ID\nargument_list|,\nname|LOG_LEVEL_INTERNAL_RAW_STRING\nargument_list|,\nname|exp_timestamp\noperator|++\noperator|&\nname|backend1\nargument_list|,\nliteral|1\nargument_list|,\nname|CONFIG_LOG_DOMAIN_ID\nargument_list|,\nname|LOG_LEVEL_INTERNAL_RAW_STRING\nargument_list|,\nname|exp_timestamp\noperator|++",
  "result": "I corrected the issue in the code by changing the following tokens:\n-config LOG_DOMAIN_ID\n-\tint \"Domain ID [DEPRECATED]\"\n-\tdepends on !LOG_MODE_MINIMAL\n-\tdefault 0\n-\trange 0 7\n-\thelp\n-\t  Deprecated. It is not used in the code.\n-\n-name|CONFIG_LOG_DOMAIN_ID\n+literal|0\n-name|CONFIG_LOG_DOMAIN_ID\n+literal|0\nThe issue was with: log: remove CONFIG_LOG_DOMAIN_ID\n\n`CONFIG_LOG_DOMAIN_ID` has been deprecated for years and\nshouldn't be used according to its documentation, remove it."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: eth_nxp_enet: fix MMIO mapping issue\n\nFixed #74370, the issue is caused by the update to introduce MMIO\nmapping, after MMIO mapping, should use data->base for device\nbase memory address. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ret\nreturn|;\nblock|}\nname|ENET_Reset\nargument_list|(\nname|config\noperator|->\nname|base\nargument_list|)\nexpr_stmt|;\nname|ENET_Down\nargument_list|(\nname|config\noperator|->\nname|base\nargument_list|)\nexpr_stmt|;\nname|clock_control_off",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|config\n+name|data\n-name|config\n+name|data\nThe issue was with: drivers: eth_nxp_enet: fix MMIO mapping issue\n\nFixed #74370, the issue is caused by the update to introduce MMIO\nmapping, after MMIO mapping, should use data->base for device\nbase memory address."
},{
  "instruction": "There is an issue in the following code. It relates to soc: stm32: config DBGMCU register writing for SWO configuration\n\nSome stm32 series, do not have a LL_DBGMCU_SetTracePinAssignment\nfunction  to enable trace IO port, this is the case with the\nstm32h7 serie. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|!\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_STM32WBX\nargument_list|)\nname|LL_DBGMCU_SetTracePinAssignment\nargument_list|(\nname|LL_DBGMCU_TRACE_ASYNCH\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|&&\n+name|defined\n+argument_list|(\n+name|DBGMCU_CR_TRACE_IOEN\n+argument_list|)\nThe issue was with: soc: stm32: config DBGMCU register writing for SWO configuration\n\nSome stm32 series, do not have a LL_DBGMCU_SetTracePinAssignment\nfunction  to enable trace IO port, this is the case with the\nstm32h7 serie."
},{
  "instruction": "There is an issue in the following code. It relates to net: lib: dhcpv4: Add check for input parameter of echo_reply_handler\n\nFor station and internal AP coexist case, station connected to\nexternal AP, ping from station to external AP cause cpu hang.\n\nInternal AP dhcpv4 server register handler echo_reply_handler\non icmp handler by net_icmp_init_ctx for dhcp server snoop\nfeature. Ping also register handler handle_ipv4_echo_reply on\nicmp handler for ping cmd. If no external station connect to\ninternal AP, input parameter ‘user_data’ of function\necho_reply_handler is NULL. When we trigger ping process,\nicmp_call_handlers fetch all handlers from icmp handler\nif receive any ICMP packet, so echo_reply_handler be called,\nbut input parameter is NULL, cause CPU hang.\nAdd input parameters check to fix this issue. Please fix this issue.",
  "input": "Faulty tokenized code:\ndecl_stmt|;\nname|struct\nname|dhcpv4_server_probe_ctx\nmodifier|*\nname|probe_ctx\ninit|=\noperator|&\nname|ctx\noperator|->\nname|probe_ctx\ndecl_stmt|;\nname|struct\nname|dhcpv4_addr_slot\nmodifier|*\nname|new_slot\nname|K_FOREVER\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|probe_ctx\noperator|->\nname|slot\noperator|==\nname|NULL",
  "result": "I corrected the issue in the code by changing the following tokens:\n-init|=\n-operator|&\n-name|ctx\n-operator|->\n-name|probe_ctx\n+name|ctx\n+operator|==\n+name|NULL\n+condition|)\n+block|{\n+goto|goto\n+name|out\n+goto|;\n+block|}\n+name|probe_ctx\n+operator|=\n+operator|&\n+name|ctx\n+operator|->\n+name|probe_ctx\n+expr_stmt|;\n+if|if\n+condition|(\nThe issue was with: net: lib: dhcpv4: Add check for input parameter of echo_reply_handler\n\nFor station and internal AP coexist case, station connected to\nexternal AP, ping from station to external AP cause cpu hang.\n\nInternal AP dhcpv4 server register handler echo_reply_handler\non icmp handler by net_icmp_init_ctx for dhcp server snoop\nfeature. Ping also register handler handle_ipv4_echo_reply on\nicmp handler for ping cmd. If no external station connect to\ninternal AP, input parameter ‘user_data’ of function\necho_reply_handler is NULL. When we trigger ping process,\nicmp_call_handlers fetch all handlers from icmp handler\nif receive any ICMP packet, so echo_reply_handler be called,\nbut input parameter is NULL, cause CPU hang.\nAdd input parameters check to fix this issue."
},{
  "instruction": "There is an issue in the following code. It relates to random: timer: Comply with MISRA Rule 14.4\n\nUse boolean expression in a controlling expression. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ret\ndecl_stmt|;\nwhile|while\ncondition|(\nname|outlen\ncondition|)\nblock|{\nname|ret\noperator|=\nname|rand32_get",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|>\n+literal|0\nThe issue was with: random: timer: Comply with MISRA Rule 14.4\n\nUse boolean expression in a controlling expression."
},{
  "instruction": "There is an issue in the following code. It relates to arch: xtensa: fatal: Comply with MISRA Rule 14.4\n\nUse boolean expression in a controlling expression. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|ifdef\nname|CONFIG_EXCEPTION_DEBUG\nif|if\ncondition|(\nname|esf\ncondition|)\nblock|{\ncomment|/* Don't want to get elbowed by xtensa_switch \t\t * in between printing registers and dumping them; \t\t * corrupts backtrace \t\t */\nname|unsigned\nname|int",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|!=\n+name|NULL\nThe issue was with: arch: xtensa: fatal: Comply with MISRA Rule 14.4\n\nUse boolean expression in a controlling expression."
},{
  "instruction": "There is an issue in the following code. It relates to soc: intel_adsp/ace: Comply with MISRA Rule 14.4\n\nUse boolean type in a controlling expression. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<stdint.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/spinlock.h>\nend_include\nargument_list|)\nexpr_stmt|;\ncomment|/* Wait for timestamp capture to complete */\nwhile|while\ncondition|(\nliteral|1\ncondition|)\nblock|{\nname|tsctrl_temp\noperator|=\nname|sys_read32",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<stdbool.h>\n+end_include\n+\n-literal|1\n+name|true\nThe issue was with: soc: intel_adsp/ace: Comply with MISRA Rule 14.4\n\nUse boolean type in a controlling expression."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: pinctrl: gecko: Fix Series 1 I2C SCL route location config\n\nImplementation erroneously used a mask from the ROUTEPEN register\nwhen writing the ROUTELOC register. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|i2c_base\noperator|->\nname|ROUTELOC0\noperator|&=\noperator|~\nname|_I2C_ROUTEPEN_SCLPEN_MASK\nexpr_stmt|;\nname|i2c_base\noperator|->\nname|ROUTELOC0\noperator||=",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|_I2C_ROUTEPEN_SCLPEN_MASK\n+name|_I2C_ROUTELOC0_SCLLOC_MASK\nThe issue was with: drivers: pinctrl: gecko: Fix Series 1 I2C SCL route location config\n\nImplementation erroneously used a mask from the ROUTEPEN register\nwhen writing the ROUTELOC register."
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: rtc: skip alarm callback test if not supported\n\nCheck for ENOTSUP on alarm callback test if ALARM functionality is\nenabled but callbacks are not supported Please fix this issue.",
  "input": "Faulty tokenized code:\nname|NULL\nargument_list|,\nname|NULL\nargument_list|)\nexpr_stmt|;\nname|zassert_ok\nargument_list|(\nname|ret\nargument_list|,\nliteral|\"Failed to clear and disable alarm %d\"\nargument_list|,\nname|i\nargument_list|)\nexpr_stmt|;\nblock|}\ncomment|/* Validate alarms supported fields */\nfor|for\ncontrol|(\nname|uint16_t\nname|i",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|ret\n+operator|==\n+operator|-\n+name|ENOTSUP\n+condition|)\n+block|{\n+name|TC_PRINT\n+argument_list|(\n+literal|\"Alarm callbacks not supported\\n\"\n+argument_list|)\n+expr_stmt|;\n+name|ztest_test_skip\n+argument_list|()\n+expr_stmt|;\n+block|}\n+else|else\n+block|{\n+block|}\nThe issue was with: tests: drivers: rtc: skip alarm callback test if not supported\n\nCheck for ENOTSUP on alarm callback test if ALARM functionality is\nenabled but callbacks are not supported"
},{
  "instruction": "There is an issue in the following code. It relates to sched: Limit deadline scheduler parameter\n\nThe deadline of deadline scheduler should lager than zero\nbecause if deadline is negative, it menas the task should\nbe finished in past. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|,\nname|int\nname|deadline\nparameter_list|)\nblock|{\nname|struct\nname|k_thread\nmodifier|*\nname|thread\ninit|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|deadline\n+operator|=\n+name|CLAMP\n+argument_list|(\n+name|deadline\n+argument_list|,\n+literal|0\n+argument_list|,\n+name|INT_MAX\n+argument_list|)\n+expr_stmt|;\nThe issue was with: sched: Limit deadline scheduler parameter\n\nThe deadline of deadline scheduler should lager than zero\nbecause if deadline is negative, it menas the task should\nbe finished in past."
},{
  "instruction": "There is an issue in the following code. It relates to xtensa: mmu: arch_buffer_validate is only for user thread\n\narch_buffer_validate() is only to verify that user threads have\naccess to the memory region. It should not be used to verify\nif kernel thread has access (which they should anyway). So\nchange the logic. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\ndecl_stmt|;\nname|uint8_t\nname|ring\ninit|=\noperator|(\noperator|(\nname|thread\noperator|->\nname|base\noperator|.\nname|user_options\noperator|&\nname|K_USER\noperator|)\noperator|!=\nliteral|0\noperator|)\ncondition|?\nname|XTENSA_MMU_USER_RING\nelse|:\nname|XTENSA_MMU_KERNEL_RING\ndecl_stmt|;\ncomment|/* addr/size arbitrary, fix this up into an aligned region */\nname|k_mem_region_align\nargument_list|(\noperator|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|(\n-operator|(\n-name|thread\n-operator|->\n-name|base\n-operator|.\n-name|user_options\n-operator|&\n-name|K_USER\n-operator|)\n-operator|!=\n-literal|0\n-operator|)\n-condition|?\n-else|:\n-name|XTENSA_MMU_KERNEL_RING\nThe issue was with: xtensa: mmu: arch_buffer_validate is only for user thread\n\narch_buffer_validate() is only to verify that user threads have\naccess to the memory region. It should not be used to verify\nif kernel thread has access (which they should anyway). So\nchange the logic."
},{
  "instruction": "There is an issue in the following code. It relates to xtensa: no need to clear DEPC on C handler exit for MPU\n\nXtensa MPU code does not handle double exception in C. So there\nis no need to clear DEPC on C handler exit. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|nested\noperator|=\nliteral|1\nblock|; \t}\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_XTENSA_MMU\nargument_list|)\noperator|||\nname|defined\nargument_list|(\nname|CONFIG_XTENSA_MPU\nargument_list|)\nifdef|#\ndirective|ifdef\nname|CONFIG_USERSPACE\nname|fixup_out\noperator|:\nbegin_endif\nendif|#\ndirective|endif\nend_endif\n\nbegin_if_stmt\nif|if\ncondition|(\nname|is_dblexc\ncondition|)\nendif|#\ndirective|endif\nend_endif\n\nbegin_comment\ncomment|/* CONFIG_XTENSA_MMU || CONFIG_XTENSA_MPU */\nend_comment\n\nbegin_return\nreturn|return\nname|return_to",
  "result": "I corrected the issue in the code by changing the following tokens:\n-if|#\n-directive|if\n-name|defined\n-argument_list|(\n-name|CONFIG_XTENSA_MMU\n-argument_list|)\n-operator|||\n-name|defined\n-argument_list|(\n-name|CONFIG_XTENSA_MPU\n-argument_list|)\n+begin_if\n+if|#\n+directive|if\n+name|defined\n+argument_list|(\n+name|CONFIG_XTENSA_MMU\n+argument_list|)\n+end_if\n+\n-comment|/* CONFIG_XTENSA_MMU || CONFIG_XTENSA_MPU */\n+comment|/* CONFIG_XTENSA_MMU */\nThe issue was with: xtensa: no need to clear DEPC on C handler exit for MPU\n\nXtensa MPU code does not handle double exception in C. So there\nis no need to clear DEPC on C handler exit."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: timer: Fix timing in suspend-to-ram\n\nFix timing in suspend-to-ram when using STM32WBA.\nSwitch to use RTC timer should be done only when idle is set\nand LPTIM clocks should be switched off Please fix this issue.",
  "input": "Faulty tokenized code:\nname|next\noperator|!=\nname|NULL\noperator|)\noperator|&&\noperator|(\nname|next\noperator|->\nname|state\noperator|==\nname|lptim_cnt_pre_stdby\noperator|=\nname|z_clock_lptim_getcounter\nargument_list|()\nexpr_stmt|;\nreturn|return;\nblock|}\nendif|#\ndirective|endif\ncomment|/* CONFIG_STM32_LPTIM_STDBY_TIMER */",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|idle\n+operator|&&\n+comment|/* Stop clocks for LPTIM, since RTC is used instead */\n+name|clock_control_off\n+argument_list|(\n+name|clk_ctrl\n+argument_list|,\n+operator|(\n+name|clock_control_subsys_t\n+operator|)\n+operator|&\n+name|lptim_clk\n+index|[\n+literal|0\n+index|]\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: timer: Fix timing in suspend-to-ram\n\nFix timing in suspend-to-ram when using STM32WBA.\nSwitch to use RTC timer should be done only when idle is set\nand LPTIM clocks should be switched off"
},{
  "instruction": "There is an issue in the following code. It relates to test: bluetooth/tester: fix ccc_find_by_attr\n\nAdded check if ccc_values[i].attr != NULL,\nbefore accessing to ccc_values[i].attr structure:\n(handle == ccc_values[i].attr->handle)\n\nOn 20829 platform it's causing hard fault, not sure about\nanother platforms (in GAP testing). Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/*  * gatt_buf - cache used by a gatt client (to cache data read/discovered)  * and gatt server (to store attribute user_data).  * It is not intended to be used by client and server at the same time.  */\nend_comment\n\nbegin_struct\nDECL|struct|__anon298021b00108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|len\nname|uint16_t\noperator|++\ncontrol|)\nblock|{\nif|if\ncondition|(\nname|handle\noperator|==\nname|ccc_values\nindex|[\nname|i\nindex|]\noperator|.\nname|attr\noperator|->\nname|handle\ncondition|)\nblock|{\nreturn|return\nname|i\nreturn|;\nblock|}\nstruct|;\nend_struct\n\nbegin_enum\nDECL|enum|__anon298021b00203\nenum|enum\nblock|{\nDECL|enumerator|GATT_VALUE_CCC_FLAG\nname|GATT_VALUE_CCC_FLAG\nblock|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon298021b00108\n+DECL|struct|__anon29f70e9c0108\n+operator|(\n+name|ccc_values\n+index|[\n+name|i\n+index|]\n+operator|.\n+name|attr\n+operator|!=\n+name|NULL\n+operator|)\n+operator|&&\n+operator|(\n+operator|)\n-DECL|enum|__anon298021b00203\n+DECL|enum|__anon29f70e9c0203\nThe issue was with: test: bluetooth/tester: fix ccc_find_by_attr\n\nAdded check if ccc_values[i].attr != NULL,\nbefore accessing to ccc_values[i].attr structure:\n(handle == ccc_values[i].attr->handle)\n\nOn 20829 platform it's causing hard fault, not sure about\nanother platforms (in GAP testing)."
},{
  "instruction": "There is an issue in the following code. It relates to drivers/sensor: si7006: Clean up headers\n\nSome, like stdio.h, don't belong here at all and aren't needed. Please fix this issue.",
  "input": "Faulty tokenized code:\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/drivers/sensor.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/kernel.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/device.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/init.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<string.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include",
  "result": "I corrected the issue in the code by changing the following tokens:\n-file|<zephyr/drivers/sensor.h>\n-end_include\n-\n-begin_include\n-include|#\n-directive|include\n-file|<zephyr/kernel.h>\n+file|<zephyr/device.h>\n-file|<zephyr/device.h>\n+file|<zephyr/drivers/i2c.h>\n-file|<zephyr/init.h>\n+file|<zephyr/drivers/sensor.h>\n-file|<string.h>\n+file|<zephyr/kernel.h>\nThe issue was with: drivers/sensor: si7006: Clean up headers\n\nSome, like stdio.h, don't belong here at all and aren't needed."
},{
  "instruction": "There is an issue in the following code. It relates to drivers/sensor: si7006: Remove unused struct device field\n\nUse was removed but the field itself wasn't deleted. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_struct\nDECL|struct|si7006_data\nstruct|struct\nname|si7006_data\nblock|{\nDECL|member|i2c_dev\nspecifier|const\nname|struct\nname|device\nmodifier|*\nname|i2c_dev\ndecl_stmt|;\nDECL|member|temperature\nname|uint16_t\nname|temperature\ndecl_stmt|;\nDECL|member|humidity",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|member|i2c_dev\n-specifier|const\n-name|struct\n-name|device\n-modifier|*\n-name|i2c_dev\n-decl_stmt|;\nThe issue was with: drivers/sensor: si7006: Remove unused struct device field\n\nUse was removed but the field itself wasn't deleted."
},{
  "instruction": "There is an issue in the following code. It relates to lib: os: reboot: dump coverage info on `sys_reboot`\n\nIf `sys_reboot` is called during testing, the standard dump when `main`\nreturns will never be executed. Failing to dump at this point means any\ncoverage information gathered will be lost upon reboot. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/sys/printk.h>\nend_include\n\nbegin_function_decl\nspecifier|extern\nname|void\nname|sys_arch_reboot\nparameter_list|(\nparameter_list|(\nname|int\nname|type\nparameter_list|)\nblock|{\noperator|(\nname|void\noperator|)\nname|irq_lock\nargument_list|()",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/debug/gcov.h>\n+end_include\n+\n+ifdef|#\n+directive|ifdef\n+name|CONFIG_COVERAGE_DUMP\n+name|gcov_coverage_dump\n+argument_list|()\n+expr_stmt|;\n+endif|#\n+directive|endif\n+comment|/* CONFIG_COVERAGE_DUMP */\nThe issue was with: lib: os: reboot: dump coverage info on `sys_reboot`\n\nIf `sys_reboot` is called during testing, the standard dump when `main`\nreturns will never be executed. Failing to dump at this point means any\ncoverage information gathered will be lost upon reboot."
},{
  "instruction": "There is an issue in the following code. It relates to testsuite: coverage: don't lock scheduler in ISR\n\nDon't attempt to lock the scheduler is trying to dump coverage\ninformation from an ISR. The scheduler won't run while the ISR is in\nprogress. Please fix this issue.",
  "input": "Faulty tokenized code:\nmodifier|*\nname|gcov_list\ninit|=\nname|gcov_info_head\ndecl_stmt|;\nname|k_sched_lock\nargument_list|()\nexpr_stmt|;\nname|printk\nargument_list|(\nliteral|\"\\nGCOV_COVERAGE_DUMP_START\"\nargument_list|)\nexpr_stmt|;\nname|printk\nargument_list|(\nliteral|\"\\nGCOV_COVERAGE_DUMP_END\\n\"\nargument_list|)\nexpr_stmt|;\nname|k_sched_unlock\nargument_list|()\nexpr_stmt|;\nreturn|return;\nblock|}\nend_function\n\nbegin_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+operator|!\n+name|k_is_in_isr\n+argument_list|()\n+condition|)\n+block|{\n+block|}\n+if|if\n+condition|(\n+operator|!\n+name|k_is_in_isr\n+argument_list|()\n+condition|)\n+block|{\n+block|}\nThe issue was with: testsuite: coverage: don't lock scheduler in ISR\n\nDon't attempt to lock the scheduler is trying to dump coverage\ninformation from an ISR. The scheduler won't run while the ISR is in\nprogress."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: counter: add missing include\n\nAdd missing include for get_value_64 in the counter_handlers.c file. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|z_vrfy_counter_get_value_64 (const struct device * dev,uint64_t * ticks)\nspecifier|static\nspecifier|inline\nname|int\nend_function\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/syscalls/counter_get_value_mrsh.c>\nend_include\n\nbegin_function\nDECL|function|z_vrfy_counter_set_channel_alarm (const struct device * dev,uint8_t chan_id,const struct counter_alarm_cfg * alarm_cfg)\nspecifier|static",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/syscalls/counter_get_value_mrsh.c>\n+end_include\n+\n-file|<zephyr/syscalls/counter_get_value_mrsh.c>\n+file|<zephyr/syscalls/counter_get_value_64_mrsh.c>\nThe issue was with: drivers: counter: add missing include\n\nAdd missing include for get_value_64 in the counter_handlers.c file."
},{
  "instruction": "There is an issue in the following code. It relates to xtensa: userspace: fix uninitialized return values in mpu_map_region_add\n\nEnsure that *first_idx is populated for the case of adding entries\nto an empty table Please fix this issue.",
  "input": "Faulty tokenized code:\nname|access_rights\nargument_list|,\nname|memory_type\nargument_list|)\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\ncomment|/* \t\t\t\t * Populate the last two entries to indicate \t\t\t\t * a memory region. Notice that the second entry \t\t\t\t * is not enabled as it is merely marking the end of \t\t\t\t * a region and is not the starting of another \t\t\t\t * enabled MPU region. \t\t\t\t */\nname|entry_slot_s\nname|XTENSA_MPU_ACCESS_P_NA_U_NA\nargument_list|,\nname|CONFIG_XTENSA_MPU_DEFAULT_MEM_TYPE\nargument_list|)\nexpr_stmt|;\nblock|}\nname|ret\noperator|=\nliteral|0\nexpr_stmt|;\nargument_list|,\nname|memory_type\nargument_list|)\nexpr_stmt|;\nblock|}\nif|if\ncondition|(\nname|first_idx\noperator|!=\nname|NULL",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|first_enabled_idx\n+operator|=\n+name|XTENSA_MPU_NUM_ENTRIES\n+operator|-\n+literal|1\n+expr_stmt|;\n+goto|goto\n+name|end\n+goto|;\n+name|first_enabled_idx\n+operator|=\n+name|XTENSA_MPU_NUM_ENTRIES\n+operator|-\n+literal|2\n+expr_stmt|;\n+goto|goto\n+name|end\n+goto|;\n+name|end\n+label|:\nThe issue was with: xtensa: userspace: fix uninitialized return values in mpu_map_region_add\n\nEnsure that *first_idx is populated for the case of adding entries\nto an empty table"
},{
  "instruction": "There is an issue in the following code. It relates to kernel: Unified type of stack protection canary __stack_chk_guard.\n\nExtern declaration of __stack_chk_guard added volatile to\nthe type while the declaration was non-volatile. This cause\ntype check errors with compilers that declares the\n__stack_chk_guard variable in an internal pre-include\nheader file (IAR).\n\nWhile I think the volatile keyword is unnecessary, I decided\non keep it and add it to the declaration in\nkernel/compiler_stack_protect.c\n\nTested with IAR ICCARM and the Zephyr SDK GCC. Please fix this issue.",
  "input": "Faulty tokenized code:\nend_ifdef\n\nbegin_decl_stmt\nDECL|variable|__stack_chk_guard\nname|__thread\nname|uintptr_t\nname|__stack_chk_guard\ndecl_stmt|;\nend_decl_stmt\n\nelif|#\ndirective|elif\nname|CONFIG_USERSPACE\nend_elif\n\nbegin_macro\nname|K_APP_DMEM\nargument_list|(\nargument|z_libc_partition\nargument_list|)\nend_macro\n\nbegin_decl_stmt\nname|uintptr_t\nname|__stack_chk_guard\ndecl_stmt|;\nend_decl_stmt\n\nbegin_else\nelse|#\ndirective|else\nend_else\n\nbegin_decl_stmt\nname|__noinit\nname|uintptr_t\nname|__stack_chk_guard\ndecl_stmt|;\nend_decl_stmt\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n+specifier|volatile\n-begin_macro\n+begin_expr_stmt\n-argument|z_libc_partition\n+name|z_libc_partition\n-end_macro\n-\n-begin_decl_stmt\n+specifier|volatile\n-decl_stmt|;\n-end_decl_stmt\n+expr_stmt|;\n+end_expr_stmt\n+specifier|volatile\nThe issue was with: kernel: Unified type of stack protection canary __stack_chk_guard.\n\nExtern declaration of __stack_chk_guard added volatile to\nthe type while the declaration was non-volatile. This cause\ntype check errors with compilers that declares the\n__stack_chk_guard variable in an internal pre-include\nheader file (IAR).\n\nWhile I think the volatile keyword is unnecessary, I decided\non keep it and add it to the declaration in\nkernel/compiler_stack_protect.c\n\nTested with IAR ICCARM and the Zephyr SDK GCC."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: mdio_nxp_enet: remove unused header file\n\nsoc.h is not used, and some platform has no such header file, so\nremove it. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/sys_clock.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<soc.h>\nend_include\n\nbegin_struct\nDECL|struct|nxp_enet_mdio_config\nstruct|struct\nname|nxp_enet_mdio_config\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_include\n-include|#\n-directive|include\n-file|<soc.h>\n-end_include\n-\nThe issue was with: drivers: mdio_nxp_enet: remove unused header file\n\nsoc.h is not used, and some platform has no such header file, so\nremove it."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: ethernet: eth_enet: remove building error\n\nDon't block building in case of there is no unique ID provided. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_else\nelse|#\ndirective|else\nend_else\n\nbegin_error\nerror|#\ndirective|error\nliteral|\"Unsupported SOC\"\nend_error\n\nbegin_endif\nendif|#\ndirective|endif\nend_endif\nname|uint32_t\nname|id\ninit|=\nname|ETH_NXP_ENET_UNIQUE_ID\ndecl_stmt|;\ncomment|/* Setting LAA bit because it is not guaranteed universally unique */\nname|mac_addr\nindex|[\nliteral|0\nindex|]",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_error\n-error|#\n-directive|error\n-literal|\"Unsupported SOC\"\n-end_error\n+begin_define\n+DECL|macro|ETH_NXP_ENET_UNIQUE_ID\n+define|#\n+directive|define\n+name|ETH_NXP_ENET_UNIQUE_ID\n+value|0xFFFFFF\n+end_define\n+if|if\n+condition|(\n+name|id\n+operator|==\n+literal|0xFFFFFF\n+condition|)\n+name|LOG_ERR\n+argument_list|(\n+literal|\"No unique MAC can be provided in this platform\"\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: ethernet: eth_enet: remove building error\n\nDon't block building in case of there is no unique ID provided."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: eth_nxp_enet: fix cache maintain\n\nNeed to disable cache maintain by driver in case of\nusing noncache DMA buffer. Please fix this issue.",
  "input": "Faulty tokenized code:\nDECL|macro|_nxp_enet_driver_buffer_section\ndefine|#\ndirective|define\nname|_nxp_enet_driver_buffer_section\nvalue|__dtcm_noinit_section\nelif|#\ndirective|elif\nname|defined\nargument_list|(\nname|CONFIG_NOCACHE_MEMORY\nvalue|__nocache\nDECL|macro|_nxp_enet_driver_buffer_section\ndefine|#\ndirective|define\nname|_nxp_enet_driver_buffer_section\nelse|#\ndirective|else\nDECL|macro|_nxp_enet_dma_desc_section\ndefine|#\ndirective|define\nname|_nxp_enet_dma_buffer_section\nDECL|macro|_nxp_enet_driver_buffer_section\ndefine|#\ndirective|define\nname|_nxp_enet_driver_buffer_section\nendif|#\ndirective|endif\ncomment|/* Use ENET_FRAME_MAX_VLANFRAMELEN for VLAN frame size  * Use ENET_FRAME_MAX_FRAMELEN for Ethernet frame size  */\nif|#\ndirective|if\nname|NXP_ENET_MAC_INIT\nparameter_list|(\nname|n\nparameter_list|)\ndefine|\\\nvalue|NXP_ENET_NODE_HAS_MAC_ADDR_CHECK(n)\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tNXP_ENET_NODE_PHY_MODE_CHECK(n)\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tPINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tNXP_ENET_FRAMEINFO_ARRAY(n)\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstatic void nxp_enet_##n##_irq_config_func(void)\t\t\t\\ \t\t{\t\t\t\t\t\t\t\t\t\\ \t\t\tDT_INST_FOREACH_PROP_ELEM(n, interrupt_names,\t\t\t\\ \t\t\t\t\t\tNXP_ENET_CONNECT_IRQ);\t\t\t\\ \t\t}\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tvolatile static __aligned(ENET_BUFF_ALIGNMENT)\t\t\t\t\\ \t\t\t_nxp_enet_dma_desc_section\t\t\t\t\t\\ \t\t\tenet_rx_bd_struct_t\t\t\t\t\t\t\\ \t\t\tnxp_enet_##n##_rx_buffer_desc[CONFIG_ETH_NXP_ENET_RX_BUFFERS];\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tvolatile static __aligned(ENET_BUFF_ALIGNMENT)\t\t\t\t\\ \t\t\t_nxp_enet_dma_desc_section\t\t\t\t\t\\ \t\t\tenet_tx_bd_struct_t\t\t\t\t\t\t\\ \t\t\tnxp_enet_##n##_tx_buffer_desc[CONFIG_ETH_NXP_ENET_TX_BUFFERS];\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstatic uint8_t __aligned(ENET_BUFF_ALIGNMENT)\t\t\t\t\\ \t\t\t_nxp_enet_dma_buffer_section\t\t\t\t\t\\ \t\t\tnxp_enet_##n##_rx_buffer[CONFIG_ETH_NXP_ENET_RX_BUFFERS]\t\\ \t\t\t\t\t\t[ETH_NXP_ENET_BUFFER_SIZE];\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstatic uint8_t __aligned(ENET_BUFF_ALIGNMENT)\t\t\t\t\\ \t\t\t_nxp_enet_dma_buffer_section\t\t\t\t\t\\ \t\t\tnxp_enet_##n##_tx_buffer[CONFIG_ETH_NXP_ENET_TX_BUFFERS]\t\\ \t\t\t\t\t\t[ETH_NXP_ENET_BUFFER_SIZE];\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tconst struct nxp_enet_mac_config nxp_enet_##n##_config = {\t\t\\ \t\t\t.base = (ENET_Type *)DT_REG_ADDR(DT_INST_PARENT(n)),\t\t\\ \t\t\t.irq_config_func = nxp_enet_##n##_irq_config_func,\t\t\\ \t\t\t.clock_dev = DEVICE_DT_GET(DT_CLOCKS_CTLR(DT_INST_PARENT(n))),\t\\ \t\t\t.clock_subsys = (void *)DT_CLOCKS_CELL_BY_IDX(\t\t\t\\ \t\t\t\t\t\tDT_INST_PARENT(n), 0, name),\t\t\\ \t\t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\t\\ \t\t\t.buffer_config = {\t\t\t\t\t\t\\ \t\t\t\t.rxBdNumber = CONFIG_ETH_NXP_ENET_RX_BUFFERS,\t\t\\ \t\t\t\t.txBdNumber = CONFIG_ETH_NXP_ENET_TX_BUFFERS,\t\t\\ \t\t\t\t.rxBuffSizeAlign = ETH_NXP_ENET_BUFFER_SIZE,\t\t\\ \t\t\t\t.txBuffSizeAlign = ETH_NXP_ENET_BUFFER_SIZE,\t\t\\ \t\t\t\t.rxBdStartAddrAlign = nxp_enet_##n##_rx_buffer_desc,\t\\ \t\t\t\t.txBdStartAddrAlign = nxp_enet_##n##_tx_buffer_desc,\t\\ \t\t\t\t.rxBufferAlign = nxp_enet_##n##_rx_buffer[0],\t\t\\ \t\t\t\t.txBufferAlign = nxp_enet_##n##_tx_buffer[0],\t\t\\ \t\t\t\t.rxMaintainEnable = true,\t\t\t\t\\ \t\t\t\t.txMaintainEnable = true,\t\t\t\t\\ \t\t\t\tNXP_ENET_FRAMEINFO(n)\t\t\t\t\t\\ \t\t\t},\t\t\t\t\t\t\t\t\\ \t\t\t.phy_mode = NXP_ENET_PHY_MODE(DT_DRV_INST(n)),\t\t\t\\ \t\t\t.phy_dev = DEVICE_DT_GET(DT_INST_PHANDLE(n, phy_handle)),\t\\ \t\t\t.mdio = DEVICE_DT_GET(DT_INST_PHANDLE(n, nxp_mdio)),\t\t\\ \t\t\tNXP_ENET_PTP_DEV(n)\t\t\t\t\t\t\\ \t\t\t.mac_addr_source = NXP_ENET_MAC_ADDR_SOURCE(n),\t\t\t\\ \t\t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstatic _nxp_enet_driver_buffer_section uint8_t\t\t\t\t\\ \t\t\tnxp_enet_##n##_tx_frame_buf[NET_ETH_MAX_FRAME_SIZE];\t\t\\ \t\tstatic _nxp_enet_driver_buffer_section uint8_t\t\t\t\t\\ \t\t\tnxp_enet_##n##_rx_frame_buf[NET_ETH_MAX_FRAME_SIZE];\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstruct nxp_enet_mac_data nxp_enet_##n##_data = {\t\t\t\\ \t\t\t.tx_frame_buf = nxp_enet_##n##_tx_frame_buf,\t\t\t\\ \t\t\t.rx_frame_buf = nxp_enet_##n##_rx_frame_buf,\t\t\t\\ \t\t\t.dev = DEVICE_DT_INST_GET(n),\t\t\t\t\t\\ \t\t\t.mac_addr = DT_INST_PROP_OR(n, local_mac_address, {0}),\t\t\\ \t\t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tETH_NXP_ENET_PM_DEVICE_INIT(n)\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tETH_NET_DEVICE_DT_INST_DEFINE(n, eth_nxp_enet_init,\t\t\t\\ \t\t\t\t\tETH_NXP_ENET_PM_DEVICE_GET(n),\t\t\t\\&nxp_enet_##n##_data,&nxp_enet_##n##_config,\t\\ \t\t\t\t\tCONFIG_ETH_INIT_PRIORITY,\t\t\t\\&api_funcs, NET_ETH_MTU);\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(\nargument|NXP_ENET_MAC_INIT\nargument_list|)\nDECL|macro|NXP_ENET_INIT (n,compat)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+DECL|macro|driver_cache_maintain\n+define|#\n+directive|define\n+name|driver_cache_maintain\n+value|false\n+DECL|macro|driver_cache_maintain\n+define|#\n+directive|define\n+name|driver_cache_maintain\n+value|false\n+DECL|macro|driver_cache_maintain\n+define|#\n+directive|define\n+name|driver_cache_maintain\n+value|true\n-value|NXP_ENET_NODE_HAS_MAC_ADDR_CHECK(n)\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tNXP_ENET_NODE_PHY_MODE_CHECK(n)\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tPINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tNXP_ENET_FRAMEINFO_ARRAY(n)\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstatic void nxp_enet_##n##_irq_config_func(void)\t\t\t\\ \t\t{\t\t\t\t\t\t\t\t\t\\ \t\t\tDT_INST_FOREACH_PROP_ELEM(n, interrupt_names,\t\t\t\\ \t\t\t\t\t\tNXP_ENET_CONNECT_IRQ);\t\t\t\\ \t\t}\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tvolatile static __aligned(ENET_BUFF_ALIGNMENT)\t\t\t\t\\ \t\t\t_nxp_enet_dma_desc_section\t\t\t\t\t\\ \t\t\tenet_rx_bd_struct_t\t\t\t\t\t\t\\ \t\t\tnxp_enet_##n##_rx_buffer_desc[CONFIG_ETH_NXP_ENET_RX_BUFFERS];\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tvolatile static __aligned(ENET_BUFF_ALIGNMENT)\t\t\t\t\\ \t\t\t_nxp_enet_dma_desc_section\t\t\t\t\t\\ \t\t\tenet_tx_bd_struct_t\t\t\t\t\t\t\\ \t\t\tnxp_enet_##n##_tx_buffer_desc[CONFIG_ETH_NXP_ENET_TX_BUFFERS];\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstatic uint8_t __aligned(ENET_BUFF_ALIGNMENT)\t\t\t\t\\ \t\t\t_nxp_enet_dma_buffer_section\t\t\t\t\t\\ \t\t\tnxp_enet_##n##_rx_buffer[CONFIG_ETH_NXP_ENET_RX_BUFFERS]\t\\ \t\t\t\t\t\t[ETH_NXP_ENET_BUFFER_SIZE];\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstatic uint8_t __aligned(ENET_BUFF_ALIGNMENT)\t\t\t\t\\ \t\t\t_nxp_enet_dma_buffer_section\t\t\t\t\t\\ \t\t\tnxp_enet_##n##_tx_buffer[CONFIG_ETH_NXP_ENET_TX_BUFFERS]\t\\ \t\t\t\t\t\t[ETH_NXP_ENET_BUFFER_SIZE];\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tconst struct nxp_enet_mac_config nxp_enet_##n##_config = {\t\t\\ \t\t\t.base = (ENET_Type *)DT_REG_ADDR(DT_INST_PARENT(n)),\t\t\\ \t\t\t.irq_config_func = nxp_enet_##n##_irq_config_func,\t\t\\ \t\t\t.clock_dev = DEVICE_DT_GET(DT_CLOCKS_CTLR(DT_INST_PARENT(n))),\t\\ \t\t\t.clock_subsys = (void *)DT_CLOCKS_CELL_BY_IDX(\t\t\t\\ \t\t\t\t\t\tDT_INST_PARENT(n), 0, name),\t\t\\ \t\t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\t\\ \t\t\t.buffer_config = {\t\t\t\t\t\t\\ \t\t\t\t.rxBdNumber = CONFIG_ETH_NXP_ENET_RX_BUFFERS,\t\t\\ \t\t\t\t.txBdNumber = CONFIG_ETH_NXP_ENET_TX_BUFFERS,\t\t\\ \t\t\t\t.rxBuffSizeAlign = ETH_NXP_ENET_BUFFER_SIZE,\t\t\\ \t\t\t\t.txBuffSizeAlign = ETH_NXP_ENET_BUFFER_SIZE,\t\t\\ \t\t\t\t.rxBdStartAddrAlign = nxp_enet_##n##_rx_buffer_desc,\t\\ \t\t\t\t.txBdStartAddrAlign = nxp_enet_##n##_tx_buffer_desc,\t\\ \t\t\t\t.rxBufferAlign = nxp_enet_##n##_rx_buffer[0],\t\t\\ \t\t\t\t.txBufferAlign = nxp_enet_##n##_tx_buffer[0],\t\t\\ \t\t\t\t.rxMaintainEnable = true,\t\t\t\t\\ \t\t\t\t.txMaintainEnable = true,\t\t\t\t\\ \t\t\t\tNXP_ENET_FRAMEINFO(n)\t\t\t\t\t\\ \t\t\t},\t\t\t\t\t\t\t\t\\ \t\t\t.phy_mode = NXP_ENET_PHY_MODE(DT_DRV_INST(n)),\t\t\t\\ \t\t\t.phy_dev = DEVICE_DT_GET(DT_INST_PHANDLE(n, phy_handle)),\t\\ \t\t\t.mdio = DEVICE_DT_GET(DT_INST_PHANDLE(n, nxp_mdio)),\t\t\\ \t\t\tNXP_ENET_PTP_DEV(n)\t\t\t\t\t\t\\ \t\t\t.mac_addr_source = NXP_ENET_MAC_ADDR_SOURCE(n),\t\t\t\\ \t\t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstatic _nxp_enet_driver_buffer_section uint8_t\t\t\t\t\\ \t\t\tnxp_enet_##n##_tx_frame_buf[NET_ETH_MAX_FRAME_SIZE];\t\t\\ \t\tstatic _nxp_enet_driver_buffer_section uint8_t\t\t\t\t\\ \t\t\tnxp_enet_##n##_rx_frame_buf[NET_ETH_MAX_FRAME_SIZE];\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstruct nxp_enet_mac_data nxp_enet_##n##_data = {\t\t\t\\ \t\t\t.tx_frame_buf = nxp_enet_##n##_tx_frame_buf,\t\t\t\\ \t\t\t.rx_frame_buf = nxp_enet_##n##_rx_frame_buf,\t\t\t\\ \t\t\t.dev = DEVICE_DT_INST_GET(n),\t\t\t\t\t\\ \t\t\t.mac_addr = DT_INST_PROP_OR(n, local_mac_address, {0}),\t\t\\ \t\t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tETH_NXP_ENET_PM_DEVICE_INIT(n)\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tETH_NET_DEVICE_DT_INST_DEFINE(n, eth_nxp_enet_init,\t\t\t\\ \t\t\t\t\tETH_NXP_ENET_PM_DEVICE_GET(n),\t\t\t\\&nxp_enet_##n##_data,&nxp_enet_##n##_config,\t\\ \t\t\t\t\tCONFIG_ETH_INIT_PRIORITY,\t\t\t\\&api_funcs, NET_ETH_MTU);\n+value|NXP_ENET_NODE_HAS_MAC_ADDR_CHECK(n)\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tNXP_ENET_NODE_PHY_MODE_CHECK(n)\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tPINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tNXP_ENET_FRAMEINFO_ARRAY(n)\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstatic void nxp_enet_##n##_irq_config_func(void)\t\t\t\\ \t\t{\t\t\t\t\t\t\t\t\t\\ \t\t\tDT_INST_FOREACH_PROP_ELEM(n, interrupt_names,\t\t\t\\ \t\t\t\t\t\tNXP_ENET_CONNECT_IRQ);\t\t\t\\ \t\t}\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tvolatile static __aligned(ENET_BUFF_ALIGNMENT)\t\t\t\t\\ \t\t\t_nxp_enet_dma_desc_section\t\t\t\t\t\\ \t\t\tenet_rx_bd_struct_t\t\t\t\t\t\t\\ \t\t\tnxp_enet_##n##_rx_buffer_desc[CONFIG_ETH_NXP_ENET_RX_BUFFERS];\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tvolatile static __aligned(ENET_BUFF_ALIGNMENT)\t\t\t\t\\ \t\t\t_nxp_enet_dma_desc_section\t\t\t\t\t\\ \t\t\tenet_tx_bd_struct_t\t\t\t\t\t\t\\ \t\t\tnxp_enet_##n##_tx_buffer_desc[CONFIG_ETH_NXP_ENET_TX_BUFFERS];\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstatic uint8_t __aligned(ENET_BUFF_ALIGNMENT)\t\t\t\t\\ \t\t\t_nxp_enet_dma_buffer_section\t\t\t\t\t\\ \t\t\tnxp_enet_##n##_rx_buffer[CONFIG_ETH_NXP_ENET_RX_BUFFERS]\t\\ \t\t\t\t\t\t[ETH_NXP_ENET_BUFFER_SIZE];\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstatic uint8_t __aligned(ENET_BUFF_ALIGNMENT)\t\t\t\t\\ \t\t\t_nxp_enet_dma_buffer_section\t\t\t\t\t\\ \t\t\tnxp_enet_##n##_tx_buffer[CONFIG_ETH_NXP_ENET_TX_BUFFERS]\t\\ \t\t\t\t\t\t[ETH_NXP_ENET_BUFFER_SIZE];\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tconst struct nxp_enet_mac_config nxp_enet_##n##_config = {\t\t\\ \t\t\t.base = (ENET_Type *)DT_REG_ADDR(DT_INST_PARENT(n)),\t\t\\ \t\t\t.irq_config_func = nxp_enet_##n##_irq_config_func,\t\t\\ \t\t\t.clock_dev = DEVICE_DT_GET(DT_CLOCKS_CTLR(DT_INST_PARENT(n))),\t\\ \t\t\t.clock_subsys = (void *)DT_CLOCKS_CELL_BY_IDX(\t\t\t\\ \t\t\t\t\t\tDT_INST_PARENT(n), 0, name),\t\t\\ \t\t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\t\\ \t\t\t.buffer_config = {\t\t\t\t\t\t\\ \t\t\t\t.rxBdNumber = CONFIG_ETH_NXP_ENET_RX_BUFFERS,\t\t\\ \t\t\t\t.txBdNumber = CONFIG_ETH_NXP_ENET_TX_BUFFERS,\t\t\\ \t\t\t\t.rxBuffSizeAlign = ETH_NXP_ENET_BUFFER_SIZE,\t\t\\ \t\t\t\t.txBuffSizeAlign = ETH_NXP_ENET_BUFFER_SIZE,\t\t\\ \t\t\t\t.rxBdStartAddrAlign = nxp_enet_##n##_rx_buffer_desc,\t\\ \t\t\t\t.txBdStartAddrAlign = nxp_enet_##n##_tx_buffer_desc,\t\\ \t\t\t\t.rxBufferAlign = nxp_enet_##n##_rx_buffer[0],\t\t\\ \t\t\t\t.txBufferAlign = nxp_enet_##n##_tx_buffer[0],\t\t\\ \t\t\t\t.rxMaintainEnable = driver_cache_maintain,\t\t\\ \t\t\t\t.txMaintainEnable = driver_cache_maintain,\t\t\\ \t\t\t\tNXP_ENET_FRAMEINFO(n)\t\t\t\t\t\\ \t\t\t},\t\t\t\t\t\t\t\t\\ \t\t\t.phy_mode = NXP_ENET_PHY_MODE(DT_DRV_INST(n)),\t\t\t\\ \t\t\t.phy_dev = DEVICE_DT_GET(DT_INST_PHANDLE(n, phy_handle)),\t\\ \t\t\t.mdio = DEVICE_DT_GET(DT_INST_PHANDLE(n, nxp_mdio)),\t\t\\ \t\t\tNXP_ENET_PTP_DEV(n)\t\t\t\t\t\t\\ \t\t\t.mac_addr_source = NXP_ENET_MAC_ADDR_SOURCE(n),\t\t\t\\ \t\t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstatic _nxp_enet_driver_buffer_section uint8_t\t\t\t\t\\ \t\t\tnxp_enet_##n##_tx_frame_buf[NET_ETH_MAX_FRAME_SIZE];\t\t\\ \t\tstatic _nxp_enet_driver_buffer_section uint8_t\t\t\t\t\\ \t\t\tnxp_enet_##n##_rx_frame_buf[NET_ETH_MAX_FRAME_SIZE];\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tstruct nxp_enet_mac_data nxp_enet_##n##_data = {\t\t\t\\ \t\t\t.tx_frame_buf = nxp_enet_##n##_tx_frame_buf,\t\t\t\\ \t\t\t.rx_frame_buf = nxp_enet_##n##_rx_frame_buf,\t\t\t\\ \t\t\t.dev = DEVICE_DT_INST_GET(n),\t\t\t\t\t\\ \t\t\t.mac_addr = DT_INST_PROP_OR(n, local_mac_address, {0}),\t\t\\ \t\t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tETH_NXP_ENET_PM_DEVICE_INIT(n)\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\tETH_NET_DEVICE_DT_INST_DEFINE(n, eth_nxp_enet_init,\t\t\t\\ \t\t\t\t\tETH_NXP_ENET_PM_DEVICE_GET(n),\t\t\t\\&nxp_enet_##n##_data,&nxp_enet_##n##_config,\t\\ \t\t\t\t\tCONFIG_ETH_INIT_PRIORITY,\t\t\t\\&api_funcs, NET_ETH_MTU);\nThe issue was with: drivers: eth_nxp_enet: fix cache maintain\n\nNeed to disable cache maintain by driver in case of\nusing noncache DMA buffer."
},{
  "instruction": "There is an issue in the following code. It relates to samples: video: capture: Enhance logs readability\n\nThere are some compatibilty situations where carriage return does not\nwork (e.g. on Serial Monitor in VSCode). Moreover, keeping the\ntimestamps logs on the console would help to have an idea about the\nframe rate. So, it's better to use line feed instead of carriage return\nin this case. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|0\nreturn|;\nblock|}\nname|printk\nargument_list|(\nliteral|\"\\rGot frame %u! size: %u; timestamp %u ms\"\nargument_list|,\nname|frame\noperator|++\nargument_list|,\nname|vbuf",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"\\rGot frame %u! size: %u; timestamp %u ms\"\n+literal|\"Got frame %u! size: %u; timestamp %u ms\\n\"\nThe issue was with: samples: video: capture: Enhance logs readability\n\nThere are some compatibilty situations where carriage return does not\nwork (e.g. on Serial Monitor in VSCode). Moreover, keeping the\ntimestamps logs on the console would help to have an idea about the\nframe rate. So, it's better to use line feed instead of carriage return\nin this case."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: avoided increments/decrements with side effects\n\n- moved ++/-- before or after the value use Please fix this issue.",
  "input": "Faulty tokenized code:\nname|order_key\noperator|=\nname|pq\noperator|->\nname|next_order_key\noperator|++\nexpr_stmt|;\ncomment|/* Renumber at wraparound.  This is tiny code, and in practice \t * will almost never be hit on real systems.  BUT on very \t * long-running systems where a priq never completely empties \t * AND that contains very large numbers of threads, it can be \t * a latency glitch to loop over all the threads like this. \t */\nif|if\ncondition|(\noperator|!\nname|order_key\noperator|=\nname|pq\noperator|->\nname|next_order_key\noperator|++\nexpr_stmt|;\nblock|}\nblock|}\nname|rb_insert\nargument_list|(\nblock|{\nname|heap_ref\noperator|=\nname|ptr\nexpr_stmt|;\nname|ptr\noperator|=\noperator|--\nname|heap_ref\nexpr_stmt|;\nname|SYS_PORT_TRACING_OBJ_FUNC_ENTER\nargument_list|(\nname|k_heap_sys",
  "result": "I corrected the issue in the code by changing the following tokens:\n+expr_stmt|;\n+name|pq\n+operator|->\n+name|next_order_key\n+expr_stmt|;\n+name|pq\n+operator|->\n+name|next_order_key\n+operator|--\n+name|heap_ref\n+expr_stmt|;\n-operator|--\nThe issue was with: kernel: avoided increments/decrements with side effects\n\n- moved ++/-- before or after the value use"
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: dac: use zassert_ok\n\nReplace `zassert_equal` with `zassert_ok` where return value contains 0\nor errno. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\noperator|&\nname|dac_ch_cfg\nargument_list|)\nexpr_stmt|;\nname|zassert_equal\nargument_list|(\nname|ret\nargument_list|,\nliteral|0\nargument_list|,\nliteral|\"Setting up of the first channel failed with code %d\"\nargument_list|,\nname|ret\nargument_list|)\nexpr_stmt|;\noperator|)\noperator|/\nliteral|2\nargument_list|)\nexpr_stmt|;\nname|zassert_equal\nargument_list|(\nname|ret\nargument_list|,\nliteral|0\nargument_list|,\nliteral|\"dac_write_value() failed with code %d\"\nargument_list|,\nname|ret\nargument_list|)\nexpr_stmt|;\nargument_list|,\noperator|&\nname|dac_ch_cfg\nargument_list|)\nexpr_stmt|;\nname|zassert_equal\nargument_list|(\nname|ret\nargument_list|,\nliteral|0\nargument_list|,\nliteral|\"Setting up of the first channel failed with code %d\"\nargument_list|,\nname|ret\nargument_list|)\nexpr_stmt|;\nargument_list|,\noperator|&\nname|adc_ch_cfg\nargument_list|)\nexpr_stmt|;\nname|zassert_equal\nargument_list|(\nname|ret\nargument_list|,\nliteral|0\nargument_list|,\nliteral|\"Setting up of the ADC channel failed with code %d\"\nargument_list|,\nname|ret\nargument_list|)\nexpr_stmt|;\noperator|)\noperator|/\nliteral|2\nargument_list|)\nexpr_stmt|;\nname|zassert_equal\nargument_list|(\nname|ret\nargument_list|,\nliteral|0\nargument_list|,\nliteral|\"dac_write_value() failed with code %d\"\nargument_list|,\nname|ret\nargument_list|)\nexpr_stmt|;\nargument_list|,\noperator|&\nname|sequence\nargument_list|)\nexpr_stmt|;\nname|zassert_equal\nargument_list|(\nname|ret\nargument_list|,\nliteral|0\nargument_list|,\nliteral|\"adc_read() failed with code %d\"\nargument_list|,\nname|ret\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|zassert_equal\n+name|zassert_ok\n-literal|0\n-argument_list|,\n-name|zassert_equal\n+name|zassert_ok\n-literal|0\n-argument_list|,\n-name|zassert_equal\n+name|zassert_ok\n-literal|0\n-argument_list|,\n-name|zassert_equal\n+name|zassert_ok\n-literal|0\n-argument_list|,\n-name|zassert_equal\n+name|zassert_ok\n-literal|0\n-argument_list|,\n-name|zassert_equal\n+name|zassert_ok\n-literal|0\n-argument_list|,\nThe issue was with: tests: drivers: dac: use zassert_ok\n\nReplace `zassert_equal` with `zassert_ok` where return value contains 0\nor errno."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: esp32: Fix next buffer release on rx disable\n\nSet event data rx buffer as next buffer instead of current buffer. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|=\nname|data\noperator|->\nname|async\noperator|.\nname|rx_buf\nexpr_stmt|;\nif|if\ncondition|(\nname|data\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|rx_buf\n+name|rx_next_buf\nThe issue was with: drivers: serial: esp32: Fix next buffer release on rx disable\n\nSet event data rx buffer as next buffer instead of current buffer."
},{
  "instruction": "There is an issue in the following code. It relates to soc: samd51: Fix xosc32 initialization\n\nAt osc32k_init in the soc_samd5x.c file the start-up value of 7 which\nis reserved. This fixes the startup timeout and control gain with the\ncorrect values. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator||\nname|OSC32KCTRL_XOSC32K_RUNSTDBY\noperator||\nname|OSC32KCTRL_XOSC32K_STARTUP\nargument_list|(\nliteral|7\nargument_list|)\nexpr_stmt|;\nwhile|while\ncondition|(\noperator|!\nname|OSC32KCTRL",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|7\n+literal|6\n+operator||\n+name|OSC32KCTRL_XOSC32K_CGM_XT\nThe issue was with: soc: samd51: Fix xosc32 initialization\n\nAt osc32k_init in the soc_samd5x.c file the start-up value of 7 which\nis reserved. This fixes the startup timeout and control gain with the\ncorrect values."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: ethernet: phy_realtek_rtl8211f: fix monitor work schedule\n\nMonitor work should be scheduled for non-interrupt mode. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|interrupt_gpio\noperator|.\nname|port\ncondition|)\nblock|{\ngoto|goto\nname|skip_int_gpio\ngoto|;\nblock|}\ncomment|/* Set INTB/PMEB pin to interrupt mode */\nname|ret\nreturn|;\nblock|}\nname|skip_int_gpio\nlabel|:\nendif|#\ndirective|endif\ncomment|/* DT_ANY_INST_HAS_PROP_STATUS_OKAY(int_gpios) */\nreturn|return\nliteral|0",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|phy_rt_rtl8211f_monitor_work_handler\n+argument_list|(\n+operator|&\n+name|data\n+operator|->\n+name|phy_monitor_work\n+operator|.\n+name|work\n+argument_list|)\n+expr_stmt|;\n+else|#\n+directive|else\n+name|phy_rt_rtl8211f_monitor_work_handler\n+argument_list|(\n+operator|&\n+name|data\n+operator|->\n+name|phy_monitor_work\n+operator|.\n+name|work\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: ethernet: phy_realtek_rtl8211f: fix monitor work schedule\n\nMonitor work should be scheduled for non-interrupt mode."
},{
  "instruction": "There is an issue in the following code. It relates to samples: sensor: accel_polling: Allow coverage calculation\n\nSample must end to dump coverage data. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|return\nliteral|0\nreturn|;\nblock|}\nblock|}\nwhile|while\ncondition|(\nliteral|1\ncondition|)\nblock|{\nfor|for\ncontrol|(\nname|size_t\nname|i\ninit|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n+ifndef|#\n+directive|ifndef\n+name|CONFIG_COVERAGE\n+else|#\n+directive|else\n+for|for\n+control|(\n+name|int\n+name|i\n+init|=\n+literal|0\n+init|;\n+name|i\n+operator|<\n+literal|5\n+condition|;\n+name|i\n+operator|++\n+control|)\n+block|{\n+endif|#\n+directive|endif\nThe issue was with: samples: sensor: accel_polling: Allow coverage calculation\n\nSample must end to dump coverage data."
},{
  "instruction": "There is an issue in the following code. It relates to samples: sensor: bme680: Allow coverage calculation\n\nSample must end to dump coverage data. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|dev\noperator|->\nname|name\nargument_list|)\nexpr_stmt|;\nwhile|while\ncondition|(\nliteral|1\ncondition|)\nblock|{\nname|k_sleep\nargument_list|(\nname|K_MSEC\nargument_list|(\nliteral|3000",
  "result": "I corrected the issue in the code by changing the following tokens:\n+ifndef|#\n+directive|ifndef\n+name|CONFIG_COVERAGE\n+else|#\n+directive|else\n+for|for\n+control|(\n+name|int\n+name|i\n+init|=\n+literal|0\n+init|;\n+name|i\n+operator|<\n+literal|5\n+condition|;\n+name|i\n+operator|++\n+control|)\n+block|{\n+endif|#\n+directive|endif\nThe issue was with: samples: sensor: bme680: Allow coverage calculation\n\nSample must end to dump coverage data."
},{
  "instruction": "There is an issue in the following code. It relates to net: lwm2m: Retry DTLS handshake before dropping to bootstrap\n\nAllow DTLS handshake to be retried before the engine\ndrops into bootstrap. Otherwise any termporary failure,\nfor example DNS failure might drop us into bootstrap\nwithout retrying.\n\nNow all the retry logic should be in sm_do_network_error().\nsm_do_registration() should only fall back to bootstrap\nif there is configuration error. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|ret\nargument_list|)\nexpr_stmt|;\ngoto|goto\nname|bootstrap_or_retry\ngoto|;\nblock|}\nblock|}\nname|sm_send_registration_msg\nargument_list|()\nexpr_stmt|;\nreturn|return;\nname|bootstrap_or_retry\nlabel|:\nname|lwm2m_engine_stop\nargument_list|(\nname|client\noperator|.\nname|ctx\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\noperator|!\nname|client\noperator|.\noperator|&&\nname|fallback_to_bootstrap\nargument_list|()\ncondition|)\nblock|{\nreturn|return;\nblock|}\nname|set_sm_state\nargument_list|(\nname|ENGINE_NETWORK_ERROR\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|bootstrap_or_retry\n+name|retry\n-name|lwm2m_engine_stop\n-argument_list|(\n-name|client\n-operator|.\n-name|ctx\n-argument_list|)\n-expr_stmt|;\n+name|lwm2m_engine_stop\n+argument_list|(\n+name|client\n+operator|.\n+name|ctx\n+argument_list|)\n+expr_stmt|;\n+name|retry\n+label|:\n+name|lwm2m_engine_stop\n+argument_list|(\n+name|client\n+operator|.\n+name|ctx\n+argument_list|)\n+expr_stmt|;\nThe issue was with: net: lwm2m: Retry DTLS handshake before dropping to bootstrap\n\nAllow DTLS handshake to be retried before the engine\ndrops into bootstrap. Otherwise any termporary failure,\nfor example DNS failure might drop us into bootstrap\nwithout retrying.\n\nNow all the retry logic should be in sm_do_network_error().\nsm_do_registration() should only fall back to bootstrap\nif there is configuration error."
},{
  "instruction": "There is an issue in the following code. It relates to arch: riscv: stacktrace: conditionally check stack_info\n\nCheck if an address is in the thread stack only when\n`CONFIG_THREAD_STACK_INFO` is enabled, since otherwise the\n`stack_info` will not be available.\n\nThis fixes compilation error when `CONFIG_THREAD_STACK_INFO`\nis explicitly disabled. Please fix this issue.",
  "input": "Faulty tokenized code:\nmodifier|*\nspecifier|const\nname|thread\nparameter_list|)\nblock|{\nname|uintptr_t\nname|start\ndecl_stmt|,\nname|end\ndecl_stmt|;\nname|addr\noperator|<\nname|end\noperator|)\nreturn|;\nblock|}\nend_function\n\nbegin_ifdef\nifdef|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n+ifdef|#\n+directive|ifdef\n+name|CONFIG_THREAD_STACK_INFO\n+else|#\n+directive|else\n+name|ARG_UNUSED\n+argument_list|(\n+name|addr\n+argument_list|)\n+expr_stmt|;\n+name|ARG_UNUSED\n+argument_list|(\n+name|thread\n+argument_list|)\n+expr_stmt|;\n+comment|/* Return false as we can't check if the addr is in the thread stack without stack info */\n+return|return\n+name|false\n+return|;\n+endif|#\n+directive|endif\nThe issue was with: arch: riscv: stacktrace: conditionally check stack_info\n\nCheck if an address is in the thread stack only when\n`CONFIG_THREAD_STACK_INFO` is enabled, since otherwise the\n`stack_info` will not be available.\n\nThis fixes compilation error when `CONFIG_THREAD_STACK_INFO`\nis explicitly disabled."
},{
  "instruction": "There is an issue in the following code. It relates to dap: do not return error in DAP connect command\n\nIf a host client crashes or fails to disconnect, the probe will\nhang. Allow a new connection without raising errors. Please fix this issue.",
  "input": "Faulty tokenized code:\ndecl_stmt|;\nDECL|member|pkt_size\nname|uint16_t\nname|pkt_size\ndecl_stmt|;\nDECL|struct|__anon2c1903b30108\nstruct|struct\nblock|{\ncomment|/* Idle cycles after transfer */\nDECL|member|idle_cycles\nname|uint8_t\nname|LOG_ERR\nargument_list|(\nliteral|\"DAP device is already connected\"\nargument_list|)\nexpr_stmt|;\nname|port\noperator|=\nname|DAP_ERROR\nexpr_stmt|;\nbreak|break;\nblock|}\nname|api\noperator|->\nname|swdp_port_on",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2c1903b30108\n+DECL|struct|__anon27a2d8540108\n-name|port\n-operator|=\n-name|DAP_ERROR\n-expr_stmt|;\nThe issue was with: dap: do not return error in DAP connect command\n\nIf a host client crashes or fails to disconnect, the probe will\nhang. Allow a new connection without raising errors."
},{
  "instruction": "There is an issue in the following code. It relates to dap: add Konfig option to set maximum packet size\n\nThis also fixes a bug where the packet size returned was only 17 byte. Please fix this issue.",
  "input": "Faulty tokenized code:\n\tdefault 4\n\trange 1 255\n\thelp\n\t  Maximum packet buffers for request and response data.\n\nmodule = DAP\nmodule-str = dap\nsource \"subsys/logging/Kconfig.template.log_config\"\n\nendif # DAP\nDECL|member|capabilities\nname|uint8_t\nname|capabilities\ndecl_stmt|;\nDECL|member|pkt_size\nname|uint8_t\nname|pkt_size\ndecl_stmt|;\nDECL|struct|__anon27e652640108\nstruct|struct\nblock|{\ncomment|/* Idle cycles after transfer */\nDECL|member|idle_cycles\nname|uint8_t\nexpr_stmt|;\nname|sys_put_le16\nargument_list|(\nname|ctx\noperator|->\nname|capabilities\nargument_list|,\noperator|&\nname|info\nindex|[\nliteral|0\nliteral|0\nindex|]\noperator|.\nname|pkt_size\noperator|=\nliteral|64U\nexpr_stmt|;\nname|dap_ctx\nindex|[\nliteral|0\nindex|]",
  "result": "I corrected the issue in the code by changing the following tokens:\n+config CMSIS_DAP_PACKET_SIZE\n+\tint \"Maximum packet size for request and response data.\"\n+\tdefault 64\n+\trange 64 512\n+\thelp\n+\t  Maximum packet size for request and response data.\n+\n-name|uint8_t\n+name|uint16_t\n-DECL|struct|__anon27e652640108\n+DECL|struct|__anon2c1903b30108\n-name|capabilities\n+name|pkt_size\n-literal|64U\n+name|CONFIG_CMSIS_DAP_PACKET_SIZE\nThe issue was with: dap: add Konfig option to set maximum packet size\n\nThis also fixes a bug where the packet size returned was only 17 byte."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: watchdog: stm32 wdg driver support stm32H7RS serie\n\nAdd the stm32h7rs serie to the stm32 WDG driver Please fix this issue.",
  "input": "Faulty tokenized code:\nname|LL_DBGMCU_APB4_GRP1_FreezePeriph\nargument_list|(\nname|LL_DBGMCU_APB4_GRP1_IWDG1_STOP\nargument_list|)\nexpr_stmt|;\nelse|#\ndirective|else\nname|LL_DBGMCU_APB1_GRP1_FreezePeriph\nargument_list|(\nname|LL_DBGMCU_APB1_GRP1_IWDG_STOP",
  "result": "I corrected the issue in the code by changing the following tokens:\n+elif|#\n+directive|elif\n+name|defined\n+argument_list|(\n+name|CONFIG_SOC_SERIES_STM32H7RSX\n+argument_list|)\n+name|LL_DBGMCU_APB4_GRP1_FreezePeriph\n+argument_list|(\n+name|LL_DBGMCU_APB4_GRP1_IWDG_STOP\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: watchdog: stm32 wdg driver support stm32H7RS serie\n\nAdd the stm32h7rs serie to the stm32 WDG driver"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: hwinfo: stm32 driver supports the stm32h7rs serie\n\nAdd the support of the stm32h7rs serie to the HWinfo\ndriver. UID base is 0x8FFF800 Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|elif\nname|defined\nargument_list|(\nname|PWR_FLAG_SB\nargument_list|)\nif|if\ncondition|(\nname|LL_PWR_IsActiveFlag_SB\nargument_list|()\ncondition|)\nexpr_stmt|;\nelif|#\ndirective|elif\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_STM32MP1X\nargument_list|)\nname|LL_PWR_ClearFlag_MCU\nargument_list|()\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|||\n+name|defined\n+argument_list|(\n+name|PWR_FLAG_SBF\n+argument_list|)\n+name|CONFIG_SOC_SERIES_STM32H7RSX\n+argument_list|)\n+name|LL_PWR_ClearFlag_STOP_SB\n+argument_list|()\n+expr_stmt|;\n+elif|#\n+directive|elif\n+name|defined\n+argument_list|(\nThe issue was with: drivers: hwinfo: stm32 driver supports the stm32h7rs serie\n\nAdd the support of the stm32h7rs serie to the HWinfo\ndriver. UID base is 0x8FFF800"
},{
  "instruction": "There is an issue in the following code. It relates to kernel: banner: Add option to clear screen on boot\n\nOn each reboot, this option causes the serial output to start top-left\non the users terminal, simplifying (human) parsing. Please fix this issue.",
  "input": "Faulty tokenized code:\n\t  detect the new USB serial bus, enumerate it and get ready to\n\t  receive before it actually gets data. A similar effect can be\n\t  achieved by waiting for DCD on the serial port--however, not\n\t  all serial ports have DCD.\n\nconfig THREAD_MONITOR\n\tbool \"Thread monitoring\"\n\thelp\n\t  This option instructs the kernel to maintain a list of all threads\n\t  (excluding those that have not yet started or have already\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\ncomment|/* defined(CONFIG_BOOT_DELAY)&& (CONFIG_BOOT_DELAY> 0) */\nifdef|#\ndirective|ifdef\nname|CONFIG_BOOT_BANNER\nname|printk\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+config BOOT_CLEAR_SCREEN\n+\tbool \"Clear screen\"\n+\thelp\n+\t  Use this option to clear the screen before printing anything else.\n+\t  Using a VT100 enabled terminal on the client side is required for this to work.\n+\n+if|#\n+directive|if\n+name|defined\n+argument_list|(\n+name|CONFIG_BOOT_CLEAR_SCREEN\n+argument_list|)\n+comment|/* \\x1b[ = escape sequence \t  * 3J = erase scrollback \t  * 2J = erase screen \t  * H = move cursor to top left \t  */\n+name|printk\n+argument_list|(\n+literal|\"\\x1b[3J\\x1b[2J\\x1b[H\"\n+argument_list|)\n+expr_stmt|;\n+endif|#\n+directive|endif\n+comment|/* CONFIG_BOOT_CLEAR_SCREEN */\nThe issue was with: kernel: banner: Add option to clear screen on boot\n\nOn each reboot, this option causes the serial output to start top-left\non the users terminal, simplifying (human) parsing."
},{
  "instruction": "There is an issue in the following code. It relates to tests: timer_api: Use 64-bit integers in busy slew threshold calculation\n\n32-bit multiplication overflows for the 130000 ppm value used currently\non Nordic SoCs and the duration that is configured to 100000 us. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|BUSY_SLEW_THRESHOLD_TICKS\nparameter_list|(\nname|_us\nparameter_list|)\ndefine|\\\nvalue|k_us_to_ticks_ceil32((_us) * BUSY_TICK_SLEW_PPM\t\t\\ \t\t\t     / PPM_DIVISOR)\nend_define\n\nbegin_function_decl\nspecifier|static\nname|void",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|k_us_to_ticks_ceil32((_us) * BUSY_TICK_SLEW_PPM\t\t\\ \t\t\t     / PPM_DIVISOR)\n+value|k_us_to_ticks_ceil32((_us) * (uint64_t)BUSY_TICK_SLEW_PPM\t\\ \t\t\t     / PPM_DIVISOR)\nThe issue was with: tests: timer_api: Use 64-bit integers in busy slew threshold calculation\n\n32-bit multiplication overflows for the 130000 ppm value used currently\non Nordic SoCs and the duration that is configured to 100000 us."
},{
  "instruction": "There is an issue in the following code. It relates to tests: timer_api: Use busy slew threshold when checking remaining ticks\n\nOn Nordic SoCs, the clock that drives the system timer and the one that\nis used in busy-waiting may be significantly skewed, so the test cases\nthat compare durations derived from those two clocks need to take into\naccount a proper threshold. After the `z_timeout_expires` function was\ncorrected in c707e0d901a2e1b79794e1223347b33231751277 [formerly 3d29c9fe546cd42554becee9dddcbe2e9e73d5cc], it turned out\nthat the threshold was missing in one check and the related test case\nstarted to fail on nRF platforms. This patch adds that threshold there. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|delta_ticks\nargument_list|,\nname|slew_ticks\nargument_list|)\nexpr_stmt|;\ncomment|/* Note +1 tick precision: even though we're calculating in \t * ticks, we're waiting in k_busy_wait(), not for a timer \t * interrupt, so it's possible for that to take 1 tick longer \t * than expected on systems where the requested microsecond \t * delay cannot be exactly represented as an integer number of \t * ticks. \t */\nname|zassert_true\nargument_list|(\noperator|(\noperator|(\nname|int64_t\noperator|/\nliteral|2\noperator|)\noperator|+\nliteral|1\nargument_list|,\nname|NULL\nargument_list|)\nexpr_stmt|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* Note +1 tick precision: even though we're calculating in \t * ticks, we're waiting in k_busy_wait(), not for a timer \t * interrupt, so it's possible for that to take 1 tick longer \t * than expected on systems where the requested microsecond \t * delay cannot be exactly represented as an integer number of \t * ticks. \t */\n+comment|/* Note +1 tick precision: even though we're calculating in \t * ticks, we're waiting in k_busy_wait(), not for a timer \t * interrupt, so it's possible for that to take 1 tick longer \t * than expected on systems where the requested microsecond \t * delay cannot be exactly represented as an integer number of \t * ticks. \t * As above, use higher tolerance on platforms where the clock used \t * by the kernel timer and the one used for busy-waiting may be skewed. \t */\n+operator|+\n+name|slew_ticks\nThe issue was with: tests: timer_api: Use busy slew threshold when checking remaining ticks\n\nOn Nordic SoCs, the clock that drives the system timer and the one that\nis used in busy-waiting may be significantly skewed, so the test cases\nthat compare durations derived from those two clocks need to take into\naccount a proper threshold. After the `z_timeout_expires` function was\ncorrected in c707e0d901a2e1b79794e1223347b33231751277 [formerly 3d29c9fe546cd42554becee9dddcbe2e9e73d5cc], it turned out\nthat the threshold was missing in one check and the related test case\nstarted to fail on nRF platforms. This patch adds that threshold there."
},{
  "instruction": "There is an issue in the following code. It relates to lib: added missing parenthesis\n\n- added missing parenthesis around macro argument expansion Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|DESC\nparameter_list|(\nname|d\nparameter_list|)\nvalue|((void *)d)\nend_define\n\nbegin_function\nDECL|function|fprintf (FILE * ZRESTRICT stream,const char * ZRESTRICT format,...)\nname|int\nDECL|member|specifier\nname|unsigned\nname|char\nname|specifier\ndecl_stmt|;\nDECL|union|__anon2b4beac6010a\nunion|union\nblock|{\ncomment|/** Width value from specification. \t\t * \t\t * Valid until conversion begins. \t\t */\nDECL|member|width_value\nname|int\nname|int\nname|pad0_value\ndecl_stmt|;\nblock|}\nunion|;\nDECL|union|__anon2b4beac6020a\nunion|union\nblock|{\ncomment|/** Precision from specification. \t\t * \t\t * Valid until conversion begins. \t\t */\nDECL|member|prec_value\nname|int\nmodifier|*\nmodifier|*\nname|bpe\nparameter_list|)\nblock|{\nDECL|union|__anon2b4beac6030a\nunion|union\nblock|{\nDECL|member|u64\nname|uint64_t\nname|u64\nparameter_list|(\nname|_sp\nparameter_list|,\nname|_ep\nparameter_list|)\nvalue|do { \\ \tint rc = outs(out, ctx, _sp, _ep); \\ \t\\ \tif (rc< 0) {\t    \\ \t\treturn rc; \\ \t} \\ \tcount += rc; \\ } while (false)\nwhile|while\ncondition|(\noperator|*\nname|fp\noperator|!=\nargument_list|)\nexpr_stmt|;\ncontinue|continue;\nblock|}\ncomment|/* Force union into RAM with conversion state to \t\t * mitigate LLVM code generation bug. \t\t */\nDECL|struct|__anon2b4beac60408\nstruct|struct\nblock|{\nDECL|member|value\nname|union\nname|argument_value\ndirective|define\nname|bundle_bitness\nparameter_list|(\nname|ba\nparameter_list|)\nvalue|(sizeof(ba->bundles[0]) * 8)\nend_define\n\nbegin_struct\nDECL|struct|bundle_data\nstruct|struct",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|((void *)d)\n+value|((void *)(d))\n-DECL|union|__anon2b4beac6010a\n+DECL|union|__anon2a351634010a\n-DECL|union|__anon2b4beac6020a\n+DECL|union|__anon2a351634020a\n-DECL|union|__anon2b4beac6030a\n+DECL|union|__anon2a351634030a\n-value|do { \\ \tint rc = outs(out, ctx, _sp, _ep); \\ \t\\ \tif (rc< 0) {\t    \\ \t\treturn rc; \\ \t} \\ \tcount += rc; \\ } while (false)\n+value|do { \\ \tint rc = outs(out, ctx, (_sp), (_ep)); \\ \t\\ \tif (rc< 0) {\t    \\ \t\treturn rc; \\ \t} \\ \tcount += rc; \\ } while (false)\n-DECL|struct|__anon2b4beac60408\n+DECL|struct|__anon2a3516340408\n-value|(sizeof(ba->bundles[0]) * 8)\n+value|(sizeof((ba)->bundles[0]) * 8)\nThe issue was with: lib: added missing parenthesis\n\n- added missing parenthesis around macro argument expansion"
},{
  "instruction": "There is an issue in the following code. It relates to ieee802154: ieee802154_cc13xx_cc26xx_subg: Fix tcp timeout\n\n- If status == PROP_ERROR_RXBUF, that means rx buffer head is not empty.\n  In case of this, RF_EventRxEntryDone is never triggered and thus we\n  enter an infinite loop of nothing happening. Due to this, TCP socket\n  times out.\n- To fix this, we need to free rx buffer current head. However, it seems\n  better to free all the elements that are already finished instead of\n  just head.\n- Before a90796f732dd6f5b51da154e7d4134d314751452 [formerly 128354ae17fb95ec6c61d73b9060f1a274715464], the buffer was reset\n  every time drv_rx_start was called. However, that also seems wrong for\n  a ring buffer. So I am freeing the finished buffers instead.\n- Tested on Beagleconnect Freedom.\n- Fixes https://github.com/zephyrproject-rtos/zephyr/issues/71191 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|status\nargument_list|,\nname|e\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|e\noperator|&\nname|RF_EventRxEntryDone\ncondition|)\nblock|{\nname|drv_rx_done\nargument_list|(\nname|drv_data",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* If PROP_ERROR_RXBUF is returned, then RF_EventRxEntryDone is never \t * triggered. So finished buffers need to be cleaned up even on this \t * status. \t */\n+operator|||\n+name|op\n+operator|->\n+name|status\n+operator|==\n+name|PROP_ERROR_RXBUF\nThe issue was with: ieee802154: ieee802154_cc13xx_cc26xx_subg: Fix tcp timeout\n\n- If status == PROP_ERROR_RXBUF, that means rx buffer head is not empty.\n  In case of this, RF_EventRxEntryDone is never triggered and thus we\n  enter an infinite loop of nothing happening. Due to this, TCP socket\n  times out.\n- To fix this, we need to free rx buffer current head. However, it seems\n  better to free all the elements that are already finished instead of\n  just head.\n- Before a90796f732dd6f5b51da154e7d4134d314751452 [formerly 128354ae17fb95ec6c61d73b9060f1a274715464], the buffer was reset\n  every time drv_rx_start was called. However, that also seems wrong for\n  a ring buffer. So I am freeing the finished buffers instead.\n- Tested on Beagleconnect Freedom.\n- Fixes https://github.com/zephyrproject-rtos/zephyr/issues/71191"
},{
  "instruction": "There is an issue in the following code. It relates to samples: Bluetooth: CAP: Add missing argument to get_chan_allocation\n\nThe sample was missing a argument to the function. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|codec_cfg\nargument_list|,\noperator|&\nname|chan_allocation\nargument_list|)\noperator|==\nliteral|0\ncondition|)\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n+argument_list|,\n+name|true\nThe issue was with: samples: Bluetooth: CAP: Add missing argument to get_chan_allocation\n\nThe sample was missing a argument to the function."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: display: Update setting the mode in the st7796s driver\n\nMIPI mode is read from the device tree. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ST7796S_INIT\nparameter_list|(\nname|n\nparameter_list|)\ndefine|\\\nvalue|static const struct st7796s_config st7796s_config_##n = {\t\t\\ \t\t.mipi_dbi = DEVICE_DT_GET(DT_INST_PARENT(n)),\t\t\t\\ \t\t.dbi_config = {\t\t\t\t\t\t\t\\ \t\t\t.config = MIPI_DBI_SPI_CONFIG_DT(\t\t\t\\ \t\t\t\t\t\tDT_DRV_INST(n),\t\t\t\\ \t\t\t\t\t\tSPI_OP_MODE_MASTER |\t\t\\ \t\t\t\t\t\tSPI_WORD_SET(8),\t\t\\ \t\t\t\t\t\t0),\t\t\t\t\\ \t\t\t.mode = MIPI_DBI_MODE_SPI_4WIRE,\t\t\t\\ \t\t},\t\t\t\t\t\t\t\t\\ \t\t.width = DT_INST_PROP(n, width),\t\t\t\t\\ \t\t.height = DT_INST_PROP(n, height),\t\t\t\t\\ \t\t.inverted = DT_INST_PROP(n, color_invert),\t\t\t\\ \t\t.dic = DT_INST_ENUM_IDX(n, invert_mode),\t\t\t\\ \t\t.frmctl1 = DT_INST_PROP(n, frmctl1),\t\t\t\t\\ \t\t.frmctl2 = DT_INST_PROP(n, frmctl2),\t\t\t\t\\ \t\t.frmctl3 = DT_INST_PROP(n, frmctl3),\t\t\t\t\\ \t\t.bpc = DT_INST_PROP(n, bpc),\t\t\t\t\t\\ \t\t.dfc = DT_INST_PROP(n, dfc),\t\t\t\t\t\\ \t\t.pwr1 = DT_INST_PROP(n, pwr1),\t\t\t\t\t\\ \t\t.pwr2 = DT_INST_PROP(n, pwr2),\t\t\t\t\t\\ \t\t.pwr3 = DT_INST_PROP(n, pwr3),\t\t\t\t\t\\ \t\t.vcmpctl = DT_INST_PROP(n, vcmpctl),\t\t\t\t\\ \t\t.doca = DT_INST_PROP(n, doca),\t\t\t\t\t\\ \t\t.pgc = DT_INST_PROP(n, pgc),\t\t\t\t\t\\ \t\t.ngc = DT_INST_PROP(n, ngc),\t\t\t\t\t\\ \t\t.madctl = DT_INST_PROP(n, madctl),\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n, st7796s_init,\t\t\t\t\t\\ \t\t\tNULL,\t\t\t\t\t\t\t\\ \t\t\tNULL,\t\t\t\t\t\t\t\\&st7796s_config_##n,\t\t\t\t\t\\ \t\t\tPOST_KERNEL, CONFIG_DISPLAY_INIT_PRIORITY,\t\t\\&st7796s_api);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|static const struct st7796s_config st7796s_config_##n = {\t\t\\ \t\t.mipi_dbi = DEVICE_DT_GET(DT_INST_PARENT(n)),\t\t\t\\ \t\t.dbi_config = {\t\t\t\t\t\t\t\\ \t\t\t.config = MIPI_DBI_SPI_CONFIG_DT(\t\t\t\\ \t\t\t\t\t\tDT_DRV_INST(n),\t\t\t\\ \t\t\t\t\t\tSPI_OP_MODE_MASTER |\t\t\\ \t\t\t\t\t\tSPI_WORD_SET(8),\t\t\\ \t\t\t\t\t\t0),\t\t\t\t\\ \t\t\t.mode = MIPI_DBI_MODE_SPI_4WIRE,\t\t\t\\ \t\t},\t\t\t\t\t\t\t\t\\ \t\t.width = DT_INST_PROP(n, width),\t\t\t\t\\ \t\t.height = DT_INST_PROP(n, height),\t\t\t\t\\ \t\t.inverted = DT_INST_PROP(n, color_invert),\t\t\t\\ \t\t.dic = DT_INST_ENUM_IDX(n, invert_mode),\t\t\t\\ \t\t.frmctl1 = DT_INST_PROP(n, frmctl1),\t\t\t\t\\ \t\t.frmctl2 = DT_INST_PROP(n, frmctl2),\t\t\t\t\\ \t\t.frmctl3 = DT_INST_PROP(n, frmctl3),\t\t\t\t\\ \t\t.bpc = DT_INST_PROP(n, bpc),\t\t\t\t\t\\ \t\t.dfc = DT_INST_PROP(n, dfc),\t\t\t\t\t\\ \t\t.pwr1 = DT_INST_PROP(n, pwr1),\t\t\t\t\t\\ \t\t.pwr2 = DT_INST_PROP(n, pwr2),\t\t\t\t\t\\ \t\t.pwr3 = DT_INST_PROP(n, pwr3),\t\t\t\t\t\\ \t\t.vcmpctl = DT_INST_PROP(n, vcmpctl),\t\t\t\t\\ \t\t.doca = DT_INST_PROP(n, doca),\t\t\t\t\t\\ \t\t.pgc = DT_INST_PROP(n, pgc),\t\t\t\t\t\\ \t\t.ngc = DT_INST_PROP(n, ngc),\t\t\t\t\t\\ \t\t.madctl = DT_INST_PROP(n, madctl),\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n, st7796s_init,\t\t\t\t\t\\ \t\t\tNULL,\t\t\t\t\t\t\t\\ \t\t\tNULL,\t\t\t\t\t\t\t\\&st7796s_config_##n,\t\t\t\t\t\\ \t\t\tPOST_KERNEL, CONFIG_DISPLAY_INIT_PRIORITY,\t\t\\&st7796s_api);\n+value|static const struct st7796s_config st7796s_config_##n = {\t\t\\ \t\t.mipi_dbi = DEVICE_DT_GET(DT_INST_PARENT(n)),\t\t\t\\ \t\t.dbi_config = {\t\t\t\t\t\t\t\\ \t\t\t.config = MIPI_DBI_SPI_CONFIG_DT(\t\t\t\\ \t\t\t\t\t\tDT_DRV_INST(n),\t\t\t\\ \t\t\t\t\t\tSPI_OP_MODE_MASTER |\t\t\\ \t\t\t\t\t\tSPI_WORD_SET(8),\t\t\\ \t\t\t\t\t\t0),\t\t\t\t\\ \t\t\t.mode = DT_INST_PROP_OR(n, mipi_mode,\t\t\t\\ \t\t\t\t\t\tMIPI_DBI_MODE_SPI_4WIRE),\t\\ \t\t},\t\t\t\t\t\t\t\t\\ \t\t.width = DT_INST_PROP(n, width),\t\t\t\t\\ \t\t.height = DT_INST_PROP(n, height),\t\t\t\t\\ \t\t.inverted = DT_INST_PROP(n, color_invert),\t\t\t\\ \t\t.dic = DT_INST_ENUM_IDX(n, invert_mode),\t\t\t\\ \t\t.frmctl1 = DT_INST_PROP(n, frmctl1),\t\t\t\t\\ \t\t.frmctl2 = DT_INST_PROP(n, frmctl2),\t\t\t\t\\ \t\t.frmctl3 = DT_INST_PROP(n, frmctl3),\t\t\t\t\\ \t\t.bpc = DT_INST_PROP(n, bpc),\t\t\t\t\t\\ \t\t.dfc = DT_INST_PROP(n, dfc),\t\t\t\t\t\\ \t\t.pwr1 = DT_INST_PROP(n, pwr1),\t\t\t\t\t\\ \t\t.pwr2 = DT_INST_PROP(n, pwr2),\t\t\t\t\t\\ \t\t.pwr3 = DT_INST_PROP(n, pwr3),\t\t\t\t\t\\ \t\t.vcmpctl = DT_INST_PROP(n, vcmpctl),\t\t\t\t\\ \t\t.doca = DT_INST_PROP(n, doca),\t\t\t\t\t\\ \t\t.pgc = DT_INST_PROP(n, pgc),\t\t\t\t\t\\ \t\t.ngc = DT_INST_PROP(n, ngc),\t\t\t\t\t\\ \t\t.madctl = DT_INST_PROP(n, madctl),\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n, st7796s_init,\t\t\t\t\t\\ \t\t\tNULL,\t\t\t\t\t\t\t\\ \t\t\tNULL,\t\t\t\t\t\t\t\\&st7796s_config_##n,\t\t\t\t\t\\ \t\t\tPOST_KERNEL, CONFIG_DISPLAY_INIT_PRIORITY,\t\t\\&st7796s_api);\nThe issue was with: drivers: display: Update setting the mode in the st7796s driver\n\nMIPI mode is read from the device tree."
},{
  "instruction": "There is an issue in the following code. It relates to modbus_serial: Disable rx interrupt if buffer fills up\n\nDisable rx interrupt if the buffer fills up so that rtu_timer can fire and\nprocess the buffer. Please fix this issue.",
  "input": "Faulty tokenized code:\nelse|else\nblock|{\nname|int\nname|n\ndecl_stmt|;\ncomment|/* Restart timer on a new character */\nname|k_timer_start\nargument_list|(\noperator|&\nname|cfg",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|cfg\n+operator|->\n+name|uart_buf_ctr\n+operator|==\n+name|CONFIG_MODBUS_BUFFER_SIZE\n+condition|)\n+block|{\n+comment|/* Buffer full. Disable interrupt until timeout. */\n+name|modbus_serial_rx_disable\n+argument_list|(\n+name|ctx\n+argument_list|)\n+expr_stmt|;\n+return|return;\n+block|}\nThe issue was with: modbus_serial: Disable rx interrupt if buffer fills up\n\nDisable rx interrupt if the buffer fills up so that rtu_timer can fire and\nprocess the buffer."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: crypto: make driver API and conf structs const\n\nSave precious RAM by making sure driver API and config structs are\ndeclared as const Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_struct\nDECL|struct|chip_sha256_ctx\nstruct|struct\nname|chip_sha256_ctx\nblock|{\nDECL|union|__anon2c8bc6bb010a\nunion|union\nblock|{\ncomment|/* W[0] ~ W[15] */\nDECL|member|w_sha\nname|uint32_t\nend_function\n\nbegin_decl_stmt\nDECL|variable|it8xxx2_crypto_api\nspecifier|static\nname|struct\nname|crypto_driver_api\nname|it8xxx2_crypto_api\ninit|=\nblock|{\nbegin_struct\nDECL|struct|chip_sha256_ctx\nstruct|struct\nname|chip_sha256_ctx\nblock|{\nDECL|union|__anon2965aed9010a\nunion|union\nblock|{\ncomment|/* SHA data buffer */\nDECL|member|w_sha\nname|uint32_t\nend_function\n\nbegin_decl_stmt\nDECL|variable|it8xxx2_crypto_api\nspecifier|static\nname|struct\nname|crypto_driver_api\nname|it8xxx2_crypto_api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|xec_symcr_api\nspecifier|static\nname|struct\nname|crypto_driver_api\nname|xec_symcr_api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|crypto_dcp_api\nspecifier|static\nname|struct\nname|crypto_driver_api\nname|crypto_dcp_api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|npcx_crypto_api\nspecifier|static\nname|struct\nname|crypto_driver_api\nname|npcx_crypto_api\ninit|=\nblock|{\nname|defined\nargument_list|(\nname|CONFIG_CRYPTO_ASYNC\nargument_list|)\ncomment|/*      * User-defined callbacks to be called upon completion of asynchronous      * cryptographic operations. Note that the AES and HASH modes can work      * complementary to each other.      */\nDECL|union|__anon27fea83a010a\nunion|union\nblock|{\nDECL|member|cipher_user_cb\nname|cipher_completion_cb\nname|cipher_user_cb\nname|hash_user_cb\ndecl_stmt|;\nblock|}\nunion|;\ncomment|/*      * Packet context should be stored during a session so that can be rertieved      * from within the crypto engine ISR context.      */\nDECL|union|__anon27fea83a020a\nunion|union\nblock|{\nDECL|member|cipher_pkt\nname|struct\nname|cipher_pkt\nend_endif\n\nbegin_decl_stmt\nDECL|variable|crypto_smartbond_driver_api\nspecifier|static\nname|struct\nname|crypto_driver_api\nname|crypto_smartbond_driver_api\ninit|=\nblock|{\nend_decl_stmt\n\nbegin_decl_stmt\nDECL|variable|crypto_stm32_dev_config\nspecifier|static\nname|struct\nname|crypto_stm32_config\nname|crypto_stm32_dev_config\ninit|=\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon2c8bc6bb010a\n+DECL|union|__anon2af040ff010a\n+specifier|const\n-DECL|union|__anon2965aed9010a\n+DECL|union|__anon2ac4e5ee010a\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\n-DECL|union|__anon27fea83a010a\n+DECL|union|__anon2748fb3a010a\n-DECL|union|__anon27fea83a020a\n+DECL|union|__anon2748fb3a020a\n+specifier|const\n+specifier|const\nThe issue was with: drivers: crypto: make driver API and conf structs const\n\nSave precious RAM by making sure driver API and config structs are\ndeclared as const"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: Fix regression due to use of TMR_START_DELAY_US\n\nFix regression due to use of HAL_RADIO_TMR_START_DELAY_US\nintroduced in commit b422d74c5d6f [formerly 11bae5cfa95b] (\\\"Bluetooth: Controller:\nFix missing radio timer comp and range delay\\\"). Please fix this issue.",
  "input": "Faulty tokenized code:\nindex|[\nname|cc\nindex|]\noperator|-\nname|delay\noperator|-\nname|HAL_RADIO_TMR_START_DELAY_US\noperator|)\nargument_list|)\nexpr_stmt|;\nblock|}\nelse|else",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|-\n-name|HAL_RADIO_TMR_START_DELAY_US\nThe issue was with: Bluetooth: Controller: Fix regression due to use of TMR_START_DELAY_US\n\nFix regression due to use of HAL_RADIO_TMR_START_DELAY_US\nintroduced in commit b422d74c5d6f [formerly 11bae5cfa95b] (\\\"Bluetooth: Controller:\nFix missing radio timer comp and range delay\\\")."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: Set default baud rate and data bits in max32 driver\n\nThe uart-controller devicetree binding declares current-speed and\ndata-bits properties as optional, but the max32 uart driver failed to\nbuild if they weren't defined. Fix the driver by falling back to\ncommonly used values for these properties. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|MAX32_UART_INIT\nparameter_list|(\nname|_num\nparameter_list|)\ndefine|\\\nvalue|PINCTRL_DT_INST_DEFINE(_num);                                                              \\ \tIF_ENABLED(CONFIG_UART_INTERRUPT_DRIVEN,                                                   \\ \t\t   (static void uart_max32_irq_init_##_num(const struct device *dev)               \\ \t\t   {                                                                               \\ \t\t\t   IF_ENABLED(                                                             \\ \t\t\t\t   CONFIG_UART_INTERRUPT_DRIVEN,                                   \\ \t\t\t\t   (IRQ_CONNECT(DT_INST_IRQN(_num), DT_INST_IRQ(_num, priority),   \\ \t\t\t\t\t\tuart_max32_isr, DEVICE_DT_INST_GET(_num), 0);      \\ \t\t\t\t    irq_enable(DT_INST_IRQN(_num))));                              \\ \t\t   }));                                                                            \\ \tstatic const struct max32_uart_config max32_uart_config_##_num = {                         \\ \t\t.regs = (mxc_uart_regs_t *)DT_INST_REG_ADDR(_num),                                 \\ \t\t.pctrl = PINCTRL_DT_INST_DEV_CONFIG_GET(_num),                                     \\ \t\t.clock = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(_num)),                                 \\ \t\t.perclk.bus = DT_INST_CLOCKS_CELL(_num, offset),                                   \\ \t\t.perclk.bit = DT_INST_CLOCKS_CELL(_num, bit),                                      \\ \t\t.perclk.clk_src =                                                                  \\ \t\t\tDT_INST_PROP_OR(_num, clock_source, ADI_MAX32_PRPH_CLK_SRC_PCLK),          \\ \t\t.uart_conf.baudrate = DT_INST_PROP(_num, current_speed),                           \\ \t\t.uart_conf.parity = DT_INST_ENUM_IDX_OR(_num, parity, UART_CFG_PARITY_NONE),       \\ \t\t.uart_conf.data_bits = DT_INST_ENUM_IDX(_num, data_bits),                          \\ \t\t.uart_conf.stop_bits = DT_INST_ENUM_IDX_OR(_num, stop_bits, UART_CFG_STOP_BITS_1), \\ \t\t.uart_conf.flow_ctrl =                                                             \\ \t\t\tDT_INST_PROP_OR(_num, hw_flow_control, UART_CFG_FLOW_CTRL_NONE),           \\ \t\tIF_ENABLED(CONFIG_UART_INTERRUPT_DRIVEN,                                           \\ \t\t\t   (.irq_config_func = uart_max32_irq_init_##_num,))};                     \\ \tstatic struct max32_uart_data max32_uart_data##_num = {                                    \\ \t\tIF_ENABLED(CONFIG_UART_INTERRUPT_DRIVEN, (.cb = NULL,))};                          \\ \tDEVICE_DT_INST_DEFINE(_num, uart_max32_init, NULL,&max32_uart_data##_num,                 \\&max32_uart_config_##_num, PRE_KERNEL_1,                             \\ \t\t\t      CONFIG_SERIAL_INIT_PRIORITY, (void *)&uart_max32_driver_api);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|PINCTRL_DT_INST_DEFINE(_num);                                                              \\ \tIF_ENABLED(CONFIG_UART_INTERRUPT_DRIVEN,                                                   \\ \t\t   (static void uart_max32_irq_init_##_num(const struct device *dev)               \\ \t\t   {                                                                               \\ \t\t\t   IF_ENABLED(                                                             \\ \t\t\t\t   CONFIG_UART_INTERRUPT_DRIVEN,                                   \\ \t\t\t\t   (IRQ_CONNECT(DT_INST_IRQN(_num), DT_INST_IRQ(_num, priority),   \\ \t\t\t\t\t\tuart_max32_isr, DEVICE_DT_INST_GET(_num), 0);      \\ \t\t\t\t    irq_enable(DT_INST_IRQN(_num))));                              \\ \t\t   }));                                                                            \\ \tstatic const struct max32_uart_config max32_uart_config_##_num = {                         \\ \t\t.regs = (mxc_uart_regs_t *)DT_INST_REG_ADDR(_num),                                 \\ \t\t.pctrl = PINCTRL_DT_INST_DEV_CONFIG_GET(_num),                                     \\ \t\t.clock = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(_num)),                                 \\ \t\t.perclk.bus = DT_INST_CLOCKS_CELL(_num, offset),                                   \\ \t\t.perclk.bit = DT_INST_CLOCKS_CELL(_num, bit),                                      \\ \t\t.perclk.clk_src =                                                                  \\ \t\t\tDT_INST_PROP_OR(_num, clock_source, ADI_MAX32_PRPH_CLK_SRC_PCLK),          \\ \t\t.uart_conf.baudrate = DT_INST_PROP(_num, current_speed),                           \\ \t\t.uart_conf.parity = DT_INST_ENUM_IDX_OR(_num, parity, UART_CFG_PARITY_NONE),       \\ \t\t.uart_conf.data_bits = DT_INST_ENUM_IDX(_num, data_bits),                          \\ \t\t.uart_conf.stop_bits = DT_INST_ENUM_IDX_OR(_num, stop_bits, UART_CFG_STOP_BITS_1), \\ \t\t.uart_conf.flow_ctrl =                                                             \\ \t\t\tDT_INST_PROP_OR(_num, hw_flow_control, UART_CFG_FLOW_CTRL_NONE),           \\ \t\tIF_ENABLED(CONFIG_UART_INTERRUPT_DRIVEN,                                           \\ \t\t\t   (.irq_config_func = uart_max32_irq_init_##_num,))};                     \\ \tstatic struct max32_uart_data max32_uart_data##_num = {                                    \\ \t\tIF_ENABLED(CONFIG_UART_INTERRUPT_DRIVEN, (.cb = NULL,))};                          \\ \tDEVICE_DT_INST_DEFINE(_num, uart_max32_init, NULL,&max32_uart_data##_num,                 \\&max32_uart_config_##_num, PRE_KERNEL_1,                             \\ \t\t\t      CONFIG_SERIAL_INIT_PRIORITY, (void *)&uart_max32_driver_api);\n+value|PINCTRL_DT_INST_DEFINE(_num);                                                              \\ \tIF_ENABLED(CONFIG_UART_INTERRUPT_DRIVEN,                                                   \\ \t\t   (static void uart_max32_irq_init_##_num(const struct device *dev)               \\ \t\t   {                                                                               \\ \t\t\t   IF_ENABLED(                                                             \\ \t\t\t\t   CONFIG_UART_INTERRUPT_DRIVEN,                                   \\ \t\t\t\t   (IRQ_CONNECT(DT_INST_IRQN(_num), DT_INST_IRQ(_num, priority),   \\ \t\t\t\t\t\tuart_max32_isr, DEVICE_DT_INST_GET(_num), 0);      \\ \t\t\t\t    irq_enable(DT_INST_IRQN(_num))));                              \\ \t\t   }));                                                                            \\ \tstatic const struct max32_uart_config max32_uart_config_##_num = {                         \\ \t\t.regs = (mxc_uart_regs_t *)DT_INST_REG_ADDR(_num),                                 \\ \t\t.pctrl = PINCTRL_DT_INST_DEV_CONFIG_GET(_num),                                     \\ \t\t.clock = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(_num)),                                 \\ \t\t.perclk.bus = DT_INST_CLOCKS_CELL(_num, offset),                                   \\ \t\t.perclk.bit = DT_INST_CLOCKS_CELL(_num, bit),                                      \\ \t\t.perclk.clk_src =                                                                  \\ \t\t\tDT_INST_PROP_OR(_num, clock_source, ADI_MAX32_PRPH_CLK_SRC_PCLK),          \\ \t\t.uart_conf.baudrate = DT_INST_PROP_OR(_num, current_speed, 115200),                \\ \t\t.uart_conf.parity = DT_INST_ENUM_IDX_OR(_num, parity, UART_CFG_PARITY_NONE),       \\ \t\t.uart_conf.data_bits = DT_INST_ENUM_IDX_OR(_num, data_bits, UART_CFG_DATA_BITS_8), \\ \t\t.uart_conf.stop_bits = DT_INST_ENUM_IDX_OR(_num, stop_bits, UART_CFG_STOP_BITS_1), \\ \t\t.uart_conf.flow_ctrl =                                                             \\ \t\t\tDT_INST_PROP_OR(_num, hw_flow_control, UART_CFG_FLOW_CTRL_NONE),           \\ \t\tIF_ENABLED(CONFIG_UART_INTERRUPT_DRIVEN,                                           \\ \t\t\t   (.irq_config_func = uart_max32_irq_init_##_num,))};                     \\ \tstatic struct max32_uart_data max32_uart_data##_num = {                                    \\ \t\tIF_ENABLED(CONFIG_UART_INTERRUPT_DRIVEN, (.cb = NULL,))};                          \\ \tDEVICE_DT_INST_DEFINE(_num, uart_max32_init, NULL,&max32_uart_data##_num,                 \\&max32_uart_config_##_num, PRE_KERNEL_1,                             \\ \t\t\t      CONFIG_SERIAL_INIT_PRIORITY, (void *)&uart_max32_driver_api);\nThe issue was with: drivers: serial: Set default baud rate and data bits in max32 driver\n\nThe uart-controller devicetree binding declares current-speed and\ndata-bits properties as optional, but the max32 uart driver failed to\nbuild if they weren't defined. Fix the driver by falling back to\ncommonly used values for these properties."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: wifi: add bssid/mac to wifi_scan result\n\ncopy bssid in wifi scan result if set Please fix this issue.",
  "input": "Faulty tokenized code:\nname|k\nindex|]\noperator|.\nname|primary\nexpr_stmt|;\nswitch|switch\ncondition|(\nname|ap_list_buffer\nindex|[\nname|k",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|memcpy\n+argument_list|(\n+name|res\n+operator|.\n+name|mac\n+argument_list|,\n+name|ap_list_buffer\n+index|[\n+name|k\n+index|]\n+operator|.\n+name|bssid\n+argument_list|,\n+name|WIFI_MAC_ADDR_LEN\n+argument_list|)\n+expr_stmt|;\n+name|res\n+operator|.\n+name|mac_length\n+operator|=\n+name|WIFI_MAC_ADDR_LEN\n+expr_stmt|;\nThe issue was with: drivers: wifi: add bssid/mac to wifi_scan result\n\ncopy bssid in wifi scan result if set"
},{
  "instruction": "There is an issue in the following code. It relates to modem: chat: patch unintended behavior in modem_chat_run_script()\n\nTrying to start a chat script using either modem_chat_run_script()\nor modem_chat_run_script_async() should result in returning -EBUSY\nwithout affecting the currently running script and thread waiting\non the current script to stop.\n\nThe current behavior causes the thread waiting for the current\nscript to stop to return with error -EAGAIN, and the thread trying\nto start the new script to return with error -EBUSY.\n\nThis commit moves the reset of the sem the current thread is\nwaiting on, to after the check of whether a script is currently\nrunning, leaving the current thread unaffected as is intended. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|return\noperator|-\nname|EBUSY\nreturn|;\nblock|}\nname|chat\noperator|->\nname|pending_script\noperator|=\nname|script\nparameter_list|)\nblock|{\nname|int\nname|ret\ndecl_stmt|;\nname|k_sem_reset\nargument_list|(\noperator|&\nname|chat\noperator|->\nname|script_stopped_sem\nargument_list|)\nexpr_stmt|;\nname|ret\noperator|=\nname|modem_chat_run_script_async\nargument_list|(\nname|chat",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|k_sem_reset\n+argument_list|(\n+operator|&\n+name|chat\n+operator|->\n+name|script_stopped_sem\n+argument_list|)\n+expr_stmt|;\n-name|k_sem_reset\n-argument_list|(\n-operator|&\n-name|chat\n-operator|->\n-name|script_stopped_sem\n-argument_list|)\n-expr_stmt|;\nThe issue was with: modem: chat: patch unintended behavior in modem_chat_run_script()\n\nTrying to start a chat script using either modem_chat_run_script()\nor modem_chat_run_script_async() should result in returning -EBUSY\nwithout affecting the currently running script and thread waiting\non the current script to stop.\n\nThe current behavior causes the thread waiting for the current\nscript to stop to return with error -EAGAIN, and the thread trying\nto start the new script to return with error -EBUSY.\n\nThis commit moves the reset of the sem the current thread is\nwaiting on, to after the check of whether a script is currently\nrunning, leaving the current thread unaffected as is intended."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: loapic: move 'z_loapic_int_vec_set()' into pinned section\n\nMove it out of boot section because it's also called by none-boot function\n'loapic_resume()' at runtime. Better to keep boot-only things in boot\nsection to avoid paging in boot section things at runtime. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/**  * @brief Set the vector field in the specified RTE  *  * This associates an IRQ with the desired vector in the IDT.  */\nend_comment\n\nbegin_function\nname|__boot_func\nDECL|function|z_loapic_int_vec_set (unsigned int irq,unsigned int vector)\nname|void\nname|z_loapic_int_vec_set\nparameter_list|(\nname|unsigned",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|__boot_func\n+name|__pinned_func\nThe issue was with: drivers: loapic: move 'z_loapic_int_vec_set()' into pinned section\n\nMove it out of boot section because it's also called by none-boot function\n'loapic_resume()' at runtime. Better to keep boot-only things in boot\nsection to avoid paging in boot section things at runtime."
},{
  "instruction": "There is an issue in the following code. It relates to tests: Bluetooth: bap_broadcast_source: Fix call\n\nbt_audio_codec_cfg_get_chan_allocation() now takes an\nextra parameter.\nLet's set it to the value which keeps the old behaviour. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|codec_cfg\nargument_list|,\noperator|&\nname|chan_allocation\nargument_list|)\nexpr_stmt|;\nname|zassert_equal\nargument_list|(\nname|chan_allocation",
  "result": "I corrected the issue in the code by changing the following tokens:\n+argument_list|,\n+name|false\nThe issue was with: tests: Bluetooth: bap_broadcast_source: Fix call\n\nbt_audio_codec_cfg_get_chan_allocation() now takes an\nextra parameter.\nLet's set it to the value which keeps the old behaviour."
},{
  "instruction": "There is an issue in the following code. It relates to bsim: fix missing parameter in BT audio source test\n\nPR #72571 added fallback functions to BT audio, but not all bsim\ntests were properly updated to use new functions signatures. This\ncommit fixes a remaining error with the same pattern as the\noriginal PR did for \\\"bap_broadcast_sink_test.c\\\". Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|codec_cfg\nargument_list|,\noperator|&\nname|chan_allocation\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|ret",
  "result": "I corrected the issue in the code by changing the following tokens:\n+argument_list|,\n+name|false\nThe issue was with: bsim: fix missing parameter in BT audio source test\n\nPR #72571 added fallback functions to BT audio, but not all bsim\ntests were properly updated to use new functions signatures. This\ncommit fixes a remaining error with the same pattern as the\noriginal PR did for \\\"bap_broadcast_sink_test.c\\\"."
},{
  "instruction": "There is an issue in the following code. It relates to soc: stm32c0 Enable ART acceleration\n\nEnable instruction cache as well as prefetch. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<string.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<cmsis_core.h>\nend_include\nname|stm32c0_init\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\ncomment|/* Update CMSIS SystemCoreClock variable (HCLK) */\ncomment|/* At reset, system core clock is set to 48 MHz from HSI */\nname|SystemCoreClock\noperator|=\nliteral|48000000",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<stm32_ll_system.h>\n+end_include\n+\n+comment|/* Enable ART Accelerator I-cache and prefetch */\n+name|LL_FLASH_EnableInstCache\n+argument_list|()\n+expr_stmt|;\n+name|LL_FLASH_EnablePrefetch\n+argument_list|()\n+expr_stmt|;\nThe issue was with: soc: stm32c0 Enable ART acceleration\n\nEnable instruction cache as well as prefetch."
},{
  "instruction": "There is an issue in the following code. It relates to soc: stm32g4: Enable ART acceleration\n\nEnable instruction and data cache as well as prefetch. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|stm32g4_init\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\ncomment|/* Update CMSIS SystemCoreClock variable (HCLK) */\ncomment|/* At reset, system core clock is set to 16 MHz from HSI */\nname|SystemCoreClock\noperator|=\nliteral|16000000",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Enable ART Accelerator I/D-cache and prefetch */\n+name|LL_FLASH_EnableInstCache\n+argument_list|()\n+expr_stmt|;\n+name|LL_FLASH_EnableDataCache\n+argument_list|()\n+expr_stmt|;\n+name|LL_FLASH_EnablePrefetch\n+argument_list|()\n+expr_stmt|;\nThe issue was with: soc: stm32g4: Enable ART acceleration\n\nEnable instruction and data cache as well as prefetch."
},{
  "instruction": "There is an issue in the following code. It relates to soc: stm32: stm32wb: Enable ART accelerations\n\nEnable instruction and data cache as well as prefetch. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/logging/log.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<cmsis_core.h>\nend_include\nname|stm32wb_init\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\ncomment|/* Update CMSIS SystemCoreClock variable (HCLK) */\ncomment|/* At reset, system core clock is set to 4 MHz from MSI */\nname|SystemCoreClock\noperator|=\nliteral|4000000",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<stm32_ll_system.h>\n+end_include\n+\n+comment|/* Enable the ART Accelerator I-cache, D-cache and prefetch */\n+name|LL_FLASH_EnableInstCache\n+argument_list|()\n+expr_stmt|;\n+name|LL_FLASH_EnableDataCache\n+argument_list|()\n+expr_stmt|;\n+name|LL_FLASH_EnablePrefetch\n+argument_list|()\n+expr_stmt|;\nThe issue was with: soc: stm32: stm32wb: Enable ART accelerations\n\nEnable instruction and data cache as well as prefetch."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: clock_control: litex: declare unmuttable map as const\n\nSave precious RAM by declaring DRP reg->size map as const as it's\nimmutable Please fix this issue.",
  "input": "Faulty tokenized code:\nend_comment\n\nbegin_decl_stmt\nDECL|variable|drp\nspecifier|static\nname|struct\nname|litex_drp_reg\nname|drp\nindex|[]\ninit|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n+specifier|const\nThe issue was with: drivers: clock_control: litex: declare unmuttable map as const\n\nSave precious RAM by declaring DRP reg->size map as const as it's\nimmutable"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: clock_control: make driver API and conf structs const\n\nSave precious RAM by making sure driver API and config structs are\ndeclared as const Please fix this issue.",
  "input": "Faulty tokenized code:\nend_function\n\nbegin_decl_stmt\nDECL|variable|clock_control_gd32_api\nspecifier|static\nname|struct\nname|clock_control_driver_api\nname|clock_control_gd32_api\ninit|=\nblock|{\nend_comment\n\nbegin_decl_stmt\nDECL|variable|xec_clock_control_api\nspecifier|static\nname|struct\nname|clock_control_driver_api\nname|xec_clock_control_api\ninit|=\nblock|{\nend_comment\n\nbegin_decl_stmt\nDECL|variable|npcx_clock_control_api\nspecifier|static\nname|struct\nname|clock_control_driver_api\nname|npcx_clock_control_api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|clock_control_nrf_auxpll_api\nspecifier|static\nname|struct\nname|clock_control_driver_api\nname|clock_control_nrf_auxpll_api\ninit|=\nblock|{\nend_comment\n\nbegin_decl_stmt\nDECL|variable|numaker_scc_api\nspecifier|static\nname|struct\nname|clock_control_driver_api\nname|numaker_scc_api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|clock_control_pwm_api\nspecifier|static\nname|struct\nname|clock_control_driver_api\nname|clock_control_pwm_api\ninit|=\nblock|{\nname|RV32M1_PCC_INIT\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|static struct rv32m1_pcc_config rv32m1_pcc##inst##_config = {\t\\ \t\t.base_address = DT_INST_REG_ADDR(inst)\t\t\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst,\t\t\t\t\t\\ \t\t\t    NULL,\t\t\t\t\t\\ \t\t\t    NULL,\t\t\t\t\t\\ \t\t\t    NULL,&rv32m1_pcc##inst##_config,\t\t\\ \t\t\t    PRE_KERNEL_1,\t\t\t\t\\ \t\t\t    CONFIG_CLOCK_CONTROL_INIT_PRIORITY,\t\t\\&rv32m1_pcc_api);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(\nend_function\n\nbegin_decl_stmt\nDECL|variable|atmel_sam_clock_control_api\nspecifier|static\nname|struct\nname|clock_control_driver_api\nname|atmel_sam_clock_control_api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|smartbond_clock_control_api\nspecifier|static\nname|struct\nname|clock_control_driver_api\nname|smartbond_clock_control_api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|stm32_clock_control_api\nspecifier|static\nname|struct\nname|clock_control_driver_api\nname|stm32_clock_control_api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|stm32_clock_control_api\nspecifier|static\nname|struct\nname|clock_control_driver_api\nname|stm32_clock_control_api\ninit|=\nblock|{\nliteral|0\nreturn|;\nblock|}\nDECL|variable|stm32_clock_control_api\nspecifier|static\nname|struct\nname|clock_control_driver_api\nname|stm32_clock_control_api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|stm32_clock_control_api\nspecifier|static\nname|struct\nname|clock_control_driver_api\nname|stm32_clock_control_api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|stm32_clock_control_api\nspecifier|static\nname|struct\nname|clock_control_driver_api\nname|stm32_clock_control_api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|stm32_clock_control_api\nspecifier|static\nname|struct\nname|clock_control_driver_api\nname|stm32_clock_control_api\ninit|=\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\n-value|static struct rv32m1_pcc_config rv32m1_pcc##inst##_config = {\t\\ \t\t.base_address = DT_INST_REG_ADDR(inst)\t\t\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst,\t\t\t\t\t\\ \t\t\t    NULL,\t\t\t\t\t\\ \t\t\t    NULL,\t\t\t\t\t\\ \t\t\t    NULL,&rv32m1_pcc##inst##_config,\t\t\\ \t\t\t    PRE_KERNEL_1,\t\t\t\t\\ \t\t\t    CONFIG_CLOCK_CONTROL_INIT_PRIORITY,\t\t\\&rv32m1_pcc_api);\n+value|static const struct rv32m1_pcc_config rv32m1_pcc##inst##_config = {\t\\ \t\t.base_address = DT_INST_REG_ADDR(inst)\t\t\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst,\t\t\t\t\t\\ \t\t\t    NULL,\t\t\t\t\t\\ \t\t\t    NULL,\t\t\t\t\t\\ \t\t\t    NULL,&rv32m1_pcc##inst##_config,\t\t\\ \t\t\t    PRE_KERNEL_1,\t\t\t\t\\ \t\t\t    CONFIG_CLOCK_CONTROL_INIT_PRIORITY,\t\t\\&rv32m1_pcc_api);\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\nThe issue was with: drivers: clock_control: make driver API and conf structs const\n\nSave precious RAM by making sure driver API and config structs are\ndeclared as const"
},{
  "instruction": "There is an issue in the following code. It relates to net: ipv6: mcast_routing: hop limit handling\n\nWhile forwarding a multicast packet decrement hop limit in a common net\nbuffer. Also, packets with hop limit equal to 0 should not be forwarded. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|CONFIG_NET_ROUTE_MCAST\nargument_list|)\nname|int\nname|routed\ndecl_stmt|;\ncomment|/* check if routing loop could be created or if the destination is of \t * interface local scope or if from link local source \t */\nif|if\ncondition|(\nname|net_ipv6_is_addr_mcast\nargument_list|(\noperator|(\noperator|)\nname|hdr\noperator|->\nname|src\nargument_list|)\ncondition|)\nblock|{\nreturn|return\nname|NET_CONTINUE\nreturn|;\nbegin_comment\ncomment|/* CONFIG_NET_MCAST_ROUTE_MLD_REPORTS */\nend_comment\n\nbegin_function\nDECL|function|net_route_mcast_forward_packet (struct net_pkt * pkt,const struct net_ipv6_hdr * hdr)\nname|int\nname|net_route_mcast_forward_packet\nparameter_list|(\nname|struct\nname|net_pkt\nmodifier|*\nname|pkt\nparameter_list|,\nspecifier|const\nname|struct\nname|net_ipv6_hdr\nmodifier|*\nname|hdr\nparameter_list|)\ndecl_stmt|,\nname|err\ninit|=\nliteral|0\ndecl_stmt|;\nname|ARRAY_FOR_EACH_PTR\nargument_list|(\nargument|route_mcast_entries\nargument_list|,\nargument|route\nname|struct\nname|net_pkt\nmodifier|*\nname|pkt\nparameter_list|,\nspecifier|const\nname|struct\nname|net_ipv6_hdr\nmodifier|*\nname|hdr\nparameter_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* check if routing loop could be created or if the destination is of \t * interface local scope or if from link local source \t */\n+comment|/* Continue processing without forwarding if: \t *   1. routing loop could be created \t *   2. the destination is of interface local scope \t *   3. is from link local source \t *   4. hop limit is or would become zero \t */\n+operator|||\n+name|hdr\n+operator|->\n+name|hop_limit\n+operator|<=\n+literal|1\n-DECL|function|net_route_mcast_forward_packet (struct net_pkt * pkt,const struct net_ipv6_hdr * hdr)\n+DECL|function|net_route_mcast_forward_packet (struct net_pkt * pkt,struct net_ipv6_hdr * hdr)\n-specifier|const\n+comment|/* At this point, the original pkt has already stored the hop limit in its metadata. \t * Change its value in a common buffer so the forwardee has a proper count. As we have \t * a direct access to the buffer there is no need to perform read/write operations. \t */\n+name|hdr\n+operator|->\n+name|hop_limit\n+operator|--\n+expr_stmt|;\n-specifier|const\nThe issue was with: net: ipv6: mcast_routing: hop limit handling\n\nWhile forwarding a multicast packet decrement hop limit in a common net\nbuffer. Also, packets with hop limit equal to 0 should not be forwarded."
},{
  "instruction": "There is an issue in the following code. It relates to net: if: Increment the packet ref count when adding to timestamp queue\n\nAdded incrementation of the packet reference count when puting\nthe packet on the queue used in tx timestamping thread. This fixes\nan issue when user wants to access the packet data in the timestamp\ncallback context. Before the fix was introduced if sockets were used\npacket has been unreferenced before execution reached timestamp callback\ncontext. Please fix this issue.",
  "input": "Faulty tokenized code:\nendif|#\ndirective|endif\nend_endif\n\nbegin_struct\nDECL|struct|__anon2c0be4aa0108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|ipv6\nname|struct\nname|CONFIG_NET_NATIVE_IPV4\nargument_list|)\nend_if\n\nbegin_struct\nDECL|struct|__anon2c0be4aa0208\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|ipv4\nname|struct\nargument_list|(\nname|pkt\nargument_list|)\nexpr_stmt|;\nblock|}\nblock|}\nblock|}\nend_function\n\nbegin_function\nname|tx_ts_queue\nargument_list|,\nname|pkt\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_endif\nendif|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2c0be4aa0108\n+DECL|struct|__anon2c412ddb0108\n-DECL|struct|__anon2c0be4aa0208\n+DECL|struct|__anon2c412ddb0208\n+name|net_pkt_unref\n+argument_list|(\n+name|pkt\n+argument_list|)\n+expr_stmt|;\n+name|net_pkt_ref\n+argument_list|(\n+name|pkt\n+argument_list|)\n+expr_stmt|;\nThe issue was with: net: if: Increment the packet ref count when adding to timestamp queue\n\nAdded incrementation of the packet reference count when puting\nthe packet on the queue used in tx timestamping thread. This fixes\nan issue when user wants to access the packet data in the timestamp\ncallback context. Before the fix was introduced if sockets were used\npacket has been unreferenced before execution reached timestamp callback\ncontext."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: HFP_AG: fix building warning\n\nGive `err` a initialization value 0. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nstruct|;\nend_struct\n\nbegin_struct\nDECL|struct|__anon2a164c200108\nspecifier|static\nspecifier|const\nstruct|struct\nblock|{\nDECL|member|name\ninit|=\nliteral|0U\ndecl_stmt|;\nname|int\nname|err\ndecl_stmt|;\nif|if\ncondition|(\noperator|!\nname|is_char",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2a164c200108\n+DECL|struct|__anon28ed627d0108\n+init|=\n+literal|0\nThe issue was with: Bluetooth: HFP_AG: fix building warning\n\nGive `err` a initialization value 0."
},{
  "instruction": "There is an issue in the following code. It relates to bluetooth: hfp_hf: update channel sent callback prototype\n\nDue to the parameter `buf` has been removed by rfcomm,\nupdate the prototype of channel sent callback hfp_hf_sent. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/* The order should follow the enum hfp_hf_ag_indicators */\nend_comment\n\nbegin_struct\nDECL|struct|__anon2755ced90108\nspecifier|static\nspecifier|const\nstruct|struct\nblock|{\nDECL|member|name\nblock|}\nblock|}\nend_function\n\nbegin_function\nDECL|function|hfp_hf_sent (struct bt_rfcomm_dlc * dlc,struct net_buf * buf,int err)\nspecifier|static\nname|void\nname|hfp_hf_sent\nparameter_list|(\nname|struct\nname|bt_rfcomm_dlc\nmodifier|*\nname|dlc\nparameter_list|,\nname|struct\nname|net_buf\nmodifier|*\nname|buf\nparameter_list|,\nname|int\nname|err\nparameter_list|)\nblock|{\nname|LOG_DBG\nargument_list|(\nliteral|\"DLC %p sent cb buf %p (err %d)\"\nargument_list|,\nname|dlc\nargument_list|,\nname|buf\nargument_list|,\nname|err\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2755ced90108\n+DECL|struct|__anon29c9034c0108\n-DECL|function|hfp_hf_sent (struct bt_rfcomm_dlc * dlc,struct net_buf * buf,int err)\n+DECL|function|hfp_hf_sent (struct bt_rfcomm_dlc * dlc,int err)\n-name|struct\n-name|net_buf\n-modifier|*\n-name|buf\n-parameter_list|,\n-literal|\"DLC %p sent cb buf %p (err %d)\"\n+literal|\"DLC %p sent cb (err %d)\"\n-name|buf\n-argument_list|,\nThe issue was with: bluetooth: hfp_hf: update channel sent callback prototype\n\nDue to the parameter `buf` has been removed by rfcomm,\nupdate the prototype of channel sent callback hfp_hf_sent."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: mm: rename z_page_fault() to k_mem_page_fault()\n\nThis is part of a series of move memory management related\nstuff out of Z_ namespace into its own namespace. Please fix this issue.",
  "input": "Faulty tokenized code:\nelse|#\ndirective|else\nblock|{\nname|was_valid_access\noperator|=\nname|z_page_fault\nargument_list|(\nname|virt\nargument_list|)\nexpr_stmt|;\nblock|}\nname|ptables\nargument_list|,\nname|addr\nargument_list|)\nexpr_stmt|;\ncomment|/* Might as well also check if it's un-mapped, normally we don't \t * fetch the PTE from the page tables until we are inside \t * z_page_fault() and call arch_page_fault_status_get() \t */\nif|if\ncondition|(\nname|level\noperator|!=\nname|PTE_LEVEL\nbegin_struct\nDECL|struct|k_mem_page_frame\nstruct|struct\nname|k_mem_page_frame\nblock|{\nDECL|union|__anon28a0a474010a\nunion|union\nblock|{\ncomment|/* \t\t * If mapped, K_MEM_PAGE_FRAME_* flags and virtual address \t\t * this page is mapped to. \t\t */\nDECL|member|va_and_flags\nname|uintptr_t\ncomment|/**  * Handle a page fault for a virtual data page  *  * This is invoked from the architecture page fault handler.  *  * If a valid page fault, the core kernel will obtain a page frame,  * populate it with the data page that was evicted to the backing store,  * update page tables, and return so that the faulting instruction may be  * re-tried.  *  * The architecture must not call this function if the page was mapped and  * not paged out at the time the exception was triggered (i.e. a protection  * violation for a mapped page).  *  * If the faulting context had interrupts disabled when the page fault was  * triggered, the entire page fault handling path must have interrupts  * disabled, including the invocation of this function.  *  * Otherwise, interrupts may be enabled and the page fault handler may be  * preemptible. Races to page-in will be appropriately handled by the kernel.  *  * @param addr Faulting virtual address  * @retval true Page fault successfully handled, or nothing needed to be done.  *              The arch layer should retry the faulting instruction.  * @retval false This page fault was from an un-mapped page, should  *               be treated as an error, and not re-tried.  */\nend_comment\n\nbegin_function_decl\nname|bool\nname|z_page_fault\nparameter_list|(\nname|void\nmodifier|*\nname|addr\nparameter_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|z_page_fault (void * addr)\nname|bool\nname|z_page_fault\nparameter_list|(\nname|void\nmodifier|*\nname|addr\nparameter_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|z_page_fault\n+name|k_mem_page_fault\n-comment|/* Might as well also check if it's un-mapped, normally we don't \t * fetch the PTE from the page tables until we are inside \t * z_page_fault() and call arch_page_fault_status_get() \t */\n+comment|/* Might as well also check if it's un-mapped, normally we don't \t * fetch the PTE from the page tables until we are inside \t * k_mem_page_fault() and call arch_page_fault_status_get() \t */\n-DECL|union|__anon28a0a474010a\n+DECL|union|__anon2b4d60ed010a\n-name|z_page_fault\n+name|k_mem_page_fault\n-DECL|function|z_page_fault (void * addr)\n+DECL|function|k_mem_page_fault (void * addr)\n-name|z_page_fault\n+name|k_mem_page_fault\nThe issue was with: kernel: mm: rename z_page_fault() to k_mem_page_fault()\n\nThis is part of a series of move memory management related\nstuff out of Z_ namespace into its own namespace."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: mm: rename Z_BOOT_* to K_MEM_BOOT_*\n\nRename Z_BOOT_VIRT_TO_PHYS() and Z_BOOT_PHYS_TO_VIRT() to\nK_MEM_BOOT_VIRT_TO_PHYS() and K_MEM_BOOT_PHYS_TO_VIRT()\nrespectively. This is part of a series to move memory management\nfunctions away from the Z_ namespace and into its own namespace. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|Z_VM_OFFSET\nvalue|((CONFIG_KERNEL_VM_BASE + CONFIG_KERNEL_VM_OFFSET) - \\ \t\t\t  (CONFIG_SRAM_BASE_ADDRESS + CONFIG_SRAM_OFFSET))\nend_define\n\nbegin_comment\ncomment|/* Only applies to boot RAM mappings within the Zephyr image that have never  * been remapped or paged out. Never use this unless you know exactly what you  * are doing.  */\nend_comment\n\nbegin_define\nDECL|macro|Z_BOOT_VIRT_TO_PHYS (virt)\ndefine|#\ndirective|define\nname|Z_BOOT_VIRT_TO_PHYS\nparameter_list|(\nname|virt\nparameter_list|)\nvalue|((uintptr_t)(((uint8_t *)(virt)) - Z_VM_OFFSET))\nend_define\n\nbegin_define\nDECL|macro|Z_BOOT_PHYS_TO_VIRT (phys)\ndefine|#\ndirective|define\nname|Z_BOOT_PHYS_TO_VIRT\nparameter_list|(\nname|phys\nparameter_list|)\nvalue|((uint8_t *)(((uintptr_t)(phys)) + Z_VM_OFFSET))\nend_define\nbegin_define\nDECL|macro|Z_FREE_VM_START\ndefine|#\ndirective|define\nname|Z_FREE_VM_START\nvalue|Z_BOOT_PHYS_TO_VIRT(Z_PHYS_RAM_END)\nend_define\n\nbegin_else\nelse|#\ndirective|else\nbegin_struct\nDECL|struct|z_page_frame\nstruct|struct\nname|z_page_frame\nblock|{\nDECL|union|__anon2ab1def7010a\nunion|union\nblock|{\ncomment|/* \t\t * If mapped, Z_PAGE_FRAME_* flags and virtual address \t\t * this page is mapped to. \t\t */\nDECL|member|va_and_flags\nname|uintptr_t\nblock|{\nname|pf\noperator|=\nname|z_phys_to_page_frame\nargument_list|(\nname|Z_BOOT_VIRT_TO_PHYS\nargument_list|(\nname|addr\nargument_list|)\nargument_list|)\nexpr_stmt|;\nblock|{\nname|pf\noperator|=\nname|z_phys_to_page_frame\nargument_list|(\nname|Z_BOOT_VIRT_TO_PHYS\nargument_list|(\nname|addr\nargument_list|)\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* Only applies to boot RAM mappings within the Zephyr image that have never  * been remapped or paged out. Never use this unless you know exactly what you  * are doing.  */\n+comment|/**  * @brief Get physical address from virtual address for boot RAM mappings.  *  * @note Only applies to boot RAM mappings within the Zephyr image that have never  *       been remapped or paged out. Never use this unless you know exactly what you  *       are doing.  *  * @param virt Virtual address.  *  * @return Physical address.  */\n-DECL|macro|Z_BOOT_VIRT_TO_PHYS (virt)\n+DECL|macro|K_MEM_BOOT_VIRT_TO_PHYS (virt)\n-name|Z_BOOT_VIRT_TO_PHYS\n+name|K_MEM_BOOT_VIRT_TO_PHYS\n+begin_comment\n+comment|/**  * @brief Get virtual address from physical address for boot RAM mappings.  *  * @note Only applies to boot RAM mappings within the Zephyr image that have never  *       been remapped or paged out. Never use this unless you know exactly what you  *       are doing.  *  * @param phys Physical address.  *  * @return Virtual address.  */\n+end_comment\n+\n-DECL|macro|Z_BOOT_PHYS_TO_VIRT (phys)\n+DECL|macro|K_MEM_BOOT_PHYS_TO_VIRT (phys)\n-name|Z_BOOT_PHYS_TO_VIRT\n+name|K_MEM_BOOT_PHYS_TO_VIRT\n-value|Z_BOOT_PHYS_TO_VIRT(Z_PHYS_RAM_END)\n+value|K_MEM_BOOT_PHYS_TO_VIRT(Z_PHYS_RAM_END)\n-DECL|union|__anon2ab1def7010a\n+DECL|union|__anon2c42fbb4010a\n-name|Z_BOOT_VIRT_TO_PHYS\n+name|K_MEM_BOOT_VIRT_TO_PHYS\n-name|Z_BOOT_VIRT_TO_PHYS\n+name|K_MEM_BOOT_VIRT_TO_PHYS\nThe issue was with: kernel: mm: rename Z_BOOT_* to K_MEM_BOOT_*\n\nRename Z_BOOT_VIRT_TO_PHYS() and Z_BOOT_PHYS_TO_VIRT() to\nK_MEM_BOOT_VIRT_TO_PHYS() and K_MEM_BOOT_PHYS_TO_VIRT()\nrespectively. This is part of a series to move memory management\nfunctions away from the Z_ namespace and into its own namespace."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: mm: rename Z_MEM_VM_OFFSET to K_MEM_VIRT_OFFSET\n\nThis is part of a series to move memory management functions\naway from the z_ namespace and into its own namespace. Also\nmake documentation available via doxygen. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nif|else if\ncondition|(\nname|phys\noperator|+\nname|Z_MEM_VM_OFFSET\noperator|==\nname|virt\ncondition|)\nblock|{\ncomment|/* Permanent RAM mappings */\nbegin_comment\ncomment|/**  * @defgroup kernel_mm_internal_apis Kernel Memory Management Internal APIs  * @ingroup internal_api  * @{  */\nend_comment\n\nbegin_comment\ncomment|/*  * This is the offset to subtract from a virtual address mapped in the  * kernel's permanent mapping of RAM, to obtain its physical address.  *  *     virt_addr = phys_addr + Z_MEM_VM_OFFSET  *  * This only works for virtual addresses within the interval  * [CONFIG_KERNEL_VM_BASE, CONFIG_KERNEL_VM_BASE + (CONFIG_SRAM_SIZE * 1024)).  *  * These macros are intended for assembly, linker code, and static initializers.  * Use with care.  *  * Note that when demand paging is active, these will only work with page  * frames that are pinned to their virtual mapping at boot.  *  * TODO: This will likely need to move to an arch API or need additional  * constraints defined.  */\nend_comment\n\nbegin_ifdef\nifdef|#\ndirective|ifdef\nname|CONFIG_MMU\nend_ifdef\n\nbegin_define\nDECL|macro|Z_MEM_VM_OFFSET\ndefine|#\ndirective|define\nname|Z_MEM_VM_OFFSET\nvalue|((CONFIG_KERNEL_VM_BASE + CONFIG_KERNEL_VM_OFFSET) - \\ \t\t\t (CONFIG_SRAM_BASE_ADDRESS + CONFIG_SRAM_OFFSET))\nend_define\n\nbegin_else\nelse|#\ndirective|else\nend_else\n\nbegin_define\nDECL|macro|Z_MEM_VM_OFFSET\ndefine|#\ndirective|define\nname|Z_MEM_VM_OFFSET\nvalue|0\nend_define\n\nbegin_endif\nendif|#\ndirective|define\nname|Z_MEM_PHYS_ADDR\nparameter_list|(\nname|virt\nparameter_list|)\nvalue|((virt) - Z_MEM_VM_OFFSET)\nend_define\n\nbegin_define\nDECL|macro|Z_MEM_VIRT_ADDR (phys)\ndefine|#\ndirective|define\nname|Z_MEM_VIRT_ADDR\nparameter_list|(\nname|phys\nparameter_list|)\nvalue|((phys) + Z_MEM_VM_OFFSET)\nend_define\n\nbegin_if\nif|#\ndirective|if\nname|Z_MEM_VM_OFFSET\noperator|!=\nliteral|0\nend_if\n\nbegin_define",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|Z_MEM_VM_OFFSET\n+name|K_MEM_VIRT_OFFSET\n-comment|/*  * This is the offset to subtract from a virtual address mapped in the  * kernel's permanent mapping of RAM, to obtain its physical address.  *  *     virt_addr = phys_addr + Z_MEM_VM_OFFSET  *  * This only works for virtual addresses within the interval  * [CONFIG_KERNEL_VM_BASE, CONFIG_KERNEL_VM_BASE + (CONFIG_SRAM_SIZE * 1024)).  *  * These macros are intended for assembly, linker code, and static initializers.  * Use with care.  *  * Note that when demand paging is active, these will only work with page  * frames that are pinned to their virtual mapping at boot.  *  * TODO: This will likely need to move to an arch API or need additional  * constraints defined.  */\n+comment|/**  * @def K_MEM_VIRT_OFFSET  * @brief Address offset of permanent virtual mapping from physical address.  *  * This is the offset to subtract from a virtual address mapped in the  * kernel's permanent mapping of RAM, to obtain its physical address.  *  *     virt_addr = phys_addr + K_MEM_VIRT_OFFSET  *  * This only works for virtual addresses within the interval  * [CONFIG_KERNEL_VM_BASE, CONFIG_KERNEL_VM_BASE + (CONFIG_SRAM_SIZE * 1024)).  *  * These macros are intended for assembly, linker code, and static initializers.  * Use with care.  *  * Note that when demand paging is active, these will only work with page  * frames that are pinned to their virtual mapping at boot.  *  * TODO: This will likely need to move to an arch API or need additional  * constraints defined.  */\n-DECL|macro|Z_MEM_VM_OFFSET\n+DECL|macro|K_MEM_VIRT_OFFSET\n-name|Z_MEM_VM_OFFSET\n-value|((CONFIG_KERNEL_VM_BASE + CONFIG_KERNEL_VM_OFFSET) - \\ \t\t\t (CONFIG_SRAM_BASE_ADDRESS + CONFIG_SRAM_OFFSET))\n+name|K_MEM_VIRT_OFFSET\n+value|((CONFIG_KERNEL_VM_BASE + CONFIG_KERNEL_VM_OFFSET) - \\ \t\t\t\t (CONFIG_SRAM_BASE_ADDRESS + CONFIG_SRAM_OFFSET))\n-DECL|macro|Z_MEM_VM_OFFSET\n+DECL|macro|K_MEM_VIRT_OFFSET\n-name|Z_MEM_VM_OFFSET\n+name|K_MEM_VIRT_OFFSET\n-value|((virt) - Z_MEM_VM_OFFSET)\n+value|((virt) - K_MEM_VIRT_OFFSET)\n-value|((phys) + Z_MEM_VM_OFFSET)\n+value|((phys) + K_MEM_VIRT_OFFSET)\n-name|Z_MEM_VM_OFFSET\n+name|K_MEM_VIRT_OFFSET\nThe issue was with: kernel: mm: rename Z_MEM_VM_OFFSET to K_MEM_VIRT_OFFSET\n\nThis is part of a series to move memory management functions\naway from the z_ namespace and into its own namespace. Also\nmake documentation available via doxygen."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: mm: rename k_mem_un/map_impl to k_mem_*_phys_guard\n\nThe internal functions k_mem_map_impl() and k_mem_unmap_impl()\nare renamed to k_mem_map_phys_guard() and\nk_mem_unmap_phys_guard() respectively to better clarify\ntheir usage. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|,\nname|size_t\nname|size\nparameter_list|)\nfunction_decl|;\ncomment|/**  * Map memory into virtual address space with guard pages.  *  * This maps memory into virtual address space with a preceding and  * a succeeding guard pages.  *  * @see k_mem_map() for additional information if called via that.  *  * @see k_mem_phys_map() for additional information if called via that.  *  * @param phys Physical address base of the memory region if not requesting  *             anonymous memory. Must be page-aligned.  * @param size Size of the memory mapping. This must be page-aligned.  * @param flags K_MEM_PERM_*, K_MEM_MAP_* control flags.  * @param is_anon True is requesting mapping with anonymous memory.  *  * @return The mapped memory location, or NULL if insufficient virtual address  *         space, insufficient physical memory to establish the mapping,  *         or insufficient memory for paging structures.  */\nname|void\nmodifier|*\nname|k_mem_map_impl\nparameter_list|(\nname|uintptr_t\nname|phys\nparameter_list|,\nname|size_t\nparameter_list|,\nname|bool\nname|is_anon\nparameter_list|)\nfunction_decl|;\ncomment|/**  * Un-map mapped memory  *  * This removes the memory mappings for the provided page-aligned region,  * and the two guard pages surrounding the region.  *  * @see k_mem_unmap() for additional information if called via that.  *  * @see k_mem_phys_unmap() for additional information if called via that.  *  * @note Calling this function on a region which was not mapped to begin  *       with is undefined behavior.  *  * @param addr Page-aligned memory region base virtual address  * @param size Page-aligned memory region size  * @param is_anon True if the mapped memory is from anonymous memory.  */\nname|void\nname|k_mem_unmap_impl\nparameter_list|(\nname|void\nmodifier|*\nname|addr\nparameter_list|,\nname|uint32_t\nname|flags\nparameter_list|)\nblock|{\nreturn|return\nname|k_mem_map_impl\nargument_list|(\noperator|(\nname|uintptr_t\noperator|)\nname|NULL\nname|uint32_t\nname|flags\nparameter_list|)\nblock|{\nreturn|return\nname|k_mem_map_impl\nargument_list|(\nname|phys\nargument_list|,\nname|size\nargument_list|,\nparameter_list|,\nname|size_t\nname|size\nparameter_list|)\nblock|{\nname|k_mem_unmap_impl\nargument_list|(\nname|addr\nargument_list|,\nname|size\nargument_list|,\nparameter_list|,\nname|size_t\nname|size\nparameter_list|)\nblock|{\nname|k_mem_unmap_impl\nargument_list|(\nname|addr\nargument_list|,\nname|size\nargument_list|,\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|k_mem_map_impl (uintptr_t phys,size_t size,uint32_t flags,bool is_anon)\nname|void\nmodifier|*\nname|k_mem_map_impl\nparameter_list|(\nname|uintptr_t\nname|phys\nparameter_list|,\nname|size_t\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|k_mem_unmap_impl (void * addr,size_t size,bool is_anon)\nname|void\nname|k_mem_unmap_impl\nparameter_list|(\nname|void\nmodifier|*\nname|addr\nparameter_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/**  * Map memory into virtual address space with guard pages.  *  * This maps memory into virtual address space with a preceding and  * a succeeding guard pages.  *  * @see k_mem_map() for additional information if called via that.  *  * @see k_mem_phys_map() for additional information if called via that.  *  * @param phys Physical address base of the memory region if not requesting  *             anonymous memory. Must be page-aligned.  * @param size Size of the memory mapping. This must be page-aligned.  * @param flags K_MEM_PERM_*, K_MEM_MAP_* control flags.  * @param is_anon True is requesting mapping with anonymous memory.  *  * @return The mapped memory location, or NULL if insufficient virtual address  *         space, insufficient physical memory to establish the mapping,  *         or insufficient memory for paging structures.  */\n+comment|/**  * Map memory into virtual address space with guard pages.  *  * This maps memory into virtual address space with a preceding and  * a succeeding guard pages. The memory mapped via this function must be  * unmapped using k_mem_unmap_phys_guard().  *  * This function maps a contiguous physical memory region into kernel's  * virtual address space with a preceding and a succeeding guard pages.  * Given a physical address and a size, return a linear address representing  * the base of where the physical region is mapped in the virtual address  * space for the Zephyr kernel.  *  * This function alters the active page tables in the area reserved  * for the kernel. This function will choose the virtual address  * and return it to the caller.  *  * If user thread access control needs to be managed in any way, do not enable  * K_MEM_PERM_USER flags here; instead manage the region's permissions  * with memory domain APIs after the mapping has been established. Setting  * K_MEM_PERM_USER here will allow all user threads to access this memory  * which is usually undesirable.  *  * Unless K_MEM_MAP_UNINIT is used, the returned memory will be zeroed.  *  * The returned virtual memory pointer will be page-aligned. The size  * parameter, and any base address for re-mapping purposes must be page-  * aligned.  *  * Note that the allocation includes two guard pages immediately before  * and after the requested region. The total size of the allocation will be  * the requested size plus the size of these two guard pages.  *  * Many K_MEM_MAP_* flags have been implemented to alter the behavior of this  * function, with details in the documentation for these flags.  *  * @see k_mem_map() for additional information if called via that.  *  * @see k_mem_phys_map() for additional information if called via that.  *  * @param phys Physical address base of the memory region if not requesting  *             anonymous memory. Must be page-aligned.  * @param size Size of the memory mapping. This must be page-aligned.  * @param flags K_MEM_PERM_*, K_MEM_MAP_* control flags.  * @param is_anon True is requesting mapping with anonymous memory.  *  * @return The mapped memory location, or NULL if insufficient virtual address  *         space, insufficient physical memory to establish the mapping,  *         or insufficient memory for paging structures.  */\n-name|k_mem_map_impl\n+name|k_mem_map_phys_guard\n-comment|/**  * Un-map mapped memory  *  * This removes the memory mappings for the provided page-aligned region,  * and the two guard pages surrounding the region.  *  * @see k_mem_unmap() for additional information if called via that.  *  * @see k_mem_phys_unmap() for additional information if called via that.  *  * @note Calling this function on a region which was not mapped to begin  *       with is undefined behavior.  *  * @param addr Page-aligned memory region base virtual address  * @param size Page-aligned memory region size  * @param is_anon True if the mapped memory is from anonymous memory.  */\n+comment|/**  * Un-map memory mapped via k_mem_map_phys_guard().  *  * This removes the memory mappings for the provided page-aligned region,  * and the two guard pages surrounding the region.  *  * This function alters the active page tables in the area reserved  * for the kernel.  *  * @see k_mem_unmap() for additional information if called via that.  *  * @see k_mem_phys_unmap() for additional information if called via that.  *  * @note Calling this function on a region which was not mapped via  *       k_mem_map_phys_guard() to begin with is undefined behavior.  *  * @param addr Page-aligned memory region base virtual address  * @param size Page-aligned memory region size  * @param is_anon True if the mapped memory is from anonymous memory.  */\n-name|k_mem_unmap_impl\n+name|k_mem_unmap_phys_guard\n-name|k_mem_map_impl\n+name|k_mem_map_phys_guard\n-name|k_mem_map_impl\n+name|k_mem_map_phys_guard\n-name|k_mem_unmap_impl\n+name|k_mem_unmap_phys_guard\n-name|k_mem_unmap_impl\n+name|k_mem_unmap_phys_guard\n-DECL|function|k_mem_map_impl (uintptr_t phys,size_t size,uint32_t flags,bool is_anon)\n+DECL|function|k_mem_map_phys_guard (uintptr_t phys,size_t size,uint32_t flags,bool is_anon)\n-name|k_mem_map_impl\n+name|k_mem_map_phys_guard\n-DECL|function|k_mem_unmap_impl (void * addr,size_t size,bool is_anon)\n+DECL|function|k_mem_unmap_phys_guard (void * addr,size_t size,bool is_anon)\n-name|k_mem_unmap_impl\n+name|k_mem_unmap_phys_guard\nThe issue was with: kernel: mm: rename k_mem_un/map_impl to k_mem_*_phys_guard\n\nThe internal functions k_mem_map_impl() and k_mem_unmap_impl()\nare renamed to k_mem_map_phys_guard() and\nk_mem_unmap_phys_guard() respectively to better clarify\ntheir usage."
},{
  "instruction": "There is an issue in the following code. It relates to kernel/init: use zephyr's stack size macro for main/idle thread creation\n\nAs their stacks are defined by zephyr's kernel/thread stack definition\nmacro, better use zephyr's kernel/thread stack size macro for their stack\nsize, ensuring consistency and preventing potenial issues related to stack\nsize misconfiguration. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|z_idle_stacks\nindex|[\nname|i\nindex|]\ndecl_stmt|;\nifdef|#\ndirective|ifdef\nname|CONFIG_THREAD_NAME\nif|#\ndirective|if\nargument_list|(\nname|thread\nargument_list|,\nname|stack\nargument_list|,\nname|CONFIG_IDLE_STACK_SIZE\nargument_list|,\nname|idle\nargument_list|,\noperator|&\nname|_kernel\noperator|&\nname|z_main_thread\nargument_list|,\nname|z_main_stack\nargument_list|,\nname|CONFIG_MAIN_STACK_SIZE\nargument_list|,\nname|bg_thread_main\nargument_list|,\nname|NULL\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|size_t\n+name|stack_size\n+init|=\n+name|K_KERNEL_STACK_SIZEOF\n+argument_list|(\n+name|z_idle_stacks\n+index|[\n+name|i\n+index|]\n+argument_list|)\n+decl_stmt|;\n-name|CONFIG_IDLE_STACK_SIZE\n+name|stack_size\n-name|CONFIG_MAIN_STACK_SIZE\n+name|K_THREAD_STACK_SIZEOF\n+argument_list|(\n+name|z_main_stack\n+argument_list|)\nThe issue was with: kernel/init: use zephyr's stack size macro for main/idle thread creation\n\nAs their stacks are defined by zephyr's kernel/thread stack definition\nmacro, better use zephyr's kernel/thread stack size macro for their stack\nsize, ensuring consistency and preventing potenial issues related to stack\nsize misconfiguration."
},{
  "instruction": "There is an issue in the following code. It relates to arch: arm: cortex_m: update inline comment pointing to isr_wrapper.*\n\nisr_wrapper has been converted to C but this inline comment was not\nupdated. This fixes the out-of-sync comment. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|elif\nname|defined\nargument_list|(\nname|CONFIG_ARMV7_M_ARMV8_M_MAINLINE\nargument_list|)\ncomment|/* Lock all interrupts. irq_lock() will on this CPU only disable those \t * lower than BASEPRI, which is not what we want. See comments in \t * arch/arm/core/isr_wrapper.S \t */\nasm|__asm__\nspecifier|volatile\nasm|(\"cpsid i\" : : : \"memory\");\nelse|#\ndirective|else",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* Lock all interrupts. irq_lock() will on this CPU only disable those \t * lower than BASEPRI, which is not what we want. See comments in \t * arch/arm/core/isr_wrapper.S \t */\n+comment|/* Lock all interrupts. irq_lock() will on this CPU only disable those \t * lower than BASEPRI, which is not what we want. See comments in \t * arch/arm/core/cortex_m/isr_wrapper.c \t */\nThe issue was with: arch: arm: cortex_m: update inline comment pointing to isr_wrapper.*\n\nisr_wrapper has been converted to C but this inline comment was not\nupdated. This fixes the out-of-sync comment."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: nxp_enet: Support RW6XX series\n\nSupport RW6xx series in NXP ENET driver. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|ETH_NXP_ENET_UNIQUE_ID\nvalue|(SIM->UIDH ^ SIM->UIDMH ^ SIM->UIDML ^ SIM->UIDL)\nend_define\n\nbegin_else\nelse|#\ndirective|else\nend_else\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_elif\n+elif|#\n+directive|elif\n+name|defined\n+argument_list|(\n+name|CONFIG_SOC_SERIES_RW6XX\n+argument_list|)\n+end_elif\n+\n+begin_define\n+DECL|macro|ETH_NXP_ENET_UNIQUE_ID\n+define|#\n+directive|define\n+name|ETH_NXP_ENET_UNIQUE_ID\n+value|(OCOTP->OTP_SHADOW[46])\n+end_define\n+\nThe issue was with: drivers: nxp_enet: Support RW6XX series\n\nSupport RW6xx series in NXP ENET driver."
},{
  "instruction": "There is an issue in the following code. It relates to sensor: fix fallthrough on sample_channel_get on AQI\n\nfixed fallthrough on getting channel AQI value from ENS160 Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|val2\noperator|=\nliteral|0\nexpr_stmt|;\ndefault|default:\nreturn|return\noperator|-\nname|ENOTSUP\nreturn|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+break|break;\nThe issue was with: sensor: fix fallthrough on sample_channel_get on AQI\n\nfixed fallthrough on getting channel AQI value from ENS160"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: display: make driver API structs const\n\nSave precious RAM by making sure driver API structs are declared as\nconst Please fix this issue.",
  "input": "Faulty tokenized code:\nend_endif\n\nbegin_decl_stmt\nDECL|variable|display_smartbond_driver_api\nspecifier|static\nname|struct\nname|display_driver_api\nname|display_smartbond_driver_api\ninit|=\nblock|{\nend_decl_stmt\n\nbegin_decl_stmt\nDECL|variable|ls0xx_driver_api\nspecifier|static\nname|struct\nname|display_driver_api\nname|ls0xx_driver_api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|ssd1306_driver_api\nspecifier|static\nname|struct\nname|display_driver_api\nname|ssd1306_driver_api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|ssd16xx_driver_api\nspecifier|static\nname|struct\nname|display_driver_api\nname|ssd16xx_driver_api\ninit|=\nblock|{\nend_endif\n\nbegin_decl_stmt\nDECL|variable|uc81xx_driver_api\nspecifier|static\nname|struct\nname|display_driver_api\nname|uc81xx_driver_api\ninit|=\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\nThe issue was with: drivers: display: make driver API structs const\n\nSave precious RAM by making sure driver API structs are declared as\nconst"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Audio: CAP broadcast reception start bugfix\n\nWhen validating the parameters for broadcast reception start some\nreturn statements were missing, they have been added, as well as\nproper initialisation of a variable Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|broadcast_id\nexpr_stmt|;\nname|add_src_param\noperator|->\nname|pa_interval\noperator|=\nname|start_param\noperator|->\nname|pa_interval\nexpr_stmt|;\nreturn|return\nname|false\nreturn|;\nblock|}\nfor|for\ncontrol|(\nname|size_t\nname|j\ninit|=\nname|param_subgroups\noperator|->\nname|bis_sync\nargument_list|)\nexpr_stmt|;\nblock|}\nname|CHECKIF\nargument_list|(\nargument|(total_bis_sync& param_subgroups->bis_sync) !=\nliteral|0\nname|bis_sync\nargument_list|,\nname|total_bis_sync\nargument_list|)\nexpr_stmt|;\nblock|}\nname|total_bis_sync\noperator||=\nname|param_subgroups\noperator|->\nliteral|0\ncondition|)\nblock|{\nname|LOG_DBG\nargument_list|(\nliteral|\"Failed to register VCP callbacks\"\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|ENOEXEC",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|pa_sync\n+operator|=\n+name|true\n+expr_stmt|;\n+name|add_src_param\n+operator|->\n+name|total_bis_sync\n+operator|=\n+literal|0U\n+expr_stmt|;\n+return|return\n+name|false\n+return|;\n+return|return\n+name|false\n+return|;\n-literal|\"Failed to register VCP callbacks\"\n+literal|\"Failed to register broadcast assistant callbacks\"\nThe issue was with: Bluetooth: Audio: CAP broadcast reception start bugfix\n\nWhen validating the parameters for broadcast reception start some\nreturn statements were missing, they have been added, as well as\nproper initialisation of a variable"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: BAP: Fix missing len increment when merging non-LC3 data\n\nIf we are merging subgroup and BIS codec configuration data\nfor a codec other than LC3, then we just append them, but\ndid not properly update the length. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|bis\noperator|->\nname|data_len\nargument_list|)\nexpr_stmt|;\nblock|}\nendif|#\ndirective|endif\ncomment|/* CONFIG_BT_AUDIO_CODEC_CFG_MAX_DATA_SIZE> 0 */\nname|data",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|sink_bis\n+operator|->\n+name|codec_cfg\n+operator|.\n+name|data_len\n+operator|+=\n+name|bis\n+operator|->\n+name|data_len\n+expr_stmt|;\nThe issue was with: Bluetooth: BAP: Fix missing len increment when merging non-LC3 data\n\nIf we are merging subgroup and BIS codec configuration data\nfor a codec other than LC3, then we just append them, but\ndid not properly update the length."
},{
  "instruction": "There is an issue in the following code. It relates to intel_adsp: Fix data cache flush before D3\n\nFix sys_cache_data_flush_range() calls during D3 entrance. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|=\nname|global_imr_ram_storage\nexpr_stmt|;\nname|sys_cache_data_flush_range\nargument_list|(\nname|imr_layout\nargument_list|,\nsizeof|sizeof\nargument_list|(\noperator|*\noperator|)\nname|rom_entry\nexpr_stmt|;\nname|sys_cache_data_flush_range\nargument_list|(\nname|imr_layout\nargument_list|,\nsizeof|sizeof\nargument_list|(\noperator|*",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+name|void\n+operator|*\n+operator|)\n+operator|(\n+name|void\n+operator|*\n+operator|)\nThe issue was with: intel_adsp: Fix data cache flush before D3\n\nFix sys_cache_data_flush_range() calls during D3 entrance."
},{
  "instruction": "There is an issue in the following code. It relates to driver: ram_console: leave one byte from the defined buffer size\n\nLeave one byte from the CONFIG_RAM_CONSOLE_BUFFER_SIZE to ensure\nthe NULL-termination. Please fix this issue.",
  "input": "Faulty tokenized code:\nconfig RAM_CONSOLE_BUFFER_SIZE\n\tint \"Ram Console buffer size\"\n\tdefault 1024\n\tdepends on RAM_CONSOLE\n\thelp\n\t  Size of the RAM console buffer. Messages will wrap around if the\n\t  length is exceeded.\n\nconfig RTT_CONSOLE\n\tbool \"Use RTT console\"\n\tdepends on USE_SEGGER_RTT\n\tselect CONSOLE_HAS_DRIVER\nparameter_list|)\nparameter_list|)\nfunction_decl|;\nend_function_decl\n\nbegin_comment\ncomment|/* Extra byte to ensure we're always NULL-terminated */\nend_comment\n\nbegin_decl_stmt\nDECL|variable|ram_console\nname|char\nname|ram_console\nindex|[\nname|CONFIG_RAM_CONSOLE_BUFFER_SIZE\noperator|+\nliteral|1\nindex|]\ndecl_stmt|;\nend_decl_stmt\n\nbegin_decl_stmt\noperator|(\nname|char\noperator|)\nname|character\nexpr_stmt|;\nname|pos\noperator|=\noperator|(\nname|pos\noperator|+\nliteral|1\noperator|)\noperator|%\nname|CONFIG_RAM_CONSOLE_BUFFER_SIZE\nexpr_stmt|;\nreturn|return\nname|character\nreturn|;\nblock|}\nname|uint32_t\noperator|)\nname|ram_console\nblock|,\nname|CONFIG_RAM_CONSOLE_BUFFER_SIZE\noperator|+\nliteral|1\nblock|,\nliteral|0\nblock|,\nliteral|\"Zephyr_log\"\nblock|, \t}",
  "result": "I corrected the issue in the code by changing the following tokens:\n-\t  Size of the RAM console buffer. Messages will wrap around if the\n-\t  length is exceeded.\n+\t  Total size of the RAM console buffer, to ensure it's always\n+\t  NULL-terminated leave one byte unused, the actual length is\n+\t  one byte less. Messages will wrap around if the actual length\n+\t  is exceeded.\n-begin_comment\n-comment|/* Extra byte to ensure we're always NULL-terminated */\n-end_comment\n-\n-operator|+\n-literal|1\n+comment|/* Leave one byte to ensure we're always NULL-terminated */\n+operator|(\n+operator|-\n+literal|1\n+operator|)\n-operator|+\n-literal|1\nThe issue was with: driver: ram_console: leave one byte from the defined buffer size\n\nLeave one byte from the CONFIG_RAM_CONSOLE_BUFFER_SIZE to ensure\nthe NULL-termination."
},{
  "instruction": "There is an issue in the following code. It relates to lib: smf: fix ctx->executing in smf_execute_all_entry_actions\n\nFix ctx->executing is not updated in smf_execute_all_entry_actions() Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|to_execute\nargument_list|)\ncontrol|)\nblock|{\ncomment|/* Execute every entry action EXCEPT that of the topmost state */\nif|if\ncondition|(\nname|to_execute\noperator|->\nname|entry\ncondition|)\nblock|{\ncomment|/* Keep track of the executing entry action in case it calls \t\t\t * smf_set_State() \t\t\t */\nname|ctx\noperator|->\nname|executing\noperator|=\nname|to_execute\nexpr_stmt|;\nname|to_execute\noperator|->\nname|entry\nargument_list|(\nname|ctx\nreturn|;\nblock|}\nblock|}\nblock|}\ncomment|/* and execute the new state entry action */\nif|if\ncondition|(\nname|new_state\noperator|->\nname|entry",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Keep track of the executing entry action in case it calls \t\t * smf_set_state() \t\t */\n+name|ctx\n+operator|->\n+name|executing\n+operator|=\n+name|to_execute\n+expr_stmt|;\n-comment|/* Keep track of the executing entry action in case it calls \t\t\t * smf_set_State() \t\t\t */\n-name|ctx\n-operator|->\n-name|executing\n-operator|=\n-name|to_execute\n-expr_stmt|;\n+name|ctx\n+operator|->\n+name|executing\n+operator|=\n+name|new_state\n+expr_stmt|;\nThe issue was with: lib: smf: fix ctx->executing in smf_execute_all_entry_actions\n\nFix ctx->executing is not updated in smf_execute_all_entry_actions()"
},{
  "instruction": "There is an issue in the following code. It relates to lib: smf: add NULL check in smf_execute_all_exit_actions\n\nLike in smf_execute_all_entry_actions(), add NULL check\nin smf_execute_all_exit_actions(). Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|current\ninit|;\nname|to_execute\noperator|!=\nname|topmost\ncondition|;\nname|to_execute\noperator|=\nname|to_execute",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|NULL\n+operator|&&\n+name|to_execute\n+operator|!=\nThe issue was with: lib: smf: add NULL check in smf_execute_all_exit_actions\n\nLike in smf_execute_all_entry_actions(), add NULL check\nin smf_execute_all_exit_actions()."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: spi: gecko: Add support for devices with a single USART\n\nThis commit adds support for devices such as EFR32xG24 in the SPI\ndriver, as these devices only have a single USART peripheral. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_if\nif|#\ndirective|if\noperator|(\nname|USART_COUNT\noperator|<=\nliteral|2\noperator|)\nend_if\n\nbegin_define\nDECL|macro|CLOCK_USART (ref)\ndefine|#\ndirective|define\nname|CLOCK_USART",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|<=\n-literal|2\n+operator|==\n+literal|1\n+begin_define\n+DECL|macro|CLOCK_USART (ref)\n+define|#\n+directive|define\n+name|CLOCK_USART\n+parameter_list|(\n+name|ref\n+parameter_list|)\n+value|(((ref) == USART0) ? cmuClock_USART0 \\ \t\t\t       : -1)\n+end_define\n+\n+begin_elif\n+elif|#\n+directive|elif\n+operator|(\n+name|USART_COUNT\n+operator|==\n+literal|2\n+operator|)\n+end_elif\n+\nThe issue was with: drivers: spi: gecko: Add support for devices with a single USART\n\nThis commit adds support for devices such as EFR32xG24 in the SPI\ndriver, as these devices only have a single USART peripheral."
},{
  "instruction": "There is an issue in the following code. It relates to soc: psoc6: fix build error when CONFIG_UART_INTERRUPT_DRIVEN\n\nFix build error when CONFIG_UART_INTERRUPT_DRIVEN is enabled\nsee details: issues/74004 Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/drivers/pinctrl.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|\"cy_syslib.h\"\nend_include\nname|CY_PSOC6_UART_INIT\nparameter_list|(\nname|n\nparameter_list|)\ndefine|\\\nvalue|PINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t        \\ \tstatic const struct cypress_psoc6_config cy_psoc6_uart##n##_config = {\t\\ \t\t.base = (CySCB_Type *)DT_INST_REG_ADDR(n),\t\t\t\\ \t\t.periph_id = DT_INST_PROP(n, peripheral_id),\t\t\t\\ \t\t.pcfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \t\tCY_PSOC6_UART_IRQ_SET_FUNC(n)\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n,&uart_psoc6_init, NULL,\t\t\t\\ \t\t\t      CY_PSOC6_UART_DECL_DATA_PTR(n),\t\t\t\\&cy_psoc6_uart##n##_config, PRE_KERNEL_1,\t\t\\ \t\t\t      CONFIG_SERIAL_INIT_PRIORITY,\t\t\t\\&uart_psoc6_driver_api);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<soc.h>\n+end_include\n+\n-value|PINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t        \\ \tstatic const struct cypress_psoc6_config cy_psoc6_uart##n##_config = {\t\\ \t\t.base = (CySCB_Type *)DT_INST_REG_ADDR(n),\t\t\t\\ \t\t.periph_id = DT_INST_PROP(n, peripheral_id),\t\t\t\\ \t\t.pcfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \t\tCY_PSOC6_UART_IRQ_SET_FUNC(n)\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n,&uart_psoc6_init, NULL,\t\t\t\\ \t\t\t      CY_PSOC6_UART_DECL_DATA_PTR(n),\t\t\t\\&cy_psoc6_uart##n##_config, PRE_KERNEL_1,\t\t\\ \t\t\t      CONFIG_SERIAL_INIT_PRIORITY,\t\t\t\\&uart_psoc6_driver_api);\n+value|PINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t        \\ \tCY_PSOC6_UART_DECL_DATA(n)\t\t\t\t\t\t\\ \tCY_PSOC6_UART_IRQ_FUNC(n)\t\t\t\t\t\t\\ \tstatic const struct cypress_psoc6_config cy_psoc6_uart##n##_config = {\t\\ \t\t.base = (CySCB_Type *)DT_INST_REG_ADDR(n),\t\t\t\\ \t\t.periph_id = DT_INST_PROP(n, peripheral_id),\t\t\t\\ \t\t.pcfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \t\tCY_PSOC6_UART_IRQ_SET_FUNC(n)\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n,&uart_psoc6_init, NULL,\t\t\t\\ \t\t\t      CY_PSOC6_UART_DECL_DATA_PTR(n),\t\t\t\\&cy_psoc6_uart##n##_config, PRE_KERNEL_1,\t\t\\ \t\t\t      CONFIG_SERIAL_INIT_PRIORITY,\t\t\t\\&uart_psoc6_driver_api);\nThe issue was with: soc: psoc6: fix build error when CONFIG_UART_INTERRUPT_DRIVEN\n\nFix build error when CONFIG_UART_INTERRUPT_DRIVEN is enabled\nsee details: issues/74004"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: gnss: make `gnss_xxx_config` and `gnss_driver_api` as `const`\n\nThis change marks each instance of the `gnss_xxx_config` and\n`gnss_driver_api` as `const`.\n\nBy using `const`, we ensure immutability, leading to usage of only\n`.rodata` and a reduction in the `.data` area. Please fix this issue.",
  "input": "Faulty tokenized code:\nend_function\n\nbegin_decl_stmt\nDECL|variable|api\nspecifier|static\nname|struct\nname|gnss_driver_api\nname|api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|gnss_api\nspecifier|static\nname|struct\nname|gnss_driver_api\nname|gnss_api\ninit|=\nblock|{\nname|LUATOS_AIR530Z\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|static struct gnss_luatos_air530z_config gnss_luatos_air530z_cfg_##inst = {\t\\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),\t\t\t\t\\ \t\t.on_off_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, on_off_gpios, { 0 }),\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct gnss_luatos_air530z_data gnss_luatos_air530z_data_##inst = {\t\\ \t\t.chat_delimiter = {'\\r', '\\n'},\t\t\t\t\t\t\\ \t\t.dynamic_separators_buf = {',', '*'},\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(inst, luatos_air530z_pm_action);\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst, gnss_luatos_air530z_init,\t\t\t\t\\ \t\tPM_DEVICE_DT_INST_GET(inst),\t\t\t\t\t\t\\&gnss_luatos_air530z_data_##inst,\t\t\t\t\t\\&gnss_luatos_air530z_cfg_##inst,\t\t\t\t\t\t\\ \t\tPOST_KERNEL, CONFIG_GNSS_INIT_PRIORITY,&gnss_api);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(\nend_function\n\nbegin_decl_stmt\nDECL|variable|gnss_api\nspecifier|static\nname|struct\nname|gnss_driver_api\nname|gnss_api\ninit|=\nblock|{ }\nname|GNSS_NMEA_GENERIC\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|static struct gnss_nmea_generic_config gnss_nmea_generic_cfg_##inst = {\t\t\\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),\t\t\t\t\\ \t\t.init_chat_script =&_CONCAT(DT_DRV_COMPAT, _init_chat_script),         \\ \t};\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct gnss_nmea_generic_data gnss_nmea_generic_data_##inst;\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(inst, gnss_nmea_generic_pm_action);                    \\                                                                                         \\ \tDEVICE_DT_INST_DEFINE(inst, gnss_nmea_generic_init, PM_DEVICE_DT_INST_GET(inst),\\&gnss_nmea_generic_data_##inst,\t\t\t\t\\&gnss_nmea_generic_cfg_##inst,\t\t\t\t\\ \t\t\t      POST_KERNEL, CONFIG_GNSS_INIT_PRIORITY,&gnss_api);\nend_define\n\nbegin_define\nDECL|macro|DT_DRV_COMPAT\ndefine|#\nname|struct\nname|modem_chat_script\nname|pair_script\ndecl_stmt|;\ncomment|/* Allocation for responses from GNSS modem */\nDECL|union|__anon2bd17edd010a\nunion|union\nblock|{\nDECL|member|fix_rate_response\nname|uint16_t\nname|fix_rate_response\nend_function\n\nbegin_decl_stmt\nDECL|variable|gnss_api\nspecifier|static\nname|struct\nname|gnss_driver_api\nname|gnss_api\ninit|=\nblock|{\nname|LCX6G_DEVICE\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|static struct quectel_lcx6g_config LCX6G_INST_NAME(inst, config) = {\t\t\\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),\t\t\t\t\\ \t\t.pps_mode = DT_INST_STRING_UPPER_TOKEN(inst, pps_mode),\t\t\t\\ \t\t.pps_pulse_width = DT_INST_PROP(inst, pps_pulse_width),\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct quectel_lcx6g_data LCX6G_INST_NAME(inst, data) = {\t\t\\ \t\t.chat_delimiter = {'\\r', '\\n'},\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(inst, quectel_lcx6g_pm_action);\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst, quectel_lcx6g_init, PM_DEVICE_DT_INST_GET(inst),\t\\&LCX6G_INST_NAME(inst, data),&LCX6G_INST_NAME(inst, config),\t\\ \t\t\t POST_KERNEL, CONFIG_GNSS_INIT_PRIORITY,&gnss_api);\nend_define\n\nbegin_define\nDECL|macro|DT_DRV_COMPAT\ndefine|#\nend_function\n\nbegin_decl_stmt\nDECL|variable|gnss_api\nspecifier|static\nname|struct\nname|gnss_driver_api\nname|gnss_api\ninit|=\nblock|{\nname|UBX_M10\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|static struct ubx_m10_config ubx_m10_cfg_##inst = {\t\t\t\t\t\\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),\t\t\t\t\t\\ \t\t.uart_baudrate = DT_PROP(DT_DRV_INST(inst), uart_baudrate),\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct ubx_m10_data ubx_m10_data_##inst = {\t\t\t\t\t\\ \t\t.script.request = (struct ubx_frame *)ubx_m10_data_##inst.request_buf,\t\t\\ \t\t.script.response = (struct ubx_frame *)ubx_m10_data_##inst.response_buf,\t\\ \t\t.script.match = (struct ubx_frame *)ubx_m10_data_##inst.match_buf,\t\t\\ \t\t.script.retry_count = UBX_M10_SCRIPT_RETRY_DEFAULT,\t\t\t\t\\ \t\t.script.timeout = K_MSEC(MODEM_UBX_SCRIPT_TIMEOUT_MS),\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst,\t\t\t\t\t\t\t\t\\ \t\t\t      ubx_m10_init,\t\t\t\t\t\t\t\\ \t\t\t      NULL,\t\t\t\t\t\t\t\t\\&ubx_m10_data_##inst,\t\t\t\t\t\t\\&ubx_m10_cfg_##inst,\t\t\t\t\t\t\\ \t\t\t      POST_KERNEL,\t\t\t\t\t\t\t\\ \t\t\t      CONFIG_GNSS_INIT_PRIORITY,\t\t\t\t\t\\&gnss_api);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+specifier|const\n+specifier|const\n-value|static struct gnss_luatos_air530z_config gnss_luatos_air530z_cfg_##inst = {\t\\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),\t\t\t\t\\ \t\t.on_off_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, on_off_gpios, { 0 }),\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct gnss_luatos_air530z_data gnss_luatos_air530z_data_##inst = {\t\\ \t\t.chat_delimiter = {'\\r', '\\n'},\t\t\t\t\t\t\\ \t\t.dynamic_separators_buf = {',', '*'},\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(inst, luatos_air530z_pm_action);\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst, gnss_luatos_air530z_init,\t\t\t\t\\ \t\tPM_DEVICE_DT_INST_GET(inst),\t\t\t\t\t\t\\&gnss_luatos_air530z_data_##inst,\t\t\t\t\t\\&gnss_luatos_air530z_cfg_##inst,\t\t\t\t\t\t\\ \t\tPOST_KERNEL, CONFIG_GNSS_INIT_PRIORITY,&gnss_api);\n+value|static const struct gnss_luatos_air530z_config gnss_luatos_air530z_cfg_##inst = {\t\\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),\t\t\t\t\t\\ \t\t.on_off_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, on_off_gpios, { 0 }),\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct gnss_luatos_air530z_data gnss_luatos_air530z_data_##inst = {\t\t\\ \t\t.chat_delimiter = {'\\r', '\\n'},\t\t\t\t\t\t\t\\ \t\t.dynamic_separators_buf = {',', '*'},\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(inst, luatos_air530z_pm_action);\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst, gnss_luatos_air530z_init,\t\t\t\t\t\\ \t\tPM_DEVICE_DT_INST_GET(inst),\t\t\t\t\t\t\t\\&gnss_luatos_air530z_data_##inst,\t\t\t\t\t\t\\&gnss_luatos_air530z_cfg_##inst,\t\t\t\t\t\t\\ \t\tPOST_KERNEL, CONFIG_GNSS_INIT_PRIORITY,&gnss_api);\n+specifier|const\n-value|static struct gnss_nmea_generic_config gnss_nmea_generic_cfg_##inst = {\t\t\\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),\t\t\t\t\\ \t\t.init_chat_script =&_CONCAT(DT_DRV_COMPAT, _init_chat_script),         \\ \t};\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct gnss_nmea_generic_data gnss_nmea_generic_data_##inst;\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(inst, gnss_nmea_generic_pm_action);                    \\                                                                                         \\ \tDEVICE_DT_INST_DEFINE(inst, gnss_nmea_generic_init, PM_DEVICE_DT_INST_GET(inst),\\&gnss_nmea_generic_data_##inst,\t\t\t\t\\&gnss_nmea_generic_cfg_##inst,\t\t\t\t\\ \t\t\t      POST_KERNEL, CONFIG_GNSS_INIT_PRIORITY,&gnss_api);\n+value|static const struct gnss_nmea_generic_config gnss_nmea_generic_cfg_##inst = {\t\\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),\t\t\t\t\\ \t\t.init_chat_script =&_CONCAT(DT_DRV_COMPAT, _init_chat_script),         \\ \t};\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct gnss_nmea_generic_data gnss_nmea_generic_data_##inst;\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(inst, gnss_nmea_generic_pm_action);                    \\                                                                                         \\ \tDEVICE_DT_INST_DEFINE(inst, gnss_nmea_generic_init, PM_DEVICE_DT_INST_GET(inst),\\&gnss_nmea_generic_data_##inst,\t\t\t\t\\&gnss_nmea_generic_cfg_##inst,\t\t\t\t\\ \t\t\t      POST_KERNEL, CONFIG_GNSS_INIT_PRIORITY,&gnss_api);\n-DECL|union|__anon2bd17edd010a\n+DECL|union|__anon27797403010a\n+specifier|const\n-value|static struct quectel_lcx6g_config LCX6G_INST_NAME(inst, config) = {\t\t\\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),\t\t\t\t\\ \t\t.pps_mode = DT_INST_STRING_UPPER_TOKEN(inst, pps_mode),\t\t\t\\ \t\t.pps_pulse_width = DT_INST_PROP(inst, pps_pulse_width),\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct quectel_lcx6g_data LCX6G_INST_NAME(inst, data) = {\t\t\\ \t\t.chat_delimiter = {'\\r', '\\n'},\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(inst, quectel_lcx6g_pm_action);\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst, quectel_lcx6g_init, PM_DEVICE_DT_INST_GET(inst),\t\\&LCX6G_INST_NAME(inst, data),&LCX6G_INST_NAME(inst, config),\t\\ \t\t\t POST_KERNEL, CONFIG_GNSS_INIT_PRIORITY,&gnss_api);\n+value|static const struct quectel_lcx6g_config LCX6G_INST_NAME(inst, config) = {\t\\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),\t\t\t\t\\ \t\t.pps_mode = DT_INST_STRING_UPPER_TOKEN(inst, pps_mode),\t\t\t\\ \t\t.pps_pulse_width = DT_INST_PROP(inst, pps_pulse_width),\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct quectel_lcx6g_data LCX6G_INST_NAME(inst, data) = {\t\t\\ \t\t.chat_delimiter = {'\\r', '\\n'},\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(inst, quectel_lcx6g_pm_action);\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst, quectel_lcx6g_init, PM_DEVICE_DT_INST_GET(inst),\t\\&LCX6G_INST_NAME(inst, data),&LCX6G_INST_NAME(inst, config),\t\\ \t\t\t POST_KERNEL, CONFIG_GNSS_INIT_PRIORITY,&gnss_api);\n+specifier|const\n-value|static struct ubx_m10_config ubx_m10_cfg_##inst = {\t\t\t\t\t\\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),\t\t\t\t\t\\ \t\t.uart_baudrate = DT_PROP(DT_DRV_INST(inst), uart_baudrate),\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct ubx_m10_data ubx_m10_data_##inst = {\t\t\t\t\t\\ \t\t.script.request = (struct ubx_frame *)ubx_m10_data_##inst.request_buf,\t\t\\ \t\t.script.response = (struct ubx_frame *)ubx_m10_data_##inst.response_buf,\t\\ \t\t.script.match = (struct ubx_frame *)ubx_m10_data_##inst.match_buf,\t\t\\ \t\t.script.retry_count = UBX_M10_SCRIPT_RETRY_DEFAULT,\t\t\t\t\\ \t\t.script.timeout = K_MSEC(MODEM_UBX_SCRIPT_TIMEOUT_MS),\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst,\t\t\t\t\t\t\t\t\\ \t\t\t      ubx_m10_init,\t\t\t\t\t\t\t\\ \t\t\t      NULL,\t\t\t\t\t\t\t\t\\&ubx_m10_data_##inst,\t\t\t\t\t\t\\&ubx_m10_cfg_##inst,\t\t\t\t\t\t\\ \t\t\t      POST_KERNEL,\t\t\t\t\t\t\t\\ \t\t\t      CONFIG_GNSS_INIT_PRIORITY,\t\t\t\t\t\\&gnss_api);\n+value|static const struct ubx_m10_config ubx_m10_cfg_##inst = {\t\t\t\t\\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),\t\t\t\t\t\\ \t\t.uart_baudrate = DT_PROP(DT_DRV_INST(inst), uart_baudrate),\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct ubx_m10_data ubx_m10_data_##inst = {\t\t\t\t\t\\ \t\t.script.request = (struct ubx_frame *)ubx_m10_data_##inst.request_buf,\t\t\\ \t\t.script.response = (struct ubx_frame *)ubx_m10_data_##inst.response_buf,\t\\ \t\t.script.match = (struct ubx_frame *)ubx_m10_data_##inst.match_buf,\t\t\\ \t\t.script.retry_count = UBX_M10_SCRIPT_RETRY_DEFAULT,\t\t\t\t\\ \t\t.script.timeout = K_MSEC(MODEM_UBX_SCRIPT_TIMEOUT_MS),\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst,\t\t\t\t\t\t\t\t\\ \t\t\t      ubx_m10_init,\t\t\t\t\t\t\t\\ \t\t\t      NULL,\t\t\t\t\t\t\t\t\\&ubx_m10_data_##inst,\t\t\t\t\t\t\\&ubx_m10_cfg_##inst,\t\t\t\t\t\t\\ \t\t\t      POST_KERNEL,\t\t\t\t\t\t\t\\ \t\t\t      CONFIG_GNSS_INIT_PRIORITY,\t\t\t\t\t\\&gnss_api);\nThe issue was with: drivers: gnss: make `gnss_xxx_config` and `gnss_driver_api` as `const`\n\nThis change marks each instance of the `gnss_xxx_config` and\n`gnss_driver_api` as `const`.\n\nBy using `const`, we ensure immutability, leading to usage of only\n`.rodata` and a reduction in the `.data` area."
},{
  "instruction": "There is an issue in the following code. It relates to usb: device: allow uneven SN to be obtained from HWINFO\n\nIf the length of the string literal reserved for the serial number\ndescriptor is odd, the string is not used because its length is always\neven and therefore one character longer. Fix this by using the shortest\nlength for the copy. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|runtime_sn_len\noperator|!=\nname|default_sn_len\ncondition|)\nblock|{\nname|LOG_ERR\nargument_list|(\nliteral|\"the new SN descriptor doesn't have the same \"\nliteral|\"length as CONFIG_USB_DEVICE_SN\"\nargument_list|)\nexpr_stmt|;\nreturn|return;\nblock|}\nname|memcpy\nargument_list|(\nname|sn\noperator|->\nname|bString\nargument_list|,\nname|runtime_sn\nargument_list|,\nname|runtime_sn_len\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|LOG_ERR\n+name|LOG_WRN\n-return|return;\n+name|MIN\n+argument_list|(\n+argument_list|,\n+name|default_sn_len\n+argument_list|)\nThe issue was with: usb: device: allow uneven SN to be obtained from HWINFO\n\nIf the length of the string literal reserved for the serial number\ndescriptor is odd, the string is not used because its length is always\neven and therefore one character longer. Fix this by using the shortest\nlength for the copy."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: udc_dwc2: Allocate at least 8 bytes for control OUT\n\nMake sure to feed control OUT endpoint with at least 8 bytes buffer to\nmake it possible to always receive SETUP data. This solves the assertion\nfailure in net_buf_add() called inside dwc2_handle_evt_setup() when a\nhost decides to start new control transfer immediately after it has\nissued control transfer with Data Stage from host to device with wLength\nless than 8. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|\"s:%p|feed for -out-\"\nargument_list|,\nname|buf\nargument_list|)\nexpr_stmt|;\nname|err\noperator|=\nname|dwc2_ctrl_feed_dout\nargument_list|(\nname|dev\nargument_list|,\nname|udc_data_stage_length\nargument_list|(\nname|buf\nargument_list|)\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|err",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Allocate at least 8 bytes in case the host decides to send \t\t * SETUP DATA instead of OUT DATA packet. \t\t */\n+name|MAX\n+argument_list|(\n+argument_list|,\n+literal|8\n+argument_list|)\nThe issue was with: drivers: udc_dwc2: Allocate at least 8 bytes for control OUT\n\nMake sure to feed control OUT endpoint with at least 8 bytes buffer to\nmake it possible to always receive SETUP data. This solves the assertion\nfailure in net_buf_add() called inside dwc2_handle_evt_setup() when a\nhost decides to start new control transfer immediately after it has\nissued control transfer with Data Stage from host to device with wLength\nless than 8."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: Update Infineon CAT1 UART driver\n\nSet RTS/CTS flow control pins as NC in cyhal\nUART object so cyhal will skip to try initialize\nthose pins.\n\nInitialization of RTS/CTS is done via\nPINCNTRL driver. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|NULL\nargument_list|)\nexpr_stmt|;\nblock|}\ncomment|/* Enable RTS/CTS flow control */\nif|if\ncondition|(\noperator|(\nname|result",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Set RTS/CTS flow control pins as NC so cyhal will skip initialization */\n+name|data\n+operator|->\n+name|obj\n+operator|.\n+name|pin_cts\n+operator|=\n+name|NC\n+expr_stmt|;\n+name|data\n+operator|->\n+name|obj\n+operator|.\n+name|pin_rts\n+operator|=\n+name|NC\n+expr_stmt|;\nThe issue was with: drivers: serial: Update Infineon CAT1 UART driver\n\nSet RTS/CTS flow control pins as NC in cyhal\nUART object so cyhal will skip to try initialize\nthose pins.\n\nInitialization of RTS/CTS is done via\nPINCNTRL driver."
},{
  "instruction": "There is an issue in the following code. It relates to mbedtls: add psa_crypto_init() when Mbed TLS acts a PSA crypto client\n\nEnsure psa_crypto_init() is called during initialization when\nMbed TLS acts as a PSA crypto client. This will setup the PSA\ncrypto server for further calls. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|option\noperator|.\nexpr|\"\nend_expr\n\nunit|#endif  static unsigned char _mbedtls_heap[CONFIG_MBEDTLS_HEAP_SIZE];  static void init_heap(void) { \tmbedtls_memory_buffer_alloc_init(_mbedtls_heap, sizeof(_mbedtls_heap)); } #else #define init_heap(...) #endif /* CONFIG_MBEDTLS_ENABLE_HEAP&& MBEDTLS_MEMORY_BUFFER_ALLOC_C */  #if defined(CONFIG_MBEDTLS_ZEPHYR_ENTROPY) static const struct device *const entropy_dev = \t\t\tDEVICE_DT_GET_OR_NULL(DT_CHOSEN(zephyr_entropy));  int mbedtls_hardware_poll(void *data, unsigned char *output, size_t len, \t\t\t  size_t *olen) { \tint ret; \tuint16_t request_len = len> UINT16_MAX ? UINT16_MAX : len;  \tARG_UNUSED(data);  \tif (output == NULL || olen == NULL || len == 0) { \t\treturn MBEDTLS_ERR_ENTROPY_SOURCE_FAILED; \t}  \tif (!IS_ENABLED(CONFIG_ENTROPY_HAS_DRIVER)) { \t\tsys_rand_get(output, len); \t\t*olen = len;  \t\treturn 0; \t}  \tif (!device_is_ready(entropy_dev)) { \t\treturn MBEDTLS_ERR_ENTROPY_SOURCE_FAILED; \t}  \tret = entropy_get_entropy(entropy_dev, (uint8_t *)output, request_len); \tif (ret< 0) { \t\treturn MBEDTLS_ERR_ENTROPY_SOURCE_FAILED; \t}  \t*olen = request_len;  \treturn 0; } #endif /* CONFIG_MBEDTLS_ZEPHYR_ENTROPY */  static int _mbedtls_init(void) {  \tinit_heap();  #if defined(CONFIG_MBEDTLS_DEBUG_LEVEL) \tmbedtls_debug_set_threshold(CONFIG_MBEDTLS_DEBUG_LEVEL); #endif  \treturn 0; }  #if defined(CONFIG_MBEDTLS_INIT) SYS_INIT(_mbedtls_init, POST_KERNEL, 0); #endif  /* if CONFIG_MBEDTLS_INIT is not defined then this function  * should be called by the platform before any mbedtls functionality  * is used  */ int mbedtls_init(void) { \treturn _mbedtls_init(); }  /* TLS 1.3 ticket lifetime needs a timing interface */ mbedtls_ms_time_t mbedtls_ms_time(void) { \treturn (mbedtls_ms_time_t)k_uptime_get(); }  #if defined(CONFIG_MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG) /* MBEDTLS_PSA_CRYPTO_C requires a random generator to work and this can  * be achieved through either legacy MbedTLS modules  * (ENTROPY + CTR_DRBG/HMAC_DRBG) or provided externally by enabling the  * CONFIG_MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG. In the latter case the following  * callback functions needs to be defined.  */ psa_status_t mbedtls_psa_external_get_random( \tmbedtls_psa_external_random_context_t *context, \tuint8_t *output, size_t output_size, size_t *output_length) { \t(void) context;  \tif (sys_csrand_get(output, output_size) != 0) { \t\treturn PSA_ERROR_GENERIC_ERROR; \t}  \t*output_length = output_size;  \treturn PSA_SUCCESS; } #endif\nend_unit\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n-unit|#endif  static unsigned char _mbedtls_heap[CONFIG_MBEDTLS_HEAP_SIZE];  static void init_heap(void) { \tmbedtls_memory_buffer_alloc_init(_mbedtls_heap, sizeof(_mbedtls_heap)); } #else #define init_heap(...) #endif /* CONFIG_MBEDTLS_ENABLE_HEAP&& MBEDTLS_MEMORY_BUFFER_ALLOC_C */  #if defined(CONFIG_MBEDTLS_ZEPHYR_ENTROPY) static const struct device *const entropy_dev = \t\t\tDEVICE_DT_GET_OR_NULL(DT_CHOSEN(zephyr_entropy));  int mbedtls_hardware_poll(void *data, unsigned char *output, size_t len, \t\t\t  size_t *olen) { \tint ret; \tuint16_t request_len = len> UINT16_MAX ? UINT16_MAX : len;  \tARG_UNUSED(data);  \tif (output == NULL || olen == NULL || len == 0) { \t\treturn MBEDTLS_ERR_ENTROPY_SOURCE_FAILED; \t}  \tif (!IS_ENABLED(CONFIG_ENTROPY_HAS_DRIVER)) { \t\tsys_rand_get(output, len); \t\t*olen = len;  \t\treturn 0; \t}  \tif (!device_is_ready(entropy_dev)) { \t\treturn MBEDTLS_ERR_ENTROPY_SOURCE_FAILED; \t}  \tret = entropy_get_entropy(entropy_dev, (uint8_t *)output, request_len); \tif (ret< 0) { \t\treturn MBEDTLS_ERR_ENTROPY_SOURCE_FAILED; \t}  \t*olen = request_len;  \treturn 0; } #endif /* CONFIG_MBEDTLS_ZEPHYR_ENTROPY */  static int _mbedtls_init(void) {  \tinit_heap();  #if defined(CONFIG_MBEDTLS_DEBUG_LEVEL) \tmbedtls_debug_set_threshold(CONFIG_MBEDTLS_DEBUG_LEVEL); #endif  \treturn 0; }  #if defined(CONFIG_MBEDTLS_INIT) SYS_INIT(_mbedtls_init, POST_KERNEL, 0); #endif  /* if CONFIG_MBEDTLS_INIT is not defined then this function  * should be called by the platform before any mbedtls functionality  * is used  */ int mbedtls_init(void) { \treturn _mbedtls_init(); }  /* TLS 1.3 ticket lifetime needs a timing interface */ mbedtls_ms_time_t mbedtls_ms_time(void) { \treturn (mbedtls_ms_time_t)k_uptime_get(); }  #if defined(CONFIG_MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG) /* MBEDTLS_PSA_CRYPTO_C requires a random generator to work and this can  * be achieved through either legacy MbedTLS modules  * (ENTROPY + CTR_DRBG/HMAC_DRBG) or provided externally by enabling the  * CONFIG_MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG. In the latter case the following  * callback functions needs to be defined.  */ psa_status_t mbedtls_psa_external_get_random( \tmbedtls_psa_external_random_context_t *context, \tuint8_t *output, size_t output_size, size_t *output_length) { \t(void) context;  \tif (sys_csrand_get(output, output_size) != 0) { \t\treturn PSA_ERROR_GENERIC_ERROR; \t}  \t*output_length = output_size;  \treturn PSA_SUCCESS; } #endif\n+unit|#endif  static unsigned char _mbedtls_heap[CONFIG_MBEDTLS_HEAP_SIZE];  static void init_heap(void) { \tmbedtls_memory_buffer_alloc_init(_mbedtls_heap, sizeof(_mbedtls_heap)); } #else #define init_heap(...) #endif /* CONFIG_MBEDTLS_ENABLE_HEAP&& MBEDTLS_MEMORY_BUFFER_ALLOC_C */  #if defined(CONFIG_MBEDTLS_ZEPHYR_ENTROPY) static const struct device *const entropy_dev = \t\t\tDEVICE_DT_GET_OR_NULL(DT_CHOSEN(zephyr_entropy));  int mbedtls_hardware_poll(void *data, unsigned char *output, size_t len, \t\t\t  size_t *olen) { \tint ret; \tuint16_t request_len = len> UINT16_MAX ? UINT16_MAX : len;  \tARG_UNUSED(data);  \tif (output == NULL || olen == NULL || len == 0) { \t\treturn MBEDTLS_ERR_ENTROPY_SOURCE_FAILED; \t}  \tif (!IS_ENABLED(CONFIG_ENTROPY_HAS_DRIVER)) { \t\tsys_rand_get(output, len); \t\t*olen = len;  \t\treturn 0; \t}  \tif (!device_is_ready(entropy_dev)) { \t\treturn MBEDTLS_ERR_ENTROPY_SOURCE_FAILED; \t}  \tret = entropy_get_entropy(entropy_dev, (uint8_t *)output, request_len); \tif (ret< 0) { \t\treturn MBEDTLS_ERR_ENTROPY_SOURCE_FAILED; \t}  \t*olen = request_len;  \treturn 0; } #endif /* CONFIG_MBEDTLS_ZEPHYR_ENTROPY */  static int _mbedtls_init(void) {  \tinit_heap();  #if defined(CONFIG_MBEDTLS_DEBUG_LEVEL) \tmbedtls_debug_set_threshold(CONFIG_MBEDTLS_DEBUG_LEVEL); #endif  #if defined(CONFIG_MBEDTLS_PSA_CRYPTO_CLIENT) \tif (psa_crypto_init() != PSA_SUCCESS) { \t\treturn -EIO; \t} #endif  \treturn 0; }  #if defined(CONFIG_MBEDTLS_INIT) SYS_INIT(_mbedtls_init, POST_KERNEL, 0); #endif  /* if CONFIG_MBEDTLS_INIT is not defined then this function  * should be called by the platform before any mbedtls functionality  * is used  */ int mbedtls_init(void) { \treturn _mbedtls_init(); }  /* TLS 1.3 ticket lifetime needs a timing interface */ mbedtls_ms_time_t mbedtls_ms_time(void) { \treturn (mbedtls_ms_time_t)k_uptime_get(); }  #if defined(CONFIG_MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG) /* MBEDTLS_PSA_CRYPTO_C requires a random generator to work and this can  * be achieved through either legacy MbedTLS modules  * (ENTROPY + CTR_DRBG/HMAC_DRBG) or provided externally by enabling the  * CONFIG_MBEDTLS_PSA_CRYPTO_EXTERNAL_RNG. In the latter case the following  * callback functions needs to be defined.  */ psa_status_t mbedtls_psa_external_get_random( \tmbedtls_psa_external_random_context_t *context, \tuint8_t *output, size_t output_size, size_t *output_length) { \t(void) context;  \tif (sys_csrand_get(output, output_size) != 0) { \t\treturn PSA_ERROR_GENERIC_ERROR; \t}  \t*output_length = output_size;  \treturn PSA_SUCCESS; } #endif\nThe issue was with: mbedtls: add psa_crypto_init() when Mbed TLS acts a PSA crypto client\n\nEnsure psa_crypto_init() is called during initialization when\nMbed TLS acts as a PSA crypto client. This will setup the PSA\ncrypto server for further calls."
},{
  "instruction": "There is an issue in the following code. It relates to tests: poll: fix misconstructed k_poll_event test\n\nSince commit fcd92f55022b [formerly 0c23cf94a43b] (\\\"include/kernel: check type of object passed\nto K_POLL_EVENT_INITIALIZER\\\") it is no longer possible to use arbitrary\ntype literals with the initializer macro. Misconstructing a k_poll_event\ntype for test purpose must be done explicitly. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|EINVAL\nargument_list|,\nname|NULL\nargument_list|)\nexpr_stmt|;\nname|struct\nname|k_poll_event\nname|bad_events2\nindex|[]\ninit|=\nblock|{\nname|K_POLL_EVENT_INITIALIZER\nargument_list|(\nliteral|0xFU\nargument_list|,\nname|K_POLL_MODE_NOTIFY_ONLY\nargument_list|,\noperator|&\nname|no_wait_sem\nargument_list|)\nblock|, \t}\ndecl_stmt|;\nname|zassert_equal\nargument_list|(\nname|k_poll",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* can't use the initializer to misconstruct this */\n-name|K_POLL_EVENT_INITIALIZER\n-argument_list|(\n+block|{\n+operator|.\n+name|type\n+operator|=\n-argument_list|,\n+block|,\n+operator|.\n+name|state\n+operator|=\n+name|K_POLL_STATE_NOT_READY\n+block|,\n+operator|.\n+name|mode\n+operator|=\n-argument_list|,\n+block|,\n+operator|.\n+name|obj\n+operator|=\n-argument_list|)\n+block|, \t\t}\nThe issue was with: tests: poll: fix misconstructed k_poll_event test\n\nSince commit fcd92f55022b [formerly 0c23cf94a43b] (\\\"include/kernel: check type of object passed\nto K_POLL_EVENT_INITIALIZER\\\") it is no longer possible to use arbitrary\ntype literals with the initializer macro. Misconstructing a k_poll_event\ntype for test purpose must be done explicitly."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: tmag5273: fix documentation of tmag5273_check_device_status\n\nTypos and invalid doxygen documentation. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|;\nblock|}\nend_function\n\nbegin_comment\ncomment|/**  * @brief checks for DIAG_FAIL errors and reads out the DEVICE_STATUS register if necessary  *  * Prints a human readable representation to the log, if \\c CONFIG_LOG is activated.  *  * @param drv_cfg[in] driver instance configuration  * @param device_status[out] DEVICE_STATUS register if DIAG_FAIL is set  *  * @retval 0 on success  * @retval \"!= 0\" on error (see @ref i2c_reg_read_byte for error codes)  *  * @note  * If tmag5273_config.ignore_diag_fail is se  *   -  \\a device_status will be always set to \\c 0,  *   - the function always returns \\c 0.  */\nend_comment\n\nbegin_function\nDECL|function|tmag5273_check_device_status (const struct tmag5273_config * drv_cfg,uint8_t * device_status)\nspecifier|static",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/**  * @brief checks for DIAG_FAIL errors and reads out the DEVICE_STATUS register if necessary  *  * Prints a human readable representation to the log, if \\c CONFIG_LOG is activated.  *  * @param drv_cfg[in] driver instance configuration  * @param device_status[out] DEVICE_STATUS register if DIAG_FAIL is set  *  * @retval 0 on success  * @retval \"!= 0\" on error (see @ref i2c_reg_read_byte for error codes)  *  * @note  * If tmag5273_config.ignore_diag_fail is se  *   -  \\a device_status will be always set to \\c 0,  *   - the function always returns \\c 0.  */\n+comment|/**  * @brief checks for DIAG_FAIL errors and reads out the DEVICE_STATUS register if necessary  *  * @param[in] drv_cfg driver instance configuration  * @param[out] device_status DEVICE_STATUS register if DIAG_FAIL is set  *  * @retval 0 on success  * @retval \"!= 0\" on error  *                  - \\c -EIO on any set error device status bit  *                  - see @ref i2c_reg_read_byte for error codes  *  * @note  * If tmag5273_config.ignore_diag_fail is set  *   - \\a device_status will be always set to \\c 0,  *   - the function always returns \\c 0.  */\nThe issue was with: drivers: tmag5273: fix documentation of tmag5273_check_device_status\n\nTypos and invalid doxygen documentation."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: display: st7796s: remove unused gpio pins\n\nRemove unused includes and gpio pins from st7796s driver, which were\nleftover from before this driver used the MIPI DBI API class. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/device.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/drivers/spi.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/drivers/gpio.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/drivers/display.h>\nend_include\nspecifier|const\nname|struct\nname|mipi_dbi_config\nname|dbi_config\ndecl_stmt|;\nDECL|member|cmd_data_gpio\nspecifier|const\nname|struct\nname|gpio_dt_spec\nname|cmd_data_gpio\ndecl_stmt|;\nDECL|member|reset_gpio\nspecifier|const\nname|struct\nname|gpio_dt_spec\nname|reset_gpio\ndecl_stmt|;\nDECL|member|width\nname|uint16_t\nname|width\ndecl_stmt|;\nDECL|member|height",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_include\n-include|#\n-directive|include\n-file|<zephyr/drivers/spi.h>\n-end_include\n-\n-begin_include\n-include|#\n-directive|include\n-file|<zephyr/drivers/gpio.h>\n-end_include\n-\n-DECL|member|cmd_data_gpio\n-specifier|const\n-name|struct\n-name|gpio_dt_spec\n-name|cmd_data_gpio\n-decl_stmt|;\n-DECL|member|reset_gpio\n-specifier|const\n-name|struct\n-name|gpio_dt_spec\n-name|reset_gpio\n-decl_stmt|;\nThe issue was with: drivers: display: st7796s: remove unused gpio pins\n\nRemove unused includes and gpio pins from st7796s driver, which were\nleftover from before this driver used the MIPI DBI API class."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: gpio: stm32: clean up unnecessary code\n\nRemoved the unnecessary initialization of the `ret` variable in\n`gpio_stm32_clock_request` where its value is guaranteed to be\noverwritten by subsequent operations, then simply returned `ret`. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|config\ndecl_stmt|;\nname|int\nname|ret\ninit|=\nliteral|0\ndecl_stmt|;\nname|__ASSERT_NO_MSG\nargument_list|(\nname|dev\noperator|!=\noperator|->\nname|pclken\nargument_list|)\nexpr_stmt|;\nblock|}\nif|if\ncondition|(\nname|ret\noperator|!=\nliteral|0\ncondition|)\nblock|{\nreturn|return\nname|ret\nreturn|;\nblock|}\nreturn|return\nname|ret\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-init|=\n-literal|0\n-if|if\n-condition|(\n-name|ret\n-operator|!=\n-literal|0\n-condition|)\n-block|{\n-return|return\n-name|ret\n-return|;\n-block|}\nThe issue was with: drivers: gpio: stm32: clean up unnecessary code\n\nRemoved the unnecessary initialization of the `ret` variable in\n`gpio_stm32_clock_request` where its value is guaranteed to be\noverwritten by subsequent operations, then simply returned `ret`."
},{
  "instruction": "There is an issue in the following code. It relates to Driver: Sensor: HTS221: Remove log message when trigger disabled\n\nMy students are using a disco_l475_iot1 board with HTS221 sensor.\nWhen logging is enabled, the following log message is always emitted:\n\\\"HTS221: Cannot enable trigger without drdy-gpios\\\"\n\nThis message is confusing to my students as they are not using the\nHTS221 sensor in their projects. However since HTS221 is enabled in\nthe devicetree it gets initialized on boot and the log message\nappears.\n\nIt doesn't seem necessary to tell people that they haven't enabled\nCONFIG_HTS221_TRIGGER at log level INF. I'd be amenable to changing\nthis to LOG_DBG, but I don't think it needs to exist at all. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nreturn|return\nname|status\nreturn|;\nblock|}\nelse|#\ndirective|else\nname|LOG_INF\nargument_list|(\nliteral|\"Cannot enable trigger without drdy-gpios\"\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\nreturn|return\nliteral|0\nreturn|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-else|#\n-directive|else\n-name|LOG_INF\n-argument_list|(\n-literal|\"Cannot enable trigger without drdy-gpios\"\n-argument_list|)\n-expr_stmt|;\nThe issue was with: Driver: Sensor: HTS221: Remove log message when trigger disabled\n\nMy students are using a disco_l475_iot1 board with HTS221 sensor.\nWhen logging is enabled, the following log message is always emitted:\n\\\"HTS221: Cannot enable trigger without drdy-gpios\\\"\n\nThis message is confusing to my students as they are not using the\nHTS221 sensor in their projects. However since HTS221 is enabled in\nthe devicetree it gets initialized on boot and the log message\nappears.\n\nIt doesn't seem necessary to tell people that they haven't enabled\nCONFIG_HTS221_TRIGGER at log level INF. I'd be amenable to changing\nthis to LOG_DBG, but I don't think it needs to exist at all."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: samples: hci_uart_async: Remove bt_recv() dependency\n\nApps shouldn't try to call bt_recv() since that's not a public API and\nis going completely away with the new HCI driver API. Just inject the\nbuffer directly into the k_fifo which we anyway have access to in this\napp. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|BT_BUF_EVT\nargument_list|,\nname|K_FOREVER\nargument_list|)\ndecl_stmt|;\nname|net_buf_add_mem\nargument_list|(\nname|buf\nargument_list|,\nname|hci_evt_hw_err\nname|hci_evt_hw_err\nargument_list|)\nargument_list|)\nexpr_stmt|;\ncomment|/* Inject the message into the c2h queue. */\nname|bt_recv\nargument_list|(\nname|buf\nargument_list|)\nexpr_stmt|;\ncomment|/* The c2h thread will send the message at some point. The host \t * will receive it and reset the controller. \t */\nblock|}\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_struct\nDECL|struct|__anon27b2b8e50108\nspecifier|const\nstruct|struct\nblock|{\nDECL|member|h4\nname|uint8_t",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|net_buf_add_u8\n+argument_list|(\n+name|buf\n+argument_list|,\n+name|BT_HCI_H4_EVT\n+argument_list|)\n+expr_stmt|;\n-name|bt_recv\n+name|net_buf_put\n+operator|&\n+name|c2h_queue\n+argument_list|,\n-DECL|struct|__anon27b2b8e50108\n+DECL|struct|__anon2976a4cd0108\nThe issue was with: Bluetooth: samples: hci_uart_async: Remove bt_recv() dependency\n\nApps shouldn't try to call bt_recv() since that's not a public API and\nis going completely away with the new HCI driver API. Just inject the\nbuffer directly into the k_fifo which we anyway have access to in this\napp."
},{
  "instruction": "There is an issue in the following code. It relates to sensor: current_amp: fix fractional value\n\nIt needs to be x1000\n\nAlso correct the units used in the log Please fix this issue.",
  "input": "Faulty tokenized code:\nname|i_ma\nargument_list|)\nexpr_stmt|;\nname|LOG_DBG\nargument_list|(\nliteral|\"%d/%d, %dmV, current:%duA\"\nargument_list|,\nname|data\noperator|->\nname|raw\nargument_list|,\nexpr_stmt|;\nname|val\noperator|->\nname|val2\noperator|=\nname|i_ma\noperator|%\nliteral|1000\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"%d/%d, %dmV, current:%duA\"\n+literal|\"%d/%d, %dmV, current:%dmA\"\n+operator|(\n+operator|)\n+operator|*\n+literal|1000\nThe issue was with: sensor: current_amp: fix fractional value\n\nIt needs to be x1000\n\nAlso correct the units used in the log"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: nxp_enet: Fix nxp,unique-mac\n\nnxp,unique-mac actually is not meant to be universally\nunique, the LAA bit should therefore be set, and fix the\ndescription of the property in the binding to clarify\nthe intended usage of this property. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_else\nelse|#\ndirective|else\nend_else\n\nbegin_define\nDECL|macro|ETH_NXP_ENET_UNIQUE_ID\ndefine|#\ndirective|define\nname|ETH_NXP_ENET_UNIQUE_ID\nvalue|0xFFFFFF\nend_define\n\nbegin_error\nerror|#\ndirective|error\nliteral|\"Unsupported SOC\"\nend_error\nargument_list|(\nname|irq_lock_key\nargument_list|)\nexpr_stmt|;\nblock|}\nDECL|function|nxp_enet_unique_mac (uint8_t * mac_addr)\nspecifier|static\nspecifier|inline\nname|void\nname|nxp_enet_unique_mac\nname|uint32_t\nname|id\ninit|=\nname|ETH_NXP_ENET_UNIQUE_ID\ndecl_stmt|;\nname|mac_addr\nindex|[\nliteral|0\nindex|]\noperator|=\nname|FREESCALE_OUI_B0\nexpr_stmt|;\nname|mac_addr\nindex|[\nliteral|1\nindex|]\n      Corresponding ptp clock device\n\n  nxp,unique-mac:\n    type: boolean\n    description: |\n     Use unique silicon ID to use UAA MAC.\n      This property will be overridden if the node has\n      zephyr,random-mac-address or local-mac-address also.",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_define\n-DECL|macro|ETH_NXP_ENET_UNIQUE_ID\n-define|#\n-directive|define\n-name|ETH_NXP_ENET_UNIQUE_ID\n-value|0xFFFFFF\n-end_define\n-\n+comment|/* Note this is not universally unique, it just is probably unique on a network */\n+comment|/* Setting LAA bit because it is not guaranteed universally unique */\n+operator||\n+literal|0x02\n-      Use unique silicon ID to use UAA MAC.\n+      Use part of the unique silicon ID to generate the MAC.\n+      This option is intended for cases where a very low likelihood\n+      that the mac address is the same as another on the network\n+      is sufficient, such as, testing, bringup, demos, etc.\n+      The first 3 bytes will be the freescale OUI and the next\n+      3 bytes will come from the chip's unique ID.\nThe issue was with: drivers: nxp_enet: Fix nxp,unique-mac\n\nnxp,unique-mac actually is not meant to be universally\nunique, the LAA bit should therefore be set, and fix the\ndescription of the property in the binding to clarify\nthe intended usage of this property."
},{
  "instruction": "There is an issue in the following code. It relates to lib: utils: avoid Boolean-to-integer type casts\n\nAvoid casting expression to an inappropriate essential type. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ref_abs\nexpr_stmt|;\nname|rv\noperator|=\noperator|(\nname|int\noperator|)\noperator|(\nname|tsp\noperator|->\nname|skew\noperator|!=\nliteral|1.0f\noperator|)\nexpr_stmt|;\nblock|}\nblock|}\nreturn|return\nname|rv\nname|local_abs\nexpr_stmt|;\nname|rv\noperator|=\noperator|(\nname|int\noperator|)\noperator|(\nname|tsp\noperator|->\nname|skew\noperator|!=\nliteral|1.0f\noperator|)\nexpr_stmt|;\nblock|}\nreturn|return\nname|rv\nreturn|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|int\n-operator|)\n-operator|(\n+condition|?\n+literal|1\n+else|:\n+literal|0\n-name|int\n-operator|)\n-operator|(\n+condition|?\n+literal|1\n+else|:\n+literal|0\nThe issue was with: lib: utils: avoid Boolean-to-integer type casts\n\nAvoid casting expression to an inappropriate essential type."
},{
  "instruction": "There is an issue in the following code. It relates to soc: microchip: mec: Common SoC init updated to MEC5 HAL v0.2\n\nMicrochip MEC5 HAL version 0.2 standardizes HAL API and register\ndefine names. Updated the SoC common initialization code using\nnew HAL API names. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|mec_ecs_etm_pins\nargument_list|(\nname|ECS_ETM_PINS_DISABLE\nargument_list|)\nexpr_stmt|;\nname|mec_ecs_debug_port\nargument_list|(\nname|MEC_DEBUG_MODE_DISABLE\nargument_list|)\nexpr_stmt|;\nelse|#\nname|mec_ecs_etm_pins\nargument_list|(\nname|ECS_ETM_PINS_DISABLE\nargument_list|)\nexpr_stmt|;\nname|mec_ecs_debug_port\nargument_list|(\nname|MEC_DEBUG_MODE_SWD\nargument_list|)\nexpr_stmt|;\nelif|#\nname|mec_ecs_etm_pins\nargument_list|(\nname|ECS_ETM_PINS_DISABLE\nargument_list|)\nexpr_stmt|;\nname|mec_ecs_debug_port\nargument_list|(\nname|MEC_DEBUG_MODE_SWD_SWV\nargument_list|)\nexpr_stmt|;\nelif|#\nname|mec_ecs_debug_port\nargument_list|(\nname|MEC_DEBUG_MODE_SWD\nargument_list|)\nexpr_stmt|;\nname|mec_ecs_etm_pins\nargument_list|(\nname|ECS_ETM_PINS_ENABLE\nargument_list|)\nexpr_stmt|;\nendif|#\nparameter_list|)\nblock|{\nname|mec5_soc_init_debug_interface\nargument_list|()\nexpr_stmt|;\nname|mec_ecia_init\nargument_list|(\nname|MEC5_ECIA_DIRECT_BITMAP\nargument_list|,\nliteral|1\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|mec_ecs_debug_port\n+name|mec_hal_ecs_debug_port\n-name|mec_ecs_debug_port\n+name|mec_hal_ecs_debug_port\n-name|mec_ecs_debug_port\n+name|mec_hal_ecs_debug_port\n-name|mec_ecs_etm_pins\n+name|mec_hal_ecs_etm_pins\n-name|mec_ecia_init\n+name|mec_hal_ecia_init\nThe issue was with: soc: microchip: mec: Common SoC init updated to MEC5 HAL v0.2\n\nMicrochip MEC5 HAL version 0.2 standardizes HAL API and register\ndefine names. Updated the SoC common initialization code using\nnew HAL API names."
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: counter: counter_basic_api: enabled lptmr testing\n\nEnabled the counter_basic_api test to test lptmr. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nargument|ambiq_counter\nargument_list|)\nendif|#\ndirective|endif\nblock|}\ndecl_stmt|;\nend_decl_stmt\n\nbegin_decl_stmt",
  "result": "I corrected the issue in the code by changing the following tokens:\n+ifdef|#\n+directive|ifdef\n+name|CONFIG_COUNTER_MCUX_LPTMR\n+name|DEVS_FOR_DT_COMPAT\n+argument_list|(\n+argument|nxp_lptmr\n+argument_list|)\n+endif|#\n+directive|endif\nThe issue was with: tests: drivers: counter: counter_basic_api: enabled lptmr testing\n\nEnabled the counter_basic_api test to test lptmr."
},{
  "instruction": "There is an issue in the following code. It relates to boards: nxp: frdm_mcxn947: Enable lpmtr for frdm_mcxn947\n\nEnabled one instance of lptmr\nrunning from the 16k FRO. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|)\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\ncomment|/* Set SystemCoreClock variable. */\nname|SystemCoreClock\noperator|=\nname|CLOCK_INIT_CORE_CLOCK\nexpr_stmt|;\n+-----------+------------+-------------------------------------+\n| LPCMP     | on-chip    | sensor(comparator)                  |\n+-----------+------------+-------------------------------------+\n| FLEXCAN   | on-chip    | CAN                                 |\n+-----------+------------+-------------------------------------+\n\nTargets available\n==================\n\nThe default configuration file\n};\n\n&lpcmp0 {\n\tstatus = \"okay\";\n};",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|#\n+directive|if\n+name|DT_NODE_HAS_STATUS\n+argument_list|(\n+name|DT_NODELABEL\n+argument_list|(\n+name|lptmr0\n+argument_list|)\n+operator|,\n+name|okay\n+argument_list|)\n+name|CLOCK_SetupClk16KClocking\n+argument_list|(\n+name|kCLOCK_Clk16KToVsys\n+argument_list|)\n+expr_stmt|;\n+endif|#\n+directive|endif\n+| LPTMR     | on-chip    | counter                             |\n+\n+&lptmr0 {\n+\tstatus = \"okay\";\n+};\nThe issue was with: boards: nxp: frdm_mcxn947: Enable lpmtr for frdm_mcxn947\n\nEnabled one instance of lptmr\nrunning from the 16k FRO."
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: counter: basic_api: Tweak test timing\n\nFor slow processors it is possible that setting 1 ms alarm and\nthen canceling it could lead to alarm expiring before it is canceled\nand that was not expected in the test. Increasing timeout to 1.5ms. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|cnt\ndecl_stmt|;\nname|uint32_t\nname|us\ninit|=\nliteral|1000\ndecl_stmt|;\nname|uint32_t\nname|ticks\ninit|=\nname|counter_us_to_ticks",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|1000\n+literal|1500\nThe issue was with: tests: drivers: counter: basic_api: Tweak test timing\n\nFor slow processors it is possible that setting 1 ms alarm and\nthen canceling it could lead to alarm expiring before it is canceled\nand that was not expected in the test. Increasing timeout to 1.5ms."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: mem_slab: only define slab_ptr_is_good with assert enabled\n\nAdd a __ASSERT_ON guard around slab_ptr_is_good, as that is only used in\nassertions and leaving it on seems to generate a build warning with some\nclang versions:\n\nkernel/mem_slab.c:207:20: error: unused function 'slab_ptr_is_good'\n  207 | static inline bool slab_ptr_is_good(struct k_mem_slab *slab,...\n      |                    ^~~~~~~~~~~~~~~~ Please fix this issue.",
  "input": "Faulty tokenized code:\nname|rc\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|slab_ptr_is_good (struct k_mem_slab * slab,const void * ptr)\nspecifier|static\nspecifier|inline\nname|bool\nname|slab_ptr_is_good\nparameter_list|(\nname|struct\nname|k_mem_slab\noperator|)\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|k_mem_slab_alloc (struct k_mem_slab * slab,void ** mem,k_timeout_t timeout)\nname|int\nname|k_mem_slab_alloc\nparameter_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_if\n+if|#\n+directive|if\n+name|__ASSERT_ON\n+end_if\n+\n-specifier|inline\n+begin_endif\n+endif|#\n+directive|endif\n+end_endif\n+\nThe issue was with: kernel: mem_slab: only define slab_ptr_is_good with assert enabled\n\nAdd a __ASSERT_ON guard around slab_ptr_is_good, as that is only used in\nassertions and leaving it on seems to generate a build warning with some\nclang versions:\n\nkernel/mem_slab.c:207:20: error: unused function 'slab_ptr_is_good'\n  207 | static inline bool slab_ptr_is_good(struct k_mem_slab *slab,...\n      |                    ^~~~~~~~~~~~~~~~"
},{
  "instruction": "There is an issue in the following code. It relates to arch: riscv: core: Enable RISCV IRQs for no multithreading\n\nEnable MSTATUS.IEN to allow RISCV interrupts for\nnon-multithreaded applications. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|z_main_stack\nargument_list|)\noperator|)\nexpr_stmt|;\nasm|__asm__\nspecifier|volatile\nasm|( \t\"mv sp, %0; jalr ra, %1, 0\" \t: \t: \"r\" (main_stack), \"r\" (main_entry) \t: \"memory\");\ncomment|/* infinite loop */\nname|irq_lock",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|irq_unlock\n+argument_list|(\n+name|MSTATUS_IEN\n+argument_list|)\n+expr_stmt|;\nThe issue was with: arch: riscv: core: Enable RISCV IRQs for no multithreading\n\nEnable MSTATUS.IEN to allow RISCV interrupts for\nnon-multithreaded applications."
},{
  "instruction": "There is an issue in the following code. It relates to soc: stm32h7: m4: Always enable hardware semaphore clock\n\nWhen BCM4 bit is set to zero, the hardware semaphore clock is never\nenabled on startup. The hardware semaphores might still randomly work,\nbut very unreliably, and the locking procedure will need several retries\ndespite no competition on the hardware semaphores. This leads to wasted\nclock cycles on the M4 and sometimes even random kernel panics.\n\nThis can be solved by always enabling the hardware semaphore clock in\nthe init procedure of the M4, regardless of whether it is used within\nthe initialization or not. On the M7, it is already always enabled. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nname|LL_ART_Enable\nargument_list|()\nexpr_stmt|;\ncomment|/* In case CM4 has not been forced boot by CM7, \t * CM4 needs to wait until CM7 has setup clock configuration \t */\nif|if\ncondition|(\noperator|!\nname|LL_RCC_IsCM4BootForced\nargument_list|()\ncondition|)\nblock|{\ncomment|/* \t\t * Domain D2 is waiting for Cortex-M7 to perform \t\t * system initialization \t\t * (system clock config, external memory configuration.. ). \t\t * End of system initialization is reached when CM7 takes HSEM. \t\t */\nname|LL_AHB4_GRP1_EnableClock\nargument_list|(\nname|LL_AHB4_GRP1_PERIPH_HSEM\nargument_list|)\nexpr_stmt|;\nwhile|while\ncondition|(\noperator|(\nname|HSEM\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Enable hardware semaphore clock */\n+name|LL_AHB4_GRP1_EnableClock\n+argument_list|(\n+name|LL_AHB4_GRP1_PERIPH_HSEM\n+argument_list|)\n+expr_stmt|;\n-name|LL_AHB4_GRP1_EnableClock\n-argument_list|(\n-name|LL_AHB4_GRP1_PERIPH_HSEM\n-argument_list|)\n-expr_stmt|;\nThe issue was with: soc: stm32h7: m4: Always enable hardware semaphore clock\n\nWhen BCM4 bit is set to zero, the hardware semaphore clock is never\nenabled on startup. The hardware semaphores might still randomly work,\nbut very unreliably, and the locking procedure will need several retries\ndespite no competition on the hardware semaphores. This leads to wasted\nclock cycles on the M4 and sometimes even random kernel panics.\n\nThis can be solved by always enabling the hardware semaphore clock in\nthe init procedure of the M4, regardless of whether it is used within\nthe initialization or not. On the M7, it is already always enabled."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: dma: smartbond: Add missing direction case\n\nThis commit should deal with adding a missing\ndirection case  as memory-to-peripheral\nand peripheral-to-memory transfers\nshould be considered the same. Please fix this issue.",
  "input": "Faulty tokenized code:\nbreak|break;\ncase|case\nname|PERIPHERAL_TO_MEMORY\ncase|:\ncase|case\nname|PERIPHERAL_TO_PERIPHERAL\ncase|:\ncomment|/* DMA channels starts by peripheral DMA req */\nname|DMA_CTRL_REG_SET_FIELD\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|MEMORY_TO_PERIPHERAL\n+case|:\n+case|case\nThe issue was with: drivers: dma: smartbond: Add missing direction case\n\nThis commit should deal with adding a missing\ndirection case  as memory-to-peripheral\nand peripheral-to-memory transfers\nshould be considered the same."
},{
  "instruction": "There is an issue in the following code. It relates to net: shell: ipv4: Add information about ACD\n\nPrint information in IPv4 shell whether address conflict detection is\nenabled or not. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|\"disabled\"\nargument_list|)\nexpr_stmt|;\nname|PR\nargument_list|(\nliteral|\"Max number of IPv4 network interfaces \"\nliteral|\"in the system          : %d\\n\"\nargument_list|,\nname|CONFIG_NET_IF_MAX_IPV4_COUNT\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+literal|\"IPv4 conflict detection support           : %s\\n\"\n+argument_list|,\n+name|IS_ENABLED\n+argument_list|(\n+name|CONFIG_NET_IPV4_ACD\n+argument_list|)\n+condition|?\n+literal|\"enabled\"\n+else|:\n+literal|\"disabled\"\n+argument_list|)\n+expr_stmt|;\n+name|PR\n+argument_list|(\nThe issue was with: net: shell: ipv4: Add information about ACD\n\nPrint information in IPv4 shell whether address conflict detection is\nenabled or not."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: banner: fix disabling boot banner\n\nWhen the CONFIG_BOOT_BANNER flag is set to \\\"n\\\", but CONFIG_BOOT_DELAY\nis enabled, there is a delay message printed at boot time.\nThis allows for the whole boot banner to be disabled. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|(\nname|CONFIG_BOOT_DELAY\noperator|>\nliteral|0\noperator|)\nname|printk\nargument_list|(\nliteral|\"***** delaying boot \"\nname|DELAY_STR\nliteral|\"ms (per build configuration) *****\\n\"\nargument_list|)\nexpr_stmt|;\nname|k_busy_wait\nargument_list|(\nname|CONFIG_BOOT_DELAY\noperator|*\nname|USEC_PER_MSEC",
  "result": "I corrected the issue in the code by changing the following tokens:\n+ifdef|#\n+directive|ifdef\n+name|CONFIG_BOOT_BANNER\n+endif|#\n+directive|endif\n+comment|/* CONFIG_BOOT_BANNER */\nThe issue was with: kernel: banner: fix disabling boot banner\n\nWhen the CONFIG_BOOT_BANNER flag is set to \\\"n\\\", but CONFIG_BOOT_DELAY\nis enabled, there is a delay message printed at boot time.\nThis allows for the whole boot banner to be disabled."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: gpio: pcal64xxa: give semaphore in case of error\n\nIn function pcal64xxa_process_input, lock was not released in case of\nerror when calling inputs_read.\nThis was causing an infinite wait in the following calls of functions\nusing I2C bus. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|dev\noperator|->\nname|name\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|rc\nreturn|;\nblock|}\nif|if",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|k_sem_give\n+argument_list|(\n+operator|&\n+name|drv_data\n+operator|->\n+name|lock\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: gpio: pcal64xxa: give semaphore in case of error\n\nIn function pcal64xxa_process_input, lock was not released in case of\nerror when calling inputs_read.\nThis was causing an infinite wait in the following calls of functions\nusing I2C bus."
},{
  "instruction": "There is an issue in the following code. It relates to arch: common: Removed unnecessary cast\n\nRemoved an unnecessary cast to void * from a function that already\nhad the correct signature.\nThis makes for more portable code as casting between code and data\npointers are frowned upon by the C standard. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|void\noperator|*\noperator|)\nliteral|0x42\nblock|,\noperator|(\nname|void\noperator|*\noperator|)\noperator|&\nname|z_irq_spurious\nblock|}\nblock|, }\ndecl_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|(\n-name|void\n-operator|*\n-operator|)\nThe issue was with: arch: common: Removed unnecessary cast\n\nRemoved an unnecessary cast to void * from a function that already\nhad the correct signature.\nThis makes for more portable code as casting between code and data\npointers are frowned upon by the C standard."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: gpio: gecko: Use SIZEOF_FIELD() macro\n\nUse the utility macro instead of bare code. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/irq.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<soc.h>\nend_include\nname|mode\nparameter_list|)\nvalue|(mode<< ((pin - 8) * 4))\nend_define\n\nbegin_define\nDECL|macro|member_size (type,member)\ndefine|#\ndirective|define\nname|member_size\nparameter_list|(\nname|type\nparameter_list|,\nname|member\nparameter_list|)\nvalue|sizeof(((type *)0)->member)\nend_define\n\nbegin_define\nDECL|macro|NUMBER_OF_PORTS\ndefine|#\ndirective|define\nname|NUMBER_OF_PORTS\nvalue|(member_size(GPIO_TypeDef, P) / \\ \t\t\t member_size(GPIO_TypeDef, P[0]))\nend_define\n\nbegin_struct\nDECL|struct|gpio_gecko_common_config\nstruct|struct",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/sys/util.h>\n+end_include\n+\n-begin_define\n-DECL|macro|member_size (type,member)\n-define|#\n-directive|define\n-name|member_size\n-parameter_list|(\n-name|type\n-parameter_list|,\n-name|member\n-parameter_list|)\n-value|sizeof(((type *)0)->member)\n-end_define\n-\n-value|(member_size(GPIO_TypeDef, P) / \\ \t\t\t member_size(GPIO_TypeDef, P[0]))\n+value|(SIZEOF_FIELD(GPIO_TypeDef, P) / \\ \t\t\t SIZEOF_FIELD(GPIO_TypeDef, P[0]))\nThe issue was with: drivers: gpio: gecko: Use SIZEOF_FIELD() macro\n\nUse the utility macro instead of bare code."
},{
  "instruction": "There is an issue in the following code. It relates to testsuite: ztest: ztress: Add missing static keywords\n\nAdd static to local timers definition. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|)\nfunction_decl|;\nend_function_decl\n\nbegin_expr_stmt\nname|K_TIMER_DEFINE\nargument_list|(\nname|ctrl_timer\nargument_list|,\nname|ctrl_timeout\nparameter_list|)\nfunction_decl|;\nend_function_decl\n\nbegin_expr_stmt\nname|K_TIMER_DEFINE\nargument_list|(\nname|progress_timer\nargument_list|,\nname|progress_timeout\nparameter_list|)\nfunction_decl|;\nend_function_decl\n\nbegin_expr_stmt\nname|K_TIMER_DEFINE\nargument_list|(\nname|ztress_timer\nargument_list|,\nname|ztress_timeout\nparameter_list|)\nfunction_decl|;\nend_function_decl\n\nbegin_expr_stmt\nname|K_TIMER_DEFINE\nargument_list|(\nname|test_timer\nargument_list|,\nname|test_timeout",
  "result": "I corrected the issue in the code by changing the following tokens:\n+specifier|static\n+specifier|static\n+specifier|static\n+specifier|static\nThe issue was with: testsuite: ztest: ztress: Add missing static keywords\n\nAdd static to local timers definition."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: Use BT_HCI_ERR_UNSPECIFIED as needed\n\nA Host shall consider any error code that it does not\nexplicitly understand equivalent to the error code\nUnspecified Error (0x1F). Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ep\noperator|->\nname|status\noperator|=\nname|err\nexpr_stmt|;\nname|ep\noperator|->\nname|handle\noperator|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n+condition|?\n+name|err\n+else|:\n+operator|(\n+name|encryption_on\n+condition|?\n+name|err\n+else|:\n+name|BT_HCI_ERR_UNSPECIFIED\n+operator|)\nThe issue was with: Bluetooth: Controller: Use BT_HCI_ERR_UNSPECIFIED as needed\n\nA Host shall consider any error code that it does not\nexplicitly understand equivalent to the error code\nUnspecified Error (0x1F)."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: Refactor BT_CTLR_LE_ENC implementation\n\nRefactor reused function in BT_CTLR_LE_ENC feature. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|encrypt_change (uint8_t err,uint16_t handle,struct net_buf * buf)\nspecifier|static\nname|void\nname|encrypt_change\nparameter_list|(\nname|uint8_t\nparameter_list|,\nname|struct\nname|net_buf\nmodifier|*\nname|buf\nparameter_list|)\nblock|{\nname|struct\nname|bt_hci_evt_encrypt_change\nmodifier|*\nexpr_stmt|;\nname|ep\noperator|->\nname|encrypt\noperator|=\noperator|!\nname|err\ncondition|?\nliteral|1\nelse|:\nliteral|0\nexpr_stmt|;\nliteral|0x00\nargument_list|,\nname|handle\nargument_list|,\nname|buf\nargument_list|)\nexpr_stmt|;\nbreak|break;\nendif|#\ndirective|endif\nname|error_code\nargument_list|,\nname|handle\nargument_list|,\nname|buf\nargument_list|)\nexpr_stmt|;\nbreak|break;\nendif|#\ndirective|endif",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|encrypt_change (uint8_t err,uint16_t handle,struct net_buf * buf)\n+DECL|function|encrypt_change (uint8_t err,uint16_t handle,struct net_buf * buf,bool encryption_on)\n+parameter_list|,\n+name|bool\n+name|encryption_on\n-operator|!\n-name|err\n+name|encryption_on\n+argument_list|,\n+name|true\n+argument_list|,\n+name|false\nThe issue was with: Bluetooth: Controller: Refactor BT_CTLR_LE_ENC implementation\n\nRefactor reused function in BT_CTLR_LE_ENC feature."
},{
  "instruction": "There is an issue in the following code. It relates to samples: Bluetooth: use correct periodic advertising intervals\n\nBT_GAP_ADV_SLOW_INT_MIN and BT_GAP_ADV_SLOW_INT_MAX represent 1s and 1.2s,\nrespectively, in the extended advertising context, where the bit interval\nis 0.625 ms. Using them for periodic advertising will result in a range\nof [2s, 2.4s], as the bit interval for periodic advertising is 1.25ms.\n\nInstead, BT_GAP_PER_ADV_SLOW_INT_MIN and BT_GAP_PER_ADV_SLOW_INT_MAX\nshould be used in this sample, and the range will become [1s, 1.2s]. Please fix this issue.",
  "input": "Faulty tokenized code:\ninit|=\nblock|{\noperator|.\nname|interval_min\noperator|=\nname|BT_GAP_ADV_SLOW_INT_MIN\nblock|,\noperator|.\nname|interval_max\noperator|=\nname|BT_GAP_ADV_SLOW_INT_MAX\nblock|,\noperator|.\nname|options\noperator|=\nname|BT_LE_ADV_OPT_USE_TX_POWER",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|BT_GAP_ADV_SLOW_INT_MIN\n+name|BT_GAP_PER_ADV_SLOW_INT_MIN\n-name|BT_GAP_ADV_SLOW_INT_MAX\n+name|BT_GAP_PER_ADV_SLOW_INT_MAX\nThe issue was with: samples: Bluetooth: use correct periodic advertising intervals\n\nBT_GAP_ADV_SLOW_INT_MIN and BT_GAP_ADV_SLOW_INT_MAX represent 1s and 1.2s,\nrespectively, in the extended advertising context, where the bit interval\nis 0.625 ms. Using them for periodic advertising will result in a range\nof [2s, 2.4s], as the bit interval for periodic advertising is 1.25ms.\n\nInstead, BT_GAP_PER_ADV_SLOW_INT_MIN and BT_GAP_PER_ADV_SLOW_INT_MAX\nshould be used in this sample, and the range will become [1s, 1.2s]."
},{
  "instruction": "There is an issue in the following code. It relates to Samples: Bluetooth: Remove unnecessary signal\n\nThe `sec_update_signal` was raised but never waited on. It could be\nconfusing, remove it. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|k_poll_signal\nname|conn_signal\ndecl_stmt|;\nend_decl_stmt\n\nbegin_decl_stmt\nDECL|variable|sec_update_signal\nspecifier|static\nname|struct\nname|k_poll_signal\nname|sec_update_signal\ndecl_stmt|;\nend_decl_stmt\n\nbegin_decl_stmt\nDECL|variable|passkey_enter_signal\nspecifier|static\nname|struct\nname|k_poll_signal\nname|addr\nargument_list|,\nname|level\nargument_list|)\nexpr_stmt|;\nname|k_poll_signal_raise\nargument_list|(\noperator|&\nname|sec_update_signal\nargument_list|,\nliteral|0\nargument_list|)\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\nname|LOG_DBG\nargument_list|(\nargument_list|)\nexpr_stmt|;\nname|k_poll_signal_init\nargument_list|(\noperator|&\nname|sec_update_signal\nargument_list|)\nexpr_stmt|;\nname|k_poll_signal_init\nargument_list|(\noperator|&\nname|gatt_disc_signal\nargument_list|)\nexpr_stmt|;\nname|k_poll_signal_init\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_decl_stmt\n-DECL|variable|sec_update_signal\n-specifier|static\n-name|struct\n-name|k_poll_signal\n-name|sec_update_signal\n-decl_stmt|;\n-end_decl_stmt\n-\n-name|k_poll_signal_raise\n-argument_list|(\n-operator|&\n-name|sec_update_signal\n-argument_list|,\n-literal|0\n-argument_list|)\n-expr_stmt|;\n-name|sec_update_signal\n-argument_list|)\n-expr_stmt|;\n-name|k_poll_signal_init\n-argument_list|(\n-operator|&\nThe issue was with: Samples: Bluetooth: Remove unnecessary signal\n\nThe `sec_update_signal` was raised but never waited on. It could be\nconfusing, remove it."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: added missing parenthesis\n\n- added missing parenthesis around macro argument expansion Please fix this issue.",
  "input": "Faulty tokenized code:\nname|K_SPINLOCK\nparameter_list|(\nname|lck\nparameter_list|)\ndefine|\\\nvalue|for (k_spinlock_key_t __i K_SPINLOCK_ONEXIT = {}, __key = k_spin_lock(lck); !__i.key;      \\ \t     k_spin_unlock(lck, __key), __i.key = 1)\ncomment|/** @} */\nifdef|#\ndirective|ifdef\nname|__cplusplus\nblock|}\ndirective|define\nname|Z_BOOT_VIRT_TO_PHYS\nparameter_list|(\nname|virt\nparameter_list|)\nvalue|((uintptr_t)(((uint8_t *)virt) - Z_VM_OFFSET))\nend_define\n\nbegin_define\nDECL|macro|Z_BOOT_PHYS_TO_VIRT (phys)\ndefine|#\ndirective|define\nname|Z_BOOT_PHYS_TO_VIRT\nparameter_list|(\nname|phys\nparameter_list|)\nvalue|((uint8_t *)(((uintptr_t)phys) + Z_VM_OFFSET))\nend_define\n\nbegin_ifdef\nifdef|#\ndirective|ifdef\nbegin_struct\nDECL|struct|z_page_frame\nstruct|struct\nname|z_page_frame\nblock|{\nDECL|union|__anon2b48460a010a\nunion|union\nblock|{\ncomment|/* \t\t * If mapped, Z_PAGE_FRAME_* flags and virtual address \t\t * this page is mapped to. \t\t */\nDECL|member|va_and_flags\nname|uintptr_t\nname|_phys\nparameter_list|,\nname|_pageframe\nparameter_list|)\ndefine|\\\nvalue|for (_phys = Z_PHYS_RAM_START, _pageframe = z_page_frames; \\ \t     _phys< Z_PHYS_RAM_END; \\ \t     _phys += CONFIG_MMU_PAGE_SIZE, _pageframe++)\nend_define\n\nbegin_ifdef\nifdef|#\ndirective|ifdef\nname|_size\nparameter_list|,\nname|_pos\nparameter_list|)\ndefine|\\\nvalue|for (_pos = _base; \\ \t     _pos< ((uint8_t *)_base + _size); _pos += CONFIG_MMU_PAGE_SIZE)\nend_define\n\nbegin_define\nDECL|macro|PHYS_FOREACH (_base,_size,_pos)\ndefine|#\nname|_size\nparameter_list|,\nname|_pos\nparameter_list|)\ndefine|\\\nvalue|for (_pos = _base; \\ \t     _pos< ((uintptr_t)_base + _size); _pos += CONFIG_MMU_PAGE_SIZE)\nend_define\n\nbegin_comment\ncomment|/*  * Virtual address space management  *  * Call all of these functions with z_mm_lock held.  *  * Overall virtual memory map: When the kernel starts, it resides in  * virtual memory in the region Z_KERNEL_VIRT_START to  * Z_KERNEL_VIRT_END. Unused virtual memory past this, up to the limit  * noted by CONFIG_KERNEL_VM_SIZE may be used for runtime memory mappings.  *  * If CONFIG_ARCH_MAPS_ALL_RAM is set, we do not just map the kernel image,  * but have a mapping for all RAM in place. This is for special architectural  * purposes and does not otherwise affect page frame accounting or flags;  * the only guarantee is that such RAM mapping outside of the Zephyr image  * won't be disturbed by subsequent memory mapping calls.  *  * +--------------+<- Z_VIRT_RAM_START  * | Undefined VM |<- May contain ancillary regions like x86_64's locore  * +--------------+<- Z_KERNEL_VIRT_START (often == Z_VIRT_RAM_START)  * | Mapping for  |  * | main kernel  |  * | image        |  * |\t\t  |  * |\t\t  |  * +--------------+<- Z_FREE_VM_START  * |              |  * | Unused,      |  * | Available VM |  * |              |  * |..............|<- mapping_pos (grows downward as more mappings are made)  * | Mapping      |  * +--------------+  * | Mapping      |  * +--------------+  * | ...          |  * +--------------+  * | Mapping      |  * +--------------+<- mappings start here  * | Reserved     |<- special purpose virtual page(s) of size Z_VM_RESERVED  * +--------------+<- Z_VIRT_RAM_END  */\nend_comment",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|for (k_spinlock_key_t __i K_SPINLOCK_ONEXIT = {}, __key = k_spin_lock(lck); !__i.key;      \\ \t     k_spin_unlock(lck, __key), __i.key = 1)\n+value|for (k_spinlock_key_t __i K_SPINLOCK_ONEXIT = {}, __key = k_spin_lock(lck); !__i.key;      \\ \t     k_spin_unlock((lck), __key), __i.key = 1)\n-value|((uintptr_t)(((uint8_t *)virt) - Z_VM_OFFSET))\n+value|((uintptr_t)(((uint8_t *)(virt)) - Z_VM_OFFSET))\n-value|((uint8_t *)(((uintptr_t)phys) + Z_VM_OFFSET))\n+value|((uint8_t *)(((uintptr_t)(phys)) + Z_VM_OFFSET))\n-DECL|union|__anon2b48460a010a\n+DECL|union|__anon2ab1def7010a\n-value|for (_phys = Z_PHYS_RAM_START, _pageframe = z_page_frames; \\ \t     _phys< Z_PHYS_RAM_END; \\ \t     _phys += CONFIG_MMU_PAGE_SIZE, _pageframe++)\n+value|for ((_phys) = Z_PHYS_RAM_START, (_pageframe) = z_page_frames; \\ \t     (_phys)< Z_PHYS_RAM_END; \\ \t     (_phys) += CONFIG_MMU_PAGE_SIZE, (_pageframe)++)\n-value|for (_pos = _base; \\ \t     _pos< ((uint8_t *)_base + _size); _pos += CONFIG_MMU_PAGE_SIZE)\n+value|for ((_pos) = (_base); \\ \t     (_pos)< ((uint8_t *)(_base) + (_size)); (_pos) += CONFIG_MMU_PAGE_SIZE)\n-value|for (_pos = _base; \\ \t     _pos< ((uintptr_t)_base + _size); _pos += CONFIG_MMU_PAGE_SIZE)\n+value|for ((_pos) = (_base); \\ \t     (_pos)< ((uintptr_t)(_base) + (_size)); (_pos) += CONFIG_MMU_PAGE_SIZE)\nThe issue was with: kernel: added missing parenthesis\n\n- added missing parenthesis around macro argument expansion"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: flash: flash_shell: Fix unused variables\n\nFix unused variable compilation warnings. Please fix this issue.",
  "input": "Faulty tokenized code:\nmodifier|*\nname|argv\nindex|[]\nparameter_list|)\nblock|{\nspecifier|const\nname|struct\nname|device\nmodifier|*\nname|flash_dev\ndecl_stmt|;\nname|uint32_t\nname|page_addr\ndecl_stmt|;\nname|int\nname|result\ninit|=\noperator|-\nname|ENOTSUP\ndecl_stmt|;\nname|uint32_t\nname|size\ndecl_stmt|;\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_FLASH_HAS_EXPLICIT_ERASE\nargument_list|)\nname|result\noperator|=\nname|parse_helper\nargument_list|(\nname|sh",
  "result": "I corrected the issue in the code by changing the following tokens:\n-specifier|const\n-name|struct\n-name|device\n-modifier|*\n-name|flash_dev\n-decl_stmt|;\n-name|uint32_t\n-name|page_addr\n-decl_stmt|;\n-name|uint32_t\n-name|size\n-decl_stmt|;\n+specifier|const\n+name|struct\n+name|device\n+modifier|*\n+name|flash_dev\n+decl_stmt|;\n+name|uint32_t\n+name|page_addr\n+decl_stmt|;\n+name|uint32_t\n+name|size\n+decl_stmt|;\nThe issue was with: drivers: flash: flash_shell: Fix unused variables\n\nFix unused variable compilation warnings."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: clock_control: add a macro for mke17z9 to wrap flexbus clock\n\nThe flexbus clock-related macro is not defined in mke17z9 clock. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nbreak|break;\nif|#\ndirective|if\noperator|!\nname|defined\nargument_list|(\nname|CONFIG_SOC_MKE17Z7\nargument_list|)\ncase|case\nname|KINETIS_SCG_FLEXBUS_CLK\ncase|:\nname|clock_name\noperator|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+operator|||\n+name|defined\n+argument_list|(\n+name|CONFIG_SOC_MKE17Z9\n+argument_list|)\n+operator|)\nThe issue was with: drivers: clock_control: add a macro for mke17z9 to wrap flexbus clock\n\nThe flexbus clock-related macro is not defined in mke17z9 clock."
},{
  "instruction": "There is an issue in the following code. It relates to fs: fcb: correct `FCB_MAX_LEN` boundary condition\n\nCorrect the boundary condition in `fcb_put_len` function to\nproperly include `FCB_MAX_LEN` and change the #define to address\nthe potential flaw where `CHAR_MAX` might be treated as unsigned by\nthe compiler flag `-funsigned-char`, which would yield `FCB_MAX_LEN`\nto 0x7fff instead of 0x3fff.\n\nFixes #73868 Please fix this issue.",
  "input": "Faulty tokenized code:\ncomment|/**  * @defgroup fcb_data_structures Flash Circular Buffer Data Structures  * @ingroup fcb  * @{  */\nDECL|macro|FCB_MAX_LEN\ndefine|#\ndirective|define\nname|FCB_MAX_LEN\nvalue|(CHAR_MAX | CHAR_MAX<< 7)\ncomment|/**< Max length of element */\ncomment|/**  * @brief FCB entry info structure. This data structure describes the element  * location in the flash.  *  * You would use it to figure out what parameters to pass to flash_area_read()  * to read element contents. Or to flash_area_write() when adding a new element.  * Entry location is pointer to area (within fcb->f_sectors), and offset  * within that area.  */\nDECL|struct|fcb_entry\nstruct|struct\nname|fcb_entry\nblock|{\nreturn|;\nblock|}\nif|else if\ncondition|(\nname|len\noperator|<\nname|FCB_MAX_LEN\ncondition|)\nblock|{\nname|buf\nindex|[",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|(CHAR_MAX | CHAR_MAX<< 7)\n-comment|/**< Max length of element */\n+value|(0x3fffu)\n+comment|/**< Max length of element (16,383) */\n-operator|<\n+operator|<=\nThe issue was with: fs: fcb: correct `FCB_MAX_LEN` boundary condition\n\nCorrect the boundary condition in `fcb_put_len` function to\nproperly include `FCB_MAX_LEN` and change the #define to address\nthe potential flaw where `CHAR_MAX` might be treated as unsigned by\nthe compiler flag `-funsigned-char`, which would yield `FCB_MAX_LEN`\nto 0x7fff instead of 0x3fff.\n\nFixes #73868"
},{
  "instruction": "There is an issue in the following code. It relates to soc: nordic: nrf54h: Retrigger TASK_FREQ_CHANGE\n\nA single trigger of the TASK_FREQ_CHANGE task might not be enough, so\ntrigger twice to make sure the frequency gets updated. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|hsfll\nargument_list|,\nname|NRF_HSFLL_TASK_FREQ_CHANGE\nargument_list|)\nexpr_stmt|;\nname|LOG_DBG\nargument_list|(\nliteral|\"NRF_HSFLL->TRIM.VSUP = %d\"\nargument_list|,\nname|hsfll",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* HSFLL task frequency change needs to be triggered twice to take effect.*/\n+name|nrf_hsfll_task_trigger\n+argument_list|(\n+name|hsfll\n+argument_list|,\n+name|NRF_HSFLL_TASK_FREQ_CHANGE\n+argument_list|)\n+expr_stmt|;\nThe issue was with: soc: nordic: nrf54h: Retrigger TASK_FREQ_CHANGE\n\nA single trigger of the TASK_FREQ_CHANGE task might not be enough, so\ntrigger twice to make sure the frequency gets updated."
},{
  "instruction": "There is an issue in the following code. It relates to samples: video: tcpserversink: Use mt9m114 camera shield\n\nUpdate the sample to use a camera shield with a camera chosen node.\nThis is not only because the camera nodes in the mimxrt1064 device\ntree has been now moved to a separate mt9m114 shield but also to\nmake the sample more generic. Please fix this issue.",
  "input": "Faulty tokenized code:\nFor :ref:`mimxrt1064_evk`, build this sample application with the following commands:\n\n.. zephyr-app-commands::\n   :zephyr-app: samples/subsys/video/tcpserversink\n   :board: mimxrt1064_evk\n   :goals: build\n   :compact:\n\nSample Output\n=============\nsample:\n  name: Video TCP server sink\ntests:\n  sample.video.tcpserversink:\n    build_only: true\n    tags:\n      - video\n      - net\n      - socket\n    platform_allow: mimxrt1064_evk\n    depends_on:\n      - video\n      - netif\n    integration_platforms:\n      - mimxrt1064_evk\nname|device\nmodifier|*\nspecifier|const\nname|video\ninit|=\nname|DEVICE_DT_GET_ANY\nargument_list|(\nname|nxp_imx_csi\nargument_list|)\ndecl_stmt|;\ncomment|/* Prepare Network */\noperator|(\nname|void",
  "result": "I corrected the issue in the code by changing the following tokens:\n+   :shield: dvp_fpc24_mt9m114\n+    filter: dt_chosen_enabled(\"zephyr,camera\")\n+      - shield\n+    extra_args:\n+      - platform:mimxrt1064_evk:SHIELD=dvp_fpc24_mt9m114\n-name|DEVICE_DT_GET_ANY\n+name|DEVICE_DT_GET\n-name|nxp_imx_csi\n+name|DT_CHOSEN\n+argument_list|(\n+name|zephyr_camera\n+argument_list|)\nThe issue was with: samples: video: tcpserversink: Use mt9m114 camera shield\n\nUpdate the sample to use a camera shield with a camera chosen node.\nThis is not only because the camera nodes in the mimxrt1064 device\ntree has been now moved to a separate mt9m114 shield but also to\nmake the sample more generic."
},{
  "instruction": "There is an issue in the following code. It relates to samples: video: tcpserversink: Add a new line after printk\n\nAdd a new line so that logs are easier to be read. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|0\nreturn|;\nblock|}\nname|printk\nargument_list|(\nliteral|\"\\rSending frame %d\"\nargument_list|,\nname|i\noperator|++\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"\\rSending frame %d\"\n+literal|\"\\rSending frame %d\\n\"\nThe issue was with: samples: video: tcpserversink: Add a new line after printk\n\nAdd a new line so that logs are easier to be read."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: nsos: handle sendto() blocking call\n\nUse poll(), similar to accept() and recvfrom() APIs. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|return_ret\ngoto|;\nblock|}\nname|ret\noperator|=\nname|nsos_adapt_sendto\nargument_list|(\nname|sock\noperator|->\nname|poll",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|nsos_poll_if_blocking\n+argument_list|(\n+name|sock\n+argument_list|,\n+name|ZSOCK_POLLOUT\n+argument_list|,\n+name|K_FOREVER\n+argument_list|,\n+name|flags\n+argument_list|)\n+expr_stmt|;\n+if|if\n+condition|(\n+name|ret\n+operator|<\n+literal|0\n+condition|)\n+block|{\n+goto|goto\n+name|return_ret\n+goto|;\n+block|}\n+name|ret\n+operator|=\nThe issue was with: drivers: nsos: handle sendto() blocking call\n\nUse poll(), similar to accept() and recvfrom() APIs."
},{
  "instruction": "There is an issue in the following code. It relates to modules: lvgl: input: Fix invalid encoder readout\n\nWhen the encoder button was pressed, it would send a LV_KEY_LEFT/RIGHT\ninstead of a LV_KEY_ENTER event.\nThis clears the enc_diff field, and set the key field to LV_KEY_ENTER\nfor button events.\n\nFixes #73529 Please fix this issue.",
  "input": "Faulty tokenized code:\ncondition|?\nname|LV_INDEV_STATE_PR\nelse|:\nname|LV_INDEV_STATE_REL\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\nname|LOG_DBG\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|data\n+operator|->\n+name|pending_event\n+operator|.\n+name|enc_diff\n+operator|=\n+literal|0\n+expr_stmt|;\n+name|data\n+operator|->\n+name|pending_event\n+operator|.\n+name|key\n+operator|=\n+name|LV_KEY_ENTER\n+expr_stmt|;\nThe issue was with: modules: lvgl: input: Fix invalid encoder readout\n\nWhen the encoder button was pressed, it would send a LV_KEY_LEFT/RIGHT\ninstead of a LV_KEY_ENTER event.\nThis clears the enc_diff field, and set the key field to LV_KEY_ENTER\nfor button events.\n\nFixes #73529"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: pinctrl: esp32: Use BIT macro when writing pin value\n\nGPIO registers w1ts and w1tc expects bitfield of pins to set/clean. Please fix this issue.",
  "input": "Faulty tokenized code:\ndecl_stmt|;\nname|gpio_dev\noperator|->\nname|out_w1ts\noperator|=\nname|pin_num\nexpr_stmt|;\nif|#\ndirective|if\nname|DT_NODE_HAS_STATUS\nargument_list|(\noperator|->\nname|out1_w1ts\noperator|.\nname|data\noperator|=\nname|pin_num\nexpr_stmt|;\nendif|#\ndirective|endif\nblock|}\nblock|}\ndecl_stmt|;\nname|gpio_dev\noperator|->\nname|out_w1tc\noperator|=\nname|pin_num\nexpr_stmt|;\nif|#\ndirective|if\nname|DT_NODE_HAS_STATUS\nargument_list|(\noperator|->\nname|out1_w1tc\noperator|.\nname|data\noperator|=\nname|pin_num\nexpr_stmt|;\nendif|#\ndirective|endif\nblock|}\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|BIT\n+argument_list|(\n+argument_list|)\n+name|BIT\n+argument_list|(\n+operator|-\n+literal|32\n+argument_list|)\n+name|BIT\n+argument_list|(\n+argument_list|)\n+name|BIT\n+argument_list|(\n+operator|-\n+literal|32\n+argument_list|)\nThe issue was with: drivers: pinctrl: esp32: Use BIT macro when writing pin value\n\nGPIO registers w1ts and w1tc expects bitfield of pins to set/clean."
},{
  "instruction": "There is an issue in the following code. It relates to task_wdt: Feed hardware watchdog only when its started\n\nPreviously the schedule_next_timeout() function was feeding the hardware\nwatchdog irrespective of whether or not it was started. This is now\nfixed. Please fix this issue.",
  "input": "Faulty tokenized code:\nifdef|#\ndirective|ifdef\nname|CONFIG_TASK_WDT_HW_FALLBACK\nif|if\ncondition|(\nname|hw_wdt_dev\ncondition|)\nblock|{\nname|wdt_feed\nargument_list|(\nname|hw_wdt_dev",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|hw_wdt_dev\n+name|hw_wdt_started\nThe issue was with: task_wdt: Feed hardware watchdog only when its started\n\nPreviously the schedule_next_timeout() function was feeding the hardware\nwatchdog irrespective of whether or not it was started. This is now\nfixed."
},{
  "instruction": "There is an issue in the following code. It relates to posix: re-introduce PTHREAD_RWLOCK_INITIALIZER\n\nRename the POSIX_RWLOCK_INITIALIZER back to PTHREAD_RWLOCK_INITIALIZER.\nThis was changed in 64f529e4810 [formerly 70e2b02c8e1], but PTHREAD_RWLOCK_INITIALIZER is the\nstandard name used by external libraries.\n\nChange it back to restore compatibility. Please fix this issue.",
  "input": "Faulty tokenized code:\ndefine|#\ndirective|define\nname|PTHREAD_MUTEX_INITIALIZER\nvalue|(-1)\ncomment|/**  * @brief Declare a rwlock as initialized  *  * Initialize a rwlock with the default rwlock attributes.  */\nDECL|macro|POSIX_RWLOCK_INITIALIZER\ndefine|#\ndirective|define\nname|POSIX_RWLOCK_INITIALIZER\nvalue|(-1)\ncomment|/*  *  Mutex attributes - type  *  *  PTHREAD_MUTEX_NORMAL: Owner of mutex cannot relock it. Attempting  *      to relock will cause deadlock.  *  PTHREAD_MUTEX_RECURSIVE: Owner can relock the mutex.  *  PTHREAD_MUTEX_ERRORCHECK: If owner attempts to relock the mutex, an  *      error is returned.  *  */\nDECL|macro|PTHREAD_MUTEX_NORMAL\ndefine|#\ndirective|define\nif|if\ncondition|(\noperator|*\nname|rwlock\noperator|!=\nname|POSIX_RWLOCK_INITIALIZER\ncondition|)\nblock|{\nreturn|return\nname|get_posix_rwlock\nargument_list|(\nargument_list|)\nexpr_stmt|;\noperator|*\nname|rwlock\noperator|=\nname|POSIX_RWLOCK_INITIALIZER\nexpr_stmt|;\nname|rwl\noperator|=\nname|to_posix_rwlock\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|macro|POSIX_RWLOCK_INITIALIZER\n+DECL|macro|PTHREAD_RWLOCK_INITIALIZER\n-name|POSIX_RWLOCK_INITIALIZER\n+name|PTHREAD_RWLOCK_INITIALIZER\n-name|POSIX_RWLOCK_INITIALIZER\n+name|PTHREAD_RWLOCK_INITIALIZER\n-name|POSIX_RWLOCK_INITIALIZER\n+name|PTHREAD_RWLOCK_INITIALIZER\nThe issue was with: posix: re-introduce PTHREAD_RWLOCK_INITIALIZER\n\nRename the POSIX_RWLOCK_INITIALIZER back to PTHREAD_RWLOCK_INITIALIZER.\nThis was changed in 64f529e4810 [formerly 70e2b02c8e1], but PTHREAD_RWLOCK_INITIALIZER is the\nstandard name used by external libraries.\n\nChange it back to restore compatibility."
},{
  "instruction": "There is an issue in the following code. It relates to boards: rebrand lairdconnect to ezurio\n\nRename boards/lairdconnect to boards/ezurio. Please fix this issue.",
  "input": "Faulty tokenized code:\nsimilarity index 100%\nrename from boards/lairdconnect/bl5340_dvk/CMakeLists.txt\nrename to boards/ezurio/bl5340_dvk/CMakeLists.txt\nsimilarity index 100%\nrename from boards/lairdconnect/bl5340_dvk/Kconfig\nrename to boards/ezurio/bl5340_dvk/Kconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bl5340_dvk/Kconfig.bl5340_dvk\nrename to boards/ezurio/bl5340_dvk/Kconfig.bl5340_dvk\nsimilarity index 100%\nrename from boards/lairdconnect/bl5340_dvk/Kconfig.defconfig\nrename to boards/ezurio/bl5340_dvk/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp.dts\nrename to boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp.dts\nsimilarity index 100%\nrename from boards/lairdconnect/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp.yaml\nrename to boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp.yaml\nsimilarity index 100%\nrename from boards/lairdconnect/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp_common-pinctrl.dtsi\nrename to boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp_common-pinctrl.dtsi\nsimilarity index 100%\nrename from boards/lairdconnect/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp_common.dtsi\nrename to boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp_common.dtsi\nsimilarity index 100%\nrename from boards/lairdconnect/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp_defconfig\nrename to boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp_defconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp_ns.dts\nrename to boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp_ns.dts\nsimilarity index 100%\nrename from boards/lairdconnect/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp_ns.yaml\nrename to boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp_ns.yaml\nsimilarity index 100%\nrename from boards/lairdconnect/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp_ns_defconfig\nrename to boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp_ns_defconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp_partition_conf.dtsi\nrename to boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpuapp_partition_conf.dtsi\nsimilarity index 100%\nrename from boards/lairdconnect/bl5340_dvk/bl5340_dvk_nrf5340_cpunet-pinctrl.dtsi\nrename to boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpunet-pinctrl.dtsi\nsimilarity index 100%\nrename from boards/lairdconnect/bl5340_dvk/bl5340_dvk_nrf5340_cpunet.dts\nrename to boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpunet.dts\nsimilarity index 100%\nrename from boards/lairdconnect/bl5340_dvk/bl5340_dvk_nrf5340_cpunet.yaml\nrename to boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpunet.yaml\nsimilarity index 100%\nrename from boards/lairdconnect/bl5340_dvk/bl5340_dvk_nrf5340_cpunet_common.dtsi\nrename to boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpunet_common.dtsi\nsimilarity index 100%\nrename from boards/lairdconnect/bl5340_dvk/bl5340_dvk_nrf5340_cpunet_defconfig\nrename to boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpunet_defconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bl5340_dvk/bl5340_dvk_nrf5340_cpunet_reset.c\nrename to boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_cpunet_reset.c\nsimilarity index 100%\nrename from boards/lairdconnect/bl5340_dvk/bl5340_dvk_nrf5340_shared_sram_planning_conf.dtsi\nrename to boards/ezurio/bl5340_dvk/bl5340_dvk_nrf5340_shared_sram_planning_conf.dtsi\nsimilarity index 100%\nrename from boards/lairdconnect/bl5340_dvk/board.cmake\nrename to boards/ezurio/bl5340_dvk/board.cmake\nsimilarity index 100%\nrename from boards/lairdconnect/bl5340_dvk/board.yml\nrename to boards/ezurio/bl5340_dvk/board.yml\nsimilarity index 100%\nrename from boards/lairdconnect/bl5340_dvk/doc/img/bl5340_dvk_top.jpg\nrename to boards/ezurio/bl5340_dvk/doc/img/bl5340_dvk_top.jpg\nsimilarity index 100%\nrename from boards/lairdconnect/bl5340_dvk/doc/index.rst\nrename to boards/ezurio/bl5340_dvk/doc/index.rst\nsimilarity index 100%\nrename from boards/lairdconnect/bl5340_dvk/pre_dt_board.cmake\nrename to boards/ezurio/bl5340_dvk/pre_dt_board.cmake\nsimilarity index 100%\nrename from boards/lairdconnect/bl652_dvk/Kconfig\nrename to boards/ezurio/bl652_dvk/Kconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bl652_dvk/Kconfig.bl652_dvk\nrename to boards/ezurio/bl652_dvk/Kconfig.bl652_dvk\nsimilarity index 100%\nrename from boards/lairdconnect/bl652_dvk/Kconfig.defconfig\nrename to boards/ezurio/bl652_dvk/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bl652_dvk/bl652_dvk-pinctrl.dtsi\nrename to boards/ezurio/bl652_dvk/bl652_dvk-pinctrl.dtsi\nsimilarity index 100%\nrename from boards/lairdconnect/bl652_dvk/bl652_dvk.dts\nrename to boards/ezurio/bl652_dvk/bl652_dvk.dts\nsimilarity index 100%\nrename from boards/lairdconnect/bl652_dvk/bl652_dvk.yaml\nrename to boards/ezurio/bl652_dvk/bl652_dvk.yaml\nsimilarity index 100%\nrename from boards/lairdconnect/bl652_dvk/bl652_dvk_defconfig\nrename to boards/ezurio/bl652_dvk/bl652_dvk_defconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bl652_dvk/board.cmake\nrename to boards/ezurio/bl652_dvk/board.cmake\nsimilarity index 100%\nrename from boards/lairdconnect/bl652_dvk/board.yml\nrename to boards/ezurio/bl652_dvk/board.yml\nsimilarity index 100%\nrename from boards/lairdconnect/bl652_dvk/doc/bl652_dvk.rst\nrename to boards/ezurio/bl652_dvk/doc/bl652_dvk.rst\nsimilarity index 100%\nrename from boards/lairdconnect/bl652_dvk/doc/img/BL652-SA_DVK_BoxContents.jpg\nrename to boards/ezurio/bl652_dvk/doc/img/BL652-SA_DVK_BoxContents.jpg\nsimilarity index 100%\nrename from boards/lairdconnect/bl652_dvk/doc/img/bl652_dvk.jpg\nrename to boards/ezurio/bl652_dvk/doc/img/bl652_dvk.jpg\nsimilarity index 100%\nrename from boards/lairdconnect/bl652_dvk/pre_dt_board.cmake\nrename to boards/ezurio/bl652_dvk/pre_dt_board.cmake\nsimilarity index 100%\nrename from boards/lairdconnect/bl653_dvk/Kconfig\nrename to boards/ezurio/bl653_dvk/Kconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bl653_dvk/Kconfig.bl653_dvk\nrename to boards/ezurio/bl653_dvk/Kconfig.bl653_dvk\nsimilarity index 100%\nrename from boards/lairdconnect/bl653_dvk/Kconfig.defconfig\nrename to boards/ezurio/bl653_dvk/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bl653_dvk/bl653_dvk-pinctrl.dtsi\nrename to boards/ezurio/bl653_dvk/bl653_dvk-pinctrl.dtsi\nsimilarity index 100%\nrename from boards/lairdconnect/bl653_dvk/bl653_dvk.dts\nrename to boards/ezurio/bl653_dvk/bl653_dvk.dts\nsimilarity index 100%\nrename from boards/lairdconnect/bl653_dvk/bl653_dvk.yaml\nrename to boards/ezurio/bl653_dvk/bl653_dvk.yaml\nsimilarity index 100%\nrename from boards/lairdconnect/bl653_dvk/bl653_dvk_defconfig\nrename to boards/ezurio/bl653_dvk/bl653_dvk_defconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bl653_dvk/board.cmake\nrename to boards/ezurio/bl653_dvk/board.cmake\nsimilarity index 100%\nrename from boards/lairdconnect/bl653_dvk/board.yml\nrename to boards/ezurio/bl653_dvk/board.yml\nsimilarity index 100%\nrename from boards/lairdconnect/bl653_dvk/doc/bl653_dvk.rst\nrename to boards/ezurio/bl653_dvk/doc/bl653_dvk.rst\nsimilarity index 100%\nrename from boards/lairdconnect/bl653_dvk/doc/img/bl653_dvk.jpg\nrename to boards/ezurio/bl653_dvk/doc/img/bl653_dvk.jpg\nsimilarity index 100%\nrename from boards/lairdconnect/bl653_dvk/pre_dt_board.cmake\nrename to boards/ezurio/bl653_dvk/pre_dt_board.cmake\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_dvk/Kconfig\nrename to boards/ezurio/bl654_dvk/Kconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_dvk/Kconfig.bl654_dvk\nrename to boards/ezurio/bl654_dvk/Kconfig.bl654_dvk\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_dvk/Kconfig.defconfig\nrename to boards/ezurio/bl654_dvk/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_dvk/bl654_dvk-pinctrl.dtsi\nrename to boards/ezurio/bl654_dvk/bl654_dvk-pinctrl.dtsi\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_dvk/bl654_dvk.dts\nrename to boards/ezurio/bl654_dvk/bl654_dvk.dts\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_dvk/bl654_dvk.yaml\nrename to boards/ezurio/bl654_dvk/bl654_dvk.yaml\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_dvk/bl654_dvk_defconfig\nrename to boards/ezurio/bl654_dvk/bl654_dvk_defconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_dvk/bl654_dvk_nrf52840_pa.dts\nrename to boards/ezurio/bl654_dvk/bl654_dvk_nrf52840_pa.dts\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_dvk/bl654_dvk_nrf52840_pa.yaml\nrename to boards/ezurio/bl654_dvk/bl654_dvk_nrf52840_pa.yaml\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_dvk/bl654_dvk_nrf52840_pa_defconfig\nrename to boards/ezurio/bl654_dvk/bl654_dvk_nrf52840_pa_defconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_dvk/board.cmake\nrename to boards/ezurio/bl654_dvk/board.cmake\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_dvk/board.yml\nrename to boards/ezurio/bl654_dvk/board.yml\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_dvk/doc/bl654_dvk.rst\nrename to boards/ezurio/bl654_dvk/doc/bl654_dvk.rst\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_dvk/doc/img/455-00001_BoxContents.jpg\nrename to boards/ezurio/bl654_dvk/doc/img/455-00001_BoxContents.jpg\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_dvk/doc/img/bl654_dvk.jpg\nrename to boards/ezurio/bl654_dvk/doc/img/bl654_dvk.jpg\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_dvk/pre_dt_board.cmake\nrename to boards/ezurio/bl654_dvk/pre_dt_board.cmake\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_sensor_board/Kconfig\nrename to boards/ezurio/bl654_sensor_board/Kconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_sensor_board/Kconfig.bl654_sensor_board\nrename to boards/ezurio/bl654_sensor_board/Kconfig.bl654_sensor_board\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_sensor_board/Kconfig.defconfig\nrename to boards/ezurio/bl654_sensor_board/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_sensor_board/bl654_sensor_board-pinctrl.dtsi\nrename to boards/ezurio/bl654_sensor_board/bl654_sensor_board-pinctrl.dtsi\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_sensor_board/bl654_sensor_board.dts\nrename to boards/ezurio/bl654_sensor_board/bl654_sensor_board.dts\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_sensor_board/bl654_sensor_board.yaml\nrename to boards/ezurio/bl654_sensor_board/bl654_sensor_board.yaml\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_sensor_board/bl654_sensor_board_defconfig\nrename to boards/ezurio/bl654_sensor_board/bl654_sensor_board_defconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_sensor_board/board.cmake\nrename to boards/ezurio/bl654_sensor_board/board.cmake\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_sensor_board/board.yml\nrename to boards/ezurio/bl654_sensor_board/board.yml\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_sensor_board/doc/bl654_sensor_board.rst\nrename to boards/ezurio/bl654_sensor_board/doc/bl654_sensor_board.rst\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_sensor_board/doc/img/bl654_sensor_board.jpg\nrename to boards/ezurio/bl654_sensor_board/doc/img/bl654_sensor_board.jpg\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_sensor_board/doc/img/bl654_sensor_board_usb_swd_programmer.jpg\nrename to boards/ezurio/bl654_sensor_board/doc/img/bl654_sensor_board_usb_swd_programmer.jpg\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_sensor_board/pre_dt_board.cmake\nrename to boards/ezurio/bl654_sensor_board/pre_dt_board.cmake\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_usb/Kconfig\nrename to boards/ezurio/bl654_usb/Kconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_usb/Kconfig.bl654_usb\nrename to boards/ezurio/bl654_usb/Kconfig.bl654_usb\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_usb/Kconfig.defconfig\nrename to boards/ezurio/bl654_usb/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_usb/bl654_usb-pinctrl.dtsi\nrename to boards/ezurio/bl654_usb/bl654_usb-pinctrl.dtsi\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_usb/bl654_usb.dts\nrename to boards/ezurio/bl654_usb/bl654_usb.dts\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_usb/bl654_usb.yaml\nrename to boards/ezurio/bl654_usb/bl654_usb.yaml\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_usb/bl654_usb_defconfig\nrename to boards/ezurio/bl654_usb/bl654_usb_defconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_usb/board.yml\nrename to boards/ezurio/bl654_usb/board.yml\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_usb/doc/bl654_usb.rst\nrename to boards/ezurio/bl654_usb/doc/bl654_usb.rst\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_usb/doc/img/bl654_usb.jpg\nrename to boards/ezurio/bl654_usb/doc/img/bl654_usb.jpg\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_usb/doc/img/bl654_usb_pcb.jpg\nrename to boards/ezurio/bl654_usb/doc/img/bl654_usb_pcb.jpg\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_usb/doc/img/bl654_usb_reset.jpg\nrename to boards/ezurio/bl654_usb/doc/img/bl654_usb_reset.jpg\nsimilarity index 100%\nrename from boards/lairdconnect/bl654_usb/pre_dt_board.cmake\nrename to boards/ezurio/bl654_usb/pre_dt_board.cmake\nsimilarity index 100%\nrename from boards/lairdconnect/bt510/Kconfig\nrename to boards/ezurio/bt510/Kconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bt510/Kconfig.bt510\nrename to boards/ezurio/bt510/Kconfig.bt510\nsimilarity index 100%\nrename from boards/lairdconnect/bt510/Kconfig.defconfig\nrename to boards/ezurio/bt510/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bt510/board.cmake\nrename to boards/ezurio/bt510/board.cmake\nsimilarity index 100%\nrename from boards/lairdconnect/bt510/board.yml\nrename to boards/ezurio/bt510/board.yml\nsimilarity index 100%\nrename from boards/lairdconnect/bt510/bt510-pinctrl.dtsi\nrename to boards/ezurio/bt510/bt510-pinctrl.dtsi\nsimilarity index 100%\nrename from boards/lairdconnect/bt510/bt510.dts\nrename to boards/ezurio/bt510/bt510.dts\nsimilarity index 100%\nrename from boards/lairdconnect/bt510/bt510.yaml\nrename to boards/ezurio/bt510/bt510.yaml\nsimilarity index 100%\nrename from boards/lairdconnect/bt510/bt510_defconfig\nrename to boards/ezurio/bt510/bt510_defconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bt510/doc/bt510.rst\nrename to boards/ezurio/bt510/doc/bt510.rst\nsimilarity index 100%\nrename from boards/lairdconnect/bt510/doc/img/bt510.jpg\nrename to boards/ezurio/bt510/doc/img/bt510.jpg\nsimilarity index 100%\nrename from boards/lairdconnect/bt510/doc/img/bt510_back.jpg\nrename to boards/ezurio/bt510/doc/img/bt510_back.jpg\nsimilarity index 100%\nrename from boards/lairdconnect/bt510/doc/img/bt510_prog.jpg\nrename to boards/ezurio/bt510/doc/img/bt510_prog.jpg\nsimilarity index 100%\nrename from boards/lairdconnect/bt510/pre_dt_board.cmake\nrename to boards/ezurio/bt510/pre_dt_board.cmake\nsimilarity index 100%\nrename from boards/lairdconnect/bt610/Kconfig\nrename to boards/ezurio/bt610/Kconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bt610/Kconfig.bt610\nrename to boards/ezurio/bt610/Kconfig.bt610\nsimilarity index 100%\nrename from boards/lairdconnect/bt610/Kconfig.defconfig\nrename to boards/ezurio/bt610/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bt610/board.cmake\nrename to boards/ezurio/bt610/board.cmake\nsimilarity index 100%\nrename from boards/lairdconnect/bt610/board.yml\nrename to boards/ezurio/bt610/board.yml\nsimilarity index 100%\nrename from boards/lairdconnect/bt610/bt610-pinctrl.dtsi\nrename to boards/ezurio/bt610/bt610-pinctrl.dtsi\nsimilarity index 100%\nrename from boards/lairdconnect/bt610/bt610.dts\nrename to boards/ezurio/bt610/bt610.dts\nsimilarity index 100%\nrename from boards/lairdconnect/bt610/bt610.yaml\nrename to boards/ezurio/bt610/bt610.yaml\nsimilarity index 100%\nrename from boards/lairdconnect/bt610/bt610_defconfig\nrename to boards/ezurio/bt610/bt610_defconfig\nsimilarity index 100%\nrename from boards/lairdconnect/bt610/doc/bt610.rst\nrename to boards/ezurio/bt610/doc/bt610.rst\nsimilarity index 100%\nrename from boards/lairdconnect/bt610/doc/img/bt610_back.jpg\nrename to boards/ezurio/bt610/doc/img/bt610_back.jpg\nsimilarity index 100%\nrename from boards/lairdconnect/bt610/doc/img/bt610_board.jpg\nrename to boards/ezurio/bt610/doc/img/bt610_board.jpg\nsimilarity index 100%\nrename from boards/lairdconnect/bt610/doc/img/bt610_front.jpg\nrename to boards/ezurio/bt610/doc/img/bt610_front.jpg\nsimilarity index 100%\nrename from boards/lairdconnect/bt610/pre_dt_board.cmake\nrename to boards/ezurio/bt610/pre_dt_board.cmake\nsimilarity index 100%\nrename from boards/lairdconnect/index.rst\nrename to boards/ezurio/index.rst\nsimilarity index 100%\nrename from boards/lairdconnect/mg100/Kconfig\nrename to boards/ezurio/mg100/Kconfig\nsimilarity index 100%\nrename from boards/lairdconnect/mg100/Kconfig.defconfig\nrename to boards/ezurio/mg100/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/lairdconnect/mg100/Kconfig.mg100\nrename to boards/ezurio/mg100/Kconfig.mg100\nsimilarity index 100%\nrename from boards/lairdconnect/mg100/board.cmake\nrename to boards/ezurio/mg100/board.cmake\nsimilarity index 100%\nrename from boards/lairdconnect/mg100/board.yml\nrename to boards/ezurio/mg100/board.yml\nsimilarity index 100%\nrename from boards/lairdconnect/mg100/doc/img/mg100.jpg\nrename to boards/ezurio/mg100/doc/img/mg100.jpg\nsimilarity index 100%\nrename from boards/lairdconnect/mg100/doc/index.rst\nrename to boards/ezurio/mg100/doc/index.rst\nsimilarity index 100%\nrename from boards/lairdconnect/mg100/mg100-pinctrl.dtsi\nrename to boards/ezurio/mg100/mg100-pinctrl.dtsi\nsimilarity index 100%\nrename from boards/lairdconnect/mg100/mg100.dts\nrename to boards/ezurio/mg100/mg100.dts\nsimilarity index 100%\nrename from boards/lairdconnect/mg100/mg100.yaml\nrename to boards/ezurio/mg100/mg100.yaml\nsimilarity index 100%\nrename from boards/lairdconnect/mg100/mg100_defconfig\nrename to boards/ezurio/mg100/mg100_defconfig\nsimilarity index 100%\nrename from boards/lairdconnect/mg100/pre_dt_board.cmake\nrename to boards/ezurio/mg100/pre_dt_board.cmake\nsimilarity index 100%\nrename from boards/lairdconnect/pinnacle_100_dvk/Kconfig\nrename to boards/ezurio/pinnacle_100_dvk/Kconfig\nsimilarity index 100%\nrename from boards/lairdconnect/pinnacle_100_dvk/Kconfig.defconfig\nrename to boards/ezurio/pinnacle_100_dvk/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/lairdconnect/pinnacle_100_dvk/Kconfig.pinnacle_100_dvk\nrename to boards/ezurio/pinnacle_100_dvk/Kconfig.pinnacle_100_dvk\nsimilarity index 100%\nrename from boards/lairdconnect/pinnacle_100_dvk/board.cmake\nrename to boards/ezurio/pinnacle_100_dvk/board.cmake\nsimilarity index 100%\nrename from boards/lairdconnect/pinnacle_100_dvk/board.yml\nrename to boards/ezurio/pinnacle_100_dvk/board.yml\nsimilarity index 100%\nrename from boards/lairdconnect/pinnacle_100_dvk/doc/img/pinnacle_100_dvk.jpg\nrename to boards/ezurio/pinnacle_100_dvk/doc/img/pinnacle_100_dvk.jpg\nsimilarity index 100%\nrename from boards/lairdconnect/pinnacle_100_dvk/doc/index.rst\nrename to boards/ezurio/pinnacle_100_dvk/doc/index.rst\nsimilarity index 100%\nrename from boards/lairdconnect/pinnacle_100_dvk/pinnacle_100_dvk-pinctrl.dtsi\nrename to boards/ezurio/pinnacle_100_dvk/pinnacle_100_dvk-pinctrl.dtsi\nsimilarity index 100%\nrename from boards/lairdconnect/pinnacle_100_dvk/pinnacle_100_dvk.dts\nrename to boards/ezurio/pinnacle_100_dvk/pinnacle_100_dvk.dts\nsimilarity index 100%\nrename from boards/lairdconnect/pinnacle_100_dvk/pinnacle_100_dvk.yaml\nrename to boards/ezurio/pinnacle_100_dvk/pinnacle_100_dvk.yaml\nsimilarity index 100%\nrename from boards/lairdconnect/pinnacle_100_dvk/pinnacle_100_dvk_defconfig\nrename to boards/ezurio/pinnacle_100_dvk/pinnacle_100_dvk_defconfig\nsimilarity index 100%\nrename from boards/lairdconnect/pinnacle_100_dvk/pre_dt_board.cmake\nrename to boards/ezurio/pinnacle_100_dvk/pre_dt_board.cmake\nsimilarity index 100%\nrename from boards/lairdconnect/rm1xx_dvk/Kconfig.defconfig\nrename to boards/ezurio/rm1xx_dvk/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/lairdconnect/rm1xx_dvk/Kconfig.rm1xx_dvk\nrename to boards/ezurio/rm1xx_dvk/Kconfig.rm1xx_dvk\nsimilarity index 100%\nrename from boards/lairdconnect/rm1xx_dvk/board.cmake\nrename to boards/ezurio/rm1xx_dvk/board.cmake\nsimilarity index 100%\nrename from boards/lairdconnect/rm1xx_dvk/board.yml\nrename to boards/ezurio/rm1xx_dvk/board.yml\nsimilarity index 100%\nrename from boards/lairdconnect/rm1xx_dvk/doc/img/RM186-DVK.jpg\nrename to boards/ezurio/rm1xx_dvk/doc/img/RM186-DVK.jpg\nsimilarity index 100%\nrename from boards/lairdconnect/rm1xx_dvk/doc/img/RM186-SM.jpg\nrename to boards/ezurio/rm1xx_dvk/doc/img/RM186-SM.jpg\nsimilarity index 100%\nrename from boards/lairdconnect/rm1xx_dvk/doc/index.rst\nrename to boards/ezurio/rm1xx_dvk/doc/index.rst\nsimilarity index 100%\nrename from boards/lairdconnect/rm1xx_dvk/pre_dt_board.cmake\nrename to boards/ezurio/rm1xx_dvk/pre_dt_board.cmake\nsimilarity index 100%\nrename from boards/lairdconnect/rm1xx_dvk/rm1xx_dvk-pinctrl.dtsi\nrename to boards/ezurio/rm1xx_dvk/rm1xx_dvk-pinctrl.dtsi\nsimilarity index 100%\nrename from boards/lairdconnect/rm1xx_dvk/rm1xx_dvk.dts\nrename to boards/ezurio/rm1xx_dvk/rm1xx_dvk.dts\nsimilarity index 100%\nrename from boards/lairdconnect/rm1xx_dvk/rm1xx_dvk.yaml\nrename to boards/ezurio/rm1xx_dvk/rm1xx_dvk.yaml\nsimilarity index 100%\nrename from boards/lairdconnect/rm1xx_dvk/rm1xx_dvk_defconfig\nrename to boards/ezurio/rm1xx_dvk/rm1xx_dvk_defconfig",
  "result": "I corrected the issue in the code by changing the following tokens:\n\nThe issue was with: boards: rebrand lairdconnect to ezurio\n\nRename boards/lairdconnect to boards/ezurio."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Tester: Adjust bap ext adv options\n\nThis change removes the BT_LE_PER_ADV_OPT_USE_TX_POWER option for\nextended advertisement in BLE Audio PTS tests.\n\nThe Broadcaster setup options was hardcoded to include the\nBT_LE_PER_ADV_OPT_USE_TX_POWER option. This causes incompabilities\nfor any controller not support it, and since the option is not\nrequired for the audio tests it should not be used here.\n\nsigned-off-by: Frode van der Meeren <frode.vandermeeren@nordicsemi.no> Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|BT_GAP_PER_ADV_FAST_INT_MIN_2\nargument_list|,\nname|BT_GAP_PER_ADV_FAST_INT_MAX_2\nargument_list|,\nname|BT_LE_PER_ADV_OPT_USE_TX_POWER\nargument_list|)\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nargument_list|(\nname|BT_GAP_PER_ADV_FAST_INT_MIN_2\nargument_list|,\nname|BT_GAP_PER_ADV_FAST_INT_MAX_2\nargument_list|,\nname|BT_LE_PER_ADV_OPT_USE_TX_POWER\nargument_list|)\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|BT_LE_PER_ADV_OPT_USE_TX_POWER\n+name|BT_LE_PER_ADV_OPT_NONE\n-name|BT_LE_PER_ADV_OPT_USE_TX_POWER\n+name|BT_LE_PER_ADV_OPT_NONE\nThe issue was with: Bluetooth: Tester: Adjust bap ext adv options\n\nThis change removes the BT_LE_PER_ADV_OPT_USE_TX_POWER option for\nextended advertisement in BLE Audio PTS tests.\n\nThe Broadcaster setup options was hardcoded to include the\nBT_LE_PER_ADV_OPT_USE_TX_POWER option. This causes incompabilities\nfor any controller not support it, and since the option is not\nrequired for the audio tests it should not be used here.\n\nsigned-off-by: Frode van der Meeren <frode.vandermeeren@nordicsemi.no>"
},{
  "instruction": "There is an issue in the following code. It relates to net: lwm2m: On write, use server selected block size\n\nWhen we receive CoAP packets, it is in input buffer\nthat is size of NET_IPV6_MTU.\nSo in reality, we can handle bigger Block-Wise writes\nthan CONFIG_LWM2M_COAP_BLOCK_SIZE.\n\nSo if parsing of CoAP packet has passed, continue\nwith the same block-size instead of going to default. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\noperator|&\nname|block_ctx\nargument_list|)\nexpr_stmt|;\nblock|}\nif|if\ncondition|(\nname|r\noperator|<",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* If we have already parsed the packet, we can handle the block size \t\t\t * given by the server. \t\t\t */\n+name|block_ctx\n+operator|->\n+name|ctx\n+operator|.\n+name|block_size\n+operator|=\n+name|block_size\n+expr_stmt|;\nThe issue was with: net: lwm2m: On write, use server selected block size\n\nWhen we receive CoAP packets, it is in input buffer\nthat is size of NET_IPV6_MTU.\nSo in reality, we can handle bigger Block-Wise writes\nthan CONFIG_LWM2M_COAP_BLOCK_SIZE.\n\nSo if parsing of CoAP packet has passed, continue\nwith the same block-size instead of going to default."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: spi: nrf: fix async cs deactivation\n\nChip Select signal must be deactivated only after transaction\nis finalized. In async case this means it cannot be done from\n`transceive` call context, as this context is left as soon as\ntransfer is initialized. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|busy\noperator|=\nname|false\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|transfer_next_chunk (const struct device * dev)\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\nblock|}\nname|spi_context_cs_control\nargument_list|(\noperator|&\nname|dev_data\noperator|->\nname|ctx\nargument_list|,\nname|false\nargument_list|)\nexpr_stmt|;\nblock|}\nname|spi_context_release\nargument_list|(\noperator|&\nname|dev_data",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|spi_context_cs_control\n+argument_list|(\n+operator|&\n+name|dev_data\n+operator|->\n+name|ctx\n+argument_list|,\n+name|false\n+argument_list|)\n+expr_stmt|;\n-name|spi_context_cs_control\n-argument_list|(\n-operator|&\n-name|dev_data\n-operator|->\n-name|ctx\n-argument_list|,\n-name|false\n-argument_list|)\n-expr_stmt|;\nThe issue was with: drivers: spi: nrf: fix async cs deactivation\n\nChip Select signal must be deactivated only after transaction\nis finalized. In async case this means it cannot be done from\n`transceive` call context, as this context is left as soon as\ntransfer is initialized."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: pinctrl: nrf: use CLOCKPIN for slow SPIM MOSI\n\nFast SPIM instances must not have CLOCKPIN setting applied to MOSI. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|&&\nname|defined\nargument_list|(\nname|NRF_SPIM_CLOCKPIN_MOSI_NEEDED\nargument_list|)\nname|clockpin\noperator|=\nname|true\nexpr_stmt|;\nendif|#\ndirective|endif\nbreak|break;\ncase|case\nname|NRF_FUN_SPIM_MISO",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* CLOCKPIN setting must not be applied to SPIM12x instances. */\n+if|if\n+condition|(\n+operator|!\n+name|NRF_SPIM_IS_320MHZ_SPIM\n+argument_list|(\n+operator|(\n+name|void\n+operator|*\n+operator|)\n+name|reg\n+argument_list|)\n+condition|)\n+block|{\n+block|}\nThe issue was with: drivers: pinctrl: nrf: use CLOCKPIN for slow SPIM MOSI\n\nFast SPIM instances must not have CLOCKPIN setting applied to MOSI."
},{
  "instruction": "There is an issue in the following code. It relates to arch: arm: core: mpu: allow non-ARM memory attributes\n\nMemory region defined in devicetree can have attributes\nthat are not intended to be parsed by MPU library,\nbut might be valid for other components. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nbreak|break;\nendif|#\ndirective|endif\ndefault|default:\ncomment|/* Either the specified `ATTR_MPU_*` attribute does not \t\t\t * exists or the `REGION_*_ATTR` macro is not defined \t\t\t * for that attribute. \t\t\t */\nname|LOG_ERR\nargument_list|(\nliteral|\"Invalid attribute for the region\\n\"\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}\nif|#\ndirective|if\nname|defined\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* Either the specified `ATTR_MPU_*` attribute does not \t\t\t * exists or the `REGION_*_ATTR` macro is not defined \t\t\t * for that attribute. \t\t\t */\n-name|LOG_ERR\n-argument_list|(\n-literal|\"Invalid attribute for the region\\n\"\n-argument_list|)\n-expr_stmt|;\n-return|return\n-operator|-\n-name|EINVAL\n-return|;\n+comment|/* Attribute other than ARM-specific is set. \t\t\t * This region should not be configured in MPU. \t\t\t */\n+continue|continue;\nThe issue was with: arch: arm: core: mpu: allow non-ARM memory attributes\n\nMemory region defined in devicetree can have attributes\nthat are not intended to be parsed by MPU library,\nbut might be valid for other components."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: cc13xx_cc26xx: pwm: Fix building blinky_pwm\n\n- Add channel, flags to pwm-cells\n- Replace __ASSERT_UNREACHABLE with CODE_UNREACHABLE Please fix this issue.",
  "input": "Faulty tokenized code:\ncase|:\nreturn|return\nliteral|3\nreturn|;\ndefault|default:\nname|__ASSERT_UNREACHABLE\nexpr_stmt|;\nblock|}\nblock|}\nend_function\n\ncase|:\nreturn|return\nname|PRCM_PERIPH_TIMER3\nreturn|;\ndefault|default:\nname|__ASSERT_UNREACHABLE\nexpr_stmt|;\nblock|}\nblock|}\nend_function\n\n\t\t\tinterrupt-names = \"gpt0a\", \"gpt0b\";\n\t\t\tstatus = \"disabled\";\n\n\t\t\tpwm0: pwm {\n\t\t\t\tcompatible = \"ti,cc13xx-cc26xx-timer-pwm\";\n\t\t\t\t#pwm-cells = <1>;\n\t\t\t\tstatus = \"disabled\";\n\t\t\t};\n\t\t};\n\n\t\tgpt1: timer@40011000 {\n\t\t\tinterrupt-names = \"gpt1a\", \"gpt1b\";\n\t\t\tstatus = \"disabled\";\n\n\t\t\tpwm1: pwm {\n\t\t\t\tcompatible = \"ti,cc13xx-cc26xx-timer-pwm\";\n\t\t\t\t#pwm-cells = <1>;\n\t\t\t\tstatus = \"disabled\";\n\t\t\t};\n\t\t};\n\n\t\tgpt2: timer@40012000 {\n\t\t\tinterrupt-names = \"gpt2a\", \"gpt2b\";\n\t\t\tstatus = \"disabled\";\n\n\t\t\tpwm2: pwm {\n\t\t\t\tcompatible = \"ti,cc13xx-cc26xx-timer-pwm\";\n\t\t\t\t#pwm-cells = <1>;\n\t\t\t\tstatus = \"disabled\";\n\t\t\t};\n\t\t};\n\n\t\tgpt3: timer@40013000 {\n\t\t\tinterrupt-names = \"gpt3a\", \"gpt3b\";\n\t\t\tstatus = \"disabled\";\n\n\t\t\tpwm3: pwm {\n\t\t\t\tcompatible = \"ti,cc13xx-cc26xx-timer-pwm\";\n\t\t\t\t#pwm-cells = <1>;\n\t\t\t\tstatus = \"disabled\";\n\t\t\t};\n\t\t};\n\n\t\tuart0: uart@40001000 {\nproperties:\n  pinctrl-0:\n    required: true\n\npwm-cells:\n- period",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|__ASSERT_UNREACHABLE\n+name|CODE_UNREACHABLE\n-name|__ASSERT_UNREACHABLE\n+name|CODE_UNREACHABLE\n-\t\t\t\t#pwm-cells = <1>;\n+\t\t\t\t#pwm-cells = <3>;\n-\t\t\t\t#pwm-cells = <1>;\n+\t\t\t\t#pwm-cells = <3>;\n-\t\t\t\t#pwm-cells = <1>;\n+\t\t\t\t#pwm-cells = <3>;\n-\t\t\t\t#pwm-cells = <1>;\n+\t\t\t\t#pwm-cells = <3>;\n+  - channel\n+  - period\n+  - flags\nThe issue was with: drivers: cc13xx_cc26xx: pwm: Fix building blinky_pwm\n\n- Add channel, flags to pwm-cells\n- Replace __ASSERT_UNREACHABLE with CODE_UNREACHABLE"
},{
  "instruction": "There is an issue in the following code. It relates to samples: basic: fade_led: add testing base on console output\n\nExtend automated testing on HW by veryfing console output. Please fix this issue.",
  "input": "Faulty tokenized code:\n  sample.basic.fade_led:\n    tags:\n      - drivers\n      - pwm\n    depends_on: pwm\n   harness: led\n    filter: dt_alias_exists(\"pwm-led0\") and dt_compat_enabled(\"pwm-leds\")\n    integration_platforms:\n      - nrf51dk/nrf51822\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}\nif|if\ncondition|(\nname|dir\ncondition|)\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n-    harness: led\n+    harness: console\n+    harness_config:\n+      type: multi_line\n+      ordered: true\n+      regex:\n+        - \"PWM-based LED fade\"\n+        - \"Using pulse width [0-9]+%\"\n+        - \"Using pulse width [0-9]+%\"\n+name|printk\n+argument_list|(\n+literal|\"Using pulse width %d%%\\n\"\n+argument_list|,\n+literal|100\n+operator|*\n+name|pulse_width\n+operator|/\n+name|pwm_led0\n+operator|.\n+name|period\n+argument_list|)\n+expr_stmt|;\nThe issue was with: samples: basic: fade_led: add testing base on console output\n\nExtend automated testing on HW by veryfing console output."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: rtc: rtc_mc146818: Patch incorrect field comparisons\n\nMinutes and hour values are incorrectly compared with MAX_SEC.\n\nCompare minutes and hour to MAX_MIN and MAX_HOUR respectively. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nif|if\ncondition|(\nname|value\noperator|<=\nname|MAX_SEC\ncondition|)\nblock|{\nname|timeptr\noperator|->\nname|tm_min\nexpr_stmt|;\nif|if\ncondition|(\nname|value\noperator|<=\nname|MAX_SEC\ncondition|)\nblock|{\nname|timeptr\noperator|->\nname|tm_hour",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|MAX_SEC\n+name|MAX_MIN\n-name|MAX_SEC\n+name|MAX_HOUR\nThe issue was with: drivers: rtc: rtc_mc146818: Patch incorrect field comparisons\n\nMinutes and hour values are incorrectly compared with MAX_SEC.\n\nCompare minutes and hour to MAX_MIN and MAX_HOUR respectively."
},{
  "instruction": "There is an issue in the following code. It relates to soc: atmel: sam: Add invalidate d-cache at z_arm_platform_init\n\nBefore that fix, the SOC was unable to boot properly.\nStarting turned directly into z_arm_usage_fault().\nFixes zephyrproject-rtos#73485 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|soc_pmc_enable_waitmode\nargument_list|()\nexpr_stmt|;\nblock|}\ncomment|/* \t * DTCM is enabled by default at reset, therefore we have to disable \t * it first to get the caches into a state where then the \t * sys_cache*-functions can enable them, if requested by the \t * configuration. \t */\nname|SCB_DisableDCache\nargument_list|()\nexpr_stmt|;\ncomment|/* \t * Enable the caches only if configured to do so. \t */\nname|sys_cache_instr_enable\nname|soc_pmc_enable_waitmode\nargument_list|()\nexpr_stmt|;\nblock|}\ncomment|/* \t * DTCM is enabled by default at reset, therefore we have to disable \t * it first to get the caches into a state where then the \t * sys_cache*-functions can enable them, if requested by the \t * configuration. \t */\nname|SCB_DisableDCache\nargument_list|()\nexpr_stmt|;\ncomment|/* \t * Enable the caches only if configured to do so. \t */\nname|sys_cache_instr_enable",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|SCB_InvalidateDCache\n+argument_list|()\n+expr_stmt|;\n+name|SCB_InvalidateDCache\n+argument_list|()\n+expr_stmt|;\nThe issue was with: soc: atmel: sam: Add invalidate d-cache at z_arm_platform_init\n\nBefore that fix, the SOC was unable to boot properly.\nStarting turned directly into z_arm_usage_fault().\nFixes zephyrproject-rtos#73485"
},{
  "instruction": "There is an issue in the following code. It relates to drivers/flash/spi_nor: Fix DPD exit\n\nIncorrectly placed preprocessor conditions caused exit_dpd\nwhen there has been no instance of a device with\ndpd_wakeup_sequence parameter. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|flag_access_32bit\noperator|)\noperator|)\ndecl_stmt|;\nDECL|union|__anon2b70739d010a\nunion|union\nblock|{\nDECL|member|u32\nname|uint32_t\nname|u32\nname|int\nname|ret\ninit|=\nliteral|0\ndecl_stmt|;\nspecifier|const\nname|struct\nname|spi_nor_config\nmodifier|*\nname|cfg\nname|delay_until_exit_dpd_ok\nargument_list|(\nname|dev\nargument_list|)\nexpr_stmt|;\nif|#\ndirective|if\nname|ANY_INST_HAS_DPD_WAKEUP_SEQUENCE\nif|if\ncondition|(\nname|cfg\noperator|->\nname|dpd_wakeup_sequence_exist\ncondition|)\nblock|{\ncomment|/* Assert CSn and wait for tCRDP. \t\t\t * \t\t\t * Unfortunately the SPI API doesn't allow us to \t\t\t * control CSn so fake it by writing a known-supported \t\t\t * single-byte command, hoping that'll hold the assert \t\t\t * long enough.  This is highly likely, since the \t\t\t * duration is usually less than two SPI clock cycles. \t\t\t */\nname|ret\noperator|=\nname|spi_nor_cmd_write\nargument_list|(\noperator|->\nname|t_rdp_ms\nargument_list|)\nargument_list|)\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\nname|ret\noperator|=\nblock|}\nendif|#\ndirective|endif\ncomment|/* T_EXIT_DPD */\nblock|}\nendif|#\ndirective|endif\ncomment|/* DPD_WAKEUP_SEQUENCE */\nblock|}\nreturn|return\nname|ret\nreturn|;\nblock|}\nend_function\nname|uint8_t\nname|decl_nph\ninit|=\nliteral|2\ndecl_stmt|;\nDECL|union|__anon2b70739d020a\nunion|union\nblock|{\ncomment|/* We only process BFP so use one parameter block */\nDECL|member|raw\nname|uint8_t\nname|id\noperator|==\nname|JESD216_SFDP_PARAM_ID_BFP\ncondition|)\nblock|{\nDECL|union|__anon2b70739d030a\nunion|union\nblock|{\nDECL|member|dw\nname|uint32_t\nname|dw",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon2b70739d010a\n+DECL|union|__anon2946cdc4010a\n+if|#\n+directive|if\n+name|ANY_INST_HAS_DPD\n-if|#\n-directive|if\n-name|ANY_INST_HAS_DPD_WAKEUP_SEQUENCE\n+if|#\n+directive|if\n+name|ANY_INST_HAS_DPD_WAKEUP_SEQUENCE\n+endif|#\n+directive|endif\n+comment|/* ANY_INST_HAS_DPD_WAKEUP_SEQUENCE */\n+block|}\n-comment|/* DPD_WAKEUP_SEQUENCE */\n-block|}\n+comment|/* ANY_INST_HAS_DPD */\n-DECL|union|__anon2b70739d020a\n+DECL|union|__anon2946cdc4020a\n-DECL|union|__anon2b70739d030a\n+DECL|union|__anon2946cdc4030a\nThe issue was with: drivers/flash/spi_nor: Fix DPD exit\n\nIncorrectly placed preprocessor conditions caused exit_dpd\nwhen there has been no instance of a device with\ndpd_wakeup_sequence parameter."
},{
  "instruction": "There is an issue in the following code. It relates to modules: lvgl: lvgl_fs: Free file on close\n\nAdd missing call to LV_MEM_CUSTOM_FREE when closing a file to prevent\nmemory from leaking.\n\nResolves issue #73148. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|*\noperator|)\nname|file\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|errno_to_lv_fs_res\nargument_list|(\nname|err\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|LV_MEM_CUSTOM_FREE\n+argument_list|(\n+name|file\n+argument_list|)\n+expr_stmt|;\nThe issue was with: modules: lvgl: lvgl_fs: Free file on close\n\nAdd missing call to LV_MEM_CUSTOM_FREE when closing a file to prevent\nmemory from leaking.\n\nResolves issue #73148."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: counter_smartbond_timer: Fix warning\n\nFix the warning about control reaching end of non void\nfunction by adding a default to the switch statement. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|TIMER4\ncase|:\nreturn|return\nname|MCU_PDC_TRIGGER_TIMER4\nreturn|;\nblock|}\nblock|}\nend_function\n\nbegin_comment",
  "result": "I corrected the issue in the code by changing the following tokens:\n+default|default:\n+return|return\n+literal|0\n+return|;\nThe issue was with: drivers: counter_smartbond_timer: Fix warning\n\nFix the warning about control reaching end of non void\nfunction by adding a default to the switch statement."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: adc: adc_ad559x: fix 5593 adc read\n\nThe AD5593 conversion result also contains the channel read and not just a\nvalue:\n| adc channel (3 bits) | adc value (12 bits) |\n\nThis value was not removed from the result before using it as an adc value.\n\nReuse the AD5592 code to fix the issue. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nreturn|return\nname|ret\nreturn|;\nblock|}\noperator|*\nname|result\noperator|=\nname|sys_get_be16\nargument_list|(\noperator|(\nname|uint8_t\noperator|*\noperator|)\noperator|&\nname|val\nargument_list|)\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\ncomment|/* \t\t * Invalid data: \t\t * See Figure 46. Single-Channel ADC Conversion Sequence. \t\t * The first conversion result always returns invalid data. \t\t */\noperator|(\nblock|{\nreturn|return\nname|ret\nreturn|;\nblock|}\nname|val\noperator|=\nname|sys_be16_to_cpu\nargument_list|(\nname|val\nargument_list|)\nexpr_stmt|;\ncomment|/* \t\t * Invalid data: \t\t * See \"ADC section\" in \"Theory of operation\" chapter. \t\t * Valid ADC result has MSB bit set to 0. \t\t */\nif|if\ncondition|(\noperator|(\nname|val\noperator|&\nreturn|return\noperator|-\nname|EAGAIN\nreturn|;\nblock|}\ncomment|/* \t\t * Invalid channel converted: \t\t * See \"ADC section\" in \"Theory of operation\" chapter. \t\t * Conversion result contains channel number which should match requested channel. \t\t */\nname|conv_channel\noperator|=\nname|FIELD_GET\nargument_list|(\nname|AD559X_ADC_RES_CHAN_MASK\noperator|=\nname|val\noperator|&\nname|AD559X_ADC_RES_VAL_MASK\nexpr_stmt|;\nblock|}\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|*\n-name|result\n-operator|=\n-name|sys_get_be16\n-argument_list|(\n-operator|(\n-name|uint8_t\n-operator|*\n-operator|)\n-operator|&\n-name|val\n-argument_list|)\n-expr_stmt|;\n+block|}\n-comment|/* \t\t * Invalid data: \t\t * See \"ADC section\" in \"Theory of operation\" chapter. \t\t * Valid ADC result has MSB bit set to 0. \t\t */\n+comment|/* \t * Invalid data: \t * See AD5592 \"ADC section\" in \"Theory of operation\" chapter. \t * Valid ADC result has MSB bit set to 0. \t */\n-comment|/* \t\t * Invalid channel converted: \t\t * See \"ADC section\" in \"Theory of operation\" chapter. \t\t * Conversion result contains channel number which should match requested channel. \t\t */\n+comment|/* \t * Invalid channel converted: \t * See AD5592 \"ADC section\" in \"Theory of operation\" chapter. \t * Conversion result contains channel number which should match requested channel. \t */\n-block|}\nThe issue was with: drivers: adc: adc_ad559x: fix 5593 adc read\n\nThe AD5593 conversion result also contains the channel read and not just a\nvalue:\n| adc channel (3 bits) | adc value (12 bits) |\n\nThis value was not removed from the result before using it as an adc value.\n\nReuse the AD5592 code to fix the issue."
},{
  "instruction": "There is an issue in the following code. It relates to net: wifi_shell: Resolve filter settings mismatch\n\nThe control and data settings are set improperly for packet filter\noperation for sniffer operation. The change sets them properly. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|MAX_BANDS_STR_LEN\nvalue|64\nend_define\n\nbegin_struct\nDECL|struct|__anon2bbebb6a0108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\ndecl_stmt|;\nDECL|member|scan_result\nname|uint32_t\nname|scan_result\ndecl_stmt|;\nDECL|union|__anon2bbebb6a020a\nunion|union\nblock|{\nDECL|struct|__anon2bbebb6a0308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\ncase|:\nname|filter\noperator|->\nname|filter\noperator||=\nname|WIFI_PACKET_FILTER_DATA\nexpr_stmt|;\nbreak|break;\ncase|case\nliteral|'d'\ncase|:\nname|filter\noperator|->\nname|filter\noperator||=\nname|WIFI_PACKET_FILTER_CTRL\nexpr_stmt|;\nbreak|break;\ncase|case\nliteral|'i'\ncase|:",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2bbebb6a0108\n+DECL|struct|__anon28c8dc300108\n-DECL|union|__anon2bbebb6a020a\n+DECL|union|__anon28c8dc30020a\n-DECL|struct|__anon2bbebb6a0308\n+DECL|struct|__anon28c8dc300308\n-name|WIFI_PACKET_FILTER_DATA\n+name|WIFI_PACKET_FILTER_CTRL\n-name|WIFI_PACKET_FILTER_CTRL\n+name|WIFI_PACKET_FILTER_DATA\nThe issue was with: net: wifi_shell: Resolve filter settings mismatch\n\nThe control and data settings are set improperly for packet filter\noperation for sniffer operation. The change sets them properly."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: bluetooth: hci_ambiq: add necessary SPI CS control\n\nBefore sending packet to controller the host needs to poll the status of\ncontroller to know it's ready, or before reading packets from controller\nthe host needs to get the payload size of coming packets by sending\nspecific command and putting the status or size to the rx buffer, the CS\nshould be held at this moment to continue to send or receive packets.\nThis change is needed for the based SPI driver update. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|(\nname|size_t\noperator|)\nname|rx_len\nexpr_stmt|;\nreturn|return\nname|spi_transceive\nargument_list|(\nname|spi_dev\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Before sending packet to controller the host needs to poll the status of \t * controller to know it's ready, or before reading packets from controller \t * the host needs to get the payload size of coming packets by sending specific \t * command and putting the status or size to the rx buffer, the CS should be \t * held at this moment to continue to send or receive packets. \t */\n+if|if\n+condition|(\n+name|tx_len\n+operator|&&\n+name|rx_len\n+condition|)\n+block|{\n+name|spi_cfg\n+operator|.\n+name|operation\n+operator||=\n+name|SPI_HOLD_ON_CS\n+expr_stmt|;\n+block|}\n+else|else\n+block|{\n+name|spi_cfg\n+operator|.\n+name|operation\n+operator|&=\n+operator|~\n+name|SPI_HOLD_ON_CS\n+expr_stmt|;\n+block|}\nThe issue was with: drivers: bluetooth: hci_ambiq: add necessary SPI CS control\n\nBefore sending packet to controller the host needs to poll the status of\ncontroller to know it's ready, or before reading packets from controller\nthe host needs to get the payload size of coming packets by sending\nspecific command and putting the status or size to the rx buffer, the CS\nshould be held at this moment to continue to send or receive packets.\nThis change is needed for the based SPI driver update."
},{
  "instruction": "There is an issue in the following code. It relates to samples: basic: blinky_pwm: add testing base on console output\n\nExtend automated testing on HW by veryfing console output. Please fix this issue.",
  "input": "Faulty tokenized code:\n    filter: dt_alias_exists(\"pwm-led0\") and dt_compat_enabled(\"pwm-leds\")\n    tags:\n      - drivers\n      - pwm\n    depends_on: pwm\n   harness: led\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}\nname|period\noperator|=\nname|dir\ncondition|?\noperator|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-    harness: led\n+    harness: console\n+    harness_config:\n+      type: multi_line\n+      ordered: true\n+      regex:\n+        - \"PWM-based blinky\"\n+        - \"Calibrating for channel [0-9]+\"\n+        - \"Done calibrating; maximum/minimum periods [0-9]+/[0-9]+ nsec\"\n+        - \"Using period [0-9]+\"\n+        - \"Using period [0-9]+\"\n+name|printk\n+argument_list|(\n+literal|\"Using period %d\\n\"\n+argument_list|,\n+name|period\n+argument_list|)\n+expr_stmt|;\nThe issue was with: samples: basic: blinky_pwm: add testing base on console output\n\nExtend automated testing on HW by veryfing console output."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: flash: flash_util: params may be unused\n\nThe params variable may be unused depending on the Kconfig options enabled.\n\nFixes: #73697 Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|)\nname|dev\noperator|->\nname|api\ndecl_stmt|;\nspecifier|const\nname|struct\nname|flash_parameters\nmodifier|*\nname|params\ninit|=\nname|api\noperator|->\nname|get_parameters\nargument_list|(\nname|dev\nargument_list|)\ndecl_stmt|;\nif|#\ndirective|if\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_FLASH_HAS_EXPLICIT_ERASE",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|__maybe_unused\n-name|struct\n+expr|struct\n-modifier|*\n+operator|*\n-init|=\n+operator|=\n-decl_stmt|;\n+expr_stmt|;\nThe issue was with: drivers: flash: flash_util: params may be unused\n\nThe params variable may be unused depending on the Kconfig options enabled.\n\nFixes: #73697"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: flash: shell: Add support for devices without erase\n\nShell will now work with devices that do not implement erase callback. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|uint32_t\nname|page_addr\ndecl_stmt|;\nname|int\nname|result\ndecl_stmt|;\nname|uint32_t\nname|size\ndecl_stmt|;\nname|result\noperator|=\nname|parse_helper\nargument_list|(\nname|sh\nargument_list|,\nliteral|\"Erase success.\"\nargument_list|)\nexpr_stmt|;\nblock|}\nreturn|return\nname|result\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+init|=\n+operator|-\n+name|ENOTSUP\n+if|#\n+directive|if\n+name|defined\n+argument_list|(\n+name|CONFIG_FLASH_HAS_EXPLICIT_ERASE\n+argument_list|)\n+endif|#\n+directive|endif\nThe issue was with: drivers: flash: shell: Add support for devices without erase\n\nShell will now work with devices that do not implement erase callback."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: flash: Mark numaker series RMC as no_explicit_erase\n\nThe device is based on ReRAM and does not require erase. Please fix this issue.",
  "input": "Faulty tokenized code:\nconfig SOC_FLASH_NUMAKER_RMC\n\tbool \"Nuvoton NuMaker MCU embedded RRAM memory controller\"\n\tdefault y\n\tselect FLASH_HAS_PAGE_LAYOUT\n\tselect FLASH_HAS_DRIVER_ENABLED\n\tselect HAS_NUMAKER_RMC\n\tdepends on DT_HAS_NUVOTON_NUMAKER_RMC_ENABLED\n\thelp\n\t  This option enables the RMC driver for Nuvoton NuMaker family of\n\t  processors.\nblock|,\noperator|.\nname|erase_value\noperator|=\nliteral|0xff\nblock|, }\ndecl_stmt|;\nend_decl_stmt\n\nbegin_comment",
  "result": "I corrected the issue in the code by changing the following tokens:\n+\tselect FLASH_HAS_NO_EXPLICIT_ERASE\n+block|,\n+operator|.\n+name|caps\n+operator|=\n+block|{\n+operator|.\n+name|no_explicit_erase\n+operator|=\n+name|true\n+block|, \t}\nThe issue was with: drivers: flash: Mark numaker series RMC as no_explicit_erase\n\nThe device is based on ReRAM and does not require erase."
},{
  "instruction": "There is an issue in the following code. It relates to samples/usb/imass: Use flash_area_flatten to wipe storage\n\nThe commit replaces flash_area_erase with flash_area_flatten,\nas it allows to emulate erase and scramble data stored\non devices that do not provide erase callback. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|\"Erasing flash area ... \"\nargument_list|)\nexpr_stmt|;\nname|rc\noperator|=\nname|flash_area_erase\nargument_list|(\nname|pfa\nargument_list|,\nliteral|0\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|flash_area_erase\n+name|flash_area_flatten\nThe issue was with: samples/usb/imass: Use flash_area_flatten to wipe storage\n\nThe commit replaces flash_area_erase with flash_area_flatten,\nas it allows to emulate erase and scramble data stored\non devices that do not provide erase callback."
},{
  "instruction": "There is an issue in the following code. It relates to samples/fs/littlefs: Use flash_area_flatten to wipe storage\n\nThe commit replaces flash_area_erase with flash_area_flatten,\nas it allows to emulate erase and scramble data stored\non devices that do not require explicit erase before write\nor do not provide erase callback. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\ncondition|)\nblock|{\nname|rc\noperator|=\nname|flash_area_erase\nargument_list|(\nname|pfa\nargument_list|,\nliteral|0\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|flash_area_erase\n+name|flash_area_flatten\nThe issue was with: samples/fs/littlefs: Use flash_area_flatten to wipe storage\n\nThe commit replaces flash_area_erase with flash_area_flatten,\nas it allows to emulate erase and scramble data stored\non devices that do not require explicit erase before write\nor do not provide erase callback."
},{
  "instruction": "There is an issue in the following code. It relates to tests: Bluetooth: Mesh: Use flash_area_flatten for erase\n\nThe flash_area_erase is replaced with flash_area_flatten that\nis also able to erase/scramble devices that do not require\nexplicit call to erase procedure before write. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|err\nargument_list|)\nexpr_stmt|;\nname|err\noperator|=\nname|flash_area_erase\nargument_list|(\nname|fa\nargument_list|,\nliteral|0\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|flash_area_erase\n+name|flash_area_flatten\nThe issue was with: tests: Bluetooth: Mesh: Use flash_area_flatten for erase\n\nThe flash_area_erase is replaced with flash_area_flatten that\nis also able to erase/scramble devices that do not require\nexplicit call to erase procedure before write."
},{
  "instruction": "There is an issue in the following code. It relates to tests/dfu: Replace flash_area_erase with flash_area_flatten\n\nUse flash_area_flatten instead of flash_area_erase; this allows\nto run tests on devices that do not require explicit erase\nbefore write or do not provide the callback. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nelse|#\ndirective|else\nname|ret\noperator|=\nname|flash_area_erase\nargument_list|(\nname|ctx\noperator|.\nname|flash_area\nargument_list|,\nliteral|\"Flash img init 1\"\nargument_list|)\nexpr_stmt|;\nname|ret\noperator|=\nname|flash_area_erase\nargument_list|(\nname|ctx\noperator|.\nname|flash_area\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|flash_area_erase\n+name|flash_area_flatten\n-name|flash_area_erase\n+name|flash_area_flatten\nThe issue was with: tests/dfu: Replace flash_area_erase with flash_area_flatten\n\nUse flash_area_flatten instead of flash_area_erase; this allows\nto run tests on devices that do not require explicit erase\nbefore write or do not provide the callback."
},{
  "instruction": "There is an issue in the following code. It relates to dfu/mcuboot: Use flash_area_flatten instead of flash_area_erase\n\nThe invocation of flash_area_erase, in boot_erase_img_bank,\nhas been replaced by flash_area_flatten. Please fix this issue.",
  "input": "Faulty tokenized code:\ndecl_stmt|;\nDECL|member|image_flags\nname|uint32_t\nname|image_flags\ndecl_stmt|;\nDECL|struct|__anon28879a5b0108\nstruct|struct\nblock|{\nDECL|member|major\nname|uint8_t\nname|major\nname|rc\nreturn|;\nblock|}\nname|rc\noperator|=\nname|flash_area_erase\nargument_list|(\nname|fa\nargument_list|,\nliteral|0\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon28879a5b0108\n+DECL|struct|__anon2c5449230108\n-name|flash_area_erase\n+name|flash_area_flatten\nThe issue was with: dfu/mcuboot: Use flash_area_flatten instead of flash_area_erase\n\nThe invocation of flash_area_erase, in boot_erase_img_bank,\nhas been replaced by flash_area_flatten."
},{
  "instruction": "There is an issue in the following code. It relates to mgmt/mcumgr: Replace use of flash_area_erase with flash_area_flatten\n\nThe commit replaces flash_area_erase with flash_area_flatten.\nThe function is used in to places:\n 1) in image management commands IMG_MGMT_ID_UPLOAD\n    and IMG_MGMT_ID_ERASE: to erase an image in secondary slot\n    or to scramble trailer part of image, which could be misunderstood\n    by MCUboot as valid image operation request;\n 2) in command ZEPHYR_MGMT_GRP_BASIC_CMD_ERASE_STORAGE to\n    erase/scramble data partition. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|0\ncondition|)\nblock|{\nname|rc\noperator|=\nname|flash_area_erase\nargument_list|(\nname|fa\nargument_list|,\nliteral|0\nargument_list|,\noperator|->\nname|fa_off\ndecl_stmt|;\nname|rc\noperator|=\nname|flash_area_erase\nargument_list|(\nname|fa\nargument_list|,\nliteral|0\nargument_list|,\noperator|-\nname|off\nexpr_stmt|;\nname|rc\noperator|=\nname|flash_area_erase\nargument_list|(\nname|fa\nargument_list|,\nname|off\nargument_list|,\nblock|}\nelse|else\nblock|{\nname|rc\noperator|=\nname|flash_area_erase\nargument_list|(\nname|fa\nargument_list|,\nliteral|0\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|flash_area_erase\n+name|flash_area_flatten\n-name|flash_area_erase\n+name|flash_area_flatten\n-name|flash_area_erase\n+name|flash_area_flatten\n-name|flash_area_erase\n+name|flash_area_flatten\nThe issue was with: mgmt/mcumgr: Replace use of flash_area_erase with flash_area_flatten\n\nThe commit replaces flash_area_erase with flash_area_flatten.\nThe function is used in to places:\n 1) in image management commands IMG_MGMT_ID_UPLOAD\n    and IMG_MGMT_ID_ERASE: to erase an image in secondary slot\n    or to scramble trailer part of image, which could be misunderstood\n    by MCUboot as valid image operation request;\n 2) in command ZEPHYR_MGMT_GRP_BASIC_CMD_ERASE_STORAGE to\n    erase/scramble data partition."
},{
  "instruction": "There is an issue in the following code. It relates to tests/settings: Move from flash_area_erase to flash_area_flatten\n\nThe Settings test wipe out areas to have a start clean,\nso flash_arae_flatten will do that form them for program-erase\nand no-erase devices. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|++\ncontrol|)\nblock|{\nname|rc\noperator|=\nname|flash_area_erase\nargument_list|(\nname|fap\nargument_list|,\nname|fs\nindex|[\nliteral|\"Can't open storage flash area\"\nargument_list|)\nexpr_stmt|;\nname|err\noperator|=\nname|flash_area_erase\nargument_list|(\nname|fa\nargument_list|,\nliteral|0\nargument_list|,\nname|rc\nargument_list|)\nexpr_stmt|;\nname|rc\noperator|=\nname|flash_area_erase\nargument_list|(\nname|fap\nargument_list|,\nliteral|0\nargument_list|,\nliteral|0\ncondition|)\nblock|{\nname|rc\noperator|=\nname|flash_area_erase\nargument_list|(\nname|fap\nargument_list|,\nliteral|0\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|flash_area_erase\n+name|flash_area_flatten\n-name|flash_area_erase\n+name|flash_area_flatten\n-name|flash_area_erase\n+name|flash_area_flatten\n-name|flash_area_erase\n+name|flash_area_flatten\nThe issue was with: tests/settings: Move from flash_area_erase to flash_area_flatten\n\nThe Settings test wipe out areas to have a start clean,\nso flash_arae_flatten will do that form them for program-erase\nand no-erase devices."
},{
  "instruction": "There is an issue in the following code. It relates to tests/fs: Replace flash_area_erase with flash_area_flatten\n\nTest of file systems use flash_area_erase to erase device\nto have a clear start for tests; switching to flash_area_flatten\nallows them to do the same with devices that do not explicit\ncall to erase procedure before write. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|fa_size\nargument_list|)\nexpr_stmt|;\nname|rc\noperator|=\nname|flash_area_erase\nargument_list|(\nname|pfa\nargument_list|,\nliteral|0\nargument_list|,\noperator|++\ncontrol|)\nblock|{\nname|rc\noperator|=\nname|flash_area_erase\nargument_list|(\nname|fap\nargument_list|,\nname|test_fcb_sector\nindex|[\nname|fa_size\nargument_list|)\nexpr_stmt|;\nname|rc\noperator|=\nname|flash_area_erase\nargument_list|(\nname|pfa\nargument_list|,\nliteral|0\nargument_list|,\nname|rc\nargument_list|)\nexpr_stmt|;\nname|rc\noperator|=\nname|flash_area_erase\nargument_list|(\nname|fap\nargument_list|,\nliteral|0\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|flash_area_erase\n+name|flash_area_flatten\n-name|flash_area_erase\n+name|flash_area_flatten\n-name|flash_area_erase\n+name|flash_area_flatten\n-name|flash_area_erase\n+name|flash_area_flatten\nThe issue was with: tests/fs: Replace flash_area_erase with flash_area_flatten\n\nTest of file systems use flash_area_erase to erase device\nto have a clear start for tests; switching to flash_area_flatten\nallows them to do the same with devices that do not explicit\ncall to erase procedure before write."
},{
  "instruction": "There is an issue in the following code. It relates to fs/fcb: Replace flash_area_erase with flash_area_flatten\n\nFCB depends on explicit erase characteristics of a device. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|EIO\nreturn|;\nblock|}\nname|rc\noperator|=\nname|flash_area_erase\nargument_list|(\nname|fcb\noperator|->\nname|fap\nargument_list|,\n      - native_sim/native/64\n      - mr_canhubk3\n    tags: flash_circural_buffer\n    integration_platforms:\n      - nrf52840dk/nrf52840\n  filesystem.fcb.native_sim.fcb_0x00:\n    extra_args: DTC_OVERLAY_FILE=boards/native_sim_ev_0x00.overlay\n    platform_allow: native_sim\n  filesystem.fcb.qemu_x86.fcb_0x00:\n    extra_args: DTC_OVERLAY_FILE=boards/qemu_x86_ev_0x00.overlay",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|flash_area_erase\n+name|flash_area_flatten\n+  filesystem.fcb.no_erase:\n+    platform_allow:\n+      - nrf54l15pdk/nrf54l15/cpuapp\n+  filesystem.fcb.native_sim.no_erase:\n+    extra_args: CONFIG_FLASH_SIMULATOR_EXPLICIT_ERASE=n\n+    platform_allow: native_sim\nThe issue was with: fs/fcb: Replace flash_area_erase with flash_area_flatten\n\nFCB depends on explicit erase characteristics of a device."
},{
  "instruction": "There is an issue in the following code. It relates to storage/settings: Replace flash_area_erase with flash_area_flatten\n\nReplace flash_area_erase with flash_area_flatten to allow FCB\nSettings backend to work on devices that do not provide erase\ncallback. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|1\ncondition|)\nblock|{\nname|rc\noperator|=\nname|flash_area_erase\nargument_list|(\nname|cf\noperator|->\nname|cf_fcb\noperator|.\nname|rc\nreturn|;\nblock|}\nname|rc\noperator|=\nname|flash_area_erase\nargument_list|(\nname|fap\nargument_list|,\nliteral|0\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|flash_area_erase\n+name|flash_area_flatten\n-name|flash_area_erase\n+name|flash_area_flatten\nThe issue was with: storage/settings: Replace flash_area_erase with flash_area_flatten\n\nReplace flash_area_erase with flash_area_flatten to allow FCB\nSettings backend to work on devices that do not provide erase\ncallback."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Mesh: Switch erase to flash_area_flatten\n\nThe flash_area_erase has been replaced with flash_area_flatten,\nallowing code to work with devices that do not provide\nerase callback. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|size\nexpr_stmt|;\nendif|#\ndirective|endif\nreturn|return\nname|flash_area_erase\nargument_list|(\nname|flash\noperator|->\nname|area\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|flash_area_erase\n+name|flash_area_flatten\nThe issue was with: Bluetooth: Mesh: Switch erase to flash_area_flatten\n\nThe flash_area_erase has been replaced with flash_area_flatten,\nallowing code to work with devices that do not provide\nerase callback."
},{
  "instruction": "There is an issue in the following code. It relates to drivers/flash/Ambiq: Set erase capabilities, depending on SoC\n\nThe commit selects HAS_NO_EXPLICIT_ERASE for Apollo4,\nwith MRAM, and HAS_EXPLICIT_ERASE for Apollo3 which has Flash,\nfor a driver that shares code between SoCs.\n\nIn case of Apollo4 the no_explicit_erase capability is set to\ntrue, while it remains false for Apollo3. Please fix this issue.",
  "input": "Faulty tokenized code:\n\tdefault y\n\tdepends on DT_HAS_AMBIQ_FLASH_CONTROLLER_ENABLED\n\tselect AMBIQ_HAL\n\tselect FLASH_HAS_PAGE_LAYOUT\n\tselect FLASH_HAS_DRIVER_ENABLED\n\thelp\n\t  Enables Ambiq flash driver on MRAM (e.g. Apollo4x) or\n\t  flash (e.g. Apollo3x).\nblock|,\noperator|.\nname|erase_value\noperator|=\nname|FLASH_ERASE_BYTE\nblock|, }\ndecl_stmt|;\nend_decl_stmt\n\nbegin_function\nDECL|function|flash_ambiq_valid_range (off_t offset,size_t len)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+\tselect FLASH_HAS_NO_EXPLICIT_ERASE if SOC_SERIES_APOLLO4X\n+\tselect FLASH_HAS_EXPLICIT_ERASE if SOC_SERIES_APOLLO3X\n-block|, }\n+block|,\n+if|#\n+directive|if\n+name|defined\n+argument_list|(\n+name|CONFIG_SOC_SERIES_APOLLO4X\n+argument_list|)\n+operator|.\n+name|caps\n+operator|=\n+block|{\n+operator|.\n+name|no_explicit_erase\n+operator|=\n+name|true\n+block|, \t}\n+block|,\n+endif|#\n+directive|endif\n+block|}\nThe issue was with: drivers/flash/Ambiq: Set erase capabilities, depending on SoC\n\nThe commit selects HAS_NO_EXPLICIT_ERASE for Apollo4,\nwith MRAM, and HAS_EXPLICIT_ERASE for Apollo3 which has Flash,\nfor a driver that shares code between SoCs.\n\nIn case of Apollo4 the no_explicit_erase capability is set to\ntrue, while it remains false for Apollo3."
},{
  "instruction": "There is an issue in the following code. It relates to drivers/flash/nrf_mram: Set no explicit erase capability to true\n\nNRF MRAM does not require erase prior to re-programming already\nwritten area. Please fix this issue.",
  "input": "Faulty tokenized code:\n\tbool \"Nordic Semiconductor flash driver for MRAM\"\n\tdefault y\n\tdepends on DT_HAS_NORDIC_MRAM_ENABLED\n\tselect FLASH_HAS_DRIVER_ENABLED\n\tselect FLASH_HAS_PAGE_LAYOUT\n\timply MPU_ALLOW_FLASH_WRITE if ARM_MPU\n\thelp\n\t  Enables Nordic Semiconductor flash driver for MRAM in direct write mode.\n\n\t  Note that MRAM words are auto-erased when written to, but writing to a\nblock|,\noperator|.\nname|erase_value\noperator|=\nname|ERASE_VALUE\nblock|, \t}\ndecl_stmt|;\nreturn|return\noperator|&\nname|parameters",
  "result": "I corrected the issue in the code by changing the following tokens:\n+\tselect FLASH_HAS_NO_EXPLICIT_ERASE\n+block|,\n+operator|.\n+name|caps\n+operator|=\n+block|{\n+operator|.\n+name|no_explicit_erase\n+operator|=\n+name|true\n+block|, \t\t}\nThe issue was with: drivers/flash/nrf_mram: Set no explicit erase capability to true\n\nNRF MRAM does not require erase prior to re-programming already\nwritten area."
},{
  "instruction": "There is an issue in the following code. It relates to drivers/flash/nrf_rram: Set no explicit erase capability to true\n\nNRF RRAM does not require erase prior to re-programming already\nwritten area. Please fix this issue.",
  "input": "Faulty tokenized code:\n\tdefault y\n\tdepends on DT_HAS_NORDIC_RRAM_CONTROLLER_ENABLED\n\tselect NRFX_RRAMC\n\tselect FLASH_HAS_DRIVER_ENABLED\n\tselect FLASH_HAS_PAGE_LAYOUT\n\tselect FLASH_NRF_FORCE_ALT\n\tselect MPU_ALLOW_FLASH_WRITE if ARM_MPU\n\thelp\n\t  Enables Nordic Semiconductor flash driver for nRF RRAM controllers.\n\t  The entire contiguous block of RRAM gets logically divided into pages,\nblock|,\noperator|.\nname|erase_value\noperator|=\nname|ERASE_VALUE\nblock|, \t}\ndecl_stmt|;\nreturn|return\noperator|&\nname|parameters",
  "result": "I corrected the issue in the code by changing the following tokens:\n+\tselect FLASH_HAS_NO_EXPLICIT_ERASE\n+block|,\n+operator|.\n+name|caps\n+operator|=\n+block|{\n+operator|.\n+name|no_explicit_erase\n+operator|=\n+name|true\n+block|, \t\t}\nThe issue was with: drivers/flash/nrf_rram: Set no explicit erase capability to true\n\nNRF RRAM does not require erase prior to re-programming already\nwritten area."
},{
  "instruction": "There is an issue in the following code. It relates to drivers/flash/nrf: Mark driver as FLASH_HAS_EXPLICIT_ERASE\n\nSelect CONFIG_FLASH_HAS_EXPLICIT_ERASE for the NRF driver. Please fix this issue.",
  "input": "Faulty tokenized code:\n\t\t   DT_HAS_NORDIC_NRF53_FLASH_CONTROLLER_ENABLED || \\\n\t\t   DT_HAS_NORDIC_NRF91_FLASH_CONTROLLER_ENABLED\n\tdepends on !FLASH_NRF_FORCE_ALT\n\tselect FLASH_HAS_PAGE_LAYOUT\n\tselect FLASH_HAS_DRIVER_ENABLED\n\tselect NRFX_NVMC\n\tselect MPU_ALLOW_FLASH_WRITE if ARM_MPU\n\thelp\n\t  Enables Nordic Semiconductor nRF flash driver.\n\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright (c) 2017-2023 Nordic Semiconductor ASA  * Copyright (c) 2016 Linaro Limited  * Copyright (c) 2016 Intel Corporation  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+\tselect FLASH_HAS_EXPLICIT_ERASE\n-comment|/*  * Copyright (c) 2017-2023 Nordic Semiconductor ASA  * Copyright (c) 2016 Linaro Limited  * Copyright (c) 2016 Intel Corporation  *  * SPDX-License-Identifier: Apache-2.0  */\n+comment|/*  * Copyright (c) 2017-2024 Nordic Semiconductor ASA  * Copyright (c) 2016 Linaro Limited  * Copyright (c) 2016 Intel Corporation  *  * SPDX-License-Identifier: Apache-2.0  */\nThe issue was with: drivers/flash/nrf: Mark driver as FLASH_HAS_EXPLICIT_ERASE\n\nSelect CONFIG_FLASH_HAS_EXPLICIT_ERASE for the NRF driver."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: espi: npcx: add support 66MHz eSPI clock\n\nThis CL adds support 66MHz eSPI clock for NPCX4. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|NPCX_ESPI_MAXFREQ_50\nvalue|3\nend_define\n\nbegin_comment\ncomment|/* Minimum delay before acknowledging a virtual wire */\nend_comment\n\nbegin_define\nname|max_freq\noperator|=\nname|NPCX_ESPI_MAXFREQ_50\nexpr_stmt|;\nbreak|break;\ndefault|default:\nreturn|return\noperator|-\nname|EINVAL\nreturn|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_define\n+DECL|macro|NPCX_ESPI_MAXFREQ_66\n+define|#\n+directive|define\n+name|NPCX_ESPI_MAXFREQ_66\n+value|4\n+end_define\n+\n+ifdef|#\n+directive|ifdef\n+name|CONFIG_SOC_SERIES_NPCX4\n+case|case\n+literal|66\n+case|:\n+name|max_freq\n+operator|=\n+name|NPCX_ESPI_MAXFREQ_66\n+expr_stmt|;\n+break|break;\n+endif|#\n+directive|endif\nThe issue was with: drivers: espi: npcx: add support 66MHz eSPI clock\n\nThis CL adds support 66MHz eSPI clock for NPCX4."
},{
  "instruction": "There is an issue in the following code. It relates to usb: device_next: Update remote wakeup log level\n\nThe `Remote wakeup feature not enabled or not suspended` log is not\nrelated to an actual error (connected host might not enable USB remote\nwakeup feature). Use warning log level. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|uds_ctx\nargument_list|)\ncondition|)\nblock|{\nname|LOG_ERR\nargument_list|(\nliteral|\"Remote wakeup feature not enabled or not suspended\"\nargument_list|)\nexpr_stmt|;\nname|ret",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|LOG_ERR\n+name|LOG_WRN\nThe issue was with: usb: device_next: Update remote wakeup log level\n\nThe `Remote wakeup feature not enabled or not suspended` log is not\nrelated to an actual error (connected host might not enable USB remote\nwakeup feature). Use warning log level."
},{
  "instruction": "There is an issue in the following code. It relates to coding guidelines: comply with MISRA Rule 12.1.\n\n-added parentheses verifying lack of ambiguities Please fix this issue.",
  "input": "Faulty tokenized code:\ndecl_stmt|;\nname|printk\nargument_list|(\nliteral|\"%c\"\nargument_list|,\nname|isprint\nargument_list|(\noperator|(\nname|int\noperator|)\nname|c\nargument_list|)\noperator|!=\nliteral|0\ncondition|?\nname|c\nelse|:\nliteral|'.'\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+operator|)\nThe issue was with: coding guidelines: comply with MISRA Rule 12.1.\n\n-added parentheses verifying lack of ambiguities"
},{
  "instruction": "There is an issue in the following code. It relates to coding guidelines: comply with MISRA Rule 11.8\n\n- modified parameter types to receive a const pointer when a\n  non-const pointer is not needed Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nend_macro\n\nbegin_block\nblock|{\nname|struct\nname|z_device_mmio_rom\nmodifier|*\nname|rom\ndecl_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+specifier|const\nThe issue was with: coding guidelines: comply with MISRA Rule 11.8\n\n- modified parameter types to receive a const pointer when a\n  non-const pointer is not needed"
},{
  "instruction": "There is an issue in the following code. It relates to intel_adsp/ace: power: fix address space annotation for powerdown\n\npower_down() expects a cached pointer. Fix the sparse annotation\nto match the implementation (sys_cache_cached_ptr_get() returns a cached\npointer so this is correct). Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|(\nname|bool\nname|disable_lpsram\nparameter_list|,\nname|uint32_t\nmodifier|*\nname|hpsram_pg_mask\nparameter_list|,\nname|bool\nname|response_to_ipc",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|__sparse_cache\nThe issue was with: intel_adsp/ace: power: fix address space annotation for powerdown\n\npower_down() expects a cached pointer. Fix the sparse annotation\nto match the implementation (sys_cache_cached_ptr_get() returns a cached\npointer so this is correct)."
},{
  "instruction": "There is an issue in the following code. It relates to boards nrf_bsim: Add NVIC_GetEnableIRQ()\n\nProvide a replacement for CMSIS' NVIC_GetEnableIRQ()\nas some applications use it. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|NVIC_SetPriority (IRQn_Type IRQn,uint32_t priority)\nname|void\nname|NVIC_SetPriority\nparameter_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_function\n+DECL|function|NVIC_GetEnableIRQ (IRQn_Type IRQn)\n+name|uint32_t\n+name|NVIC_GetEnableIRQ\n+parameter_list|(\n+name|IRQn_Type\n+name|IRQn\n+parameter_list|)\n+block|{\n+return|return\n+name|hw_irq_ctrl_is_irq_enabled\n+argument_list|(\n+name|CONFIG_NATIVE_SIMULATOR_MCU_N\n+argument_list|,\n+name|IRQn\n+argument_list|)\n+return|;\n+block|}\n+end_function\n+\nThe issue was with: boards nrf_bsim: Add NVIC_GetEnableIRQ()\n\nProvide a replacement for CMSIS' NVIC_GetEnableIRQ()\nas some applications use it."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Document reasons for HCI command timeouts\n\nWhen reading the error message:\n\\\"ASSERTION_FAIL: command opcode 0x0c03 timeout with err -11\\\" it may not be\nobvious what is wrong with their setup unless you are very familiar\nwith HCI.\n\nThis commit adds some more documentation to make this more obvious. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|buf\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|err\noperator|=\nname|k_sem_take\nargument_list|(\noperator|&\nargument_list|(\nname|err\noperator|==\nliteral|0\nargument_list|,\nliteral|\"command opcode 0x%04x timeout with err %d\"\nargument_list|,\nname|opcode\nargument_list|,\nname|err\nargument_list|)\nname|hci_vs_init\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nDECL|union|__anon2aa99e39010a\nunion|union\nblock|{\nDECL|member|info\nname|struct\nname|bt_hci_rp_vs_read_version_info",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Wait for a response from the Bluetooth Controller. \t * The Controller may fail to respond if: \t *  - It was never programmed or connected. \t *  - There was a fatal error. \t * \t * See the `BT_HCI_OP_` macros in hci_types.h or \t * Core_v5.4, Vol 4, Part E, Section 5.4.1 and Section 7 \t * to map the opcode to the HCI command documentation. \t * Example: 0x0c03 represents HCI_Reset command. \t */\n-literal|\"command opcode 0x%04x timeout with err %d\"\n+literal|\"Controller unresponsive, command opcode 0x%04x timeout with err %d\"\n-DECL|union|__anon2aa99e39010a\n+DECL|union|__anon29480b58010a\nThe issue was with: Bluetooth: Document reasons for HCI command timeouts\n\nWhen reading the error message:\n\\\"ASSERTION_FAIL: command opcode 0x0c03 timeout with err -11\\\" it may not be\nobvious what is wrong with their setup unless you are very familiar\nwith HCI.\n\nThis commit adds some more documentation to make this more obvious."
},{
  "instruction": "There is an issue in the following code. It relates to net: http_server: Send chunked response correctly\n\nThe chunked response was not sent properly. There were extra\n\\\"\\r\\n\\\" before the chunk lenght and the length of the string\nto be sent was calculated incorrectly.\n\nFixes #72887 Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|(\nname|_template\nparameter_list|,\nname|_content_type\nparameter_list|)\nvalue|({\t\t\t\\ \tchar http_response[sizeof(_template) +\t\t\t\t\\ \t\t\t   sizeof(\"Content-Type: \\r\\n\") +\t\t\\ \t\t\t   HTTP_SERVER_MAX_CONTENT_TYPE_LEN +\t\t\\ \t\t\t   sizeof(\"xxxx\") +\t\t\t\t\\ \t\t\t   sizeof(\"\\r\\n\")];\t\t\t\t\\ \tsnprintk(http_response, sizeof(http_response),\t\t\t\\ \t\t _template \"\\r\\n\",\t\t\t\t\t\\ \t\t \"Content-Type: \",\t\t\t\t\t\\ \t\t _content_type == NULL ?\t\t\t\t\\ \t\t \"text/html\" : _content_type);\t\t\t\t\\ \tret = http_server_sendall(client, http_response,\t\t\\ \t\t\t\t  strnlen(http_response,\t\t\\ \t\t\t\t\t  sizeof(_template) - 1));\t\\ \tret; })\nend_define\n\nbegin_function\nDECL|function|dynamic_get_req (struct http_resource_detail_dynamic * dynamic_detail,struct http_client_ctx * client)\nspecifier|static",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|({\t\t\t\\ \tchar http_response[sizeof(_template) +\t\t\t\t\\ \t\t\t   sizeof(\"Content-Type: \\r\\n\") +\t\t\\ \t\t\t   HTTP_SERVER_MAX_CONTENT_TYPE_LEN +\t\t\\ \t\t\t   sizeof(\"xxxx\") +\t\t\t\t\\ \t\t\t   sizeof(\"\\r\\n\")];\t\t\t\t\\ \tsnprintk(http_response, sizeof(http_response),\t\t\t\\ \t\t _template \"\\r\\n\",\t\t\t\t\t\\ \t\t \"Content-Type: \",\t\t\t\t\t\\ \t\t _content_type == NULL ?\t\t\t\t\\ \t\t \"text/html\" : _content_type);\t\t\t\t\\ \tret = http_server_sendall(client, http_response,\t\t\\ \t\t\t\t  strnlen(http_response,\t\t\\ \t\t\t\t\t  sizeof(_template) - 1));\t\\ \tret; })\n+value|({\t\t\t\\ \tchar http_response[sizeof(_template) +\t\t\t\t\\ \t\t\t   sizeof(\"Content-Type: \\r\\n\") +\t\t\\ \t\t\t   HTTP_SERVER_MAX_CONTENT_TYPE_LEN +\t\t\\ \t\t\t   sizeof(\"xxxx\") +\t\t\t\t\\ \t\t\t   sizeof(\"\\r\\n\")];\t\t\t\t\\ \tsnprintk(http_response, sizeof(http_response),\t\t\t\\ \t\t _template,\t\t\t\t\t\t\\ \t\t \"Content-Type: \",\t\t\t\t\t\\ \t\t _content_type == NULL ?\t\t\t\t\\ \t\t \"text/html\" : _content_type);\t\t\t\t\\ \tret = http_server_sendall(client, http_response,\t\t\\ \t\t\t\t  strnlen(http_response,\t\t\\ \t\t\t\t\t  sizeof(http_response) - 1));\t\\ \tret; })\nThe issue was with: net: http_server: Send chunked response correctly\n\nThe chunked response was not sent properly. There were extra\n\\\"\\r\\n\\\" before the chunk lenght and the length of the string\nto be sent was calculated incorrectly.\n\nFixes #72887"
},{
  "instruction": "There is an issue in the following code. It relates to usb: device_next: initialize BOS device caps number\n\nExplicitly initialize bNumDeviceCaps to 0 because the bos descriptor is\nstored on stack.\n\nFixes: dafd3a930c00 [formerly b0d7d70834ab] (\\\"usb: device_next: add initial BOS support\\\")\nCoverity-CID: 368798 Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|=\nname|root\noperator|->\nname|bLength\nexpr_stmt|;\nname|SYS_DLIST_FOR_EACH_CONTAINER\nargument_list|(\nargument|&uds_ctx->descriptors\nargument_list|,\nargument|desc_nd",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|root\n+operator|->\n+name|bNumDeviceCaps\n+operator|=\n+literal|0\n+expr_stmt|;\nThe issue was with: usb: device_next: initialize BOS device caps number\n\nExplicitly initialize bNumDeviceCaps to 0 because the bos descriptor is\nstored on stack.\n\nFixes: dafd3a930c00 [formerly b0d7d70834ab] (\\\"usb: device_next: add initial BOS support\\\")\nCoverity-CID: 368798"
},{
  "instruction": "There is an issue in the following code. It relates to boards: nxp: vmu_rt1170: fix dummy cycle value in flash configuration\n\nThe VMURT1170 board configures the FLEXSPI to run at 200MHz serial clock\nin DDR mode, via the flash configuration block passed to the ROM API.\nPer the datasheet of the MX25UM51345G flash present on the board, 20\ndummy cycles are required before reading data in OPI DTR mode. Correct\nthe dummy cycle value used for read commands to 0x28 (40 DDR dummy\ncycles, equivalent to 20 dummy cycles of the clock) to resolve this\nissue. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright (c) 2019, MADMACHINE LIMITED  *  * refer to hal_nxp board file  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nargument_list|,\nname|DUMMY_DDR\nargument_list|,\nname|FLEXSPI_8PAD\nargument_list|,\nliteral|0x04\nargument_list|)\nblock|,\nindex|[\nliteral|0\noperator|+",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/*  * Copyright (c) 2019, MADMACHINE LIMITED  *  * refer to hal_nxp board file  *  * SPDX-License-Identifier: Apache-2.0  */\n+comment|/*  * Copyright (c) 2019, MADMACHINE LIMITED  * Copyright 2024 NXP  *  * refer to hal_nxp board file  *  * SPDX-License-Identifier: Apache-2.0  */\n-literal|0x04\n+literal|0x28\nThe issue was with: boards: nxp: vmu_rt1170: fix dummy cycle value in flash configuration\n\nThe VMURT1170 board configures the FLEXSPI to run at 200MHz serial clock\nin DDR mode, via the flash configuration block passed to the ROM API.\nPer the datasheet of the MX25UM51345G flash present on the board, 20\ndummy cycles are required before reading data in OPI DTR mode. Correct\nthe dummy cycle value used for read commands to 0x28 (40 DDR dummy\ncycles, equivalent to 20 dummy cycles of the clock) to resolve this\nissue."
},{
  "instruction": "There is an issue in the following code. It relates to net: lwm2m: Block-Wise response NUM field fix\n\nWhen calculating the offset for blockwise writes,\nwe should not advance the block_ctx->current field\npast the block boundary.\nIt causes CoAP layer to reply with the next NUM field\ninstead of the current one being processed. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|msg\noperator|->\nname|in\noperator|.\nname|block_ctx\ncondition|)\nblock|{\nname|msg\noperator|->\nname|in",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|&&\n+operator|!\n+name|last_pkt_block\nThe issue was with: net: lwm2m: Block-Wise response NUM field fix\n\nWhen calculating the offset for blockwise writes,\nwe should not advance the block_ctx->current field\npast the block boundary.\nIt causes CoAP layer to reply with the next NUM field\ninstead of the current one being processed."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: rtc: rtc_shell: fix milliseconds display\n\nThe RTC shell get command displays the time according to the ISO8601\nstandard. Fix the milliseconds field to be displayed on 3 digits instead\nof 6 like if they were microseconds. In addition change the separator\nbetween seconds and milliseconds to a dot like specified in the ISO8601\nstandard.\n\nBefore:\n2024-06-02T22:33:10:000667\n\nAfter:\n2024-06-02T22:33:10.667 Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nname|shell_print\nargument_list|(\nname|sh\nargument_list|,\nliteral|\"%04d-%02d-%02dT%02d:%02d:%02d:%06d\"\nargument_list|,\nname|rtctime\noperator|.\nname|tm_year\noperator|+",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"%04d-%02d-%02dT%02d:%02d:%02d:%06d\"\n+literal|\"%04d-%02d-%02dT%02d:%02d:%02d.%03d\"\nThe issue was with: drivers: rtc: rtc_shell: fix milliseconds display\n\nThe RTC shell get command displays the time according to the ISO8601\nstandard. Fix the milliseconds field to be displayed on 3 digits instead\nof 6 like if they were microseconds. In addition change the separator\nbetween seconds and milliseconds to a dot like specified in the ISO8601\nstandard.\n\nBefore:\n2024-06-02T22:33:10:000667\n\nAfter:\n2024-06-02T22:33:10.667"
},{
  "instruction": "There is an issue in the following code. It relates to arch: arm64: create ARM64_EXCEPTION_STACK_TRACE\n\nCurrently, the stack trace in ARM64 implementation depends on\nframe pointer Kconfigs combo to be enabled. Create a dedicated\nKconfig for that instead, so that it is consistent with x86 and\nriscv, and update the source accordingly. Please fix this issue.",
  "input": "Faulty tokenized code:\n\t  Deprecated. Use CONFIG_FRAME_POINTER instead.\n\t  Hidden option to simplify access to OVERRIDE_FRAME_POINTER_DEFAULT\n\t  and OMIT_FRAME_POINTER. It is automatically enabled when the frame\n\t  pointer unwinding is enabled.\n\nconfig ARM64_SAFE_EXCEPTION_STACK_SIZE\n\tint \"The stack size of the safe exception stack\"\n\tdefault 4096\n\tdepends on ARM64_SAFE_EXCEPTION_STACK\n\thelp\nend_function\n\nbegin_ifdef\nifdef|#\ndirective|ifdef\nname|CONFIG_FRAME_POINTER\nend_ifdef\n\nbegin_function\nDECL|function|esf_unwind (const z_arch_esf_t * esf)\nspecifier|static\nargument_list|)\nexpr_stmt|;\nblock|}\nifdef|#\ndirective|ifdef\nname|CONFIG_FRAME_POINTER\nname|esf_unwind\nargument_list|(\nname|esf\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\ncomment|/* CONFIG_FRAME_POINTER */\nendif|#\ndirective|endif\ncomment|/* CONFIG_EXCEPTION_DEBUG */\nname|z_fatal_error\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+config ARM64_EXCEPTION_STACK_TRACE\n+\tbool\n+\tdefault y\n+\tdepends on FRAME_POINTER\n+\thelp\n+\t  Internal config to enable runtime stack traces on fatal exceptions.\n+\n-name|CONFIG_FRAME_POINTER\n+name|CONFIG_ARM64_EXCEPTION_STACK_TRACE\n-name|CONFIG_FRAME_POINTER\n+name|CONFIG_ARM64_EXCEPTION_STACK_TRACE\n-comment|/* CONFIG_FRAME_POINTER */\n+comment|/* CONFIG_ARM64_EXCEPTION_STACK_TRACE */\nThe issue was with: arch: arm64: create ARM64_EXCEPTION_STACK_TRACE\n\nCurrently, the stack trace in ARM64 implementation depends on\nframe pointer Kconfigs combo to be enabled. Create a dedicated\nKconfig for that instead, so that it is consistent with x86 and\nriscv, and update the source accordingly."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: can: mcan: skip read/write to mram if data length is 0\n\ncan_mcan_send/can_mcan_get_message issued a message ram write/read even\nwhen data length was 0. This caused some issues on systems where data\ncache is enabled, because the cache invd/flushing calls present in the\nmcan driver can fail if provided length is 0. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|&\nname|CAN_FRAME_RTR\noperator|)\noperator|==\nliteral|0U\ncondition|)\nblock|{\nname|err\noperator|=\nname|can_mcan_read_mram\noperator|&\nname|CAN_FRAME_RTR\noperator|)\noperator|==\nliteral|0U\ncondition|)\nblock|{\nname|err\noperator|=\nname|can_mcan_write_mram",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|&&\n+name|data_length\n+operator|!=\n+literal|0U\n+operator|&&\n+name|data_length\n+operator|!=\n+literal|0U\nThe issue was with: drivers: can: mcan: skip read/write to mram if data length is 0\n\ncan_mcan_send/can_mcan_get_message issued a message ram write/read even\nwhen data length was 0. This caused some issues on systems where data\ncache is enabled, because the cache invd/flushing calls present in the\nmcan driver can fail if provided length is 0."
},{
  "instruction": "There is an issue in the following code. It relates to net: dns: llmnr_responder: Print query type properly\n\nInstead of printing either A or AAAA resource query type,\nprint the correct query type value. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nliteral|\"[%d] query %s/%s label %s (%d bytes)\"\nargument_list|,\nname|queries\nargument_list|,\nname|qtype\noperator|==\nname|DNS_RR_TYPE_A\ncondition|?\nliteral|\"A\"\nelse|:\nliteral|\"AAAA\"\nargument_list|,\nliteral|\"IN\"\nargument_list|,\nname|result\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|dns_qtype_to_str\n+argument_list|(\n-operator|==\n-name|DNS_RR_TYPE_A\n-condition|?\n-literal|\"A\"\n-else|:\n-literal|\"AAAA\"\n+argument_list|)\nThe issue was with: net: dns: llmnr_responder: Print query type properly\n\nInstead of printing either A or AAAA resource query type,\nprint the correct query type value."
},{
  "instruction": "There is an issue in the following code. It relates to net: dns: Add ANY query resource type\n\nDon't give an error for ANY type record. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|DNS_RR_TYPE_SRV\noperator|&&\nname|query_type\noperator|!=\nname|DNS_RR_TYPE_TXT\ncondition|)\nblock|{\nreturn|return\noperator|-\nname|EINVAL\nname|DNS_RR_TYPE_SRV\ninit|=\nliteral|33\nblock|,\ncomment|/* SRV   */\nblock|}\nenum|;\nend_enum\n\nbegin_enum",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|&&\n+name|query_type\n+operator|!=\n+name|DNS_RR_TYPE_ANY\n+DECL|enumerator|DNS_RR_TYPE_ANY\n+name|DNS_RR_TYPE_ANY\n+init|=\n+literal|0xff\n+block|,\n+comment|/* ANY (all records)   */\nThe issue was with: net: dns: Add ANY query resource type\n\nDon't give an error for ANY type record."
},{
  "instruction": "There is an issue in the following code. It relates to tests: net: socket: af_packet: fix TSN socket recv IP pkt\n\ntest_packet_sockets_dgram create ETH_P_TSN sockets but\nsend and recv ETH_P_IP packet.\n\nFix it by sending ETH_P_TSN packet. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|.\nname|sll_protocol\noperator|=\nname|htons\nargument_list|(\nname|ETH_P_IP\nargument_list|)\nexpr_stmt|;\nname|memcpy\nargument_list|(\nname|dst",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|ETH_P_IP\n+name|ETH_P_TSN\nThe issue was with: tests: net: socket: af_packet: fix TSN socket recv IP pkt\n\ntest_packet_sockets_dgram create ETH_P_TSN sockets but\nsend and recv ETH_P_IP packet.\n\nFix it by sending ETH_P_TSN packet."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: akm09918c: fix decoder api define\n\nDecoder api was not defined and lead to build error\nif it is used in userland.\nFix that by adding necessary DT_DRV_COMPAT #define\nin akm09918c sensor decoder. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|\"akm09918c.h\"\nend_include\n\nbegin_function\nDECL|function|akm09918c_decoder_get_frame_count (const uint8_t * buffer,struct sensor_chan_spec chan_spec,uint16_t * frame_count)\nspecifier|static\nname|int\nname|akm09918c_decoder_get_frame_count",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_define\n+DECL|macro|DT_DRV_COMPAT\n+define|#\n+directive|define\n+name|DT_DRV_COMPAT\n+value|asahi_kasei_akm09918c\n+end_define\n+\nThe issue was with: drivers: sensor: akm09918c: fix decoder api define\n\nDecoder api was not defined and lead to build error\nif it is used in userland.\nFix that by adding necessary DT_DRV_COMPAT #define\nin akm09918c sensor decoder."
},{
  "instruction": "There is an issue in the following code. It relates to samples: video: tcpserversink: fix build failure\n\nThe nxp,imx-csi node was removed from dts in a previous commit\nwhich caused a build failure / regression in CI.\n\nUse DEVICE_DT_GET_ANY() instead of DEVICE_DT_GET_ONE(), since\nthe latter requires a DT node present, while the former does\nnot and returns NULL if no such compat exists. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|device\nmodifier|*\nspecifier|const\nname|video\ninit|=\nname|DEVICE_DT_GET_ONE\nargument_list|(\nname|nxp_imx_csi\nargument_list|)\ndecl_stmt|;\ncomment|/* Prepare Network */",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|DEVICE_DT_GET_ONE\n+name|DEVICE_DT_GET_ANY\nThe issue was with: samples: video: tcpserversink: fix build failure\n\nThe nxp,imx-csi node was removed from dts in a previous commit\nwhich caused a build failure / regression in CI.\n\nUse DEVICE_DT_GET_ANY() instead of DEVICE_DT_GET_ONE(), since\nthe latter requires a DT node present, while the former does\nnot and returns NULL if no such compat exists."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: ieee802154: nrf5: sleep if idle when RxOnWhenIdle=0\n\nWhen RxOnWhenIdle is set to False, turn the radio off\nif no operation is ongoing in order to save power. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|=\nname|config\noperator|->\nname|rx_on_when_idle\nexpr_stmt|;\nbreak|break;\ndefault|default:\nreturn|return\noperator|-\nname|EINVAL",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|config\n+operator|->\n+name|rx_on_when_idle\n+operator|==\n+name|false\n+condition|)\n+block|{\n+operator|(\n+name|void\n+operator|)\n+name|nrf_802154_sleep_if_idle\n+argument_list|()\n+expr_stmt|;\n+block|}\nThe issue was with: drivers: ieee802154: nrf5: sleep if idle when RxOnWhenIdle=0\n\nWhen RxOnWhenIdle is set to False, turn the radio off\nif no operation is ongoing in order to save power."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: clock_control: add a soc config macro wrap flexbus clock\n\nke17z7 platform does not define flexbus clock-related macros,\nso comment it out. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright (c) 2019-2021 Vestas Wind Systems A/S  * Copyright 2024 NXP  *  * Based on clock_control_mcux_sim.c, which is:  * Copyright (c) 2017, NXP  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_define\nDECL|macro|DT_DRV_COMPAT\ndefine|#\nname|clock_name\noperator|=\nname|kCLOCK_BusClk\nexpr_stmt|;\nbreak|break;\ncase|case\nname|KINETIS_SCG_FLEXBUS_CLK\ncase|:\nname|clock_name\noperator|=\nname|kCLOCK_FlexBusClk\nexpr_stmt|;\nbreak|break;\ncase|case\nname|KINETIS_SCG_FLASH_CLK\ncase|:\nname|clock_name\noperator|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/*  * Copyright (c) 2019-2021 Vestas Wind Systems A/S  * Copyright 2024 NXP  *  * Based on clock_control_mcux_sim.c, which is:  * Copyright (c) 2017, NXP  *  * SPDX-License-Identifier: Apache-2.0  */\n+comment|/*  * Copyright (c) 2019-2021 Vestas Wind Systems A/S  * Copyright 2024 NXP  *  * Based on clock_control_mcux_sim.c, which is:  * Copyright (c) 2017, 2024 NXP  *  * SPDX-License-Identifier: Apache-2.0  */\n+if|#\n+directive|if\n+operator|!\n+name|defined\n+argument_list|(\n+name|CONFIG_SOC_MKE17Z7\n+argument_list|)\n+endif|#\n+directive|endif\nThe issue was with: drivers: clock_control: add a soc config macro wrap flexbus clock\n\nke17z7 platform does not define flexbus clock-related macros,\nso comment it out."
},{
  "instruction": "There is an issue in the following code. It relates to Samples: Bluetooth: Add () to AUDIO_RING_BUF_BYTES for broadcast source\n\nThe BAP broadcast source sample did not properly use\nparentheses for the macro, potentially causing issues. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_define\nDECL|macro|AUDIO_RING_BUF_BYTES\ndefine|#\ndirective|define\nname|AUDIO_RING_BUF_BYTES\nvalue|USB_NUM_SAMPLES * USB_BYTES_PER_SAMPLE * RING_BUF_USB_FRAMES\nend_define\n\nbegin_else\nelse|#\ndirective|else",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|USB_NUM_SAMPLES * USB_BYTES_PER_SAMPLE * RING_BUF_USB_FRAMES\n+value|(USB_NUM_SAMPLES * USB_BYTES_PER_SAMPLE * RING_BUF_USB_FRAMES)\nThe issue was with: Samples: Bluetooth: Add () to AUDIO_RING_BUF_BYTES for broadcast source\n\nThe BAP broadcast source sample did not properly use\nparentheses for the macro, potentially causing issues."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: host: Update id.c to support id rst/del for CONFIG_BT_SMP=n\n\nCurrently calls to these two functions fail unnecessarily when\nCONFIG_BT_SMP is disabled. This fix allows identity resets\nwithout having the BT_SMP stack enabled. The primary use case\nis enabling random mac address rotation for privacy in memory\nconstrained SOCs. Fixes #73313 Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nif|if\ncondition|(\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_BT_CONN\nargument_list|)\noperator|&&\noperator|!\nname|bt_addr_le_eq\nargument_list|(\nblock|}\nif|if\ncondition|(\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_BT_CONN\nargument_list|)\ncondition|)\nblock|{\nname|int\nname|err",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_BT_CONN\n+name|CONFIG_BT_SMP\n-name|CONFIG_BT_CONN\n+name|CONFIG_BT_SMP\nThe issue was with: Bluetooth: host: Update id.c to support id rst/del for CONFIG_BT_SMP=n\n\nCurrently calls to these two functions fail unnecessarily when\nCONFIG_BT_SMP is disabled. This fix allows identity resets\nwithout having the BT_SMP stack enabled. The primary use case\nis enabling random mac address rotation for privacy in memory\nconstrained SOCs. Fixes #73313"
},{
  "instruction": "There is an issue in the following code. It relates to arch: arm: cortex_m: restore comment lost in translation\n\nThe comment about ISB in swap.S was lost when translation to C. Please fix this issue.",
  "input": "Faulty tokenized code:\ncomment|/* restore mode */\nname|IF_ENABLED\nargument_list|(\nargument|CONFIG_USERSPACE\nargument_list|,\nargument|({ \t\t\t   CONTROL_Type ctrl = {.w = __get_CONTROL()};\ncomment|/* exit privileged state when returing to thread mode. */\nargument|ctrl.b.nPRIV =\nliteral|0\nargument|; \t\t\t   __set_CONTROL(ctrl.w | current->arch.mode); \t\t   })\nargument_list|)\nempty_stmt|;\nreturn|return\nname|exc_ret\nreturn|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-argument|({ \t\t\t   CONTROL_Type ctrl = {.w = __get_CONTROL()};\n-comment|/* exit privileged state when returing to thread mode. */\n+argument|({ \t\t\tCONTROL_Type ctrl = {.w = __get_CONTROL()};\n+comment|/* exit privileged state when returning to thread mode. */\n-argument|; \t\t\t   __set_CONTROL(ctrl.w | current->arch.mode); \t\t   })\n+argument|;\n+comment|/* __set_CONTROL inserts an ISB which is may not be necessary here \t\t\t * (stack pointer may not be touched), but it's recommended to avoid \t\t\t * executing pre-fetched instructions with the previous privilege. \t\t\t */\n+argument|__set_CONTROL(ctrl.w | current->arch.mode); \t\t})\nThe issue was with: arch: arm: cortex_m: restore comment lost in translation\n\nThe comment about ISB in swap.S was lost when translation to C."
},{
  "instruction": "There is an issue in the following code. It relates to debug: symtab: rename `start_addr` to `first_addr`\n\n`start_addr` is the address of the first symbol, rename it to\n`first_addr` instead as it seems more intuitive and relatable\nto the comments. Please fix this issue.",
  "input": "Faulty tokenized code:\nDECL|struct|symtab_info\nstruct|struct\nname|symtab_info\nblock|{\ncomment|/* Absolute address of the first symbol */\nDECL|member|start_addr\nspecifier|const\nname|uintptr_t\nname|start_addr\ndecl_stmt|;\ncomment|/* Number of symbol entries */\nDECL|member|length\nspecifier|const\nname|uint32_t\n\n    def __eq__(self, other):\n        return self.addr == other.addr\n\n\nstart_addr = 0\nsymtab_list = []\n\n\ndef sanitize_func_name(name):\n    pattern = r'(^[a-zA-Z_][a-zA-Z0-9_]*)'\n\n        # Sort the address in ascending order\n        symtab_list.sort(key=lambda x: x.addr, reverse=False)\n\n        # Get the address of the first symbol\n       start_addr = symtab_list[0].addr\n\n        for i, entry in enumerate(symtab_list):\n            # Offset is calculated here\n           entry.offset = entry.addr - start_addr\n\n            # Debug print\n            log.debug('%6d: %s %s %.25s' % (\n                i,\n                hex(entry.addr),\n        print(\n            f\"\\t[{len(symtab_list)}] = {{.offset = {dummy_offset}, .name = \\\"?\\\"}},\", file=wf)\n        print(f\"}};\\n\", file=wf)\n\n        print(f\"const struct symtab_info z_symtab = {{\", file=wf)\n       print(f\"\\t.start_addr = {hex(start_addr)},\", file=wf)\n        print(f\"\\t.length = {len(symtab_list)},\", file=wf)\n        print(f\"\\t.entries = z_symtab_entries,\", file=wf)\n        print(f\"}};\\n\", file=wf)\n\n\ninit|=\nname|addr\noperator|-\nname|symtab\noperator|->\nname|start_addr\ndecl_stmt|;\nname|uint32_t\nname|left\ninit|=\nliteral|0",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|member|start_addr\n+DECL|member|first_addr\n-name|start_addr\n+name|first_addr\n-start_addr = 0\n+first_addr = 0\n-        start_addr = symtab_list[0].addr\n+        first_addr = symtab_list[0].addr\n-            entry.offset = entry.addr - start_addr\n+            entry.offset = entry.addr - first_addr\n-        print(f\"\\t.start_addr = {hex(start_addr)},\", file=wf)\n+        print(f\"\\t.first_addr = {hex(first_addr)},\", file=wf)\n-name|start_addr\n+name|first_addr\nThe issue was with: debug: symtab: rename `start_addr` to `first_addr`\n\n`start_addr` is the address of the first symbol, rename it to\n`first_addr` instead as it seems more intuitive and relatable\nto the comments."
},{
  "instruction": "There is an issue in the following code. It relates to tests: random: Move and rename rng test\n\nRandom number generator is a subsystem and although it is mostly used\nin crypto, this is not its only utility.\n\nMove the current random number generator test to it is own space\n(tests/subsys/random) and rename it to rng.\n\nWe need more and better tests for rng, this is an initial commit\nto organize it and get ready for further tests. Please fix this issue.",
  "input": "Faulty tokenized code:\nsimilarity index 100%\nrename from tests/crypto/rand32/CMakeLists.txt\nrename to tests/subsys/random/rng/CMakeLists.txt\nsimilarity index 100%\nrename from tests/crypto/rand32/entropy_psa_crypto.overlay\nrename to tests/subsys/random/rng/entropy_psa_crypto.overlay\nsimilarity index 100%\nrename from tests/crypto/rand32/prj.conf\nrename to tests/subsys/random/rng/prj.conf\nsimilarity index 100%\nrename from tests/crypto/rand32/prj_ctr_drbg.conf\nrename to tests/subsys/random/rng/prj_ctr_drbg.conf\nsimilarity index 100%\nrename from tests/crypto/rand32/prj_hw_random_psa_crypto.conf\nrename to tests/subsys/random/rng/prj_hw_random_psa_crypto.conf\nsimilarity index 100%\nrename from tests/crypto/rand32/prj_hw_random_xoshiro.conf\nrename to tests/subsys/random/rng/prj_hw_random_xoshiro.conf\nsimilarity index 100%\nrename from tests/crypto/rand32/prj_sw_random_systimer.conf\nrename to tests/subsys/random/rng/prj_sw_random_systimer.conf\nsimilarity index 98%\nrename from tests/crypto/rand32/src/main.c\nrename to tests/subsys/random/rng/src/main.c\nbegin_comment\ncomment|/**  *  * @brief Regression test's entry point  *  */\nend_comment\n\nbegin_macro\nDECL|function|ZTEST (rand32_common,test_rand32)\nname|ZTEST\nargument_list|(\nargument|rand32_common\nargument_list|,\nargument|test_rand32\nargument_list|)\nend_macro\n\nend_block\n\nbegin_expr_stmt\nname|ZTEST_SUITE\nargument_list|(\nname|rand32_common\nargument_list|,\nname|NULL\nargument_list|,\nname|NULL\nargument_list|,\nsimilarity index 83%\nrename from tests/crypto/rand32/testcase.yaml\nrename to tests/subsys/random/rng/testcase.yaml\n  tags:\n    - crypto\n    - random\n    - security\ntests:\n crypto.rand32:\n    min_ram: 16\n    integration_platforms:\n      - qemu_x86\n crypto.rand32.random_sw_systimer:\n    extra_args: CONF_FILE=prj_sw_random_systimer.conf\n    integration_platforms:\n      - qemu_x86\n crypto.rand32.random_hw_xoshiro:\n    extra_args: CONF_FILE=prj_hw_random_xoshiro.conf\n    filter: CONFIG_ENTROPY_HAS_DRIVER\n    min_ram: 16\n    integration_platforms:\n      - native_sim\n crypto.rand32.random_ctr_drbg:\n    extra_args: CONF_FILE=prj_ctr_drbg.conf\n    filter: CONFIG_ENTROPY_HAS_DRIVER\n    min_ram: 16\n    integration_platforms:\n      - native_sim\n drivers.rand32.random_psa_crypto:\n    filter: CONFIG_BUILD_WITH_TFM\n    arch_exclude: posix\n    extra_args:\n      - DTC_OVERLAY_FILE=./entropy_psa_crypto.overlay\n      - CONF_FILE=prj_hw_random_psa_crypto.conf",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|ZTEST (rand32_common,test_rand32)\n+DECL|function|ZTEST (rng_common,test_rand32)\n-argument|rand32_common\n+argument|rng_common\n-name|rand32_common\n+name|rng_common\n-  crypto.rand32:\n+  crypto.rng:\n-  crypto.rand32.random_sw_systimer:\n+  crypto.rng.random_sw_systimer:\n-  crypto.rand32.random_hw_xoshiro:\n+  crypto.rng.random_hw_xoshiro:\n-  crypto.rand32.random_ctr_drbg:\n+  crypto.rng.random_ctr_drbg:\n-  drivers.rand32.random_psa_crypto:\n+  drivers.rng.random_psa_crypto:\nThe issue was with: tests: random: Move and rename rng test\n\nRandom number generator is a subsystem and although it is mostly used\nin crypto, this is not its only utility.\n\nMove the current random number generator test to it is own space\n(tests/subsys/random) and rename it to rng.\n\nWe need more and better tests for rng, this is an initial commit\nto organize it and get ready for further tests."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: CAP: Add check for `member` in `common_get_client`\n\nThe function did not check if `member` was NULL before\ndereferencing it. Please fix this issue.",
  "input": "Faulty tokenized code:\ninit|=\nname|NULL\ndecl_stmt|;\nif|if\ncondition|(\nname|type\noperator|==\nname|BT_CAP_SET_TYPE_AD_HOC\ncondition|)\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|member\n+operator|==\n+name|NULL\n+condition|)\n+block|{\n+name|LOG_DBG\n+argument_list|(\n+literal|\"member is NULL\"\n+argument_list|)\n+expr_stmt|;\n+return|return\n+name|NULL\n+return|;\n+block|}\n+if|if\n+condition|(\nThe issue was with: Bluetooth: CAP: Add check for `member` in `common_get_client`\n\nThe function did not check if `member` was NULL before\ndereferencing it."
},{
  "instruction": "There is an issue in the following code. It relates to llext: zero is a valid relocation offset\n\nZero offset in a relocation entry is valid, shouldn't ignore it. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|name\nargument_list|)\nexpr_stmt|;\ncontinue|continue;\nblock|}\nif|if\ncondition|(\noperator|!\nname|rela\noperator|.\nname|r_offset\ncondition|)\nblock|{\nname|LOG_WRN\nargument_list|(\nliteral|\"PLT: zero offset idx %u name %s\"\nargument_list|,\nname|j\nargument_list|,\nname|name\nargument_list|)\nexpr_stmt|;\ncontinue|continue;\nblock|}\ncomment|/* Resolve the symbol */\noperator|*\noperator|(\nspecifier|const\nname|void",
  "result": "I corrected the issue in the code by changing the following tokens:\n-if|if\n-condition|(\n-operator|!\n-name|rela\n-operator|.\n-name|r_offset\n-condition|)\n-block|{\n-name|LOG_WRN\n-argument_list|(\n-literal|\"PLT: zero offset idx %u name %s\"\n-argument_list|,\n-name|j\n-argument_list|,\n-name|name\n-argument_list|)\n-expr_stmt|;\n-continue|continue;\n-block|}\nThe issue was with: llext: zero is a valid relocation offset\n\nZero offset in a relocation entry is valid, shouldn't ignore it."
},{
  "instruction": "There is an issue in the following code. It relates to llext: (cosmetic) fix a misplaced space and re-use a variable\n\nUse an existing variable instead of re-calculating and fix swapped\nspace and a paranthesis. Please fix this issue.",
  "input": "Faulty tokenized code:\n\t  generate the object file.\n\nconfig LLEXT_TYPE_ELF_RELOCATABLE\n\tbool \"Relocatable ELF file\"\n\thelp\n\t  Build and expect relocatable (partially linked )files as the\n\t  binary object type for the llext subsystem. These object files\n\t  are generated by the linker by combining multiple object files\n\t  into a single one.\n\nconfig LLEXT_TYPE_ELF_SHAREDLIB\nargument_list|(\nliteral|\"section %d at %zx: name %d, type %d, flags %zx, addr %zx, size %zd\"\nargument_list|,\nname|i\nargument_list|,\noperator|(\nname|size_t\noperator|)\nname|ldr\noperator|->\nname|hdr\noperator|.\nname|e_shoff\noperator|+\nname|i\noperator|*\nname|ldr\noperator|->\nname|hdr\noperator|.\nname|e_shentsize\nargument_list|,\nname|shdr\noperator|.\nname|sh_name\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-\t  Build and expect relocatable (partially linked )files as the\n+\t  Build and expect relocatable (partially linked) files as the\n-operator|(\n-name|size_t\n-operator|)\n-name|ldr\n-operator|->\n-name|hdr\n-operator|.\n-name|e_shoff\n-operator|+\n-name|i\n-operator|*\n-name|ldr\n-operator|->\n-name|hdr\n-operator|.\n-name|e_shentsize\n+name|pos\nThe issue was with: llext: (cosmetic) fix a misplaced space and re-use a variable\n\nUse an existing variable instead of re-calculating and fix swapped\nspace and a paranthesis."
},{
  "instruction": "There is an issue in the following code. It relates to modules: lvgl: fix pointer input for normal orientation\n\nAdd missing break statement for normal orientation. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|=\nname|tmp_point\noperator|.\nname|y\nexpr_stmt|;\ncase|case\nname|DISPLAY_ORIENTATION_ROTATED_90\ncase|:\nname|point\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n+break|break;\nThe issue was with: modules: lvgl: fix pointer input for normal orientation\n\nAdd missing break statement for normal orientation."
},{
  "instruction": "There is an issue in the following code. It relates to i2c: target: eeprom_target: add addressable size assert\n\nAdd build-time assert to check if the size defined is actually addressable.\ni.e: if address-width is set to 8, the maximum addressable size is 256\nbytes. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|I2C_EEPROM_INIT\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|static struct i2c_eeprom_target_data\t\t\t\t\\ \t\ti2c_eeprom_target_##inst##_dev_data = {\t\t\t\\ \t\t\t.address_width = DT_INST_PROP_OR(inst,\t\t\\ \t\t\t\t\taddress_width, 8),\t\t\\ \t\t};\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic uint8_t\t\t\t\t\t\t\t\\ \ti2c_eeprom_target_##inst##_buffer[(DT_INST_PROP(inst, size))];\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic const struct i2c_eeprom_target_config\t\t\t\\ \t\ti2c_eeprom_target_##inst##_cfg = {\t\t\t\\ \t\t.bus = I2C_DT_SPEC_INST_GET(inst),\t\t\t\\ \t\t.buffer_size = DT_INST_PROP(inst, size),\t\t\\ \t\t.buffer = i2c_eeprom_target_##inst##_buffer\t\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst,\t\t\t\t\t\\&i2c_eeprom_target_init,\t\t\t\\ \t\t\t    NULL,\t\t\t\\&i2c_eeprom_target_##inst##_dev_data,\t\\&i2c_eeprom_target_##inst##_cfg,\t\t\\ \t\t\t    POST_KERNEL,\t\t\t\t\\ \t\t\t    CONFIG_I2C_TARGET_INIT_PRIORITY,\t\t\\&api_funcs);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|static struct i2c_eeprom_target_data\t\t\t\t\\ \t\ti2c_eeprom_target_##inst##_dev_data = {\t\t\t\\ \t\t\t.address_width = DT_INST_PROP_OR(inst,\t\t\\ \t\t\t\t\taddress_width, 8),\t\t\\ \t\t};\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic uint8_t\t\t\t\t\t\t\t\\ \ti2c_eeprom_target_##inst##_buffer[(DT_INST_PROP(inst, size))];\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic const struct i2c_eeprom_target_config\t\t\t\\ \t\ti2c_eeprom_target_##inst##_cfg = {\t\t\t\\ \t\t.bus = I2C_DT_SPEC_INST_GET(inst),\t\t\t\\ \t\t.buffer_size = DT_INST_PROP(inst, size),\t\t\\ \t\t.buffer = i2c_eeprom_target_##inst##_buffer\t\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst,\t\t\t\t\t\\&i2c_eeprom_target_init,\t\t\t\\ \t\t\t    NULL,\t\t\t\\&i2c_eeprom_target_##inst##_dev_data,\t\\&i2c_eeprom_target_##inst##_cfg,\t\t\\ \t\t\t    POST_KERNEL,\t\t\t\t\\ \t\t\t    CONFIG_I2C_TARGET_INIT_PRIORITY,\t\t\\&api_funcs);\n+value|static struct i2c_eeprom_target_data\t\t\t\t\\ \t\ti2c_eeprom_target_##inst##_dev_data = {\t\t\t\\ \t\t\t.address_width = DT_INST_PROP_OR(inst,\t\t\\ \t\t\t\t\taddress_width, 8),\t\t\\ \t\t};\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic uint8_t\t\t\t\t\t\t\t\\ \ti2c_eeprom_target_##inst##_buffer[(DT_INST_PROP(inst, size))];\t\\ \t\t\t\t\t\t\t\t\t\\ \tBUILD_ASSERT(DT_INST_PROP(inst, size)<=\t\t\t\\ \t\t\t(1<< DT_INST_PROP_OR(inst, address_width, 8)), \\ \t\t\t\"size must be<= than 2^address_width\");\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic const struct i2c_eeprom_target_config\t\t\t\\ \t\ti2c_eeprom_target_##inst##_cfg = {\t\t\t\\ \t\t.bus = I2C_DT_SPEC_INST_GET(inst),\t\t\t\\ \t\t.buffer_size = DT_INST_PROP(inst, size),\t\t\\ \t\t.buffer = i2c_eeprom_target_##inst##_buffer\t\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst,\t\t\t\t\t\\&i2c_eeprom_target_init,\t\t\t\\ \t\t\t    NULL,\t\t\t\\&i2c_eeprom_target_##inst##_dev_data,\t\\&i2c_eeprom_target_##inst##_cfg,\t\t\\ \t\t\t    POST_KERNEL,\t\t\t\t\\ \t\t\t    CONFIG_I2C_TARGET_INIT_PRIORITY,\t\t\\&api_funcs);\nThe issue was with: i2c: target: eeprom_target: add addressable size assert\n\nAdd build-time assert to check if the size defined is actually addressable.\ni.e: if address-width is set to 8, the maximum addressable size is 256\nbytes."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: CAP: Shell: Fix minors bugs with unicast_stop\n\nThe cap_initiator unicast_stop shell command had the wrong\nminimum parameter count (as it defaults to all).\n\nSome indentation had also gone wrong for it in the\ndocumentation. Please fix this issue.",
  "input": "Faulty tokenized code:\n     discover          : Discover CAS\n     unicast_start     : Unicast Start [csip] [sinks <cnt> (default 1)] [sources\n                        <cnt> (default 1)] [conns (<cnt> | all) (default 1)]\n     unicast_list      : Unicast list streams\n     unicast_update    : Unicast Update <all | stream [stream [stream...]]>\n    unicast_stop      :Unicast stop streams [stream [stream [stream...]]] (all by default)\n     unicast_cancel    : Unicast cancel current procedure\n     ac_1              : Unicast audio configuration 1\n     ac_2              : Unicast audio configuration 2\n     ac_3              : Unicast audio configuration 3\n     ac_4              : Unicast audio configuration 4\nargument_list|,\nliteral|\"Unicast stop streams [stream [stream [stream...]]] (all by default)\"\nargument_list|,\nname|cmd_cap_initiator_unicast_stop\nargument_list|,\nliteral|2\nargument_list|,\nname|CAP_UNICAST_CLIENT_STREAM_COUNT\nargument_list|)\nargument_list|,\nname|SHELL_CMD_ARG",
  "result": "I corrected the issue in the code by changing the following tokens:\n-     unicast_stop      :Unicast stop streams [stream [stream [stream...]]] (all by default)\n+     unicast_stop      : Unicast stop streams [stream [stream [stream...]]] (all by default)\n-literal|2\n+literal|1\nThe issue was with: Bluetooth: CAP: Shell: Fix minors bugs with unicast_stop\n\nThe cap_initiator unicast_stop shell command had the wrong\nminimum parameter count (as it defaults to all).\n\nSome indentation had also gone wrong for it in the\ndocumentation."
},{
  "instruction": "There is an issue in the following code. It relates to arch: arm64: fatal: limit max number of stack traces\n\nIn some cases, the `fp` will never be `NULL` and the stack\nunwinding can go on and on forever, limit the max depth so that\nthis will not happen. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|LOG_ERR\nargument_list|(\nliteral|\"\"\nargument_list|)\nexpr_stmt|;\nwhile|while\ncondition|(\nname|fp\noperator|!=\nname|NULL\ncondition|)\nblock|{\nname|lr\noperator|=\nname|fp\nindex|[",
  "result": "I corrected the issue in the code by changing the following tokens:\n-while|while\n-condition|(\n+for|for\n+control|(\n+name|int\n+name|i\n+init|=\n+literal|0\n+init|;\n+operator|(\n-condition|)\n+operator|)\n+operator|&&\n+operator|(\n+name|i\n+operator|<\n+name|CONFIG_EXCEPTION_STACK_TRACE_MAX_FRAMES\n+operator|)\n+condition|;\n+name|i\n+operator|++\n+control|)\nThe issue was with: arch: arm64: fatal: limit max number of stack traces\n\nIn some cases, the `fp` will never be `NULL` and the stack\nunwinding can go on and on forever, limit the max depth so that\nthis will not happen."
},{
  "instruction": "There is an issue in the following code. It relates to tests: mcuboot: add boot_request_upgrade() return value check\n\n- Adds boot_request_upgrade() return value check.\n- Avoid repeating resets if the upgrade request fails. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright 2022 NXP  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nname|main\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nname|printk\nargument_list|(\nliteral|\"Launching primary slot application on %s\\n\"\nargument_list|,\nname|CONFIG_BOARD\nargument_list|)\nexpr_stmt|;\ncomment|/* Perform a permanent swap of MCUBoot application */\nname|boot_request_upgrade\nargument_list|(\nliteral|1\nargument_list|)\nexpr_stmt|;\nname|printk\nargument_list|(\nliteral|\"Secondary application ready for swap, rebooting\\n\"\nargument_list|)\nexpr_stmt|;\nname|sys_reboot\nargument_list|(\nname|SYS_REBOOT_COLD\nargument_list|)\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/*  * Copyright 2022 NXP  *  * SPDX-License-Identifier: Apache-2.0  */\n+comment|/*  * Copyright 2022-2024 NXP  *  * SPDX-License-Identifier: Apache-2.0  */\n+name|int\n+name|err\n+decl_stmt|;\n+name|err\n+operator|=\n-literal|1\n+name|BOOT_UPGRADE_PERMANENT\n+argument_list|)\n+expr_stmt|;\n+if|if\n+condition|(\n+name|err\n+condition|)\n+block|{\n+name|printk\n+argument_list|(\n+literal|\"Failed to request upgrade: %d\"\n+argument_list|,\n+name|err\n+block|}\n+else|else\n+block|{\n+block|}\nThe issue was with: tests: mcuboot: add boot_request_upgrade() return value check\n\n- Adds boot_request_upgrade() return value check.\n- Avoid repeating resets if the upgrade request fails."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: uart_mcux_flexcomm: remove incorrect dma_slot.\n\na change in the dma driver exposed that the dma_slot was incorrectly\nset in the uart driver. this change is needed for async uart on lpc55\nto work. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|UART_MCUX_FLEXCOMM_ASYNC_CFG\nparameter_list|(\nname|n\nparameter_list|)\ndefine|\\\nvalue|.tx_dma = {\t\t\t\t\t\t\t\t\\ \t\t.dev = DEVICE_DT_GET(DT_INST_DMAS_CTLR_BY_NAME(n, tx)),\t\t\\ \t\t.channel = DT_INST_DMAS_CELL_BY_NAME(n, tx, channel),\t\t\\ \t\t.cfg = {\t\t\t\t\t\t\t\\ \t\t\t.source_burst_length = 1,\t\t\t\t\\ \t\t\t.dest_burst_length = 1,\t\t\t\t\t\\ \t\t\t.source_data_size = 1,\t\t\t\t\t\\ \t\t\t.dest_data_size = 1,\t\t\t\t\t\\ \t\t\t.complete_callback_en = 1,\t\t\t\t\\ \t\t\t.error_callback_dis = 1,\t\t\t\t\\ \t\t\t.block_count = 1,\t\t\t\t\t\\ \t\t\t.head_block =\t\t\t\t\t\t\\&mcux_flexcomm_##n##_data.tx_data.active_block,\t\\ \t\t\t.channel_direction = MEMORY_TO_PERIPHERAL,\t\t\\ \t\t\t.dma_slot = DT_INST_DMAS_CELL_BY_NAME(n, tx, channel),\t\\ \t\t\t.dma_callback = mcux_flexcomm_uart_dma_tx_callback,\t\\ \t\t\t.user_data = (void *)DEVICE_DT_INST_GET(n),\t\t\\ \t\t},\t\t\t\t\t\t\t\t\\ \t\t.base = (DMA_Type *)\t\t\t\t\t\t\\ \t\t\t\tDT_REG_ADDR(DT_INST_DMAS_CTLR_BY_NAME(n, tx)),\t\\ \t},\t\t\t\t\t\t\t\t\t\\ \t.rx_dma = {\t\t\t\t\t\t\t\t\\ \t\t.dev = DEVICE_DT_GET(DT_INST_DMAS_CTLR_BY_NAME(n, rx)),\t\t\\ \t\t.channel = DT_INST_DMAS_CELL_BY_NAME(n, rx, channel),\t\t\\ \t\t.cfg = {\t\t\t\t\t\t\t\\ \t\t\t.source_burst_length = 1,\t\t\t\t\\ \t\t\t.dest_burst_length = 1,\t\t\t\t\t\\ \t\t\t.source_data_size = 1,\t\t\t\t\t\\ \t\t\t.dest_data_size = 1,\t\t\t\t\t\\ \t\t\t.complete_callback_en = 1,\t\t\t\t\\ \t\t\t.error_callback_dis = 1,\t\t\t\t\\ \t\t\t.block_count = 1,\t\t\t\t\t\\ \t\t\t.head_block =\t\t\t\t\t\t\\&mcux_flexcomm_##n##_data.rx_data.active_block,\t\\ \t\t\t.channel_direction = PERIPHERAL_TO_MEMORY,\t\t\\ \t\t\t.dma_slot = DT_INST_DMAS_CELL_BY_NAME(n, rx, channel),\t\\ \t\t\t.dma_callback = mcux_flexcomm_uart_dma_rx_callback,\t\\ \t\t\t.user_data = (void *)DEVICE_DT_INST_GET(n)\t\t\\ \t\t},\t\t\t\t\t\t\t\t\\ \t\t.base = (DMA_Type *)\t\t\t\t\t\t\\ \t\t\t\tDT_REG_ADDR(DT_INST_DMAS_CTLR_BY_NAME(n, rx)),\t\\ \t},\t\t\t\t\t\t\t\t\t\\ \t.rx_timeout_func = mcux_flexcomm_uart_##n##_rx_timeout,\t\t\t\\ \t.tx_timeout_func = mcux_flexcomm_uart_##n##_tx_timeout,\nend_define\n\nbegin_else\nelse|#\ndirective|else",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|.tx_dma = {\t\t\t\t\t\t\t\t\\ \t\t.dev = DEVICE_DT_GET(DT_INST_DMAS_CTLR_BY_NAME(n, tx)),\t\t\\ \t\t.channel = DT_INST_DMAS_CELL_BY_NAME(n, tx, channel),\t\t\\ \t\t.cfg = {\t\t\t\t\t\t\t\\ \t\t\t.source_burst_length = 1,\t\t\t\t\\ \t\t\t.dest_burst_length = 1,\t\t\t\t\t\\ \t\t\t.source_data_size = 1,\t\t\t\t\t\\ \t\t\t.dest_data_size = 1,\t\t\t\t\t\\ \t\t\t.complete_callback_en = 1,\t\t\t\t\\ \t\t\t.error_callback_dis = 1,\t\t\t\t\\ \t\t\t.block_count = 1,\t\t\t\t\t\\ \t\t\t.head_block =\t\t\t\t\t\t\\&mcux_flexcomm_##n##_data.tx_data.active_block,\t\\ \t\t\t.channel_direction = MEMORY_TO_PERIPHERAL,\t\t\\ \t\t\t.dma_slot = DT_INST_DMAS_CELL_BY_NAME(n, tx, channel),\t\\ \t\t\t.dma_callback = mcux_flexcomm_uart_dma_tx_callback,\t\\ \t\t\t.user_data = (void *)DEVICE_DT_INST_GET(n),\t\t\\ \t\t},\t\t\t\t\t\t\t\t\\ \t\t.base = (DMA_Type *)\t\t\t\t\t\t\\ \t\t\t\tDT_REG_ADDR(DT_INST_DMAS_CTLR_BY_NAME(n, tx)),\t\\ \t},\t\t\t\t\t\t\t\t\t\\ \t.rx_dma = {\t\t\t\t\t\t\t\t\\ \t\t.dev = DEVICE_DT_GET(DT_INST_DMAS_CTLR_BY_NAME(n, rx)),\t\t\\ \t\t.channel = DT_INST_DMAS_CELL_BY_NAME(n, rx, channel),\t\t\\ \t\t.cfg = {\t\t\t\t\t\t\t\\ \t\t\t.source_burst_length = 1,\t\t\t\t\\ \t\t\t.dest_burst_length = 1,\t\t\t\t\t\\ \t\t\t.source_data_size = 1,\t\t\t\t\t\\ \t\t\t.dest_data_size = 1,\t\t\t\t\t\\ \t\t\t.complete_callback_en = 1,\t\t\t\t\\ \t\t\t.error_callback_dis = 1,\t\t\t\t\\ \t\t\t.block_count = 1,\t\t\t\t\t\\ \t\t\t.head_block =\t\t\t\t\t\t\\&mcux_flexcomm_##n##_data.rx_data.active_block,\t\\ \t\t\t.channel_direction = PERIPHERAL_TO_MEMORY,\t\t\\ \t\t\t.dma_slot = DT_INST_DMAS_CELL_BY_NAME(n, rx, channel),\t\\ \t\t\t.dma_callback = mcux_flexcomm_uart_dma_rx_callback,\t\\ \t\t\t.user_data = (void *)DEVICE_DT_INST_GET(n)\t\t\\ \t\t},\t\t\t\t\t\t\t\t\\ \t\t.base = (DMA_Type *)\t\t\t\t\t\t\\ \t\t\t\tDT_REG_ADDR(DT_INST_DMAS_CTLR_BY_NAME(n, rx)),\t\\ \t},\t\t\t\t\t\t\t\t\t\\ \t.rx_timeout_func = mcux_flexcomm_uart_##n##_rx_timeout,\t\t\t\\ \t.tx_timeout_func = mcux_flexcomm_uart_##n##_tx_timeout,\n+value|.tx_dma = {\t\t\t\t\t\t\t\t\\ \t\t.dev = DEVICE_DT_GET(DT_INST_DMAS_CTLR_BY_NAME(n, tx)),\t\t\\ \t\t.channel = DT_INST_DMAS_CELL_BY_NAME(n, tx, channel),\t\t\\ \t\t.cfg = {\t\t\t\t\t\t\t\\ \t\t\t.source_burst_length = 1,\t\t\t\t\\ \t\t\t.dest_burst_length = 1,\t\t\t\t\t\\ \t\t\t.source_data_size = 1,\t\t\t\t\t\\ \t\t\t.dest_data_size = 1,\t\t\t\t\t\\ \t\t\t.complete_callback_en = 1,\t\t\t\t\\ \t\t\t.error_callback_dis = 1,\t\t\t\t\\ \t\t\t.block_count = 1,\t\t\t\t\t\\ \t\t\t.head_block =\t\t\t\t\t\t\\&mcux_flexcomm_##n##_data.tx_data.active_block,\t\\ \t\t\t.channel_direction = MEMORY_TO_PERIPHERAL,\t\t\\ \t\t\t.dma_callback = mcux_flexcomm_uart_dma_tx_callback,\t\\ \t\t\t.user_data = (void *)DEVICE_DT_INST_GET(n),\t\t\\ \t\t},\t\t\t\t\t\t\t\t\\ \t\t.base = (DMA_Type *)\t\t\t\t\t\t\\ \t\t\t\tDT_REG_ADDR(DT_INST_DMAS_CTLR_BY_NAME(n, tx)),\t\\ \t},\t\t\t\t\t\t\t\t\t\\ \t.rx_dma = {\t\t\t\t\t\t\t\t\\ \t\t.dev = DEVICE_DT_GET(DT_INST_DMAS_CTLR_BY_NAME(n, rx)),\t\t\\ \t\t.channel = DT_INST_DMAS_CELL_BY_NAME(n, rx, channel),\t\t\\ \t\t.cfg = {\t\t\t\t\t\t\t\\ \t\t\t.source_burst_length = 1,\t\t\t\t\\ \t\t\t.dest_burst_length = 1,\t\t\t\t\t\\ \t\t\t.source_data_size = 1,\t\t\t\t\t\\ \t\t\t.dest_data_size = 1,\t\t\t\t\t\\ \t\t\t.complete_callback_en = 1,\t\t\t\t\\ \t\t\t.error_callback_dis = 1,\t\t\t\t\\ \t\t\t.block_count = 1,\t\t\t\t\t\\ \t\t\t.head_block =\t\t\t\t\t\t\\&mcux_flexcomm_##n##_data.rx_data.active_block,\t\\ \t\t\t.channel_direction = PERIPHERAL_TO_MEMORY,\t\t\\ \t\t\t.dma_callback = mcux_flexcomm_uart_dma_rx_callback,\t\\ \t\t\t.user_data = (void *)DEVICE_DT_INST_GET(n)\t\t\\ \t\t},\t\t\t\t\t\t\t\t\\ \t\t.base = (DMA_Type *)\t\t\t\t\t\t\\ \t\t\t\tDT_REG_ADDR(DT_INST_DMAS_CTLR_BY_NAME(n, rx)),\t\\ \t},\t\t\t\t\t\t\t\t\t\\ \t.rx_timeout_func = mcux_flexcomm_uart_##n##_rx_timeout,\t\t\t\\ \t.tx_timeout_func = mcux_flexcomm_uart_##n##_tx_timeout,\nThe issue was with: drivers: uart_mcux_flexcomm: remove incorrect dma_slot.\n\na change in the dma driver exposed that the dma_slot was incorrectly\nset in the uart driver. this change is needed for async uart on lpc55\nto work."
},{
  "instruction": "There is an issue in the following code. It relates to vcnl36825t: allow \\\"force\\\"-mode only if low-power mode is inactive\n\nBehavior of \\\"force\\\"-mode as described in datasheet cannot be achieved if\nlow-power mode is enabled. After triggering a sampling, the sensor will\nnot sample again for the period specified in measurement-time. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|VCNL36825T_DEFINE\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|BUILD_ASSERT(!DT_INST_PROP(inst, low_power) || (DT_INST_PROP(inst, measurement_period)>=  \\ \t\t\t\t\t\t\tVCNL36825T_PS_LPPER_VALUE_MIN_MS),         \\ \t\t     \"measurement-period must be greater/equal 40 ms in low-power mode\");          \\ \tBUILD_ASSERT(                                                                              \\ \t\tDT_INST_PROP(inst, low_power) || (DT_INST_PROP(inst, measurement_period)<=        \\ \t\t\t\t\t\t  VCNL36825T_PS_PERIOD_VALUE_MAX_MS),              \\ \t\t\"measurement-period must be less/equal 80 ms with deactivated low-power mode\");    \\ \tstatic struct vcnl36825t_data vcnl36825t_data_##inst;                                      \\ \tstatic const struct vcnl36825t_config vcnl36825t_config_##inst = {                         \\ \t\t.i2c = I2C_DT_SPEC_INST_GET(inst),                                                 \\ \t\t.operation_mode = DT_INST_ENUM_IDX(inst, operation_mode),                          \\ \t\t.period = DT_INST_ENUM_IDX(inst, measurement_period),                              \\ \t\t.proximity_it = DT_INST_ENUM_IDX(inst, proximity_it),                              \\ \t\t.proximity_itb = DT_INST_ENUM_IDX(inst, proximity_itb),                            \\ \t\t.multi_pulse = DT_INST_ENUM_IDX(inst, multi_pulse),                                \\ \t\t.low_power = DT_INST_PROP(inst, low_power),                                        \\ \t\t.high_gain = DT_INST_PROP(inst, high_gain),                                        \\ \t\t.laser_current = DT_INST_ENUM_IDX(inst, laser_current),                            \\ \t\t.high_dynamic_output = DT_INST_PROP(inst, high_dynamic_output),                    \\ \t\t.sunlight_cancellation = DT_INST_PROP(inst, sunlight_cancellation),                \\ \t};                                                                                         \\ \tIF_ENABLED(CONFIG_PM_DEVICE, (PM_DEVICE_DT_INST_DEFINE(inst, vcnl36825t_pm_action)));      \\ \tSENSOR_DEVICE_DT_INST_DEFINE(                                                              \\ \t\tinst, vcnl36825t_init,                                                             \\ \t\tCOND_CODE_1(CONFIG_PM_DEVICE, (PM_DEVICE_DT_INST_GET(inst)), (NULL)),              \\&vcnl36825t_data_##inst,&vcnl36825t_config_##inst, POST_KERNEL,                   \\ \t\tCONFIG_SENSOR_INIT_PRIORITY,&vcnl36825t_driver_api);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(\n      - \"auto\": the sensor performs sampling continuously,\n      - \"force\": the sampling is performed on every fetch command.\n\n      Defaults to sensor reset value.\n\n  measurement-period:\n    type: int\n    default: 40\n    enum: [10, 20, 40, 80, 160, 320]\n    description: |",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|BUILD_ASSERT(!DT_INST_PROP(inst, low_power) || (DT_INST_PROP(inst, measurement_period)>=  \\ \t\t\t\t\t\t\tVCNL36825T_PS_LPPER_VALUE_MIN_MS),         \\ \t\t     \"measurement-period must be greater/equal 40 ms in low-power mode\");          \\ \tBUILD_ASSERT(                                                                              \\ \t\tDT_INST_PROP(inst, low_power) || (DT_INST_PROP(inst, measurement_period)<=        \\ \t\t\t\t\t\t  VCNL36825T_PS_PERIOD_VALUE_MAX_MS),              \\ \t\t\"measurement-period must be less/equal 80 ms with deactivated low-power mode\");    \\ \tstatic struct vcnl36825t_data vcnl36825t_data_##inst;                                      \\ \tstatic const struct vcnl36825t_config vcnl36825t_config_##inst = {                         \\ \t\t.i2c = I2C_DT_SPEC_INST_GET(inst),                                                 \\ \t\t.operation_mode = DT_INST_ENUM_IDX(inst, operation_mode),                          \\ \t\t.period = DT_INST_ENUM_IDX(inst, measurement_period),                              \\ \t\t.proximity_it = DT_INST_ENUM_IDX(inst, proximity_it),                              \\ \t\t.proximity_itb = DT_INST_ENUM_IDX(inst, proximity_itb),                            \\ \t\t.multi_pulse = DT_INST_ENUM_IDX(inst, multi_pulse),                                \\ \t\t.low_power = DT_INST_PROP(inst, low_power),                                        \\ \t\t.high_gain = DT_INST_PROP(inst, high_gain),                                        \\ \t\t.laser_current = DT_INST_ENUM_IDX(inst, laser_current),                            \\ \t\t.high_dynamic_output = DT_INST_PROP(inst, high_dynamic_output),                    \\ \t\t.sunlight_cancellation = DT_INST_PROP(inst, sunlight_cancellation),                \\ \t};                                                                                         \\ \tIF_ENABLED(CONFIG_PM_DEVICE, (PM_DEVICE_DT_INST_DEFINE(inst, vcnl36825t_pm_action)));      \\ \tSENSOR_DEVICE_DT_INST_DEFINE(                                                              \\ \t\tinst, vcnl36825t_init,                                                             \\ \t\tCOND_CODE_1(CONFIG_PM_DEVICE, (PM_DEVICE_DT_INST_GET(inst)), (NULL)),              \\&vcnl36825t_data_##inst,&vcnl36825t_config_##inst, POST_KERNEL,                   \\ \t\tCONFIG_SENSOR_INIT_PRIORITY,&vcnl36825t_driver_api);\n+value|BUILD_ASSERT(!DT_INST_PROP(inst, low_power) || (DT_INST_PROP(inst, measurement_period)>=  \\ \t\t\t\t\t\t\tVCNL36825T_PS_LPPER_VALUE_MIN_MS),         \\ \t\t     \"measurement-period must be greater/equal 40 ms in low-power mode\");          \\ \tBUILD_ASSERT(                                                                              \\ \t\tDT_INST_PROP(inst, low_power) || (DT_INST_PROP(inst, measurement_period)<=        \\ \t\t\t\t\t\t  VCNL36825T_PS_PERIOD_VALUE_MAX_MS),              \\ \t\t\"measurement-period must be less/equal 80 ms with deactivated low-power mode\");    \\ \tBUILD_ASSERT(!DT_INST_PROP(inst, low_power) || (DT_INST_ENUM_IDX(inst, operation_mode) ==  \\ \t\t\t\t\t\t\tVCNL36825T_OPERATION_MODE_AUTO),           \\ \t\t     \"operation-mode \\\"force\\\" only available if low-power mode deactivated\");     \\ \tstatic struct vcnl36825t_data vcnl36825t_data_##inst;                                      \\ \tstatic const struct vcnl36825t_config vcnl36825t_config_##inst = {                         \\ \t\t.i2c = I2C_DT_SPEC_INST_GET(inst),                                                 \\ \t\t.operation_mode = DT_INST_ENUM_IDX(inst, operation_mode),                          \\ \t\t.period = DT_INST_ENUM_IDX(inst, measurement_period),                              \\ \t\t.proximity_it = DT_INST_ENUM_IDX(inst, proximity_it),                              \\ \t\t.proximity_itb = DT_INST_ENUM_IDX(inst, proximity_itb),                            \\ \t\t.multi_pulse = DT_INST_ENUM_IDX(inst, multi_pulse),                                \\ \t\t.low_power = DT_INST_PROP(inst, low_power),                                        \\ \t\t.high_gain = DT_INST_PROP(inst, high_gain),                                        \\ \t\t.laser_current = DT_INST_ENUM_IDX(inst, laser_current),                            \\ \t\t.high_dynamic_output = DT_INST_PROP(inst, high_dynamic_output),                    \\ \t\t.sunlight_cancellation = DT_INST_PROP(inst, sunlight_cancellation),                \\ \t};                                                                                         \\ \tIF_ENABLED(CONFIG_PM_DEVICE, (PM_DEVICE_DT_INST_DEFINE(inst, vcnl36825t_pm_action)));      \\ \tSENSOR_DEVICE_DT_INST_DEFINE(                                                              \\ \t\tinst, vcnl36825t_init,                                                             \\ \t\tCOND_CODE_1(CONFIG_PM_DEVICE, (PM_DEVICE_DT_INST_GET(inst)), (NULL)),              \\&vcnl36825t_data_##inst,&vcnl36825t_config_##inst, POST_KERNEL,                   \\ \t\tCONFIG_SENSOR_INIT_PRIORITY,&vcnl36825t_driver_api);\n+      Note: \"force\"-mode only available if low-power mode inactive.\n+\nThe issue was with: vcnl36825t: allow \\\"force\\\"-mode only if low-power mode is inactive\n\nBehavior of \\\"force\\\"-mode as described in datasheet cannot be achieved if\nlow-power mode is enabled. After triggering a sampling, the sensor will\nnot sample again for the period specified in measurement-time."
},{
  "instruction": "There is an issue in the following code. It relates to net: wifi: shell: Correction to connect command default case\n\nFor default case it should print the option character provided by user.\nExtra shell_help removed as it's being called in the caller function. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|MAX_BANDS_STR_LEN\nvalue|64\nend_define\n\nbegin_struct\nDECL|struct|__anon2b8714f80108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\ndecl_stmt|;\nDECL|member|scan_result\nname|uint32_t\nname|scan_result\ndecl_stmt|;\nDECL|union|__anon2b8714f8020a\nunion|union\nblock|{\nDECL|struct|__anon2b8714f80308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\ndefault|default:\nname|PR_ERROR\nargument_list|(\nliteral|\"Invalid option %c\\n\"\nargument_list|,\nname|opt\nargument_list|)\nexpr_stmt|;\nname|shell_help\nargument_list|(\nname|sh\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|EINVAL",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2b8714f80108\n+DECL|struct|__anon2bbebb6a0108\n-DECL|union|__anon2b8714f8020a\n+DECL|union|__anon2bbebb6a020a\n-DECL|struct|__anon2b8714f80308\n+DECL|struct|__anon2bbebb6a0308\n-name|opt\n-argument_list|)\n-expr_stmt|;\n-name|shell_help\n-argument_list|(\n-name|sh\n+name|optopt\nThe issue was with: net: wifi: shell: Correction to connect command default case\n\nFor default case it should print the option character provided by user.\nExtra shell_help removed as it's being called in the caller function."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: display: smartbond: Update PM policy\n\nSince the display port should be enabled\nby default and sleep is bound to the\nblanking status, PM constraints should\nbe acquired at initialization. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|display_smartbond_resume\nargument_list|(\nname|dev\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\nreturn|return\nname|ret\nreturn|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|ret\n+operator|==\n+literal|0\n+condition|)\n+block|{\n+comment|/* Display port should be enabled at this moment and so sleep is not allowed. */\n+name|lcdc_smartbond_pm_policy_state_lock_get\n+argument_list|(\n+name|data\n+argument_list|)\n+expr_stmt|;\n+block|}\nThe issue was with: drivers: display: smartbond: Update PM policy\n\nSince the display port should be enabled\nby default and sleep is bound to the\nblanking status, PM constraints should\nbe acquired at initialization."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: interrupt_controller: litex: add prefix\n\nadd litex prefix to its interupt controller. Please fix this issue.",
  "input": "Faulty tokenized code:\n\t  Programmable Interrupt Controller for the SweRV EH1 RISC-V CPU.\n\nconfig VEXRISCV_LITEX_IRQ\n\tbool \"VexRiscv LiteX Interrupt controller\"\n\tdefault y\n\tdepends on DT_HAS_VEXRISCV_INTC0_ENABLED\n\thelp\n\t  IRQ implementation for LiteX VexRiscv\n\nconfig LEON_IRQMP\n\tbool \"GRLIB IRQMP interrupt controller\"\nbegin_define\nDECL|macro|DT_DRV_COMPAT\ndefine|#\ndirective|define\nname|DT_DRV_COMPAT\nvalue|vexriscv_intc0\nend_define\n\nbegin_include\ninclude|#\ndirective|include\nsimilarity index 92%\nrename from dts/bindings/interrupt-controller/vexriscv-intc0.yaml\nrename to dts/bindings/interrupt-controller/litex,vexriscv-intc0.yaml\n# Copyright (c) 2018 - 2019 Antmicro <www.antmicro.com>\n# SPDX-License-Identifier: Apache-2.0\n\ndescription: LiteX VexRiscV interrupt controller\n\ncompatible: \"vexriscv-intc0\"\n\ninclude: [interrupt-controller.yaml, base.yaml]\n\nproperties:\n  reg:\n\t\t#address-cells = <1>;\n\t\t#size-cells = <1>;\n\t\tcompatible = \"litex,vexriscv\";\n\t\tranges;\n\t\tintc0: interrupt-controller@bc0 {\n\t\t\tcompatible = \"vexriscv-intc0\";\n\t\t\t#address-cells = <0>;\n\t\t\t#interrupt-cells = <2>;\n\t\t\tinterrupt-controller;\n\t\t\treg = <0xbc0 0x4 0xfc0 0x4>;\n\t\t\treg-names = \"irq_mask\", \"irq_pending\";",
  "result": "I corrected the issue in the code by changing the following tokens:\n-\tdepends on DT_HAS_VEXRISCV_INTC0_ENABLED\n+\tdepends on DT_HAS_LITEX_VEXRISCV_INTC0_ENABLED\n-value|vexriscv_intc0\n+value|litex_vexriscv_intc0\n-compatible: \"vexriscv-intc0\"\n+compatible: \"litex,vexriscv-intc0\"\n-\t\t\tcompatible = \"vexriscv-intc0\";\n+\t\t\tcompatible = \"litex,vexriscv-intc0\";\nThe issue was with: drivers: interrupt_controller: litex: add prefix\n\nadd litex prefix to its interupt controller."
},{
  "instruction": "There is an issue in the following code. It relates to arch: riscv: stacktrace: fix cpuid type and optimize branch with compiler\n\nChange the type of `cpu_id` to `uint8_t` since that is the type\nof `arch_curr_cpu()->id`.\n\nInstead of using precompiler switch (`#ifdef CONFIG_SMP`), use\nif-else shorthand instead (`IS_ENABLED(CONFIG_SMP)`). Please fix this issue.",
  "input": "Faulty tokenized code:\nname|arch_is_in_isr\nargument_list|()\ncondition|)\nblock|{\ncomment|/* We were servicing an interrupt */\nname|int\nname|cpu_id\ndecl_stmt|;\nifdef|#\ndirective|ifdef\nname|CONFIG_SMP\nname|cpu_id\noperator|=\nname|arch_curr_cpu\nargument_list|()\noperator|->\nname|id\nexpr_stmt|;\nelse|#\ndirective|else\nname|cpu_id\noperator|=\nliteral|0\nexpr_stmt|;\nendif|#\ndirective|endif\nname|start\noperator|=\noperator|(\nname|uintptr_t\noperator|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|int\n+name|uint8_t\n-decl_stmt|;\n-ifdef|#\n-directive|ifdef\n+init|=\n+name|IS_ENABLED\n+argument_list|(\n-name|cpu_id\n-operator|=\n+argument_list|)\n+condition|?\n-expr_stmt|;\n-else|#\n-directive|else\n-name|cpu_id\n-operator|=\n-literal|0\n-expr_stmt|;\n-endif|#\n-directive|endif\n+else|:\n+literal|0U\n+decl_stmt|;\nThe issue was with: arch: riscv: stacktrace: fix cpuid type and optimize branch with compiler\n\nChange the type of `cpu_id` to `uint8_t` since that is the type\nof `arch_curr_cpu()->id`.\n\nInstead of using precompiler switch (`#ifdef CONFIG_SMP`), use\nif-else shorthand instead (`IS_ENABLED(CONFIG_SMP)`)."
},{
  "instruction": "There is an issue in the following code. It relates to sensor: ms5837: fix compensate parameters for 30BA variant\n\nThe previous parameters seems wrong if we refer to:\nhttps://www.te.com/usa-en/product-CAT-BLPS0017.html Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|)\noperator|/\noperator|(\nliteral|1ll\noperator|<<\nliteral|23\noperator|)\nexpr_stmt|;\nname|OFFi\noperator|=\noperator|(\nliteral|3ll\noperator|*\nname|temp_sq\noperator|)\noperator|/\nliteral|1ll\nexpr_stmt|;\nname|SENSi\noperator|=\noperator|(\nliteral|5ll\noperator|*\nname|temp_sq\nexpr_stmt|;\nname|SENSi\noperator|+=\nliteral|5ll\noperator|*\nname|temp_sq\nexpr_stmt|;\nblock|}\nblock|}\nelse|else\nblock|{\nname|Ti\noperator|=\noperator|(\nliteral|1ll\noperator|*\nname|dT\noperator|*\nname|dT\noperator|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|23\n+literal|33\n+operator|(\n+operator|<<\n+literal|1\n+operator|)\n-literal|5ll\n+literal|4ll\n-literal|1ll\n+literal|2ll\nThe issue was with: sensor: ms5837: fix compensate parameters for 30BA variant\n\nThe previous parameters seems wrong if we refer to:\nhttps://www.te.com/usa-en/product-CAT-BLPS0017.html"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: w1: Ensure DQ pin is both input and output.\n\nDriver did not work on ESP32c3, by specifying pin to be output and\ninput solve the issue. Improve documentation, to highlight that driver\nis requiring open-drain support. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|GPIO_OUTPUT_INACTIVE\noperator||\nname|GPIO_OPEN_DRAIN\noperator||\nname|GPIO_PULL_UP\nargument_list|)\ndecl_stmt|;\nif|if\ncondition|(\nname|ret\n\n  Above:\n    - w1 is pin 13 on gpio0. The gpio is active when the pin is high, is\n      configured as an open-drain, and has a pull-up resistor.\n\ncompatible: \"zephyr,w1-gpio\"\n\ninclude: [w1-master.yaml]\n\nproperties:",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|GPIO_PULL_UP\n+name|GPIO_INPUT\n+  Implementation details:\n+    - Most drivers require the selected gpio to support open drain, this enables onewire\n+      devices to lower the signal when the SOC set the signal high.\n+    - Ensure pullup is strong enough (4.7K according to the specification). Standard pullup in\n+      SOC are usually weak, and may not be strong enough.\n+\nThe issue was with: drivers: w1: Ensure DQ pin is both input and output.\n\nDriver did not work on ESP32c3, by specifying pin to be output and\ninput solve the issue. Improve documentation, to highlight that driver\nis requiring open-drain support."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: si7006: fix redundant include in si7006\n\nRemove redundant include of `zephyr/logging/log.h` in si7006.c. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/sys/__assert.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/logging/log.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/drivers/i2c.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/logging/log.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<stdio.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<stdlib.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|\"si7006.h\"\nend_include\n\nbegin_expr_stmt\nname|LOG_MODULE_REGISTER\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_include\n-include|#\n-directive|include\n-file|<zephyr/logging/log.h>\n-end_include\n-\n-file|<zephyr/logging/log.h>\n+file|<stdio.h>\n-file|<stdio.h>\n+file|<stdlib.h>\n-file|<stdlib.h>\n+file|\"si7006.h\"\n-file|\"si7006.h\"\n+file|<zephyr/logging/log.h>\nThe issue was with: drivers: sensor: si7006: fix redundant include in si7006\n\nRemove redundant include of `zephyr/logging/log.h` in si7006.c."
},{
  "instruction": "There is an issue in the following code. It relates to sd: sd_ops: fix DISK_IOCTL_CTRL_SYNC return code\n\nSD IOCTL handling for DISK_IOCTL_CTRL_SYNC was falling through to the\ndefault return statement, and returning an error when disk sync\nsucceeded. Fix this issue by properly breaking in IOCTL handler. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|sdmmc_wait_ready\nargument_list|(\nname|card\nargument_list|)\nexpr_stmt|;\ndefault|default:\nname|ret\noperator|=\noperator|-\nname|ENOTSUP",
  "result": "I corrected the issue in the code by changing the following tokens:\n+break|break;\nThe issue was with: sd: sd_ops: fix DISK_IOCTL_CTRL_SYNC return code\n\nSD IOCTL handling for DISK_IOCTL_CTRL_SYNC was falling through to the\ndefault return statement, and returning an error when disk sync\nsucceeded. Fix this issue by properly breaking in IOCTL handler."
},{
  "instruction": "There is an issue in the following code. It relates to build: namespace syscall sources to `zephyr/`\n\nNamespace the `syscall_dispatch.c` & `syscall_export_llext.c`\nto `zephyr/` as well Please fix this issue.",
  "input": "Faulty tokenized code:\n    ${CMAKE_COMMAND} -E copy\n    ${syscall_list_h}\n    ${CMAKE_CURRENT_BINARY_DIR}/include/generated/syscall_list.h)\nendif()\n\nadd_custom_command(OUTPUT include/generated/syscall_dispatch.c ${syscall_list_h}\n  # Also, some files are written to include/generated/zephyr/syscalls/\n  COMMAND\n  ${PYTHON_EXECUTABLE}\n  ${ZEPHYR_BASE}/scripts/build/gen_syscalls.py\n  --json-file        ${syscalls_json}                     # Read this file\n  --base-output      include/generated/zephyr/syscalls    # Write to this dir\n --syscall-dispatch include/generated/syscall_dispatch.c # Write this file\n --syscall-export-llext  include/generated/syscall_export_llext.c\n  --syscall-list     ${syscall_list_h}\n  $<$<BOOL:${CONFIG_USERSPACE}>:--gen-mrsh-files>\n  ${SYSCALL_LONG_REGISTERS_ARG}\n  ${SYSCALL_SPLIT_TIMEOUT_ARG}\n  COMMAND\n    COMMAND\n        ${PYTHON_EXECUTABLE}\n        ${ZEPHYR_BASE}/scripts/build/gen_syscalls.py\n        --json-file        ${syscalls_json}                     # Read this file\n        --base-output      edk/include/generated/zephyr/syscalls           # Write to this dir\n       --syscall-dispatch edk/include/generated/syscall_dispatch.c # Write this file\n        --syscall-list     ${edk_syscall_list_h}\n        $<$<BOOL:${CONFIG_LLEXT_EDK_USERSPACE_ONLY}>:--userspace-only>\n        ${SYSCALL_LONG_REGISTERS_ARG}\n        ${SYSCALL_SPLIT_TIMEOUT_ARG}\n    COMMAND ${CMAKE_COMMAND}\n* The system call is added to the enumerated type of system call IDs,\n  which is expressed in ``include/generated/zephyr/syscall_list.h``. It is the name\n  of the API in uppercase, prefixed with ``K_SYSCALL_``.\n\n* An entry for the system call is created in the dispatch table\n ``_k_syscall_table``, expressed in ``include/generated/syscall_dispatch.c``\n\n  * This table only contains syscalls where their corresponding\n    prototypes are declared in header files when\n    :kconfig:option:`CONFIG_EMIT_ALL_SYSCALLS` is enabled:\n\n     * - ``strsignal_table.h``\n     * - ``syscall_list.h``\n     * - ``version.h``\n     * - ``zsr.h``\n\n and syscall headers are now namespaced into the ``zephyr/`` folder. The change is largely\n  automated, and the script can be found in :github:`63973`.\n  For the time being, the compatibility Kconfig (:kconfig:option:`CONFIG_LEGACY_GENERATED_INCLUDE_PATH`)\n  is enabled by default so that downstream applications will continue to compile, a warning message\n  will be generated during CMake configuration time.\n  This Kconfig will be deprecated and eventually removed in the future, developers are advised to\nend_function\n\nbegin_include\ninclude|#\ndirective|include\nfile|<syscall_dispatch.c>\nend_include\n\nend_unit\n\nend_expr_stmt\n\nbegin_include\ninclude|#\ndirective|include\nfile|<syscall_export_llext.c>\nend_include\n\nend_unit\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n-add_custom_command(OUTPUT include/generated/syscall_dispatch.c ${syscall_list_h}\n+add_custom_command(OUTPUT include/generated/zephyr/syscall_dispatch.c ${syscall_list_h}\n-  --syscall-dispatch include/generated/syscall_dispatch.c # Write this file\n-  --syscall-export-llext  include/generated/syscall_export_llext.c\n+  --syscall-dispatch include/generated/zephyr/syscall_dispatch.c # Write this file\n+  --syscall-export-llext  include/generated/zephyr/syscall_export_llext.c\n-        --syscall-dispatch edk/include/generated/syscall_dispatch.c # Write this file\n+        --syscall-dispatch edk/include/generated/zephyr/syscall_dispatch.c # Write this file\n-  ``_k_syscall_table``, expressed in ``include/generated/syscall_dispatch.c``\n+  ``_k_syscall_table``, expressed in ``include/generated/zephyr/syscall_dispatch.c``\n-  and syscall headers are now namespaced into the ``zephyr/`` folder. The change is largely\n+  as well as syscall headers & sources are now namespaced into the ``zephyr/`` folder. The change is largely\n-file|<syscall_dispatch.c>\n+file|<zephyr/syscall_dispatch.c>\n-file|<syscall_export_llext.c>\n+file|<zephyr/syscall_export_llext.c>\nThe issue was with: build: namespace syscall sources to `zephyr/`\n\nNamespace the `syscall_dispatch.c` & `syscall_export_llext.c`\nto `zephyr/` as well"
},{
  "instruction": "There is an issue in the following code. It relates to build: namespace `autoconf.h` with `zephyr/`\n\nNamespace the generated `autoconf.h` file with `zephyr/`. Please fix this issue.",
  "input": "Faulty tokenized code:\n#   Solution:\n#   The amendment function deletes the __cplusplus entry from\n#   CMAKE_EXTRA_GENERATOR_CXX_SYSTEM_DEFINED_MACROS.\n#\n#3. The amendment function appends the defines from\n#   ${CMAKE_BINARY_DIR}/zephyr/include/generated/autoconf.h to\n#   CMAKE_EXTRA_GENERATOR_C_SYSTEM_DEFINED_MACROS.\n#\nfunction(eclipse_cdt4_generator_amendment _param_defs)\n#\n# _param_defs handled values:\n\n# autoconf.h is generated by Kconfig and placed in\n# <build>/zephyr/include/generated/autoconf.h.\n# A project may request a custom location by setting AUTOCONF_H explicitly before\n# calling 'find_package(Zephyr)' or loading this module.\nset_ifndef(AUTOCONF_H ${PROJECT_BINARY_DIR}/include/generated/autoconf.h)\n# Re-configure (Re-execute all CMakeLists.txt code) when autoconf.h changes\nset_property(DIRECTORY APPEND PROPERTY CMAKE_CONFIGURE_DEPENDS ${AUTOCONF_H})\n\n# Folders needed for conf/mconf files (kconfig has no method of redirecting all output files).\n# conf/mconf needs to be run from a different directory because of: GH-3408\n  .. list-table::\n     :header-rows: 1\n\n     * - Affected header files\n     * - ``app_version.h``\n     * - ``cmake_intdef.h``\n     * - ``core-isa-dM.h``\n     * - ``devicetree_generated.h``\n     * - ``driver-validation.h``\n     * - ``kobj-types-enum.h``\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<autoconf.h>\nend_include\n\nbegin_ifdef\nifdef|#\ndirective|ifdef\nend_define\n\nbegin_include\ninclude|#\ndirective|include\nfile|<autoconf.h>\nend_include\n\nbegin_comment\ncomment|/* ARRAY_SIZE causes a conflict as it is defined both by TF-M and indirectly by devicetree.h */\nend_comment\nend_define\n\nbegin_include\ninclude|#\ndirective|include\nfile|<autoconf.h>\nend_include\n\nbegin_comment\ncomment|/* ARRAY_SIZE causes a conflict as it is defined both by TF-M and indirectly by devicetree.h */\nend_comment\n        load_allconfig(self, filename)\n\n    def write_autoconf(self, filename=None, header=None):\n        r\"\"\"\n        Writes out symbol values as a C header file, matching the format used\n       by include/generated/autoconf.h in the kernel.\n\n        The ordering of the #defines matches the one generated by\n        write_config(). The order in the C implementation depends on the hash\n        table implementation as of writing, and so won't match.\n\n\n        filename (default: None):\n          Path to write header to.\n\n          If None (the default), the path in the environment variable\n         KCONFIG_AUTOHEADER is used if set, and \"include/generated/autoconf.h\"\n          otherwise. This is compatible with the C tools.\n\n        header (default: None):\n          Text inserted verbatim at the beginning of the file. You would\n          usually want it enclosed in '/* */' to make it a C comment, and\n        that there were no changes to it. This is meant to reduce boilerplate\n        in tools, which can do e.g. print(kconf.write_autoconf()).\n        \"\"\"\n        if filename is None:\n            filename = os.getenv(\"KCONFIG_AUTOHEADER\",\n                                \"include/generated/autoconf.h\")\n\n        if self._write_if_changed(filename, self._autoconf_contents(header)):\n            return \"Kconfig header saved to '{}'\".format(filename)\n        return \"No change to Kconfig header in '{}'\".format(filename)\n\n        # and don't need any REM trick.\n        preproc_cmd += ['-DREM=']\n\n        preproc_cmd += ['-I', str(self.sof_src_dir / 'src')]\n        preproc_cmd += ['-imacros',\n                       str(pathlib.Path('zephyr') / 'include' / 'generated' / 'autoconf.h')]\n        preproc_cmd += ['-o', str(subdir / 'rimage_config.toml')]\n        self.command.inf(quote_sh_list(preproc_cmd))\n        subprocess.run(preproc_cmd, check=True, cwd=self.build_dir)\n\n    def sign(self, command, build_dir, build_conf, formats):\nend_pragma\n\nbegin_include\ninclude|#\ndirective|include\nfile|<autoconf.h>\nend_include\n\nbegin_define\nDECL|macro|IRAM_BASE\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-#   ${CMAKE_BINARY_DIR}/zephyr/include/generated/autoconf.h to\n+#   ${CMAKE_BINARY_DIR}/zephyr/include/generated/zephyr/autoconf.h to\n-set_ifndef(AUTOCONF_H ${PROJECT_BINARY_DIR}/include/generated/autoconf.h)\n+set_ifndef(AUTOCONF_H ${PROJECT_BINARY_DIR}/include/generated/zephyr/autoconf.h)\n+     * - ``autoconf.h``\n-file|<autoconf.h>\n+file|<zephyr/autoconf.h>\n-file|<autoconf.h>\n+file|<zephyr/autoconf.h>\n-file|<autoconf.h>\n+file|<zephyr/autoconf.h>\n-        by include/generated/autoconf.h in the kernel.\n+        by include/generated/zephyr/autoconf.h in the kernel.\n-          KCONFIG_AUTOHEADER is used if set, and \"include/generated/autoconf.h\"\n+          KCONFIG_AUTOHEADER is used if set, and \"include/generated/zephyr/autoconf.h\"\n-                                 \"include/generated/autoconf.h\")\n+                                 \"include/generated/zephyr/autoconf.h\")\n-                        str(pathlib.Path('zephyr') / 'include' / 'generated' / 'autoconf.h')]\n+                        str(pathlib.Path('zephyr') / 'include' / 'generated' / 'zephyr' / 'autoconf.h')]\n-file|<autoconf.h>\n+file|<zephyr/autoconf.h>\nThe issue was with: build: namespace `autoconf.h` with `zephyr/`\n\nNamespace the generated `autoconf.h` file with `zephyr/`."
},{
  "instruction": "There is an issue in the following code. It relates to usb: device: cdc_acm: Warn once about full ring buffer\n\nGenerating separate log entry at INFO level for every single character\ndropped is excessive and leads to log flood. Logging dropped character\nin no way helps end user and is really a delayed performance killer that\ntriggers when CDC ACM buffer gets full.\n\nIf user does not want to lose outgoing characters then the solution is\nto enable hardware flow control which properly blocks in the case the\noutput buffer is full. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|dev_data\noperator|->\nname|flow_ctrl\ncondition|)\nblock|{\nname|LOG_INF\nargument_list|(\nliteral|\"Ring buffer full, discard %c\"\nargument_list|,\nname|c\nargument_list|)\nexpr_stmt|;\nbreak|break;\nblock|}\nname|k_msleep",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|LOG_INF\n+name|LOG_WRN_ONCE\n-literal|\"Ring buffer full, discard %c\"\n-argument_list|,\n-name|c\n+literal|\"Ring buffer full, discard data\"\nThe issue was with: usb: device: cdc_acm: Warn once about full ring buffer\n\nGenerating separate log entry at INFO level for every single character\ndropped is excessive and leads to log flood. Logging dropped character\nin no way helps end user and is really a delayed performance killer that\ntriggers when CDC ACM buffer gets full.\n\nIf user does not want to lose outgoing characters then the solution is\nto enable hardware flow control which properly blocks in the case the\noutput buffer is full."
},{
  "instruction": "There is an issue in the following code. It relates to usb: device_next: uac2: Fix integer handling issues\n\nFix integer handling issues found out by Coverity Scan.\n\nCoverity-CID: 363729\nCoverity-CID: 363737 Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|)\nvalue|(setup->wValue& 0x00FF)\nend_define\n\nbegin_typedef\nDECL|enum|__anon289ac8c80103\ntypedef|typedef\nenum|enum\nblock|{\nDECL|enumerator|ENTITY_TYPE_INVALID\nname|ENTITY_TYPE_INVALID\ndecl_stmt|;\nif|if\ncondition|(\noperator|(\nname|as_idx\noperator|<\nname|cfg\noperator|->\nname|num_ifaces\noperator|)\nargument_list|)\ndecl_stmt|;\nname|int\nname|ret\ndecl_stmt|;\nname|buf\noperator|=\nname|net_buf_alloc\nargument_list|(\noperator|&",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon289ac8c80103\n+DECL|enum|__anon2b5e4fee0103\n+operator|>=\n+literal|0\n+operator|)\n+operator|&&\n+operator|(\n+name|as_idx\n+name|__ASSERT_NO_MSG\n+argument_list|(\n+name|as_idx\n+operator|>=\n+literal|0\n+argument_list|)\n+expr_stmt|;\nThe issue was with: usb: device_next: uac2: Fix integer handling issues\n\nFix integer handling issues found out by Coverity Scan.\n\nCoverity-CID: 363729\nCoverity-CID: 363737"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: ethernet: enc28j60: ESTAT TXABRT bit should be cleared on error\n\nIf the TXABRT bit from ESTAT is ever set (because of a single failed\ntransmission), the driver will continue showing an error on every\nsubsequent packet sent, although it is correctly sent:\n\n\t <err> eth_enc28j60: TX failed!\n\nThe enc28j60 datasheet says under\n\\\"12.1.3 TRANSMIT ERROR INTERRUPT FLAG (TXERIF)\\\":\n\n\t\\\"After determining the problem and solution, the\n\thost controller should clear the LATECOL (if set) and\n\tTXABRT bits so that future aborts can be detected\n\taccurately.\\\"\n\nTherefore, clear the TXABRT and LATECOL bits in case of transmission error. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|dev\noperator|->\nname|name\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|EIO\nreturn|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* 12.1.3 \"TRANSMIT ERROR INTERRUPT FLAG (TXERIF)\" states: \t\t * \t\t * \"After determining the problem and solution, the \t\t * host controller should clear the LATECOL (if set) and \t\t * TXABRT bits so that future aborts can be detected \t\t * accurately.\" \t\t */\n+name|eth_enc28j60_clear_eth_reg\n+argument_list|(\n+name|dev\n+argument_list|,\n+name|ENC28J60_REG_ESTAT\n+argument_list|,\n+name|ENC28J60_BIT_ESTAT_TXABRT\n+operator||\n+name|ENC28J60_BIT_ESTAT_LATECOL\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: ethernet: enc28j60: ESTAT TXABRT bit should be cleared on error\n\nIf the TXABRT bit from ESTAT is ever set (because of a single failed\ntransmission), the driver will continue showing an error on every\nsubsequent packet sent, although it is correctly sent:\n\n\t <err> eth_enc28j60: TX failed!\n\nThe enc28j60 datasheet says under\n\\\"12.1.3 TRANSMIT ERROR INTERRUPT FLAG (TXERIF)\\\":\n\n\t\\\"After determining the problem and solution, the\n\thost controller should clear the LATECOL (if set) and\n\tTXABRT bits so that future aborts can be detected\n\taccurately.\\\"\n\nTherefore, clear the TXABRT and LATECOL bits in case of transmission error."
},{
  "instruction": "There is an issue in the following code. It relates to usb: device: usb_descriptor.c\n\nfix cbprintf_package warning.\ncbprintf_package complains about char usage for %p\nstring argument and suggests void * usage. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|idx_max\nargument_list|,\nname|ascii_idx_max\nargument_list|,\nname|buf\nargument_list|)\nexpr_stmt|;\nfor|for\ncontrol|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+name|void\n+operator|*\n+operator|)\nThe issue was with: usb: device: usb_descriptor.c\n\nfix cbprintf_package warning.\ncbprintf_package complains about char usage for %p\nstring argument and suggests void * usage."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: usb: device: fix cbprintf_package warning\n\ncbprintf_package complains about char usage for %p\nstring argument and suggests void * usage. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|read_offset\nargument_list|,\nname|read_count\nargument_list|,\nname|data\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\noperator|->\nname|read_offset\nargument_list|,\nname|read_count\nargument_list|,\nname|data\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+name|void\n+operator|*\n+operator|)\n+operator|(\n+name|void\n+operator|*\n+operator|)\nThe issue was with: drivers: usb: device: fix cbprintf_package warning\n\ncbprintf_package complains about char usage for %p\nstring argument and suggests void * usage."
},{
  "instruction": "There is an issue in the following code. It relates to net: lwm2m: Fix null dereference when post-write cb is set\n\nWhen opaque resources have post-write callback set, but\nthe write is not a Block-Wise write, there is no block_ctx\nand the code causes null pointer dereference when calculating\nthe offset of the data. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|opaque_ctx\noperator|.\nname|len\nargument_list|,\nname|msg\noperator|->\nname|in\noperator|.\nname|block_ctx\noperator|->\nname|ctx\noperator|.\nname|current\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|ret",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+name|msg\n+operator|->\n+name|in\n+operator|.\n+name|block_ctx\n+condition|?\n+else|:\n+literal|0\n+operator|)\nThe issue was with: net: lwm2m: Fix null dereference when post-write cb is set\n\nWhen opaque resources have post-write callback set, but\nthe write is not a Block-Wise write, there is no block_ctx\nand the code causes null pointer dereference when calculating\nthe offset of the data."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: timer: grtc: Fix ticks calculation for GRTC\n\nFixed calculation of GRTC ticks inside\n`z_nrf_grtc_timer_get_ticks()` function. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|result\ndecl_stmt|;\nname|int64_t\nname|abs_ticks\ndecl_stmt|;\nname|curr_time\noperator|=\nname|counter\nargument_list|()\nexpr_stmt|;\nname|curr_tick\noperator|=\nname|sys_clock_tick_get\nargument_list|()\nexpr_stmt|;\nname|abs_ticks\noperator|=\nname|Z_TICK_ABS\nargument_list|(\nname|t\ncondition|)\nblock|{\ncomment|/* relative timeout */\nreturn|return\noperator|(\nname|t\noperator|.\nname|ticks\noperator|>\noperator|(\nname|int64_t\noperator|)\nname|COUNTER_SPAN\nname|EINVAL\nelse|:\noperator|(\nname|curr_time\noperator|+\nname|t\noperator|.\nname|ticks\noperator|)\nreturn|;\nblock|}\ncomment|/* absolute timeout */\nname|result\noperator|=\nname|abs_ticks\noperator|-\nname|curr_tick\nexpr_stmt|;\nif|if\ncondition|(\nname|result\noperator|>\nname|uint64_t\nmodifier|*\nname|val\nparameter_list|)\nfunction_decl|;\ncomment|/** @brief  Set compare channel to given value.  *  * @param chan Channel ID.  *  * @param target_time Absolute target time in ticks.  *  * @param handler User function called in the context of the GRTC interrupt.  *  * @param user_data Data passed to the handler.  *  * @retval 0 if the compare channel was set successfully.  * @retval -EPERM if either channel is unavailable or SYSCOUNTER is not running.  */\nname|int\nname|z_nrf_grtc_timer_set\nparameter_list|(\nname|int32_t\nname|chan",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|int64_t\n+name|grtc_ticks\n+decl_stmt|;\n+name|grtc_ticks\n+operator|=\n+name|t\n+operator|.\n+name|ticks\n+operator|*\n+name|CYC_PER_TICK\n+expr_stmt|;\n-name|t\n-operator|.\n-name|ticks\n+name|grtc_ticks\n-name|t\n-operator|.\n-name|ticks\n+name|grtc_ticks\n+operator|(\n+operator|)\n+operator|*\n+name|CYC_PER_TICK\n-comment|/** @brief  Set compare channel to given value.  *  * @param chan Channel ID.  *  * @param target_time Absolute target time in ticks.  *  * @param handler User function called in the context of the GRTC interrupt.  *  * @param user_data Data passed to the handler.  *  * @retval 0 if the compare channel was set successfully.  * @retval -EPERM if either channel is unavailable or SYSCOUNTER is not running.  */\n+comment|/** @brief  Set compare channel to given value.  *  * @param chan Channel ID.  *  * @param target_time Absolute target time in GRTC ticks.  *  * @param handler User function called in the context of the GRTC interrupt.  *  * @param user_data Data passed to the handler.  *  * @retval 0 if the compare channel was set successfully.  * @retval -EPERM if either channel is unavailable or SYSCOUNTER is not running.  */\nThe issue was with: drivers: timer: grtc: Fix ticks calculation for GRTC\n\nFixed calculation of GRTC ticks inside\n`z_nrf_grtc_timer_get_ticks()` function."
},{
  "instruction": "There is an issue in the following code. It relates to shell: backend: telnet: Rename write and read functions\n\nRename write() to telnet_write(), and read() to telnet_read() so\nthat if we enable CONFIG_POSIX_API, the compiler will not complain\nabout those two functions as they conflict with POSIX API ones. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|write (const struct shell_transport * transport,const void * data,size_t length,size_t * cnt)\nspecifier|static\nname|int\nname|write\nparameter_list|(\nspecifier|const\nname|struct\nname|shell_transport\nmodifier|*\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|read (const struct shell_transport * transport,void * data,size_t length,size_t * cnt)\nspecifier|static\nname|int\nname|read\nparameter_list|(\nspecifier|const\nname|struct\nname|shell_transport\nmodifier|*\nname|enable\nblock|,\noperator|.\nname|write\noperator|=\nname|write\nblock|,\noperator|.\nname|read\noperator|=\nname|read\nblock|}\ndecl_stmt|;\nend_decl_stmt\n\nbegin_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|write (const struct shell_transport * transport,const void * data,size_t length,size_t * cnt)\n+DECL|function|telnet_write (const struct shell_transport * transport,const void * data,size_t length,size_t * cnt)\n-name|write\n+name|telnet_write\n-DECL|function|read (const struct shell_transport * transport,void * data,size_t length,size_t * cnt)\n+DECL|function|telnet_read (const struct shell_transport * transport,void * data,size_t length,size_t * cnt)\n-name|read\n+name|telnet_read\n-name|write\n+name|telnet_write\n-name|read\n+name|telnet_read\nThe issue was with: shell: backend: telnet: Rename write and read functions\n\nRename write() to telnet_write(), and read() to telnet_read() so\nthat if we enable CONFIG_POSIX_API, the compiler will not complain\nabout those two functions as they conflict with POSIX API ones."
},{
  "instruction": "There is an issue in the following code. It relates to net: dns: Fix resolver debug print\n\nMake sure that we are not trying to print NULL pointer string. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|\"Cancelling DNS req %u (name %s type %d hash %u)\"\nargument_list|,\nname|dns_id\nargument_list|,\nname|query_name\nargument_list|,\nname|ctx\noperator|->\nname|queries\nindex|[",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|==\n+name|NULL\n+condition|?\n+literal|\"<unknown>\"\n+else|:\n+name|query_name\nThe issue was with: net: dns: Fix resolver debug print\n\nMake sure that we are not trying to print NULL pointer string."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: i2s: i2s_ll_stm32: tx_stream_disable: Add busy wait\n\nAdd a k_busy_wait to the function tx_stream_disable\nto be able to complete the drain of the TX queue before disabling. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|mem_block\noperator|=\nname|NULL\nexpr_stmt|;\nblock|}\nname|LL_I2S_Disable\nargument_list|(\nname|cfg\noperator|->\nname|i2s",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Wait for TX queue to drain before disabling */\n+name|k_busy_wait\n+argument_list|(\n+literal|100\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: i2s: i2s_ll_stm32: tx_stream_disable: Add busy wait\n\nAdd a k_busy_wait to the function tx_stream_disable\nto be able to complete the drain of the TX queue before disabling."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: crypto: stm32: AES CTR IV is 16bytes\n\nAES-CTR IV is the same as the block size 128-bits(16 bytes)\n regardless of key size. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\ndecl_stmt|;\nname|int\nname|ivlen\ninit|=\nname|ctx\noperator|->\nname|keylen\noperator|-\noperator|(\nname|ctx\noperator|->\nname|mode_params\nblock|}\ndecl_stmt|;\nname|int\nname|ivlen\ninit|=\nname|ctx\noperator|->\nname|keylen\noperator|-\noperator|(\nname|ctx\noperator|->\nname|mode_params",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|ctx\n-operator|->\n-name|keylen\n+name|BLOCK_LEN_BYTES\n-name|ctx\n-operator|->\n-name|keylen\n+name|BLOCK_LEN_BYTES\nThe issue was with: drivers: crypto: stm32: AES CTR IV is 16bytes\n\nAES-CTR IV is the same as the block size 128-bits(16 bytes)\n regardless of key size."
},{
  "instruction": "There is an issue in the following code. It relates to shell: fix index out bound issue\n\nIn order to prevent index out of bounds access of the sh->ctx->cmd_buff\narray when sh->ctx->cmd_buff_pos is 0, it has been added a check for the\nvalue of sh->ctx->cmd_buff_pos.\n\nThis ensures that the array will not be accessed beyond its boundaries. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\ncomment|/* If last command is not completed (followed by space) it is treated \t * as uncompleted one. \t */\nname|int\nname|space\ninit|=\nname|isspace\nargument_list|(\noperator|(\nname|int\noperator|)\nname|cmd_buff_pos\noperator|-\nliteral|1\nindex|]\nargument_list|)\ndecl_stmt|;\ncomment|/* root command completion */\nif|if\ncondition|(\noperator|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+name|sh\n+operator|->\n+name|ctx\n+operator|->\n+name|cmd_buff_pos\n+operator|>\n+literal|0\n+operator|)\n+condition|?\n+else|:\n+literal|0\nThe issue was with: shell: fix index out bound issue\n\nIn order to prevent index out of bounds access of the sh->ctx->cmd_buff\narray when sh->ctx->cmd_buff_pos is 0, it has been added a check for the\nvalue of sh->ctx->cmd_buff_pos.\n\nThis ensures that the array will not be accessed beyond its boundaries."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: clock_control: stm32: clean up unnecessary code\n\nThis commit removes unnecessary initialization of the local variable\nwhere its value is guaranteed to be overwritten by subsequent operations. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|dev\nparameter_list|)\nblock|{\nname|uint32_t\nname|old_hclk_freq\ninit|=\nliteral|0\ndecl_stmt|;\nname|int\nname|r\ninit|=\nliteral|0\ndecl_stmt|;\nname|ARG_UNUSED\nargument_list|(\nname|dev\nargument_list|)\nargument_list|(\nname|CONFIG_CPU_CORTEX_M7\nargument_list|)\nname|uint32_t\nname|old_hclk_freq\ninit|=\nliteral|0\ndecl_stmt|;\nname|uint32_t\nname|new_hclk_freq\ninit|=\nliteral|0\ndecl_stmt|;\ncomment|/* HW semaphore Clock enable */\nif|#\ndirective|if\nname|defined\nname|dev\nparameter_list|)\nblock|{\nname|uint32_t\nname|old_hclk_freq\ninit|=\nliteral|0\ndecl_stmt|;\nname|int\nname|r\ninit|=\nliteral|0\ndecl_stmt|;\nname|ARG_UNUSED\nargument_list|(\nname|dev\nargument_list|)\nname|uint32_t\nname|old_flash_freq\ndecl_stmt|;\nname|int\nname|r\ninit|=\nliteral|0\ndecl_stmt|;\nname|ARG_UNUSED\nargument_list|(\nname|dev\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-init|=\n-literal|0\n-init|=\n-literal|0\n-init|=\n-literal|0\n-init|=\n-literal|0\n-init|=\n-literal|0\n-init|=\n-literal|0\n-init|=\n-literal|0\nThe issue was with: drivers: clock_control: stm32: clean up unnecessary code\n\nThis commit removes unnecessary initialization of the local variable\nwhere its value is guaranteed to be overwritten by subsequent operations."
},{
  "instruction": "There is an issue in the following code. It relates to soc: intel_adsp: only implement FW_STATUS boot protocol for cavs\n\nThe software protocol to write status value of 0x05 (FW_ENTERED)\ninto memory window 0 at Zephyr boot, is not needed in the ace1.x\nboot flow and does not match the semantics host systems are expecting\nat this location in the memory window (e.g. write of 0x05 is not\nexpected).\n\nMake this logic specific to intel_adsp_cavs platforms and move the code\nout from common intel_adsp code.\n\nThis commit depends on update to cavstool.py to use correct\nROM status register to observe boot state. Please fix this issue.",
  "input": "Faulty tokenized code:\n\nzephyr_library_sources(\n    sram.c\n    power.c\n    power_down_cavs.S\n    )\n\nif(CONFIG_SMP OR CONFIG_MP_MAX_NUM_CPUS GREATER 1)\n    zephyr_library_sources(multiprocessing.c)\nendif()\nsimilarity index 100%\nrename from soc/intel/intel_adsp/common/boot_complete.c\nrename to soc/intel/intel_adsp/cavs/boot_complete.c\nzephyr_library_sources(\n    rimage_modules.c\n    boot.c\n    soc.c\n    mem_window.c\n   boot_complete.c\n    )\n\nzephyr_library_sources_ifdef(CONFIG_ADSP_CLOCK clk.c)\n\nif(CONFIG_SMP OR CONFIG_MP_MAX_NUM_CPUS GREATER 1)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+    boot_complete.c\n-    boot_complete.c\nThe issue was with: soc: intel_adsp: only implement FW_STATUS boot protocol for cavs\n\nThe software protocol to write status value of 0x05 (FW_ENTERED)\ninto memory window 0 at Zephyr boot, is not needed in the ace1.x\nboot flow and does not match the semantics host systems are expecting\nat this location in the memory window (e.g. write of 0x05 is not\nexpected).\n\nMake this logic specific to intel_adsp_cavs platforms and move the code\nout from common intel_adsp code.\n\nThis commit depends on update to cavstool.py to use correct\nROM status register to observe boot state."
},{
  "instruction": "There is an issue in the following code. It relates to soc: stm32: common: Fix proprocessor if/else flow\n\nNo reason to be more complex than it should be. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|CONFIG_SOC_SERIES_STM32MP1X\nargument_list|)\nname|HAL_EnableDBGStopMode\nargument_list|()\nexpr_stmt|;\nelse|#\ndirective|else\ncomment|/* CONFIG_SOC_SERIES_STM32H7X || CONFIG_SOC_SERIES_STM32MP1X */\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_STM32G0X\nargument_list|)\noperator|||\nname|LL_DBGMCU_EnableDBGStopMode\nargument_list|()\nexpr_stmt|;\nendif|#\ndirective|endif\nendif|#\ndirective|endif\ncomment|/* CONFIG_SOC_SERIES_STM32H7X || CONFIG_SOC_SERIES_STM32MP1X */\nelse|#\ndirective|else\ncomment|/* keeping in mind that debugging draws a lot of power we explcitly disable when not needed */\nif|#\ndirective|if\nname|CONFIG_SOC_SERIES_STM32MP1X\nargument_list|)\nname|HAL_DisableDBGStopMode\nargument_list|()\nexpr_stmt|;\nelse|#\ndirective|else\ncomment|/* CONFIG_SOC_SERIES_STM32H7X || CONFIG_SOC_SERIES_STM32MP1X */\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_STM32G0X\nargument_list|)\noperator|||\nexpr_stmt|;\nendif|#\ndirective|endif\nendif|#\ndirective|endif\ncomment|/* CONFIG_SOC_SERIES_STM32H7X || CONFIG_SOC_SERIES_STM32MP1X */\nendif|#\ndirective|endif\ncomment|/* CONFIG_STM32_ENABLE_DEBUG_SLEEP_STOP */\nreturn|return\nliteral|0\nreturn|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n-else|#\n-directive|else\n-comment|/* CONFIG_SOC_SERIES_STM32H7X || CONFIG_SOC_SERIES_STM32MP1X */\n-if|#\n-directive|if\n+elif|#\n+directive|elif\n-endif|#\n-directive|endif\n-comment|/* CONFIG_SOC_SERIES_STM32H7X || CONFIG_SOC_SERIES_STM32MP1X */\n-else|#\n-directive|else\n-comment|/* CONFIG_SOC_SERIES_STM32H7X || CONFIG_SOC_SERIES_STM32MP1X */\n-if|#\n-directive|if\n+elif|#\n+directive|elif\n-comment|/* CONFIG_SOC_SERIES_STM32H7X || CONFIG_SOC_SERIES_STM32MP1X */\n-endif|#\n-directive|endif\nThe issue was with: soc: stm32: common: Fix proprocessor if/else flow\n\nNo reason to be more complex than it should be."
},{
  "instruction": "There is an issue in the following code. It relates to soc: stm32: common: Fix Kconfig symbol usage\n\nThese symbols don't exist. Please fix this issue.",
  "input": "Faulty tokenized code:\ncomment|/* CONFIG_SOC_SERIES_STM32H7X || CONFIG_SOC_SERIES_STM32MP1X */\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|SOC_SERIES_STM32G0X\nargument_list|)\noperator|||\nname|defined\nargument_list|(\nname|SOC_SERIES_STM32C0X\nargument_list|)\nname|LL_APB1_GRP1_EnableClock\nargument_list|(\nname|LL_APB1_GRP1_PERIPH_DBGMCU\nargument_list|)\nexpr_stmt|;\nelif|#\ndirective|elif\nname|defined\nargument_list|(\nname|SOC_SERIES_STM32F0X\nargument_list|)\nname|LL_APB1_GRP2_EnableClock\nargument_list|(\nname|LL_APB1_GRP2_PERIPH_DBGMCU\nargument_list|)\nexpr_stmt|;\nelif|#\ndirective|elif\nname|defined\nargument_list|(\nname|SOC_SERIES_STM32L0X\nargument_list|)\nname|LL_APB2_GRP1_EnableClock\nargument_list|(\nname|LL_APB2_GRP1_PERIPH_DBGMCU\nargument_list|)\ncomment|/* CONFIG_SOC_SERIES_STM32H7X || CONFIG_SOC_SERIES_STM32MP1X */\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|SOC_SERIES_STM32G0X\nargument_list|)\noperator|||\nname|defined\nargument_list|(\nname|SOC_SERIES_STM32C0X\nargument_list|)\nname|LL_APB1_GRP1_EnableClock\nargument_list|(\nname|LL_APB1_GRP1_PERIPH_DBGMCU\nargument_list|)\nexpr_stmt|;\nelif|#\ndirective|elif\nname|defined\nargument_list|(\nname|SOC_SERIES_STM32F0X\nargument_list|)\nname|LL_APB1_GRP2_EnableClock\nargument_list|(\nname|LL_APB1_GRP2_PERIPH_DBGMCU\nargument_list|)\nexpr_stmt|;\nelif|#\ndirective|elif\nname|defined\nargument_list|(\nname|SOC_SERIES_STM32L0X\nargument_list|)\nname|LL_APB2_GRP1_EnableClock\nargument_list|(\nname|LL_APB2_GRP1_PERIPH_DBGMCU\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|SOC_SERIES_STM32G0X\n+name|CONFIG_SOC_SERIES_STM32G0X\n-name|SOC_SERIES_STM32C0X\n+name|CONFIG_SOC_SERIES_STM32C0X\n-name|SOC_SERIES_STM32F0X\n+name|CONFIG_SOC_SERIES_STM32F0X\n-name|SOC_SERIES_STM32L0X\n+name|CONFIG_SOC_SERIES_STM32L0X\n-name|SOC_SERIES_STM32G0X\n+name|CONFIG_SOC_SERIES_STM32G0X\n-name|SOC_SERIES_STM32C0X\n+name|CONFIG_SOC_SERIES_STM32C0X\n-name|SOC_SERIES_STM32F0X\n+name|CONFIG_SOC_SERIES_STM32F0X\n-name|SOC_SERIES_STM32L0X\n+name|CONFIG_SOC_SERIES_STM32L0X\nThe issue was with: soc: stm32: common: Fix Kconfig symbol usage\n\nThese symbols don't exist."
},{
  "instruction": "There is an issue in the following code. It relates to net: ppp: Optimize memory allocation\n\nnet_pkt_alloc_buffer() deducts the free space from the requested number\nof bytes.\n\nAs ppp_save_byte() calls net_pkt_alloc_buffer() when the packet has one\nbyte available still, this causes all but the first net_buf in the\npacket to be of size CONFIG_NET_BUF_DATA_SIZE - 1.\n\nConsequences:\n - With CONFIG_NET_BUF_FIXED_DATA_SIZE enabled, one byte per net_buf\n   gets wasted.\n - CONFIG_NET_BUF_DATA_SIZE has typically an even, likely even a power\n   of two value. Using exactly one byte less per buffer causes\n   operations that require aligned memory (e.g. DMA) to become\n   inefficient or to not work at all. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ppp\noperator|->\nname|pkt\nargument_list|,\nname|CONFIG_NET_BUF_DATA_SIZE\nargument_list|,\nname|AF_UNSPEC\nargument_list|,\nname|K_NO_WAIT\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|+\n+name|ppp\n+operator|->\n+name|available\nThe issue was with: net: ppp: Optimize memory allocation\n\nnet_pkt_alloc_buffer() deducts the free space from the requested number\nof bytes.\n\nAs ppp_save_byte() calls net_pkt_alloc_buffer() when the packet has one\nbyte available still, this causes all but the first net_buf in the\npacket to be of size CONFIG_NET_BUF_DATA_SIZE - 1.\n\nConsequences:\n - With CONFIG_NET_BUF_FIXED_DATA_SIZE enabled, one byte per net_buf\n   gets wasted.\n - CONFIG_NET_BUF_DATA_SIZE has typically an even, likely even a power\n   of two value. Using exactly one byte less per buffer causes\n   operations that require aligned memory (e.g. DMA) to become\n   inefficient or to not work at all."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: samples: hci_ipc: Fix incorrect NULL pointer check\n\nThe condition was the inverse of what it should have been, leading to an\ninevitable NULL pointer dereference later. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|buf\noperator|==\nname|NULL\ncondition|)\nblock|{\ncomment|/* Send the event over ipc */\nname|hci_ipc_send",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|==\n+operator|!=\nThe issue was with: Bluetooth: samples: hci_ipc: Fix incorrect NULL pointer check\n\nThe condition was the inverse of what it should have been, leading to an\ninevitable NULL pointer dereference later."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: CAP: fix bug in reception start\n\nThe wrong number of subgroups was used in copying subgroups Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nexpr|struct\nname|bt_bap_bass_subgroup\nargument_list|)\noperator|*\nname|add_src_param\noperator|.\nname|num_subgroups\nargument_list|)\nexpr_stmt|;\nblock|}\nname|active_proc",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|add_src_param\n-operator|.\n+name|member_param\n+operator|->\nThe issue was with: Bluetooth: CAP: fix bug in reception start\n\nThe wrong number of subgroups was used in copying subgroups"
},{
  "instruction": "There is an issue in the following code. It relates to net: dns: The DNS_EAI_ALLDONE is not an error\n\nIf DNS_EAI_ALLDONE is returned, it indicates that the request\nwas done and should not be considered an error. Please fix this issue.",
  "input": "Faulty tokenized code:\nif|if\ncondition|(\nname|ret\noperator|<\nliteral|0\ncondition|)\nblock|{\nname|NET_ERR\nargument_list|(\nliteral|\"DNS recv error (%d)\"",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|&&\n+name|ret\n+operator|!=\n+name|DNS_EAI_ALLDONE\nThe issue was with: net: dns: The DNS_EAI_ALLDONE is not an error\n\nIf DNS_EAI_ALLDONE is returned, it indicates that the request\nwas done and should not be considered an error."
},{
  "instruction": "There is an issue in the following code. It relates to arch: riscv: check esf before calling z_riscv_unwind_stack\n\nMake sure that esf is not NULL before calling\nz_riscv_unwind_stack to prevent NULL pointer dereferencing. Please fix this issue.",
  "input": "Faulty tokenized code:\ncondition|(\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_RISCV_EXCEPTION_STACK_TRACE\nargument_list|)\ncondition|)\nblock|{\nname|z_riscv_unwind_stack\nargument_list|(\nname|esf\nname|struct\nname|stackframe\nmodifier|*\nname|frame\ndecl_stmt|;\nif|if\ncondition|(\nname|esf\noperator|==\nname|NULL\ncondition|)\nblock|{\nreturn|return;\nblock|}\nname|LOG_ERR\nargument_list|(\nliteral|\"call trace:\"\nargument_list|)\nexpr_stmt|;\nname|uintptr_t\noperator|*\noperator|)\nname|sp\ndecl_stmt|;\nif|if\ncondition|(\nname|esf\noperator|==\nname|NULL\ncondition|)\nblock|{\nreturn|return;\nblock|}\nname|LOG_ERR\nargument_list|(\nliteral|\"call trace:\"\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|&&\n+operator|(\n+name|esf\n+operator|!=\n+name|NULL\n+operator|)\n-if|if\n-condition|(\n-name|esf\n-operator|==\n-name|NULL\n-condition|)\n-block|{\n-return|return;\n-block|}\n-if|if\n-condition|(\n-name|esf\n-operator|==\n-name|NULL\n-condition|)\n-block|{\n-return|return;\n-block|}\nThe issue was with: arch: riscv: check esf before calling z_riscv_unwind_stack\n\nMake sure that esf is not NULL before calling\nz_riscv_unwind_stack to prevent NULL pointer dereferencing."
},{
  "instruction": "There is an issue in the following code. It relates to pm: system: Restore clock after sleep\n\nsys_clock_idle_exits was being called *only* when the system\nwas resumed from interruption. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|pm_state_notify\nargument_list|(\nname|false\nargument_list|)\nexpr_stmt|;\nname|z_cpus_pm_state\nindex|[\nname|id\nindex|]\noperator|=\nblock|{\ncomment|/* Some CPU low power states require notification at the ISR \t * to allow any operations that needs to be done before kernel \t * switches task or processes nested interrupts. \t * This can be simply ignored if not required. \t */\nname|pm_system_resume\nargument_list|()\nexpr_stmt|;\nifdef|#\ndirective|ifdef\nname|CONFIG_SYS_CLOCK_EXISTS\nname|sys_clock_idle_exit\nargument_list|()\nexpr_stmt|;\nendif|#\ndirective|endif\ncomment|/* CONFIG_SYS_CLOCK_EXISTS */\nblock|}\nend_function\n\nend_unit\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n+ifdef|#\n+directive|ifdef\n+name|CONFIG_SYS_CLOCK_EXISTS\n+name|sys_clock_idle_exit\n+argument_list|()\n+expr_stmt|;\n+endif|#\n+directive|endif\n+comment|/* CONFIG_SYS_CLOCK_EXISTS */\n-ifdef|#\n-directive|ifdef\n-name|CONFIG_SYS_CLOCK_EXISTS\n-name|sys_clock_idle_exit\n-argument_list|()\n-expr_stmt|;\n-endif|#\n-directive|endif\n-comment|/* CONFIG_SYS_CLOCK_EXISTS */\nThe issue was with: pm: system: Restore clock after sleep\n\nsys_clock_idle_exits was being called *only* when the system\nwas resumed from interruption."
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: counter: support rtc timer\n\nAdd support for rtc timer node in the test. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nendif|#\ndirective|endif\nifdef|#\ndirective|ifdef\nname|CONFIG_COUNTER_NXP_S32_SYS_TIMER\nname|DEVS_FOR_DT_COMPAT\nargument_list|(\nargument|nxp_s32_sys_timer\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|CONFIG_COUNTER_TMR_RTC_ESP32\n+name|DEVS_FOR_DT_COMPAT\n+argument_list|(\n+argument|espressif_esp32_rtc_timer\n+argument_list|)\n+endif|#\n+directive|endif\n+ifdef|#\n+directive|ifdef\nThe issue was with: tests: drivers: counter: support rtc timer\n\nAdd support for rtc timer node in the test."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: can: shell: print raw DLC when sending frame, not bytes\n\nPrint the raw DLC when enqueuing a CAN frame for sending, not the\ncorresponding number of bytes.\n\nFixes: #73309 Please fix this issue.",
  "input": "Faulty tokenized code:\ncondition|?\nliteral|1\nelse|:\nliteral|0\nargument_list|,\nname|can_dlc_to_bytes\nargument_list|(\nname|frame\noperator|.\nname|dlc\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|err\noperator|=\nname|can_send\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|can_dlc_to_bytes\n-argument_list|(\n-argument_list|)\nThe issue was with: drivers: can: shell: print raw DLC when sending frame, not bytes\n\nPrint the raw DLC when enqueuing a CAN frame for sending, not the\ncorresponding number of bytes.\n\nFixes: #73309"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: can: shell: fully initialize frame before sending\n\nZerorise the CAN frame before filling in data to ensure all data bytes are\ninitialized.\n\nFixes: #73309 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|frame_no\ndecl_stmt|;\nname|struct\nname|can_frame\nname|frame\ndecl_stmt|;\nname|uint32_t\nname|id_mask\ndecl_stmt|;\nname|int",
  "result": "I corrected the issue in the code by changing the following tokens:\n+init|=\n+block|{\n+literal|0\n+block|}\nThe issue was with: drivers: can: shell: fully initialize frame before sending\n\nZerorise the CAN frame before filling in data to ensure all data bytes are\ninitialized.\n\nFixes: #73309"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: intc_dw_ace: convert to use instance-based macros\n\nDefine the DRV_COMPAT and use instance-based device DT macros. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright (c) 2022 Intel Corporation  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/device.h>\nend_include\nbegin_define\nDECL|macro|ACE_INTC\ndefine|#\ndirective|define\nname|ACE_INTC\nvalue|((volatile struct dw_ictl_registers *)DT_REG_ADDR(DT_NODELABEL(ace_intc)))\nend_define\n\nbegin_function\nDECL|function|is_dw_irq (uint32_t irq)\nspecifier|static\nblock|}\ndecl_stmt|;\nend_decl_stmt\n\nbegin_expr_stmt\nname|DEVICE_DT_DEFINE\nargument_list|(\nname|DT_NODELABEL\nargument_list|(\nname|ace_intc\nargument_list|)\nargument_list|,\nname|dw_ace_init\nargument_list|,\nname|NULL\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_define\n+DECL|macro|DT_DRV_COMPAT\n+define|#\n+directive|define\n+name|DT_DRV_COMPAT\n+value|intel_ace_intc\n+end_define\n+\n-value|((volatile struct dw_ictl_registers *)DT_REG_ADDR(DT_NODELABEL(ace_intc)))\n+value|((volatile struct dw_ictl_registers *)DT_INST_REG_ADDR(0))\n-name|DEVICE_DT_DEFINE\n-argument_list|(\n-name|DT_NODELABEL\n+name|DEVICE_DT_INST_DEFINE\n-name|ace_intc\n-argument_list|)\n+literal|0\nThe issue was with: drivers: intc_dw_ace: convert to use instance-based macros\n\nDefine the DRV_COMPAT and use instance-based device DT macros."
},{
  "instruction": "There is an issue in the following code. It relates to arch: common: multilevel_irq: simplification with new multilevel IRQ APIs\n\nUse the multi-level interrupt APIs that accepts `level` as an\nargument for the code where the level of the interrupt is not\nknown at build time. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|NULL\ncondition|)\nblock|{\nname|local_irq\noperator|=\nname|level\noperator|==\nliteral|2\ncondition|?\nname|irq_from_level_2\nargument_list|(\nname|irq\nargument_list|)\nelse|:\nname|irq_from_level_3\nargument_list|(\nname|irq\nargument_list|)\nexpr_stmt|;\nname|__ASSERT_NO_MSG\nargument_list|(\nname|local_irq",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|level\n-operator|==\n-literal|2\n-condition|?\n-name|irq_from_level_2\n-argument_list|(\n-name|irq\n-argument_list|)\n-else|:\n-name|irq_from_level_3\n+name|irq_from_level\n+argument_list|,\n+name|level\nThe issue was with: arch: common: multilevel_irq: simplification with new multilevel IRQ APIs\n\nUse the multi-level interrupt APIs that accepts `level` as an\nargument for the code where the level of the interrupt is not\nknown at build time."
},{
  "instruction": "There is an issue in the following code. It relates to mgmt: hawkbit: option for cold reboot\n\nadd option for cold reboot. Please fix this issue.",
  "input": "Faulty tokenized code:\n\thelp\n\t  Static certificate tag for TLS connection to the hawkBit server.\n\nendif\n\nmodule = HAWKBIT\nmodule-str = Log Level for hawkbit\nmodule-help = Enables logging for hawkBit code.\nsource \"subsys/logging/Kconfig.template.log_config\"\n\nname|hb_context\nstruct|;\nend_struct\n\nbegin_union\nDECL|union|__anon274424f3010a\nspecifier|static\nunion|union\nblock|{\nDECL|member|dep\nname|struct\nname|LOG_PANIC\nargument_list|()\nexpr_stmt|;\nname|sys_reboot\nargument_list|(\nname|SYS_REBOOT_WARM\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+choice HAWKBIT_REBOOT_MODE\n+\tprompt \"Reboot mode after update\"\n+\tdefault HAWKBIT_REBOOT_WARM\n+\n+config HAWKBIT_REBOOT_WARM\n+\tbool \"Warm reboot after update\"\n+\thelp\n+\t  Do a warm reboot after the update.\n+\n+config HAWKBIT_REBOOT_COLD\n+\tbool \"Cold reboot after update\"\n+\thelp\n+\t  Do a cold reboot after the update.\n+\n+endchoice\n+\n-DECL|union|__anon274424f3010a\n+DECL|union|__anon27c22393010a\n+name|IS_ENABLED\n+argument_list|(\n+name|CONFIG_HAWKBIT_REBOOT_COLD\n+argument_list|)\n+condition|?\n+name|SYS_REBOOT_COLD\n+else|:\nThe issue was with: mgmt: hawkbit: option for cold reboot\n\nadd option for cold reboot."
},{
  "instruction": "There is an issue in the following code. It relates to soc: renesas: smartbond: Fix exiting from suspend state\n\nWe need to enable irqs that were disabled when entering suspend state. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ARG_UNUSED\nargument_list|(\nname|substate_id\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|renesas_da1469x_pm_init (void)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|state\n+operator|==\n+name|PM_STATE_STANDBY\n+condition|)\n+block|{\n+name|__enable_irq\n+argument_list|()\n+expr_stmt|;\n+block|}\nThe issue was with: soc: renesas: smartbond: Fix exiting from suspend state\n\nWe need to enable irqs that were disabled when entering suspend state."
},{
  "instruction": "There is an issue in the following code. It relates to intel_adsp/ace: pm: Remove unnecessary cache flush\n\nsoc_cpus_active is not in cached memory. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|core_id\nindex|]\noperator|=\nname|false\nexpr_stmt|;\nname|sys_cache_data_flush_range\nargument_list|(\nname|soc_cpus_active\nargument_list|,\nsizeof|sizeof\nargument_list|(\nname|soc_cpus_active\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|k_cpu_idle\nargument_list|()\nexpr_stmt|;\ncomment|/* It is unlikely we get in here, but when this happens \t * we need to lock interruptions again. \t * \t * @note Zephyr looks PS.INTLEVEL to check if interruptions are locked. \t */\noperator|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|sys_cache_data_flush_range\n-argument_list|(\n-name|soc_cpus_active\n-argument_list|,\n-sizeof|sizeof\n-argument_list|(\n-name|soc_cpus_active\n-argument_list|)\n-argument_list|)\n-expr_stmt|;\nThe issue was with: intel_adsp/ace: pm: Remove unnecessary cache flush\n\nsoc_cpus_active is not in cached memory."
},{
  "instruction": "There is an issue in the following code. It relates to intel_adsp/ace: pm: Keep irq locked until restore context\n\nKeep interruptions locked until we properly restore the core\ncontext. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nblock|}\nend_function\n\nbegin_asm\nasm|__asm__(\".align 4\\n\\t\" \t\".global dsp_restore_vector\\n\\t\" \t\"dsp_restore_vector:\\n\\t\" \t\"  movi  a0, 0\\n\\t\" \t\"  movi  a1, 1\\n\\t\" \t\"  movi  a2, 0x40020\\n\\t\"\ncomment|/* PS_UM|PS_WOE */\nasm|\"  wsr   a2, PS\\n\\t\" \t\"  wsr   a1, WINDOWSTART\\n\\t\" \t\"  wsr   a0, WINDOWBASE\\n\\t\" \t\"  rsync\\n\\t\" \t\"  movi  a1, z_interrupt_stacks\\n\\t\" \t\"  rsr   a2, PRID\\n\\t\" \t\"  movi  a3, \" STRINGIFY(CONFIG_ISR_STACK_SIZE) \"\\n\\t\" \t\"  mull  a2, a2, a3\\n\\t\" \t\"  add   a2, a2, a3\\n\\t\" \t\"  add   a1, a1, a2\\n\\t\" \t\"  call0 power_gate_exit\\n\\t\");\nend_asm\n\nbegin_ifdef\nifdef|#\ndirective|ifdef\nname|power_off_exit\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nasm|__asm__( \t\t\"  movi  a0, 0\\n\\t\" \t\t\"  movi  a1, 1\\n\\t\" \t\t\"  movi  a2, 0x40020\\n\\t\"\ncomment|/* PS_UM|PS_WOE */\nasm|\"  wsr   a2, PS\\n\\t\" \t\t\"  wsr   a1, WINDOWSTART\\n\\t\" \t\t\"  wsr   a0, WINDOWBASE\\n\\t\" \t\t\"  rsync\\n\\t\");\nname|_restore_core_context\nargument_list|()\nexpr_stmt|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-asm|__asm__(\".align 4\\n\\t\" \t\".global dsp_restore_vector\\n\\t\" \t\"dsp_restore_vector:\\n\\t\" \t\"  movi  a0, 0\\n\\t\" \t\"  movi  a1, 1\\n\\t\" \t\"  movi  a2, 0x40020\\n\\t\"\n-comment|/* PS_UM|PS_WOE */\n-asm|\"  wsr   a2, PS\\n\\t\" \t\"  wsr   a1, WINDOWSTART\\n\\t\" \t\"  wsr   a0, WINDOWBASE\\n\\t\" \t\"  rsync\\n\\t\" \t\"  movi  a1, z_interrupt_stacks\\n\\t\" \t\"  rsr   a2, PRID\\n\\t\" \t\"  movi  a3, \" STRINGIFY(CONFIG_ISR_STACK_SIZE) \"\\n\\t\" \t\"  mull  a2, a2, a3\\n\\t\" \t\"  add   a2, a2, a3\\n\\t\" \t\"  add   a1, a1, a2\\n\\t\" \t\"  call0 power_gate_exit\\n\\t\");\n+asm|__asm__(\".align 4\\n\\t\" \t\".global dsp_restore_vector\\n\\t\" \t\"dsp_restore_vector:\\n\\t\" \t\"  movi  a0, 0\\n\\t\" \t\"  movi  a1, 1\\n\\t\" \t\"  movi  a2, \" STRINGIFY(PS_UM | PS_WOE | PS_INTLEVEL(XCHAL_EXCM_LEVEL)) \"\\n\\t\" \t\"  wsr   a2, PS\\n\\t\" \t\"  wsr   a1, WINDOWSTART\\n\\t\" \t\"  wsr   a0, WINDOWBASE\\n\\t\" \t\"  rsync\\n\\t\" \t\"  movi  a1, z_interrupt_stacks\\n\\t\" \t\"  rsr   a2, PRID\\n\\t\" \t\"  movi  a3, \" STRINGIFY(CONFIG_ISR_STACK_SIZE) \"\\n\\t\" \t\"  mull  a2, a2, a3\\n\\t\" \t\"  add   a2, a2, a3\\n\\t\" \t\"  add   a1, a1, a2\\n\\t\" \t\"  call0 power_gate_exit\\n\\t\");\n-asm|__asm__( \t\t\"  movi  a0, 0\\n\\t\" \t\t\"  movi  a1, 1\\n\\t\" \t\t\"  movi  a2, 0x40020\\n\\t\"\n-comment|/* PS_UM|PS_WOE */\n-asm|\"  wsr   a2, PS\\n\\t\" \t\t\"  wsr   a1, WINDOWSTART\\n\\t\" \t\t\"  wsr   a0, WINDOWBASE\\n\\t\" \t\t\"  rsync\\n\\t\");\n+asm|__asm__( \t\t\"  movi  a0, 0\\n\\t\" \t\t\"  movi  a1, 1\\n\\t\" \t\t\"  movi  a2, \" STRINGIFY(PS_UM | PS_WOE | PS_INTLEVEL(XCHAL_EXCM_LEVEL)) \"\\n\\t\" \t\t\"  wsr   a2, PS\\n\\t\" \t\t\"  wsr   a1, WINDOWSTART\\n\\t\" \t\t\"  wsr   a0, WINDOWBASE\\n\\t\" \t\t\"  rsync\\n\\t\");\nThe issue was with: intel_adsp/ace: pm: Keep irq locked until restore context\n\nKeep interruptions locked until we properly restore the core\ncontext."
},{
  "instruction": "There is an issue in the following code. It relates to intel_adsp/ace: pm: Remove unnecessary cache flush\n\ncore_desc is not located (nor is accessed) in cached memory.\nThere is no need to flush it. Please fix this issue.",
  "input": "Faulty tokenized code:\nspecifier|volatile\nasm|(\"mov %0, a0\" : \"=r\"(core_desc[core_id].a0));\nasm|__asm__\nspecifier|volatile\nasm|(\"mov %0, a1\" : \"=r\"(core_desc[core_id].a1));\nname|sys_cache_data_flush_range\nargument_list|(\noperator|&\nname|core_desc\nindex|[\nexpr|struct\nname|core_state\nargument_list|)\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|_restore_core_context (void)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|#\n+directive|if\n+name|CONFIG_MP_MAX_NUM_CPUS\n+operator|==\n+literal|1\n+comment|/* With one core only, the memory is mapped in cache and we need to flush \t * it. \t */\n+endif|#\n+directive|endif\nThe issue was with: intel_adsp/ace: pm: Remove unnecessary cache flush\n\ncore_desc is not located (nor is accessed) in cached memory.\nThere is no need to flush it."
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: wdt_basic_api: Add missing failure indications\n\nTwo API calls that are supposed to set up the watchdog are not actually\ncausing the test to fail, only error messages are printed. This patch\nadds the proper return statements. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|TC_PRINT\nargument_list|(\nliteral|\"Watchdog install error\\n\"\nargument_list|)\nexpr_stmt|;\nblock|}\nname|err\noperator|=\nname|wdt_setup\nargument_list|(\nname|TC_PRINT\nargument_list|(\nliteral|\"Watchdog setup error\\n\"\nargument_list|)\nexpr_stmt|;\nblock|}\nname|TC_PRINT\nargument_list|(\nliteral|\"Waiting to restart MCU\\n\"\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+return|return\n+name|TC_FAIL\n+return|;\n+return|return\n+name|TC_FAIL\n+return|;\nThe issue was with: tests: drivers: wdt_basic_api: Add missing failure indications\n\nTwo API calls that are supposed to set up the watchdog are not actually\ncausing the test to fail, only error messages are printed. This patch\nadds the proper return statements."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Audio: Get function for bt_audio_codec_qos_pref.\n\nGet the preferred QoS settings via bt_bap_ep_get_info()\nTherefore no need to use the internal header file to get it.\n\nThis PR fixes https://github.com/zephyrproject-rtos/zephyr/issues/72359 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|enum\nname|bt_bap_ascs_rsp_code\nname|code\ndecl_stmt|;\ncomment|/** \t * @brief Value of the Reason field. \t * \t * The meaning of this value depend on the Response Code field. \t */\nDECL|union|__anon28bffcdc010a\nunion|union\nblock|{\ncomment|/** \t\t * @brief Response reason \t\t * \t\t * If the Response Code is one of the following: \t\t * - @ref BT_BAP_ASCS_RSP_CODE_CONF_UNSUPPORTED \t\t * - @ref BT_BAP_ASCS_RSP_CODE_CONF_REJECTED \t\t * all values from @ref bt_bap_ascs_reason can be used. \t\t * \t\t * If the Response Code is one of the following: \t\t * - @ref BT_BAP_ASCS_RSP_CODE_SUCCESS \t\t * - @ref BT_BAP_ASCS_RSP_CODE_CAP_UNSUPPORTED \t\t * - @ref BT_BAP_ASCS_RSP_CODE_NO_MEM \t\t * - @ref BT_BAP_ASCS_RSP_CODE_UNSPECIFIED \t\t * only value @ref BT_BAP_ASCS_REASON_NONE shall be used. \t\t */\nDECL|member|reason\nname|enum\nname|struct\nname|bt_bap_ep\nmodifier|*\nname|paired_ep\ndecl_stmt|;\nblock|}\nstruct|;\ncomment|/**  * @brief Return structure holding information of audio stream endpoint  *  * @param ep   The audio stream endpoint object.  * @param info The structure object to be filled with the info.  *  * @retval 0 in case of success  * @retval -EINVAL if @p ep or @p info are NULL  */\nname|int\nname|bt_bap_ep_get_info\noperator|->\nname|dir\noperator|=\nname|dir\nexpr_stmt|;\nif|if\ncondition|(\nname|ep\noperator|->\nname|iso",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon28bffcdc010a\n+DECL|union|__anon29e72baa010a\n+comment|/** Pointer to the preferred QoS settings associated with the endpoint */\n+DECL|member|qos_pref\n+specifier|const\n+name|struct\n+name|bt_audio_codec_qos_pref\n+modifier|*\n+name|qos_pref\n+decl_stmt|;\n+name|info\n+operator|->\n+name|qos_pref\n+operator|=\n+operator|&\n+name|ep\n+operator|->\n+name|qos_pref\n+expr_stmt|;\nThe issue was with: Bluetooth: Audio: Get function for bt_audio_codec_qos_pref.\n\nGet the preferred QoS settings via bt_bap_ep_get_info()\nTherefore no need to use the internal header file to get it.\n\nThis PR fixes https://github.com/zephyrproject-rtos/zephyr/issues/72359"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: timer: smartbond: Fix timer2 timeout set\n\nWhen function sys_clock_set_timout() is called with small value\n(i.e. 1) calculated time to be programmed to TIMER2 reload\nregister may be such that is expires before code set's it\nup. In that case timer interrupt will be scheduled in far\nfuture.\n\nWith this change, code checks after it sets reload value if\nrequested time already passed and if so TIMER2 interrupt\nis marked as pending to avoid races. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|set_reload\nargument_list|(\nname|target_val\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|sys_clock_elapsed (void)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* \t * If time was so small that it already fired or should fire \t * just now, mark interrupt as pending to avoid losing timer event. \t * Condition is true when target_val (point in time that should be \t * used for wakeup) is behind timer value or is equal to it. \t * In that case we don't know if reload value was set in time or \t * not but time expired anyway so make sure that interrupt is pending. \t */\n+if|if\n+condition|(\n+operator|(\n+name|int32_t\n+operator|)\n+operator|(\n+name|target_val\n+operator|-\n+name|timer_val_32_noupdate\n+argument_list|()\n+operator|-\n+literal|1\n+operator|)\n+operator|<\n+literal|0\n+condition|)\n+block|{\n+name|NVIC_SetPendingIRQ\n+argument_list|(\n+name|TIMER2_IRQn\n+argument_list|)\n+expr_stmt|;\n+block|}\nThe issue was with: drivers: timer: smartbond: Fix timer2 timeout set\n\nWhen function sys_clock_set_timout() is called with small value\n(i.e. 1) calculated time to be programmed to TIMER2 reload\nregister may be such that is expires before code set's it\nup. In that case timer interrupt will be scheduled in far\nfuture.\n\nWith this change, code checks after it sets reload value if\nrequested time already passed and if so TIMER2 interrupt\nis marked as pending to avoid races."
},{
  "instruction": "There is an issue in the following code. It relates to samples: ipc: icmsg: Do not return busy error codes\n\nWhen sending a lot of data, a busy error code returned by the IPC is to\nbe expected. But if the last attempted send returns busy, this error\ncode is returned to the calling function, causing an error log message.\nFix this by setting return variable to 0 on this acceptable error. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|-\nname|ENOMEM\ncondition|)\nblock|{\ncomment|/* No space in the buffer. Retry. */\ncontinue|continue;\nblock|}\nif|else if\ncondition|(\nname|ret",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|ret\n+operator|=\n+literal|0\n+expr_stmt|;\nThe issue was with: samples: ipc: icmsg: Do not return busy error codes\n\nWhen sending a lot of data, a busy error code returned by the IPC is to\nbe expected. But if the last attempted send returns busy, this error\ncode is returned to the calling function, causing an error log message.\nFix this by setting return variable to 0 on this acceptable error."
},{
  "instruction": "There is an issue in the following code. It relates to samples: ipc: icmsg: Add received bytes metric\n\nBy adding this metric, any problem with the remote core sending messages\nis observable. Please fix this issue.",
  "input": "Faulty tokenized code:\ninit|=\nname|PACKET_SIZE_START\ndecl_stmt|;\nend_decl_stmt\n\nbegin_function\nDECL|function|ep_bound (void * priv)\nspecifier|static\nname|void\nname|ep_bound\nname|void\nmodifier|*\nname|priv\nparameter_list|)\nblock|{\nname|k_sem_give\nargument_list|(\noperator|&\nname|bound_sem\nargument_list|)\nname|expected_len\nargument_list|,\nname|len\nargument_list|)\nexpr_stmt|;\nname|expected_message\noperator|++\nexpr_stmt|;\nname|expected_len\noperator|++\nliteral|500\nargument_list|)\nexpr_stmt|;\nname|LOG_INF\nargument_list|(\nliteral|\"Stop network core\"\nargument_list|)\nexpr_stmt|;\nname|nrf53_cpunet_enable\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_decl_stmt\n+DECL|variable|received\n+specifier|static\n+name|size_t\n+name|received\n+decl_stmt|;\n+end_decl_stmt\n+\n+name|received\n+operator|=\n+literal|0\n+expr_stmt|;\n+name|received\n+operator|+=\n+name|len\n+expr_stmt|;\n+literal|\"Received %zu [Bytes] in total\"\n+argument_list|,\n+name|received\n+argument_list|)\n+expr_stmt|;\n+name|LOG_INF\n+argument_list|(\nThe issue was with: samples: ipc: icmsg: Add received bytes metric\n\nBy adding this metric, any problem with the remote core sending messages\nis observable."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: spi: stm32: Skip pinctrl suspend/resume for subghzspi\n\nSubghzspi instances cannot have any pinctrl configs. This causes a\nfailure of the power management suspend and resume operations for the\nsubghzspi instance because no \\\"default\\\" pinctrl is found.\n\nFix that by skipping the pinctrl parts on subghzspi instances.\n\nAt the same time fix a copy and paste in the suspend error message.\n\nFixes: 1d9ac4e33d8a [formerly b567a7db83ae] Please fix this issue.",
  "input": "Faulty tokenized code:\ncondition|)\nblock|{\ncase|case\nname|PM_DEVICE_ACTION_RESUME\ncase|:\ncomment|/* Set pins to active state */\nname|err\noperator|=\nname|pinctrl_apply_state\nargument_list|(\nblock|{\nreturn|return\nname|err\nreturn|;\nblock|}\ncomment|/* enable clock */\nname|err\noperator|=\nname|clock_control_on\nargument_list|(\nliteral|0\ncondition|)\nblock|{\nname|LOG_ERR\nargument_list|(\nliteral|\"Could not enable SPI clock\"\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|err\nreturn|;\nblock|}\ncomment|/* Move pins to sleep state */\nname|err\noperator|=\nname|pinctrl_apply_state\nargument_list|(\noperator|-\nname|ENOENT\noperator|)\ncondition|)\nblock|{\ncomment|/* \t\t\t * If returning -ENOENT, no pins where defined for sleep mode : \t\t\t * Do not output on console (might sleep already) when going to sleep, \t\t\t * \"SPI pinctrl sleep state not available\" \t\t\t * and don't block PM suspend. \t\t\t * Else return the error. \t\t\t */\nreturn|return\nname|err\nreturn|;\nblock|}\nbreak|break;\ndefault|default:\nreturn|return\noperator|-\nname|ENOTSUP",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+operator|!\n+name|spi_stm32_is_subghzspi\n+argument_list|(\n+name|dev\n+argument_list|)\n+condition|)\n+block|{\n+block|}\n-literal|\"Could not enable SPI clock\"\n+literal|\"Could not disable SPI clock\"\n+if|if\n+condition|(\n+operator|!\n+name|spi_stm32_is_subghzspi\n+argument_list|(\n+name|dev\n+argument_list|)\n+condition|)\n+block|{\n-comment|/* \t\t\t * If returning -ENOENT, no pins where defined for sleep mode : \t\t\t * Do not output on console (might sleep already) when going to sleep, \t\t\t * \"SPI pinctrl sleep state not available\" \t\t\t * and don't block PM suspend. \t\t\t * Else return the error. \t\t\t */\n+comment|/* \t\t\t\t * If returning -ENOENT, no pins where defined for sleep mode : \t\t\t\t * Do not output on console (might sleep already) when going to \t\t\t\t * sleep, \t\t\t\t * \"SPI pinctrl sleep state not available\" \t\t\t\t * and don't block PM suspend. \t\t\t\t * Else return the error. \t\t\t\t */\n+block|}\nThe issue was with: drivers: spi: stm32: Skip pinctrl suspend/resume for subghzspi\n\nSubghzspi instances cannot have any pinctrl configs. This causes a\nfailure of the power management suspend and resume operations for the\nsubghzspi instance because no \\\"default\\\" pinctrl is found.\n\nFix that by skipping the pinctrl parts on subghzspi instances.\n\nAt the same time fix a copy and paste in the suspend error message.\n\nFixes: 1d9ac4e33d8a [formerly b567a7db83ae]"
},{
  "instruction": "There is an issue in the following code. It relates to sensors: shell: use SENSOR_CHANNEL_3_AXIS whenever possible\n\nInstead of specifying 3 axis channels manually, use\n`SENSOR_CHANNEL_3_AXIS` instead. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/**  * @brief This table stores a mapping of string trigger names along with the sensor_trigger struct  * that gets passed to the driver to enable that trigger, plus a function pointer to a handler. If  * that pointer is NULL, this indicates there is not currently support for that trigger type in the  * sensor shell.  */\nend_comment\n\nbegin_struct\nDECL|struct|__anon2b85fbce0108\nspecifier|static\nspecifier|const\nstruct|struct\nblock|{\nDECL|member|name\nname|decoded_buffer\nindex|[\nliteral|128\nindex|]\ndecl_stmt|;\nDECL|struct|__anon2b85fbce0208\nstruct|struct\nblock|{\nDECL|member|base_timestamp_ns\nname|uint64_t\nname|base_timestamp_ns\ncontinue|continue;\nblock|}\ncomment|/* Skip 3 axis channels */\nif|if\ncondition|(\nname|i\noperator|==\nname|SENSOR_CHAN_ACCEL_XYZ\noperator|||\nname|i\noperator|==\nname|SENSOR_CHAN_GYRO_XYZ\noperator|||\nname|i\noperator|==\nname|SENSOR_CHAN_MAGN_XYZ\ncondition|)\nblock|{\ncontinue|continue;\nblock|}\nname|rc",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2b85fbce0108\n+DECL|struct|__anon289104c00108\n-DECL|struct|__anon2b85fbce0208\n+DECL|struct|__anon289104c00208\n+name|SENSOR_CHANNEL_3_AXIS\n+argument_list|(\n-operator|==\n-name|SENSOR_CHAN_ACCEL_XYZ\n-operator|||\n-name|i\n-operator|==\n-name|SENSOR_CHAN_GYRO_XYZ\n-operator|||\n-name|i\n-operator|==\n-name|SENSOR_CHAN_MAGN_XYZ\n+argument_list|)\nThe issue was with: sensors: shell: use SENSOR_CHANNEL_3_AXIS whenever possible\n\nInstead of specifying 3 axis channels manually, use\n`SENSOR_CHANNEL_3_AXIS` instead."
},{
  "instruction": "There is an issue in the following code. It relates to sensor_shell: fix assertion due to NULL pointer deref\n\nThe `SENSOR_CHAN_VSHUNT` was added in #60717 but was never\nadded to the `sensor_channel_name[SENSOR_CHAN_COMMON_COUNT]`\ntable. Since the length of `sensor_channel_name` is fixed to\n`SENSOR_CHAN_COMMON_COUNT`, this means that the index at\n`SENSOR_CHAN_VSHUNT` points to `NULL`. When we use the\n`sensor get` command for anything bigger than\n`SENSOR_CHAN_VSHUNT`, we will deref that `NULL` pointer\nwhen we do `strcmp` in the for-loop of `parse_named_int`.\n\nFix this by defining `SENSOR_CHAN_VSHUNT` in the table. Please fix this issue.",
  "input": "Faulty tokenized code:\nindex|]\noperator|=\nliteral|\"voltage\"\nblock|,\nindex|[\nname|SENSOR_CHAN_CURRENT\nindex|]\noperator|=\nliteral|\"current\"\nblock|,\nbegin_comment\ncomment|/**  * @brief This table stores a mapping of string trigger names along with the sensor_trigger struct  * that gets passed to the driver to enable that trigger, plus a function pointer to a handler. If  * that pointer is NULL, this indicates there is not currently support for that trigger type in the  * sensor shell.  */\nend_comment\n\nbegin_struct\nDECL|struct|__anon2bee69300108\nspecifier|static\nspecifier|const\nstruct|struct\nblock|{\nDECL|member|name\nname|decoded_buffer\nindex|[\nliteral|128\nindex|]\ndecl_stmt|;\nDECL|struct|__anon2bee69300208\nstruct|struct\nblock|{\nDECL|member|base_timestamp_ns\nname|uint64_t\nname|base_timestamp_ns",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|SENSOR_CHAN_VSHUNT\n+index|]\n+operator|=\n+literal|\"vshunt\"\n+block|,\n+index|[\n-DECL|struct|__anon2bee69300108\n+DECL|struct|__anon27f026180108\n-DECL|struct|__anon2bee69300208\n+DECL|struct|__anon27f026180208\nThe issue was with: sensor_shell: fix assertion due to NULL pointer deref\n\nThe `SENSOR_CHAN_VSHUNT` was added in #60717 but was never\nadded to the `sensor_channel_name[SENSOR_CHAN_COMMON_COUNT]`\ntable. Since the length of `sensor_channel_name` is fixed to\n`SENSOR_CHAN_COMMON_COUNT`, this means that the index at\n`SENSOR_CHAN_VSHUNT` points to `NULL`. When we use the\n`sensor get` command for anything bigger than\n`SENSOR_CHAN_VSHUNT`, we will deref that `NULL` pointer\nwhen we do `strcmp` in the for-loop of `parse_named_int`.\n\nFix this by defining `SENSOR_CHAN_VSHUNT` in the table."
},{
  "instruction": "There is an issue in the following code. It relates to usb: dfu: fix detach happening too fast\n\nIn some relatively rare conditions, the DFU detach/attach happens to\nfast, which cause the host to not notice it. It seems to to be the case\nfor instance on STM32 when no endpoint are being used.\n\nAdding a 1 ms delay (i.e. one SOF period) between the detach and the\nattach fixes the issue. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nblock|}\nname|dfu_enter_idle\nargument_list|()\nexpr_stmt|;\nif|if\ncondition|(\nname|usb_dc_attach\nargument_list|()\ncondition|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Wait 1 SOF period to ensure the host notices the deconnection. */\n+name|k_sleep\n+argument_list|(\n+name|K_MSEC\n+argument_list|(\n+literal|1\n+argument_list|)\n+argument_list|)\n+expr_stmt|;\nThe issue was with: usb: dfu: fix detach happening too fast\n\nIn some relatively rare conditions, the DFU detach/attach happens to\nfast, which cause the host to not notice it. It seems to to be the case\nfor instance on STM32 when no endpoint are being used.\n\nAdding a 1 ms delay (i.e. one SOF period) between the detach and the\nattach fixes the issue."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: timer: nrf_grtc_timer: Fix for random system hangs\n\n7402e5a2658c0 [formerly d599e2b6705eb] removed early return from sys_clock_timeout_handler if\ncurrent counter value is less than cc_val. It seems that this return is\nneeded as after the removal some stress tests which were using system\ntimers heavily started to hang. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nname|uint64_t\nname|dticks\ndecl_stmt|;\nname|dticks\noperator|=\nname|counter_sub\nargument_list|(\nname|cc_val",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|uint64_t\n+name|now\n+init|=\n+name|counter\n+argument_list|()\n+decl_stmt|;\n+if|if\n+condition|(\n+name|unlikely\n+argument_list|(\n+name|now\n+operator|<\n+name|cc_val\n+argument_list|)\n+condition|)\n+block|{\n+return|return;\n+block|}\nThe issue was with: drivers: timer: nrf_grtc_timer: Fix for random system hangs\n\n7402e5a2658c0 [formerly d599e2b6705eb] removed early return from sys_clock_timeout_handler if\ncurrent counter value is less than cc_val. It seems that this return is\nneeded as after the removal some stress tests which were using system\ntimers heavily started to hang."
},{
  "instruction": "There is an issue in the following code. It relates to tests: Bluetooth: Fix incorrect comments about adv sets\n\nSeveral places we simply had\n/* Create a non-connectable non-scannable advertising set */\nregardless of the type of advertising it was.\n\nModified the comment to omit the scannable part\nand corrected the connectable part. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|printk\nargument_list|(\nliteral|\"Bluetooth initialized\\n\"\nargument_list|)\nexpr_stmt|;\ncomment|/* Create a non-connectable non-scannable advertising set */\nname|err\noperator|=\nname|bt_le_ext_adv_create\nargument_list|(\nname|BT_LE_EXT_ADV_NCONN\nblock|, \t}\ndecl_stmt|;\nname|int\nname|err\ndecl_stmt|;\ncomment|/* Create a non-connectable non-scannable advertising set */\nname|err\noperator|=\nname|bt_le_ext_adv_create\nargument_list|(\nname|BT_LE_EXT_ADV_CONN\nname|broadcast_id\ndecl_stmt|;\nname|int\nname|err\ndecl_stmt|;\ncomment|/* Create a non-connectable non-scannable advertising set */\nname|err\noperator|=\nname|bt_le_ext_adv_create\nargument_list|(\noperator|&\noperator|&\nname|stream_ops\nargument_list|)\nexpr_stmt|;\nblock|}\ncomment|/* Create a non-connectable non-scannable advertising set */\nname|err\noperator|=\nname|bt_le_ext_adv_create\nargument_list|(\nname|BT_LE_EXT_ADV_CONN\nparameter_list|)\nblock|{\nname|int\nname|err\ndecl_stmt|;\ncomment|/* Create a non-connectable non-scannable advertising set */\nname|err\noperator|=\nname|bt_le_ext_adv_create\nargument_list|(\nname|BT_LE_EXT_ADV_CUSTOM\nparameter_list|)\nblock|{\nname|int\nname|err\ndecl_stmt|;\ncomment|/* Create a non-connectable non-scannable advertising set */\nname|err\noperator|=\nname|bt_le_ext_adv_create\nargument_list|(\nname|BT_LE_EXT_ADV_CUSTOM\nparameter_list|)\nblock|{\nname|int\nname|err\ndecl_stmt|;\ncomment|/* Create a non-connectable non-scannable advertising set */\nname|err\noperator|=\nname|bt_le_ext_adv_create\nargument_list|(\nname|BT_LE_EXT_ADV_NCONN\nname|LOG_INF\nargument_list|(\nliteral|\"Creating extended advertising set with periodic advertising\"\nargument_list|)\nexpr_stmt|;\ncomment|/* Create a non-connectable non-scannable advertising set */\nname|err\noperator|=\nname|bt_le_ext_adv_create\nargument_list|(\nname|BT_LE_EXT_ADV_NCONN",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* Create a non-connectable non-scannable advertising set */\n+comment|/* Create a non-connectable advertising set */\n-comment|/* Create a non-connectable non-scannable advertising set */\n+comment|/* Create a connectable advertising set */\n-comment|/* Create a non-connectable non-scannable advertising set */\n+comment|/* Create a non-connectable advertising set */\n-comment|/* Create a non-connectable non-scannable advertising set */\n+comment|/* Create a connectable advertising set */\n-comment|/* Create a non-connectable non-scannable advertising set */\n+comment|/* Create a non-connectable advertising set */\n-comment|/* Create a non-connectable non-scannable advertising set */\n+comment|/* Create a non-connectable advertising set */\n-comment|/* Create a non-connectable non-scannable advertising set */\n+comment|/* Create a non-connectable advertising set */\n-comment|/* Create a non-connectable non-scannable advertising set */\n+comment|/* Create a non-connectable advertising set */\nThe issue was with: tests: Bluetooth: Fix incorrect comments about adv sets\n\nSeveral places we simply had\n/* Create a non-connectable non-scannable advertising set */\nregardless of the type of advertising it was.\n\nModified the comment to omit the scannable part\nand corrected the connectable part."
},{
  "instruction": "There is an issue in the following code. It relates to arch: make the max stack frames configurable\n\nCurrent on x86 & risc-v that implement stack trace, the\nmaximum depth of the stack trace is defined by a macro.\n\nIntroduce a new Kconfig:EXCEPTION_STACK_TRACE_MAX_FRAMES\nso that this is configurable in software. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_define\nDECL|macro|MAX_STACK_FRAMES\ndefine|#\ndirective|define\nname|MAX_STACK_FRAMES\nvalue|8\nend_define\n\nbegin_struct\nDECL|struct|stackframe\nstruct|struct\nbegin_define\nDECL|macro|MAX_STACK_FRAMES\ndefine|#\ndirective|define\nname|MAX_STACK_FRAMES\nvalue|8\nend_define\n\nbegin_function\nname|__pinned_func\nDECL|function|unwind_stack (uintptr_t base_ptr,uint16_t cs)\n\thelp\n\t  If the architecture fatal handling code supports it, attempt to\n\t  print a stack trace of function memory addresses when an\n\t  exception is reported.\n\nconfig EXCEPTION_STACK_TRACE_SYMTAB\n\tbool \"Print function names in the stack trace\"\n\tselect SYMTAB\n\tdepends on EXCEPTION_STACK_TRACE\n\thelp",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|8\n+value|CONFIG_EXCEPTION_STACK_TRACE_MAX_FRAMES\n-value|8\n+value|CONFIG_EXCEPTION_STACK_TRACE_MAX_FRAMES\n+config EXCEPTION_STACK_TRACE_MAX_FRAMES\n+\tint \"Configures the depth of stack trace\"\n+\tdefault 8\n+\tdepends on EXCEPTION_STACK_TRACE\n+\thelp\n+\t  In the event of a stack trace, this place a limit on the depths\n+\t  of the stack to examine.\n+\nThe issue was with: arch: make the max stack frames configurable\n\nCurrent on x86 & risc-v that implement stack trace, the\nmaximum depth of the stack trace is defined by a macro.\n\nIntroduce a new Kconfig:EXCEPTION_STACK_TRACE_MAX_FRAMES\nso that this is configurable in software."
},{
  "instruction": "There is an issue in the following code. It relates to soc: intel_adsp: ipc: don't call k_sem_init() multiple times\n\nk_sem_init() is called for every IPC message sent in\nintel_adsp_ipc_send_message(). This has not had any side-effects\nin upstream configurations, but has been linked to a failing\nrun of test_obj_tracking_sanity test case in downstream Zephyr\nuse.\n\nReplace k_sem_init() with k_sem_reset() as this is more appropriate\nAPI to reset the semaphore count, and ensure deterministic\nbehaviour in case a thread is waiting on the semaphore at time\nof reset.\n\nSuggested-by: Peter Mitsis <peter.mitsis@intel.com> Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|return\noperator|-\nname|EBUSY\nreturn|;\nblock|}\nname|k_sem_init\nargument_list|(\noperator|&\nname|devdata\noperator|->\nname|sem\nargument_list|,\nliteral|0\nargument_list|,\nliteral|1\nargument_list|)\nexpr_stmt|;\ncomment|/* Prevent entering runtime idle state until IPC acknowledgment is received. */\nname|pm_policy_state_lock_get\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|k_sem_init\n+name|k_sem_reset\n-argument_list|,\n-literal|0\n-argument_list|,\n-literal|1\nThe issue was with: soc: intel_adsp: ipc: don't call k_sem_init() multiple times\n\nk_sem_init() is called for every IPC message sent in\nintel_adsp_ipc_send_message(). This has not had any side-effects\nin upstream configurations, but has been linked to a failing\nrun of test_obj_tracking_sanity test case in downstream Zephyr\nuse.\n\nReplace k_sem_init() with k_sem_reset() as this is more appropriate\nAPI to reset the semaphore count, and ensure deterministic\nbehaviour in case a thread is waiting on the semaphore at time\nof reset.\n\nSuggested-by: Peter Mitsis <peter.mitsis@intel.com>"
},{
  "instruction": "There is an issue in the following code. It relates to logging: backend: uart: fix coverity warning\n\nThis commit is to fix a warning which is reported in Coverity scan\nafter device runtime pm is enabled. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_PM_DEVICE_RUNTIME\nargument_list|)\nname|pm_device_runtime_get\nargument_list|(\nname|uart_dev\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+name|void\n+operator|)\nThe issue was with: logging: backend: uart: fix coverity warning\n\nThis commit is to fix a warning which is reported in Coverity scan\nafter device runtime pm is enabled."
},{
  "instruction": "There is an issue in the following code. It relates to soc: st: stm32: stm32g0x: enable ART flash cache accelerator\n\nEnable instruction cache and prefetching on STM32G0X SoC family. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<cmsis_core.h>\nend_include\n\nbegin_if\nif|#\ndirective|if\nname|defined\nargument_list|(\nargument_list|(\nname|SYSCFG_CFGR1_UCPD2_STROBE\nargument_list|)\nend_if\n\nbegin_include\ninclude|#\ndirective|include\nfile|<stm32_ll_system.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<stm32_ll_bus.h>\nend_include\nname|stm32g0_init\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\ncomment|/* Update CMSIS SystemCoreClock variable (HCLK) */\ncomment|/* At reset, system core clock is set to 16 MHz from HSI */\nname|SystemCoreClock\noperator|=\nliteral|16000000",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<stm32_ll_system.h>\n+end_include\n+\n-begin_include\n-include|#\n-directive|include\n-file|<stm32_ll_system.h>\n-end_include\n-\n+comment|/* Enable ART Accelerator I-cache and prefetch */\n+name|LL_FLASH_EnableInstCache\n+argument_list|()\n+expr_stmt|;\n+name|LL_FLASH_EnablePrefetch\n+argument_list|()\n+expr_stmt|;\nThe issue was with: soc: st: stm32: stm32g0x: enable ART flash cache accelerator\n\nEnable instruction cache and prefetching on STM32G0X SoC family."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: spi: stm32: add runtime PM support\n\nAdd runtime power management suppor to the STM32 SPI driver. This allows\nthe driver to be suspended when not in use, and as a stop effect removes\nthe need to suspend/resume around each transition to stop mode. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/pm/device.h>\nend_include\n\nbegin_ifdef\nifdef|#\ndirective|ifdef\nname|CONFIG_SPI_STM32_DMA\nend_ifdef\nargument_list|,\nname|PM_ALL_SUBSTATES\nargument_list|)\nexpr_stmt|;\nblock|}\nblock|}\nblock|}\nblock|}\nend_function\n\noperator|->\nname|pm_policy_state_on\noperator|=\nname|false\nexpr_stmt|;\nname|pm_policy_state_lock_put\nargument_list|(\nname|PM_STATE_SUSPEND_TO_IDLE\nargument_list|,\nname|PM_ALL_SUBSTATES\noperator|->\nname|ctx\nargument_list|)\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function\n\nbegin_ifdef",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/pm/device_runtime.h>\n+end_include\n+\n+name|pm_device_runtime_get\n+argument_list|(\n+name|dev\n+argument_list|)\n+expr_stmt|;\n+name|pm_device_runtime_put\n+argument_list|(\n+name|dev\n+argument_list|)\n+expr_stmt|;\n-literal|0\n+name|pm_device_runtime_enable\n+argument_list|(\n+name|dev\n+argument_list|)\nThe issue was with: drivers: spi: stm32: add runtime PM support\n\nAdd runtime power management suppor to the STM32 SPI driver. This allows\nthe driver to be suspended when not in use, and as a stop effect removes\nthe need to suspend/resume around each transition to stop mode."
},{
  "instruction": "There is an issue in the following code. It relates to net: tls_credentials: Add missing base64.h header inclusion\n\nbase64_encode() was used w/o including the base64.h header. This commit\nfixes it. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<psa/crypto.h>\nend_include\n\nbegin_function\nDECL|function|credential_digest_raw (struct tls_credential * credential,void * dest,size_t * len)\nname|int\nname|credential_digest_raw\nparameter_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/sys/base64.h>\n+end_include\n+\nThe issue was with: net: tls_credentials: Add missing base64.h header inclusion\n\nbase64_encode() was used w/o including the base64.h header. This commit\nfixes it."
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: uart: uart_pm fix 'rxbuf' may be used uninitialized\n\nFix for uart_pm/src/main.c:106:23:\nerror: 'rxbuf' may be used uninitialized [-Werror=maybe-uninitialized]\n\nstring.h:62:10: note: by argument 2 of type 'const void *' to 'memcmp'\n   62 | int      memcmp (const void *, const void *, size_t);\n      |          ^~~~~~\ntests/drivers/uart/uart_pm/src/main.c:69:17: note: 'rxbuf' declared here\n   69 |         uint8_t rxbuf[32];\n      |                 ^~~~~ Please fix this issue.",
  "input": "Faulty tokenized code:\nname|uint8_t\nname|rxbuf\nindex|[\nliteral|32\nindex|]\ndecl_stmt|;\nspecifier|volatile\nname|bool\nname|tx_done\ninit|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n+init|=\n+block|{\n+literal|0\n+block|}\nThe issue was with: tests: drivers: uart: uart_pm fix 'rxbuf' may be used uninitialized\n\nFix for uart_pm/src/main.c:106:23:\nerror: 'rxbuf' may be used uninitialized [-Werror=maybe-uninitialized]\n\nstring.h:62:10: note: by argument 2 of type 'const void *' to 'memcmp'\n   62 | int      memcmp (const void *, const void *, size_t);\n      |          ^~~~~~\ntests/drivers/uart/uart_pm/src/main.c:69:17: note: 'rxbuf' declared here\n   69 |         uint8_t rxbuf[32];\n      |                 ^~~~~"
},{
  "instruction": "There is an issue in the following code. It relates to tests: net: net_pkt: Fix typo\n\nThis fixes what seems to be a copy and paste error. Please fix this issue.",
  "input": "Faulty tokenized code:\n\nbegin_block\nblock|{\nname|test_net_pkt_shallow_clone_append_buf\nargument_list|(\nliteral|2\nargument_list|)\nexpr_stmt|;\nblock|}\nend_block\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|2\n+literal|1\nThe issue was with: tests: net: net_pkt: Fix typo\n\nThis fixes what seems to be a copy and paste error."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: Relax loop in z_smp_global_lock()\n\nUpdates z_smp_global_lock() to follow the pattern used in spinlocks\nto relax the loop between atomic_cas() attempts. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nliteral|1\nargument_list|)\ncondition|)\nblock|{\nblock|}\nblock|}\nname|_current\noperator|->\nname|base",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|arch_spin_relax\n+argument_list|()\n+expr_stmt|;\nThe issue was with: kernel: Relax loop in z_smp_global_lock()\n\nUpdates z_smp_global_lock() to follow the pattern used in spinlocks\nto relax the loop between atomic_cas() attempts."
},{
  "instruction": "There is an issue in the following code. It relates to net: lib: dhcpv4: goto INIT on IF down, not RENEWING\n\nWhen the interface goes down, the safest thing to do is to return to\nthe INIT state, as there is no guarantee that any state is preserved\nupon the interface coming back up again.\n\nThis is particularly the case with WiFi. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|.\nname|dhcpv4\noperator|.\nname|state\noperator|=\nname|NET_DHCPV4_RENEWING\nexpr_stmt|;\nname|NET_DBG\nargument_list|(\nliteral|\"enter state=%s\"\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|NET_DHCPV4_RENEWING\n+name|NET_DHCPV4_INIT\nThe issue was with: net: lib: dhcpv4: goto INIT on IF down, not RENEWING\n\nWhen the interface goes down, the safest thing to do is to return to\nthe INIT state, as there is no guarantee that any state is preserved\nupon the interface coming back up again.\n\nThis is particularly the case with WiFi."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: nsos: fix ENOMEM return from ZFD_IOCTL_POLL_PREPARE\n\nioctl() API expects error codes to be returned as negative value directly,\ninstead of using 'errno'. Fix ZFD_IOCTL_POLL_PREPARE handling to respect\nthat. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|pev\noperator|==\nname|pev_end\ncondition|)\nblock|{\nname|errno\noperator|=\nname|ENOMEM\nexpr_stmt|;\nreturn|return\noperator|-\nliteral|1\nreturn|;\nblock|}\nname|k_poll_signal_init\nargument_list|(\noperator|&",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|errno\n-operator|=\n-name|ENOMEM\n-expr_stmt|;\n-literal|1\n+name|ENOMEM\nThe issue was with: drivers: nsos: fix ENOMEM return from ZFD_IOCTL_POLL_PREPARE\n\nioctl() API expects error codes to be returned as negative value directly,\ninstead of using 'errno'. Fix ZFD_IOCTL_POLL_PREPARE handling to respect\nthat."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: nsos: set errno on failed z_reserve_fd()\n\nJust propagate proper error code, which is the negated return value from\nz_reserve_fd(). Please fix this issue.",
  "input": "Faulty tokenized code:\nname|zephyr_fd\noperator|<\nliteral|0\ncondition|)\nblock|{\ngoto|goto\nname|close_adapt_fd\ngoto|;\nblock|}\nname|conn_sock",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|errno\n+operator|=\n+operator|-\n+name|zephyr_fd\n+expr_stmt|;\nThe issue was with: drivers: nsos: set errno on failed z_reserve_fd()\n\nJust propagate proper error code, which is the negated return value from\nz_reserve_fd()."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: nsos: fix nsos_sendmsg() error code\n\nThere is a goto statement with conversion using errno_from_nsos_mid(). Use\nNSOS_MID_ERRNO instead of ERRNO to return proper error code. Please fix this issue.",
  "input": "Faulty tokenized code:\ncondition|)\nblock|{\nname|ret\noperator|=\noperator|-\nname|ENOMEM\nexpr_stmt|;\ngoto|goto\nname|return_ret\ngoto|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|ENOMEM\n+name|NSOS_MID_ENOMEM\nThe issue was with: drivers: nsos: fix nsos_sendmsg() error code\n\nThere is a goto statement with conversion using errno_from_nsos_mid(). Use\nNSOS_MID_ERRNO instead of ERRNO to return proper error code."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: nsos: propagate POLLHUP from host's epoll()\n\nThis flag is set in case socket was closed, so propagate it as well. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|POLLERR\nargument_list|,\nname|EPOLLERR\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|events_to\nreturn|;\nblock|}\nend_function\nname|EPOLLERR\nargument_list|,\nname|POLLERR\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|events_to\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|MAP_POLL_EPOLL\n+argument_list|(\n+name|POLLHUP\n+argument_list|,\n+name|EPOLLHUP\n+argument_list|)\n+expr_stmt|;\n+name|MAP_POLL_EPOLL\n+argument_list|(\n+name|EPOLLHUP\n+argument_list|,\n+name|POLLHUP\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: nsos: propagate POLLHUP from host's epoll()\n\nThis flag is set in case socket was closed, so propagate it as well."
},{
  "instruction": "There is an issue in the following code. It relates to userspace: dynamic: Fix k_thread_stack_free verification\n\nk_thread_stack_free syscall was not checking if the caller\nhad permission to given stack object. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|k_thread_stack_t\nmodifier|*\nname|stack\nparameter_list|)\nblock|{\nreturn|return\nname|z_impl_k_thread_stack_free\nargument_list|(\nname|stack\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* The thread stack object must not be in initialized state. \t * \t * Thread stack objects are initialized when the thread is created \t * and de-initialized whent the thread is destroyed. Since we can't \t * free a stack that is in use, we have to check that the caller \t * has access to the object but that it is not in use anymore. \t */\n+name|K_OOPS\n+argument_list|(\n+name|K_SYSCALL_OBJ_NEVER_INIT\n+argument_list|(\n+name|stack\n+argument_list|,\n+name|K_OBJ_THREAD_STACK_ELEMENT\n+argument_list|)\n+argument_list|)\n+expr_stmt|;\nThe issue was with: userspace: dynamic: Fix k_thread_stack_free verification\n\nk_thread_stack_free syscall was not checking if the caller\nhad permission to given stack object."
},{
  "instruction": "There is an issue in the following code. It relates to logging: log_output: Prevent redundant flush with zero-length data\n\nThere's such a case captured. When log immediate mode is enabled, each log\nmessage is output per character. However, \\\"log_output_flush()\\\" function is\nstill called with zero data length at the end of \\\"log_output_process()\\\".\nBetter to make \\\"buffer_write()\\\" returns immediatley if buffer data\nlength is zero. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|)\nblock|{\nname|int\nname|processed\ndecl_stmt|;\ndo|do\nblock|{\nname|processed\noperator|=\nname|outf\nargument_list|(\nname|buf\noperator|+=\nname|processed\nexpr_stmt|;\nblock|}\ndo|while\ncondition|(\nname|len\noperator|!=\nliteral|0\ncondition|)\ndo|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|log_output_flush (const struct log_output * output)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-do|do\n+while|while\n+condition|(\n+name|len\n+operator|!=\n+literal|0\n+condition|)\n-do|while\n-condition|(\n-name|len\n-operator|!=\n-literal|0\n-condition|)\n-do|;\nThe issue was with: logging: log_output: Prevent redundant flush with zero-length data\n\nThere's such a case captured. When log immediate mode is enabled, each log\nmessage is output per character. However, \\\"log_output_flush()\\\" function is\nstill called with zero data length at the end of \\\"log_output_process()\\\".\nBetter to make \\\"buffer_write()\\\" returns immediatley if buffer data\nlength is zero."
},{
  "instruction": "There is an issue in the following code. It relates to test: dac: esp32s2_devkitc bugfix\n\nadd dts and dac setting for tests/driver/dac/dac_api Please fix this issue.",
  "input": "Faulty tokenized code:\n};\n\n&wdt0 {\n\tstatus = \"okay\";\n};\nargument_list|)\noperator|||\nexpr|\\\nname|defined\nargument_list|(\nname|CONFIG_BOARD_GD32A503V_EVAL\nargument_list|)\noperator|||\nexpr|\\\nname|defined",
  "result": "I corrected the issue in the code by changing the following tokens:\n+\n+&dac {\n+\tstatus = \"okay\";\n+};\n+name|CONFIG_BOARD_ESP32S2_DEVKITC\n+argument_list|)\n+operator|||\n+expr|\\\n+name|defined\n+argument_list|(\nThe issue was with: test: dac: esp32s2_devkitc bugfix\n\nadd dts and dac setting for tests/driver/dac/dac_api"
},{
  "instruction": "There is an issue in the following code. It relates to tests: dac: frdm_mcx947 add dac test support\n\nadd frdm_mcx947 defines in source Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\noperator|||\nexpr|\\\nname|defined\nargument_list|(\nname|CONFIG_BOARD_SEEEDUINO_XIAO\nargument_list|)\noperator|||\nexpr|\\\nname|defined",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|CONFIG_BOARD_FRDM_MCXN947\n+argument_list|)\n+operator|||\n+expr|\\\n+name|defined\n+argument_list|(\nThe issue was with: tests: dac: frdm_mcx947 add dac test support\n\nadd frdm_mcx947 defines in source"
},{
  "instruction": "There is an issue in the following code. It relates to kernel: Predicate _cpus_active on CONFIG_PM\n\nThis value isn't used outside of the PM subsystem, so don't build it.\n\nMore important than the four bytes of .bss was the use of an\natomic_inc().  Some platforms are forced to use\nCONFIG_ATOMIC_OPERATIONS_C (but in almost all cases are single-core\ndevices that won't use atomics at runtime).  There, this turns into a\nfunction call that pulls in the whole atomics implementation. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|z_kernel\nname|_kernel\ndecl_stmt|;\nend_decl_stmt\n\nbegin_decl_stmt\nname|__pinned_bss\nDECL|variable|_cpus_active\nname|atomic_t\nname|_cpus_active\ndecl_stmt|;\nend_decl_stmt\n\nbegin_comment\ncomment|/* init/main and idle threads */\nend_comment\n\nbegin_expr_stmt\noperator|=\nname|CONFIG_SCHED_THREAD_USAGE_AUTO_ENABLE\nexpr_stmt|;\nendif|#\ndirective|endif\ncomment|/* \t * Increment number of CPUs active. The pm subsystem \t * will keep track of this from here. \t */\nname|atomic_inc\nargument_list|(\noperator|&\nname|_cpus_active\nargument_list|)\nexpr_stmt|;\nifdef|#\ndirective|ifdef\nname|CONFIG_OBJ_CORE_SYSTEM\nname|k_obj_core_init_and_link\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_ifdef\n+ifdef|#\n+directive|ifdef\n+name|CONFIG_PM\n+end_ifdef\n+\n-name|__pinned_bss\n+name|__pinned_bss\n+begin_endif\n+endif|#\n+directive|endif\n+end_endif\n+\n+ifdef|#\n+directive|ifdef\n+name|CONFIG_PM\n+endif|#\n+directive|endif\nThe issue was with: kernel: Predicate _cpus_active on CONFIG_PM\n\nThis value isn't used outside of the PM subsystem, so don't build it.\n\nMore important than the four bytes of .bss was the use of an\natomic_inc().  Some platforms are forced to use\nCONFIG_ATOMIC_OPERATIONS_C (but in almost all cases are single-core\ndevices that won't use atomics at runtime).  There, this turns into a\nfunction call that pulls in the whole atomics implementation."
},{
  "instruction": "There is an issue in the following code. It relates to net: gptp: fix rate_ratio in gptp_mi_set_ps_sync_cmss()\n\nSetting a ration of 0 breaks the computation of scaled_rate_offset\nin gptp_md_follow_up_prepare().\n\nAccording to IEEE802.1AS 10.2.2.3.9, when sent by clock master\nentity, rate_ratio shall be equal to gmRateRatio. But since\nin gptp_md_follow_up_prepare(), in case we are the grand master\nclock, we take the assumption that clock source is the local clock,\nwe may set this ratio to 1.0. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|=\nname|current_time\noperator|%\nname|NSEC_PER_SEC\nexpr_stmt|;\ncomment|/* TODO calculate correction field properly, rate_ratio is also set to \t * zero instead of being copied from global_ds as it affects the final \t * value of FUP correction field. \t */\nname|sync_info\noperator|->\nname|follow_up_correction_field\noperator|=\nliteral|0\nexpr_stmt|;\nname|sync_info\noperator|->\nname|rate_ratio\noperator|=\nliteral|0\nexpr_stmt|;\nname|memcpy\nargument_list|(\noperator|&\nname|sync_info",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* TODO calculate correction field properly, rate_ratio is also set to \t * zero instead of being copied from global_ds as it affects the final \t * value of FUP correction field. \t */\n+comment|/* TODO calculate rate ratio and correction field properly. \t * Whenever time aware system is the grand master clock, we currently \t * make the following shortcuts: \t * - assuming that clock source is the local clock, \t *   rate_ratio is set to 1.0 instead of being copied from global_ds. \t * - considering that precise origin timestamp is directly inherited \t *   from sync egress timestamp in gptp_md_follow_up_prepare(), \t *   follow_up_correction_field is set to 0. \t */\n-literal|0\n+literal|1.0\nThe issue was with: net: gptp: fix rate_ratio in gptp_mi_set_ps_sync_cmss()\n\nSetting a ration of 0 breaks the computation of scaled_rate_offset\nin gptp_md_follow_up_prepare().\n\nAccording to IEEE802.1AS 10.2.2.3.9, when sent by clock master\nentity, rate_ratio shall be equal to gmRateRatio. But since\nin gptp_md_follow_up_prepare(), in case we are the grand master\nclock, we take the assumption that clock source is the local clock,\nwe may set this ratio to 1.0."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: nxp: kinetis: temp: fix memset() length\n\nUse the correct buffer size when calling memset().\n\nFixes: #73093 Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|buffer\nargument_list|,\nliteral|0\nargument_list|,\nname|ARRAY_SIZE\nargument_list|(\nname|data\noperator|->\nname|buffer\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|ARRAY_SIZE\n+sizeof|sizeof\nThe issue was with: drivers: sensor: nxp: kinetis: temp: fix memset() length\n\nUse the correct buffer size when calling memset().\n\nFixes: #73093"
},{
  "instruction": "There is an issue in the following code. It relates to drivers/clock_control: Add build assertion for RC32K\n\nAdd build assertion for RC32K to prevent user from\ndisabling RC32K in DT Please fix this issue.",
  "input": "Faulty tokenized code:\ncondition|)\nblock|{\ncase|case\nname|SMARTBOND_CLK_RC32K\ncase|:\nif|if\ncondition|(\noperator|(\noperator|(\nname|CRG_TOP",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|BUILD_ASSERT\n+argument_list|(\n+name|DT_NODE_HAS_STATUS\n+argument_list|(\n+name|DT_NODELABEL\n+argument_list|(\n+name|rc32k\n+argument_list|)\n+argument_list|,\n+name|okay\n+argument_list|)\n+argument_list|,\n+literal|\"RC32K is not allowed to be turned off\"\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers/clock_control: Add build assertion for RC32K\n\nAdd build assertion for RC32K to prevent user from\ndisabling RC32K in DT"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Mesh: Shell: Update DFD start bool parse\n\nChanges the parsing of boolean input parameter \\\"PolicyApply\\\"\nto DFD start command to use shell boolean parse library. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nname|params\noperator|.\nname|apply\noperator|=\nname|strcmp\nargument_list|(\nname|argv\nindex|[\nliteral|4\nindex|]\nargument_list|,\nliteral|\"true\"\nargument_list|)\ncondition|?\nname|false\nelse|:\nname|true\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\nname|params",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|strcmp\n+name|shell_strtobool\n-literal|\"true\"\n+literal|0\n+argument_list|,\n+operator|&\n+name|err\n-condition|?\n-name|false\n-else|:\n-name|true\nThe issue was with: Bluetooth: Mesh: Shell: Update DFD start bool parse\n\nChanges the parsing of boolean input parameter \\\"PolicyApply\\\"\nto DFD start command to use shell boolean parse library."
},{
  "instruction": "There is an issue in the following code. It relates to soc/da1469x: Take PD_SYS control only once during initialization\n\nTake PD_SYS control only once during initialization Please fix this issue.",
  "input": "Faulty tokenized code:\nname|CRG_TOP_PMU_CTRL_REG_COM_SLEEP_Msk\noperator||\nname|CRG_TOP_PMU_CTRL_REG_RADIO_SLEEP_Msk\noperator|)\nexpr_stmt|;\ncomment|/* PDC should take care of PD_SYS */\nname|CRG_TOP\noperator|->\nname|PMU_CTRL_REG\noperator|&=\noperator|~\nname|CRG_TOP_PMU_CTRL_REG_SYS_SLEEP_Msk\nexpr_stmt|;\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_PM\nname|CRG_TOP_BOD_CTRL_REG_BOD_V30_EN_Msk\noperator||\nname|CRG_TOP_BOD_CTRL_REG_BOD_VBAT_EN_Msk\noperator|)\nexpr_stmt|;\nname|da1469x_pdc_reset\nargument_list|()\nexpr_stmt|;\nname|da1469x_otp_init\nargument_list|()\nexpr_stmt|;\nname|da1469x_trimv_init_from_otp\nargument_list|()\nexpr_stmt|;\nname|da1469x_pd_init\nargument_list|()\nexpr_stmt|;\nname|da1469x_pd_acquire\nargument_list|(\nname|MCU_PD_DOMAIN_SYS\nargument_list|)\nexpr_stmt|;\nname|da1469x_pd_acquire\nargument_list|(\nname|MCU_PD_DOMAIN_TIM\nargument_list|)\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* PDC should take care of PD_SYS */\n-name|CRG_TOP\n-operator|->\n-name|PMU_CTRL_REG\n-operator|&=\n-operator|~\n-name|CRG_TOP_PMU_CTRL_REG_SYS_SLEEP_Msk\n-expr_stmt|;\n-name|da1469x_pdc_reset\n-argument_list|()\n-expr_stmt|;\n+comment|/* \t * Take PD_SYS control. \t */\n+name|da1469x_pdc_reset\n+argument_list|()\n+expr_stmt|;\nThe issue was with: soc/da1469x: Take PD_SYS control only once during initialization\n\nTake PD_SYS control only once during initialization"
},{
  "instruction": "There is an issue in the following code. It relates to mgmt: mcumgr: transport: Add missing net include file\n\nAdds a missing network include file which was causing an undefined\nfunction build failure, likely caused by a recent change affecting\nincludes in other header files Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/net/socket.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/mgmt/mcumgr/mgmt/mgmt.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/net/net_if.h>\n+end_include\n+\nThe issue was with: mgmt: mcumgr: transport: Add missing net include file\n\nAdds a missing network include file which was causing an undefined\nfunction build failure, likely caused by a recent change affecting\nincludes in other header files"
},{
  "instruction": "There is an issue in the following code. It relates to arch/xtensa: \\\"NMILEVEL\\\" is an optional feature\n\nSome oddballs cores can be generated without an \\\"NMI\\\" interrupt, in\nwhich case core-isa.h will not define XCHAL_NMILEVEL.  This code is\ntrying to unconditionally mask interrupts, so XCHAL_EXCM_LEVEL is the\npedantically correct choice anyway (NMI's by definition, cannot be\nmasked). Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ignore\noperator|)\noperator|:\nliteral|\"i\"\noperator|(\nname|XCHAL_NMILEVEL\noperator|)\noperator|)\nblock|;\nname|_current_cpu\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|XCHAL_NMILEVEL\n+name|XCHAL_EXCM_LEVEL\nThe issue was with: arch/xtensa: \\\"NMILEVEL\\\" is an optional feature\n\nSome oddballs cores can be generated without an \\\"NMI\\\" interrupt, in\nwhich case core-isa.h will not define XCHAL_NMILEVEL.  This code is\ntrying to unconditionally mask interrupts, so XCHAL_EXCM_LEVEL is the\npedantically correct choice anyway (NMI's by definition, cannot be\nmasked)."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: stm32_temp: use sensor_value_from_float()\n\nThe temperature being computed using a float variable, use\nsensor_value_from_float() instead of sensor_value_from_double(). This\nsaves some flash. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|25\nexpr_stmt|;\nendif|#\ndirective|endif\nreturn|return\nname|sensor_value_from_double\nargument_list|(\nname|val\nargument_list|,\nname|temp\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|sensor_value_from_double\n+name|sensor_value_from_float\nThe issue was with: drivers: sensor: stm32_temp: use sensor_value_from_float()\n\nThe temperature being computed using a float variable, use\nsensor_value_from_float() instead of sensor_value_from_double(). This\nsaves some flash."
},{
  "instruction": "There is an issue in the following code. It relates to coding guidelines: comply with MISRA Rule 11.6\n\nremoved unneeded conversions from integer to pointer Please fix this issue.",
  "input": "Faulty tokenized code:\ndecl_stmt|,\nname|ret2\ndecl_stmt|;\nname|LOG_DBG\nargument_list|(\nliteral|\"%s: %p -> %p (%zu) flags \"\nname|PRI_ENTRY\nliteral|\" mask \"\nname|PRI_ENTRY\nliteral|\" opt 0x%x\"\nargument_list|,\nname|__func__\nargument_list|,\noperator|(\nname|void\noperator|*\noperator|)\nname|phys\nargument_list|,\nname|virt\nargument_list|,\nname|size\nname|ptables\nparameter_list|)\nblock|{\nname|LOG_DBG\nargument_list|(\nliteral|\"update stack for thread %p's ptables at %p: %p (size %zu)\"\nargument_list|,\nname|thread\nargument_list|,\nname|ptables\nargument_list|,\noperator|(\nname|void\noperator|*\noperator|)\nname|thread\noperator|->\nname|stack_info\noperator|.\nname|start\nname|ptables\nargument_list|)\nexpr_stmt|;\nname|LOG_DBG\nargument_list|(\nliteral|\"set thread %p page tables to %p\"\nargument_list|,\nname|thread\nargument_list|,\noperator|(\nname|void\noperator|*\noperator|)\nname|thread\noperator|->\nname|arch\noperator|.\nname|ptables",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"%s: %p -> %p (%zu) flags \"\n+literal|\"%s: 0x%\"\n+name|PRIxPTR\n+literal|\" -> %p (%zu) flags \"\n-operator|(\n-name|void\n-operator|*\n-operator|)\n-literal|\"update stack for thread %p's ptables at %p: %p (size %zu)\"\n+literal|\"update stack for thread %p's ptables at %p: 0x%\"\n+name|PRIxPTR\n+literal|\" (size %zu)\"\n-operator|(\n-name|void\n-operator|*\n-operator|)\n-literal|\"set thread %p page tables to %p\"\n+literal|\"set thread %p page tables to 0x%\"\n+name|PRIxPTR\n-operator|(\n-name|void\n-operator|*\n-operator|)\nThe issue was with: coding guidelines: comply with MISRA Rule 11.6\n\nremoved unneeded conversions from integer to pointer"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: set LIS2DH default trigger mode to \\\"EDGE_BOTH\\\"\n\nPrevious value just activated the ability to trigger for both edges,\nwithout (de)-activating the gpio. This caused an assrtion error in GPIO.h.\n\nFixes #71227 Please fix this issue.",
  "input": "Faulty tokenized code:\nindex|[\nliteral|5\nindex|]\ninit|=\nblock|{\nname|GPIO_INT_EDGE\nblock|,\nname|GPIO_INT_EDGE_RISING\nblock|,\nname|GPIO_INT_EDGE_FALLING\nblock|,\n      Select the interrupt configuration for INT1 gpio.\n\n      The default of 0 is the most common situation to avoid multiple interrupts\n      to be triggered by same event.\n\n     - 0 # LIS2DH_DT_GPIO_INT_EDGE\n      - 1 # LIS2DH_DT_GPIO_INT_EDGE_RISING\n      - 2 # LIS2DH_DT_GPIO_INT_EDGE_FALLING\n      - 3 # LIS2DH_DT_GPIO_INT_LEVEL_HIGH\n      - 4 # LIS2DH_DT_GPIO_INT_LEVEL_LOW\n\n      Select the interrupt configuration for INT2 gpio.\n\n      The default of 0 is the most common situation to avoid multiple interrupts\n      to be triggered by same event.\n\n     - 0 # LIS2DH_DT_GPIO_INT_EDGE\n      - 1 # LIS2DH_DT_GPIO_INT_EDGE_RISING\n      - 2 # LIS2DH_DT_GPIO_INT_EDGE_FALLING\n      - 3 # LIS2DH_DT_GPIO_INT_LEVEL_HIGH\n      - 4 # LIS2DH_DT_GPIO_INT_LEVEL_LOW\n\nbegin_comment\ncomment|/* GPIO interrupt configuration */\nend_comment\n\nbegin_define\nDECL|macro|LIS2DH_DT_GPIO_INT_EDGE\ndefine|#\ndirective|define\nname|LIS2DH_DT_GPIO_INT_EDGE\nvalue|0\nend_define\n\nbegin_define\nDECL|macro|LIS2DH_DT_GPIO_INT_EDGE_RISING",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|GPIO_INT_EDGE\n+name|GPIO_INT_EDGE_BOTH\n-      - 0 # LIS2DH_DT_GPIO_INT_EDGE\n+      - 0 # LIS2DH_DT_GPIO_INT_EDGE_BOTH\n-      - 0 # LIS2DH_DT_GPIO_INT_EDGE\n+      - 0 # LIS2DH_DT_GPIO_INT_EDGE_BOTH\n-DECL|macro|LIS2DH_DT_GPIO_INT_EDGE\n+DECL|macro|LIS2DH_DT_GPIO_INT_EDGE_BOTH\n-name|LIS2DH_DT_GPIO_INT_EDGE\n+name|LIS2DH_DT_GPIO_INT_EDGE_BOTH\nThe issue was with: drivers: set LIS2DH default trigger mode to \\\"EDGE_BOTH\\\"\n\nPrevious value just activated the ability to trigger for both edges,\nwithout (de)-activating the gpio. This caused an assrtion error in GPIO.h.\n\nFixes #71227"
},{
  "instruction": "There is an issue in the following code. It relates to arch: x86: added missing parenthesis\n\n- added missing parenthesis around macro argument expansion Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|IN\nparameter_list|(\nname|reg\nparameter_list|)\nvalue|(sys_read32(mmio + reg * 4)& 0xff)\nend_define\n\nbegin_define\nDECL|macro|OUT (reg,val)\ndefine|#\nparameter_list|(\nname|reg\nparameter_list|,\nname|val\nparameter_list|)\nvalue|sys_write32((val)& 0xff, mmio + reg * 4)\nend_define\n\nbegin_elif\nelif|#\ndirective|elif",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|(sys_read32(mmio + reg * 4)& 0xff)\n+value|(sys_read32(mmio + (reg) * 4)& 0xff)\n-value|sys_write32((val)& 0xff, mmio + reg * 4)\n+value|sys_write32((val)& 0xff, mmio + (reg) * 4)\nThe issue was with: arch: x86: added missing parenthesis\n\n- added missing parenthesis around macro argument expansion"
},{
  "instruction": "There is an issue in the following code. It relates to tests: net: ipv6: Fix packet leak\n\nReceive callback has to unref the packet received, otherwise we leak\npacket. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nname|recv_cb_called\noperator|=\nname|true\nexpr_stmt|;\nname|k_sem_give\nargument_list|(\noperator|&\nname|wait_data\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|net_pkt_unref\n+argument_list|(\n+name|pkt\n+argument_list|)\n+expr_stmt|;\nThe issue was with: tests: net: ipv6: Fix packet leak\n\nReceive callback has to unref the packet received, otherwise we leak\npacket."
},{
  "instruction": "There is an issue in the following code. It relates to logging: Fix network backend compilation\n\nBecause of include file changes, we now need to include both\nhostname.h and net_if.h in the syslog logging module directly. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/logging/log_backend_net.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/net/socket.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/net/hostname.h>\n+end_include\n+\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/net/net_if.h>\n+end_include\n+\nThe issue was with: logging: Fix network backend compilation\n\nBecause of include file changes, we now need to include both\nhostname.h and net_if.h in the syslog logging module directly."
},{
  "instruction": "There is an issue in the following code. It relates to samples: net: Add net_if.h include\n\nBecause of changes in other network header files, the net_if.h\nwas not included so add it directly to the echo-client and\nmqtt_azure sources. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/kernel.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/net/socket.h>\nend_include\ninclude|#\ndirective|include\nfile|<zephyr/net/tls_credentials.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/net/net_mgmt.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/net/net_if.h>\n+end_include\n+\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/net/net_if.h>\n+end_include\n+\nThe issue was with: samples: net: Add net_if.h include\n\nBecause of changes in other network header files, the net_if.h\nwas not included so add it directly to the echo-client and\nmqtt_azure sources."
},{
  "instruction": "There is an issue in the following code. It relates to net: sockets: Add extra debug print for invalid socket access\n\nPrint also thread name when printing socket access error.\nThis helps debugging what thread caused it.\nLowering the Error to Debug as we could be missing vtable\nfor example for eventfd descriptors, this is easily seen when using\nsocket service API. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ctx\noperator|==\nname|NULL\ncondition|)\nblock|{\nname|NET_ERR\nargument_list|(\nliteral|\"invalid access on sock %d by thread %p\"\nargument_list|,\nname|sock\nargument_list|,\nname|_current\nargument_list|)\nexpr_stmt|;\nblock|}\nreturn|return\nname|ctx",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|NET_ERR\n+name|NET_DBG\n-literal|\"invalid access on sock %d by thread %p\"\n+literal|\"Invalid access on sock %d by thread %p (%s)\"\n+argument_list|,\n+name|k_thread_name_get\n+argument_list|(\n+name|_current\n+argument_list|)\nThe issue was with: net: sockets: Add extra debug print for invalid socket access\n\nPrint also thread name when printing socket access error.\nThis helps debugging what thread caused it.\nLowering the Error to Debug as we could be missing vtable\nfor example for eventfd descriptors, this is easily seen when using\nsocket service API."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Host: Guard set state in conn_destroy\n\nIf bt_conn_set_state(conn, BT_CONN_DISCONNECTED) is called\nwhile the connection is already disconnected, this triggers\na warning. This is likely to happen when bt_conn_cleanup_all\nis called as part of bt_disable.\n\nAdded the state check to avoid unnecessary warnings in the log. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|;\nblock|}\nend_function\n\nbegin_enum\nDECL|enum|__anon2af2cd010103\nenum|enum\nblock|{\nDECL|enumerator|FRAG_START\nname|FRAG_START\nblock|,\nargument_list|,\nname|BT_CONN_DISCONNECT_COMPLETE\nargument_list|)\nexpr_stmt|;\nblock|}\nname|bt_conn_set_state\nargument_list|(\nname|conn\nargument_list|,\nname|BT_CONN_DISCONNECTED\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|bt_conn_cleanup_all (void)\nname|void",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon2af2cd010103\n+DECL|enum|__anon2b940ae70103\n+if|if\n+condition|(\n+name|conn\n+operator|->\n+name|state\n+operator|!=\n+name|BT_CONN_DISCONNECTED\n+condition|)\n+block|{\n+block|}\nThe issue was with: Bluetooth: Host: Guard set state in conn_destroy\n\nIf bt_conn_set_state(conn, BT_CONN_DISCONNECTED) is called\nwhile the connection is already disconnected, this triggers\na warning. This is likely to happen when bt_conn_cleanup_all\nis called as part of bt_disable.\n\nAdded the state check to avoid unnecessary warnings in the log."
},{
  "instruction": "There is an issue in the following code. It relates to soc: nxp: rw: remove DT_NODE_HAS_STATUS_OKAY\n\nWe do not have `DT_NODE_HAS_STATUS_OKAY`, change that to\n`DT_NODE_HAS_STATUS(node_id, okay)` instead Please fix this issue.",
  "input": "Faulty tokenized code:\nDECL|macro|WDT_RESET\ndefine|#\ndirective|define\nname|WDT_RESET\ndefine|\\\nvalue|COND_CODE_1(DT_NODE_HAS_STATUS_OKAY(wwdt), (kPOWER_ResetSourceWdt), (0))\nDECL|macro|RESET_CAUSES\ndefine|#\ndirective|define\nname|RESET_CAUSES\ndefine|\\",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|COND_CODE_1(DT_NODE_HAS_STATUS_OKAY(wwdt), (kPOWER_ResetSourceWdt), (0))\n+value|COND_CODE_1(DT_NODE_HAS_STATUS(wwdt, okay), (kPOWER_ResetSourceWdt), (0))\nThe issue was with: soc: nxp: rw: remove DT_NODE_HAS_STATUS_OKAY\n\nWe do not have `DT_NODE_HAS_STATUS_OKAY`, change that to\n`DT_NODE_HAS_STATUS(node_id, okay)` instead"
},{
  "instruction": "There is an issue in the following code. It relates to net: if: Fix potential unaligned word access\n\nThe input address originates from an RX net_buf which may\nbe unaligned. Consequently, word access to this unaligned buffer\ncan trigger an unaligned access exception on certain platforms,\nsuch as the ARMv7 Cortex-A9. Please fix this issue.",
  "input": "Faulty tokenized code:\nendif|#\ndirective|endif\nend_endif\n\nbegin_struct\nDECL|struct|__anon29a5b8440108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|ipv6\nname|struct\nname|CONFIG_NET_NATIVE_IPV4\nargument_list|)\nend_if\n\nbegin_struct\nDECL|struct|__anon29a5b8440208\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|ipv4\nname|struct\ncondition|(\nname|bcast\noperator|.\nname|s_addr\noperator|==\nname|addr\noperator|->\nname|s_addr\ncondition|)\nblock|{\nname|ret\noperator|=\nname|true",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon29a5b8440108\n+DECL|struct|__anon2b2aa98c0108\n-DECL|struct|__anon29a5b8440208\n+DECL|struct|__anon2b2aa98c0208\n+name|UNALIGNED_GET\n+argument_list|(\n+operator|&\n+argument_list|)\nThe issue was with: net: if: Fix potential unaligned word access\n\nThe input address originates from an RX net_buf which may\nbe unaligned. Consequently, word access to this unaligned buffer\ncan trigger an unaligned access exception on certain platforms,\nsuch as the ARMv7 Cortex-A9."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: lpuart: Fix async configure\n\nFix async configure function not being called\nwhen the irq driven api is not used, which\nboth causes a build warning and would not\nwork at runtime. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|api_type\noperator|=\nname|LPUART_ASYNC\nexpr_stmt|;\nreturn|return\nname|mcux_lpuart_configure_async\nargument_list|(\nname|dev\nargument_list|)\nreturn|;\nelse|#\ndirective|else\nreturn|return\nliteral|0\nreturn|;\nendif|#\ndirective|endif\nblock|}\nend_function\n\nbegin_function\nDECL|function|mcux_lpuart_tx (const struct device * dev,const uint8_t * buf,size_t len,int32_t timeout_us)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+endif|#\n+directive|endif\n-else|#\n-directive|else\n-return|return\n-literal|0\n-return|;\n-endif|#\n-directive|endif\nThe issue was with: drivers: lpuart: Fix async configure\n\nFix async configure function not being called\nwhen the irq driven api is not used, which\nboth causes a build warning and would not\nwork at runtime."
},{
  "instruction": "There is an issue in the following code. It relates to mgmt/MCUmgr/img: Fix img_mgmt_get_unused_slot_area_id checks\n\nRemove image == -1 check that can not happen anymore. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|>=\nliteral|2\nend_elif\n\nbegin_function\nDECL|function|img_mgmt_get_unused_slot_area_id (int image)\nspecifier|static\nname|int\nname|img_mgmt_get_unused_slot_area_id\nparameter_list|(\nname|int\nname|image\nparameter_list|)\nblock|{\nname|int\nname|int\nname|slot\ninit|=\nliteral|0\ndecl_stmt|;\nif|if\ncondition|(\nname|image\noperator|==\noperator|-\nliteral|1\ncondition|)\nblock|{\nname|image\noperator|=\nliteral|0\nexpr_stmt|;\nblock|}\nname|slot\noperator|=\nname|img_mgmt_get_opposite_slot\nargument_list|(\nname|img_mgmt_active_slot",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|img_mgmt_get_unused_slot_area_id (int image)\n+DECL|function|img_mgmt_get_unused_slot_area_id (unsigned int image)\n+name|unsigned\n-if|if\n-condition|(\n-name|image\n-operator|==\n-operator|-\n-literal|1\n-condition|)\n-block|{\n-name|image\n-operator|=\n-literal|0\n-expr_stmt|;\n-block|}\nThe issue was with: mgmt/MCUmgr/img: Fix img_mgmt_get_unused_slot_area_id checks\n\nRemove image == -1 check that can not happen anymore."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: display: smartbond: Acquire power rail when using PM\n\nThe power rail of a peripheral block should always be\nacquired/released before/after its employment even if\nit's known that it should already be up and running. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|mipi_dbi_smartbond_suspend\nargument_list|(\nname|dev\nargument_list|)\nexpr_stmt|;\nname|ret\noperator|=\nliteral|0\nexpr_stmt|;\nblock|}\nname|data\noperator|->\nname|is_active\nargument_list|)\nexpr_stmt|;\ncomment|/* \t\t * The resume error code should not be taken into consideration \t\t * by the PM subsystem. \t\t */\nname|ret\noperator|=\nname|mipi_dbi_smartbond_resume\nargument_list|(\nname|dev\nargument_list|)\nexpr_stmt|;\nelse|#\ndirective|else\ncomment|/* Resme if either PM is not used at all or if PM without runtime is used. */\nname|ret\noperator|=\nname|mipi_dbi_smartbond_resume\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* \t\t\t * Once the display block is turned off, its power domain \t\t\t * can be released as well. \t\t\t */\n+name|da1469x_pd_release_nowait\n+argument_list|(\n+name|MCU_PD_DOMAIN_SYS\n+argument_list|)\n+expr_stmt|;\n+comment|/* \t\t * Although PD_SYS should already be turned on, make sure LCD controller's \t\t * power domain is up and running before accessing the display block. \t\t * Acquiring PD_SYS is mandatory when in PM runtime mode. \t\t */\n+name|da1469x_pd_acquire\n+argument_list|(\n+name|MCU_PD_DOMAIN_SYS\n+argument_list|)\n+expr_stmt|;\n+name|da1469x_pd_acquire\n+argument_list|(\n+name|MCU_PD_DOMAIN_SYS\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: display: smartbond: Acquire power rail when using PM\n\nThe power rail of a peripheral block should always be\nacquired/released before/after its employment even if\nit's known that it should already be up and running."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: udc_dwc2: fix interpretation of NUMDEVEPS and INEPS fields\n\nThe NUMDEVEPS field provides the number of endpoints in addition to the\ncontrol endpoint. It is used to iterate over GHWCFG1 register value to\nget correct number of configured IN/OUT endpoints. To get it correctly,\nwe need to use it internally as number including control endpoint.\n\nInterpretation of INEPS misses +1 because value 0 means 1 IN endpoint\nand so on. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|int\nname|dynfifosizing\nrange|:\nliteral|1\ndecl_stmt|;\ncomment|/* Number of endpoints in addition to control endpoint */\nDECL|member|numdeveps\nname|uint8_t\nname|numdeveps\ndecl_stmt|;\ncomment|/* Number of IN endpoints including control endpoint */\nname|i\ninit|=\nname|priv\noperator|->\nname|ineps\ninit|;\nname|i\noperator|>\nliteral|0\ncondition|;\noperator|=\nname|usb_dwc2_get_ghwcfg2_numdeveps\nargument_list|(\nname|ghwcfg2\nargument_list|)\nexpr_stmt|;\nname|priv\noperator|->\nname|ineps\noperator|=\nname|usb_dwc2_get_ghwcfg4_ineps\nargument_list|(\nname|ghwcfg4\nargument_list|)\nexpr_stmt|;\nname|LOG_DBG\nargument_list|(\nliteral|\"Number of endpoints (NUMDEVEPS) %u\"\nargument_list|,\nname|priv\noperator|->\nname|numdeveps\nargument_list|)\nexpr_stmt|;\nname|LOG_DBG\nargument_list|(\nliteral|\"Number of IN endpoints (INEPS) %u\"\nargument_list|,\nname|priv\noperator|->\nname|ineps\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* Number of endpoints in addition to control endpoint */\n+comment|/* Number of endpoints including control endpoint */\n+operator|-\n+literal|1U\n+operator|+\n+literal|1U\n+operator|+\n+literal|1U\n-literal|\"Number of endpoints (NUMDEVEPS) %u\"\n+literal|\"Number of endpoints (NUMDEVEPS + 1) %u\"\n-literal|\"Number of IN endpoints (INEPS) %u\"\n+literal|\"Number of IN endpoints (INEPS + 1) %u\"\nThe issue was with: drivers: udc_dwc2: fix interpretation of NUMDEVEPS and INEPS fields\n\nThe NUMDEVEPS field provides the number of endpoints in addition to the\ncontrol endpoint. It is used to iterate over GHWCFG1 register value to\nget correct number of configured IN/OUT endpoints. To get it correctly,\nwe need to use it internally as number including control endpoint.\n\nInterpretation of INEPS misses +1 because value 0 means 1 IN endpoint\nand so on."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: sensor_shell: fix infinite loop when doing `sensor get`\n\nShould increment `ch.chan_idx` instead of `channel_idx`,\notherwise we will be stucked in the loop forever. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/**  * @brief This table stores a mapping of string trigger names along with the sensor_trigger struct  * that gets passed to the driver to enable that trigger, plus a function pointer to a handler. If  * that pointer is NULL, this indicates there is not currently support for that trigger type in the  * sensor shell.  */\nend_comment\n\nbegin_struct\nDECL|struct|__anon288688850108\nspecifier|static\nspecifier|const\nstruct|struct\nblock|{\nDECL|member|name\nname|decoded_buffer\nindex|[\nliteral|128\nindex|]\ndecl_stmt|;\nDECL|struct|__anon288688850208\nstruct|struct\nblock|{\nDECL|member|base_timestamp_ns\nname|uint64_t\nname|base_timestamp_ns\nname|base_size\ndecl_stmt|;\nname|size_t\nname|frame_size\ndecl_stmt|;\nname|size_t\nname|channel_idx\ninit|=\nliteral|0\ndecl_stmt|;\nname|uint16_t\nname|frame_count\ndecl_stmt|;\ncomment|/* Channels with multi-axis equivalents are skipped */\nswitch|switch\nargument_list|)\nexpr_stmt|;\nblock|}\nblock|}\noperator|++\nname|channel_idx\nexpr_stmt|;\nblock|}\nblock|}\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon288688850108\n+DECL|struct|__anon291510d30108\n-DECL|struct|__anon288688850208\n+DECL|struct|__anon291510d30208\n-name|size_t\n-name|channel_idx\n-init|=\n-literal|0\n-decl_stmt|;\n-name|channel_idx\n+name|ch\n+operator|.\n+name|chan_idx\nThe issue was with: drivers: sensor: sensor_shell: fix infinite loop when doing `sensor get`\n\nShould increment `ch.chan_idx` instead of `channel_idx`,\notherwise we will be stucked in the loop forever."
},{
  "instruction": "There is an issue in the following code. It relates to tests: socket: udp: reduce SO_PRIORITY from 8 to 6 for NSOS compatbility\n\nAccording to 'man 7 socket' about SO_PRIORITY:\n\n  Setting a priority outside the range 0 to 6 requires the CAP_NET_ADMIN\n  capability.\n\nSo use 6 instead of 8, in order to make UDP socket tests pass with native\noffloaded sockets on native_sim platform. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|errno\nargument_list|)\nexpr_stmt|;\nname|optval\noperator|=\nliteral|8\nexpr_stmt|;\nname|rv\noperator|=\nname|zsock_setsockopt\nargument_list|(\nname|io_vector\nindex|[\nliteral|1\nindex|]\ndecl_stmt|;\nDECL|union|__anon289db1fc010a\nunion|union\nblock|{\nDECL|member|hdr\nname|struct\nname|cmsghdr\nname|io_vector\nindex|[\nliteral|1\nindex|]\ndecl_stmt|;\nDECL|union|__anon289db1fc020a\nunion|union\nblock|{\nDECL|member|hdr\nname|struct\nname|cmsghdr\nname|io_vector\nindex|[\nliteral|1\nindex|]\ndecl_stmt|;\nDECL|union|__anon289db1fc030a\nunion|union\nblock|{\nDECL|member|hdr\nname|struct\nname|cmsghdr\nname|io_vector\nindex|[\nliteral|1\nindex|]\ndecl_stmt|;\nDECL|union|__anon289db1fc040a\nunion|union\nblock|{\nDECL|member|hdr\nname|struct\nname|cmsghdr\nname|io_vector\nindex|[\nliteral|1\nindex|]\ndecl_stmt|;\nDECL|union|__anon289db1fc050a\nunion|union\nblock|{\nDECL|member|hdr\nname|struct\nname|cmsghdr\nname|io_vector\nindex|[\nliteral|1\nindex|]\ndecl_stmt|;\nDECL|union|__anon289db1fc060a\nunion|union\nblock|{\nDECL|member|hdr\nname|struct\nname|cmsghdr\nname|cmsg\ndecl_stmt|,\nmodifier|*\nname|prevcmsg\ndecl_stmt|;\nDECL|union|__anon289db1fc070a\nunion|union\nblock|{\nDECL|member|hdr\nname|struct\nname|cmsghdr\nname|io_vector\nindex|[\nliteral|1\nindex|]\ndecl_stmt|;\nDECL|union|__anon289db1fc080a\nunion|union\nblock|{\nDECL|member|hdr\nname|struct\nname|cmsghdr",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|8\n+literal|6\n-DECL|union|__anon289db1fc010a\n+DECL|union|__anon2b0edb03010a\n-DECL|union|__anon289db1fc020a\n+DECL|union|__anon2b0edb03020a\n-DECL|union|__anon289db1fc030a\n+DECL|union|__anon2b0edb03030a\n-DECL|union|__anon289db1fc040a\n+DECL|union|__anon2b0edb03040a\n-DECL|union|__anon289db1fc050a\n+DECL|union|__anon2b0edb03050a\n-DECL|union|__anon289db1fc060a\n+DECL|union|__anon2b0edb03060a\n-DECL|union|__anon289db1fc070a\n+DECL|union|__anon2b0edb03070a\n-DECL|union|__anon289db1fc080a\n+DECL|union|__anon2b0edb03080a\nThe issue was with: tests: socket: udp: reduce SO_PRIORITY from 8 to 6 for NSOS compatbility\n\nAccording to 'man 7 socket' about SO_PRIORITY:\n\n  Setting a priority outside the range 0 to 6 requires the CAP_NET_ADMIN\n  capability.\n\nSo use 6 instead of 8, in order to make UDP socket tests pass with native\noffloaded sockets on native_sim platform."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sdhc: sdhc_spi: release bus on error\n\nProperly release SPI bus on transmit error within the SDHC SPI driver.\nIn these cases return code is not checked, as we wish to return the\nerror code from the failed transfer to the SD stack.\n\nFixes #72364 Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright 2022 NXP  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_define\nDECL|macro|DT_DRV_COMPAT\ndefine|#\nname|ret\noperator|!=\nliteral|0\ncondition|)\nblock|{\nname|spi_cfg\noperator|->\nname|operation\noperator|&=\noperator|~\nif|if\ncondition|(\nname|ret\ncondition|)\nblock|{\nreturn|return\nname|ret\nreturn|;\nblock|}\ncomment|/* Release SPI bus */",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/*  * Copyright 2022 NXP  *  * SPDX-License-Identifier: Apache-2.0  */\n+comment|/*  * Copyright 2022,2024 NXP  *  * SPDX-License-Identifier: Apache-2.0  */\n+name|spi_release\n+argument_list|(\n+name|config\n+operator|->\n+name|spi_dev\n+argument_list|,\n+name|spi_cfg\n+argument_list|)\n+expr_stmt|;\n+comment|/* Release SPI bus */\n+name|spi_release\n+argument_list|(\n+name|config\n+operator|->\n+name|spi_dev\n+argument_list|,\n+name|dev_data\n+operator|->\n+name|spi_cfg\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: sdhc: sdhc_spi: release bus on error\n\nProperly release SPI bus on transmit error within the SDHC SPI driver.\nIn these cases return code is not checked, as we wish to return the\nerror code from the failed transfer to the SD stack.\n\nFixes #72364"
},{
  "instruction": "There is an issue in the following code. It relates to tests: smbus_emul: Remove unnecessary definition\n\npcie_prob() has been deprecated and it is not needed\nin the test. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|,\nname|d\nparameter_list|)\nend_define\n\nbegin_define\nDECL|macro|pcie_probe (bdf,id)\ndefine|#\ndirective|define\nname|pcie_probe\nparameter_list|(\nname|bdf\nparameter_list|,\nname|id\nparameter_list|)\nvalue|1\nend_define\n\nbegin_define\nDECL|macro|pcie_set_cmd (a,b,c)\ndefine|#\ndirective|define\nname|pcie_set_cmd",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_define\n-DECL|macro|pcie_probe (bdf,id)\n-define|#\n-directive|define\n-name|pcie_probe\n-parameter_list|(\n-name|bdf\n-parameter_list|,\n-name|id\n-parameter_list|)\n-value|1\n-end_define\n-\nThe issue was with: tests: smbus_emul: Remove unnecessary definition\n\npcie_prob() has been deprecated and it is not needed\nin the test."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: added missing parenthesis\n\n- added missing parenthesis around macro argument expansion Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|IS_IOAPIC_IRQ\nparameter_list|(\nname|irq\nparameter_list|)\nvalue|(irq< z_loapic_irq_base())\nend_define\n\nbegin_define\nDECL|macro|HARDWARE_IRQ_LIMIT\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|(irq< z_loapic_irq_base())\n+value|((irq)< z_loapic_irq_base())\nThe issue was with: drivers: added missing parenthesis\n\n- added missing parenthesis around macro argument expansion"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: flash: flash_mcux_flexspi_nor: better handle legacy SFDP tables\n\nImplement more robust handling for legacy SFDP tables, which may not\nimplement some of the JEDEC defined DWORDS for SFDP data. Instead of\nfailing to probe/initialize the flash when these DWORDS are not defined\nin the basic flash parameter table, revert to sane defaults for SPI\nflash.\n\nFixes #72051 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|read\noperator|-\nend_expr_stmt\n\nbegin_while\nwhile|while-write hazards. This configuration is not recommended.\" #endif  LOG_MODULE_REGISTER(flash_flexspi_nor, CONFIG_FLASH_LOG_LEVEL);  enum { \tREAD, \tPAGE_PROGRAM, \tREAD_STATUS, \tWRITE_ENABLE, \tERASE_SECTOR, \tERASE_BLOCK, \tREAD_ID, \tREAD_STATUS_REG, \tERASE_CHIP, \tREAD_JESD216, \t/* Entries after this should be for scratch commands */ \tFLEXSPI_INSTR_PROG_END, \t/* Used for temporary commands during initialization */ \tSCRATCH_CMD = FLEXSPI_INSTR_PROG_END, \tSCRATCH_CMD2, \t/* Must be last entry */ \tFLEXSPI_INSTR_END, };  struct flash_flexspi_nor_config { \t/* Note: don't use this controller reference in code. It is \t * only used during init to copy the device structure from ROM \t * into a RAM structure \t */ \tconst struct device *controller; };  /* Device variables used in critical sections should be in this structure */ struct flash_flexspi_nor_data { \tstruct device controller; \tflexspi_device_config_t config; \tflexspi_port_t port; \tbool legacy_poll; \tstruct flash_pages_layout layout; \tstruct flash_parameters flash_parameters; };  /* Initial LUT table */ static const uint32_t flash_flexspi_nor_base_lut[][MEMC_FLEXSPI_CMD_PER_SEQ] = { \t/* 1S-1S-1S flash read command, should be compatible with all SPI nor flashes */ \t[READ] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_READ, \t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 24), \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1, \t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0), \t}, \t[READ_JESD216] = { \t\t/* Install read SFDP command */ \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, JESD216_CMD_READ_SFDP, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 24), \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_DUMMY_SDR, kFLEXSPI_1PAD, 8, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x4), \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0), \t}, \t/* Standard 1S-1S-1S flash write command, can be switched to 1S-1S-4S when QE is set */ \t[PAGE_PROGRAM] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_PP, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 0x18), \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x04, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0), \t},  \t[WRITE_ENABLE] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WREN, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0), \t},  \t[ERASE_SECTOR] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_SE, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 0x18), \t},  \t[ERASE_BLOCK] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_BE, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 0x18), \t},  \t[ERASE_CHIP] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_CE, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0), \t},  \t[READ_ID] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDID, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01), \t},  \t[READ_STATUS_REG] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01), \t}, };  /* Helper so we can read flash ID without flash access for XIP */ static int flash_flexspi_nor_read_id_helper(struct flash_flexspi_nor_data *data, \t\tuint8_t *vendor_id) { \tuint32_t buffer = 0; \tint ret;  \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Read, \t\t.SeqNumber = 1, \t\t.seqIndex = READ_ID, \t\t.data =&buffer, \t\t.dataSize = 3, \t};  \tLOG_DBG(\"Reading id\");  \tret = memc_flexspi_transfer(&data->controller,&transfer); \tif (ret< 0) { \t\treturn ret; \t}  \tmemcpy(vendor_id,&buffer, 3);  \treturn ret; }  static int flash_flexspi_nor_read_id(const struct device *dev, uint8_t *vendor_id) { \tstruct flash_flexspi_nor_data *data = dev->data;  \treturn flash_flexspi_nor_read_id_helper(data, vendor_id); }  static int flash_flexspi_nor_read_status(struct flash_flexspi_nor_data *data, \t\tuint32_t *status) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Read, \t\t.SeqNumber = 1, \t\t.seqIndex = READ_STATUS_REG, \t\t.data = status, \t\t.dataSize = 1, \t};  \tLOG_DBG(\"Reading status register\");  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_write_enable(struct flash_flexspi_nor_data *data) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Command, \t\t.SeqNumber = 1, \t\t.seqIndex = WRITE_ENABLE, \t\t.data = NULL, \t\t.dataSize = 0, \t};  \tLOG_DBG(\"Enabling write\");  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_erase_sector(struct flash_flexspi_nor_data *data, \toff_t offset) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = offset, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Command, \t\t.SeqNumber = 1, \t\t.seqIndex = ERASE_SECTOR, \t\t.data = NULL, \t\t.dataSize = 0, \t};  \tLOG_DBG(\"Erasing sector at 0x%08zx\", (ssize_t) offset);  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_erase_block(struct flash_flexspi_nor_data *data, \t\t\t\t\t  off_t offset) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = offset, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Command, \t\t.SeqNumber = 1, \t\t.seqIndex = ERASE_BLOCK, \t\t.data = NULL, \t\t.dataSize = 0, \t};  \tLOG_DBG(\"Erasing block at 0x%08zx\", (ssize_t) offset);  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_erase_chip(struct flash_flexspi_nor_data *data) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Command, \t\t.SeqNumber = 1, \t\t.seqIndex = ERASE_CHIP, \t\t.data = NULL, \t\t.dataSize = 0, \t};  \tLOG_DBG(\"Erasing chip\");  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_page_program(struct flash_flexspi_nor_data *data, \t\toff_t offset, const void *buffer, size_t len) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = offset, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Write, \t\t.SeqNumber = 1, \t\t.seqIndex = PAGE_PROGRAM, \t\t.data = (uint32_t *) buffer, \t\t.dataSize = len, \t};  \tLOG_DBG(\"Page programming %d bytes to 0x%08zx\", len, (ssize_t) offset);  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_wait_bus_busy(struct flash_flexspi_nor_data *data) { \tuint32_t status = 0; \tint ret;  \twhile (1) { \t\tret = flash_flexspi_nor_read_status(data,&status); \t\tLOG_DBG(\"status: 0x%x\", status); \t\tif (ret) { \t\t\tLOG_ERR(\"Could not read status\"); \t\t\treturn ret; \t\t}  \t\tif (data->legacy_poll) { \t\t\tif ((status& BIT(0)) == 0) { \t\t\t\tbreak; \t\t\t} \t\t} else { \t\t\tif (status& BIT(7)) { \t\t\t\tbreak; \t\t\t} \t\t} \t}  \treturn 0; }  static int flash_flexspi_nor_read(const struct device *dev, off_t offset, \t\tvoid *buffer, size_t len) { \tstruct flash_flexspi_nor_data *data = dev->data; \tuint8_t *src = memc_flexspi_get_ahb_address(&data->controller, \t\t\t\t\t\t    data->port, \t\t\t\t\t\t    offset);  \tmemcpy(buffer, src, len);  \treturn 0; }  static int flash_flexspi_nor_write(const struct device *dev, off_t offset, \t\tconst void *buffer, size_t len) { \tstruct flash_flexspi_nor_data *data = dev->data; \tsize_t size = len; \tuint8_t *src = (uint8_t *) buffer; \tint i; \tunsigned int key = 0;  \tuint8_t *dst = memc_flexspi_get_ahb_address(&data->controller, \t\t\t\t\t\t    data->port, \t\t\t\t\t\t    offset);  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* \t\t * ==== ENTER CRITICAL SECTION ==== \t\t * No flash access should be performed in critical section. All \t\t * code and data accessed must reside in ram. \t\t */ \t\tkey = irq_lock(); \t}  \twhile (len) { \t\t/* If the offset isn't a multiple of the NOR page size, we first need \t\t * to write the remaining part that fits, otherwise the write could \t\t * be wrapped around within the same page \t\t */ \t\ti = MIN(SPI_NOR_PAGE_SIZE - (offset % SPI_NOR_PAGE_SIZE), len); #ifdef CONFIG_FLASH_MCUX_FLEXSPI_NOR_WRITE_BUFFER \t\tmemcpy(nor_write_buf, src, i); #endif \t\tflash_flexspi_nor_write_enable(data); #ifdef CONFIG_FLASH_MCUX_FLEXSPI_NOR_WRITE_BUFFER \t\tflash_flexspi_nor_page_program(data, offset, nor_write_buf, i); #else \t\tflash_flexspi_nor_page_program(data, offset, src, i); #endif \t\tflash_flexspi_nor_wait_bus_busy(data); \t\tmemc_flexspi_reset(&data->controller); \t\tsrc += i; \t\toffset += i; \t\tlen -= i; \t}  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* ==== EXIT CRITICAL SECTION ==== */ \t\tirq_unlock(key); \t}  #ifdef CONFIG_HAS_MCUX_CACHE \tDCACHE_InvalidateByRange((uint32_t) dst, size); #endif  \treturn 0; }  static int flash_flexspi_nor_erase(const struct device *dev, off_t offset, \t\tsize_t size) { \tstruct flash_flexspi_nor_data *data = dev->data; \tconst size_t num_sectors = size / SPI_NOR_SECTOR_SIZE; \tconst size_t num_blocks = size / SPI_NOR_BLOCK_SIZE;  \tint i; \tunsigned int key = 0;  \tuint8_t *dst = memc_flexspi_get_ahb_address(&data->controller, \t\t\t\t\t\t    data->port, \t\t\t\t\t\t    offset);  \tif (offset % SPI_NOR_SECTOR_SIZE) { \t\tLOG_ERR(\"Invalid offset\"); \t\treturn -EINVAL; \t}  \tif (size % SPI_NOR_SECTOR_SIZE) { \t\tLOG_ERR(\"Invalid size\"); \t\treturn -EINVAL; \t}  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* \t\t * ==== ENTER CRITICAL SECTION ==== \t\t * No flash access should be performed in critical section. All \t\t * code and data accessed must reside in ram. \t\t */ \t\tkey = irq_lock(); \t}  \tif ((offset == 0)&& (size == data->config.flashSize * KB(1))) { \t\tflash_flexspi_nor_write_enable(data); \t\tflash_flexspi_nor_erase_chip(data); \t\tflash_flexspi_nor_wait_bus_busy(data); \t\tmemc_flexspi_reset(&data->controller); \t} else if ((0 == (offset % SPI_NOR_BLOCK_SIZE))&& (0 == (size % SPI_NOR_BLOCK_SIZE))) { \t\tfor (i = 0; i< num_blocks; i++) { \t\t\tflash_flexspi_nor_write_enable(data); \t\t\tflash_flexspi_nor_erase_block(data, offset); \t\t\tflash_flexspi_nor_wait_bus_busy(data); \t\t\tmemc_flexspi_reset(&data->controller); \t\t\toffset += SPI_NOR_BLOCK_SIZE; \t\t} \t} else { \t\tfor (i = 0; i< num_sectors; i++) { \t\t\tflash_flexspi_nor_write_enable(data); \t\t\tflash_flexspi_nor_erase_sector(data, offset); \t\t\tflash_flexspi_nor_wait_bus_busy(data); \t\t\tmemc_flexspi_reset(&data->controller); \t\t\toffset += SPI_NOR_SECTOR_SIZE; \t\t} \t}  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* ==== EXIT CRITICAL SECTION ==== */ \t\tirq_unlock(key); \t}  #ifdef CONFIG_HAS_MCUX_CACHE \tDCACHE_InvalidateByRange((uint32_t) dst, size); #endif  \treturn 0; }  static const struct flash_parameters *flash_flexspi_nor_get_parameters( \t\tconst struct device *dev) { \tstruct flash_flexspi_nor_data *data = dev->data;  \treturn&data->flash_parameters; }  #if defined(CONFIG_FLASH_PAGE_LAYOUT) static void flash_flexspi_nor_pages_layout(const struct device *dev, \t\tconst struct flash_pages_layout **layout, size_t *layout_size) { \tstruct flash_flexspi_nor_data *data = dev->data;  \t*layout =&data->layout; \t*layout_size = 1; } #endif /* CONFIG_FLASH_PAGE_LAYOUT */   /*  * This function enables quad mode, when supported. Otherwise it  * returns an error.  * @param dev: Flexspi device  * @param flexspi_lut: flexspi lut table, useful if instruction writes are needed  * @param qer: DW15 quad enable parameter  * @return 0 if quad mode was entered, or -ENOTSUP if quad mode is not supported  */ static int flash_flexspi_nor_quad_enable(struct flash_flexspi_nor_data *data, \t\t\t\t\tuint32_t (*flexspi_lut)[MEMC_FLEXSPI_CMD_PER_SEQ], \t\t\t\t\tuint8_t qer) { \tint ret; \tuint32_t buffer = 0; \tuint16_t bit = 0; \tuint8_t rd_size, wr_size; \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.SeqNumber = 1, \t\t.data =&buffer, \t}; \tflexspi_device_config_t config = { \t\t.flexspiRootClk = MHZ(50), \t\t.flashSize = FLEXSPI_FLSHCR0_FLSHSZ_MASK, /* Max flash size */ \t\t.ARDSeqNumber = 1, \t\t.ARDSeqIndex = READ, \t};  \tswitch (qer) { \tcase JESD216_DW15_QER_VAL_NONE: \t\t/* No init needed */ \t\treturn 0; \tcase JESD216_DW15_QER_VAL_S2B1v1: \tcase JESD216_DW15_QER_VAL_S2B1v4: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WRSR, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 1 of status register 2 */ \t\tbit = BIT(9); \t\trd_size = 2; \t\twr_size = 2; \t\tbreak; \tcase JESD216_DW15_QER_VAL_S1B6: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WRSR, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 6 of status register 1 */ \t\tbit = BIT(6); \t\trd_size = 1; \t\twr_size = 1; \t\tbreak; \tcase JESD216_DW15_QER_VAL_S2B7: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0x3F, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0x3E, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 7 of status register 2 */ \t\tbit = BIT(7); \t\trd_size = 1; \t\twr_size = 1; \t\tbreak; \tcase JESD216_DW15_QER_VAL_S2B1v5: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR2, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WRSR, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 1 of status register 2 */ \t\tbit = BIT(9); \t\trd_size = 1; \t\twr_size = 2; \t\tbreak; \tcase JESD216_DW15_QER_VAL_S2B1v6: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR2, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WRSR2, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 7 of status register 2 */ \t\tbit = BIT(7); \t\trd_size = 1; \t\twr_size = 1; \t\tbreak; \tdefault: \t\treturn -ENOTSUP; \t} \tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\tdata->port); \tif (ret< 0) { \t\treturn ret; \t} \ttransfer.dataSize = rd_size; \ttransfer.seqIndex = SCRATCH_CMD; \ttransfer.cmdType = kFLEXSPI_Read; \t/* Read status register */ \tret = memc_flexspi_transfer(&data->controller,&transfer); \tif (ret< 0) { \t\treturn ret; \t} \tbuffer |= bit; \ttransfer.dataSize = wr_size; \ttransfer.seqIndex = SCRATCH_CMD2; \ttransfer.cmdType = kFLEXSPI_Write; \treturn memc_flexspi_transfer(&data->controller,&transfer); }  /*  * This function enables 4 byte addressing, when supported. Otherwise it  * returns an error.  * @param dev: Flexspi device  * @param flexspi_lut: flexspi lut table, useful if instruction writes are needed  * @param en4b: DW16 enable 4 byte mode parameter  * @return 0 if 4 byte mode was entered, or -ENOTSUP if 4 byte mode was not supported  */ static int flash_flexspi_nor_4byte_enable(struct flash_flexspi_nor_data *data, \t\t\t\t\tuint32_t (*flexspi_lut)[MEMC_FLEXSPI_CMD_PER_SEQ], \t\t\t\t\tuint32_t en4b) { \tint ret; \tuint32_t buffer = 0; \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.SeqNumber = 1, \t\t.data =&buffer, \t}; \tflexspi_device_config_t config = { \t\t.flexspiRootClk = MHZ(50), \t\t.flashSize = FLEXSPI_FLSHCR0_FLSHSZ_MASK, /* Max flash size */ \t\t.ARDSeqNumber = 1, \t\t.ARDSeqIndex = READ, \t}; \tif (en4b& BIT(6)) { \t\t/* Flash is always in 4 byte mode. We just need to configure LUT */ \t\treturn 0; \t} else if (en4b& BIT(5)) { \t\t/* Dedicated vendor instruction set, which we don't support. Exit here */ \t\treturn -ENOTSUP; \t} else if (en4b& BIT(4)) { \t\t/* Set bit 0 of 16 bit configuration register */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xB5, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xB1, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1); \t\tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\ttransfer.dataSize = 2; \t\ttransfer.seqIndex = SCRATCH_CMD; \t\ttransfer.cmdType = kFLEXSPI_Read; \t\t/* Read config register */ \t\tret = memc_flexspi_transfer(&data->controller,&transfer); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\tbuffer |= BIT(0); \t\t/* Set config register */ \t\ttransfer.seqIndex = SCRATCH_CMD2; \t\ttransfer.cmdType = kFLEXSPI_Read; \t\treturn memc_flexspi_transfer(&data->controller,&transfer); \t} else if (en4b& BIT(1)) { \t\t/* Issue write enable, then instruction 0xB7 */ \t\tflash_flexspi_nor_write_enable(data); \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xB7, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\ttransfer.dataSize = 0; \t\ttransfer.seqIndex = SCRATCH_CMD; \t\ttransfer.cmdType = kFLEXSPI_Command; \t\treturn memc_flexspi_transfer(&data->controller,&transfer); \t} else if (en4b& BIT(0)) { \t\t/* Issue instruction 0xB7 */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xB7, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\ttransfer.dataSize = 0; \t\ttransfer.seqIndex = SCRATCH_CMD; \t\ttransfer.cmdType = kFLEXSPI_Command; \t\treturn memc_flexspi_transfer(&data->controller,&transfer); \t} \t/* Other methods not supported */ \treturn -ENOTSUP; }  /*  * This function configures the FlexSPI to manage the flash device  * based on values in SFDP header  * @param data: Flexspi device data  * @param header: SFDP header for flash  * @param bfp: basic flash parameters for flash  * @param flexspi_lut: LUT table, filled with READ LUT command  * @return 0 on success, or negative value on error  */ static int flash_flexspi_nor_config_flash(struct flash_flexspi_nor_data *data, \t\t\tstruct jesd216_sfdp_header *header, \t\t\tstruct jesd216_bfp *bfp, \t\t\tuint32_t (*flexspi_lut)[MEMC_FLEXSPI_CMD_PER_SEQ]) { \tstruct jesd216_instr instr; \tstruct jesd216_bfp_dw16 dw16; \tstruct jesd216_bfp_dw15 dw15; \tstruct jesd216_bfp_dw14 dw14; \tuint8_t addr_width; \tuint8_t mode_cmd; \tint ret;  \taddr_width = jesd216_bfp_addrbytes(bfp) == \t\tJESD216_SFDP_BFP_DW1_ADDRBYTES_VAL_4B ? 32 : 24;  \t/* Check to see if we can enable 4 byte addressing */ \tret = jesd216_bfp_decode_dw16(&header->phdr[0], bfp,&dw16); \tif (ret< 0) { \t\treturn ret; \t}  \t/* Attempt to enable 4 byte addressing */ \tret = flash_flexspi_nor_4byte_enable(data, flexspi_lut, dw16.enter_4ba); \tif (ret == 0) { \t\t/* Use 4 byte address width */ \t\taddr_width = 32; \t\t/* Update LUT for ERASE_SECTOR and ERASE_BLOCK to use 32 bit addr */ \t\tflexspi_lut[ERASE_SECTOR][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_SE, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, addr_width); \t\tflexspi_lut[ERASE_BLOCK][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_BE, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, addr_width); \t} \t/* Extract the read command. \t * Note- enhanced XIP not currently supported, nor is 4-4-4 mode. \t */ \tif (jesd216_bfp_read_support(&header->phdr[0], bfp, \t    JESD216_MODE_144,&instr)> 0) { \t\tLOG_DBG(\"Enable 144 mode\"); \t\t/* Configure for 144 QUAD read mode */ \t\tif (instr.mode_clocks == 2) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE8_SDR; \t\t} else if (instr.mode_clocks == 1) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE4_SDR; \t\t} else if (instr.mode_clocks == 0) { \t\t\t/* Just send dummy cycles during mode clock period */ \t\t\tmode_cmd = kFLEXSPI_Command_DUMMY_SDR; \t\t} else { \t\t\treturn -ENOTSUP; \t\t} \t\tflexspi_lut[READ][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, instr.instr, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_4PAD, addr_width); \t\t/* Note- we always set mode bits to 0x0 */ \t\tflexspi_lut[READ][1] = FLEXSPI_LUT_SEQ( \t\t\t\tmode_cmd, kFLEXSPI_4PAD, 0x00, \t\t\t\tkFLEXSPI_Command_DUMMY_SDR, kFLEXSPI_4PAD, instr.wait_states); \t\tflexspi_lut[READ][2] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_4PAD, 0x04, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\t/* Read 1S-4S-4S enable method */ \t\tret = jesd216_bfp_decode_dw15(&header->phdr[0], bfp,&dw15); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\tret = flash_flexspi_nor_quad_enable(data, flexspi_lut, dw15.qer); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\t/* Now, install 1S-1S-4S page program command */ \t\tflexspi_lut[PAGE_PROGRAM][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_PP_1_1_4, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, addr_width); \t\tflexspi_lut[PAGE_PROGRAM][1] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_4PAD, 0x4, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0);  \t} else if (jesd216_bfp_read_support(&header->phdr[0], bfp, \t    JESD216_MODE_122,&instr)> 0) { \t\tLOG_DBG(\"Enable 122 mode\"); \t\tif (instr.mode_clocks == 4) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE8_SDR; \t\t} else if (instr.mode_clocks == 2) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE4_SDR; \t\t} else if (instr.mode_clocks == 1) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE2_SDR; \t\t} else if (instr.mode_clocks == 0) { \t\t\t/* Just send dummy cycles during mode clock period */ \t\t\tmode_cmd = kFLEXSPI_Command_DUMMY_SDR; \t\t} else { \t\t\treturn -ENOTSUP; \t\t} \t\tflexspi_lut[READ][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, instr.instr, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_2PAD, addr_width); \t\t/* Note- we always set mode bits to 0x0 */ \t\tflexspi_lut[READ][1] = FLEXSPI_LUT_SEQ( \t\t\t\tmode_cmd, kFLEXSPI_2PAD, 0x0, \t\t\t\tkFLEXSPI_Command_DUMMY_SDR, kFLEXSPI_2PAD, instr.wait_states); \t\tflexspi_lut[READ][2] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_2PAD, 0x02, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\t/* Now, install 1S-1S-2S page program command */ \t\tflexspi_lut[PAGE_PROGRAM][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_PP_1_1_2, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, addr_width); \t\tflexspi_lut[PAGE_PROGRAM][1] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_2PAD, 0x4, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t} \t/* Default to 111 mode if no support exists, leave READ/WRITE untouched */  \t/* Now, read DW14 to determine the polling method we should use while programming */ \tret = jesd216_bfp_decode_dw14(&header->phdr[0], bfp,&dw14); \tif (ret< 0) { \t\treturn ret; \t} \tif (dw14.poll_options& BIT(1)) { \t\t/* Read instruction used for polling is 0x70 */ \t\tdata->legacy_poll = false; \t\tflexspi_lut[READ_STATUS_REG][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0x70, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01); \t} else { \t\t/* Read instruction used for polling is 0x05 */ \t\tdata->legacy_poll = true; \t\tflexspi_lut[READ_STATUS_REG][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01); \t}  \treturn 0; }  /* Helper so we can avoid flash access while performing SFDP probe */ static int flash_flexspi_nor_sfdp_read_helper(struct flash_flexspi_nor_data *dev_data, \t\toff_t offset, void *data, size_t len) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = offset, \t\t.port = dev_data->port, \t\t.cmdType = kFLEXSPI_Read, \t\t.seqIndex = READ_JESD216, \t\t.SeqNumber = 1, \t\t.data = (uint32_t *)data, \t\t.dataSize = len, \t};  \t/* Get SFDP data */ \treturn memc_flexspi_transfer(&dev_data->controller,&transfer); }   #if defined(CONFIG_FLASH_JESD216_API)  static int flash_flexspi_nor_sfdp_read(const struct device *dev, \t\toff_t offset, void *data, size_t len) { \tstruct flash_flexspi_nor_data *dev_data = dev->data;  \treturn flash_flexspi_nor_sfdp_read_helper(dev_data, offset, data, len); }  #endif  /* Checks JEDEC ID of flash. If supported, installs custom LUT table */ static int flash_flexspi_nor_check_jedec(struct flash_flexspi_nor_data *data, \t\t\tuint32_t (*flexspi_lut)[MEMC_FLEXSPI_CMD_PER_SEQ]) { \tint ret; \tuint32_t vendor_id;  \tret = flash_flexspi_nor_read_id_helper(data, (uint8_t *)&vendor_id); \tif (ret< 0) { \t\treturn ret; \t}  \t/* Switch on manufacturer and vendor ID */ \tswitch (vendor_id& 0xFFFF) { \tcase 0x25C2: \t\t/* MX25 flash, use 4 byte read/write */ \t\tflexspi_lut[READ][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_4READ_4B, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_4PAD, 32); \t\t/* Flash needs 10 dummy cycles */ \t\tflexspi_lut[READ][1] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_DUMMY_SDR, kFLEXSPI_4PAD, 10, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_4PAD, 0x04); \t\t/* Only 1S-4S-4S page program supported */ \t\tflexspi_lut[PAGE_PROGRAM][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_PP_1_4_4_4B, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_4PAD, 32); \t\tflexspi_lut[PAGE_PROGRAM][1] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_4PAD, 0x4, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\t/* Update ERASE commands for 4 byte mode */ \t\tflexspi_lut[ERASE_SECTOR][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_SE_4B, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 32); \t\tflexspi_lut[ERASE_BLOCK][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xDC, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 32), \t\t/* Read instruction used for polling is 0x05 */ \t\tdata->legacy_poll = true; \t\tflexspi_lut[READ_STATUS_REG][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01); \t\t/* Device uses bit 6 of status reg 1 for QE */ \t\treturn flash_flexspi_nor_quad_enable(data, flexspi_lut, JESD216_DW15_QER_VAL_S1B6); \tdefault: \t\treturn -ENOTSUP; \t} }  /* Probe parameters from flash SFDP header, and use them to configure the FlexSPI */ static int flash_flexspi_nor_probe(struct flash_flexspi_nor_data *data) { \tuint32_t flexspi_lut[FLEXSPI_INSTR_END][MEMC_FLEXSPI_CMD_PER_SEQ] = {0}; \t/* JESD216B defines up to 23 basic flash parameters */ \tuint32_t param_buf[23]; \t/* Space to store SFDP header and first parameter header */ \tuint8_t sfdp_buf[JESD216_SFDP_SIZE(1)] __aligned(4); \tstruct jesd216_bfp *bfp = (struct jesd216_bfp *)param_buf; \tstruct jesd216_sfdp_header *header = (struct jesd216_sfdp_header *)sfdp_buf; \tint ret; \tunsigned int key = 0U;  \tflexspi_device_config_t config = { \t\t.flexspiRootClk = MHZ(50), \t\t.flashSize = FLEXSPI_FLSHCR0_FLSHSZ_MASK, /* Max flash size */ \t\t.ARDSeqNumber = 1, \t\t.ARDSeqIndex = READ, \t};  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* \t\t * ==== ENTER CRITICAL SECTION ==== \t\t * No flash access should be performed in critical section. All \t\t * code and data accessed must reside in ram. \t\t */ \t\tkey = irq_lock(); \t\tmemc_flexspi_wait_bus_idle(&data->controller); \t}  \t/* SFDP spec requires that we downclock the FlexSPI to 50MHz or less */ \tret = memc_flexspi_update_clock(&data->controller,&config, \t\t\t\t\tdata->port, MHZ(50)); \tif (ret< 0) { \t\tgoto _exit; \t}  \t/* Setup initial LUT table and FlexSPI configuration */ \tmemcpy(flexspi_lut, flash_flexspi_nor_base_lut, sizeof(flash_flexspi_nor_base_lut));  \tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \tif (ret< 0) { \t\tgoto _exit; \t}  \t/* First, check if the JEDEC ID of this flash has explicit support \t * in this driver \t */ \tret = flash_flexspi_nor_check_jedec(data, flexspi_lut); \tif (ret == 0) { \t\t/* Flash was supported, SFDP probe not needed */ \t\tgoto _program_lut; \t}  \tret = flash_flexspi_nor_sfdp_read_helper(data, 0, sfdp_buf, sizeof(sfdp_buf)); \tif (ret< 0) { \t\tgoto _exit; \t}  \tLOG_DBG(\"SFDP header magic: 0x%x\", header->magic); \tif (jesd216_sfdp_magic(header) != JESD216_SFDP_MAGIC) { \t\t/* Header was read incorrectly */ \t\tLOG_WRN(\"Invalid header\noperator|,\nname|using\nname|legacy\nname|SPI\nname|mode",
  "result": "I corrected the issue in the code by changing the following tokens:\n-while|while-write hazards. This configuration is not recommended.\" #endif  LOG_MODULE_REGISTER(flash_flexspi_nor, CONFIG_FLASH_LOG_LEVEL);  enum { \tREAD, \tPAGE_PROGRAM, \tREAD_STATUS, \tWRITE_ENABLE, \tERASE_SECTOR, \tERASE_BLOCK, \tREAD_ID, \tREAD_STATUS_REG, \tERASE_CHIP, \tREAD_JESD216, \t/* Entries after this should be for scratch commands */ \tFLEXSPI_INSTR_PROG_END, \t/* Used for temporary commands during initialization */ \tSCRATCH_CMD = FLEXSPI_INSTR_PROG_END, \tSCRATCH_CMD2, \t/* Must be last entry */ \tFLEXSPI_INSTR_END, };  struct flash_flexspi_nor_config { \t/* Note: don't use this controller reference in code. It is \t * only used during init to copy the device structure from ROM \t * into a RAM structure \t */ \tconst struct device *controller; };  /* Device variables used in critical sections should be in this structure */ struct flash_flexspi_nor_data { \tstruct device controller; \tflexspi_device_config_t config; \tflexspi_port_t port; \tbool legacy_poll; \tstruct flash_pages_layout layout; \tstruct flash_parameters flash_parameters; };  /* Initial LUT table */ static const uint32_t flash_flexspi_nor_base_lut[][MEMC_FLEXSPI_CMD_PER_SEQ] = { \t/* 1S-1S-1S flash read command, should be compatible with all SPI nor flashes */ \t[READ] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_READ, \t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 24), \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1, \t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0), \t}, \t[READ_JESD216] = { \t\t/* Install read SFDP command */ \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, JESD216_CMD_READ_SFDP, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 24), \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_DUMMY_SDR, kFLEXSPI_1PAD, 8, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x4), \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0), \t}, \t/* Standard 1S-1S-1S flash write command, can be switched to 1S-1S-4S when QE is set */ \t[PAGE_PROGRAM] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_PP, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 0x18), \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x04, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0), \t},  \t[WRITE_ENABLE] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WREN, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0), \t},  \t[ERASE_SECTOR] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_SE, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 0x18), \t},  \t[ERASE_BLOCK] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_BE, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 0x18), \t},  \t[ERASE_CHIP] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_CE, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0), \t},  \t[READ_ID] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDID, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01), \t},  \t[READ_STATUS_REG] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01), \t}, };  /* Helper so we can read flash ID without flash access for XIP */ static int flash_flexspi_nor_read_id_helper(struct flash_flexspi_nor_data *data, \t\tuint8_t *vendor_id) { \tuint32_t buffer = 0; \tint ret;  \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Read, \t\t.SeqNumber = 1, \t\t.seqIndex = READ_ID, \t\t.data =&buffer, \t\t.dataSize = 3, \t};  \tLOG_DBG(\"Reading id\");  \tret = memc_flexspi_transfer(&data->controller,&transfer); \tif (ret< 0) { \t\treturn ret; \t}  \tmemcpy(vendor_id,&buffer, 3);  \treturn ret; }  static int flash_flexspi_nor_read_id(const struct device *dev, uint8_t *vendor_id) { \tstruct flash_flexspi_nor_data *data = dev->data;  \treturn flash_flexspi_nor_read_id_helper(data, vendor_id); }  static int flash_flexspi_nor_read_status(struct flash_flexspi_nor_data *data, \t\tuint32_t *status) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Read, \t\t.SeqNumber = 1, \t\t.seqIndex = READ_STATUS_REG, \t\t.data = status, \t\t.dataSize = 1, \t};  \tLOG_DBG(\"Reading status register\");  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_write_enable(struct flash_flexspi_nor_data *data) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Command, \t\t.SeqNumber = 1, \t\t.seqIndex = WRITE_ENABLE, \t\t.data = NULL, \t\t.dataSize = 0, \t};  \tLOG_DBG(\"Enabling write\");  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_erase_sector(struct flash_flexspi_nor_data *data, \toff_t offset) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = offset, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Command, \t\t.SeqNumber = 1, \t\t.seqIndex = ERASE_SECTOR, \t\t.data = NULL, \t\t.dataSize = 0, \t};  \tLOG_DBG(\"Erasing sector at 0x%08zx\", (ssize_t) offset);  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_erase_block(struct flash_flexspi_nor_data *data, \t\t\t\t\t  off_t offset) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = offset, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Command, \t\t.SeqNumber = 1, \t\t.seqIndex = ERASE_BLOCK, \t\t.data = NULL, \t\t.dataSize = 0, \t};  \tLOG_DBG(\"Erasing block at 0x%08zx\", (ssize_t) offset);  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_erase_chip(struct flash_flexspi_nor_data *data) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Command, \t\t.SeqNumber = 1, \t\t.seqIndex = ERASE_CHIP, \t\t.data = NULL, \t\t.dataSize = 0, \t};  \tLOG_DBG(\"Erasing chip\");  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_page_program(struct flash_flexspi_nor_data *data, \t\toff_t offset, const void *buffer, size_t len) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = offset, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Write, \t\t.SeqNumber = 1, \t\t.seqIndex = PAGE_PROGRAM, \t\t.data = (uint32_t *) buffer, \t\t.dataSize = len, \t};  \tLOG_DBG(\"Page programming %d bytes to 0x%08zx\", len, (ssize_t) offset);  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_wait_bus_busy(struct flash_flexspi_nor_data *data) { \tuint32_t status = 0; \tint ret;  \twhile (1) { \t\tret = flash_flexspi_nor_read_status(data,&status); \t\tLOG_DBG(\"status: 0x%x\", status); \t\tif (ret) { \t\t\tLOG_ERR(\"Could not read status\"); \t\t\treturn ret; \t\t}  \t\tif (data->legacy_poll) { \t\t\tif ((status& BIT(0)) == 0) { \t\t\t\tbreak; \t\t\t} \t\t} else { \t\t\tif (status& BIT(7)) { \t\t\t\tbreak; \t\t\t} \t\t} \t}  \treturn 0; }  static int flash_flexspi_nor_read(const struct device *dev, off_t offset, \t\tvoid *buffer, size_t len) { \tstruct flash_flexspi_nor_data *data = dev->data; \tuint8_t *src = memc_flexspi_get_ahb_address(&data->controller, \t\t\t\t\t\t    data->port, \t\t\t\t\t\t    offset);  \tmemcpy(buffer, src, len);  \treturn 0; }  static int flash_flexspi_nor_write(const struct device *dev, off_t offset, \t\tconst void *buffer, size_t len) { \tstruct flash_flexspi_nor_data *data = dev->data; \tsize_t size = len; \tuint8_t *src = (uint8_t *) buffer; \tint i; \tunsigned int key = 0;  \tuint8_t *dst = memc_flexspi_get_ahb_address(&data->controller, \t\t\t\t\t\t    data->port, \t\t\t\t\t\t    offset);  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* \t\t * ==== ENTER CRITICAL SECTION ==== \t\t * No flash access should be performed in critical section. All \t\t * code and data accessed must reside in ram. \t\t */ \t\tkey = irq_lock(); \t}  \twhile (len) { \t\t/* If the offset isn't a multiple of the NOR page size, we first need \t\t * to write the remaining part that fits, otherwise the write could \t\t * be wrapped around within the same page \t\t */ \t\ti = MIN(SPI_NOR_PAGE_SIZE - (offset % SPI_NOR_PAGE_SIZE), len); #ifdef CONFIG_FLASH_MCUX_FLEXSPI_NOR_WRITE_BUFFER \t\tmemcpy(nor_write_buf, src, i); #endif \t\tflash_flexspi_nor_write_enable(data); #ifdef CONFIG_FLASH_MCUX_FLEXSPI_NOR_WRITE_BUFFER \t\tflash_flexspi_nor_page_program(data, offset, nor_write_buf, i); #else \t\tflash_flexspi_nor_page_program(data, offset, src, i); #endif \t\tflash_flexspi_nor_wait_bus_busy(data); \t\tmemc_flexspi_reset(&data->controller); \t\tsrc += i; \t\toffset += i; \t\tlen -= i; \t}  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* ==== EXIT CRITICAL SECTION ==== */ \t\tirq_unlock(key); \t}  #ifdef CONFIG_HAS_MCUX_CACHE \tDCACHE_InvalidateByRange((uint32_t) dst, size); #endif  \treturn 0; }  static int flash_flexspi_nor_erase(const struct device *dev, off_t offset, \t\tsize_t size) { \tstruct flash_flexspi_nor_data *data = dev->data; \tconst size_t num_sectors = size / SPI_NOR_SECTOR_SIZE; \tconst size_t num_blocks = size / SPI_NOR_BLOCK_SIZE;  \tint i; \tunsigned int key = 0;  \tuint8_t *dst = memc_flexspi_get_ahb_address(&data->controller, \t\t\t\t\t\t    data->port, \t\t\t\t\t\t    offset);  \tif (offset % SPI_NOR_SECTOR_SIZE) { \t\tLOG_ERR(\"Invalid offset\"); \t\treturn -EINVAL; \t}  \tif (size % SPI_NOR_SECTOR_SIZE) { \t\tLOG_ERR(\"Invalid size\"); \t\treturn -EINVAL; \t}  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* \t\t * ==== ENTER CRITICAL SECTION ==== \t\t * No flash access should be performed in critical section. All \t\t * code and data accessed must reside in ram. \t\t */ \t\tkey = irq_lock(); \t}  \tif ((offset == 0)&& (size == data->config.flashSize * KB(1))) { \t\tflash_flexspi_nor_write_enable(data); \t\tflash_flexspi_nor_erase_chip(data); \t\tflash_flexspi_nor_wait_bus_busy(data); \t\tmemc_flexspi_reset(&data->controller); \t} else if ((0 == (offset % SPI_NOR_BLOCK_SIZE))&& (0 == (size % SPI_NOR_BLOCK_SIZE))) { \t\tfor (i = 0; i< num_blocks; i++) { \t\t\tflash_flexspi_nor_write_enable(data); \t\t\tflash_flexspi_nor_erase_block(data, offset); \t\t\tflash_flexspi_nor_wait_bus_busy(data); \t\t\tmemc_flexspi_reset(&data->controller); \t\t\toffset += SPI_NOR_BLOCK_SIZE; \t\t} \t} else { \t\tfor (i = 0; i< num_sectors; i++) { \t\t\tflash_flexspi_nor_write_enable(data); \t\t\tflash_flexspi_nor_erase_sector(data, offset); \t\t\tflash_flexspi_nor_wait_bus_busy(data); \t\t\tmemc_flexspi_reset(&data->controller); \t\t\toffset += SPI_NOR_SECTOR_SIZE; \t\t} \t}  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* ==== EXIT CRITICAL SECTION ==== */ \t\tirq_unlock(key); \t}  #ifdef CONFIG_HAS_MCUX_CACHE \tDCACHE_InvalidateByRange((uint32_t) dst, size); #endif  \treturn 0; }  static const struct flash_parameters *flash_flexspi_nor_get_parameters( \t\tconst struct device *dev) { \tstruct flash_flexspi_nor_data *data = dev->data;  \treturn&data->flash_parameters; }  #if defined(CONFIG_FLASH_PAGE_LAYOUT) static void flash_flexspi_nor_pages_layout(const struct device *dev, \t\tconst struct flash_pages_layout **layout, size_t *layout_size) { \tstruct flash_flexspi_nor_data *data = dev->data;  \t*layout =&data->layout; \t*layout_size = 1; } #endif /* CONFIG_FLASH_PAGE_LAYOUT */   /*  * This function enables quad mode, when supported. Otherwise it  * returns an error.  * @param dev: Flexspi device  * @param flexspi_lut: flexspi lut table, useful if instruction writes are needed  * @param qer: DW15 quad enable parameter  * @return 0 if quad mode was entered, or -ENOTSUP if quad mode is not supported  */ static int flash_flexspi_nor_quad_enable(struct flash_flexspi_nor_data *data, \t\t\t\t\tuint32_t (*flexspi_lut)[MEMC_FLEXSPI_CMD_PER_SEQ], \t\t\t\t\tuint8_t qer) { \tint ret; \tuint32_t buffer = 0; \tuint16_t bit = 0; \tuint8_t rd_size, wr_size; \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.SeqNumber = 1, \t\t.data =&buffer, \t}; \tflexspi_device_config_t config = { \t\t.flexspiRootClk = MHZ(50), \t\t.flashSize = FLEXSPI_FLSHCR0_FLSHSZ_MASK, /* Max flash size */ \t\t.ARDSeqNumber = 1, \t\t.ARDSeqIndex = READ, \t};  \tswitch (qer) { \tcase JESD216_DW15_QER_VAL_NONE: \t\t/* No init needed */ \t\treturn 0; \tcase JESD216_DW15_QER_VAL_S2B1v1: \tcase JESD216_DW15_QER_VAL_S2B1v4: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WRSR, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 1 of status register 2 */ \t\tbit = BIT(9); \t\trd_size = 2; \t\twr_size = 2; \t\tbreak; \tcase JESD216_DW15_QER_VAL_S1B6: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WRSR, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 6 of status register 1 */ \t\tbit = BIT(6); \t\trd_size = 1; \t\twr_size = 1; \t\tbreak; \tcase JESD216_DW15_QER_VAL_S2B7: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0x3F, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0x3E, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 7 of status register 2 */ \t\tbit = BIT(7); \t\trd_size = 1; \t\twr_size = 1; \t\tbreak; \tcase JESD216_DW15_QER_VAL_S2B1v5: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR2, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WRSR, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 1 of status register 2 */ \t\tbit = BIT(9); \t\trd_size = 1; \t\twr_size = 2; \t\tbreak; \tcase JESD216_DW15_QER_VAL_S2B1v6: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR2, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WRSR2, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 7 of status register 2 */ \t\tbit = BIT(7); \t\trd_size = 1; \t\twr_size = 1; \t\tbreak; \tdefault: \t\treturn -ENOTSUP; \t} \tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\tdata->port); \tif (ret< 0) { \t\treturn ret; \t} \ttransfer.dataSize = rd_size; \ttransfer.seqIndex = SCRATCH_CMD; \ttransfer.cmdType = kFLEXSPI_Read; \t/* Read status register */ \tret = memc_flexspi_transfer(&data->controller,&transfer); \tif (ret< 0) { \t\treturn ret; \t} \tbuffer |= bit; \ttransfer.dataSize = wr_size; \ttransfer.seqIndex = SCRATCH_CMD2; \ttransfer.cmdType = kFLEXSPI_Write; \treturn memc_flexspi_transfer(&data->controller,&transfer); }  /*  * This function enables 4 byte addressing, when supported. Otherwise it  * returns an error.  * @param dev: Flexspi device  * @param flexspi_lut: flexspi lut table, useful if instruction writes are needed  * @param en4b: DW16 enable 4 byte mode parameter  * @return 0 if 4 byte mode was entered, or -ENOTSUP if 4 byte mode was not supported  */ static int flash_flexspi_nor_4byte_enable(struct flash_flexspi_nor_data *data, \t\t\t\t\tuint32_t (*flexspi_lut)[MEMC_FLEXSPI_CMD_PER_SEQ], \t\t\t\t\tuint32_t en4b) { \tint ret; \tuint32_t buffer = 0; \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.SeqNumber = 1, \t\t.data =&buffer, \t}; \tflexspi_device_config_t config = { \t\t.flexspiRootClk = MHZ(50), \t\t.flashSize = FLEXSPI_FLSHCR0_FLSHSZ_MASK, /* Max flash size */ \t\t.ARDSeqNumber = 1, \t\t.ARDSeqIndex = READ, \t}; \tif (en4b& BIT(6)) { \t\t/* Flash is always in 4 byte mode. We just need to configure LUT */ \t\treturn 0; \t} else if (en4b& BIT(5)) { \t\t/* Dedicated vendor instruction set, which we don't support. Exit here */ \t\treturn -ENOTSUP; \t} else if (en4b& BIT(4)) { \t\t/* Set bit 0 of 16 bit configuration register */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xB5, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xB1, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1); \t\tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\ttransfer.dataSize = 2; \t\ttransfer.seqIndex = SCRATCH_CMD; \t\ttransfer.cmdType = kFLEXSPI_Read; \t\t/* Read config register */ \t\tret = memc_flexspi_transfer(&data->controller,&transfer); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\tbuffer |= BIT(0); \t\t/* Set config register */ \t\ttransfer.seqIndex = SCRATCH_CMD2; \t\ttransfer.cmdType = kFLEXSPI_Read; \t\treturn memc_flexspi_transfer(&data->controller,&transfer); \t} else if (en4b& BIT(1)) { \t\t/* Issue write enable, then instruction 0xB7 */ \t\tflash_flexspi_nor_write_enable(data); \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xB7, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\ttransfer.dataSize = 0; \t\ttransfer.seqIndex = SCRATCH_CMD; \t\ttransfer.cmdType = kFLEXSPI_Command; \t\treturn memc_flexspi_transfer(&data->controller,&transfer); \t} else if (en4b& BIT(0)) { \t\t/* Issue instruction 0xB7 */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xB7, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\ttransfer.dataSize = 0; \t\ttransfer.seqIndex = SCRATCH_CMD; \t\ttransfer.cmdType = kFLEXSPI_Command; \t\treturn memc_flexspi_transfer(&data->controller,&transfer); \t} \t/* Other methods not supported */ \treturn -ENOTSUP; }  /*  * This function configures the FlexSPI to manage the flash device  * based on values in SFDP header  * @param data: Flexspi device data  * @param header: SFDP header for flash  * @param bfp: basic flash parameters for flash  * @param flexspi_lut: LUT table, filled with READ LUT command  * @return 0 on success, or negative value on error  */ static int flash_flexspi_nor_config_flash(struct flash_flexspi_nor_data *data, \t\t\tstruct jesd216_sfdp_header *header, \t\t\tstruct jesd216_bfp *bfp, \t\t\tuint32_t (*flexspi_lut)[MEMC_FLEXSPI_CMD_PER_SEQ]) { \tstruct jesd216_instr instr; \tstruct jesd216_bfp_dw16 dw16; \tstruct jesd216_bfp_dw15 dw15; \tstruct jesd216_bfp_dw14 dw14; \tuint8_t addr_width; \tuint8_t mode_cmd; \tint ret;  \taddr_width = jesd216_bfp_addrbytes(bfp) == \t\tJESD216_SFDP_BFP_DW1_ADDRBYTES_VAL_4B ? 32 : 24;  \t/* Check to see if we can enable 4 byte addressing */ \tret = jesd216_bfp_decode_dw16(&header->phdr[0], bfp,&dw16); \tif (ret< 0) { \t\treturn ret; \t}  \t/* Attempt to enable 4 byte addressing */ \tret = flash_flexspi_nor_4byte_enable(data, flexspi_lut, dw16.enter_4ba); \tif (ret == 0) { \t\t/* Use 4 byte address width */ \t\taddr_width = 32; \t\t/* Update LUT for ERASE_SECTOR and ERASE_BLOCK to use 32 bit addr */ \t\tflexspi_lut[ERASE_SECTOR][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_SE, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, addr_width); \t\tflexspi_lut[ERASE_BLOCK][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_BE, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, addr_width); \t} \t/* Extract the read command. \t * Note- enhanced XIP not currently supported, nor is 4-4-4 mode. \t */ \tif (jesd216_bfp_read_support(&header->phdr[0], bfp, \t    JESD216_MODE_144,&instr)> 0) { \t\tLOG_DBG(\"Enable 144 mode\"); \t\t/* Configure for 144 QUAD read mode */ \t\tif (instr.mode_clocks == 2) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE8_SDR; \t\t} else if (instr.mode_clocks == 1) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE4_SDR; \t\t} else if (instr.mode_clocks == 0) { \t\t\t/* Just send dummy cycles during mode clock period */ \t\t\tmode_cmd = kFLEXSPI_Command_DUMMY_SDR; \t\t} else { \t\t\treturn -ENOTSUP; \t\t} \t\tflexspi_lut[READ][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, instr.instr, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_4PAD, addr_width); \t\t/* Note- we always set mode bits to 0x0 */ \t\tflexspi_lut[READ][1] = FLEXSPI_LUT_SEQ( \t\t\t\tmode_cmd, kFLEXSPI_4PAD, 0x00, \t\t\t\tkFLEXSPI_Command_DUMMY_SDR, kFLEXSPI_4PAD, instr.wait_states); \t\tflexspi_lut[READ][2] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_4PAD, 0x04, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\t/* Read 1S-4S-4S enable method */ \t\tret = jesd216_bfp_decode_dw15(&header->phdr[0], bfp,&dw15); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\tret = flash_flexspi_nor_quad_enable(data, flexspi_lut, dw15.qer); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\t/* Now, install 1S-1S-4S page program command */ \t\tflexspi_lut[PAGE_PROGRAM][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_PP_1_1_4, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, addr_width); \t\tflexspi_lut[PAGE_PROGRAM][1] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_4PAD, 0x4, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0);  \t} else if (jesd216_bfp_read_support(&header->phdr[0], bfp, \t    JESD216_MODE_122,&instr)> 0) { \t\tLOG_DBG(\"Enable 122 mode\"); \t\tif (instr.mode_clocks == 4) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE8_SDR; \t\t} else if (instr.mode_clocks == 2) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE4_SDR; \t\t} else if (instr.mode_clocks == 1) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE2_SDR; \t\t} else if (instr.mode_clocks == 0) { \t\t\t/* Just send dummy cycles during mode clock period */ \t\t\tmode_cmd = kFLEXSPI_Command_DUMMY_SDR; \t\t} else { \t\t\treturn -ENOTSUP; \t\t} \t\tflexspi_lut[READ][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, instr.instr, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_2PAD, addr_width); \t\t/* Note- we always set mode bits to 0x0 */ \t\tflexspi_lut[READ][1] = FLEXSPI_LUT_SEQ( \t\t\t\tmode_cmd, kFLEXSPI_2PAD, 0x0, \t\t\t\tkFLEXSPI_Command_DUMMY_SDR, kFLEXSPI_2PAD, instr.wait_states); \t\tflexspi_lut[READ][2] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_2PAD, 0x02, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\t/* Now, install 1S-1S-2S page program command */ \t\tflexspi_lut[PAGE_PROGRAM][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_PP_1_1_2, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, addr_width); \t\tflexspi_lut[PAGE_PROGRAM][1] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_2PAD, 0x4, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t} \t/* Default to 111 mode if no support exists, leave READ/WRITE untouched */  \t/* Now, read DW14 to determine the polling method we should use while programming */ \tret = jesd216_bfp_decode_dw14(&header->phdr[0], bfp,&dw14); \tif (ret< 0) { \t\treturn ret; \t} \tif (dw14.poll_options& BIT(1)) { \t\t/* Read instruction used for polling is 0x70 */ \t\tdata->legacy_poll = false; \t\tflexspi_lut[READ_STATUS_REG][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0x70, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01); \t} else { \t\t/* Read instruction used for polling is 0x05 */ \t\tdata->legacy_poll = true; \t\tflexspi_lut[READ_STATUS_REG][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01); \t}  \treturn 0; }  /* Helper so we can avoid flash access while performing SFDP probe */ static int flash_flexspi_nor_sfdp_read_helper(struct flash_flexspi_nor_data *dev_data, \t\toff_t offset, void *data, size_t len) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = offset, \t\t.port = dev_data->port, \t\t.cmdType = kFLEXSPI_Read, \t\t.seqIndex = READ_JESD216, \t\t.SeqNumber = 1, \t\t.data = (uint32_t *)data, \t\t.dataSize = len, \t};  \t/* Get SFDP data */ \treturn memc_flexspi_transfer(&dev_data->controller,&transfer); }   #if defined(CONFIG_FLASH_JESD216_API)  static int flash_flexspi_nor_sfdp_read(const struct device *dev, \t\toff_t offset, void *data, size_t len) { \tstruct flash_flexspi_nor_data *dev_data = dev->data;  \treturn flash_flexspi_nor_sfdp_read_helper(dev_data, offset, data, len); }  #endif  /* Checks JEDEC ID of flash. If supported, installs custom LUT table */ static int flash_flexspi_nor_check_jedec(struct flash_flexspi_nor_data *data, \t\t\tuint32_t (*flexspi_lut)[MEMC_FLEXSPI_CMD_PER_SEQ]) { \tint ret; \tuint32_t vendor_id;  \tret = flash_flexspi_nor_read_id_helper(data, (uint8_t *)&vendor_id); \tif (ret< 0) { \t\treturn ret; \t}  \t/* Switch on manufacturer and vendor ID */ \tswitch (vendor_id& 0xFFFF) { \tcase 0x25C2: \t\t/* MX25 flash, use 4 byte read/write */ \t\tflexspi_lut[READ][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_4READ_4B, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_4PAD, 32); \t\t/* Flash needs 10 dummy cycles */ \t\tflexspi_lut[READ][1] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_DUMMY_SDR, kFLEXSPI_4PAD, 10, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_4PAD, 0x04); \t\t/* Only 1S-4S-4S page program supported */ \t\tflexspi_lut[PAGE_PROGRAM][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_PP_1_4_4_4B, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_4PAD, 32); \t\tflexspi_lut[PAGE_PROGRAM][1] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_4PAD, 0x4, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\t/* Update ERASE commands for 4 byte mode */ \t\tflexspi_lut[ERASE_SECTOR][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_SE_4B, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 32); \t\tflexspi_lut[ERASE_BLOCK][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xDC, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 32), \t\t/* Read instruction used for polling is 0x05 */ \t\tdata->legacy_poll = true; \t\tflexspi_lut[READ_STATUS_REG][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01); \t\t/* Device uses bit 6 of status reg 1 for QE */ \t\treturn flash_flexspi_nor_quad_enable(data, flexspi_lut, JESD216_DW15_QER_VAL_S1B6); \tdefault: \t\treturn -ENOTSUP; \t} }  /* Probe parameters from flash SFDP header, and use them to configure the FlexSPI */ static int flash_flexspi_nor_probe(struct flash_flexspi_nor_data *data) { \tuint32_t flexspi_lut[FLEXSPI_INSTR_END][MEMC_FLEXSPI_CMD_PER_SEQ] = {0}; \t/* JESD216B defines up to 23 basic flash parameters */ \tuint32_t param_buf[23]; \t/* Space to store SFDP header and first parameter header */ \tuint8_t sfdp_buf[JESD216_SFDP_SIZE(1)] __aligned(4); \tstruct jesd216_bfp *bfp = (struct jesd216_bfp *)param_buf; \tstruct jesd216_sfdp_header *header = (struct jesd216_sfdp_header *)sfdp_buf; \tint ret; \tunsigned int key = 0U;  \tflexspi_device_config_t config = { \t\t.flexspiRootClk = MHZ(50), \t\t.flashSize = FLEXSPI_FLSHCR0_FLSHSZ_MASK, /* Max flash size */ \t\t.ARDSeqNumber = 1, \t\t.ARDSeqIndex = READ, \t};  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* \t\t * ==== ENTER CRITICAL SECTION ==== \t\t * No flash access should be performed in critical section. All \t\t * code and data accessed must reside in ram. \t\t */ \t\tkey = irq_lock(); \t\tmemc_flexspi_wait_bus_idle(&data->controller); \t}  \t/* SFDP spec requires that we downclock the FlexSPI to 50MHz or less */ \tret = memc_flexspi_update_clock(&data->controller,&config, \t\t\t\t\tdata->port, MHZ(50)); \tif (ret< 0) { \t\tgoto _exit; \t}  \t/* Setup initial LUT table and FlexSPI configuration */ \tmemcpy(flexspi_lut, flash_flexspi_nor_base_lut, sizeof(flash_flexspi_nor_base_lut));  \tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \tif (ret< 0) { \t\tgoto _exit; \t}  \t/* First, check if the JEDEC ID of this flash has explicit support \t * in this driver \t */ \tret = flash_flexspi_nor_check_jedec(data, flexspi_lut); \tif (ret == 0) { \t\t/* Flash was supported, SFDP probe not needed */ \t\tgoto _program_lut; \t}  \tret = flash_flexspi_nor_sfdp_read_helper(data, 0, sfdp_buf, sizeof(sfdp_buf)); \tif (ret< 0) { \t\tgoto _exit; \t}  \tLOG_DBG(\"SFDP header magic: 0x%x\", header->magic); \tif (jesd216_sfdp_magic(header) != JESD216_SFDP_MAGIC) { \t\t/* Header was read incorrectly */ \t\tLOG_WRN(\"Invalid header\n+while|while-write hazards. This configuration is not recommended.\" #endif  LOG_MODULE_REGISTER(flash_flexspi_nor, CONFIG_FLASH_LOG_LEVEL);  enum { \tREAD, \tPAGE_PROGRAM, \tREAD_STATUS, \tWRITE_ENABLE, \tERASE_SECTOR, \tERASE_BLOCK, \tREAD_ID, \tREAD_STATUS_REG, \tERASE_CHIP, \tREAD_JESD216, \t/* Entries after this should be for scratch commands */ \tFLEXSPI_INSTR_PROG_END, \t/* Used for temporary commands during initialization */ \tSCRATCH_CMD = FLEXSPI_INSTR_PROG_END, \tSCRATCH_CMD2, \t/* Must be last entry */ \tFLEXSPI_INSTR_END, };  struct flash_flexspi_nor_config { \t/* Note: don't use this controller reference in code. It is \t * only used during init to copy the device structure from ROM \t * into a RAM structure \t */ \tconst struct device *controller; };  /* Device variables used in critical sections should be in this structure */ struct flash_flexspi_nor_data { \tstruct device controller; \tflexspi_device_config_t config; \tflexspi_port_t port; \tbool legacy_poll; \tstruct flash_pages_layout layout; \tstruct flash_parameters flash_parameters; };  /* Initial LUT table */ static const uint32_t flash_flexspi_nor_base_lut[][MEMC_FLEXSPI_CMD_PER_SEQ] = { \t/* 1S-1S-1S flash read command, should be compatible with all SPI nor flashes */ \t[READ] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_READ, \t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 24), \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1, \t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0), \t}, \t[READ_JESD216] = { \t\t/* Install read SFDP command */ \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, JESD216_CMD_READ_SFDP, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 24), \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_DUMMY_SDR, kFLEXSPI_1PAD, 8, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x4), \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0), \t}, \t/* Standard 1S-1S-1S flash write command, can be switched to 1S-1S-4S when QE is set */ \t[PAGE_PROGRAM] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_PP, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 0x18), \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x04, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0), \t},  \t[WRITE_ENABLE] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WREN, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0), \t},  \t[ERASE_SECTOR] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_SE, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 0x18), \t},  \t[ERASE_BLOCK] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_BE, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 0x18), \t},  \t[ERASE_CHIP] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_CE, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0), \t},  \t[READ_ID] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDID, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01), \t},  \t[READ_STATUS_REG] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01), \t}, };  /* Helper so we can read flash ID without flash access for XIP */ static int flash_flexspi_nor_read_id_helper(struct flash_flexspi_nor_data *data, \t\tuint8_t *vendor_id) { \tuint32_t buffer = 0; \tint ret;  \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Read, \t\t.SeqNumber = 1, \t\t.seqIndex = READ_ID, \t\t.data =&buffer, \t\t.dataSize = 3, \t};  \tLOG_DBG(\"Reading id\");  \tret = memc_flexspi_transfer(&data->controller,&transfer); \tif (ret< 0) { \t\treturn ret; \t}  \tmemcpy(vendor_id,&buffer, 3);  \treturn ret; }  static int flash_flexspi_nor_read_id(const struct device *dev, uint8_t *vendor_id) { \tstruct flash_flexspi_nor_data *data = dev->data;  \treturn flash_flexspi_nor_read_id_helper(data, vendor_id); }  static int flash_flexspi_nor_read_status(struct flash_flexspi_nor_data *data, \t\tuint32_t *status) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Read, \t\t.SeqNumber = 1, \t\t.seqIndex = READ_STATUS_REG, \t\t.data = status, \t\t.dataSize = 1, \t};  \tLOG_DBG(\"Reading status register\");  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_write_enable(struct flash_flexspi_nor_data *data) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Command, \t\t.SeqNumber = 1, \t\t.seqIndex = WRITE_ENABLE, \t\t.data = NULL, \t\t.dataSize = 0, \t};  \tLOG_DBG(\"Enabling write\");  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_erase_sector(struct flash_flexspi_nor_data *data, \toff_t offset) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = offset, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Command, \t\t.SeqNumber = 1, \t\t.seqIndex = ERASE_SECTOR, \t\t.data = NULL, \t\t.dataSize = 0, \t};  \tLOG_DBG(\"Erasing sector at 0x%08zx\", (ssize_t) offset);  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_erase_block(struct flash_flexspi_nor_data *data, \t\t\t\t\t  off_t offset) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = offset, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Command, \t\t.SeqNumber = 1, \t\t.seqIndex = ERASE_BLOCK, \t\t.data = NULL, \t\t.dataSize = 0, \t};  \tLOG_DBG(\"Erasing block at 0x%08zx\", (ssize_t) offset);  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_erase_chip(struct flash_flexspi_nor_data *data) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Command, \t\t.SeqNumber = 1, \t\t.seqIndex = ERASE_CHIP, \t\t.data = NULL, \t\t.dataSize = 0, \t};  \tLOG_DBG(\"Erasing chip\");  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_page_program(struct flash_flexspi_nor_data *data, \t\toff_t offset, const void *buffer, size_t len) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = offset, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Write, \t\t.SeqNumber = 1, \t\t.seqIndex = PAGE_PROGRAM, \t\t.data = (uint32_t *) buffer, \t\t.dataSize = len, \t};  \tLOG_DBG(\"Page programming %d bytes to 0x%08zx\", len, (ssize_t) offset);  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_wait_bus_busy(struct flash_flexspi_nor_data *data) { \tuint32_t status = 0; \tint ret;  \twhile (1) { \t\tret = flash_flexspi_nor_read_status(data,&status); \t\tLOG_DBG(\"status: 0x%x\", status); \t\tif (ret) { \t\t\tLOG_ERR(\"Could not read status\"); \t\t\treturn ret; \t\t}  \t\tif (data->legacy_poll) { \t\t\tif ((status& BIT(0)) == 0) { \t\t\t\tbreak; \t\t\t} \t\t} else { \t\t\tif (status& BIT(7)) { \t\t\t\tbreak; \t\t\t} \t\t} \t}  \treturn 0; }  static int flash_flexspi_nor_read(const struct device *dev, off_t offset, \t\tvoid *buffer, size_t len) { \tstruct flash_flexspi_nor_data *data = dev->data; \tuint8_t *src = memc_flexspi_get_ahb_address(&data->controller, \t\t\t\t\t\t    data->port, \t\t\t\t\t\t    offset);  \tmemcpy(buffer, src, len);  \treturn 0; }  static int flash_flexspi_nor_write(const struct device *dev, off_t offset, \t\tconst void *buffer, size_t len) { \tstruct flash_flexspi_nor_data *data = dev->data; \tsize_t size = len; \tuint8_t *src = (uint8_t *) buffer; \tint i; \tunsigned int key = 0;  \tuint8_t *dst = memc_flexspi_get_ahb_address(&data->controller, \t\t\t\t\t\t    data->port, \t\t\t\t\t\t    offset);  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* \t\t * ==== ENTER CRITICAL SECTION ==== \t\t * No flash access should be performed in critical section. All \t\t * code and data accessed must reside in ram. \t\t */ \t\tkey = irq_lock(); \t}  \twhile (len) { \t\t/* If the offset isn't a multiple of the NOR page size, we first need \t\t * to write the remaining part that fits, otherwise the write could \t\t * be wrapped around within the same page \t\t */ \t\ti = MIN(SPI_NOR_PAGE_SIZE - (offset % SPI_NOR_PAGE_SIZE), len); #ifdef CONFIG_FLASH_MCUX_FLEXSPI_NOR_WRITE_BUFFER \t\tmemcpy(nor_write_buf, src, i); #endif \t\tflash_flexspi_nor_write_enable(data); #ifdef CONFIG_FLASH_MCUX_FLEXSPI_NOR_WRITE_BUFFER \t\tflash_flexspi_nor_page_program(data, offset, nor_write_buf, i); #else \t\tflash_flexspi_nor_page_program(data, offset, src, i); #endif \t\tflash_flexspi_nor_wait_bus_busy(data); \t\tmemc_flexspi_reset(&data->controller); \t\tsrc += i; \t\toffset += i; \t\tlen -= i; \t}  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* ==== EXIT CRITICAL SECTION ==== */ \t\tirq_unlock(key); \t}  #ifdef CONFIG_HAS_MCUX_CACHE \tDCACHE_InvalidateByRange((uint32_t) dst, size); #endif  \treturn 0; }  static int flash_flexspi_nor_erase(const struct device *dev, off_t offset, \t\tsize_t size) { \tstruct flash_flexspi_nor_data *data = dev->data; \tconst size_t num_sectors = size / SPI_NOR_SECTOR_SIZE; \tconst size_t num_blocks = size / SPI_NOR_BLOCK_SIZE;  \tint i; \tunsigned int key = 0;  \tuint8_t *dst = memc_flexspi_get_ahb_address(&data->controller, \t\t\t\t\t\t    data->port, \t\t\t\t\t\t    offset);  \tif (offset % SPI_NOR_SECTOR_SIZE) { \t\tLOG_ERR(\"Invalid offset\"); \t\treturn -EINVAL; \t}  \tif (size % SPI_NOR_SECTOR_SIZE) { \t\tLOG_ERR(\"Invalid size\"); \t\treturn -EINVAL; \t}  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* \t\t * ==== ENTER CRITICAL SECTION ==== \t\t * No flash access should be performed in critical section. All \t\t * code and data accessed must reside in ram. \t\t */ \t\tkey = irq_lock(); \t}  \tif ((offset == 0)&& (size == data->config.flashSize * KB(1))) { \t\tflash_flexspi_nor_write_enable(data); \t\tflash_flexspi_nor_erase_chip(data); \t\tflash_flexspi_nor_wait_bus_busy(data); \t\tmemc_flexspi_reset(&data->controller); \t} else if ((0 == (offset % SPI_NOR_BLOCK_SIZE))&& (0 == (size % SPI_NOR_BLOCK_SIZE))) { \t\tfor (i = 0; i< num_blocks; i++) { \t\t\tflash_flexspi_nor_write_enable(data); \t\t\tflash_flexspi_nor_erase_block(data, offset); \t\t\tflash_flexspi_nor_wait_bus_busy(data); \t\t\tmemc_flexspi_reset(&data->controller); \t\t\toffset += SPI_NOR_BLOCK_SIZE; \t\t} \t} else { \t\tfor (i = 0; i< num_sectors; i++) { \t\t\tflash_flexspi_nor_write_enable(data); \t\t\tflash_flexspi_nor_erase_sector(data, offset); \t\t\tflash_flexspi_nor_wait_bus_busy(data); \t\t\tmemc_flexspi_reset(&data->controller); \t\t\toffset += SPI_NOR_SECTOR_SIZE; \t\t} \t}  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* ==== EXIT CRITICAL SECTION ==== */ \t\tirq_unlock(key); \t}  #ifdef CONFIG_HAS_MCUX_CACHE \tDCACHE_InvalidateByRange((uint32_t) dst, size); #endif  \treturn 0; }  static const struct flash_parameters *flash_flexspi_nor_get_parameters( \t\tconst struct device *dev) { \tstruct flash_flexspi_nor_data *data = dev->data;  \treturn&data->flash_parameters; }  #if defined(CONFIG_FLASH_PAGE_LAYOUT) static void flash_flexspi_nor_pages_layout(const struct device *dev, \t\tconst struct flash_pages_layout **layout, size_t *layout_size) { \tstruct flash_flexspi_nor_data *data = dev->data;  \t*layout =&data->layout; \t*layout_size = 1; } #endif /* CONFIG_FLASH_PAGE_LAYOUT */   /*  * This function enables quad mode, when supported. Otherwise it  * returns an error.  * @param dev: Flexspi device  * @param flexspi_lut: flexspi lut table, useful if instruction writes are needed  * @param qer: DW15 quad enable parameter  * @return 0 if quad mode was entered, or -ENOTSUP if quad mode is not supported  */ static int flash_flexspi_nor_quad_enable(struct flash_flexspi_nor_data *data, \t\t\t\t\tuint32_t (*flexspi_lut)[MEMC_FLEXSPI_CMD_PER_SEQ], \t\t\t\t\tuint8_t qer) { \tint ret; \tuint32_t buffer = 0; \tuint16_t bit = 0; \tuint8_t rd_size, wr_size; \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.SeqNumber = 1, \t\t.data =&buffer, \t}; \tflexspi_device_config_t config = { \t\t.flexspiRootClk = MHZ(50), \t\t.flashSize = FLEXSPI_FLSHCR0_FLSHSZ_MASK, /* Max flash size */ \t\t.ARDSeqNumber = 1, \t\t.ARDSeqIndex = READ, \t};  \tswitch (qer) { \tcase JESD216_DW15_QER_VAL_NONE: \t\t/* No init needed */ \t\treturn 0; \tcase JESD216_DW15_QER_VAL_S2B1v1: \tcase JESD216_DW15_QER_VAL_S2B1v4: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WRSR, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 1 of status register 2 */ \t\tbit = BIT(9); \t\trd_size = 2; \t\twr_size = 2; \t\tbreak; \tcase JESD216_DW15_QER_VAL_S1B6: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WRSR, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 6 of status register 1 */ \t\tbit = BIT(6); \t\trd_size = 1; \t\twr_size = 1; \t\tbreak; \tcase JESD216_DW15_QER_VAL_S2B7: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0x3F, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0x3E, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 7 of status register 2 */ \t\tbit = BIT(7); \t\trd_size = 1; \t\twr_size = 1; \t\tbreak; \tcase JESD216_DW15_QER_VAL_S2B1v5: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR2, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WRSR, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 1 of status register 2 */ \t\tbit = BIT(9); \t\trd_size = 1; \t\twr_size = 2; \t\tbreak; \tcase JESD216_DW15_QER_VAL_S2B1v6: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR2, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WRSR2, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 7 of status register 2 */ \t\tbit = BIT(7); \t\trd_size = 1; \t\twr_size = 1; \t\tbreak; \tdefault: \t\treturn -ENOTSUP; \t} \tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\tdata->port); \tif (ret< 0) { \t\treturn ret; \t} \ttransfer.dataSize = rd_size; \ttransfer.seqIndex = SCRATCH_CMD; \ttransfer.cmdType = kFLEXSPI_Read; \t/* Read status register */ \tret = memc_flexspi_transfer(&data->controller,&transfer); \tif (ret< 0) { \t\treturn ret; \t} \tbuffer |= bit; \ttransfer.dataSize = wr_size; \ttransfer.seqIndex = SCRATCH_CMD2; \ttransfer.cmdType = kFLEXSPI_Write; \treturn memc_flexspi_transfer(&data->controller,&transfer); }  /*  * This function enables 4 byte addressing, when supported. Otherwise it  * returns an error.  * @param dev: Flexspi device  * @param flexspi_lut: flexspi lut table, useful if instruction writes are needed  * @param en4b: DW16 enable 4 byte mode parameter  * @return 0 if 4 byte mode was entered, or -ENOTSUP if 4 byte mode was not supported  */ static int flash_flexspi_nor_4byte_enable(struct flash_flexspi_nor_data *data, \t\t\t\t\tuint32_t (*flexspi_lut)[MEMC_FLEXSPI_CMD_PER_SEQ], \t\t\t\t\tuint32_t en4b) { \tint ret; \tuint32_t buffer = 0; \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.SeqNumber = 1, \t\t.data =&buffer, \t}; \tflexspi_device_config_t config = { \t\t.flexspiRootClk = MHZ(50), \t\t.flashSize = FLEXSPI_FLSHCR0_FLSHSZ_MASK, /* Max flash size */ \t\t.ARDSeqNumber = 1, \t\t.ARDSeqIndex = READ, \t}; \tif (en4b& BIT(6)) { \t\t/* Flash is always in 4 byte mode. We just need to configure LUT */ \t\treturn 0; \t} else if (en4b& BIT(5)) { \t\t/* Dedicated vendor instruction set, which we don't support. Exit here */ \t\treturn -ENOTSUP; \t} else if (en4b& BIT(4)) { \t\t/* Set bit 0 of 16 bit configuration register */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xB5, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xB1, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1); \t\tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\ttransfer.dataSize = 2; \t\ttransfer.seqIndex = SCRATCH_CMD; \t\ttransfer.cmdType = kFLEXSPI_Read; \t\t/* Read config register */ \t\tret = memc_flexspi_transfer(&data->controller,&transfer); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\tbuffer |= BIT(0); \t\t/* Set config register */ \t\ttransfer.seqIndex = SCRATCH_CMD2; \t\ttransfer.cmdType = kFLEXSPI_Read; \t\treturn memc_flexspi_transfer(&data->controller,&transfer); \t} else if (en4b& BIT(1)) { \t\t/* Issue write enable, then instruction 0xB7 */ \t\tflash_flexspi_nor_write_enable(data); \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xB7, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\ttransfer.dataSize = 0; \t\ttransfer.seqIndex = SCRATCH_CMD; \t\ttransfer.cmdType = kFLEXSPI_Command; \t\treturn memc_flexspi_transfer(&data->controller,&transfer); \t} else if (en4b& BIT(0)) { \t\t/* Issue instruction 0xB7 */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xB7, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\ttransfer.dataSize = 0; \t\ttransfer.seqIndex = SCRATCH_CMD; \t\ttransfer.cmdType = kFLEXSPI_Command; \t\treturn memc_flexspi_transfer(&data->controller,&transfer); \t} \t/* Other methods not supported */ \treturn -ENOTSUP; }  /*  * This function configures the FlexSPI to manage the flash device  * based on values in SFDP header  * @param data: Flexspi device data  * @param header: SFDP header for flash  * @param bfp: basic flash parameters for flash  * @param flexspi_lut: LUT table, filled with READ LUT command  * @return 0 on success, or negative value on error  */ static int flash_flexspi_nor_config_flash(struct flash_flexspi_nor_data *data, \t\t\tstruct jesd216_sfdp_header *header, \t\t\tstruct jesd216_bfp *bfp, \t\t\tuint32_t (*flexspi_lut)[MEMC_FLEXSPI_CMD_PER_SEQ]) { \tstruct jesd216_instr instr; \tstruct jesd216_bfp_dw16 dw16; \tstruct jesd216_bfp_dw15 dw15; \tstruct jesd216_bfp_dw14 dw14; \tuint8_t addr_width; \tuint8_t mode_cmd; \tint ret;  \taddr_width = jesd216_bfp_addrbytes(bfp) == \t\tJESD216_SFDP_BFP_DW1_ADDRBYTES_VAL_4B ? 32 : 24;  \t/* Check to see if we can enable 4 byte addressing */ \tret = jesd216_bfp_decode_dw16(&header->phdr[0], bfp,&dw16); \tif (ret == 0) { \t\t/* Attempt to enable 4 byte addressing */ \t\tret = flash_flexspi_nor_4byte_enable(data, flexspi_lut, \t\t\t\t\t\t     dw16.enter_4ba); \t\tif (ret == 0) { \t\t\t/* Use 4 byte address width */ \t\t\taddr_width = 32; \t\t\t/* Update LUT for ERASE_SECTOR and ERASE_BLOCK to use 32 bit addr */ \t\t\tflexspi_lut[ERASE_SECTOR][0] = FLEXSPI_LUT_SEQ( \t\t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, \t\t\t\t\tSPI_NOR_CMD_SE, kFLEXSPI_Command_RADDR_SDR, \t\t\t\t\tkFLEXSPI_1PAD, addr_width); \t\t\tflexspi_lut[ERASE_BLOCK][0] = FLEXSPI_LUT_SEQ( \t\t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, \t\t\t\t\tSPI_NOR_CMD_BE, kFLEXSPI_Command_RADDR_SDR, \t\t\t\t\tkFLEXSPI_1PAD, addr_width); \t\t} \t} \t/* Extract the read command. \t * Note- enhanced XIP not currently supported, nor is 4-4-4 mode. \t */ \tif (jesd216_bfp_read_support(&header->phdr[0], bfp, \t    JESD216_MODE_144,&instr)> 0) { \t\tLOG_DBG(\"Enable 144 mode\"); \t\t/* Configure for 144 QUAD read mode */ \t\tif (instr.mode_clocks == 2) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE8_SDR; \t\t} else if (instr.mode_clocks == 1) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE4_SDR; \t\t} else if (instr.mode_clocks == 0) { \t\t\t/* Just send dummy cycles during mode clock period */ \t\t\tmode_cmd = kFLEXSPI_Command_DUMMY_SDR; \t\t} else { \t\t\treturn -ENOTSUP; \t\t} \t\tflexspi_lut[READ][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, instr.instr, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_4PAD, addr_width); \t\t/* Note- we always set mode bits to 0x0 */ \t\tflexspi_lut[READ][1] = FLEXSPI_LUT_SEQ( \t\t\t\tmode_cmd, kFLEXSPI_4PAD, 0x00, \t\t\t\tkFLEXSPI_Command_DUMMY_SDR, kFLEXSPI_4PAD, instr.wait_states); \t\tflexspi_lut[READ][2] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_4PAD, 0x04, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\t/* Read 1S-4S-4S enable method */ \t\tret = jesd216_bfp_decode_dw15(&header->phdr[0], bfp,&dw15); \t\tif (ret == 0) { \t\t\tret = flash_flexspi_nor_quad_enable(data, flexspi_lut, \t\t\t\t\t\t\t    dw15.qer); \t\t\tif (ret == 0) { \t\t\t\t/* Now, install 1S-1S-4S page program command */ \t\t\t\tflexspi_lut[PAGE_PROGRAM][0] = FLEXSPI_LUT_SEQ( \t\t\t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, \t\t\t\t\t\tSPI_NOR_CMD_PP_1_1_4, kFLEXSPI_Command_RADDR_SDR, \t\t\t\t\t\tkFLEXSPI_1PAD, addr_width); \t\t\t\tflexspi_lut[PAGE_PROGRAM][1] = FLEXSPI_LUT_SEQ( \t\t\t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_4PAD, \t\t\t\t\t\t0x4, kFLEXSPI_Command_STOP, \t\t\t\t\t\tkFLEXSPI_1PAD, 0x0); \t\t\t} \t\t}  \t} else if (jesd216_bfp_read_support(&header->phdr[0], bfp, \t    JESD216_MODE_122,&instr)> 0) { \t\tLOG_DBG(\"Enable 122 mode\"); \t\tif (instr.mode_clocks == 4) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE8_SDR; \t\t} else if (instr.mode_clocks == 2) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE4_SDR; \t\t} else if (instr.mode_clocks == 1) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE2_SDR; \t\t} else if (instr.mode_clocks == 0) { \t\t\t/* Just send dummy cycles during mode clock period */ \t\t\tmode_cmd = kFLEXSPI_Command_DUMMY_SDR; \t\t} else { \t\t\treturn -ENOTSUP; \t\t} \t\tflexspi_lut[READ][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, instr.instr, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_2PAD, addr_width); \t\t/* Note- we always set mode bits to 0x0 */ \t\tflexspi_lut[READ][1] = FLEXSPI_LUT_SEQ( \t\t\t\tmode_cmd, kFLEXSPI_2PAD, 0x0, \t\t\t\tkFLEXSPI_Command_DUMMY_SDR, kFLEXSPI_2PAD, instr.wait_states); \t\tflexspi_lut[READ][2] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_2PAD, 0x02, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\t/* Now, install 1S-1S-2S page program command */ \t\tflexspi_lut[PAGE_PROGRAM][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_PP_1_1_2, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, addr_width); \t\tflexspi_lut[PAGE_PROGRAM][1] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_2PAD, 0x4, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t} \t/* Default to 111 mode if no support exists, leave READ/WRITE untouched */  \t/* Now, read DW14 to determine the polling method we should use while programming */ \tret = jesd216_bfp_decode_dw14(&header->phdr[0], bfp,&dw14); \tif (ret< 0) { \t\t/* Default to legacy polling mode */ \t\tdw14.poll_options = 0x0; \t} \tif (dw14.poll_options& BIT(1)) { \t\t/* Read instruction used for polling is 0x70 */ \t\tdata->legacy_poll = false; \t\tflexspi_lut[READ_STATUS_REG][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0x70, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01); \t} else { \t\t/* Read instruction used for polling is 0x05 */ \t\tdata->legacy_poll = true; \t\tflexspi_lut[READ_STATUS_REG][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01); \t}  \treturn 0; }  /* Helper so we can avoid flash access while performing SFDP probe */ static int flash_flexspi_nor_sfdp_read_helper(struct flash_flexspi_nor_data *dev_data, \t\toff_t offset, void *data, size_t len) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = offset, \t\t.port = dev_data->port, \t\t.cmdType = kFLEXSPI_Read, \t\t.seqIndex = READ_JESD216, \t\t.SeqNumber = 1, \t\t.data = (uint32_t *)data, \t\t.dataSize = len, \t};  \t/* Get SFDP data */ \treturn memc_flexspi_transfer(&dev_data->controller,&transfer); }   #if defined(CONFIG_FLASH_JESD216_API)  static int flash_flexspi_nor_sfdp_read(const struct device *dev, \t\toff_t offset, void *data, size_t len) { \tstruct flash_flexspi_nor_data *dev_data = dev->data;  \treturn flash_flexspi_nor_sfdp_read_helper(dev_data, offset, data, len); }  #endif  /* Checks JEDEC ID of flash. If supported, installs custom LUT table */ static int flash_flexspi_nor_check_jedec(struct flash_flexspi_nor_data *data, \t\t\tuint32_t (*flexspi_lut)[MEMC_FLEXSPI_CMD_PER_SEQ]) { \tint ret; \tuint32_t vendor_id;  \tret = flash_flexspi_nor_read_id_helper(data, (uint8_t *)&vendor_id); \tif (ret< 0) { \t\treturn ret; \t}  \t/* Switch on manufacturer and vendor ID */ \tswitch (vendor_id& 0xFFFF) { \tcase 0x25C2: \t\t/* MX25 flash, use 4 byte read/write */ \t\tflexspi_lut[READ][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_4READ_4B, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_4PAD, 32); \t\t/* Flash needs 10 dummy cycles */ \t\tflexspi_lut[READ][1] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_DUMMY_SDR, kFLEXSPI_4PAD, 10, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_4PAD, 0x04); \t\t/* Only 1S-4S-4S page program supported */ \t\tflexspi_lut[PAGE_PROGRAM][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_PP_1_4_4_4B, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_4PAD, 32); \t\tflexspi_lut[PAGE_PROGRAM][1] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_4PAD, 0x4, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\t/* Update ERASE commands for 4 byte mode */ \t\tflexspi_lut[ERASE_SECTOR][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_SE_4B, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 32); \t\tflexspi_lut[ERASE_BLOCK][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xDC, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 32), \t\t/* Read instruction used for polling is 0x05 */ \t\tdata->legacy_poll = true; \t\tflexspi_lut[READ_STATUS_REG][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01); \t\t/* Device uses bit 6 of status reg 1 for QE */ \t\treturn flash_flexspi_nor_quad_enable(data, flexspi_lut, JESD216_DW15_QER_VAL_S1B6); \tdefault: \t\treturn -ENOTSUP; \t} }  /* Probe parameters from flash SFDP header, and use them to configure the FlexSPI */ static int flash_flexspi_nor_probe(struct flash_flexspi_nor_data *data) { \tuint32_t flexspi_lut[FLEXSPI_INSTR_END][MEMC_FLEXSPI_CMD_PER_SEQ] = {0}; \t/* JESD216B defines up to 23 basic flash parameters */ \tuint32_t param_buf[23]; \t/* Space to store SFDP header and first parameter header */ \tuint8_t sfdp_buf[JESD216_SFDP_SIZE(1)] __aligned(4); \tstruct jesd216_bfp *bfp = (struct jesd216_bfp *)param_buf; \tstruct jesd216_sfdp_header *header = (struct jesd216_sfdp_header *)sfdp_buf; \tint ret; \tunsigned int key = 0U;  \tflexspi_device_config_t config = { \t\t.flexspiRootClk = MHZ(50), \t\t.flashSize = FLEXSPI_FLSHCR0_FLSHSZ_MASK, /* Max flash size */ \t\t.ARDSeqNumber = 1, \t\t.ARDSeqIndex = READ, \t};  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* \t\t * ==== ENTER CRITICAL SECTION ==== \t\t * No flash access should be performed in critical section. All \t\t * code and data accessed must reside in ram. \t\t */ \t\tkey = irq_lock(); \t\tmemc_flexspi_wait_bus_idle(&data->controller); \t}  \t/* SFDP spec requires that we downclock the FlexSPI to 50MHz or less */ \tret = memc_flexspi_update_clock(&data->controller,&config, \t\t\t\t\tdata->port, MHZ(50)); \tif (ret< 0) { \t\tgoto _exit; \t}  \t/* Setup initial LUT table and FlexSPI configuration */ \tmemcpy(flexspi_lut, flash_flexspi_nor_base_lut, sizeof(flash_flexspi_nor_base_lut));  \tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \tif (ret< 0) { \t\tgoto _exit; \t}  \t/* First, check if the JEDEC ID of this flash has explicit support \t * in this driver \t */ \tret = flash_flexspi_nor_check_jedec(data, flexspi_lut); \tif (ret == 0) { \t\t/* Flash was supported, SFDP probe not needed */ \t\tgoto _program_lut; \t}  \tret = flash_flexspi_nor_sfdp_read_helper(data, 0, sfdp_buf, sizeof(sfdp_buf)); \tif (ret< 0) { \t\tgoto _exit; \t}  \tLOG_DBG(\"SFDP header magic: 0x%x\", header->magic); \tif (jesd216_sfdp_magic(header) != JESD216_SFDP_MAGIC) { \t\t/* Header was read incorrectly */ \t\tLOG_WRN(\"Invalid header\nThe issue was with: drivers: flash: flash_mcux_flexspi_nor: better handle legacy SFDP tables\n\nImplement more robust handling for legacy SFDP tables, which may not\nimplement some of the JEDEC defined DWORDS for SFDP data. Instead of\nfailing to probe/initialize the flash when these DWORDS are not defined\nin the basic flash parameter table, revert to sane defaults for SPI\nflash.\n\nFixes #72051"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: entropy: smartbond: Bug fix\n\nThis commit should fix few wrong expressions Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nif|if\ncondition|(\nname|random_word_get\nargument_list|(\nname|buf\nargument_list|)\noperator|!=\nliteral|0\ncondition|)\nblock|{\nwhile|while\ncondition|(\nname|ptr\noperator|<\nname|limit\ncondition|)\nblock|{\nname|buf\nindex|[\noperator|--",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|buf\n+name|bytes\n+operator|&&\n+name|len\nThe issue was with: drivers: entropy: smartbond: Bug fix\n\nThis commit should fix few wrong expressions"
},{
  "instruction": "There is an issue in the following code. It relates to boards: st: sensortile_box_pro: fix usb console init\n\nInit should return errno value. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|!\nname|device_is_ready\nargument_list|(\nname|dev\nargument_list|)\noperator|||\nname|usb_enable\nargument_list|(\nname|NULL\nargument_list|)\ncondition|)\nblock|{\nreturn|return\noperator|-\nliteral|1\nreturn|;\nblock|}\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function\n\nbegin_comment",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|||\n-name|usb_enable\n-argument_list|(\n-name|NULL\n-argument_list|)\n-literal|1\n+name|ENODEV\n-literal|0\n+name|usb_enable\n+argument_list|(\n+name|NULL\n+argument_list|)\nThe issue was with: boards: st: sensortile_box_pro: fix usb console init\n\nInit should return errno value."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: i3c: shell: fix argc length check for optional param\n\nGETSTATUS and GETMRL where not checking the right argc length. This\ncorrects it to check for the right count. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nif|if\ncondition|(\nname|argc\noperator|>\nliteral|2\ncondition|)\nblock|{\nname|mrl\noperator|.\nname|ibi_len\noperator|&\nname|mrl\nargument_list|,\nname|argc\noperator|>\nliteral|2\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|ret\ncomment|/* If there is a defining byte, then it is assumed to be Format 2*/\nif|if\ncondition|(\nname|argc\noperator|>\nliteral|2\ncondition|)\nblock|{\nname|fmt\noperator|=\nname|GETSTATUS_FORMAT_2",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|2\n+literal|3\n-literal|2\n+literal|3\n-literal|2\n+literal|3\nThe issue was with: drivers: i3c: shell: fix argc length check for optional param\n\nGETSTATUS and GETMRL where not checking the right argc length. This\ncorrects it to check for the right count."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: flash: stm32 qspi driver when Dual-Flash not supported\n\nSome stm32 devices with quadspi (like stm32l47x or stm32l48x)\ndoes not support Dual-Flash Mode. Avoid building error even if\nthe &quadspi node has a <flash-id>  property defined. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|quadspi\nargument_list|)\noperator|,\nname|flash_id\nargument_list|)\nname|uint8_t\nname|qspi_flash_id\ninit|=\nname|DT_PROP\nargument_list|(\nname|uint8_t\nname|decl_nph\ninit|=\nliteral|2\ndecl_stmt|;\nDECL|union|__anon2b897abc010a\nunion|union\nblock|{\ncomment|/* We only process BFP so use one parameter block */\nDECL|member|raw\nname|uint8_t\nname|id\noperator|==\nname|JESD216_SFDP_PARAM_ID_BFP\ncondition|)\nblock|{\nDECL|union|__anon2b897abc020a\nunion|union\nblock|{\nDECL|member|dw\nname|uint32_t\nname|dw",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|&&\n+expr|\\\n+name|defined\n+argument_list|(\n+name|QUADSPI_CR_FSEL\n+argument_list|)\n+comment|/* \t * Some stm32 mcu with quadspi (like stm32l47x or stm32l48x) \t * does not support Dual-Flash Mode \t */\n-DECL|union|__anon2b897abc010a\n+DECL|union|__anon27ebba2e010a\n-DECL|union|__anon2b897abc020a\n+DECL|union|__anon27ebba2e020a\nThe issue was with: drivers: flash: stm32 qspi driver when Dual-Flash not supported\n\nSome stm32 devices with quadspi (like stm32l47x or stm32l48x)\ndoes not support Dual-Flash Mode. Avoid building error even if\nthe &quadspi node has a <flash-id>  property defined."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: Add missing guard for mic_state in ull_conn_iso\n\nThe mic_state is a guarded field in event_done_extra where it was\naccessed outside of its guard. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|)\ncondition|)\nblock|{\nif|if\ncondition|(\nname|done\noperator|->\nname|extra\noperator|.\nname|mic_state\nname|NULL\nargument_list|,\nname|BT_HCI_ERR_TERM_DUE_TO_MIC_FAIL\nargument_list|)\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\nname|cis\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|false\n+condition|)\n+block|{\n+if|#\n+directive|if\n+name|defined\n+argument_list|(\n+name|CONFIG_BT_CTLR_LE_ENC\n+argument_list|)\n+block|}\n+if|else if\n+condition|(\n+endif|#\n+directive|endif\n+comment|/* CONFIG_BT_CTLR_LE_ENC */\nThe issue was with: Bluetooth: Controller: Add missing guard for mic_state in ull_conn_iso\n\nThe mic_state is a guarded field in event_done_extra where it was\naccessed outside of its guard."
},{
  "instruction": "There is an issue in the following code. It relates to sd: sd_ops: remove additional unlock call within card_read()\n\nSD ops card_read() implementation does not need to unlock mutex, as this\nis managed by the calling function card_write_blocks. Remove this stray\nk_mutex_unlock() call.\n\nFixes #72287 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|LOG_ERR\nargument_list|(\nliteral|\"Card did not return to ready state\"\nargument_list|)\nexpr_stmt|;\nname|k_mutex_unlock\nargument_list|(\noperator|&\nname|card\noperator|->\nname|lock\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|ETIMEDOUT\nreturn|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|k_mutex_unlock\n-argument_list|(\n-operator|&\n-name|card\n-operator|->\n-name|lock\n-argument_list|)\n-expr_stmt|;\nThe issue was with: sd: sd_ops: remove additional unlock call within card_read()\n\nSD ops card_read() implementation does not need to unlock mutex, as this\nis managed by the calling function card_write_blocks. Remove this stray\nk_mutex_unlock() call.\n\nFixes #72287"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sdhc: rcar_mmc: remove frequency correction code\n\nRCAR MMC driver previously had to report inaccurate maximum supported\nfrequency to SD subsystem so that the subsystem would select SDR104 mode\ntiming. Remove this logic, as it should no longer be needed. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|MMC_BUS_CLOCK_FREQ\nvalue|800000000\nend_define\n\nbegin_comment\ncomment|/*  * SD/MMC clock for Gen3/Gen4 R-car boards can't be equal to 208 MHz,  * but we can run SDR104 on lower frequencies:  *    \"SDR104: UHS-I 1.8V signaling, Frequency up to 208 MHz\"  * so according to SD card standard it is possible to use lower frequencies,  * and we need to pass check of frequency in sdmmc in order to use sdr104 mode.  * This is the reason why it is needed this correction.  */\nend_comment\n\nbegin_define\nDECL|macro|MMC_MAX_FREQ_CORRECTION\ndefine|#\ndirective|define\nname|MMC_MAX_FREQ_CORRECTION\nvalue|8000000\nend_define\n\nbegin_ifdef\nifdef|#\ndirective|ifdef\nname|CONFIG_RCAR_MMC_DMA_SUPPORT\nend_ifdef\nname|f_max\noperator|=\nname|cfg\noperator|->\nname|max_frequency\noperator|+\nname|MMC_MAX_FREQ_CORRECTION\nexpr_stmt|;\ncomment|/* \t * note: actually, it's possible to get lower frequency \t *       if we use divider from cpg too \t */\nname|props\noperator|->\nname|f_min",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_comment\n-comment|/*  * SD/MMC clock for Gen3/Gen4 R-car boards can't be equal to 208 MHz,  * but we can run SDR104 on lower frequencies:  *    \"SDR104: UHS-I 1.8V signaling, Frequency up to 208 MHz\"  * so according to SD card standard it is possible to use lower frequencies,  * and we need to pass check of frequency in sdmmc in order to use sdr104 mode.  * This is the reason why it is needed this correction.  */\n-end_comment\n-\n-begin_define\n-DECL|macro|MMC_MAX_FREQ_CORRECTION\n-define|#\n-directive|define\n-name|MMC_MAX_FREQ_CORRECTION\n-value|8000000\n-end_define\n-\n-operator|+\n-name|MMC_MAX_FREQ_CORRECTION\nThe issue was with: drivers: sdhc: rcar_mmc: remove frequency correction code\n\nRCAR MMC driver previously had to report inaccurate maximum supported\nfrequency to SD subsystem so that the subsystem would select SDR104 mode\ntiming. Remove this logic, as it should no longer be needed."
},{
  "instruction": "There is an issue in the following code. It relates to arch: riscv: remove unnecessary cast\n\nRemove unnecessary cast of `fp` into `uintptr_t`. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|0U\noperator|)\noperator|&&\nname|in_stack_bound\nargument_list|(\noperator|(\nname|uintptr_t\noperator|)\nname|fp\nargument_list|)\ncondition|;\ncontrol|)\nblock|{\nliteral|\"   ra: \"\nname|PR_REG\nargument_list|,\nname|i\nargument_list|,\noperator|(\nname|uintptr_t\noperator|)\nname|fp\nargument_list|,\nname|ra\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|(\n-name|uintptr_t\n-operator|)\n-operator|(\n-name|uintptr_t\n-operator|)\nThe issue was with: arch: riscv: remove unnecessary cast\n\nRemove unnecessary cast of `fp` into `uintptr_t`."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: usb: usb_dc_mcux: add case for MCXN94X SOC series\n\nAdd case for MCXN94X SOC series to indicate which device controller\nis in use. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_IMXRT11XX\nargument_list|)\noperator|||\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_IMXRT10XX\nargument_list|)\nend_elif\n\nbegin_if\nif|#\ndirective|if",
  "result": "I corrected the issue in the code by changing the following tokens:\n+expr|\\\n+operator|||\n+expr|\\\n+name|defined\n+argument_list|(\n+name|CONFIG_SOC_SERIES_MCXNX4X\n+argument_list|)\nThe issue was with: drivers: usb: usb_dc_mcux: add case for MCXN94X SOC series\n\nAdd case for MCXN94X SOC series to indicate which device controller\nis in use."
},{
  "instruction": "There is an issue in the following code. It relates to usb: device_next: lock scheduler in usbd_init()\n\nLock the scheduler to ensure that the context is not preempted before it\nis fully initialized. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|)\nblock|{\nname|int\nname|ret\ndecl_stmt|;\nname|usbd_device_lock\nargument_list|(\nname|uds_ctx\nargument_list|)\nexpr_stmt|;\nname|usbd_device_unlock\nargument_list|(\nname|uds_ctx\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|ret\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* \t * Lock the scheduler to ensure that the context is not preempted \t * before it is fully initialized. \t */\n+name|k_sched_lock\n+argument_list|()\n+expr_stmt|;\n+name|k_sched_unlock\n+argument_list|()\n+expr_stmt|;\nThe issue was with: usb: device_next: lock scheduler in usbd_init()\n\nLock the scheduler to ensure that the context is not preempted before it\nis fully initialized."
},{
  "instruction": "There is an issue in the following code. It relates to usb: device_next: remove initialized state checks in event processing\n\nFor the simple events, do not check whether the device driver and stack\nare marked as initialized. USB device notification will reschedule\ndelivery if the stack is not yet marked initialized. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|dev\noperator|=\nname|dev\nblock|, \t}\ndecl_stmt|;\nif|if\ncondition|(\noperator|!\nname|udc_is_initialized\nargument_list|(\nname|dev\nargument_list|)\ncondition|)\nblock|{\nreturn|return\noperator|-\nname|EPERM\nreturn|;\nblock|}\nreturn|return\nname|data\noperator|->\nname|event_cb\nargument_list|(\nname|dev\noperator|==\nname|event\noperator|.\nname|dev\noperator|&&\nname|usbd_is_initialized\nargument_list|(\nname|uds_ctx\nargument_list|)\ncondition|)\nblock|{\nname|usbd_event_handler\nargument_list|(\nname|uds_ctx",
  "result": "I corrected the issue in the code by changing the following tokens:\n-if|if\n-condition|(\n-operator|!\n-name|udc_is_initialized\n-argument_list|(\n-name|dev\n-argument_list|)\n-condition|)\n-block|{\n-return|return\n-operator|-\n-name|EPERM\n-return|;\n-block|}\n-operator|&&\n-name|usbd_is_initialized\n-argument_list|(\n-name|uds_ctx\n-argument_list|)\nThe issue was with: usb: device_next: remove initialized state checks in event processing\n\nFor the simple events, do not check whether the device driver and stack\nare marked as initialized. USB device notification will reschedule\ndelivery if the stack is not yet marked initialized."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: regulator/nxp_vref: Fixed incorrect input parameter\n\nFixed incorrect parameter passed in function linear_range_get_value. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright 2023 NXP  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_define\nDECL|macro|DT_DRV_COMPAT\ndefine|#\nname|linear_range_get_value\nargument_list|(\noperator|&\nname|utrim_range\nargument_list|,\nname|base\noperator|->\nname|UTRIM\nargument_list|,\nname|volt_uv\nargument_list|)\nexpr_stmt|;\nreturn|return",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/*  * Copyright 2023 NXP  * SPDX-License-Identifier: Apache-2.0  */\n+comment|/*  * Copyright 2023-2024 NXP  * SPDX-License-Identifier: Apache-2.0  */\n-name|base\n-operator|->\n-name|UTRIM\n+name|idx\nThe issue was with: drivers: regulator/nxp_vref: Fixed incorrect input parameter\n\nFixed incorrect parameter passed in function linear_range_get_value."
},{
  "instruction": "There is an issue in the following code. It relates to net: zperf: Fix upload ping timeout error\n\nFixes remote address for ping before upload. This caused the ping in zperf\nupload to timeout as shown in the following output:\n\n```\nuart:~$ zperf udp upload 2001:db8::2 5001 10 50 1M\nRemote port is 5001\nConnecting to 2001:db8::2\nDuration:       10.00 s\nPacket size:    50 bytes\nRate:           1000 kbps\nStarting...\nping 2001:db8::2 timeout\nRate:           1.00 Mbps\nPacket duration 390 us\n```\n\nFixes: https://github.com/zephyrproject-rtos/zephyr/issues/68674 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ret\nargument_list|)\nexpr_stmt|;\nreturn|return;\nblock|}\nname|memcpy\nargument_list|(\noperator|&\nname|dest_addr\noperator|.\nname|sin6_addr\nargument_list|,\nname|addr\nargument_list|,\nsizeof|sizeof\nargument_list|(\nexpr|struct\nname|in6_addr\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|k_sem_init\nargument_list|(\noperator|&",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|memcpy\n+name|dest_addr\n+operator|.\n+name|sin6_family\n+operator|=\n+name|AF_INET6\n+expr_stmt|;\n+name|net_ipv6_addr_copy_raw\n+operator|(\n+name|uint8_t\n+operator|*\n+operator|)\n+operator|(\n+name|uint8_t\n+operator|*\n+operator|)\n-argument_list|,\n-sizeof|sizeof\n-argument_list|(\n-expr|struct\n-name|in6_addr\n-argument_list|)\nThe issue was with: net: zperf: Fix upload ping timeout error\n\nFixes remote address for ping before upload. This caused the ping in zperf\nupload to timeout as shown in the following output:\n\n```\nuart:~$ zperf udp upload 2001:db8::2 5001 10 50 1M\nRemote port is 5001\nConnecting to 2001:db8::2\nDuration:       10.00 s\nPacket size:    50 bytes\nRate:           1000 kbps\nStarting...\nping 2001:db8::2 timeout\nRate:           1.00 Mbps\nPacket duration 390 us\n```\n\nFixes: https://github.com/zephyrproject-rtos/zephyr/issues/68674"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: regulator: fixed warning during build in gpio regulator\n\nFix warning in gpio regulator:\n    \\\"declaration of 'ret' shadows a previous local\\\". Please fix this issue.",
  "input": "Faulty tokenized code:\ncondition|;\nname|gpio_idx\noperator|++\ncontrol|)\nblock|{\nname|int\nname|ret\ndecl_stmt|;\nif|if\ncondition|(\noperator|!\nname|gpio_is_ready_dt\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|int\n-name|ret\n-decl_stmt|;\nThe issue was with: drivers: regulator: fixed warning during build in gpio regulator\n\nFix warning in gpio regulator:\n    \\\"declaration of 'ret' shadows a previous local\\\"."
},{
  "instruction": "There is an issue in the following code. It relates to drivers/sensor: lps25hb: Fix int32 overflow in the val2 part\n\nThe val2 calculation was done using (1000000 / 40960) as\nmultiplying factor, which was sometimes leading to a\nint32 overflow. So, let's use the equivalent (but smaller)\n(3125 / 128).\n\nFix #46615 Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|,\nname|int32_t\nname|raw_val\nparameter_list|)\nblock|{\ncomment|/* val = raw_val / 40960 */\nname|val\noperator|->\nname|val1\noperator|=\nname|raw_val\noperator|/\nliteral|40960\nexpr_stmt|;\nname|val\noperator|->\nname|val2\noperator|=\noperator|(\noperator|(\nname|int32_t\noperator|)\nname|raw_val\noperator|*\nliteral|1000000\noperator|/\nliteral|40960\noperator|)\noperator|%\nliteral|1000000\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* val = raw_val / 40960 */\n+comment|/* Pressure sensitivity is 4096 LSB/hPa */\n+comment|/* Also convert hPa into kPa */\n+comment|/* For the decimal part use (3125 / 128) as a factor instead of \t * (1000000 / 40960) to avoid int32 overflow \t */\n-operator|(\n-name|int32_t\n-operator|)\n-operator|*\n-literal|1000000\n-operator|/\n+operator|%\n-operator|%\n-literal|1000000\n+operator|*\n+literal|3125\n+operator|/\n+literal|128\nThe issue was with: drivers/sensor: lps25hb: Fix int32 overflow in the val2 part\n\nThe val2 calculation was done using (1000000 / 40960) as\nmultiplying factor, which was sometimes leading to a\nint32 overflow. So, let's use the equivalent (but smaller)\n(3125 / 128).\n\nFix #46615"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: esp_at: make esp_pull_quoted() to only return -EAGAIN\n\nIf no \\\" character is found in buffer by esp_pull_quoted() it\nreturns -EAGAIN which causes a loop that never ends. This is because\nthe buffer dont get filled up with new data so no \\\" chrachter will be\nfound. This commit changes esp_pull_quoted() to only return -EAGAIN,\nso the buffer can get filled with new data and thus the loop can come\nto an end. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|'\"'\ncondition|)\nblock|{\nreturn|return\noperator|-\nname|EBADMSG\nreturn|;\nblock|}\noperator|(\noperator|*\nname|str",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|EBADMSG\n+name|EAGAIN\nThe issue was with: drivers: esp_at: make esp_pull_quoted() to only return -EAGAIN\n\nIf no \\\" character is found in buffer by esp_pull_quoted() it\nreturns -EAGAIN which causes a loop that never ends. This is because\nthe buffer dont get filled up with new data so no \\\" chrachter will be\nfound. This commit changes esp_pull_quoted() to only return -EAGAIN,\nso the buffer can get filled with new data and thus the loop can come\nto an end."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: udc_dwc2: Fix debug logging bus fault\n\nPass DIEPTXF address instead of value to sys_read32() to prevent bus\nfault when debug logging is enabled. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|sys_read32\nargument_list|(\noperator|(\nname|mem_addr_t\noperator|)\nname|base\noperator|->\nname|dieptxf\nindex|[\nname|i",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|&\nThe issue was with: drivers: udc_dwc2: Fix debug logging bus fault\n\nPass DIEPTXF address instead of value to sys_read32() to prevent bus\nfault when debug logging is enabled."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: can: transceiver: gpio: add build assert for GPIO properties\n\nAdd a build-time assert for verifying that at least one of the supported\ndevicetree GPIO properties is present on each compatible devicetree node. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|CAN_TRANSCEIVER_GPIO_INIT\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|static const struct can_transceiver_gpio_config\tcan_transceiver_gpio_config_##inst = { \\ \t\tCAN_TRANSCEIVER_GPIO_COND(inst, enable)\t\t\t\\ \t\tCAN_TRANSCEIVER_GPIO_COND(inst, standby)\t\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst,&can_transceiver_gpio_init,\t\t\\ \t\t\tNULL, NULL,&can_transceiver_gpio_config_##inst,\\ \t\t\tPOST_KERNEL, CONFIG_CAN_TRANSCEIVER_INIT_PRIORITY, \\&can_transceiver_gpio_driver_api);\t\t\\  DT_INST_FOREACH_STATUS_OKAY(CAN_TRANSCEIVER_GPIO_INIT)\nend_define\n\nend_unit\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|static const struct can_transceiver_gpio_config\tcan_transceiver_gpio_config_##inst = { \\ \t\tCAN_TRANSCEIVER_GPIO_COND(inst, enable)\t\t\t\\ \t\tCAN_TRANSCEIVER_GPIO_COND(inst, standby)\t\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst,&can_transceiver_gpio_init,\t\t\\ \t\t\tNULL, NULL,&can_transceiver_gpio_config_##inst,\\ \t\t\tPOST_KERNEL, CONFIG_CAN_TRANSCEIVER_INIT_PRIORITY, \\&can_transceiver_gpio_driver_api);\t\t\\  DT_INST_FOREACH_STATUS_OKAY(CAN_TRANSCEIVER_GPIO_INIT)\n+value|BUILD_ASSERT(DT_INST_NODE_HAS_PROP(inst, enable_gpios) ||\t\\ \t\t     DT_INST_NODE_HAS_PROP(inst, standby_gpios),\t\\ \t\t     \"Missing GPIO property on \"\t\t\t\\ \t\t     DT_NODE_FULL_NAME(DT_DRV_INST(inst)));\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic const struct can_transceiver_gpio_config\tcan_transceiver_gpio_config_##inst = { \\ \t\tCAN_TRANSCEIVER_GPIO_COND(inst, enable)\t\t\t\\ \t\tCAN_TRANSCEIVER_GPIO_COND(inst, standby)\t\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst,&can_transceiver_gpio_init,\t\t\\ \t\t\tNULL, NULL,&can_transceiver_gpio_config_##inst,\\ \t\t\tPOST_KERNEL, CONFIG_CAN_TRANSCEIVER_INIT_PRIORITY, \\&can_transceiver_gpio_driver_api);\t\t\\  DT_INST_FOREACH_STATUS_OKAY(CAN_TRANSCEIVER_GPIO_INIT)\nThe issue was with: drivers: can: transceiver: gpio: add build assert for GPIO properties\n\nAdd a build-time assert for verifying that at least one of the supported\ndevicetree GPIO properties is present on each compatible devicetree node."
},{
  "instruction": "There is an issue in the following code. It relates to shell: devmem: correct number of `mand` and `opt` of `cmd_dump`\n\nAccording to the `SHELL_CMD_ARG` macro, the `mand` argument of `cmd_dump`\nshould be 5, including the command name itself, `dump`.\nMeanwhile, the `opt` should be 2, as this value describes the optional\nfield, which is [-w <width>]. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|\"Usage:\\n\"\nliteral|\"devmem dump -a<address> -s<size> [-w<width>]\\n\"\nargument_list|,\nname|cmd_dump\nargument_list|,\nliteral|4\nargument_list|,\nliteral|6\nargument_list|)\nargument_list|,\nname|SHELL_CMD_ARG\nargument_list|(\nname|load",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|4\n+literal|5\n-literal|6\n+literal|2\nThe issue was with: shell: devmem: correct number of `mand` and `opt` of `cmd_dump`\n\nAccording to the `SHELL_CMD_ARG` macro, the `mand` argument of `cmd_dump`\nshould be 5, including the command name itself, `dump`.\nMeanwhile, the `opt` should be 2, as this value describes the optional\nfield, which is [-w <width>]."
},{
  "instruction": "There is an issue in the following code. It relates to tests: arch arm: runtime nmi testing with dcache for ARM V7\n\nFor ARMV7 devices, use preferably the sys_cache_data_flush_all\nfunction to flush the data cache Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/tc_util.h>\nend_include\n\nbegin_comment\ncomment|/* on v8m arch the nmi pend bit is renamed to pend nmi map it to old name */\nend_comment\n\nbegin_ifndef\nargument_list|(\nname|CONFIG_DCACHE\nargument_list|)\ncondition|)\nblock|{\nname|SCB_CleanDCache\nargument_list|()\nexpr_stmt|;\nblock|}\nendif|#\ndirective|endif",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/cache.h>\n+end_include\n+\n-name|SCB_CleanDCache\n+name|sys_cache_data_flush_all\nThe issue was with: tests: arch arm: runtime nmi testing with dcache for ARM V7\n\nFor ARMV7 devices, use preferably the sys_cache_data_flush_all\nfunction to flush the data cache"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sdhc: imx_usdhc: extend reset timeout duration\n\nSome instances of the USDHC peripheral take longer to reset, and will\ntimeout with the previous delay of 100 cycles. Extend this delay to 1000\ncycles to resolve this. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|base\nargument_list|,\nname|kUSDHC_ResetAll\nargument_list|,\nliteral|100U\nargument_list|)\noperator|==\nname|true\ncondition|?\nliteral|0",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|100U\n+literal|1000U\nThe issue was with: drivers: sdhc: imx_usdhc: extend reset timeout duration\n\nSome instances of the USDHC peripheral take longer to reset, and will\ntimeout with the previous delay of 100 cycles. Extend this delay to 1000\ncycles to resolve this."
},{
  "instruction": "There is an issue in the following code. It relates to samples: net: http_server: Add example of passing Content-Type field\n\nShow how to pass Content-Type header field to client. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|,\noperator|.\nname|content_encoding\noperator|=\nliteral|\"gzip\"\nblock|, \t\t}\nblock|,\noperator|.\nname|static_data\noperator|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n+block|,\n+operator|.\n+name|content_type\n+operator|=\n+literal|\"text/html\"\nThe issue was with: samples: net: http_server: Add example of passing Content-Type field\n\nShow how to pass Content-Type header field to client."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: stm32_vref: get rid of floating point computation\n\nInstead of using floating point operations to compute the vref voltage,\nit is possible to use the sensor_value_from_milli() function.\n\nOn a STM32G0, this saves 130 bytes of flash, excluding the FP library\nneeded on a FPU less MCU. Please fix this issue.",
  "input": "Faulty tokenized code:\ninit|=\nname|dev\noperator|->\nname|config\ndecl_stmt|;\nname|float\nname|vref\ndecl_stmt|;\nif|if\ncondition|(\nname|chan\nname|raw\nexpr_stmt|;\nendif|#\ndirective|endif\ncomment|/* CONFIG_SOC_SERIES_STM32H5X */\ncomment|/* millivolt to volt */\nname|vref\noperator|/=\nliteral|1000\nexpr_stmt|;\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_STM32H5X\nexpr_stmt|;\nendif|#\ndirective|endif\ncomment|/* CONFIG_SOC_SERIES_STM32H5X */\nreturn|return\nname|sensor_value_from_double\nargument_list|(\nname|val\nargument_list|,\nname|vref\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|float\n+name|int32_t\n-comment|/* millivolt to volt */\n-name|vref\n-operator|/=\n-literal|1000\n-expr_stmt|;\n-name|sensor_value_from_double\n+name|sensor_value_from_milli\nThe issue was with: drivers: sensor: stm32_vref: get rid of floating point computation\n\nInstead of using floating point operations to compute the vref voltage,\nit is possible to use the sensor_value_from_milli() function.\n\nOn a STM32G0, this saves 130 bytes of flash, excluding the FP library\nneeded on a FPU less MCU."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: stm32_vbat: get rid of floating point computation\n\nInstead of using floating point operations to compute the vbat voltage,\nit is possible to do the computation using 32-bit variables by\nreordering operations and using the sensor_value_from_milli() function.\n\nOn a STM32G0, this saves 140 bytes of flash, excluding the FP library\nneeded on a FPU less MCU. Please fix this issue.",
  "input": "Faulty tokenized code:\ninit|=\nname|dev\noperator|->\nname|config\ndecl_stmt|;\nname|float\nname|voltage\ndecl_stmt|;\nif|if\ncondition|(\nname|chan\nreturn|return\noperator|-\nname|ENOTSUP\nreturn|;\nblock|}\ncomment|/* Sensor value in millivolts */\nname|voltage\noperator|=\nname|data\noperator|->\nname|raw\nargument_list|(\nname|data\noperator|->\nname|adc\nargument_list|)\noperator|/\nliteral|0x0FFF\nexpr_stmt|;\ncomment|/* considering the vbat input through a resistor bridge */\nname|voltage\noperator|=\nname|voltage\noperator|*\nname|cfg\noperator|->\nname|ratio\noperator|/\nliteral|1000\nexpr_stmt|;\ncomment|/* value of SENSOR_CHAN_VOLTAGE in Volt */\nreturn|return\nname|sensor_value_from_double\nargument_list|(\nname|val\nargument_list|,\nname|voltage\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|float\n+name|int32_t\n-comment|/* Sensor value in millivolts */\n+comment|/* Sensor value in millivolts considering the vbat input through a resistor bridge */\n-operator|/\n-literal|0x0FFF\n-expr_stmt|;\n-comment|/* considering the vbat input through a resistor bridge */\n-name|voltage\n-operator|=\n-name|voltage\n-literal|1000\n+literal|0x0FFF\n-comment|/* value of SENSOR_CHAN_VOLTAGE in Volt */\n-name|sensor_value_from_double\n+name|sensor_value_from_milli\nThe issue was with: drivers: sensor: stm32_vbat: get rid of floating point computation\n\nInstead of using floating point operations to compute the vbat voltage,\nit is possible to do the computation using 32-bit variables by\nreordering operations and using the sensor_value_from_milli() function.\n\nOn a STM32G0, this saves 140 bytes of flash, excluding the FP library\nneeded on a FPU less MCU."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: flash: flash_mcux_flexspi_nor: reduce LUT usage\n\nFLEXSPI nor driver uses several LUTs for \\\"scratch\\\" commands during the\nSFDP probe phase that are not needed once the flash is configured. Set a\nsecond \\\"end\\\" marker we can use to configure the FLEXSPI MEMC driver, so\nthat we can indicate the true number of LUTs needed by this driver when\ninit is completed. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|read\noperator|-\nend_expr_stmt\n\nbegin_while\nwhile|while-write hazards. This configuration is not recommended.\" #endif  LOG_MODULE_REGISTER(flash_flexspi_nor, CONFIG_FLASH_LOG_LEVEL);  enum { \tREAD, \tPAGE_PROGRAM, \tREAD_STATUS, \tWRITE_ENABLE, \tERASE_SECTOR, \tERASE_BLOCK, \tREAD_ID, \tREAD_STATUS_REG, \tERASE_CHIP, \tREAD_JESD216, \t/* Used for temporary commands during initialization */ \tSCRATCH_CMD, \tSCRATCH_CMD2, \t/* Must be last entry */ \tFLEXSPI_INSTR_END, };  struct flash_flexspi_nor_config { \t/* Note: don't use this controller reference in code. It is \t * only used during init to copy the device structure from ROM \t * into a RAM structure \t */ \tconst struct device *controller; };  /* Device variables used in critical sections should be in this structure */ struct flash_flexspi_nor_data { \tstruct device controller; \tflexspi_device_config_t config; \tflexspi_port_t port; \tbool legacy_poll; \tstruct flash_pages_layout layout; \tstruct flash_parameters flash_parameters; };  /* Initial LUT table */ static const uint32_t flash_flexspi_nor_base_lut[][MEMC_FLEXSPI_CMD_PER_SEQ] = { \t/* 1S-1S-1S flash read command, should be compatible with all SPI nor flashes */ \t[READ] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_READ, \t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 24), \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1, \t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0), \t}, \t[READ_JESD216] = { \t\t/* Install read SFDP command */ \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, JESD216_CMD_READ_SFDP, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 24), \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_DUMMY_SDR, kFLEXSPI_1PAD, 8, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x4), \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0), \t}, \t/* Standard 1S-1S-1S flash write command, can be switched to 1S-1S-4S when QE is set */ \t[PAGE_PROGRAM] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_PP, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 0x18), \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x04, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0), \t},  \t[WRITE_ENABLE] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WREN, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0), \t},  \t[ERASE_SECTOR] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_SE, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 0x18), \t},  \t[ERASE_BLOCK] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_BE, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 0x18), \t},  \t[ERASE_CHIP] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_CE, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0), \t},  \t[READ_ID] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDID, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01), \t},  \t[READ_STATUS_REG] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01), \t}, };  /* Helper so we can read flash ID without flash access for XIP */ static int flash_flexspi_nor_read_id_helper(struct flash_flexspi_nor_data *data, \t\tuint8_t *vendor_id) { \tuint32_t buffer = 0; \tint ret;  \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Read, \t\t.SeqNumber = 1, \t\t.seqIndex = READ_ID, \t\t.data =&buffer, \t\t.dataSize = 3, \t};  \tLOG_DBG(\"Reading id\");  \tret = memc_flexspi_transfer(&data->controller,&transfer); \tif (ret< 0) { \t\treturn ret; \t}  \tmemcpy(vendor_id,&buffer, 3);  \treturn ret; }  static int flash_flexspi_nor_read_id(const struct device *dev, uint8_t *vendor_id) { \tstruct flash_flexspi_nor_data *data = dev->data;  \treturn flash_flexspi_nor_read_id_helper(data, vendor_id); }  static int flash_flexspi_nor_read_status(struct flash_flexspi_nor_data *data, \t\tuint32_t *status) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Read, \t\t.SeqNumber = 1, \t\t.seqIndex = READ_STATUS_REG, \t\t.data = status, \t\t.dataSize = 1, \t};  \tLOG_DBG(\"Reading status register\");  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_write_enable(struct flash_flexspi_nor_data *data) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Command, \t\t.SeqNumber = 1, \t\t.seqIndex = WRITE_ENABLE, \t\t.data = NULL, \t\t.dataSize = 0, \t};  \tLOG_DBG(\"Enabling write\");  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_erase_sector(struct flash_flexspi_nor_data *data, \toff_t offset) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = offset, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Command, \t\t.SeqNumber = 1, \t\t.seqIndex = ERASE_SECTOR, \t\t.data = NULL, \t\t.dataSize = 0, \t};  \tLOG_DBG(\"Erasing sector at 0x%08zx\", (ssize_t) offset);  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_erase_block(struct flash_flexspi_nor_data *data, \t\t\t\t\t  off_t offset) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = offset, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Command, \t\t.SeqNumber = 1, \t\t.seqIndex = ERASE_BLOCK, \t\t.data = NULL, \t\t.dataSize = 0, \t};  \tLOG_DBG(\"Erasing block at 0x%08zx\", (ssize_t) offset);  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_erase_chip(struct flash_flexspi_nor_data *data) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Command, \t\t.SeqNumber = 1, \t\t.seqIndex = ERASE_CHIP, \t\t.data = NULL, \t\t.dataSize = 0, \t};  \tLOG_DBG(\"Erasing chip\");  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_page_program(struct flash_flexspi_nor_data *data, \t\toff_t offset, const void *buffer, size_t len) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = offset, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Write, \t\t.SeqNumber = 1, \t\t.seqIndex = PAGE_PROGRAM, \t\t.data = (uint32_t *) buffer, \t\t.dataSize = len, \t};  \tLOG_DBG(\"Page programming %d bytes to 0x%08zx\", len, (ssize_t) offset);  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_wait_bus_busy(struct flash_flexspi_nor_data *data) { \tuint32_t status = 0; \tint ret;  \twhile (1) { \t\tret = flash_flexspi_nor_read_status(data,&status); \t\tLOG_DBG(\"status: 0x%x\", status); \t\tif (ret) { \t\t\tLOG_ERR(\"Could not read status\"); \t\t\treturn ret; \t\t}  \t\tif (data->legacy_poll) { \t\t\tif ((status& BIT(0)) == 0) { \t\t\t\tbreak; \t\t\t} \t\t} else { \t\t\tif (status& BIT(7)) { \t\t\t\tbreak; \t\t\t} \t\t} \t}  \treturn 0; }  static int flash_flexspi_nor_read(const struct device *dev, off_t offset, \t\tvoid *buffer, size_t len) { \tstruct flash_flexspi_nor_data *data = dev->data; \tuint8_t *src = memc_flexspi_get_ahb_address(&data->controller, \t\t\t\t\t\t    data->port, \t\t\t\t\t\t    offset);  \tmemcpy(buffer, src, len);  \treturn 0; }  static int flash_flexspi_nor_write(const struct device *dev, off_t offset, \t\tconst void *buffer, size_t len) { \tstruct flash_flexspi_nor_data *data = dev->data; \tsize_t size = len; \tuint8_t *src = (uint8_t *) buffer; \tint i; \tunsigned int key = 0;  \tuint8_t *dst = memc_flexspi_get_ahb_address(&data->controller, \t\t\t\t\t\t    data->port, \t\t\t\t\t\t    offset);  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* \t\t * ==== ENTER CRITICAL SECTION ==== \t\t * No flash access should be performed in critical section. All \t\t * code and data accessed must reside in ram. \t\t */ \t\tkey = irq_lock(); \t}  \twhile (len) { \t\t/* If the offset isn't a multiple of the NOR page size, we first need \t\t * to write the remaining part that fits, otherwise the write could \t\t * be wrapped around within the same page \t\t */ \t\ti = MIN(SPI_NOR_PAGE_SIZE - (offset % SPI_NOR_PAGE_SIZE), len); #ifdef CONFIG_FLASH_MCUX_FLEXSPI_NOR_WRITE_BUFFER \t\tmemcpy(nor_write_buf, src, i); #endif \t\tflash_flexspi_nor_write_enable(data); #ifdef CONFIG_FLASH_MCUX_FLEXSPI_NOR_WRITE_BUFFER \t\tflash_flexspi_nor_page_program(data, offset, nor_write_buf, i); #else \t\tflash_flexspi_nor_page_program(data, offset, src, i); #endif \t\tflash_flexspi_nor_wait_bus_busy(data); \t\tmemc_flexspi_reset(&data->controller); \t\tsrc += i; \t\toffset += i; \t\tlen -= i; \t}  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* ==== EXIT CRITICAL SECTION ==== */ \t\tirq_unlock(key); \t}  #ifdef CONFIG_HAS_MCUX_CACHE \tDCACHE_InvalidateByRange((uint32_t) dst, size); #endif  \treturn 0; }  static int flash_flexspi_nor_erase(const struct device *dev, off_t offset, \t\tsize_t size) { \tstruct flash_flexspi_nor_data *data = dev->data; \tconst size_t num_sectors = size / SPI_NOR_SECTOR_SIZE; \tconst size_t num_blocks = size / SPI_NOR_BLOCK_SIZE;  \tint i; \tunsigned int key = 0;  \tuint8_t *dst = memc_flexspi_get_ahb_address(&data->controller, \t\t\t\t\t\t    data->port, \t\t\t\t\t\t    offset);  \tif (offset % SPI_NOR_SECTOR_SIZE) { \t\tLOG_ERR(\"Invalid offset\"); \t\treturn -EINVAL; \t}  \tif (size % SPI_NOR_SECTOR_SIZE) { \t\tLOG_ERR(\"Invalid size\"); \t\treturn -EINVAL; \t}  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* \t\t * ==== ENTER CRITICAL SECTION ==== \t\t * No flash access should be performed in critical section. All \t\t * code and data accessed must reside in ram. \t\t */ \t\tkey = irq_lock(); \t}  \tif ((offset == 0)&& (size == data->config.flashSize * KB(1))) { \t\tflash_flexspi_nor_write_enable(data); \t\tflash_flexspi_nor_erase_chip(data); \t\tflash_flexspi_nor_wait_bus_busy(data); \t\tmemc_flexspi_reset(&data->controller); \t} else if ((0 == (offset % SPI_NOR_BLOCK_SIZE))&& (0 == (size % SPI_NOR_BLOCK_SIZE))) { \t\tfor (i = 0; i< num_blocks; i++) { \t\t\tflash_flexspi_nor_write_enable(data); \t\t\tflash_flexspi_nor_erase_block(data, offset); \t\t\tflash_flexspi_nor_wait_bus_busy(data); \t\t\tmemc_flexspi_reset(&data->controller); \t\t\toffset += SPI_NOR_BLOCK_SIZE; \t\t} \t} else { \t\tfor (i = 0; i< num_sectors; i++) { \t\t\tflash_flexspi_nor_write_enable(data); \t\t\tflash_flexspi_nor_erase_sector(data, offset); \t\t\tflash_flexspi_nor_wait_bus_busy(data); \t\t\tmemc_flexspi_reset(&data->controller); \t\t\toffset += SPI_NOR_SECTOR_SIZE; \t\t} \t}  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* ==== EXIT CRITICAL SECTION ==== */ \t\tirq_unlock(key); \t}  #ifdef CONFIG_HAS_MCUX_CACHE \tDCACHE_InvalidateByRange((uint32_t) dst, size); #endif  \treturn 0; }  static const struct flash_parameters *flash_flexspi_nor_get_parameters( \t\tconst struct device *dev) { \tstruct flash_flexspi_nor_data *data = dev->data;  \treturn&data->flash_parameters; }  #if defined(CONFIG_FLASH_PAGE_LAYOUT) static void flash_flexspi_nor_pages_layout(const struct device *dev, \t\tconst struct flash_pages_layout **layout, size_t *layout_size) { \tstruct flash_flexspi_nor_data *data = dev->data;  \t*layout =&data->layout; \t*layout_size = 1; } #endif /* CONFIG_FLASH_PAGE_LAYOUT */   /*  * This function enables quad mode, when supported. Otherwise it  * returns an error.  * @param dev: Flexspi device  * @param flexspi_lut: flexspi lut table, useful if instruction writes are needed  * @param qer: DW15 quad enable parameter  * @return 0 if quad mode was entered, or -ENOTSUP if quad mode is not supported  */ static int flash_flexspi_nor_quad_enable(struct flash_flexspi_nor_data *data, \t\t\t\t\tuint32_t (*flexspi_lut)[MEMC_FLEXSPI_CMD_PER_SEQ], \t\t\t\t\tuint8_t qer) { \tint ret; \tuint32_t buffer = 0; \tuint16_t bit = 0; \tuint8_t rd_size, wr_size; \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.SeqNumber = 1, \t\t.data =&buffer, \t}; \tflexspi_device_config_t config = { \t\t.flexspiRootClk = MHZ(50), \t\t.flashSize = FLEXSPI_FLSHCR0_FLSHSZ_MASK, /* Max flash size */ \t\t.ARDSeqNumber = 1, \t\t.ARDSeqIndex = READ, \t};  \tswitch (qer) { \tcase JESD216_DW15_QER_VAL_NONE: \t\t/* No init needed */ \t\treturn 0; \tcase JESD216_DW15_QER_VAL_S2B1v1: \tcase JESD216_DW15_QER_VAL_S2B1v4: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WRSR, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 1 of status register 2 */ \t\tbit = BIT(9); \t\trd_size = 2; \t\twr_size = 2; \t\tbreak; \tcase JESD216_DW15_QER_VAL_S1B6: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WRSR, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 6 of status register 1 */ \t\tbit = BIT(6); \t\trd_size = 1; \t\twr_size = 1; \t\tbreak; \tcase JESD216_DW15_QER_VAL_S2B7: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0x3F, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0x3E, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 7 of status register 2 */ \t\tbit = BIT(7); \t\trd_size = 1; \t\twr_size = 1; \t\tbreak; \tcase JESD216_DW15_QER_VAL_S2B1v5: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR2, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WRSR, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 1 of status register 2 */ \t\tbit = BIT(9); \t\trd_size = 1; \t\twr_size = 2; \t\tbreak; \tcase JESD216_DW15_QER_VAL_S2B1v6: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR2, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WRSR2, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 7 of status register 2 */ \t\tbit = BIT(7); \t\trd_size = 1; \t\twr_size = 1; \t\tbreak; \tdefault: \t\treturn -ENOTSUP; \t} \tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\tdata->port); \tif (ret< 0) { \t\treturn ret; \t} \ttransfer.dataSize = rd_size; \ttransfer.seqIndex = SCRATCH_CMD; \ttransfer.cmdType = kFLEXSPI_Read; \t/* Read status register */ \tret = memc_flexspi_transfer(&data->controller,&transfer); \tif (ret< 0) { \t\treturn ret; \t} \tbuffer |= bit; \ttransfer.dataSize = wr_size; \ttransfer.seqIndex = SCRATCH_CMD2; \ttransfer.cmdType = kFLEXSPI_Write; \treturn memc_flexspi_transfer(&data->controller,&transfer); }  /*  * This function enables 4 byte addressing, when supported. Otherwise it  * returns an error.  * @param dev: Flexspi device  * @param flexspi_lut: flexspi lut table, useful if instruction writes are needed  * @param en4b: DW16 enable 4 byte mode parameter  * @return 0 if 4 byte mode was entered, or -ENOTSUP if 4 byte mode was not supported  */ static int flash_flexspi_nor_4byte_enable(struct flash_flexspi_nor_data *data, \t\t\t\t\tuint32_t (*flexspi_lut)[MEMC_FLEXSPI_CMD_PER_SEQ], \t\t\t\t\tuint32_t en4b) { \tint ret; \tuint32_t buffer = 0; \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.SeqNumber = 1, \t\t.data =&buffer, \t}; \tflexspi_device_config_t config = { \t\t.flexspiRootClk = MHZ(50), \t\t.flashSize = FLEXSPI_FLSHCR0_FLSHSZ_MASK, /* Max flash size */ \t\t.ARDSeqNumber = 1, \t\t.ARDSeqIndex = READ, \t}; \tif (en4b& BIT(6)) { \t\t/* Flash is always in 4 byte mode. We just need to configure LUT */ \t\treturn 0; \t} else if (en4b& BIT(5)) { \t\t/* Dedicated vendor instruction set, which we don't support. Exit here */ \t\treturn -ENOTSUP; \t} else if (en4b& BIT(4)) { \t\t/* Set bit 0 of 16 bit configuration register */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xB5, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xB1, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1); \t\tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\ttransfer.dataSize = 2; \t\ttransfer.seqIndex = SCRATCH_CMD; \t\ttransfer.cmdType = kFLEXSPI_Read; \t\t/* Read config register */ \t\tret = memc_flexspi_transfer(&data->controller,&transfer); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\tbuffer |= BIT(0); \t\t/* Set config register */ \t\ttransfer.seqIndex = SCRATCH_CMD2; \t\ttransfer.cmdType = kFLEXSPI_Read; \t\treturn memc_flexspi_transfer(&data->controller,&transfer); \t} else if (en4b& BIT(1)) { \t\t/* Issue write enable, then instruction 0xB7 */ \t\tflash_flexspi_nor_write_enable(data); \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xB7, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\ttransfer.dataSize = 0; \t\ttransfer.seqIndex = SCRATCH_CMD; \t\ttransfer.cmdType = kFLEXSPI_Command; \t\treturn memc_flexspi_transfer(&data->controller,&transfer); \t} else if (en4b& BIT(0)) { \t\t/* Issue instruction 0xB7 */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xB7, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\ttransfer.dataSize = 0; \t\ttransfer.seqIndex = SCRATCH_CMD; \t\ttransfer.cmdType = kFLEXSPI_Command; \t\treturn memc_flexspi_transfer(&data->controller,&transfer); \t} \t/* Other methods not supported */ \treturn -ENOTSUP; }  /*  * This function configures the FlexSPI to manage the flash device  * based on values in SFDP header  * @param data: Flexspi device data  * @param header: SFDP header for flash  * @param bfp: basic flash parameters for flash  * @param flexspi_lut: LUT table, filled with READ LUT command  * @return 0 on success, or negative value on error  */ static int flash_flexspi_nor_config_flash(struct flash_flexspi_nor_data *data, \t\t\tstruct jesd216_sfdp_header *header, \t\t\tstruct jesd216_bfp *bfp, \t\t\tuint32_t (*flexspi_lut)[MEMC_FLEXSPI_CMD_PER_SEQ]) { \tstruct jesd216_instr instr; \tstruct jesd216_bfp_dw16 dw16; \tstruct jesd216_bfp_dw15 dw15; \tstruct jesd216_bfp_dw14 dw14; \tuint8_t addr_width; \tuint8_t mode_cmd; \tint ret;  \taddr_width = jesd216_bfp_addrbytes(bfp) == \t\tJESD216_SFDP_BFP_DW1_ADDRBYTES_VAL_4B ? 32 : 24;  \t/* Check to see if we can enable 4 byte addressing */ \tret = jesd216_bfp_decode_dw16(&header->phdr[0], bfp,&dw16); \tif (ret< 0) { \t\treturn ret; \t}  \t/* Attempt to enable 4 byte addressing */ \tret = flash_flexspi_nor_4byte_enable(data, flexspi_lut, dw16.enter_4ba); \tif (ret == 0) { \t\t/* Use 4 byte address width */ \t\taddr_width = 32; \t\t/* Update LUT for ERASE_SECTOR and ERASE_BLOCK to use 32 bit addr */ \t\tflexspi_lut[ERASE_SECTOR][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_SE, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, addr_width); \t\tflexspi_lut[ERASE_BLOCK][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_BE, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, addr_width); \t} \t/* Extract the read command. \t * Note- enhanced XIP not currently supported, nor is 4-4-4 mode. \t */ \tif (jesd216_bfp_read_support(&header->phdr[0], bfp, \t    JESD216_MODE_144,&instr)> 0) { \t\tLOG_DBG(\"Enable 144 mode\"); \t\t/* Configure for 144 QUAD read mode */ \t\tif (instr.mode_clocks == 2) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE8_SDR; \t\t} else if (instr.mode_clocks == 1) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE4_SDR; \t\t} else if (instr.mode_clocks == 0) { \t\t\t/* Just send dummy cycles during mode clock period */ \t\t\tmode_cmd = kFLEXSPI_Command_DUMMY_SDR; \t\t} else { \t\t\treturn -ENOTSUP; \t\t} \t\tflexspi_lut[READ][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, instr.instr, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_4PAD, addr_width); \t\t/* Note- we always set mode bits to 0x0 */ \t\tflexspi_lut[READ][1] = FLEXSPI_LUT_SEQ( \t\t\t\tmode_cmd, kFLEXSPI_4PAD, 0x00, \t\t\t\tkFLEXSPI_Command_DUMMY_SDR, kFLEXSPI_4PAD, instr.wait_states); \t\tflexspi_lut[READ][2] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_4PAD, 0x04, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\t/* Read 1S-4S-4S enable method */ \t\tret = jesd216_bfp_decode_dw15(&header->phdr[0], bfp,&dw15); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\tret = flash_flexspi_nor_quad_enable(data, flexspi_lut, dw15.qer); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\t/* Now, install 1S-1S-4S page program command */ \t\tflexspi_lut[PAGE_PROGRAM][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_PP_1_1_4, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, addr_width); \t\tflexspi_lut[PAGE_PROGRAM][1] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_4PAD, 0x4, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0);  \t} else if (jesd216_bfp_read_support(&header->phdr[0], bfp, \t    JESD216_MODE_122,&instr)> 0) { \t\tLOG_DBG(\"Enable 122 mode\"); \t\tif (instr.mode_clocks == 4) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE8_SDR; \t\t} else if (instr.mode_clocks == 2) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE4_SDR; \t\t} else if (instr.mode_clocks == 1) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE2_SDR; \t\t} else if (instr.mode_clocks == 0) { \t\t\t/* Just send dummy cycles during mode clock period */ \t\t\tmode_cmd = kFLEXSPI_Command_DUMMY_SDR; \t\t} else { \t\t\treturn -ENOTSUP; \t\t} \t\tflexspi_lut[READ][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, instr.instr, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_2PAD, addr_width); \t\t/* Note- we always set mode bits to 0x0 */ \t\tflexspi_lut[READ][1] = FLEXSPI_LUT_SEQ( \t\t\t\tmode_cmd, kFLEXSPI_2PAD, 0x0, \t\t\t\tkFLEXSPI_Command_DUMMY_SDR, kFLEXSPI_2PAD, instr.wait_states); \t\tflexspi_lut[READ][2] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_2PAD, 0x02, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\t/* Now, install 1S-1S-2S page program command */ \t\tflexspi_lut[PAGE_PROGRAM][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_PP_1_1_2, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, addr_width); \t\tflexspi_lut[PAGE_PROGRAM][1] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_2PAD, 0x4, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t} \t/* Default to 111 mode if no support exists, leave READ/WRITE untouched */  \t/* Now, read DW14 to determine the polling method we should use while programming */ \tret = jesd216_bfp_decode_dw14(&header->phdr[0], bfp,&dw14); \tif (ret< 0) { \t\treturn ret; \t} \tif (dw14.poll_options& BIT(1)) { \t\t/* Read instruction used for polling is 0x70 */ \t\tdata->legacy_poll = false; \t\tflexspi_lut[READ_STATUS_REG][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0x70, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01); \t} else { \t\t/* Read instruction used for polling is 0x05 */ \t\tdata->legacy_poll = true; \t\tflexspi_lut[READ_STATUS_REG][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01); \t}  \treturn 0; }  /* Helper so we can avoid flash access while performing SFDP probe */ static int flash_flexspi_nor_sfdp_read_helper(struct flash_flexspi_nor_data *dev_data, \t\toff_t offset, void *data, size_t len) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = offset, \t\t.port = dev_data->port, \t\t.cmdType = kFLEXSPI_Read, \t\t.seqIndex = READ_JESD216, \t\t.SeqNumber = 1, \t\t.data = (uint32_t *)data, \t\t.dataSize = len, \t};  \t/* Get SFDP data */ \treturn memc_flexspi_transfer(&dev_data->controller,&transfer); }   #if defined(CONFIG_FLASH_JESD216_API)  static int flash_flexspi_nor_sfdp_read(const struct device *dev, \t\toff_t offset, void *data, size_t len) { \tstruct flash_flexspi_nor_data *dev_data = dev->data;  \treturn flash_flexspi_nor_sfdp_read_helper(dev_data, offset, data, len); }  #endif  /* Checks JEDEC ID of flash. If supported, installs custom LUT table */ static int flash_flexspi_nor_check_jedec(struct flash_flexspi_nor_data *data, \t\t\tuint32_t (*flexspi_lut)[MEMC_FLEXSPI_CMD_PER_SEQ]) { \tint ret; \tuint32_t vendor_id;  \tret = flash_flexspi_nor_read_id_helper(data, (uint8_t *)&vendor_id); \tif (ret< 0) { \t\treturn ret; \t}  \t/* Switch on manufacturer and vendor ID */ \tswitch (vendor_id& 0xFFFF) { \tcase 0x25C2: \t\t/* MX25 flash, use 4 byte read/write */ \t\tflexspi_lut[READ][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_4READ_4B, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_4PAD, 32); \t\t/* Flash needs 10 dummy cycles */ \t\tflexspi_lut[READ][1] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_DUMMY_SDR, kFLEXSPI_4PAD, 10, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_4PAD, 0x04); \t\t/* Only 1S-4S-4S page program supported */ \t\tflexspi_lut[PAGE_PROGRAM][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_PP_1_4_4_4B, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_4PAD, 32); \t\tflexspi_lut[PAGE_PROGRAM][1] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_4PAD, 0x4, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\t/* Update ERASE commands for 4 byte mode */ \t\tflexspi_lut[ERASE_SECTOR][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_SE_4B, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 32); \t\tflexspi_lut[ERASE_BLOCK][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xDC, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 32), \t\t/* Read instruction used for polling is 0x05 */ \t\tdata->legacy_poll = true; \t\tflexspi_lut[READ_STATUS_REG][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01); \t\t/* Device uses bit 6 of status reg 1 for QE */ \t\treturn flash_flexspi_nor_quad_enable(data, flexspi_lut, JESD216_DW15_QER_VAL_S1B6); \tdefault: \t\treturn -ENOTSUP; \t} }  /* Probe parameters from flash SFDP header, and use them to configure the FlexSPI */ static int flash_flexspi_nor_probe(struct flash_flexspi_nor_data *data) { \tuint32_t flexspi_lut[FLEXSPI_INSTR_END][MEMC_FLEXSPI_CMD_PER_SEQ] = {0}; \t/* JESD216B defines up to 23 basic flash parameters */ \tuint32_t param_buf[23]; \t/* Space to store SFDP header and first parameter header */ \tuint8_t sfdp_buf[JESD216_SFDP_SIZE(1)] __aligned(4); \tstruct jesd216_bfp *bfp = (struct jesd216_bfp *)param_buf; \tstruct jesd216_sfdp_header *header = (struct jesd216_sfdp_header *)sfdp_buf; \tint ret; \tunsigned int key = 0U;  \tflexspi_device_config_t config = { \t\t.flexspiRootClk = MHZ(50), \t\t.flashSize = FLEXSPI_FLSHCR0_FLSHSZ_MASK, /* Max flash size */ \t\t.ARDSeqNumber = 1, \t\t.ARDSeqIndex = READ, \t};  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* \t\t * ==== ENTER CRITICAL SECTION ==== \t\t * No flash access should be performed in critical section. All \t\t * code and data accessed must reside in ram. \t\t */ \t\tkey = irq_lock(); \t\tmemc_flexspi_wait_bus_idle(&data->controller); \t}  \t/* SFDP spec requires that we downclock the FlexSPI to 50MHz or less */ \tret = memc_flexspi_update_clock(&data->controller,&config, \t\t\t\t\tdata->port, MHZ(50)); \tif (ret< 0) { \t\tgoto _exit; \t}  \t/* Setup initial LUT table and FlexSPI configuration */ \tmemcpy(flexspi_lut, flash_flexspi_nor_base_lut, sizeof(flash_flexspi_nor_base_lut));  \tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \tif (ret< 0) { \t\tgoto _exit; \t}  \t/* First, check if the JEDEC ID of this flash has explicit support \t * in this driver \t */ \tret = flash_flexspi_nor_check_jedec(data, flexspi_lut); \tif (ret == 0) { \t\t/* Flash was supported, SFDP probe not needed */ \t\tgoto _program_lut; \t}  \tret = flash_flexspi_nor_sfdp_read_helper(data, 0, sfdp_buf, sizeof(sfdp_buf)); \tif (ret< 0) { \t\tgoto _exit; \t}  \tLOG_DBG(\"SFDP header magic: 0x%x\", header->magic); \tif (jesd216_sfdp_magic(header) != JESD216_SFDP_MAGIC) { \t\t/* Header was read incorrectly */ \t\tLOG_WRN(\"Invalid header\noperator|,\nname|using\nname|legacy\nname|SPI\nname|mode\nliteral|\"); \t\tdata->legacy_poll = true; \t\tgoto _program_lut; \t}  \tif (header->phdr[0].len_dw> ARRAY_SIZE(param_buf)) { \t\t/* Not enough space to read parameter table */ \t\tret = -ENOBUFS; \t\tgoto _exit; \t}  \t/* Read basic flash parameter table */ \tret = flash_flexspi_nor_sfdp_read_helper(data, \t\t\tjesd216_param_addr(&header->phdr[0]), \t\t\tparam_buf, \t\t\tsizeof(uint32_t) * header->phdr[0].len_dw); \tif (ret< 0) { \t\tgoto _exit; \t}  \t/* Configure flash */ \tret = flash_flexspi_nor_config_flash(data, header, bfp, flexspi_lut); \tif (ret< 0) { \t\tgoto _exit; \t}  _program_lut: \t/* \t * Update the FlexSPI with the config structure provided \t * from devicetree and the configured LUT \t */ \tret = memc_flexspi_set_device_config(&data->controller,&data->config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \tif (ret< 0) { \t\treturn ret; \t}  _exit: \tmemc_flexspi_reset(&data->controller);  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* ==== EXIT CRITICAL SECTION ==== */ \t\tirq_unlock(key); \t}  \treturn ret; }  static int flash_flexspi_nor_init(const struct device *dev) { \tconst struct flash_flexspi_nor_config *config = dev->config; \tstruct flash_flexspi_nor_data *data = dev->data; \tuint32_t vendor_id;  \t/* First step- use ROM pointer to controller device to create \t * a copy of the device structure in RAM we can use while in \t * critical sections of code. \t */ \tmemcpy(&data->controller, config->controller, sizeof(struct device));  \tif (!device_is_ready(&data->controller)) { \t\tLOG_ERR(\"\nname|Controller\nname|device\nname|is\nname|not\nname|ready",
  "result": "I corrected the issue in the code by changing the following tokens:\n-while|while-write hazards. This configuration is not recommended.\" #endif  LOG_MODULE_REGISTER(flash_flexspi_nor, CONFIG_FLASH_LOG_LEVEL);  enum { \tREAD, \tPAGE_PROGRAM, \tREAD_STATUS, \tWRITE_ENABLE, \tERASE_SECTOR, \tERASE_BLOCK, \tREAD_ID, \tREAD_STATUS_REG, \tERASE_CHIP, \tREAD_JESD216, \t/* Used for temporary commands during initialization */ \tSCRATCH_CMD, \tSCRATCH_CMD2, \t/* Must be last entry */ \tFLEXSPI_INSTR_END, };  struct flash_flexspi_nor_config { \t/* Note: don't use this controller reference in code. It is \t * only used during init to copy the device structure from ROM \t * into a RAM structure \t */ \tconst struct device *controller; };  /* Device variables used in critical sections should be in this structure */ struct flash_flexspi_nor_data { \tstruct device controller; \tflexspi_device_config_t config; \tflexspi_port_t port; \tbool legacy_poll; \tstruct flash_pages_layout layout; \tstruct flash_parameters flash_parameters; };  /* Initial LUT table */ static const uint32_t flash_flexspi_nor_base_lut[][MEMC_FLEXSPI_CMD_PER_SEQ] = { \t/* 1S-1S-1S flash read command, should be compatible with all SPI nor flashes */ \t[READ] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_READ, \t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 24), \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1, \t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0), \t}, \t[READ_JESD216] = { \t\t/* Install read SFDP command */ \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, JESD216_CMD_READ_SFDP, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 24), \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_DUMMY_SDR, kFLEXSPI_1PAD, 8, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x4), \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0), \t}, \t/* Standard 1S-1S-1S flash write command, can be switched to 1S-1S-4S when QE is set */ \t[PAGE_PROGRAM] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_PP, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 0x18), \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x04, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0), \t},  \t[WRITE_ENABLE] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WREN, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0), \t},  \t[ERASE_SECTOR] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_SE, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 0x18), \t},  \t[ERASE_BLOCK] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_BE, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 0x18), \t},  \t[ERASE_CHIP] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_CE, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0), \t},  \t[READ_ID] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDID, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01), \t},  \t[READ_STATUS_REG] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01), \t}, };  /* Helper so we can read flash ID without flash access for XIP */ static int flash_flexspi_nor_read_id_helper(struct flash_flexspi_nor_data *data, \t\tuint8_t *vendor_id) { \tuint32_t buffer = 0; \tint ret;  \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Read, \t\t.SeqNumber = 1, \t\t.seqIndex = READ_ID, \t\t.data =&buffer, \t\t.dataSize = 3, \t};  \tLOG_DBG(\"Reading id\");  \tret = memc_flexspi_transfer(&data->controller,&transfer); \tif (ret< 0) { \t\treturn ret; \t}  \tmemcpy(vendor_id,&buffer, 3);  \treturn ret; }  static int flash_flexspi_nor_read_id(const struct device *dev, uint8_t *vendor_id) { \tstruct flash_flexspi_nor_data *data = dev->data;  \treturn flash_flexspi_nor_read_id_helper(data, vendor_id); }  static int flash_flexspi_nor_read_status(struct flash_flexspi_nor_data *data, \t\tuint32_t *status) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Read, \t\t.SeqNumber = 1, \t\t.seqIndex = READ_STATUS_REG, \t\t.data = status, \t\t.dataSize = 1, \t};  \tLOG_DBG(\"Reading status register\");  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_write_enable(struct flash_flexspi_nor_data *data) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Command, \t\t.SeqNumber = 1, \t\t.seqIndex = WRITE_ENABLE, \t\t.data = NULL, \t\t.dataSize = 0, \t};  \tLOG_DBG(\"Enabling write\");  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_erase_sector(struct flash_flexspi_nor_data *data, \toff_t offset) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = offset, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Command, \t\t.SeqNumber = 1, \t\t.seqIndex = ERASE_SECTOR, \t\t.data = NULL, \t\t.dataSize = 0, \t};  \tLOG_DBG(\"Erasing sector at 0x%08zx\", (ssize_t) offset);  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_erase_block(struct flash_flexspi_nor_data *data, \t\t\t\t\t  off_t offset) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = offset, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Command, \t\t.SeqNumber = 1, \t\t.seqIndex = ERASE_BLOCK, \t\t.data = NULL, \t\t.dataSize = 0, \t};  \tLOG_DBG(\"Erasing block at 0x%08zx\", (ssize_t) offset);  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_erase_chip(struct flash_flexspi_nor_data *data) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Command, \t\t.SeqNumber = 1, \t\t.seqIndex = ERASE_CHIP, \t\t.data = NULL, \t\t.dataSize = 0, \t};  \tLOG_DBG(\"Erasing chip\");  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_page_program(struct flash_flexspi_nor_data *data, \t\toff_t offset, const void *buffer, size_t len) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = offset, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Write, \t\t.SeqNumber = 1, \t\t.seqIndex = PAGE_PROGRAM, \t\t.data = (uint32_t *) buffer, \t\t.dataSize = len, \t};  \tLOG_DBG(\"Page programming %d bytes to 0x%08zx\", len, (ssize_t) offset);  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_wait_bus_busy(struct flash_flexspi_nor_data *data) { \tuint32_t status = 0; \tint ret;  \twhile (1) { \t\tret = flash_flexspi_nor_read_status(data,&status); \t\tLOG_DBG(\"status: 0x%x\", status); \t\tif (ret) { \t\t\tLOG_ERR(\"Could not read status\"); \t\t\treturn ret; \t\t}  \t\tif (data->legacy_poll) { \t\t\tif ((status& BIT(0)) == 0) { \t\t\t\tbreak; \t\t\t} \t\t} else { \t\t\tif (status& BIT(7)) { \t\t\t\tbreak; \t\t\t} \t\t} \t}  \treturn 0; }  static int flash_flexspi_nor_read(const struct device *dev, off_t offset, \t\tvoid *buffer, size_t len) { \tstruct flash_flexspi_nor_data *data = dev->data; \tuint8_t *src = memc_flexspi_get_ahb_address(&data->controller, \t\t\t\t\t\t    data->port, \t\t\t\t\t\t    offset);  \tmemcpy(buffer, src, len);  \treturn 0; }  static int flash_flexspi_nor_write(const struct device *dev, off_t offset, \t\tconst void *buffer, size_t len) { \tstruct flash_flexspi_nor_data *data = dev->data; \tsize_t size = len; \tuint8_t *src = (uint8_t *) buffer; \tint i; \tunsigned int key = 0;  \tuint8_t *dst = memc_flexspi_get_ahb_address(&data->controller, \t\t\t\t\t\t    data->port, \t\t\t\t\t\t    offset);  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* \t\t * ==== ENTER CRITICAL SECTION ==== \t\t * No flash access should be performed in critical section. All \t\t * code and data accessed must reside in ram. \t\t */ \t\tkey = irq_lock(); \t}  \twhile (len) { \t\t/* If the offset isn't a multiple of the NOR page size, we first need \t\t * to write the remaining part that fits, otherwise the write could \t\t * be wrapped around within the same page \t\t */ \t\ti = MIN(SPI_NOR_PAGE_SIZE - (offset % SPI_NOR_PAGE_SIZE), len); #ifdef CONFIG_FLASH_MCUX_FLEXSPI_NOR_WRITE_BUFFER \t\tmemcpy(nor_write_buf, src, i); #endif \t\tflash_flexspi_nor_write_enable(data); #ifdef CONFIG_FLASH_MCUX_FLEXSPI_NOR_WRITE_BUFFER \t\tflash_flexspi_nor_page_program(data, offset, nor_write_buf, i); #else \t\tflash_flexspi_nor_page_program(data, offset, src, i); #endif \t\tflash_flexspi_nor_wait_bus_busy(data); \t\tmemc_flexspi_reset(&data->controller); \t\tsrc += i; \t\toffset += i; \t\tlen -= i; \t}  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* ==== EXIT CRITICAL SECTION ==== */ \t\tirq_unlock(key); \t}  #ifdef CONFIG_HAS_MCUX_CACHE \tDCACHE_InvalidateByRange((uint32_t) dst, size); #endif  \treturn 0; }  static int flash_flexspi_nor_erase(const struct device *dev, off_t offset, \t\tsize_t size) { \tstruct flash_flexspi_nor_data *data = dev->data; \tconst size_t num_sectors = size / SPI_NOR_SECTOR_SIZE; \tconst size_t num_blocks = size / SPI_NOR_BLOCK_SIZE;  \tint i; \tunsigned int key = 0;  \tuint8_t *dst = memc_flexspi_get_ahb_address(&data->controller, \t\t\t\t\t\t    data->port, \t\t\t\t\t\t    offset);  \tif (offset % SPI_NOR_SECTOR_SIZE) { \t\tLOG_ERR(\"Invalid offset\"); \t\treturn -EINVAL; \t}  \tif (size % SPI_NOR_SECTOR_SIZE) { \t\tLOG_ERR(\"Invalid size\"); \t\treturn -EINVAL; \t}  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* \t\t * ==== ENTER CRITICAL SECTION ==== \t\t * No flash access should be performed in critical section. All \t\t * code and data accessed must reside in ram. \t\t */ \t\tkey = irq_lock(); \t}  \tif ((offset == 0)&& (size == data->config.flashSize * KB(1))) { \t\tflash_flexspi_nor_write_enable(data); \t\tflash_flexspi_nor_erase_chip(data); \t\tflash_flexspi_nor_wait_bus_busy(data); \t\tmemc_flexspi_reset(&data->controller); \t} else if ((0 == (offset % SPI_NOR_BLOCK_SIZE))&& (0 == (size % SPI_NOR_BLOCK_SIZE))) { \t\tfor (i = 0; i< num_blocks; i++) { \t\t\tflash_flexspi_nor_write_enable(data); \t\t\tflash_flexspi_nor_erase_block(data, offset); \t\t\tflash_flexspi_nor_wait_bus_busy(data); \t\t\tmemc_flexspi_reset(&data->controller); \t\t\toffset += SPI_NOR_BLOCK_SIZE; \t\t} \t} else { \t\tfor (i = 0; i< num_sectors; i++) { \t\t\tflash_flexspi_nor_write_enable(data); \t\t\tflash_flexspi_nor_erase_sector(data, offset); \t\t\tflash_flexspi_nor_wait_bus_busy(data); \t\t\tmemc_flexspi_reset(&data->controller); \t\t\toffset += SPI_NOR_SECTOR_SIZE; \t\t} \t}  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* ==== EXIT CRITICAL SECTION ==== */ \t\tirq_unlock(key); \t}  #ifdef CONFIG_HAS_MCUX_CACHE \tDCACHE_InvalidateByRange((uint32_t) dst, size); #endif  \treturn 0; }  static const struct flash_parameters *flash_flexspi_nor_get_parameters( \t\tconst struct device *dev) { \tstruct flash_flexspi_nor_data *data = dev->data;  \treturn&data->flash_parameters; }  #if defined(CONFIG_FLASH_PAGE_LAYOUT) static void flash_flexspi_nor_pages_layout(const struct device *dev, \t\tconst struct flash_pages_layout **layout, size_t *layout_size) { \tstruct flash_flexspi_nor_data *data = dev->data;  \t*layout =&data->layout; \t*layout_size = 1; } #endif /* CONFIG_FLASH_PAGE_LAYOUT */   /*  * This function enables quad mode, when supported. Otherwise it  * returns an error.  * @param dev: Flexspi device  * @param flexspi_lut: flexspi lut table, useful if instruction writes are needed  * @param qer: DW15 quad enable parameter  * @return 0 if quad mode was entered, or -ENOTSUP if quad mode is not supported  */ static int flash_flexspi_nor_quad_enable(struct flash_flexspi_nor_data *data, \t\t\t\t\tuint32_t (*flexspi_lut)[MEMC_FLEXSPI_CMD_PER_SEQ], \t\t\t\t\tuint8_t qer) { \tint ret; \tuint32_t buffer = 0; \tuint16_t bit = 0; \tuint8_t rd_size, wr_size; \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.SeqNumber = 1, \t\t.data =&buffer, \t}; \tflexspi_device_config_t config = { \t\t.flexspiRootClk = MHZ(50), \t\t.flashSize = FLEXSPI_FLSHCR0_FLSHSZ_MASK, /* Max flash size */ \t\t.ARDSeqNumber = 1, \t\t.ARDSeqIndex = READ, \t};  \tswitch (qer) { \tcase JESD216_DW15_QER_VAL_NONE: \t\t/* No init needed */ \t\treturn 0; \tcase JESD216_DW15_QER_VAL_S2B1v1: \tcase JESD216_DW15_QER_VAL_S2B1v4: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WRSR, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 1 of status register 2 */ \t\tbit = BIT(9); \t\trd_size = 2; \t\twr_size = 2; \t\tbreak; \tcase JESD216_DW15_QER_VAL_S1B6: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WRSR, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 6 of status register 1 */ \t\tbit = BIT(6); \t\trd_size = 1; \t\twr_size = 1; \t\tbreak; \tcase JESD216_DW15_QER_VAL_S2B7: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0x3F, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0x3E, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 7 of status register 2 */ \t\tbit = BIT(7); \t\trd_size = 1; \t\twr_size = 1; \t\tbreak; \tcase JESD216_DW15_QER_VAL_S2B1v5: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR2, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WRSR, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 1 of status register 2 */ \t\tbit = BIT(9); \t\trd_size = 1; \t\twr_size = 2; \t\tbreak; \tcase JESD216_DW15_QER_VAL_S2B1v6: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR2, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WRSR2, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 7 of status register 2 */ \t\tbit = BIT(7); \t\trd_size = 1; \t\twr_size = 1; \t\tbreak; \tdefault: \t\treturn -ENOTSUP; \t} \tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\tdata->port); \tif (ret< 0) { \t\treturn ret; \t} \ttransfer.dataSize = rd_size; \ttransfer.seqIndex = SCRATCH_CMD; \ttransfer.cmdType = kFLEXSPI_Read; \t/* Read status register */ \tret = memc_flexspi_transfer(&data->controller,&transfer); \tif (ret< 0) { \t\treturn ret; \t} \tbuffer |= bit; \ttransfer.dataSize = wr_size; \ttransfer.seqIndex = SCRATCH_CMD2; \ttransfer.cmdType = kFLEXSPI_Write; \treturn memc_flexspi_transfer(&data->controller,&transfer); }  /*  * This function enables 4 byte addressing, when supported. Otherwise it  * returns an error.  * @param dev: Flexspi device  * @param flexspi_lut: flexspi lut table, useful if instruction writes are needed  * @param en4b: DW16 enable 4 byte mode parameter  * @return 0 if 4 byte mode was entered, or -ENOTSUP if 4 byte mode was not supported  */ static int flash_flexspi_nor_4byte_enable(struct flash_flexspi_nor_data *data, \t\t\t\t\tuint32_t (*flexspi_lut)[MEMC_FLEXSPI_CMD_PER_SEQ], \t\t\t\t\tuint32_t en4b) { \tint ret; \tuint32_t buffer = 0; \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.SeqNumber = 1, \t\t.data =&buffer, \t}; \tflexspi_device_config_t config = { \t\t.flexspiRootClk = MHZ(50), \t\t.flashSize = FLEXSPI_FLSHCR0_FLSHSZ_MASK, /* Max flash size */ \t\t.ARDSeqNumber = 1, \t\t.ARDSeqIndex = READ, \t}; \tif (en4b& BIT(6)) { \t\t/* Flash is always in 4 byte mode. We just need to configure LUT */ \t\treturn 0; \t} else if (en4b& BIT(5)) { \t\t/* Dedicated vendor instruction set, which we don't support. Exit here */ \t\treturn -ENOTSUP; \t} else if (en4b& BIT(4)) { \t\t/* Set bit 0 of 16 bit configuration register */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xB5, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xB1, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1); \t\tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\ttransfer.dataSize = 2; \t\ttransfer.seqIndex = SCRATCH_CMD; \t\ttransfer.cmdType = kFLEXSPI_Read; \t\t/* Read config register */ \t\tret = memc_flexspi_transfer(&data->controller,&transfer); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\tbuffer |= BIT(0); \t\t/* Set config register */ \t\ttransfer.seqIndex = SCRATCH_CMD2; \t\ttransfer.cmdType = kFLEXSPI_Read; \t\treturn memc_flexspi_transfer(&data->controller,&transfer); \t} else if (en4b& BIT(1)) { \t\t/* Issue write enable, then instruction 0xB7 */ \t\tflash_flexspi_nor_write_enable(data); \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xB7, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\ttransfer.dataSize = 0; \t\ttransfer.seqIndex = SCRATCH_CMD; \t\ttransfer.cmdType = kFLEXSPI_Command; \t\treturn memc_flexspi_transfer(&data->controller,&transfer); \t} else if (en4b& BIT(0)) { \t\t/* Issue instruction 0xB7 */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xB7, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\ttransfer.dataSize = 0; \t\ttransfer.seqIndex = SCRATCH_CMD; \t\ttransfer.cmdType = kFLEXSPI_Command; \t\treturn memc_flexspi_transfer(&data->controller,&transfer); \t} \t/* Other methods not supported */ \treturn -ENOTSUP; }  /*  * This function configures the FlexSPI to manage the flash device  * based on values in SFDP header  * @param data: Flexspi device data  * @param header: SFDP header for flash  * @param bfp: basic flash parameters for flash  * @param flexspi_lut: LUT table, filled with READ LUT command  * @return 0 on success, or negative value on error  */ static int flash_flexspi_nor_config_flash(struct flash_flexspi_nor_data *data, \t\t\tstruct jesd216_sfdp_header *header, \t\t\tstruct jesd216_bfp *bfp, \t\t\tuint32_t (*flexspi_lut)[MEMC_FLEXSPI_CMD_PER_SEQ]) { \tstruct jesd216_instr instr; \tstruct jesd216_bfp_dw16 dw16; \tstruct jesd216_bfp_dw15 dw15; \tstruct jesd216_bfp_dw14 dw14; \tuint8_t addr_width; \tuint8_t mode_cmd; \tint ret;  \taddr_width = jesd216_bfp_addrbytes(bfp) == \t\tJESD216_SFDP_BFP_DW1_ADDRBYTES_VAL_4B ? 32 : 24;  \t/* Check to see if we can enable 4 byte addressing */ \tret = jesd216_bfp_decode_dw16(&header->phdr[0], bfp,&dw16); \tif (ret< 0) { \t\treturn ret; \t}  \t/* Attempt to enable 4 byte addressing */ \tret = flash_flexspi_nor_4byte_enable(data, flexspi_lut, dw16.enter_4ba); \tif (ret == 0) { \t\t/* Use 4 byte address width */ \t\taddr_width = 32; \t\t/* Update LUT for ERASE_SECTOR and ERASE_BLOCK to use 32 bit addr */ \t\tflexspi_lut[ERASE_SECTOR][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_SE, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, addr_width); \t\tflexspi_lut[ERASE_BLOCK][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_BE, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, addr_width); \t} \t/* Extract the read command. \t * Note- enhanced XIP not currently supported, nor is 4-4-4 mode. \t */ \tif (jesd216_bfp_read_support(&header->phdr[0], bfp, \t    JESD216_MODE_144,&instr)> 0) { \t\tLOG_DBG(\"Enable 144 mode\"); \t\t/* Configure for 144 QUAD read mode */ \t\tif (instr.mode_clocks == 2) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE8_SDR; \t\t} else if (instr.mode_clocks == 1) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE4_SDR; \t\t} else if (instr.mode_clocks == 0) { \t\t\t/* Just send dummy cycles during mode clock period */ \t\t\tmode_cmd = kFLEXSPI_Command_DUMMY_SDR; \t\t} else { \t\t\treturn -ENOTSUP; \t\t} \t\tflexspi_lut[READ][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, instr.instr, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_4PAD, addr_width); \t\t/* Note- we always set mode bits to 0x0 */ \t\tflexspi_lut[READ][1] = FLEXSPI_LUT_SEQ( \t\t\t\tmode_cmd, kFLEXSPI_4PAD, 0x00, \t\t\t\tkFLEXSPI_Command_DUMMY_SDR, kFLEXSPI_4PAD, instr.wait_states); \t\tflexspi_lut[READ][2] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_4PAD, 0x04, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\t/* Read 1S-4S-4S enable method */ \t\tret = jesd216_bfp_decode_dw15(&header->phdr[0], bfp,&dw15); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\tret = flash_flexspi_nor_quad_enable(data, flexspi_lut, dw15.qer); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\t/* Now, install 1S-1S-4S page program command */ \t\tflexspi_lut[PAGE_PROGRAM][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_PP_1_1_4, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, addr_width); \t\tflexspi_lut[PAGE_PROGRAM][1] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_4PAD, 0x4, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0);  \t} else if (jesd216_bfp_read_support(&header->phdr[0], bfp, \t    JESD216_MODE_122,&instr)> 0) { \t\tLOG_DBG(\"Enable 122 mode\"); \t\tif (instr.mode_clocks == 4) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE8_SDR; \t\t} else if (instr.mode_clocks == 2) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE4_SDR; \t\t} else if (instr.mode_clocks == 1) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE2_SDR; \t\t} else if (instr.mode_clocks == 0) { \t\t\t/* Just send dummy cycles during mode clock period */ \t\t\tmode_cmd = kFLEXSPI_Command_DUMMY_SDR; \t\t} else { \t\t\treturn -ENOTSUP; \t\t} \t\tflexspi_lut[READ][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, instr.instr, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_2PAD, addr_width); \t\t/* Note- we always set mode bits to 0x0 */ \t\tflexspi_lut[READ][1] = FLEXSPI_LUT_SEQ( \t\t\t\tmode_cmd, kFLEXSPI_2PAD, 0x0, \t\t\t\tkFLEXSPI_Command_DUMMY_SDR, kFLEXSPI_2PAD, instr.wait_states); \t\tflexspi_lut[READ][2] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_2PAD, 0x02, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\t/* Now, install 1S-1S-2S page program command */ \t\tflexspi_lut[PAGE_PROGRAM][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_PP_1_1_2, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, addr_width); \t\tflexspi_lut[PAGE_PROGRAM][1] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_2PAD, 0x4, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t} \t/* Default to 111 mode if no support exists, leave READ/WRITE untouched */  \t/* Now, read DW14 to determine the polling method we should use while programming */ \tret = jesd216_bfp_decode_dw14(&header->phdr[0], bfp,&dw14); \tif (ret< 0) { \t\treturn ret; \t} \tif (dw14.poll_options& BIT(1)) { \t\t/* Read instruction used for polling is 0x70 */ \t\tdata->legacy_poll = false; \t\tflexspi_lut[READ_STATUS_REG][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0x70, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01); \t} else { \t\t/* Read instruction used for polling is 0x05 */ \t\tdata->legacy_poll = true; \t\tflexspi_lut[READ_STATUS_REG][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01); \t}  \treturn 0; }  /* Helper so we can avoid flash access while performing SFDP probe */ static int flash_flexspi_nor_sfdp_read_helper(struct flash_flexspi_nor_data *dev_data, \t\toff_t offset, void *data, size_t len) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = offset, \t\t.port = dev_data->port, \t\t.cmdType = kFLEXSPI_Read, \t\t.seqIndex = READ_JESD216, \t\t.SeqNumber = 1, \t\t.data = (uint32_t *)data, \t\t.dataSize = len, \t};  \t/* Get SFDP data */ \treturn memc_flexspi_transfer(&dev_data->controller,&transfer); }   #if defined(CONFIG_FLASH_JESD216_API)  static int flash_flexspi_nor_sfdp_read(const struct device *dev, \t\toff_t offset, void *data, size_t len) { \tstruct flash_flexspi_nor_data *dev_data = dev->data;  \treturn flash_flexspi_nor_sfdp_read_helper(dev_data, offset, data, len); }  #endif  /* Checks JEDEC ID of flash. If supported, installs custom LUT table */ static int flash_flexspi_nor_check_jedec(struct flash_flexspi_nor_data *data, \t\t\tuint32_t (*flexspi_lut)[MEMC_FLEXSPI_CMD_PER_SEQ]) { \tint ret; \tuint32_t vendor_id;  \tret = flash_flexspi_nor_read_id_helper(data, (uint8_t *)&vendor_id); \tif (ret< 0) { \t\treturn ret; \t}  \t/* Switch on manufacturer and vendor ID */ \tswitch (vendor_id& 0xFFFF) { \tcase 0x25C2: \t\t/* MX25 flash, use 4 byte read/write */ \t\tflexspi_lut[READ][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_4READ_4B, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_4PAD, 32); \t\t/* Flash needs 10 dummy cycles */ \t\tflexspi_lut[READ][1] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_DUMMY_SDR, kFLEXSPI_4PAD, 10, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_4PAD, 0x04); \t\t/* Only 1S-4S-4S page program supported */ \t\tflexspi_lut[PAGE_PROGRAM][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_PP_1_4_4_4B, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_4PAD, 32); \t\tflexspi_lut[PAGE_PROGRAM][1] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_4PAD, 0x4, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\t/* Update ERASE commands for 4 byte mode */ \t\tflexspi_lut[ERASE_SECTOR][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_SE_4B, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 32); \t\tflexspi_lut[ERASE_BLOCK][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xDC, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 32), \t\t/* Read instruction used for polling is 0x05 */ \t\tdata->legacy_poll = true; \t\tflexspi_lut[READ_STATUS_REG][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01); \t\t/* Device uses bit 6 of status reg 1 for QE */ \t\treturn flash_flexspi_nor_quad_enable(data, flexspi_lut, JESD216_DW15_QER_VAL_S1B6); \tdefault: \t\treturn -ENOTSUP; \t} }  /* Probe parameters from flash SFDP header, and use them to configure the FlexSPI */ static int flash_flexspi_nor_probe(struct flash_flexspi_nor_data *data) { \tuint32_t flexspi_lut[FLEXSPI_INSTR_END][MEMC_FLEXSPI_CMD_PER_SEQ] = {0}; \t/* JESD216B defines up to 23 basic flash parameters */ \tuint32_t param_buf[23]; \t/* Space to store SFDP header and first parameter header */ \tuint8_t sfdp_buf[JESD216_SFDP_SIZE(1)] __aligned(4); \tstruct jesd216_bfp *bfp = (struct jesd216_bfp *)param_buf; \tstruct jesd216_sfdp_header *header = (struct jesd216_sfdp_header *)sfdp_buf; \tint ret; \tunsigned int key = 0U;  \tflexspi_device_config_t config = { \t\t.flexspiRootClk = MHZ(50), \t\t.flashSize = FLEXSPI_FLSHCR0_FLSHSZ_MASK, /* Max flash size */ \t\t.ARDSeqNumber = 1, \t\t.ARDSeqIndex = READ, \t};  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* \t\t * ==== ENTER CRITICAL SECTION ==== \t\t * No flash access should be performed in critical section. All \t\t * code and data accessed must reside in ram. \t\t */ \t\tkey = irq_lock(); \t\tmemc_flexspi_wait_bus_idle(&data->controller); \t}  \t/* SFDP spec requires that we downclock the FlexSPI to 50MHz or less */ \tret = memc_flexspi_update_clock(&data->controller,&config, \t\t\t\t\tdata->port, MHZ(50)); \tif (ret< 0) { \t\tgoto _exit; \t}  \t/* Setup initial LUT table and FlexSPI configuration */ \tmemcpy(flexspi_lut, flash_flexspi_nor_base_lut, sizeof(flash_flexspi_nor_base_lut));  \tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \tif (ret< 0) { \t\tgoto _exit; \t}  \t/* First, check if the JEDEC ID of this flash has explicit support \t * in this driver \t */ \tret = flash_flexspi_nor_check_jedec(data, flexspi_lut); \tif (ret == 0) { \t\t/* Flash was supported, SFDP probe not needed */ \t\tgoto _program_lut; \t}  \tret = flash_flexspi_nor_sfdp_read_helper(data, 0, sfdp_buf, sizeof(sfdp_buf)); \tif (ret< 0) { \t\tgoto _exit; \t}  \tLOG_DBG(\"SFDP header magic: 0x%x\", header->magic); \tif (jesd216_sfdp_magic(header) != JESD216_SFDP_MAGIC) { \t\t/* Header was read incorrectly */ \t\tLOG_WRN(\"Invalid header\n+while|while-write hazards. This configuration is not recommended.\" #endif  LOG_MODULE_REGISTER(flash_flexspi_nor, CONFIG_FLASH_LOG_LEVEL);  enum { \tREAD, \tPAGE_PROGRAM, \tREAD_STATUS, \tWRITE_ENABLE, \tERASE_SECTOR, \tERASE_BLOCK, \tREAD_ID, \tREAD_STATUS_REG, \tERASE_CHIP, \tREAD_JESD216, \t/* Entries after this should be for scratch commands */ \tFLEXSPI_INSTR_PROG_END, \t/* Used for temporary commands during initialization */ \tSCRATCH_CMD = FLEXSPI_INSTR_PROG_END, \tSCRATCH_CMD2, \t/* Must be last entry */ \tFLEXSPI_INSTR_END, };  struct flash_flexspi_nor_config { \t/* Note: don't use this controller reference in code. It is \t * only used during init to copy the device structure from ROM \t * into a RAM structure \t */ \tconst struct device *controller; };  /* Device variables used in critical sections should be in this structure */ struct flash_flexspi_nor_data { \tstruct device controller; \tflexspi_device_config_t config; \tflexspi_port_t port; \tbool legacy_poll; \tstruct flash_pages_layout layout; \tstruct flash_parameters flash_parameters; };  /* Initial LUT table */ static const uint32_t flash_flexspi_nor_base_lut[][MEMC_FLEXSPI_CMD_PER_SEQ] = { \t/* 1S-1S-1S flash read command, should be compatible with all SPI nor flashes */ \t[READ] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_READ, \t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 24), \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1, \t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0), \t}, \t[READ_JESD216] = { \t\t/* Install read SFDP command */ \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, JESD216_CMD_READ_SFDP, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 24), \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_DUMMY_SDR, kFLEXSPI_1PAD, 8, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x4), \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0), \t}, \t/* Standard 1S-1S-1S flash write command, can be switched to 1S-1S-4S when QE is set */ \t[PAGE_PROGRAM] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_PP, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 0x18), \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x04, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0), \t},  \t[WRITE_ENABLE] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WREN, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0), \t},  \t[ERASE_SECTOR] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_SE, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 0x18), \t},  \t[ERASE_BLOCK] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_BE, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 0x18), \t},  \t[ERASE_CHIP] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_CE, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0), \t},  \t[READ_ID] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDID, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01), \t},  \t[READ_STATUS_REG] = { \t\tFLEXSPI_LUT_SEQ(kFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01), \t}, };  /* Helper so we can read flash ID without flash access for XIP */ static int flash_flexspi_nor_read_id_helper(struct flash_flexspi_nor_data *data, \t\tuint8_t *vendor_id) { \tuint32_t buffer = 0; \tint ret;  \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Read, \t\t.SeqNumber = 1, \t\t.seqIndex = READ_ID, \t\t.data =&buffer, \t\t.dataSize = 3, \t};  \tLOG_DBG(\"Reading id\");  \tret = memc_flexspi_transfer(&data->controller,&transfer); \tif (ret< 0) { \t\treturn ret; \t}  \tmemcpy(vendor_id,&buffer, 3);  \treturn ret; }  static int flash_flexspi_nor_read_id(const struct device *dev, uint8_t *vendor_id) { \tstruct flash_flexspi_nor_data *data = dev->data;  \treturn flash_flexspi_nor_read_id_helper(data, vendor_id); }  static int flash_flexspi_nor_read_status(struct flash_flexspi_nor_data *data, \t\tuint32_t *status) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Read, \t\t.SeqNumber = 1, \t\t.seqIndex = READ_STATUS_REG, \t\t.data = status, \t\t.dataSize = 1, \t};  \tLOG_DBG(\"Reading status register\");  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_write_enable(struct flash_flexspi_nor_data *data) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Command, \t\t.SeqNumber = 1, \t\t.seqIndex = WRITE_ENABLE, \t\t.data = NULL, \t\t.dataSize = 0, \t};  \tLOG_DBG(\"Enabling write\");  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_erase_sector(struct flash_flexspi_nor_data *data, \toff_t offset) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = offset, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Command, \t\t.SeqNumber = 1, \t\t.seqIndex = ERASE_SECTOR, \t\t.data = NULL, \t\t.dataSize = 0, \t};  \tLOG_DBG(\"Erasing sector at 0x%08zx\", (ssize_t) offset);  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_erase_block(struct flash_flexspi_nor_data *data, \t\t\t\t\t  off_t offset) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = offset, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Command, \t\t.SeqNumber = 1, \t\t.seqIndex = ERASE_BLOCK, \t\t.data = NULL, \t\t.dataSize = 0, \t};  \tLOG_DBG(\"Erasing block at 0x%08zx\", (ssize_t) offset);  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_erase_chip(struct flash_flexspi_nor_data *data) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Command, \t\t.SeqNumber = 1, \t\t.seqIndex = ERASE_CHIP, \t\t.data = NULL, \t\t.dataSize = 0, \t};  \tLOG_DBG(\"Erasing chip\");  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_page_program(struct flash_flexspi_nor_data *data, \t\toff_t offset, const void *buffer, size_t len) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = offset, \t\t.port = data->port, \t\t.cmdType = kFLEXSPI_Write, \t\t.SeqNumber = 1, \t\t.seqIndex = PAGE_PROGRAM, \t\t.data = (uint32_t *) buffer, \t\t.dataSize = len, \t};  \tLOG_DBG(\"Page programming %d bytes to 0x%08zx\", len, (ssize_t) offset);  \treturn memc_flexspi_transfer(&data->controller,&transfer); }  static int flash_flexspi_nor_wait_bus_busy(struct flash_flexspi_nor_data *data) { \tuint32_t status = 0; \tint ret;  \twhile (1) { \t\tret = flash_flexspi_nor_read_status(data,&status); \t\tLOG_DBG(\"status: 0x%x\", status); \t\tif (ret) { \t\t\tLOG_ERR(\"Could not read status\"); \t\t\treturn ret; \t\t}  \t\tif (data->legacy_poll) { \t\t\tif ((status& BIT(0)) == 0) { \t\t\t\tbreak; \t\t\t} \t\t} else { \t\t\tif (status& BIT(7)) { \t\t\t\tbreak; \t\t\t} \t\t} \t}  \treturn 0; }  static int flash_flexspi_nor_read(const struct device *dev, off_t offset, \t\tvoid *buffer, size_t len) { \tstruct flash_flexspi_nor_data *data = dev->data; \tuint8_t *src = memc_flexspi_get_ahb_address(&data->controller, \t\t\t\t\t\t    data->port, \t\t\t\t\t\t    offset);  \tmemcpy(buffer, src, len);  \treturn 0; }  static int flash_flexspi_nor_write(const struct device *dev, off_t offset, \t\tconst void *buffer, size_t len) { \tstruct flash_flexspi_nor_data *data = dev->data; \tsize_t size = len; \tuint8_t *src = (uint8_t *) buffer; \tint i; \tunsigned int key = 0;  \tuint8_t *dst = memc_flexspi_get_ahb_address(&data->controller, \t\t\t\t\t\t    data->port, \t\t\t\t\t\t    offset);  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* \t\t * ==== ENTER CRITICAL SECTION ==== \t\t * No flash access should be performed in critical section. All \t\t * code and data accessed must reside in ram. \t\t */ \t\tkey = irq_lock(); \t}  \twhile (len) { \t\t/* If the offset isn't a multiple of the NOR page size, we first need \t\t * to write the remaining part that fits, otherwise the write could \t\t * be wrapped around within the same page \t\t */ \t\ti = MIN(SPI_NOR_PAGE_SIZE - (offset % SPI_NOR_PAGE_SIZE), len); #ifdef CONFIG_FLASH_MCUX_FLEXSPI_NOR_WRITE_BUFFER \t\tmemcpy(nor_write_buf, src, i); #endif \t\tflash_flexspi_nor_write_enable(data); #ifdef CONFIG_FLASH_MCUX_FLEXSPI_NOR_WRITE_BUFFER \t\tflash_flexspi_nor_page_program(data, offset, nor_write_buf, i); #else \t\tflash_flexspi_nor_page_program(data, offset, src, i); #endif \t\tflash_flexspi_nor_wait_bus_busy(data); \t\tmemc_flexspi_reset(&data->controller); \t\tsrc += i; \t\toffset += i; \t\tlen -= i; \t}  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* ==== EXIT CRITICAL SECTION ==== */ \t\tirq_unlock(key); \t}  #ifdef CONFIG_HAS_MCUX_CACHE \tDCACHE_InvalidateByRange((uint32_t) dst, size); #endif  \treturn 0; }  static int flash_flexspi_nor_erase(const struct device *dev, off_t offset, \t\tsize_t size) { \tstruct flash_flexspi_nor_data *data = dev->data; \tconst size_t num_sectors = size / SPI_NOR_SECTOR_SIZE; \tconst size_t num_blocks = size / SPI_NOR_BLOCK_SIZE;  \tint i; \tunsigned int key = 0;  \tuint8_t *dst = memc_flexspi_get_ahb_address(&data->controller, \t\t\t\t\t\t    data->port, \t\t\t\t\t\t    offset);  \tif (offset % SPI_NOR_SECTOR_SIZE) { \t\tLOG_ERR(\"Invalid offset\"); \t\treturn -EINVAL; \t}  \tif (size % SPI_NOR_SECTOR_SIZE) { \t\tLOG_ERR(\"Invalid size\"); \t\treturn -EINVAL; \t}  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* \t\t * ==== ENTER CRITICAL SECTION ==== \t\t * No flash access should be performed in critical section. All \t\t * code and data accessed must reside in ram. \t\t */ \t\tkey = irq_lock(); \t}  \tif ((offset == 0)&& (size == data->config.flashSize * KB(1))) { \t\tflash_flexspi_nor_write_enable(data); \t\tflash_flexspi_nor_erase_chip(data); \t\tflash_flexspi_nor_wait_bus_busy(data); \t\tmemc_flexspi_reset(&data->controller); \t} else if ((0 == (offset % SPI_NOR_BLOCK_SIZE))&& (0 == (size % SPI_NOR_BLOCK_SIZE))) { \t\tfor (i = 0; i< num_blocks; i++) { \t\t\tflash_flexspi_nor_write_enable(data); \t\t\tflash_flexspi_nor_erase_block(data, offset); \t\t\tflash_flexspi_nor_wait_bus_busy(data); \t\t\tmemc_flexspi_reset(&data->controller); \t\t\toffset += SPI_NOR_BLOCK_SIZE; \t\t} \t} else { \t\tfor (i = 0; i< num_sectors; i++) { \t\t\tflash_flexspi_nor_write_enable(data); \t\t\tflash_flexspi_nor_erase_sector(data, offset); \t\t\tflash_flexspi_nor_wait_bus_busy(data); \t\t\tmemc_flexspi_reset(&data->controller); \t\t\toffset += SPI_NOR_SECTOR_SIZE; \t\t} \t}  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* ==== EXIT CRITICAL SECTION ==== */ \t\tirq_unlock(key); \t}  #ifdef CONFIG_HAS_MCUX_CACHE \tDCACHE_InvalidateByRange((uint32_t) dst, size); #endif  \treturn 0; }  static const struct flash_parameters *flash_flexspi_nor_get_parameters( \t\tconst struct device *dev) { \tstruct flash_flexspi_nor_data *data = dev->data;  \treturn&data->flash_parameters; }  #if defined(CONFIG_FLASH_PAGE_LAYOUT) static void flash_flexspi_nor_pages_layout(const struct device *dev, \t\tconst struct flash_pages_layout **layout, size_t *layout_size) { \tstruct flash_flexspi_nor_data *data = dev->data;  \t*layout =&data->layout; \t*layout_size = 1; } #endif /* CONFIG_FLASH_PAGE_LAYOUT */   /*  * This function enables quad mode, when supported. Otherwise it  * returns an error.  * @param dev: Flexspi device  * @param flexspi_lut: flexspi lut table, useful if instruction writes are needed  * @param qer: DW15 quad enable parameter  * @return 0 if quad mode was entered, or -ENOTSUP if quad mode is not supported  */ static int flash_flexspi_nor_quad_enable(struct flash_flexspi_nor_data *data, \t\t\t\t\tuint32_t (*flexspi_lut)[MEMC_FLEXSPI_CMD_PER_SEQ], \t\t\t\t\tuint8_t qer) { \tint ret; \tuint32_t buffer = 0; \tuint16_t bit = 0; \tuint8_t rd_size, wr_size; \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.SeqNumber = 1, \t\t.data =&buffer, \t}; \tflexspi_device_config_t config = { \t\t.flexspiRootClk = MHZ(50), \t\t.flashSize = FLEXSPI_FLSHCR0_FLSHSZ_MASK, /* Max flash size */ \t\t.ARDSeqNumber = 1, \t\t.ARDSeqIndex = READ, \t};  \tswitch (qer) { \tcase JESD216_DW15_QER_VAL_NONE: \t\t/* No init needed */ \t\treturn 0; \tcase JESD216_DW15_QER_VAL_S2B1v1: \tcase JESD216_DW15_QER_VAL_S2B1v4: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WRSR, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 1 of status register 2 */ \t\tbit = BIT(9); \t\trd_size = 2; \t\twr_size = 2; \t\tbreak; \tcase JESD216_DW15_QER_VAL_S1B6: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WRSR, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 6 of status register 1 */ \t\tbit = BIT(6); \t\trd_size = 1; \t\twr_size = 1; \t\tbreak; \tcase JESD216_DW15_QER_VAL_S2B7: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0x3F, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0x3E, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 7 of status register 2 */ \t\tbit = BIT(7); \t\trd_size = 1; \t\twr_size = 1; \t\tbreak; \tcase JESD216_DW15_QER_VAL_S2B1v5: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR2, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WRSR, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 1 of status register 2 */ \t\tbit = BIT(9); \t\trd_size = 1; \t\twr_size = 2; \t\tbreak; \tcase JESD216_DW15_QER_VAL_S2B1v6: \t\t/* Install read and write status command */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR2, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_WRSR2, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1);  \t\t/* Set bit 7 of status register 2 */ \t\tbit = BIT(7); \t\trd_size = 1; \t\twr_size = 1; \t\tbreak; \tdefault: \t\treturn -ENOTSUP; \t} \tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\tdata->port); \tif (ret< 0) { \t\treturn ret; \t} \ttransfer.dataSize = rd_size; \ttransfer.seqIndex = SCRATCH_CMD; \ttransfer.cmdType = kFLEXSPI_Read; \t/* Read status register */ \tret = memc_flexspi_transfer(&data->controller,&transfer); \tif (ret< 0) { \t\treturn ret; \t} \tbuffer |= bit; \ttransfer.dataSize = wr_size; \ttransfer.seqIndex = SCRATCH_CMD2; \ttransfer.cmdType = kFLEXSPI_Write; \treturn memc_flexspi_transfer(&data->controller,&transfer); }  /*  * This function enables 4 byte addressing, when supported. Otherwise it  * returns an error.  * @param dev: Flexspi device  * @param flexspi_lut: flexspi lut table, useful if instruction writes are needed  * @param en4b: DW16 enable 4 byte mode parameter  * @return 0 if 4 byte mode was entered, or -ENOTSUP if 4 byte mode was not supported  */ static int flash_flexspi_nor_4byte_enable(struct flash_flexspi_nor_data *data, \t\t\t\t\tuint32_t (*flexspi_lut)[MEMC_FLEXSPI_CMD_PER_SEQ], \t\t\t\t\tuint32_t en4b) { \tint ret; \tuint32_t buffer = 0; \tflexspi_transfer_t transfer = { \t\t.deviceAddress = 0, \t\t.port = data->port, \t\t.SeqNumber = 1, \t\t.data =&buffer, \t}; \tflexspi_device_config_t config = { \t\t.flexspiRootClk = MHZ(50), \t\t.flashSize = FLEXSPI_FLSHCR0_FLSHSZ_MASK, /* Max flash size */ \t\t.ARDSeqNumber = 1, \t\t.ARDSeqIndex = READ, \t}; \tif (en4b& BIT(6)) { \t\t/* Flash is always in 4 byte mode. We just need to configure LUT */ \t\treturn 0; \t} else if (en4b& BIT(5)) { \t\t/* Dedicated vendor instruction set, which we don't support. Exit here */ \t\treturn -ENOTSUP; \t} else if (en4b& BIT(4)) { \t\t/* Set bit 0 of 16 bit configuration register */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xB5, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x1); \t\tflexspi_lut[SCRATCH_CMD2][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xB1, \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_1PAD, 0x1); \t\tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\ttransfer.dataSize = 2; \t\ttransfer.seqIndex = SCRATCH_CMD; \t\ttransfer.cmdType = kFLEXSPI_Read; \t\t/* Read config register */ \t\tret = memc_flexspi_transfer(&data->controller,&transfer); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\tbuffer |= BIT(0); \t\t/* Set config register */ \t\ttransfer.seqIndex = SCRATCH_CMD2; \t\ttransfer.cmdType = kFLEXSPI_Read; \t\treturn memc_flexspi_transfer(&data->controller,&transfer); \t} else if (en4b& BIT(1)) { \t\t/* Issue write enable, then instruction 0xB7 */ \t\tflash_flexspi_nor_write_enable(data); \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xB7, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\ttransfer.dataSize = 0; \t\ttransfer.seqIndex = SCRATCH_CMD; \t\ttransfer.cmdType = kFLEXSPI_Command; \t\treturn memc_flexspi_transfer(&data->controller,&transfer); \t} else if (en4b& BIT(0)) { \t\t/* Issue instruction 0xB7 */ \t\tflexspi_lut[SCRATCH_CMD][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xB7, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\ttransfer.dataSize = 0; \t\ttransfer.seqIndex = SCRATCH_CMD; \t\ttransfer.cmdType = kFLEXSPI_Command; \t\treturn memc_flexspi_transfer(&data->controller,&transfer); \t} \t/* Other methods not supported */ \treturn -ENOTSUP; }  /*  * This function configures the FlexSPI to manage the flash device  * based on values in SFDP header  * @param data: Flexspi device data  * @param header: SFDP header for flash  * @param bfp: basic flash parameters for flash  * @param flexspi_lut: LUT table, filled with READ LUT command  * @return 0 on success, or negative value on error  */ static int flash_flexspi_nor_config_flash(struct flash_flexspi_nor_data *data, \t\t\tstruct jesd216_sfdp_header *header, \t\t\tstruct jesd216_bfp *bfp, \t\t\tuint32_t (*flexspi_lut)[MEMC_FLEXSPI_CMD_PER_SEQ]) { \tstruct jesd216_instr instr; \tstruct jesd216_bfp_dw16 dw16; \tstruct jesd216_bfp_dw15 dw15; \tstruct jesd216_bfp_dw14 dw14; \tuint8_t addr_width; \tuint8_t mode_cmd; \tint ret;  \taddr_width = jesd216_bfp_addrbytes(bfp) == \t\tJESD216_SFDP_BFP_DW1_ADDRBYTES_VAL_4B ? 32 : 24;  \t/* Check to see if we can enable 4 byte addressing */ \tret = jesd216_bfp_decode_dw16(&header->phdr[0], bfp,&dw16); \tif (ret< 0) { \t\treturn ret; \t}  \t/* Attempt to enable 4 byte addressing */ \tret = flash_flexspi_nor_4byte_enable(data, flexspi_lut, dw16.enter_4ba); \tif (ret == 0) { \t\t/* Use 4 byte address width */ \t\taddr_width = 32; \t\t/* Update LUT for ERASE_SECTOR and ERASE_BLOCK to use 32 bit addr */ \t\tflexspi_lut[ERASE_SECTOR][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_SE, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, addr_width); \t\tflexspi_lut[ERASE_BLOCK][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_BE, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, addr_width); \t} \t/* Extract the read command. \t * Note- enhanced XIP not currently supported, nor is 4-4-4 mode. \t */ \tif (jesd216_bfp_read_support(&header->phdr[0], bfp, \t    JESD216_MODE_144,&instr)> 0) { \t\tLOG_DBG(\"Enable 144 mode\"); \t\t/* Configure for 144 QUAD read mode */ \t\tif (instr.mode_clocks == 2) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE8_SDR; \t\t} else if (instr.mode_clocks == 1) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE4_SDR; \t\t} else if (instr.mode_clocks == 0) { \t\t\t/* Just send dummy cycles during mode clock period */ \t\t\tmode_cmd = kFLEXSPI_Command_DUMMY_SDR; \t\t} else { \t\t\treturn -ENOTSUP; \t\t} \t\tflexspi_lut[READ][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, instr.instr, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_4PAD, addr_width); \t\t/* Note- we always set mode bits to 0x0 */ \t\tflexspi_lut[READ][1] = FLEXSPI_LUT_SEQ( \t\t\t\tmode_cmd, kFLEXSPI_4PAD, 0x00, \t\t\t\tkFLEXSPI_Command_DUMMY_SDR, kFLEXSPI_4PAD, instr.wait_states); \t\tflexspi_lut[READ][2] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_4PAD, 0x04, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\t/* Read 1S-4S-4S enable method */ \t\tret = jesd216_bfp_decode_dw15(&header->phdr[0], bfp,&dw15); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\tret = flash_flexspi_nor_quad_enable(data, flexspi_lut, dw15.qer); \t\tif (ret< 0) { \t\t\treturn ret; \t\t} \t\t/* Now, install 1S-1S-4S page program command */ \t\tflexspi_lut[PAGE_PROGRAM][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_PP_1_1_4, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, addr_width); \t\tflexspi_lut[PAGE_PROGRAM][1] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_4PAD, 0x4, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0);  \t} else if (jesd216_bfp_read_support(&header->phdr[0], bfp, \t    JESD216_MODE_122,&instr)> 0) { \t\tLOG_DBG(\"Enable 122 mode\"); \t\tif (instr.mode_clocks == 4) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE8_SDR; \t\t} else if (instr.mode_clocks == 2) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE4_SDR; \t\t} else if (instr.mode_clocks == 1) { \t\t\tmode_cmd = kFLEXSPI_Command_MODE2_SDR; \t\t} else if (instr.mode_clocks == 0) { \t\t\t/* Just send dummy cycles during mode clock period */ \t\t\tmode_cmd = kFLEXSPI_Command_DUMMY_SDR; \t\t} else { \t\t\treturn -ENOTSUP; \t\t} \t\tflexspi_lut[READ][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, instr.instr, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_2PAD, addr_width); \t\t/* Note- we always set mode bits to 0x0 */ \t\tflexspi_lut[READ][1] = FLEXSPI_LUT_SEQ( \t\t\t\tmode_cmd, kFLEXSPI_2PAD, 0x0, \t\t\t\tkFLEXSPI_Command_DUMMY_SDR, kFLEXSPI_2PAD, instr.wait_states); \t\tflexspi_lut[READ][2] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_2PAD, 0x02, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\t/* Now, install 1S-1S-2S page program command */ \t\tflexspi_lut[PAGE_PROGRAM][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_PP_1_1_2, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, addr_width); \t\tflexspi_lut[PAGE_PROGRAM][1] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_2PAD, 0x4, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t} \t/* Default to 111 mode if no support exists, leave READ/WRITE untouched */  \t/* Now, read DW14 to determine the polling method we should use while programming */ \tret = jesd216_bfp_decode_dw14(&header->phdr[0], bfp,&dw14); \tif (ret< 0) { \t\treturn ret; \t} \tif (dw14.poll_options& BIT(1)) { \t\t/* Read instruction used for polling is 0x70 */ \t\tdata->legacy_poll = false; \t\tflexspi_lut[READ_STATUS_REG][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0x70, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01); \t} else { \t\t/* Read instruction used for polling is 0x05 */ \t\tdata->legacy_poll = true; \t\tflexspi_lut[READ_STATUS_REG][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01); \t}  \treturn 0; }  /* Helper so we can avoid flash access while performing SFDP probe */ static int flash_flexspi_nor_sfdp_read_helper(struct flash_flexspi_nor_data *dev_data, \t\toff_t offset, void *data, size_t len) { \tflexspi_transfer_t transfer = { \t\t.deviceAddress = offset, \t\t.port = dev_data->port, \t\t.cmdType = kFLEXSPI_Read, \t\t.seqIndex = READ_JESD216, \t\t.SeqNumber = 1, \t\t.data = (uint32_t *)data, \t\t.dataSize = len, \t};  \t/* Get SFDP data */ \treturn memc_flexspi_transfer(&dev_data->controller,&transfer); }   #if defined(CONFIG_FLASH_JESD216_API)  static int flash_flexspi_nor_sfdp_read(const struct device *dev, \t\toff_t offset, void *data, size_t len) { \tstruct flash_flexspi_nor_data *dev_data = dev->data;  \treturn flash_flexspi_nor_sfdp_read_helper(dev_data, offset, data, len); }  #endif  /* Checks JEDEC ID of flash. If supported, installs custom LUT table */ static int flash_flexspi_nor_check_jedec(struct flash_flexspi_nor_data *data, \t\t\tuint32_t (*flexspi_lut)[MEMC_FLEXSPI_CMD_PER_SEQ]) { \tint ret; \tuint32_t vendor_id;  \tret = flash_flexspi_nor_read_id_helper(data, (uint8_t *)&vendor_id); \tif (ret< 0) { \t\treturn ret; \t}  \t/* Switch on manufacturer and vendor ID */ \tswitch (vendor_id& 0xFFFF) { \tcase 0x25C2: \t\t/* MX25 flash, use 4 byte read/write */ \t\tflexspi_lut[READ][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_4READ_4B, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_4PAD, 32); \t\t/* Flash needs 10 dummy cycles */ \t\tflexspi_lut[READ][1] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_DUMMY_SDR, kFLEXSPI_4PAD, 10, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_4PAD, 0x04); \t\t/* Only 1S-4S-4S page program supported */ \t\tflexspi_lut[PAGE_PROGRAM][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_PP_1_4_4_4B, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_4PAD, 32); \t\tflexspi_lut[PAGE_PROGRAM][1] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_WRITE_SDR, kFLEXSPI_4PAD, 0x4, \t\t\t\tkFLEXSPI_Command_STOP, kFLEXSPI_1PAD, 0x0); \t\t/* Update ERASE commands for 4 byte mode */ \t\tflexspi_lut[ERASE_SECTOR][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_SE_4B, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 32); \t\tflexspi_lut[ERASE_BLOCK][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, 0xDC, \t\t\t\tkFLEXSPI_Command_RADDR_SDR, kFLEXSPI_1PAD, 32), \t\t/* Read instruction used for polling is 0x05 */ \t\tdata->legacy_poll = true; \t\tflexspi_lut[READ_STATUS_REG][0] = FLEXSPI_LUT_SEQ( \t\t\t\tkFLEXSPI_Command_SDR, kFLEXSPI_1PAD, SPI_NOR_CMD_RDSR, \t\t\t\tkFLEXSPI_Command_READ_SDR, kFLEXSPI_1PAD, 0x01); \t\t/* Device uses bit 6 of status reg 1 for QE */ \t\treturn flash_flexspi_nor_quad_enable(data, flexspi_lut, JESD216_DW15_QER_VAL_S1B6); \tdefault: \t\treturn -ENOTSUP; \t} }  /* Probe parameters from flash SFDP header, and use them to configure the FlexSPI */ static int flash_flexspi_nor_probe(struct flash_flexspi_nor_data *data) { \tuint32_t flexspi_lut[FLEXSPI_INSTR_END][MEMC_FLEXSPI_CMD_PER_SEQ] = {0}; \t/* JESD216B defines up to 23 basic flash parameters */ \tuint32_t param_buf[23]; \t/* Space to store SFDP header and first parameter header */ \tuint8_t sfdp_buf[JESD216_SFDP_SIZE(1)] __aligned(4); \tstruct jesd216_bfp *bfp = (struct jesd216_bfp *)param_buf; \tstruct jesd216_sfdp_header *header = (struct jesd216_sfdp_header *)sfdp_buf; \tint ret; \tunsigned int key = 0U;  \tflexspi_device_config_t config = { \t\t.flexspiRootClk = MHZ(50), \t\t.flashSize = FLEXSPI_FLSHCR0_FLSHSZ_MASK, /* Max flash size */ \t\t.ARDSeqNumber = 1, \t\t.ARDSeqIndex = READ, \t};  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* \t\t * ==== ENTER CRITICAL SECTION ==== \t\t * No flash access should be performed in critical section. All \t\t * code and data accessed must reside in ram. \t\t */ \t\tkey = irq_lock(); \t\tmemc_flexspi_wait_bus_idle(&data->controller); \t}  \t/* SFDP spec requires that we downclock the FlexSPI to 50MHz or less */ \tret = memc_flexspi_update_clock(&data->controller,&config, \t\t\t\t\tdata->port, MHZ(50)); \tif (ret< 0) { \t\tgoto _exit; \t}  \t/* Setup initial LUT table and FlexSPI configuration */ \tmemcpy(flexspi_lut, flash_flexspi_nor_base_lut, sizeof(flash_flexspi_nor_base_lut));  \tret = memc_flexspi_set_device_config(&data->controller,&config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \tif (ret< 0) { \t\tgoto _exit; \t}  \t/* First, check if the JEDEC ID of this flash has explicit support \t * in this driver \t */ \tret = flash_flexspi_nor_check_jedec(data, flexspi_lut); \tif (ret == 0) { \t\t/* Flash was supported, SFDP probe not needed */ \t\tgoto _program_lut; \t}  \tret = flash_flexspi_nor_sfdp_read_helper(data, 0, sfdp_buf, sizeof(sfdp_buf)); \tif (ret< 0) { \t\tgoto _exit; \t}  \tLOG_DBG(\"SFDP header magic: 0x%x\", header->magic); \tif (jesd216_sfdp_magic(header) != JESD216_SFDP_MAGIC) { \t\t/* Header was read incorrectly */ \t\tLOG_WRN(\"Invalid header\n-literal|\"); \t\tdata->legacy_poll = true; \t\tgoto _program_lut; \t}  \tif (header->phdr[0].len_dw> ARRAY_SIZE(param_buf)) { \t\t/* Not enough space to read parameter table */ \t\tret = -ENOBUFS; \t\tgoto _exit; \t}  \t/* Read basic flash parameter table */ \tret = flash_flexspi_nor_sfdp_read_helper(data, \t\t\tjesd216_param_addr(&header->phdr[0]), \t\t\tparam_buf, \t\t\tsizeof(uint32_t) * header->phdr[0].len_dw); \tif (ret< 0) { \t\tgoto _exit; \t}  \t/* Configure flash */ \tret = flash_flexspi_nor_config_flash(data, header, bfp, flexspi_lut); \tif (ret< 0) { \t\tgoto _exit; \t}  _program_lut: \t/* \t * Update the FlexSPI with the config structure provided \t * from devicetree and the configured LUT \t */ \tret = memc_flexspi_set_device_config(&data->controller,&data->config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \tif (ret< 0) { \t\treturn ret; \t}  _exit: \tmemc_flexspi_reset(&data->controller);  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* ==== EXIT CRITICAL SECTION ==== */ \t\tirq_unlock(key); \t}  \treturn ret; }  static int flash_flexspi_nor_init(const struct device *dev) { \tconst struct flash_flexspi_nor_config *config = dev->config; \tstruct flash_flexspi_nor_data *data = dev->data; \tuint32_t vendor_id;  \t/* First step- use ROM pointer to controller device to create \t * a copy of the device structure in RAM we can use while in \t * critical sections of code. \t */ \tmemcpy(&data->controller, config->controller, sizeof(struct device));  \tif (!device_is_ready(&data->controller)) { \t\tLOG_ERR(\"\n+literal|\"); \t\tdata->legacy_poll = true; \t\tgoto _program_lut; \t}  \tif (header->phdr[0].len_dw> ARRAY_SIZE(param_buf)) { \t\t/* Not enough space to read parameter table */ \t\tret = -ENOBUFS; \t\tgoto _exit; \t}  \t/* Read basic flash parameter table */ \tret = flash_flexspi_nor_sfdp_read_helper(data, \t\t\tjesd216_param_addr(&header->phdr[0]), \t\t\tparam_buf, \t\t\tsizeof(uint32_t) * header->phdr[0].len_dw); \tif (ret< 0) { \t\tgoto _exit; \t}  \t/* Configure flash */ \tret = flash_flexspi_nor_config_flash(data, header, bfp, flexspi_lut); \tif (ret< 0) { \t\tgoto _exit; \t}  _program_lut: \t/* \t * Update the FlexSPI with the config structure provided \t * from devicetree and the configured LUT \t */ \tret = memc_flexspi_set_device_config(&data->controller,&data->config, \t\t\t\t\t(uint32_t *)flexspi_lut, \t\t\t\t\tFLEXSPI_INSTR_PROG_END * MEMC_FLEXSPI_CMD_PER_SEQ, \t\t\t\t\tdata->port); \tif (ret< 0) { \t\treturn ret; \t}  _exit: \tmemc_flexspi_reset(&data->controller);  \tif (memc_flexspi_is_running_xip(&data->controller)) { \t\t/* ==== EXIT CRITICAL SECTION ==== */ \t\tirq_unlock(key); \t}  \treturn ret; }  static int flash_flexspi_nor_init(const struct device *dev) { \tconst struct flash_flexspi_nor_config *config = dev->config; \tstruct flash_flexspi_nor_data *data = dev->data; \tuint32_t vendor_id;  \t/* First step- use ROM pointer to controller device to create \t * a copy of the device structure in RAM we can use while in \t * critical sections of code. \t */ \tmemcpy(&data->controller, config->controller, sizeof(struct device));  \tif (!device_is_ready(&data->controller)) { \t\tLOG_ERR(\"\nThe issue was with: drivers: flash: flash_mcux_flexspi_nor: reduce LUT usage\n\nFLEXSPI nor driver uses several LUTs for \\\"scratch\\\" commands during the\nSFDP probe phase that are not needed once the flash is configured. Set a\nsecond \\\"end\\\" marker we can use to configure the FLEXSPI MEMC driver, so\nthat we can indicate the true number of LUTs needed by this driver when\ninit is completed."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: memc: memc_mcux_flexspi_is66wvq8m4: do not reset FLEXSPI\n\nDo not reset the FLEXSPI during init, as this will crash the chip if we\nare running the MEMC driver in XIP mode. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ISSI_VENDOR_ID\nvalue|0x3\nend_define\n\nbegin_enum\nDECL|enum|__anon2bcfc7320103\nenum|enum\nblock|{\nDECL|enumerator|READ_DATA\nname|READ_DATA\ninit|=\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}\nname|memc_flexspi_reset\nargument_list|(\nname|data\noperator|->\nname|controller\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|memc_flexspi_is66wvq8m4_get_vendor_id\nargument_list|(\nname|dev",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon2bcfc7320103\n+DECL|enum|__anon2bd25f720103\n-name|memc_flexspi_reset\n-argument_list|(\n-name|data\n-operator|->\n-name|controller\n-argument_list|)\n-expr_stmt|;\nThe issue was with: drivers: memc: memc_mcux_flexspi_is66wvq8m4: do not reset FLEXSPI\n\nDo not reset the FLEXSPI during init, as this will crash the chip if we\nare running the MEMC driver in XIP mode."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: memc: memc_mcux_flexspi: support initializing FLEXSPI when XIP\n\nAdd support for initializing the FLEXSPI when using a flash attached to\nthe FLEXSPI for XIP. This option is guarded behind a Kconfig, as\nenabling it is dangerous and requires special care be taken by the user\nto ensure that the configuration of pins and FLEXSPI settings will not\nbreak support for reading the attached flash, as this will break XIP\nsupport. Please fix this issue.",
  "input": "Faulty tokenized code:\n\t  flash driver must initialize before the MEMC RAM driver,\n\t  initialization priorities can be set such that\n\t  MEMC_MCUX_FLEXSPI_INIT_PRIORITY < FLASH_INIT_PRIORITY <\n\t  MEMC_INIT_PRIORITY\n\nconfig MEMC_MCUX_FLEXSPI\n\tbool\n\tselect PINCTRL\n\nendif # DT_HAS_NXP_IMX_FLEXSPI_ENABLED\nname|read\noperator|-\nend_expr_stmt\n\nbegin_while\nwhile|while-write hazards. This configuration is not recommended.\" #endif  #define FLEXSPI_MAX_LUT 64U  LOG_MODULE_REGISTER(memc_flexspi, CONFIG_MEMC_LOG_LEVEL);  struct memc_flexspi_buf_cfg { \tuint16_t prefetch; \tuint16_t priority; \tuint16_t master_id; \tuint16_t buf_size; } __packed;  /* Structure tracking LUT offset and usage per each port */ struct port_lut { \tuint8_t lut_offset; \tuint8_t lut_used; };  /* flexspi device data should be stored in RAM to avoid read-while-write hazards */ struct memc_flexspi_data { \tFLEXSPI_Type *base; \tuint8_t *ahb_base; \tbool xip; \tbool ahb_bufferable; \tbool ahb_cacheable; \tbool ahb_prefetch; \tbool ahb_read_addr_opt; \tbool combination_mode; \tbool sck_differential_clock; \tflexspi_read_sample_clock_t rx_sample_clock; #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB)&& \\ FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB \tflexspi_read_sample_clock_t rx_sample_clock_b; #endif \tconst struct pinctrl_dev_config *pincfg; \tsize_t size[kFLEXSPI_PortCount]; \tstruct port_lut port_luts[kFLEXSPI_PortCount]; \tstruct memc_flexspi_buf_cfg *buf_cfg; \tuint8_t buf_cfg_cnt; \tconst struct device *clock_dev; \tclock_control_subsys_t clock_subsys; };  void memc_flexspi_wait_bus_idle(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \twhile (false == FLEXSPI_GetBusIdleStatus(data->base)) { \t} }  bool memc_flexspi_is_running_xip(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \treturn data->xip; }  int memc_flexspi_update_clock(const struct device *dev, \t\tflexspi_device_config_t *device_config, \t\tflexspi_port_t port, uint32_t freq_hz) { \tstruct memc_flexspi_data *data = dev->data; \tuint32_t rate; \tuint32_t key; \tint ret;  \t/* To reclock the FlexSPI, we should: \t * - disable the module \t * - set the new clock \t * - reenable the module \t * - reset the module \t * We CANNOT XIP at any point during this process \t */ \tkey = irq_lock(); \tmemc_flexspi_wait_bus_idle(dev);  \tret = clock_control_set_rate(data->clock_dev, data->clock_subsys, \t\t\t\t(clock_control_subsys_rate_t)freq_hz); \tif (ret< 0) { \t\tirq_unlock(key); \t\treturn ret; \t}  \t/* \t * We need to update the DLL value before we call clock_control_get_rate, \t * because this will cause XIP (flash reads) to occur. Although the \t * true flash clock is not known, assume the set_rate function programmed \t * a value close to what we requested. \t */ \tdevice_config->flexspiRootClk = freq_hz; \tFLEXSPI_UpdateDllValue(data->base, device_config, port); \tmemc_flexspi_reset(dev);  \tmemc_flexspi_wait_bus_idle(dev); \tret = clock_control_get_rate(data->clock_dev, data->clock_subsys,&rate); \tif (ret< 0) { \t\tirq_unlock(key); \t\treturn ret; \t}   \tdevice_config->flexspiRootClk = rate; \tFLEXSPI_UpdateDllValue(data->base, device_config, port);  \tmemc_flexspi_reset(dev);  \tirq_unlock(key);  \treturn 0; }  int memc_flexspi_set_device_config(const struct device *dev, \t\tconst flexspi_device_config_t *device_config, \t\tconst uint32_t *lut_array, \t\tuint8_t lut_count, \t\tflexspi_port_t port) { \tflexspi_device_config_t tmp_config; \tuint32_t tmp_lut[FLEXSPI_MAX_LUT]; \tstruct memc_flexspi_data *data = dev->data; \tconst uint32_t *lut_ptr = lut_array; \tuint8_t lut_used = 0U; \tunsigned int key = 0;  \tif (port>= kFLEXSPI_PortCount) { \t\tLOG_ERR(\"Invalid port number\"); \t\treturn -EINVAL; \t}  \tif (data->port_luts[port].lut_used< lut_count) { \t\t/* We cannot reuse the existing LUT slot, \t\t * Check if the LUT table will fit into the remaining LUT slots \t\t */ \t\tfor (uint8_t i = 0; i< kFLEXSPI_PortCount; i++) { \t\t\tlut_used += data->port_luts[i].lut_used; \t\t}  \t\tif ((lut_used + lut_count)> FLEXSPI_MAX_LUT) { \t\t\treturn -ENOBUFS; \t\t} \t}  \tdata->size[port] = device_config->flashSize * KB(1);  \tif (memc_flexspi_is_running_xip(dev)) { \t\t/* We need to avoid flash access while configuring the FlexSPI. \t\t * To do this, we will copy the LUT array into stack-allocated \t\t * temporary memory \t\t */ \t\tmemcpy(tmp_lut, lut_array, lut_count * MEMC_FLEXSPI_CMD_SIZE); \t\tlut_ptr = tmp_lut; \t}  \tmemcpy(&tmp_config, device_config, sizeof(tmp_config)); \t/* Update FlexSPI AWRSEQID and ARDSEQID values based on where the LUT \t * array will actually be loaded. \t */ \tif (data->port_luts[port].lut_used< lut_count) { \t\t/* Update lut offset with new value */ \t\tdata->port_luts[port].lut_offset = lut_used; \t} \t/* LUTs should only be installed on sequence boundaries, every \t * 4 entries. Round LUT usage up to nearest sequence \t */ \tdata->port_luts[port].lut_used = ROUND_UP(lut_count, 4); \ttmp_config.ARDSeqIndex += data->port_luts[port].lut_offset / MEMC_FLEXSPI_CMD_PER_SEQ; \ttmp_config.AWRSeqIndex += data->port_luts[port].lut_offset / MEMC_FLEXSPI_CMD_PER_SEQ;  \t/* Lock IRQs before reconfiguring FlexSPI, to prevent XIP */ \tkey = irq_lock();  \tFLEXSPI_SetFlashConfig(data->base,&tmp_config, port); \tFLEXSPI_UpdateLUT(data->base, data->port_luts[port].lut_offset, \t\t\t  lut_ptr, lut_count); \tirq_unlock(key);  \treturn 0; }  int memc_flexspi_reset(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \tFLEXSPI_SoftwareReset(data->base);  \treturn 0; }  int memc_flexspi_transfer(const struct device *dev, \t\tflexspi_transfer_t *transfer) { \tflexspi_transfer_t tmp; \tstruct memc_flexspi_data *data = dev->data; \tstatus_t status; \tuint32_t seq_off, addr_offset = 0U; \tint i;  \t/* Calculate sequence offset and address offset based on port */ \tseq_off = data->port_luts[transfer->port].lut_offset / \t\t\t\tMEMC_FLEXSPI_CMD_PER_SEQ; \tfor (i = 0; i< transfer->port; i++) { \t\taddr_offset += data->size[i]; \t}  \tif ((seq_off != 0) || (addr_offset != 0)) { \t\t/* Adjust device address and sequence index for transfer */ \t\tmemcpy(&tmp, transfer, sizeof(tmp)); \t\ttmp.seqIndex += seq_off; \t\ttmp.deviceAddress += addr_offset; \t\tstatus = FLEXSPI_TransferBlocking(data->base,&tmp); \t} else { \t\t/* Transfer does not need adjustment */ \t\tstatus = FLEXSPI_TransferBlocking(data->base, transfer); \t}  \tif (status != kStatus_Success) { \t\tLOG_ERR(\"Transfer error: %d\", status); \t\treturn -EIO; \t}  \treturn 0; }  void *memc_flexspi_get_ahb_address(const struct device *dev, \t\tflexspi_port_t port, off_t offset) { \tstruct memc_flexspi_data *data = dev->data; \tint i;  \tif (port>= kFLEXSPI_PortCount) { \t\tLOG_ERR(\"Invalid port number: %u\", port); \t\treturn NULL; \t}  \tfor (i = 0; i< port; i++) { \t\toffset += data->size[i]; \t}  #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_ADDRESS_SHIFT)&& \\ \t(FSL_FEATURE_FLEXSPI_SUPPORT_ADDRESS_SHIFT) \tif (data->base->FLSHCR0[port]& FLEXSPI_FLSHCR0_ADDRSHIFT_MASK) { \t\t/* Address shift is set, add 0x1000_0000 to AHB address */ \t\toffset += 0x10000000; \t} #endif  \treturn data->ahb_base + offset; }  static int memc_flexspi_init(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data; \tflexspi_config_t flexspi_config;  \t/* we should not configure the device we are running on */ \tif (memc_flexspi_is_running_xip(dev)) { \t\tLOG_DBG(\"XIP active on %s\noperator|,\nname|skipping\nname|init\nliteral|\", dev->name); \t\treturn 0; \t}  \t/* \t * SOCs such as the RT1064 and RT1024 have internal flash, and no pinmux \t * settings, continue if no pinctrl state found. \t */ \tint ret;  \tret = pinctrl_apply_state(data->pincfg, PINCTRL_STATE_DEFAULT); \tif (ret< 0&& ret != -ENOENT) { \t\treturn ret; \t}  \tFLEXSPI_GetDefaultConfig(&flexspi_config);  \tflexspi_config.ahbConfig.enableAHBBufferable = data->ahb_bufferable; \tflexspi_config.ahbConfig.enableAHBCachable = data->ahb_cacheable; \tflexspi_config.ahbConfig.enableAHBPrefetch = data->ahb_prefetch; \tflexspi_config.ahbConfig.enableReadAddressOpt = data->ahb_read_addr_opt; #if !(defined(FSL_FEATURE_FLEXSPI_HAS_NO_MCR0_COMBINATIONEN)&& \\ \tFSL_FEATURE_FLEXSPI_HAS_NO_MCR0_COMBINATIONEN) \tflexspi_config.enableCombination = data->combination_mode; #endif  #if !(defined(FSL_FEATURE_FLEXSPI_HAS_NO_MCR2_SCKBDIFFOPT)&& \\ \tFSL_FEATURE_FLEXSPI_HAS_NO_MCR2_SCKBDIFFOPT) \tflexspi_config.enableSckBDiffOpt = data->sck_differential_clock; #endif \tflexspi_config.rxSampleClock = data->rx_sample_clock; #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB)&& \\ FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB \tflexspi_config.rxSampleClockPortB = data->rx_sample_clock_b; #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_RXCLKSRC_DIFF)&& \\ \tFSL_FEATURE_FLEXSPI_SUPPORT_RXCLKSRC_DIFF \tif (flexspi_config.rxSampleClock != flexspi_config.rxSampleClockPortB) { \t\tflexspi_config.rxSampleClockDiff = true; \t} #endif #endif  \t/* Configure AHB RX buffers, if any configuration settings are present */ \t__ASSERT(data->buf_cfg_cnt< FSL_FEATURE_FLEXSPI_AHB_BUFFER_COUNT, \t\t\"\nname|Maximum\nname|RX\nname|buffer\nname|configuration\nname|count\nname|exceeded\nliteral|\"\nend_while\n\nunit|); \tfor (uint8_t i = 0; i< data->buf_cfg_cnt; i++) { \t\t/* Should AHB prefetch up to buffer size? */ \t\tflexspi_config.ahbConfig.buffer[i].enablePrefetch = data->buf_cfg[i].prefetch; \t\t/* AHB access priority (used for suspending control of AHB prefetching )*/ \t\tflexspi_config.ahbConfig.buffer[i].priority = data->buf_cfg[i].priority; \t\t/* AHB master index, SOC specific */ \t\tflexspi_config.ahbConfig.buffer[i].masterIndex = data->buf_cfg[i].master_id; \t\t/* RX buffer allocation (total available buffer space is instance/SOC specific) */ \t\tflexspi_config.ahbConfig.buffer[i].bufferSize = data->buf_cfg[i].buf_size; \t}  \tFLEXSPI_Init(data->base,&flexspi_config);  \treturn 0; }  #ifdef CONFIG_PM_DEVICE static int memc_flexspi_pm_action(const struct device *dev, enum pm_device_action action) { \tstruct memc_flexspi_data *data = dev->data; \tint ret;  \tswitch (action) { \tcase PM_DEVICE_ACTION_RESUME: \t\tret = pinctrl_apply_state(data->pincfg, PINCTRL_STATE_DEFAULT); \t\tif (ret< 0&& ret != -ENOENT) { \t\t\treturn ret; \t\t} \t\tbreak; \tcase PM_DEVICE_ACTION_SUSPEND: \t\tret = pinctrl_apply_state(data->pincfg, PINCTRL_STATE_SLEEP); \t\tif (ret< 0&& ret != -ENOENT) { \t\t\treturn ret; \t\t} \t\tbreak; \tdefault: \t\treturn -ENOTSUP; \t}  \treturn 0; } #endif  #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB)&& \\ \tFSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB #define MEMC_FLEXSPI_RXCLK_B(inst) .rx_sample_clock_b = DT_INST_PROP(inst, rx_clock_source_b), #else #define MEMC_FLEXSPI_RXCLK_B(inst) #endif  #if defined(CONFIG_XIP)&& defined(CONFIG_FLASH_MCUX_FLEXSPI_XIP) /* Checks if image flash base address is in the FlexSPI AHB base region */ #define MEMC_FLEXSPI_CFG_XIP(node_id)\t\t\t\t\t\t\\ \t((CONFIG_FLASH_BASE_ADDRESS)>= DT_REG_ADDR_BY_IDX(node_id, 1))&&\t\\ \t((CONFIG_FLASH_BASE_ADDRESS)< (DT_REG_ADDR_BY_IDX(node_id, 1) +\t\\ \t\t\t\t\tDT_REG_SIZE_BY_IDX(node_id, 1)))  #else #define MEMC_FLEXSPI_CFG_XIP(node_id) false #endif  #define MEMC_FLEXSPI(n)\t\t\t\t\t\t\t\\ \tPINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t\\ \tstatic uint16_t  buf_cfg_##n[] =\t\t\t\t\\ \t\tDT_INST_PROP_OR(n, rx_buffer_config, {0});\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic struct memc_flexspi_data\t\t\t\t\t\\ \t\tmemc_flexspi_data_##n = {\t\t\t\t\\ \t\t.base = (FLEXSPI_Type *) DT_INST_REG_ADDR(n),\t\t\\ \t\t.xip = MEMC_FLEXSPI_CFG_XIP(DT_DRV_INST(n)),\t\t\\ \t\t.ahb_base = (uint8_t *) DT_INST_REG_ADDR_BY_IDX(n, 1),\t\\ \t\t.ahb_bufferable = DT_INST_PROP(n, ahb_bufferable),\t\\ \t\t.ahb_cacheable = DT_INST_PROP(n, ahb_cacheable),\t\\ \t\t.ahb_prefetch = DT_INST_PROP(n, ahb_prefetch),\t\t\\ \t\t.ahb_read_addr_opt = DT_INST_PROP(n, ahb_read_addr_opt),\\ \t\t.combination_mode = DT_INST_PROP(n, combination_mode),\t\\ \t\t.sck_differential_clock = DT_INST_PROP(n, sck_differential_clock),\t\\ \t\t.rx_sample_clock = DT_INST_PROP(n, rx_clock_source),\t\\ \t\tMEMC_FLEXSPI_RXCLK_B(n)                                 \\ \t\t.buf_cfg = (struct memc_flexspi_buf_cfg *)buf_cfg_##n,\t\\ \t\t.buf_cfg_cnt = sizeof(buf_cfg_##n) /\t\t\t\\ \t\t\tsizeof(struct memc_flexspi_buf_cfg),\t\t\\ \t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\\ \t\t.clock_dev = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(n)),     \\ \t\t.clock_subsys = (clock_control_subsys_t)                \\ \t\t\tDT_INST_CLOCKS_CELL(n, name),                   \\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(n, memc_flexspi_pm_action);\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n,\t\t\t\t\t\\ \t\t\t      memc_flexspi_init,\t\t\t\\ \t\t\t      PM_DEVICE_DT_INST_GET(n),\t\t\t\\&memc_flexspi_data_##n,\t\t\t\\ \t\t\t      NULL,\t\t\t\t\t\\ \t\t\t      POST_KERNEL,\t\t\t\t\\ \t\t\t      CONFIG_MEMC_MCUX_FLEXSPI_INIT_PRIORITY,\t\\ \t\t\t      NULL);  DT_INST_FOREACH_STATUS_OKAY(MEMC_FLEXSPI)\nend_unit\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n+config MEMC_MCUX_FLEXSPI_INIT_XIP\n+\tbool \"Initialize FLEXSPI when using device for XIP\"\n+\thelp\n+\t  Initialize the FLEXSPI device even when using it for XIP. If this\n+\t  Kconfig is enabled, the user must ensure that the pin control\n+\t  state used does not reconfigure the pins used to interface with\n+\t  the flash device used for XIP, and that the configuration settings\n+\t  used for the FLEXSPI are compatible with those needed for XIP from\n+\t  the flash device.\n+\n-while|while-write hazards. This configuration is not recommended.\" #endif  #define FLEXSPI_MAX_LUT 64U  LOG_MODULE_REGISTER(memc_flexspi, CONFIG_MEMC_LOG_LEVEL);  struct memc_flexspi_buf_cfg { \tuint16_t prefetch; \tuint16_t priority; \tuint16_t master_id; \tuint16_t buf_size; } __packed;  /* Structure tracking LUT offset and usage per each port */ struct port_lut { \tuint8_t lut_offset; \tuint8_t lut_used; };  /* flexspi device data should be stored in RAM to avoid read-while-write hazards */ struct memc_flexspi_data { \tFLEXSPI_Type *base; \tuint8_t *ahb_base; \tbool xip; \tbool ahb_bufferable; \tbool ahb_cacheable; \tbool ahb_prefetch; \tbool ahb_read_addr_opt; \tbool combination_mode; \tbool sck_differential_clock; \tflexspi_read_sample_clock_t rx_sample_clock; #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB)&& \\ FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB \tflexspi_read_sample_clock_t rx_sample_clock_b; #endif \tconst struct pinctrl_dev_config *pincfg; \tsize_t size[kFLEXSPI_PortCount]; \tstruct port_lut port_luts[kFLEXSPI_PortCount]; \tstruct memc_flexspi_buf_cfg *buf_cfg; \tuint8_t buf_cfg_cnt; \tconst struct device *clock_dev; \tclock_control_subsys_t clock_subsys; };  void memc_flexspi_wait_bus_idle(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \twhile (false == FLEXSPI_GetBusIdleStatus(data->base)) { \t} }  bool memc_flexspi_is_running_xip(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \treturn data->xip; }  int memc_flexspi_update_clock(const struct device *dev, \t\tflexspi_device_config_t *device_config, \t\tflexspi_port_t port, uint32_t freq_hz) { \tstruct memc_flexspi_data *data = dev->data; \tuint32_t rate; \tuint32_t key; \tint ret;  \t/* To reclock the FlexSPI, we should: \t * - disable the module \t * - set the new clock \t * - reenable the module \t * - reset the module \t * We CANNOT XIP at any point during this process \t */ \tkey = irq_lock(); \tmemc_flexspi_wait_bus_idle(dev);  \tret = clock_control_set_rate(data->clock_dev, data->clock_subsys, \t\t\t\t(clock_control_subsys_rate_t)freq_hz); \tif (ret< 0) { \t\tirq_unlock(key); \t\treturn ret; \t}  \t/* \t * We need to update the DLL value before we call clock_control_get_rate, \t * because this will cause XIP (flash reads) to occur. Although the \t * true flash clock is not known, assume the set_rate function programmed \t * a value close to what we requested. \t */ \tdevice_config->flexspiRootClk = freq_hz; \tFLEXSPI_UpdateDllValue(data->base, device_config, port); \tmemc_flexspi_reset(dev);  \tmemc_flexspi_wait_bus_idle(dev); \tret = clock_control_get_rate(data->clock_dev, data->clock_subsys,&rate); \tif (ret< 0) { \t\tirq_unlock(key); \t\treturn ret; \t}   \tdevice_config->flexspiRootClk = rate; \tFLEXSPI_UpdateDllValue(data->base, device_config, port);  \tmemc_flexspi_reset(dev);  \tirq_unlock(key);  \treturn 0; }  int memc_flexspi_set_device_config(const struct device *dev, \t\tconst flexspi_device_config_t *device_config, \t\tconst uint32_t *lut_array, \t\tuint8_t lut_count, \t\tflexspi_port_t port) { \tflexspi_device_config_t tmp_config; \tuint32_t tmp_lut[FLEXSPI_MAX_LUT]; \tstruct memc_flexspi_data *data = dev->data; \tconst uint32_t *lut_ptr = lut_array; \tuint8_t lut_used = 0U; \tunsigned int key = 0;  \tif (port>= kFLEXSPI_PortCount) { \t\tLOG_ERR(\"Invalid port number\"); \t\treturn -EINVAL; \t}  \tif (data->port_luts[port].lut_used< lut_count) { \t\t/* We cannot reuse the existing LUT slot, \t\t * Check if the LUT table will fit into the remaining LUT slots \t\t */ \t\tfor (uint8_t i = 0; i< kFLEXSPI_PortCount; i++) { \t\t\tlut_used += data->port_luts[i].lut_used; \t\t}  \t\tif ((lut_used + lut_count)> FLEXSPI_MAX_LUT) { \t\t\treturn -ENOBUFS; \t\t} \t}  \tdata->size[port] = device_config->flashSize * KB(1);  \tif (memc_flexspi_is_running_xip(dev)) { \t\t/* We need to avoid flash access while configuring the FlexSPI. \t\t * To do this, we will copy the LUT array into stack-allocated \t\t * temporary memory \t\t */ \t\tmemcpy(tmp_lut, lut_array, lut_count * MEMC_FLEXSPI_CMD_SIZE); \t\tlut_ptr = tmp_lut; \t}  \tmemcpy(&tmp_config, device_config, sizeof(tmp_config)); \t/* Update FlexSPI AWRSEQID and ARDSEQID values based on where the LUT \t * array will actually be loaded. \t */ \tif (data->port_luts[port].lut_used< lut_count) { \t\t/* Update lut offset with new value */ \t\tdata->port_luts[port].lut_offset = lut_used; \t} \t/* LUTs should only be installed on sequence boundaries, every \t * 4 entries. Round LUT usage up to nearest sequence \t */ \tdata->port_luts[port].lut_used = ROUND_UP(lut_count, 4); \ttmp_config.ARDSeqIndex += data->port_luts[port].lut_offset / MEMC_FLEXSPI_CMD_PER_SEQ; \ttmp_config.AWRSeqIndex += data->port_luts[port].lut_offset / MEMC_FLEXSPI_CMD_PER_SEQ;  \t/* Lock IRQs before reconfiguring FlexSPI, to prevent XIP */ \tkey = irq_lock();  \tFLEXSPI_SetFlashConfig(data->base,&tmp_config, port); \tFLEXSPI_UpdateLUT(data->base, data->port_luts[port].lut_offset, \t\t\t  lut_ptr, lut_count); \tirq_unlock(key);  \treturn 0; }  int memc_flexspi_reset(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \tFLEXSPI_SoftwareReset(data->base);  \treturn 0; }  int memc_flexspi_transfer(const struct device *dev, \t\tflexspi_transfer_t *transfer) { \tflexspi_transfer_t tmp; \tstruct memc_flexspi_data *data = dev->data; \tstatus_t status; \tuint32_t seq_off, addr_offset = 0U; \tint i;  \t/* Calculate sequence offset and address offset based on port */ \tseq_off = data->port_luts[transfer->port].lut_offset / \t\t\t\tMEMC_FLEXSPI_CMD_PER_SEQ; \tfor (i = 0; i< transfer->port; i++) { \t\taddr_offset += data->size[i]; \t}  \tif ((seq_off != 0) || (addr_offset != 0)) { \t\t/* Adjust device address and sequence index for transfer */ \t\tmemcpy(&tmp, transfer, sizeof(tmp)); \t\ttmp.seqIndex += seq_off; \t\ttmp.deviceAddress += addr_offset; \t\tstatus = FLEXSPI_TransferBlocking(data->base,&tmp); \t} else { \t\t/* Transfer does not need adjustment */ \t\tstatus = FLEXSPI_TransferBlocking(data->base, transfer); \t}  \tif (status != kStatus_Success) { \t\tLOG_ERR(\"Transfer error: %d\", status); \t\treturn -EIO; \t}  \treturn 0; }  void *memc_flexspi_get_ahb_address(const struct device *dev, \t\tflexspi_port_t port, off_t offset) { \tstruct memc_flexspi_data *data = dev->data; \tint i;  \tif (port>= kFLEXSPI_PortCount) { \t\tLOG_ERR(\"Invalid port number: %u\", port); \t\treturn NULL; \t}  \tfor (i = 0; i< port; i++) { \t\toffset += data->size[i]; \t}  #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_ADDRESS_SHIFT)&& \\ \t(FSL_FEATURE_FLEXSPI_SUPPORT_ADDRESS_SHIFT) \tif (data->base->FLSHCR0[port]& FLEXSPI_FLSHCR0_ADDRSHIFT_MASK) { \t\t/* Address shift is set, add 0x1000_0000 to AHB address */ \t\toffset += 0x10000000; \t} #endif  \treturn data->ahb_base + offset; }  static int memc_flexspi_init(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data; \tflexspi_config_t flexspi_config;  \t/* we should not configure the device we are running on */ \tif (memc_flexspi_is_running_xip(dev)) { \t\tLOG_DBG(\"XIP active on %s\n+while|while-write hazards. This configuration is not recommended.\" #endif  #define FLEXSPI_MAX_LUT 64U  LOG_MODULE_REGISTER(memc_flexspi, CONFIG_MEMC_LOG_LEVEL);  struct memc_flexspi_buf_cfg { \tuint16_t prefetch; \tuint16_t priority; \tuint16_t master_id; \tuint16_t buf_size; } __packed;  /* Structure tracking LUT offset and usage per each port */ struct port_lut { \tuint8_t lut_offset; \tuint8_t lut_used; };  /* flexspi device data should be stored in RAM to avoid read-while-write hazards */ struct memc_flexspi_data { \tFLEXSPI_Type *base; \tuint8_t *ahb_base; \tbool xip; \tbool ahb_bufferable; \tbool ahb_cacheable; \tbool ahb_prefetch; \tbool ahb_read_addr_opt; \tbool combination_mode; \tbool sck_differential_clock; \tflexspi_read_sample_clock_t rx_sample_clock; #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB)&& \\ FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB \tflexspi_read_sample_clock_t rx_sample_clock_b; #endif \tconst struct pinctrl_dev_config *pincfg; \tsize_t size[kFLEXSPI_PortCount]; \tstruct port_lut port_luts[kFLEXSPI_PortCount]; \tstruct memc_flexspi_buf_cfg *buf_cfg; \tuint8_t buf_cfg_cnt; \tconst struct device *clock_dev; \tclock_control_subsys_t clock_subsys; };  void memc_flexspi_wait_bus_idle(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \twhile (false == FLEXSPI_GetBusIdleStatus(data->base)) { \t} }  bool memc_flexspi_is_running_xip(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \treturn data->xip; }  int memc_flexspi_update_clock(const struct device *dev, \t\tflexspi_device_config_t *device_config, \t\tflexspi_port_t port, uint32_t freq_hz) { \tstruct memc_flexspi_data *data = dev->data; \tuint32_t rate; \tuint32_t key; \tint ret;  \t/* To reclock the FlexSPI, we should: \t * - disable the module \t * - set the new clock \t * - reenable the module \t * - reset the module \t * We CANNOT XIP at any point during this process \t */ \tkey = irq_lock(); \tmemc_flexspi_wait_bus_idle(dev);  \tret = clock_control_set_rate(data->clock_dev, data->clock_subsys, \t\t\t\t(clock_control_subsys_rate_t)freq_hz); \tif (ret< 0) { \t\tirq_unlock(key); \t\treturn ret; \t}  \t/* \t * We need to update the DLL value before we call clock_control_get_rate, \t * because this will cause XIP (flash reads) to occur. Although the \t * true flash clock is not known, assume the set_rate function programmed \t * a value close to what we requested. \t */ \tdevice_config->flexspiRootClk = freq_hz; \tFLEXSPI_UpdateDllValue(data->base, device_config, port); \tmemc_flexspi_reset(dev);  \tmemc_flexspi_wait_bus_idle(dev); \tret = clock_control_get_rate(data->clock_dev, data->clock_subsys,&rate); \tif (ret< 0) { \t\tirq_unlock(key); \t\treturn ret; \t}   \tdevice_config->flexspiRootClk = rate; \tFLEXSPI_UpdateDllValue(data->base, device_config, port);  \tmemc_flexspi_reset(dev);  \tirq_unlock(key);  \treturn 0; }  int memc_flexspi_set_device_config(const struct device *dev, \t\tconst flexspi_device_config_t *device_config, \t\tconst uint32_t *lut_array, \t\tuint8_t lut_count, \t\tflexspi_port_t port) { \tflexspi_device_config_t tmp_config; \tuint32_t tmp_lut[FLEXSPI_MAX_LUT]; \tstruct memc_flexspi_data *data = dev->data; \tconst uint32_t *lut_ptr = lut_array; \tuint8_t lut_used = 0U; \tunsigned int key = 0;  \tif (port>= kFLEXSPI_PortCount) { \t\tLOG_ERR(\"Invalid port number\"); \t\treturn -EINVAL; \t}  \tif (data->port_luts[port].lut_used< lut_count) { \t\t/* We cannot reuse the existing LUT slot, \t\t * Check if the LUT table will fit into the remaining LUT slots \t\t */ \t\tfor (uint8_t i = 0; i< kFLEXSPI_PortCount; i++) { \t\t\tlut_used += data->port_luts[i].lut_used; \t\t}  \t\tif ((lut_used + lut_count)> FLEXSPI_MAX_LUT) { \t\t\treturn -ENOBUFS; \t\t} \t}  \tdata->size[port] = device_config->flashSize * KB(1);  \tif (memc_flexspi_is_running_xip(dev)) { \t\t/* We need to avoid flash access while configuring the FlexSPI. \t\t * To do this, we will copy the LUT array into stack-allocated \t\t * temporary memory \t\t */ \t\tmemcpy(tmp_lut, lut_array, lut_count * MEMC_FLEXSPI_CMD_SIZE); \t\tlut_ptr = tmp_lut; \t}  \tmemcpy(&tmp_config, device_config, sizeof(tmp_config)); \t/* Update FlexSPI AWRSEQID and ARDSEQID values based on where the LUT \t * array will actually be loaded. \t */ \tif (data->port_luts[port].lut_used< lut_count) { \t\t/* Update lut offset with new value */ \t\tdata->port_luts[port].lut_offset = lut_used; \t} \t/* LUTs should only be installed on sequence boundaries, every \t * 4 entries. Round LUT usage up to nearest sequence \t */ \tdata->port_luts[port].lut_used = ROUND_UP(lut_count, 4); \ttmp_config.ARDSeqIndex += data->port_luts[port].lut_offset / MEMC_FLEXSPI_CMD_PER_SEQ; \ttmp_config.AWRSeqIndex += data->port_luts[port].lut_offset / MEMC_FLEXSPI_CMD_PER_SEQ;  \t/* Lock IRQs before reconfiguring FlexSPI, to prevent XIP */ \tkey = irq_lock();  \tFLEXSPI_SetFlashConfig(data->base,&tmp_config, port); \tFLEXSPI_UpdateLUT(data->base, data->port_luts[port].lut_offset, \t\t\t  lut_ptr, lut_count); \tirq_unlock(key);  \treturn 0; }  int memc_flexspi_reset(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \tFLEXSPI_SoftwareReset(data->base);  \treturn 0; }  int memc_flexspi_transfer(const struct device *dev, \t\tflexspi_transfer_t *transfer) { \tflexspi_transfer_t tmp; \tstruct memc_flexspi_data *data = dev->data; \tstatus_t status; \tuint32_t seq_off, addr_offset = 0U; \tint i;  \t/* Calculate sequence offset and address offset based on port */ \tseq_off = data->port_luts[transfer->port].lut_offset / \t\t\t\tMEMC_FLEXSPI_CMD_PER_SEQ; \tfor (i = 0; i< transfer->port; i++) { \t\taddr_offset += data->size[i]; \t}  \tif ((seq_off != 0) || (addr_offset != 0)) { \t\t/* Adjust device address and sequence index for transfer */ \t\tmemcpy(&tmp, transfer, sizeof(tmp)); \t\ttmp.seqIndex += seq_off; \t\ttmp.deviceAddress += addr_offset; \t\tstatus = FLEXSPI_TransferBlocking(data->base,&tmp); \t} else { \t\t/* Transfer does not need adjustment */ \t\tstatus = FLEXSPI_TransferBlocking(data->base, transfer); \t}  \tif (status != kStatus_Success) { \t\tLOG_ERR(\"Transfer error: %d\", status); \t\treturn -EIO; \t}  \treturn 0; }  void *memc_flexspi_get_ahb_address(const struct device *dev, \t\tflexspi_port_t port, off_t offset) { \tstruct memc_flexspi_data *data = dev->data; \tint i;  \tif (port>= kFLEXSPI_PortCount) { \t\tLOG_ERR(\"Invalid port number: %u\", port); \t\treturn NULL; \t}  \tfor (i = 0; i< port; i++) { \t\toffset += data->size[i]; \t}  #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_ADDRESS_SHIFT)&& \\ \t(FSL_FEATURE_FLEXSPI_SUPPORT_ADDRESS_SHIFT) \tif (data->base->FLSHCR0[port]& FLEXSPI_FLSHCR0_ADDRSHIFT_MASK) { \t\t/* Address shift is set, add 0x1000_0000 to AHB address */ \t\toffset += 0x10000000; \t} #endif  \treturn data->ahb_base + offset; }  static int memc_flexspi_init(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data; \tflexspi_config_t flexspi_config; \tuint32_t flash_sizes[kFLEXSPI_PortCount]; \tint ret; \tuint8_t i;  \t/* we should not configure the device we are running on */ \tif (memc_flexspi_is_running_xip(dev)) { \t\tif (!IS_ENABLED(CONFIG_MEMC_MCUX_FLEXSPI_INIT_XIP)) { \t\t\tLOG_DBG(\"XIP active on %s\n-literal|\", dev->name); \t\treturn 0; \t}  \t/* \t * SOCs such as the RT1064 and RT1024 have internal flash, and no pinmux \t * settings, continue if no pinctrl state found. \t */ \tint ret;  \tret = pinctrl_apply_state(data->pincfg, PINCTRL_STATE_DEFAULT); \tif (ret< 0&& ret != -ENOENT) { \t\treturn ret; \t}  \tFLEXSPI_GetDefaultConfig(&flexspi_config);  \tflexspi_config.ahbConfig.enableAHBBufferable = data->ahb_bufferable; \tflexspi_config.ahbConfig.enableAHBCachable = data->ahb_cacheable; \tflexspi_config.ahbConfig.enableAHBPrefetch = data->ahb_prefetch; \tflexspi_config.ahbConfig.enableReadAddressOpt = data->ahb_read_addr_opt; #if !(defined(FSL_FEATURE_FLEXSPI_HAS_NO_MCR0_COMBINATIONEN)&& \\ \tFSL_FEATURE_FLEXSPI_HAS_NO_MCR0_COMBINATIONEN) \tflexspi_config.enableCombination = data->combination_mode; #endif  #if !(defined(FSL_FEATURE_FLEXSPI_HAS_NO_MCR2_SCKBDIFFOPT)&& \\ \tFSL_FEATURE_FLEXSPI_HAS_NO_MCR2_SCKBDIFFOPT) \tflexspi_config.enableSckBDiffOpt = data->sck_differential_clock; #endif \tflexspi_config.rxSampleClock = data->rx_sample_clock; #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB)&& \\ FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB \tflexspi_config.rxSampleClockPortB = data->rx_sample_clock_b; #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_RXCLKSRC_DIFF)&& \\ \tFSL_FEATURE_FLEXSPI_SUPPORT_RXCLKSRC_DIFF \tif (flexspi_config.rxSampleClock != flexspi_config.rxSampleClockPortB) { \t\tflexspi_config.rxSampleClockDiff = true; \t} #endif #endif  \t/* Configure AHB RX buffers, if any configuration settings are present */ \t__ASSERT(data->buf_cfg_cnt< FSL_FEATURE_FLEXSPI_AHB_BUFFER_COUNT, \t\t\"\n+literal|\", dev->name); \t\t\treturn 0; \t\t} \t} \t/* \t * SOCs such as the RT1064 and RT1024 have internal flash, and no pinmux \t * settings, continue if no pinctrl state found. \t */ \tret = pinctrl_apply_state(data->pincfg, PINCTRL_STATE_DEFAULT); \tif (ret< 0&& ret != -ENOENT) { \t\treturn ret; \t}  \tFLEXSPI_GetDefaultConfig(&flexspi_config);  \tflexspi_config.ahbConfig.enableAHBBufferable = data->ahb_bufferable; \tflexspi_config.ahbConfig.enableAHBCachable = data->ahb_cacheable; \tflexspi_config.ahbConfig.enableAHBPrefetch = data->ahb_prefetch; \tflexspi_config.ahbConfig.enableReadAddressOpt = data->ahb_read_addr_opt; #if !(defined(FSL_FEATURE_FLEXSPI_HAS_NO_MCR0_COMBINATIONEN)&& \\ \tFSL_FEATURE_FLEXSPI_HAS_NO_MCR0_COMBINATIONEN) \tflexspi_config.enableCombination = data->combination_mode; #endif  #if !(defined(FSL_FEATURE_FLEXSPI_HAS_NO_MCR2_SCKBDIFFOPT)&& \\ \tFSL_FEATURE_FLEXSPI_HAS_NO_MCR2_SCKBDIFFOPT) \tflexspi_config.enableSckBDiffOpt = data->sck_differential_clock; #endif \tflexspi_config.rxSampleClock = data->rx_sample_clock; #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB)&& \\ FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB \tflexspi_config.rxSampleClockPortB = data->rx_sample_clock_b; #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_RXCLKSRC_DIFF)&& \\ \tFSL_FEATURE_FLEXSPI_SUPPORT_RXCLKSRC_DIFF \tif (flexspi_config.rxSampleClock != flexspi_config.rxSampleClockPortB) { \t\tflexspi_config.rxSampleClockDiff = true; \t} #endif #endif  \t/* Configure AHB RX buffers, if any configuration settings are present */ \t__ASSERT(data->buf_cfg_cnt< FSL_FEATURE_FLEXSPI_AHB_BUFFER_COUNT, \t\t\"\n-unit|); \tfor (uint8_t i = 0; i< data->buf_cfg_cnt; i++) { \t\t/* Should AHB prefetch up to buffer size? */ \t\tflexspi_config.ahbConfig.buffer[i].enablePrefetch = data->buf_cfg[i].prefetch; \t\t/* AHB access priority (used for suspending control of AHB prefetching )*/ \t\tflexspi_config.ahbConfig.buffer[i].priority = data->buf_cfg[i].priority; \t\t/* AHB master index, SOC specific */ \t\tflexspi_config.ahbConfig.buffer[i].masterIndex = data->buf_cfg[i].master_id; \t\t/* RX buffer allocation (total available buffer space is instance/SOC specific) */ \t\tflexspi_config.ahbConfig.buffer[i].bufferSize = data->buf_cfg[i].buf_size; \t}  \tFLEXSPI_Init(data->base,&flexspi_config);  \treturn 0; }  #ifdef CONFIG_PM_DEVICE static int memc_flexspi_pm_action(const struct device *dev, enum pm_device_action action) { \tstruct memc_flexspi_data *data = dev->data; \tint ret;  \tswitch (action) { \tcase PM_DEVICE_ACTION_RESUME: \t\tret = pinctrl_apply_state(data->pincfg, PINCTRL_STATE_DEFAULT); \t\tif (ret< 0&& ret != -ENOENT) { \t\t\treturn ret; \t\t} \t\tbreak; \tcase PM_DEVICE_ACTION_SUSPEND: \t\tret = pinctrl_apply_state(data->pincfg, PINCTRL_STATE_SLEEP); \t\tif (ret< 0&& ret != -ENOENT) { \t\t\treturn ret; \t\t} \t\tbreak; \tdefault: \t\treturn -ENOTSUP; \t}  \treturn 0; } #endif  #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB)&& \\ \tFSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB #define MEMC_FLEXSPI_RXCLK_B(inst) .rx_sample_clock_b = DT_INST_PROP(inst, rx_clock_source_b), #else #define MEMC_FLEXSPI_RXCLK_B(inst) #endif  #if defined(CONFIG_XIP)&& defined(CONFIG_FLASH_MCUX_FLEXSPI_XIP) /* Checks if image flash base address is in the FlexSPI AHB base region */ #define MEMC_FLEXSPI_CFG_XIP(node_id)\t\t\t\t\t\t\\ \t((CONFIG_FLASH_BASE_ADDRESS)>= DT_REG_ADDR_BY_IDX(node_id, 1))&&\t\\ \t((CONFIG_FLASH_BASE_ADDRESS)< (DT_REG_ADDR_BY_IDX(node_id, 1) +\t\\ \t\t\t\t\tDT_REG_SIZE_BY_IDX(node_id, 1)))  #else #define MEMC_FLEXSPI_CFG_XIP(node_id) false #endif  #define MEMC_FLEXSPI(n)\t\t\t\t\t\t\t\\ \tPINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t\\ \tstatic uint16_t  buf_cfg_##n[] =\t\t\t\t\\ \t\tDT_INST_PROP_OR(n, rx_buffer_config, {0});\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic struct memc_flexspi_data\t\t\t\t\t\\ \t\tmemc_flexspi_data_##n = {\t\t\t\t\\ \t\t.base = (FLEXSPI_Type *) DT_INST_REG_ADDR(n),\t\t\\ \t\t.xip = MEMC_FLEXSPI_CFG_XIP(DT_DRV_INST(n)),\t\t\\ \t\t.ahb_base = (uint8_t *) DT_INST_REG_ADDR_BY_IDX(n, 1),\t\\ \t\t.ahb_bufferable = DT_INST_PROP(n, ahb_bufferable),\t\\ \t\t.ahb_cacheable = DT_INST_PROP(n, ahb_cacheable),\t\\ \t\t.ahb_prefetch = DT_INST_PROP(n, ahb_prefetch),\t\t\\ \t\t.ahb_read_addr_opt = DT_INST_PROP(n, ahb_read_addr_opt),\\ \t\t.combination_mode = DT_INST_PROP(n, combination_mode),\t\\ \t\t.sck_differential_clock = DT_INST_PROP(n, sck_differential_clock),\t\\ \t\t.rx_sample_clock = DT_INST_PROP(n, rx_clock_source),\t\\ \t\tMEMC_FLEXSPI_RXCLK_B(n)                                 \\ \t\t.buf_cfg = (struct memc_flexspi_buf_cfg *)buf_cfg_##n,\t\\ \t\t.buf_cfg_cnt = sizeof(buf_cfg_##n) /\t\t\t\\ \t\t\tsizeof(struct memc_flexspi_buf_cfg),\t\t\\ \t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\\ \t\t.clock_dev = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(n)),     \\ \t\t.clock_subsys = (clock_control_subsys_t)                \\ \t\t\tDT_INST_CLOCKS_CELL(n, name),                   \\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(n, memc_flexspi_pm_action);\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n,\t\t\t\t\t\\ \t\t\t      memc_flexspi_init,\t\t\t\\ \t\t\t      PM_DEVICE_DT_INST_GET(n),\t\t\t\\&memc_flexspi_data_##n,\t\t\t\\ \t\t\t      NULL,\t\t\t\t\t\\ \t\t\t      POST_KERNEL,\t\t\t\t\\ \t\t\t      CONFIG_MEMC_MCUX_FLEXSPI_INIT_PRIORITY,\t\\ \t\t\t      NULL);  DT_INST_FOREACH_STATUS_OKAY(MEMC_FLEXSPI)\n+unit|); \tfor (i = 0; i< data->buf_cfg_cnt; i++) { \t\t/* Should AHB prefetch up to buffer size? */ \t\tflexspi_config.ahbConfig.buffer[i].enablePrefetch = data->buf_cfg[i].prefetch; \t\t/* AHB access priority (used for suspending control of AHB prefetching )*/ \t\tflexspi_config.ahbConfig.buffer[i].priority = data->buf_cfg[i].priority; \t\t/* AHB master index, SOC specific */ \t\tflexspi_config.ahbConfig.buffer[i].masterIndex = data->buf_cfg[i].master_id; \t\t/* RX buffer allocation (total available buffer space is instance/SOC specific) */ \t\tflexspi_config.ahbConfig.buffer[i].bufferSize = data->buf_cfg[i].buf_size; \t}  \tif (memc_flexspi_is_running_xip(dev)) { \t\t/* Save flash sizes- FlexSPI init will reset them */ \t\tfor (i = 0; i< kFLEXSPI_PortCount; i++) { \t\t\tflash_sizes[i] = data->base->FLSHCR0[i]; \t\t} \t}  \tFLEXSPI_Init(data->base,&flexspi_config);  \tif (memc_flexspi_is_running_xip(dev)) { \t\t/* Restore flash sizes */ \t\tfor (i = 0; i< kFLEXSPI_PortCount; i++) { \t\t\tdata->base->FLSHCR0[i] = flash_sizes[i]; \t\t}  \t\t/* Reenable FLEXSPI module */ \t\tdata->base->MCR0&= ~FLEXSPI_MCR0_MDIS_MASK; \t}  \treturn 0; }  #ifdef CONFIG_PM_DEVICE static int memc_flexspi_pm_action(const struct device *dev, enum pm_device_action action) { \tstruct memc_flexspi_data *data = dev->data; \tint ret;  \tswitch (action) { \tcase PM_DEVICE_ACTION_RESUME: \t\tret = pinctrl_apply_state(data->pincfg, PINCTRL_STATE_DEFAULT); \t\tif (ret< 0&& ret != -ENOENT) { \t\t\treturn ret; \t\t} \t\tbreak; \tcase PM_DEVICE_ACTION_SUSPEND: \t\tret = pinctrl_apply_state(data->pincfg, PINCTRL_STATE_SLEEP); \t\tif (ret< 0&& ret != -ENOENT) { \t\t\treturn ret; \t\t} \t\tbreak; \tdefault: \t\treturn -ENOTSUP; \t}  \treturn 0; } #endif  #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB)&& \\ \tFSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB #define MEMC_FLEXSPI_RXCLK_B(inst) .rx_sample_clock_b = DT_INST_PROP(inst, rx_clock_source_b), #else #define MEMC_FLEXSPI_RXCLK_B(inst) #endif  #if defined(CONFIG_XIP)&& defined(CONFIG_FLASH_MCUX_FLEXSPI_XIP) /* Checks if image flash base address is in the FlexSPI AHB base region */ #define MEMC_FLEXSPI_CFG_XIP(node_id)\t\t\t\t\t\t\\ \t((CONFIG_FLASH_BASE_ADDRESS)>= DT_REG_ADDR_BY_IDX(node_id, 1))&&\t\\ \t((CONFIG_FLASH_BASE_ADDRESS)< (DT_REG_ADDR_BY_IDX(node_id, 1) +\t\\ \t\t\t\t\tDT_REG_SIZE_BY_IDX(node_id, 1)))  #else #define MEMC_FLEXSPI_CFG_XIP(node_id) false #endif  #define MEMC_FLEXSPI(n)\t\t\t\t\t\t\t\\ \tPINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t\\ \tstatic uint16_t  buf_cfg_##n[] =\t\t\t\t\\ \t\tDT_INST_PROP_OR(n, rx_buffer_config, {0});\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic struct memc_flexspi_data\t\t\t\t\t\\ \t\tmemc_flexspi_data_##n = {\t\t\t\t\\ \t\t.base = (FLEXSPI_Type *) DT_INST_REG_ADDR(n),\t\t\\ \t\t.xip = MEMC_FLEXSPI_CFG_XIP(DT_DRV_INST(n)),\t\t\\ \t\t.ahb_base = (uint8_t *) DT_INST_REG_ADDR_BY_IDX(n, 1),\t\\ \t\t.ahb_bufferable = DT_INST_PROP(n, ahb_bufferable),\t\\ \t\t.ahb_cacheable = DT_INST_PROP(n, ahb_cacheable),\t\\ \t\t.ahb_prefetch = DT_INST_PROP(n, ahb_prefetch),\t\t\\ \t\t.ahb_read_addr_opt = DT_INST_PROP(n, ahb_read_addr_opt),\\ \t\t.combination_mode = DT_INST_PROP(n, combination_mode),\t\\ \t\t.sck_differential_clock = DT_INST_PROP(n, sck_differential_clock),\t\\ \t\t.rx_sample_clock = DT_INST_PROP(n, rx_clock_source),\t\\ \t\tMEMC_FLEXSPI_RXCLK_B(n)                                 \\ \t\t.buf_cfg = (struct memc_flexspi_buf_cfg *)buf_cfg_##n,\t\\ \t\t.buf_cfg_cnt = sizeof(buf_cfg_##n) /\t\t\t\\ \t\t\tsizeof(struct memc_flexspi_buf_cfg),\t\t\\ \t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\\ \t\t.clock_dev = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(n)),     \\ \t\t.clock_subsys = (clock_control_subsys_t)                \\ \t\t\tDT_INST_CLOCKS_CELL(n, name),                   \\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(n, memc_flexspi_pm_action);\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n,\t\t\t\t\t\\ \t\t\t      memc_flexspi_init,\t\t\t\\ \t\t\t      PM_DEVICE_DT_INST_GET(n),\t\t\t\\&memc_flexspi_data_##n,\t\t\t\\ \t\t\t      NULL,\t\t\t\t\t\\ \t\t\t      POST_KERNEL,\t\t\t\t\\ \t\t\t      CONFIG_MEMC_MCUX_FLEXSPI_INIT_PRIORITY,\t\\ \t\t\t      NULL);  DT_INST_FOREACH_STATUS_OKAY(MEMC_FLEXSPI)\nThe issue was with: drivers: memc: memc_mcux_flexspi: support initializing FLEXSPI when XIP\n\nAdd support for initializing the FLEXSPI when using a flash attached to\nthe FLEXSPI for XIP. This option is guarded behind a Kconfig, as\nenabling it is dangerous and requires special care be taken by the user\nto ensure that the configuration of pins and FLEXSPI settings will not\nbreak support for reading the attached flash, as this will break XIP\nsupport."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: memc: use custom initialization priority for FLEXSPI\n\nUse custom initialization priority for FLEXSPI MEMC driver. This may be\nneeded when the MEMC driver must initialize before a flash driver, and\nbefore another MEMC driver (for an attached device, like PSRAM) Please fix this issue.",
  "input": "Faulty tokenized code:\n\tbool \"MCUX FlexSPI ISSI IS66WVQ8M4 pSRAM driver\"\n\tdefault y\n\tdepends on DT_HAS_NXP_IMX_FLEXSPI_IS66WVQ8M4_ENABLED\n\tselect MEMC_MCUX_FLEXSPI\n\nconfig MEMC_MCUX_FLEXSPI\n\tbool\n\tselect PINCTRL\n\nendif # DT_HAS_NXP_IMX_FLEXSPI_ENABLED\nname|count\nname|exceeded\nliteral|\"\nend_while\n\nunit|); \tfor (uint8_t i = 0; i< data->buf_cfg_cnt; i++) { \t\t/* Should AHB prefetch up to buffer size? */ \t\tflexspi_config.ahbConfig.buffer[i].enablePrefetch = data->buf_cfg[i].prefetch; \t\t/* AHB access priority (used for suspending control of AHB prefetching )*/ \t\tflexspi_config.ahbConfig.buffer[i].priority = data->buf_cfg[i].priority; \t\t/* AHB master index, SOC specific */ \t\tflexspi_config.ahbConfig.buffer[i].masterIndex = data->buf_cfg[i].master_id; \t\t/* RX buffer allocation (total available buffer space is instance/SOC specific) */ \t\tflexspi_config.ahbConfig.buffer[i].bufferSize = data->buf_cfg[i].buf_size; \t}  \tFLEXSPI_Init(data->base,&flexspi_config);  \treturn 0; }  #ifdef CONFIG_PM_DEVICE static int memc_flexspi_pm_action(const struct device *dev, enum pm_device_action action) { \tstruct memc_flexspi_data *data = dev->data; \tint ret;  \tswitch (action) { \tcase PM_DEVICE_ACTION_RESUME: \t\tret = pinctrl_apply_state(data->pincfg, PINCTRL_STATE_DEFAULT); \t\tif (ret< 0&& ret != -ENOENT) { \t\t\treturn ret; \t\t} \t\tbreak; \tcase PM_DEVICE_ACTION_SUSPEND: \t\tret = pinctrl_apply_state(data->pincfg, PINCTRL_STATE_SLEEP); \t\tif (ret< 0&& ret != -ENOENT) { \t\t\treturn ret; \t\t} \t\tbreak; \tdefault: \t\treturn -ENOTSUP; \t}  \treturn 0; } #endif  #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB)&& \\ \tFSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB #define MEMC_FLEXSPI_RXCLK_B(inst) .rx_sample_clock_b = DT_INST_PROP(inst, rx_clock_source_b), #else #define MEMC_FLEXSPI_RXCLK_B(inst) #endif  #if defined(CONFIG_XIP)&& defined(CONFIG_FLASH_MCUX_FLEXSPI_XIP) /* Checks if image flash base address is in the FlexSPI AHB base region */ #define MEMC_FLEXSPI_CFG_XIP(node_id)\t\t\t\t\t\t\\ \t((CONFIG_FLASH_BASE_ADDRESS)>= DT_REG_ADDR_BY_IDX(node_id, 1))&&\t\\ \t((CONFIG_FLASH_BASE_ADDRESS)< (DT_REG_ADDR_BY_IDX(node_id, 1) +\t\\ \t\t\t\t\tDT_REG_SIZE_BY_IDX(node_id, 1)))  #else #define MEMC_FLEXSPI_CFG_XIP(node_id) false #endif  #define MEMC_FLEXSPI(n)\t\t\t\t\t\t\t\\ \tPINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t\\ \tstatic uint16_t  buf_cfg_##n[] =\t\t\t\t\\ \t\tDT_INST_PROP_OR(n, rx_buffer_config, {0});\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic struct memc_flexspi_data\t\t\t\t\t\\ \t\tmemc_flexspi_data_##n = {\t\t\t\t\\ \t\t.base = (FLEXSPI_Type *) DT_INST_REG_ADDR(n),\t\t\\ \t\t.xip = MEMC_FLEXSPI_CFG_XIP(DT_DRV_INST(n)),\t\t\\ \t\t.ahb_base = (uint8_t *) DT_INST_REG_ADDR_BY_IDX(n, 1),\t\\ \t\t.ahb_bufferable = DT_INST_PROP(n, ahb_bufferable),\t\\ \t\t.ahb_cacheable = DT_INST_PROP(n, ahb_cacheable),\t\\ \t\t.ahb_prefetch = DT_INST_PROP(n, ahb_prefetch),\t\t\\ \t\t.ahb_read_addr_opt = DT_INST_PROP(n, ahb_read_addr_opt),\\ \t\t.combination_mode = DT_INST_PROP(n, combination_mode),\t\\ \t\t.sck_differential_clock = DT_INST_PROP(n, sck_differential_clock),\t\\ \t\t.rx_sample_clock = DT_INST_PROP(n, rx_clock_source),\t\\ \t\tMEMC_FLEXSPI_RXCLK_B(n)                                 \\ \t\t.buf_cfg = (struct memc_flexspi_buf_cfg *)buf_cfg_##n,\t\\ \t\t.buf_cfg_cnt = sizeof(buf_cfg_##n) /\t\t\t\\ \t\t\tsizeof(struct memc_flexspi_buf_cfg),\t\t\\ \t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\\ \t\t.clock_dev = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(n)),     \\ \t\t.clock_subsys = (clock_control_subsys_t)                \\ \t\t\tDT_INST_CLOCKS_CELL(n, name),                   \\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(n, memc_flexspi_pm_action);\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n,\t\t\t\t\t\\ \t\t\t      memc_flexspi_init,\t\t\t\\ \t\t\t      PM_DEVICE_DT_INST_GET(n),\t\t\t\\&memc_flexspi_data_##n,\t\t\t\\ \t\t\t      NULL,\t\t\t\t\t\\ \t\t\t      POST_KERNEL,\t\t\t\t\\ \t\t\t      CONFIG_MEMC_INIT_PRIORITY,\t\\ \t\t\t      NULL);  DT_INST_FOREACH_STATUS_OKAY(MEMC_FLEXSPI)\nend_unit\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n+config MEMC_MCUX_FLEXSPI_INIT_PRIORITY\n+\tint \"MCUX FLEXSPI MEMC driver initialization priority\"\n+\tdefault MEMC_INIT_PRIORITY\n+\thelp\n+\t  Initialization priority for FlexSPI MEMC driver. In cases where the\n+\t  flash driver must initialize before the MEMC RAM driver,\n+\t  initialization priorities can be set such that\n+\t  MEMC_MCUX_FLEXSPI_INIT_PRIORITY < FLASH_INIT_PRIORITY <\n+\t  MEMC_INIT_PRIORITY\n+\n-unit|); \tfor (uint8_t i = 0; i< data->buf_cfg_cnt; i++) { \t\t/* Should AHB prefetch up to buffer size? */ \t\tflexspi_config.ahbConfig.buffer[i].enablePrefetch = data->buf_cfg[i].prefetch; \t\t/* AHB access priority (used for suspending control of AHB prefetching )*/ \t\tflexspi_config.ahbConfig.buffer[i].priority = data->buf_cfg[i].priority; \t\t/* AHB master index, SOC specific */ \t\tflexspi_config.ahbConfig.buffer[i].masterIndex = data->buf_cfg[i].master_id; \t\t/* RX buffer allocation (total available buffer space is instance/SOC specific) */ \t\tflexspi_config.ahbConfig.buffer[i].bufferSize = data->buf_cfg[i].buf_size; \t}  \tFLEXSPI_Init(data->base,&flexspi_config);  \treturn 0; }  #ifdef CONFIG_PM_DEVICE static int memc_flexspi_pm_action(const struct device *dev, enum pm_device_action action) { \tstruct memc_flexspi_data *data = dev->data; \tint ret;  \tswitch (action) { \tcase PM_DEVICE_ACTION_RESUME: \t\tret = pinctrl_apply_state(data->pincfg, PINCTRL_STATE_DEFAULT); \t\tif (ret< 0&& ret != -ENOENT) { \t\t\treturn ret; \t\t} \t\tbreak; \tcase PM_DEVICE_ACTION_SUSPEND: \t\tret = pinctrl_apply_state(data->pincfg, PINCTRL_STATE_SLEEP); \t\tif (ret< 0&& ret != -ENOENT) { \t\t\treturn ret; \t\t} \t\tbreak; \tdefault: \t\treturn -ENOTSUP; \t}  \treturn 0; } #endif  #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB)&& \\ \tFSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB #define MEMC_FLEXSPI_RXCLK_B(inst) .rx_sample_clock_b = DT_INST_PROP(inst, rx_clock_source_b), #else #define MEMC_FLEXSPI_RXCLK_B(inst) #endif  #if defined(CONFIG_XIP)&& defined(CONFIG_FLASH_MCUX_FLEXSPI_XIP) /* Checks if image flash base address is in the FlexSPI AHB base region */ #define MEMC_FLEXSPI_CFG_XIP(node_id)\t\t\t\t\t\t\\ \t((CONFIG_FLASH_BASE_ADDRESS)>= DT_REG_ADDR_BY_IDX(node_id, 1))&&\t\\ \t((CONFIG_FLASH_BASE_ADDRESS)< (DT_REG_ADDR_BY_IDX(node_id, 1) +\t\\ \t\t\t\t\tDT_REG_SIZE_BY_IDX(node_id, 1)))  #else #define MEMC_FLEXSPI_CFG_XIP(node_id) false #endif  #define MEMC_FLEXSPI(n)\t\t\t\t\t\t\t\\ \tPINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t\\ \tstatic uint16_t  buf_cfg_##n[] =\t\t\t\t\\ \t\tDT_INST_PROP_OR(n, rx_buffer_config, {0});\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic struct memc_flexspi_data\t\t\t\t\t\\ \t\tmemc_flexspi_data_##n = {\t\t\t\t\\ \t\t.base = (FLEXSPI_Type *) DT_INST_REG_ADDR(n),\t\t\\ \t\t.xip = MEMC_FLEXSPI_CFG_XIP(DT_DRV_INST(n)),\t\t\\ \t\t.ahb_base = (uint8_t *) DT_INST_REG_ADDR_BY_IDX(n, 1),\t\\ \t\t.ahb_bufferable = DT_INST_PROP(n, ahb_bufferable),\t\\ \t\t.ahb_cacheable = DT_INST_PROP(n, ahb_cacheable),\t\\ \t\t.ahb_prefetch = DT_INST_PROP(n, ahb_prefetch),\t\t\\ \t\t.ahb_read_addr_opt = DT_INST_PROP(n, ahb_read_addr_opt),\\ \t\t.combination_mode = DT_INST_PROP(n, combination_mode),\t\\ \t\t.sck_differential_clock = DT_INST_PROP(n, sck_differential_clock),\t\\ \t\t.rx_sample_clock = DT_INST_PROP(n, rx_clock_source),\t\\ \t\tMEMC_FLEXSPI_RXCLK_B(n)                                 \\ \t\t.buf_cfg = (struct memc_flexspi_buf_cfg *)buf_cfg_##n,\t\\ \t\t.buf_cfg_cnt = sizeof(buf_cfg_##n) /\t\t\t\\ \t\t\tsizeof(struct memc_flexspi_buf_cfg),\t\t\\ \t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\\ \t\t.clock_dev = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(n)),     \\ \t\t.clock_subsys = (clock_control_subsys_t)                \\ \t\t\tDT_INST_CLOCKS_CELL(n, name),                   \\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(n, memc_flexspi_pm_action);\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n,\t\t\t\t\t\\ \t\t\t      memc_flexspi_init,\t\t\t\\ \t\t\t      PM_DEVICE_DT_INST_GET(n),\t\t\t\\&memc_flexspi_data_##n,\t\t\t\\ \t\t\t      NULL,\t\t\t\t\t\\ \t\t\t      POST_KERNEL,\t\t\t\t\\ \t\t\t      CONFIG_MEMC_INIT_PRIORITY,\t\\ \t\t\t      NULL);  DT_INST_FOREACH_STATUS_OKAY(MEMC_FLEXSPI)\n+unit|); \tfor (uint8_t i = 0; i< data->buf_cfg_cnt; i++) { \t\t/* Should AHB prefetch up to buffer size? */ \t\tflexspi_config.ahbConfig.buffer[i].enablePrefetch = data->buf_cfg[i].prefetch; \t\t/* AHB access priority (used for suspending control of AHB prefetching )*/ \t\tflexspi_config.ahbConfig.buffer[i].priority = data->buf_cfg[i].priority; \t\t/* AHB master index, SOC specific */ \t\tflexspi_config.ahbConfig.buffer[i].masterIndex = data->buf_cfg[i].master_id; \t\t/* RX buffer allocation (total available buffer space is instance/SOC specific) */ \t\tflexspi_config.ahbConfig.buffer[i].bufferSize = data->buf_cfg[i].buf_size; \t}  \tFLEXSPI_Init(data->base,&flexspi_config);  \treturn 0; }  #ifdef CONFIG_PM_DEVICE static int memc_flexspi_pm_action(const struct device *dev, enum pm_device_action action) { \tstruct memc_flexspi_data *data = dev->data; \tint ret;  \tswitch (action) { \tcase PM_DEVICE_ACTION_RESUME: \t\tret = pinctrl_apply_state(data->pincfg, PINCTRL_STATE_DEFAULT); \t\tif (ret< 0&& ret != -ENOENT) { \t\t\treturn ret; \t\t} \t\tbreak; \tcase PM_DEVICE_ACTION_SUSPEND: \t\tret = pinctrl_apply_state(data->pincfg, PINCTRL_STATE_SLEEP); \t\tif (ret< 0&& ret != -ENOENT) { \t\t\treturn ret; \t\t} \t\tbreak; \tdefault: \t\treturn -ENOTSUP; \t}  \treturn 0; } #endif  #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB)&& \\ \tFSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB #define MEMC_FLEXSPI_RXCLK_B(inst) .rx_sample_clock_b = DT_INST_PROP(inst, rx_clock_source_b), #else #define MEMC_FLEXSPI_RXCLK_B(inst) #endif  #if defined(CONFIG_XIP)&& defined(CONFIG_FLASH_MCUX_FLEXSPI_XIP) /* Checks if image flash base address is in the FlexSPI AHB base region */ #define MEMC_FLEXSPI_CFG_XIP(node_id)\t\t\t\t\t\t\\ \t((CONFIG_FLASH_BASE_ADDRESS)>= DT_REG_ADDR_BY_IDX(node_id, 1))&&\t\\ \t((CONFIG_FLASH_BASE_ADDRESS)< (DT_REG_ADDR_BY_IDX(node_id, 1) +\t\\ \t\t\t\t\tDT_REG_SIZE_BY_IDX(node_id, 1)))  #else #define MEMC_FLEXSPI_CFG_XIP(node_id) false #endif  #define MEMC_FLEXSPI(n)\t\t\t\t\t\t\t\\ \tPINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t\\ \tstatic uint16_t  buf_cfg_##n[] =\t\t\t\t\\ \t\tDT_INST_PROP_OR(n, rx_buffer_config, {0});\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic struct memc_flexspi_data\t\t\t\t\t\\ \t\tmemc_flexspi_data_##n = {\t\t\t\t\\ \t\t.base = (FLEXSPI_Type *) DT_INST_REG_ADDR(n),\t\t\\ \t\t.xip = MEMC_FLEXSPI_CFG_XIP(DT_DRV_INST(n)),\t\t\\ \t\t.ahb_base = (uint8_t *) DT_INST_REG_ADDR_BY_IDX(n, 1),\t\\ \t\t.ahb_bufferable = DT_INST_PROP(n, ahb_bufferable),\t\\ \t\t.ahb_cacheable = DT_INST_PROP(n, ahb_cacheable),\t\\ \t\t.ahb_prefetch = DT_INST_PROP(n, ahb_prefetch),\t\t\\ \t\t.ahb_read_addr_opt = DT_INST_PROP(n, ahb_read_addr_opt),\\ \t\t.combination_mode = DT_INST_PROP(n, combination_mode),\t\\ \t\t.sck_differential_clock = DT_INST_PROP(n, sck_differential_clock),\t\\ \t\t.rx_sample_clock = DT_INST_PROP(n, rx_clock_source),\t\\ \t\tMEMC_FLEXSPI_RXCLK_B(n)                                 \\ \t\t.buf_cfg = (struct memc_flexspi_buf_cfg *)buf_cfg_##n,\t\\ \t\t.buf_cfg_cnt = sizeof(buf_cfg_##n) /\t\t\t\\ \t\t\tsizeof(struct memc_flexspi_buf_cfg),\t\t\\ \t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\\ \t\t.clock_dev = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(n)),     \\ \t\t.clock_subsys = (clock_control_subsys_t)                \\ \t\t\tDT_INST_CLOCKS_CELL(n, name),                   \\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(n, memc_flexspi_pm_action);\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n,\t\t\t\t\t\\ \t\t\t      memc_flexspi_init,\t\t\t\\ \t\t\t      PM_DEVICE_DT_INST_GET(n),\t\t\t\\&memc_flexspi_data_##n,\t\t\t\\ \t\t\t      NULL,\t\t\t\t\t\\ \t\t\t      POST_KERNEL,\t\t\t\t\\ \t\t\t      CONFIG_MEMC_MCUX_FLEXSPI_INIT_PRIORITY,\t\\ \t\t\t      NULL);  DT_INST_FOREACH_STATUS_OKAY(MEMC_FLEXSPI)\nThe issue was with: drivers: memc: use custom initialization priority for FLEXSPI\n\nUse custom initialization priority for FLEXSPI MEMC driver. This may be\nneeded when the MEMC driver must initialize before a flash driver, and\nbefore another MEMC driver (for an attached device, like PSRAM)"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: memc: memc_mcux_flexspi: correctly handle multi-device usage\n\nWhen multiple devices are used, the FLEXSPI will place their address\nspaces sequentially (based on the chip select port used). Additionally,\neach device must use different sections of the FLEXSPI LUT table.\n\nFix the following calculation issues with multi-device usage:\n- correct calculation of LUT sequence indices for AHB commands\n- correctly add address and sequence offset when submitting FLEXSPI IP\n  transfer Please fix this issue.",
  "input": "Faulty tokenized code:\nname|read\noperator|-\nend_expr_stmt\n\nbegin_while\nwhile|while-write hazards. This configuration is not recommended.\" #endif  #define FLEXSPI_MAX_LUT 64U  LOG_MODULE_REGISTER(memc_flexspi, CONFIG_MEMC_LOG_LEVEL);  struct memc_flexspi_buf_cfg { \tuint16_t prefetch; \tuint16_t priority; \tuint16_t master_id; \tuint16_t buf_size; } __packed;  /* Structure tracking LUT offset and usage per each port */ struct port_lut { \tuint8_t lut_offset; \tuint8_t lut_used; };  /* flexspi device data should be stored in RAM to avoid read-while-write hazards */ struct memc_flexspi_data { \tFLEXSPI_Type *base; \tuint8_t *ahb_base; \tbool xip; \tbool ahb_bufferable; \tbool ahb_cacheable; \tbool ahb_prefetch; \tbool ahb_read_addr_opt; \tbool combination_mode; \tbool sck_differential_clock; \tflexspi_read_sample_clock_t rx_sample_clock; #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB)&& \\ FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB \tflexspi_read_sample_clock_t rx_sample_clock_b; #endif \tconst struct pinctrl_dev_config *pincfg; \tsize_t size[kFLEXSPI_PortCount]; \tstruct port_lut port_luts[kFLEXSPI_PortCount]; \tstruct memc_flexspi_buf_cfg *buf_cfg; \tuint8_t buf_cfg_cnt; \tconst struct device *clock_dev; \tclock_control_subsys_t clock_subsys; };  void memc_flexspi_wait_bus_idle(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \twhile (false == FLEXSPI_GetBusIdleStatus(data->base)) { \t} }  bool memc_flexspi_is_running_xip(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \treturn data->xip; }  int memc_flexspi_update_clock(const struct device *dev, \t\tflexspi_device_config_t *device_config, \t\tflexspi_port_t port, uint32_t freq_hz) { \tstruct memc_flexspi_data *data = dev->data; \tuint32_t rate; \tuint32_t key; \tint ret;  \t/* To reclock the FlexSPI, we should: \t * - disable the module \t * - set the new clock \t * - reenable the module \t * - reset the module \t * We CANNOT XIP at any point during this process \t */ \tkey = irq_lock(); \tmemc_flexspi_wait_bus_idle(dev);  \tret = clock_control_set_rate(data->clock_dev, data->clock_subsys, \t\t\t\t(clock_control_subsys_rate_t)freq_hz); \tif (ret< 0) { \t\tirq_unlock(key); \t\treturn ret; \t}  \t/* \t * We need to update the DLL value before we call clock_control_get_rate, \t * because this will cause XIP (flash reads) to occur. Although the \t * true flash clock is not known, assume the set_rate function programmed \t * a value close to what we requested. \t */ \tdevice_config->flexspiRootClk = freq_hz; \tFLEXSPI_UpdateDllValue(data->base, device_config, port); \tmemc_flexspi_reset(dev);  \tmemc_flexspi_wait_bus_idle(dev); \tret = clock_control_get_rate(data->clock_dev, data->clock_subsys,&rate); \tif (ret< 0) { \t\tirq_unlock(key); \t\treturn ret; \t}   \tdevice_config->flexspiRootClk = rate; \tFLEXSPI_UpdateDllValue(data->base, device_config, port);  \tmemc_flexspi_reset(dev);  \tirq_unlock(key);  \treturn 0; }  int memc_flexspi_set_device_config(const struct device *dev, \t\tconst flexspi_device_config_t *device_config, \t\tconst uint32_t *lut_array, \t\tuint8_t lut_count, \t\tflexspi_port_t port) { \tflexspi_device_config_t tmp_config; \tuint32_t tmp_lut[FLEXSPI_MAX_LUT]; \tstruct memc_flexspi_data *data = dev->data; \tconst uint32_t *lut_ptr = lut_array; \tuint8_t lut_used = 0U; \tunsigned int key = 0;  \tif (port>= kFLEXSPI_PortCount) { \t\tLOG_ERR(\"Invalid port number\"); \t\treturn -EINVAL; \t}  \tif (data->port_luts[port].lut_used< lut_count) { \t\t/* We cannot reuse the existing LUT slot, \t\t * Check if the LUT table will fit into the remaining LUT slots \t\t */ \t\tfor (uint8_t i = 0; i< kFLEXSPI_PortCount; i++) { \t\t\tlut_used += data->port_luts[i].lut_used; \t\t}  \t\tif ((lut_used + lut_count)> FLEXSPI_MAX_LUT) { \t\t\treturn -ENOBUFS; \t\t} \t}  \tdata->size[port] = device_config->flashSize * KB(1);  \tif (memc_flexspi_is_running_xip(dev)) { \t\t/* We need to avoid flash access while configuring the FlexSPI. \t\t * To do this, we will copy the LUT array into stack-allocated \t\t * temporary memory \t\t */ \t\tmemcpy(tmp_lut, lut_array, lut_count * MEMC_FLEXSPI_CMD_SIZE); \t\tlut_ptr = tmp_lut; \t}  \tmemcpy(&tmp_config, device_config, sizeof(tmp_config)); \t/* Update FlexSPI AWRSEQID and ARDSEQID values based on where the LUT \t * array will actually be loaded. \t */ \tif (data->port_luts[port].lut_used< lut_count) { \t\t/* Update lut offset with new value */ \t\tdata->port_luts[port].lut_offset = lut_used; \t} \tdata->port_luts[port].lut_used = lut_count; \ttmp_config.ARDSeqIndex += data->port_luts[port].lut_offset; \ttmp_config.AWRSeqIndex += data->port_luts[port].lut_offset;  \t/* Lock IRQs before reconfiguring FlexSPI, to prevent XIP */ \tkey = irq_lock();  \tFLEXSPI_SetFlashConfig(data->base,&tmp_config, port); \tFLEXSPI_UpdateLUT(data->base, data->port_luts[port].lut_offset, \t\t\t  lut_ptr, lut_count); \tirq_unlock(key);  \treturn 0; }  int memc_flexspi_reset(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \tFLEXSPI_SoftwareReset(data->base);  \treturn 0; }  int memc_flexspi_transfer(const struct device *dev, \t\tflexspi_transfer_t *transfer) { \tstruct memc_flexspi_data *data = dev->data; \tstatus_t status;  \t/* Adjust transfer LUT index based on port */ \ttransfer->seqIndex += data->port_luts[transfer->port].lut_offset; \tstatus = FLEXSPI_TransferBlocking(data->base, transfer);  \tif (status != kStatus_Success) { \t\tLOG_ERR(\"Transfer error: %d\", status); \t\treturn -EIO; \t}  \treturn 0; }  void *memc_flexspi_get_ahb_address(const struct device *dev, \t\tflexspi_port_t port, off_t offset) { \tstruct memc_flexspi_data *data = dev->data; \tint i;  \tif (port>= kFLEXSPI_PortCount) { \t\tLOG_ERR(\"Invalid port number: %u\", port); \t\treturn NULL; \t}  \tfor (i = 0; i< port; i++) { \t\toffset += data->size[i]; \t}  #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_ADDRESS_SHIFT)&& \\ \t(FSL_FEATURE_FLEXSPI_SUPPORT_ADDRESS_SHIFT) \tif (data->base->FLSHCR0[port]& FLEXSPI_FLSHCR0_ADDRSHIFT_MASK) { \t\t/* Address shift is set, add 0x1000_0000 to AHB address */ \t\toffset += 0x10000000; \t} #endif  \treturn data->ahb_base + offset; }  static int memc_flexspi_init(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data; \tflexspi_config_t flexspi_config;  \t/* we should not configure the device we are running on */ \tif (memc_flexspi_is_running_xip(dev)) { \t\tLOG_DBG(\"XIP active on %s\noperator|,\nname|skipping\nname|init\nliteral|\", dev->name); \t\treturn 0; \t}  \t/* \t * SOCs such as the RT1064 and RT1024 have internal flash, and no pinmux \t * settings, continue if no pinctrl state found. \t */ \tint ret;  \tret = pinctrl_apply_state(data->pincfg, PINCTRL_STATE_DEFAULT); \tif (ret< 0&& ret != -ENOENT) { \t\treturn ret; \t}  \tFLEXSPI_GetDefaultConfig(&flexspi_config);  \tflexspi_config.ahbConfig.enableAHBBufferable = data->ahb_bufferable; \tflexspi_config.ahbConfig.enableAHBCachable = data->ahb_cacheable; \tflexspi_config.ahbConfig.enableAHBPrefetch = data->ahb_prefetch; \tflexspi_config.ahbConfig.enableReadAddressOpt = data->ahb_read_addr_opt; #if !(defined(FSL_FEATURE_FLEXSPI_HAS_NO_MCR0_COMBINATIONEN)&& \\ \tFSL_FEATURE_FLEXSPI_HAS_NO_MCR0_COMBINATIONEN) \tflexspi_config.enableCombination = data->combination_mode; #endif  #if !(defined(FSL_FEATURE_FLEXSPI_HAS_NO_MCR2_SCKBDIFFOPT)&& \\ \tFSL_FEATURE_FLEXSPI_HAS_NO_MCR2_SCKBDIFFOPT) \tflexspi_config.enableSckBDiffOpt = data->sck_differential_clock; #endif \tflexspi_config.rxSampleClock = data->rx_sample_clock; #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB)&& \\ FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB \tflexspi_config.rxSampleClockPortB = data->rx_sample_clock_b; #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_RXCLKSRC_DIFF)&& \\ \tFSL_FEATURE_FLEXSPI_SUPPORT_RXCLKSRC_DIFF \tif (flexspi_config.rxSampleClock != flexspi_config.rxSampleClockPortB) { \t\tflexspi_config.rxSampleClockDiff = true; \t} #endif #endif  \t/* Configure AHB RX buffers, if any configuration settings are present */ \t__ASSERT(data->buf_cfg_cnt< FSL_FEATURE_FLEXSPI_AHB_BUFFER_COUNT, \t\t\"\nname|Maximum",
  "result": "I corrected the issue in the code by changing the following tokens:\n-while|while-write hazards. This configuration is not recommended.\" #endif  #define FLEXSPI_MAX_LUT 64U  LOG_MODULE_REGISTER(memc_flexspi, CONFIG_MEMC_LOG_LEVEL);  struct memc_flexspi_buf_cfg { \tuint16_t prefetch; \tuint16_t priority; \tuint16_t master_id; \tuint16_t buf_size; } __packed;  /* Structure tracking LUT offset and usage per each port */ struct port_lut { \tuint8_t lut_offset; \tuint8_t lut_used; };  /* flexspi device data should be stored in RAM to avoid read-while-write hazards */ struct memc_flexspi_data { \tFLEXSPI_Type *base; \tuint8_t *ahb_base; \tbool xip; \tbool ahb_bufferable; \tbool ahb_cacheable; \tbool ahb_prefetch; \tbool ahb_read_addr_opt; \tbool combination_mode; \tbool sck_differential_clock; \tflexspi_read_sample_clock_t rx_sample_clock; #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB)&& \\ FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB \tflexspi_read_sample_clock_t rx_sample_clock_b; #endif \tconst struct pinctrl_dev_config *pincfg; \tsize_t size[kFLEXSPI_PortCount]; \tstruct port_lut port_luts[kFLEXSPI_PortCount]; \tstruct memc_flexspi_buf_cfg *buf_cfg; \tuint8_t buf_cfg_cnt; \tconst struct device *clock_dev; \tclock_control_subsys_t clock_subsys; };  void memc_flexspi_wait_bus_idle(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \twhile (false == FLEXSPI_GetBusIdleStatus(data->base)) { \t} }  bool memc_flexspi_is_running_xip(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \treturn data->xip; }  int memc_flexspi_update_clock(const struct device *dev, \t\tflexspi_device_config_t *device_config, \t\tflexspi_port_t port, uint32_t freq_hz) { \tstruct memc_flexspi_data *data = dev->data; \tuint32_t rate; \tuint32_t key; \tint ret;  \t/* To reclock the FlexSPI, we should: \t * - disable the module \t * - set the new clock \t * - reenable the module \t * - reset the module \t * We CANNOT XIP at any point during this process \t */ \tkey = irq_lock(); \tmemc_flexspi_wait_bus_idle(dev);  \tret = clock_control_set_rate(data->clock_dev, data->clock_subsys, \t\t\t\t(clock_control_subsys_rate_t)freq_hz); \tif (ret< 0) { \t\tirq_unlock(key); \t\treturn ret; \t}  \t/* \t * We need to update the DLL value before we call clock_control_get_rate, \t * because this will cause XIP (flash reads) to occur. Although the \t * true flash clock is not known, assume the set_rate function programmed \t * a value close to what we requested. \t */ \tdevice_config->flexspiRootClk = freq_hz; \tFLEXSPI_UpdateDllValue(data->base, device_config, port); \tmemc_flexspi_reset(dev);  \tmemc_flexspi_wait_bus_idle(dev); \tret = clock_control_get_rate(data->clock_dev, data->clock_subsys,&rate); \tif (ret< 0) { \t\tirq_unlock(key); \t\treturn ret; \t}   \tdevice_config->flexspiRootClk = rate; \tFLEXSPI_UpdateDllValue(data->base, device_config, port);  \tmemc_flexspi_reset(dev);  \tirq_unlock(key);  \treturn 0; }  int memc_flexspi_set_device_config(const struct device *dev, \t\tconst flexspi_device_config_t *device_config, \t\tconst uint32_t *lut_array, \t\tuint8_t lut_count, \t\tflexspi_port_t port) { \tflexspi_device_config_t tmp_config; \tuint32_t tmp_lut[FLEXSPI_MAX_LUT]; \tstruct memc_flexspi_data *data = dev->data; \tconst uint32_t *lut_ptr = lut_array; \tuint8_t lut_used = 0U; \tunsigned int key = 0;  \tif (port>= kFLEXSPI_PortCount) { \t\tLOG_ERR(\"Invalid port number\"); \t\treturn -EINVAL; \t}  \tif (data->port_luts[port].lut_used< lut_count) { \t\t/* We cannot reuse the existing LUT slot, \t\t * Check if the LUT table will fit into the remaining LUT slots \t\t */ \t\tfor (uint8_t i = 0; i< kFLEXSPI_PortCount; i++) { \t\t\tlut_used += data->port_luts[i].lut_used; \t\t}  \t\tif ((lut_used + lut_count)> FLEXSPI_MAX_LUT) { \t\t\treturn -ENOBUFS; \t\t} \t}  \tdata->size[port] = device_config->flashSize * KB(1);  \tif (memc_flexspi_is_running_xip(dev)) { \t\t/* We need to avoid flash access while configuring the FlexSPI. \t\t * To do this, we will copy the LUT array into stack-allocated \t\t * temporary memory \t\t */ \t\tmemcpy(tmp_lut, lut_array, lut_count * MEMC_FLEXSPI_CMD_SIZE); \t\tlut_ptr = tmp_lut; \t}  \tmemcpy(&tmp_config, device_config, sizeof(tmp_config)); \t/* Update FlexSPI AWRSEQID and ARDSEQID values based on where the LUT \t * array will actually be loaded. \t */ \tif (data->port_luts[port].lut_used< lut_count) { \t\t/* Update lut offset with new value */ \t\tdata->port_luts[port].lut_offset = lut_used; \t} \tdata->port_luts[port].lut_used = lut_count; \ttmp_config.ARDSeqIndex += data->port_luts[port].lut_offset; \ttmp_config.AWRSeqIndex += data->port_luts[port].lut_offset;  \t/* Lock IRQs before reconfiguring FlexSPI, to prevent XIP */ \tkey = irq_lock();  \tFLEXSPI_SetFlashConfig(data->base,&tmp_config, port); \tFLEXSPI_UpdateLUT(data->base, data->port_luts[port].lut_offset, \t\t\t  lut_ptr, lut_count); \tirq_unlock(key);  \treturn 0; }  int memc_flexspi_reset(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \tFLEXSPI_SoftwareReset(data->base);  \treturn 0; }  int memc_flexspi_transfer(const struct device *dev, \t\tflexspi_transfer_t *transfer) { \tstruct memc_flexspi_data *data = dev->data; \tstatus_t status;  \t/* Adjust transfer LUT index based on port */ \ttransfer->seqIndex += data->port_luts[transfer->port].lut_offset; \tstatus = FLEXSPI_TransferBlocking(data->base, transfer);  \tif (status != kStatus_Success) { \t\tLOG_ERR(\"Transfer error: %d\", status); \t\treturn -EIO; \t}  \treturn 0; }  void *memc_flexspi_get_ahb_address(const struct device *dev, \t\tflexspi_port_t port, off_t offset) { \tstruct memc_flexspi_data *data = dev->data; \tint i;  \tif (port>= kFLEXSPI_PortCount) { \t\tLOG_ERR(\"Invalid port number: %u\", port); \t\treturn NULL; \t}  \tfor (i = 0; i< port; i++) { \t\toffset += data->size[i]; \t}  #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_ADDRESS_SHIFT)&& \\ \t(FSL_FEATURE_FLEXSPI_SUPPORT_ADDRESS_SHIFT) \tif (data->base->FLSHCR0[port]& FLEXSPI_FLSHCR0_ADDRSHIFT_MASK) { \t\t/* Address shift is set, add 0x1000_0000 to AHB address */ \t\toffset += 0x10000000; \t} #endif  \treturn data->ahb_base + offset; }  static int memc_flexspi_init(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data; \tflexspi_config_t flexspi_config;  \t/* we should not configure the device we are running on */ \tif (memc_flexspi_is_running_xip(dev)) { \t\tLOG_DBG(\"XIP active on %s\n+while|while-write hazards. This configuration is not recommended.\" #endif  #define FLEXSPI_MAX_LUT 64U  LOG_MODULE_REGISTER(memc_flexspi, CONFIG_MEMC_LOG_LEVEL);  struct memc_flexspi_buf_cfg { \tuint16_t prefetch; \tuint16_t priority; \tuint16_t master_id; \tuint16_t buf_size; } __packed;  /* Structure tracking LUT offset and usage per each port */ struct port_lut { \tuint8_t lut_offset; \tuint8_t lut_used; };  /* flexspi device data should be stored in RAM to avoid read-while-write hazards */ struct memc_flexspi_data { \tFLEXSPI_Type *base; \tuint8_t *ahb_base; \tbool xip; \tbool ahb_bufferable; \tbool ahb_cacheable; \tbool ahb_prefetch; \tbool ahb_read_addr_opt; \tbool combination_mode; \tbool sck_differential_clock; \tflexspi_read_sample_clock_t rx_sample_clock; #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB)&& \\ FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB \tflexspi_read_sample_clock_t rx_sample_clock_b; #endif \tconst struct pinctrl_dev_config *pincfg; \tsize_t size[kFLEXSPI_PortCount]; \tstruct port_lut port_luts[kFLEXSPI_PortCount]; \tstruct memc_flexspi_buf_cfg *buf_cfg; \tuint8_t buf_cfg_cnt; \tconst struct device *clock_dev; \tclock_control_subsys_t clock_subsys; };  void memc_flexspi_wait_bus_idle(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \twhile (false == FLEXSPI_GetBusIdleStatus(data->base)) { \t} }  bool memc_flexspi_is_running_xip(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \treturn data->xip; }  int memc_flexspi_update_clock(const struct device *dev, \t\tflexspi_device_config_t *device_config, \t\tflexspi_port_t port, uint32_t freq_hz) { \tstruct memc_flexspi_data *data = dev->data; \tuint32_t rate; \tuint32_t key; \tint ret;  \t/* To reclock the FlexSPI, we should: \t * - disable the module \t * - set the new clock \t * - reenable the module \t * - reset the module \t * We CANNOT XIP at any point during this process \t */ \tkey = irq_lock(); \tmemc_flexspi_wait_bus_idle(dev);  \tret = clock_control_set_rate(data->clock_dev, data->clock_subsys, \t\t\t\t(clock_control_subsys_rate_t)freq_hz); \tif (ret< 0) { \t\tirq_unlock(key); \t\treturn ret; \t}  \t/* \t * We need to update the DLL value before we call clock_control_get_rate, \t * because this will cause XIP (flash reads) to occur. Although the \t * true flash clock is not known, assume the set_rate function programmed \t * a value close to what we requested. \t */ \tdevice_config->flexspiRootClk = freq_hz; \tFLEXSPI_UpdateDllValue(data->base, device_config, port); \tmemc_flexspi_reset(dev);  \tmemc_flexspi_wait_bus_idle(dev); \tret = clock_control_get_rate(data->clock_dev, data->clock_subsys,&rate); \tif (ret< 0) { \t\tirq_unlock(key); \t\treturn ret; \t}   \tdevice_config->flexspiRootClk = rate; \tFLEXSPI_UpdateDllValue(data->base, device_config, port);  \tmemc_flexspi_reset(dev);  \tirq_unlock(key);  \treturn 0; }  int memc_flexspi_set_device_config(const struct device *dev, \t\tconst flexspi_device_config_t *device_config, \t\tconst uint32_t *lut_array, \t\tuint8_t lut_count, \t\tflexspi_port_t port) { \tflexspi_device_config_t tmp_config; \tuint32_t tmp_lut[FLEXSPI_MAX_LUT]; \tstruct memc_flexspi_data *data = dev->data; \tconst uint32_t *lut_ptr = lut_array; \tuint8_t lut_used = 0U; \tunsigned int key = 0;  \tif (port>= kFLEXSPI_PortCount) { \t\tLOG_ERR(\"Invalid port number\"); \t\treturn -EINVAL; \t}  \tif (data->port_luts[port].lut_used< lut_count) { \t\t/* We cannot reuse the existing LUT slot, \t\t * Check if the LUT table will fit into the remaining LUT slots \t\t */ \t\tfor (uint8_t i = 0; i< kFLEXSPI_PortCount; i++) { \t\t\tlut_used += data->port_luts[i].lut_used; \t\t}  \t\tif ((lut_used + lut_count)> FLEXSPI_MAX_LUT) { \t\t\treturn -ENOBUFS; \t\t} \t}  \tdata->size[port] = device_config->flashSize * KB(1);  \tif (memc_flexspi_is_running_xip(dev)) { \t\t/* We need to avoid flash access while configuring the FlexSPI. \t\t * To do this, we will copy the LUT array into stack-allocated \t\t * temporary memory \t\t */ \t\tmemcpy(tmp_lut, lut_array, lut_count * MEMC_FLEXSPI_CMD_SIZE); \t\tlut_ptr = tmp_lut; \t}  \tmemcpy(&tmp_config, device_config, sizeof(tmp_config)); \t/* Update FlexSPI AWRSEQID and ARDSEQID values based on where the LUT \t * array will actually be loaded. \t */ \tif (data->port_luts[port].lut_used< lut_count) { \t\t/* Update lut offset with new value */ \t\tdata->port_luts[port].lut_offset = lut_used; \t} \t/* LUTs should only be installed on sequence boundaries, every \t * 4 entries. Round LUT usage up to nearest sequence \t */ \tdata->port_luts[port].lut_used = ROUND_UP(lut_count, 4); \ttmp_config.ARDSeqIndex += data->port_luts[port].lut_offset / MEMC_FLEXSPI_CMD_PER_SEQ; \ttmp_config.AWRSeqIndex += data->port_luts[port].lut_offset / MEMC_FLEXSPI_CMD_PER_SEQ;  \t/* Lock IRQs before reconfiguring FlexSPI, to prevent XIP */ \tkey = irq_lock();  \tFLEXSPI_SetFlashConfig(data->base,&tmp_config, port); \tFLEXSPI_UpdateLUT(data->base, data->port_luts[port].lut_offset, \t\t\t  lut_ptr, lut_count); \tirq_unlock(key);  \treturn 0; }  int memc_flexspi_reset(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \tFLEXSPI_SoftwareReset(data->base);  \treturn 0; }  int memc_flexspi_transfer(const struct device *dev, \t\tflexspi_transfer_t *transfer) { \tflexspi_transfer_t tmp; \tstruct memc_flexspi_data *data = dev->data; \tstatus_t status; \tuint32_t seq_off, addr_offset = 0U; \tint i;  \t/* Calculate sequence offset and address offset based on port */ \tseq_off = data->port_luts[transfer->port].lut_offset / \t\t\t\tMEMC_FLEXSPI_CMD_PER_SEQ; \tfor (i = 0; i< transfer->port; i++) { \t\taddr_offset += data->size[i]; \t}  \tif ((seq_off != 0) || (addr_offset != 0)) { \t\t/* Adjust device address and sequence index for transfer */ \t\tmemcpy(&tmp, transfer, sizeof(tmp)); \t\ttmp.seqIndex += seq_off; \t\ttmp.deviceAddress += addr_offset; \t\tstatus = FLEXSPI_TransferBlocking(data->base,&tmp); \t} else { \t\t/* Transfer does not need adjustment */ \t\tstatus = FLEXSPI_TransferBlocking(data->base, transfer); \t}  \tif (status != kStatus_Success) { \t\tLOG_ERR(\"Transfer error: %d\", status); \t\treturn -EIO; \t}  \treturn 0; }  void *memc_flexspi_get_ahb_address(const struct device *dev, \t\tflexspi_port_t port, off_t offset) { \tstruct memc_flexspi_data *data = dev->data; \tint i;  \tif (port>= kFLEXSPI_PortCount) { \t\tLOG_ERR(\"Invalid port number: %u\", port); \t\treturn NULL; \t}  \tfor (i = 0; i< port; i++) { \t\toffset += data->size[i]; \t}  #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_ADDRESS_SHIFT)&& \\ \t(FSL_FEATURE_FLEXSPI_SUPPORT_ADDRESS_SHIFT) \tif (data->base->FLSHCR0[port]& FLEXSPI_FLSHCR0_ADDRSHIFT_MASK) { \t\t/* Address shift is set, add 0x1000_0000 to AHB address */ \t\toffset += 0x10000000; \t} #endif  \treturn data->ahb_base + offset; }  static int memc_flexspi_init(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data; \tflexspi_config_t flexspi_config;  \t/* we should not configure the device we are running on */ \tif (memc_flexspi_is_running_xip(dev)) { \t\tLOG_DBG(\"XIP active on %s\nThe issue was with: drivers: memc: memc_mcux_flexspi: correctly handle multi-device usage\n\nWhen multiple devices are used, the FLEXSPI will place their address\nspaces sequentially (based on the chip select port used). Additionally,\neach device must use different sections of the FLEXSPI LUT table.\n\nFix the following calculation issues with multi-device usage:\n- correct calculation of LUT sequence indices for AHB commands\n- correctly add address and sequence offset when submitting FLEXSPI IP\n  transfer"
},{
  "instruction": "There is an issue in the following code. It relates to soc: nxp: rw: use correct mask for FLEXSPI clock setup divider\n\nMask for FLEXSPI clock divider was being used when setting the FLEXSPI\nclock selector value. Correct this to use the mask for the selector\ninstead of the divider. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|(\nname|CLKCTL0\noperator|->\nname|FLEXSPIFCLKSEL\noperator|&\nname|CLKCTL0_FLEXSPIFCLKDIV_DIV_MASK\noperator|)\nargument_list|,\noperator|(\nname|divider\noperator|+",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CLKCTL0_FLEXSPIFCLKDIV_DIV_MASK\n+name|CLKCTL0_FLEXSPIFCLKSEL_SEL_MASK\nThe issue was with: soc: nxp: rw: use correct mask for FLEXSPI clock setup divider\n\nMask for FLEXSPI clock divider was being used when setting the FLEXSPI\nclock selector value. Correct this to use the mask for the selector\ninstead of the divider."
},{
  "instruction": "There is an issue in the following code. It relates to driver: uart: native: fix stop_bits/databits mix\n\nCorrect a trivial bug and doxygen documentation error\nin which data_bits was missused instead of stop_bits. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nswitch|switch\ncondition|(\nname|cfg\noperator|->\nname|data_bits\ncondition|)\nblock|{\ncase|case\nname|UART_CFG_STOP_BITS_1\ncase|:\nblock|}\nblock|}\nend_function\n\nbegin_comment\ncomment|/**  * @brief Set the number of data bits in the termios structure  *  * @param ter  * @param stop_bits  *  */\nend_comment\n\nbegin_function\nDECL|function|native_tty_data_bits_set (struct termios * ter,enum native_tty_bottom_data_bits data_bits)\nspecifier|static",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|data_bits\n+name|stop_bits\n-comment|/**  * @brief Set the number of data bits in the termios structure  *  * @param ter  * @param stop_bits  *  */\n+comment|/**  * @brief Set the number of data bits in the termios structure  *  * @param ter  * @param data_bits  *  */\nThe issue was with: driver: uart: native: fix stop_bits/databits mix\n\nCorrect a trivial bug and doxygen documentation error\nin which data_bits was missused instead of stop_bits."
},{
  "instruction": "There is an issue in the following code. It relates to xtensa: mmu: dup_table does not need parameter\n\nThe only page table duplicated is the kernel page table. This function\ndoes not need a parameter. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|dup_table (uint32_t * source_table)\nspecifier|static\nname|uint32_t\nmodifier|*\nname|dup_table\nparameter_list|(\nname|uint32_t\nmodifier|*\nname|source_table\nparameter_list|)\nblock|{\nname|uint16_t\nname|i\ndecl_stmt|,\ndecl_stmt|;\nif|if\ncondition|(\nname|is_pte_illegal\nargument_list|(\nname|source_table\nindex|[\nname|i\nindex|]\nargument_list|)\noperator|||\noperator|(\nname|uint32_t\noperator|*\noperator|)\noperator|(\nname|source_table\nindex|[\nname|i\nindex|]\noperator|&\nname|XTENSA_MMU_PTE_PPN_MASK\ngoto|;\nblock|}\nname|ptables\noperator|=\nname|dup_table\nargument_list|(\nname|xtensa_kernel_ptables\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|ptables\noperator|==",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|dup_table (uint32_t * source_table)\n+DECL|function|dup_table (void)\n-name|uint32_t\n-modifier|*\n-name|source_table\n+name|void\n-name|source_table\n+name|xtensa_kernel_ptables\n-name|source_table\n+name|xtensa_kernel_ptables\n-argument_list|(\n-name|xtensa_kernel_ptables\n-argument_list|)\n+argument_list|()\nThe issue was with: xtensa: mmu: dup_table does not need parameter\n\nThe only page table duplicated is the kernel page table. This function\ndoes not need a parameter."
},{
  "instruction": "There is an issue in the following code. It relates to posix: env: Fix 2 build warnings\n\nFix 2 build warnings in posix/options/env:\nThe maximum length given to strncpy() matches the input\nstring length, which makes the call equivalent to strcpy().\nAs the destination buffer size has been ensured sufficient\n(in the first case by chechking just before,\nin the second case by allocating it big enough),\nlet's just use strcpy() instead.\n\nlib/posix/options/env.c: In function 'getenv_r':\nlib/posix/options/env.c:109:17: error: 'strncpy' specified bound\ndepends on the length of the source argument\n[-Werror=stringop-truncation]\n  109 |                 strncpy(buf, val, vsize);\n      |                 ^~~~~~~~~~~~~~~~~~~~~~~~\nlib/posix/options/env.c:104:25: note: length computed here\n  104 |                 vsize = strlen(val) + 1;\n      |                         ^~~~~~~~~~~\nlib/posix/options/env.c: In function 'setenv':\nlib/posix/options/env.c:191:17: error: 'strncpy' output truncated\nbefore terminating nul copying as many bytes from a string as its\nlength [-Werror=stringop-truncation]\n  191 |                 strncpy(environ[ret], name, nsize);\n      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nlib/posix/options/env.c:128:51: note: length computed here\n  128 |         const size_t nsize = (name == NULL) ? 0 : strlen(name);\n      |                                                   ^~~~~~~~~~~~ Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ERANGE\nexpr_stmt|;\nname|K_SPINLOCK_BREAK\nexpr_stmt|;\nblock|}\nname|strncpy\nargument_list|(\nname|buf\nargument_list|,\nname|val\nargument_list|,\nname|vsize\nargument_list|)\nexpr_stmt|;\nname|LOG_DBG\nargument_list|(\nliteral|\"Found entry %s\"\nindex|]\noperator|=\nname|env\nexpr_stmt|;\nblock|}\nname|strncpy\nargument_list|(\nname|environ\nindex|[\nname|ret\nindex|]\nargument_list|,\nname|name\nargument_list|,\nname|nsize\nargument_list|)\nexpr_stmt|;\nname|environ\nindex|[\nname|ret",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|strncpy\n+name|strcpy\n-argument_list|,\n-name|vsize\n-name|strncpy\n+name|strcpy\n-argument_list|,\n-name|nsize\nThe issue was with: posix: env: Fix 2 build warnings\n\nFix 2 build warnings in posix/options/env:\nThe maximum length given to strncpy() matches the input\nstring length, which makes the call equivalent to strcpy().\nAs the destination buffer size has been ensured sufficient\n(in the first case by chechking just before,\nin the second case by allocating it big enough),\nlet's just use strcpy() instead.\n\nlib/posix/options/env.c: In function 'getenv_r':\nlib/posix/options/env.c:109:17: error: 'strncpy' specified bound\ndepends on the length of the source argument\n[-Werror=stringop-truncation]\n  109 |                 strncpy(buf, val, vsize);\n      |                 ^~~~~~~~~~~~~~~~~~~~~~~~\nlib/posix/options/env.c:104:25: note: length computed here\n  104 |                 vsize = strlen(val) + 1;\n      |                         ^~~~~~~~~~~\nlib/posix/options/env.c: In function 'setenv':\nlib/posix/options/env.c:191:17: error: 'strncpy' output truncated\nbefore terminating nul copying as many bytes from a string as its\nlength [-Werror=stringop-truncation]\n  191 |                 strncpy(environ[ret], name, nsize);\n      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nlib/posix/options/env.c:128:51: note: length computed here\n  128 |         const size_t nsize = (name == NULL) ? 0 : strlen(name);\n      |                                                   ^~~~~~~~~~~~"
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: Update uart_elementary suite with different configuration\n\nConigure UART to use 2 stop bits and even parity\nin 'dual transmission' case\nto cover more driver code cases. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|115200\nblock|,\noperator|.\nname|parity\noperator|=\nname|UART_CFG_PARITY_NONE\nblock|,\noperator|.\nname|stop_bits\noperator|=\nname|UART_CFG_STOP_BITS_1\nblock|,\noperator|.\nname|data_bits\noperator|=\nname|UART_CFG_DATA_BITS_8\nliteral|9600\nblock|,\noperator|.\nname|parity\noperator|=\nname|UART_CFG_PARITY_NONE\nblock|,\noperator|.\nname|stop_bits\noperator|=\nname|UART_CFG_STOP_BITS_1\nblock|,\noperator|.\nname|data_bits\noperator|=\nname|UART_CFG_DATA_BITS_8",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|UART_CFG_PARITY_NONE\n+name|UART_CFG_PARITY_EVEN\n-name|UART_CFG_STOP_BITS_1\n+name|UART_CFG_STOP_BITS_2\n-name|UART_CFG_PARITY_NONE\n+name|UART_CFG_PARITY_EVEN\n-name|UART_CFG_STOP_BITS_1\n+name|UART_CFG_STOP_BITS_2\nThe issue was with: tests: drivers: Update uart_elementary suite with different configuration\n\nConigure UART to use 2 stop bits and even parity\nin 'dual transmission' case\nto cover more driver code cases."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: udc_dwc2: Submit reset after chirp sequence\n\nDWC USB 2.0 HS OTG Controller sets USB Reset interrupt after Reset\nsignalling starts, but before the High-Speed Detection Handshake. This\nallows software to perform most of the reset handling even before the\nconnection speed is known. The device controller indicates High-Speed\nDetection Handshake result is available in DSTS register by setting\nEnumeration Done interrupt.\n\nUSB stack expects that the connection speed is known immediately after\nUDC_EVT_RESET is submitted. Due to this expectation, it is important to\nsubmit UDC_EVT_RESET only after Enumeration Done interrupt to prevent\nthe USB stack from reading (and storing) actual device speed before\nit is known. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|LOG_DBG\nargument_list|(\nliteral|\"USB Reset interrupt\"\nargument_list|)\nexpr_stmt|;\nname|udc_submit_event\nargument_list|(\nname|dev\nargument_list|,\nname|UDC_EVT_RESET\nargument_list|,\nliteral|0\nargument_list|)\nexpr_stmt|;\nblock|}\nif|if\ncondition|(\nname|int_status\noperator|&\nname|dwc2_handle_enumdone\nargument_list|(\nname|dev\nargument_list|)\nexpr_stmt|;\nblock|}\nif|if\ncondition|(\nname|int_status\noperator|&",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|udc_submit_event\n-argument_list|(\n-name|dev\n-argument_list|,\n-name|UDC_EVT_RESET\n-argument_list|,\n-literal|0\n-argument_list|)\n-expr_stmt|;\n+name|udc_submit_event\n+argument_list|(\n+name|dev\n+argument_list|,\n+name|UDC_EVT_RESET\n+argument_list|,\n+literal|0\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: udc_dwc2: Submit reset after chirp sequence\n\nDWC USB 2.0 HS OTG Controller sets USB Reset interrupt after Reset\nsignalling starts, but before the High-Speed Detection Handshake. This\nallows software to perform most of the reset handling even before the\nconnection speed is known. The device controller indicates High-Speed\nDetection Handshake result is available in DSTS register by setting\nEnumeration Done interrupt.\n\nUSB stack expects that the connection speed is known immediately after\nUDC_EVT_RESET is submitted. Due to this expectation, it is important to\nsubmit UDC_EVT_RESET only after Enumeration Done interrupt to prevent\nthe USB stack from reading (and storing) actual device speed before\nit is known."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: CAP: Fix check for volume_mute_changed callback\n\nThe callback was guarded by a wrong check. Please fix this issue.",
  "input": "Faulty tokenized code:\ncase|:\nif|if\ncondition|(\nname|cap_cb\noperator|->\nname|volume_changed\noperator|!=\nname|NULL\ncondition|)\nblock|{\nname|cap_cb",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|volume_changed\n+name|volume_mute_changed\nThe issue was with: Bluetooth: CAP: Fix check for volume_mute_changed callback\n\nThe callback was guarded by a wrong check."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: Fix BIS IRC range check\n\nMaximum possible value for IRC is 15, not 7 Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|irc\nargument_list|,\nliteral|0x01\nargument_list|,\nliteral|0x07\nargument_list|)\ncondition|)\nblock|{\nreturn|return\nname|BT_HCI_ERR_INVALID_PARAM",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|0x07\n+literal|0x0F\nThe issue was with: Bluetooth: Controller: Fix BIS IRC range check\n\nMaximum possible value for IRC is 15, not 7"
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: dma: loop transfer: Avoid fake pass\n\nWhen the needed functionality is not available, its test should be\nskipped, not passed. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|dma\nargument_list|,\nname|chan_id\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|TC_PASS\nreturn|;\nblock|}\nname|tc\noperator|=\nname|transfer_count",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|ztest_test_skip\n+argument_list|()\n+expr_stmt|;\n-name|TC_PASS\n+name|TC_SKIP\nThe issue was with: tests: drivers: dma: loop transfer: Avoid fake pass\n\nWhen the needed functionality is not available, its test should be\nskipped, not passed."
},{
  "instruction": "There is an issue in the following code. It relates to samples: net: http_server: Close websocket connection properly\n\nUse the websocket_unregister() to close both sockets related\nto a connected websocket. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/net/socket.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/logging/log.h>\nend_include\nname|false\nexpr_stmt|;\noperator|(\nname|void\noperator|)\nname|close\nargument_list|(\nname|client\nargument_list|)\nexpr_stmt|;\nname|cfg",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/net/websocket.h>\n+end_include\n+\n-name|close\n+name|websocket_unregister\nThe issue was with: samples: net: http_server: Close websocket connection properly\n\nUse the websocket_unregister() to close both sockets related\nto a connected websocket."
},{
  "instruction": "There is an issue in the following code. It relates to net: websocket: Ignore error during close if we are disconnected\n\nNo need to return an error during a close if we are already\ndisconnected. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ret\noperator|<\nliteral|0\ncondition|)\nblock|{\nname|NET_DBG\nargument_list|(\nliteral|\"[%p] Cannot close (%d)\"\nargument_list|,\nname|obj\nreturn|return\noperator|-\nliteral|1\nreturn|;\nblock|}\nreturn|return\nname|ret\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Ignore error if we are not connected */\n+if|if\n+condition|(\n+name|ret\n+operator|!=\n+operator|-\n+name|ENOTCONN\n+condition|)\n+block|{\n+name|ret\n+operator|=\n+literal|0\n+expr_stmt|;\n+block|}\nThe issue was with: net: websocket: Ignore error during close if we are disconnected\n\nNo need to return an error during a close if we are already\ndisconnected."
},{
  "instruction": "There is an issue in the following code. It relates to soc: nxp: imxrt: clock imxrt1042 SOC at 528 MHz\n\niMXRT1042 SOC should be clocked at 528 MHz maximum. Correct the clock\nsetup to use the system PLL.\n\nFixes #70755 Please fix this issue.",
  "input": "Faulty tokenized code:\n&flexram {\n\tflexram,num-ram-banks = <16>;\n};\n\n&sysclk {\n\tclock-frequency = <500000000>;\n};\n\n&ccm {\n\tipg-podf {\n\t\tclock-div = <4>;\n\t};\n\n\tarm-podf {\n\t\tclock-div = <2>;\n\t};\n};\n\n\n/ {\n\tsoc {\n\t\t/* RT1040 only has one USB controller */\n\t\t/delete-node/ usbd@402e0200;\nconfig SOC_MIMXRT1042\n\tselect HAS_MCUX_SEMC\n\tselect CPU_HAS_FPU_DOUBLE_PRECISION\n\tselect CPU_HAS_ARM_MPU\n\tselect INIT_ARM_PLL\n\nconfig SOC_MIMXRT1051\n\tselect HAS_MCUX_ENET\n\tselect HAS_MCUX_SEMC\n\tselect CPU_HAS_FPU_DOUBLE_PRECISION\nargument_list|)\noperator|-\nliteral|1\nargument_list|)\nexpr_stmt|;\ncomment|/* Set PRE_PERIPH_CLK to PLL1, 1200M */\nname|CLOCK_SetMux\nargument_list|(\nname|kCLOCK_PrePeriphMux\nargument_list|,\nliteral|0x3\nargument_list|)\nexpr_stmt|;\ncomment|/* Set PERIPH_CLK MUX to PRE_PERIPH_CLK */\nname|CLOCK_SetMux\nargument_list|(\nname|kCLOCK_PeriphMux\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-\tclock-frequency = <500000000>;\n+\tclock-frequency = <528000000>;\n-\t\tclock-div = <2>;\n+\t\tclock-div = <1>;\n+&gpt2 {\n+\tgptfreq = <33000000>;\n+};\n+\tselect INIT_SYS_PLL\n+ifdef|#\n+directive|ifdef\n+name|CONFIG_SOC_MIMXRT1042\n+comment|/* Set PRE_PERIPH_CLK to SYS_PLL */\n+name|CLOCK_SetMux\n+argument_list|(\n+name|kCLOCK_PrePeriphMux\n+argument_list|,\n+literal|0x0\n+argument_list|)\n+expr_stmt|;\n+else|#\n+directive|else\n+endif|#\n+directive|endif\nThe issue was with: soc: nxp: imxrt: clock imxrt1042 SOC at 528 MHz\n\niMXRT1042 SOC should be clocked at 528 MHz maximum. Correct the clock\nsetup to use the system PLL.\n\nFixes #70755"
},{
  "instruction": "There is an issue in the following code. It relates to samples: move with_mcuboot sample to samples/sysbuild\n\nThis creates a new category of samples that demonstrate certain features\nof sysbuild. \\\"application development\\\" was a very generic name. Please fix this issue.",
  "input": "Faulty tokenized code:\n  collaborators:\n    - nordicjm\n    - \"57300\"\n  files:\n    - share/sysbuild/\n   - samples/application_development/sysbuild/\n    - doc/build/sysbuild/\n  labels:\n    - \"area: Sysbuild\"\n  tests:\n   - sample.application_development.sysbuild\n\nTask Watchdog:\n  status: maintained\n  maintainers:\n    - martinjaeger\n    ('reference/usb/uds_testing', 'services/usb/uds_testing'),\n    ('reference/usermode/index', 'kernel/usermode/index'),\n    ('reference/usermode/overview', 'kernel/usermode/overview'),\n    ('reference/usermode/syscalls', 'kernel/usermode/syscalls'),\n    ('reference/util/index', 'kernel/util/index'),\n    ('samples/drivers/adc/README', 'samples/drivers/adc/adc_dt/README'),\n    ('samples/drivers/kscan_touch', 'samples/subsys/input/input'),\n    ('samples/drivers/led_apa102/README', 'samples/drivers/led_strip/README'),\n    ('samples/drivers/led_lpd8806/README', 'samples/drivers/led_strip/README'),\n    ('samples/drivers/led_ws2812/README', 'samples/drivers/led_strip/README'),\n\n   sample_definition_and_criteria\n   classic\n   basic/*\n   userspace/*\n   subsys/subsys.rst\n   net/net.rst\n   bluetooth/bluetooth.rst\n   sensor/*\n   arch/*\nnew file mode 100644\nsimilarity index 100%\nrename from samples/application_development/sysbuild/with_mcuboot/CMakeLists.txt\nrename to samples/sysbuild/with_mcuboot/CMakeLists.txt\nsimilarity index 100%\nrename from samples/application_development/sysbuild/with_mcuboot/README.rst\nrename to samples/sysbuild/with_mcuboot/README.rst\nsimilarity index 100%\nrename from samples/application_development/sysbuild/with_mcuboot/prj.conf\nrename to samples/sysbuild/with_mcuboot/prj.conf\nsimilarity index 90%\nrename from samples/application_development/sysbuild/with_mcuboot/sample.yaml\nrename to samples/sysbuild/with_mcuboot/sample.yaml\nsample:\n  description: Sample with MCUboot built through sysbuild\n  name: with mcuboot\ntests:\n sample.application_development.sysbuild.with_mcuboot:\n    sysbuild: true\n    # Platform allowed is used as twister using sysbuild still lacks proper\n    # filtering support, see discussion in #49552.\n    platform_allow:\n      - reel_board\nsimilarity index 100%\nrename from samples/application_development/sysbuild/with_mcuboot/src/main.c\nrename to samples/sysbuild/with_mcuboot/src/main.c\nsimilarity index 100%\nrename from samples/application_development/sysbuild/with_mcuboot/sysbuild.conf\nrename to samples/sysbuild/with_mcuboot/sysbuild.conf\nsimilarity index 100%\nrename from samples/application_development/sysbuild/with_mcuboot/sysbuild/mcuboot.conf\nrename to samples/sysbuild/with_mcuboot/sysbuild/mcuboot.conf",
  "result": "I corrected the issue in the code by changing the following tokens:\n-    - samples/application_development/sysbuild/\n+    - samples/sysbuild/\n-    - sample.application_development.sysbuild\n+    - sample.sysbuild\n+    ('samples/application_development/with_mcuboot/README', 'samples/sysbuild/with_mcuboot/README'),\n+   sysbuild/*\n+.. _sysbuild-samples:\n+\n+Sysbuild samples\n+################\n+\n+.. toctree::\n+   :maxdepth: 1\n+   :glob:\n+\n+   **/*\n-  sample.application_development.sysbuild.with_mcuboot:\n+  sample.sysbuild.with_mcuboot:\nThe issue was with: samples: move with_mcuboot sample to samples/sysbuild\n\nThis creates a new category of samples that demonstrate certain features\nof sysbuild. \\\"application development\\\" was a very generic name."
},{
  "instruction": "There is an issue in the following code. It relates to tests: arch: x86 : update stack variable name in nmi test case\n\nupdate stack variable name in nmi test case for BSP Please fix this issue.",
  "input": "Faulty tokenized code:\nend_decl_stmt\n\nbegin_decl_stmt\nspecifier|extern\nname|uint8_t\nname|z_x86_nmi_stack\nindex|[]\ndecl_stmt|;\nend_decl_stmt\n\nbegin_decl_stmt\nmodifier|*\nname|nmi_stacks\nindex|[]\ninit|=\nblock|{\nname|z_x86_nmi_stack\nblock|,\nif|#\ndirective|if\nname|CONFIG_MP_MAX_NUM_CPUS\noperator|>",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|z_x86_nmi_stack\n+name|z_x86_nmi_stack0\n-name|z_x86_nmi_stack\n+name|z_x86_nmi_stack0\nThe issue was with: tests: arch: x86 : update stack variable name in nmi test case\n\nupdate stack variable name in nmi test case for BSP"
},{
  "instruction": "There is an issue in the following code. It relates to logging: log_cache: ensure cache contains an entry\n\nReturn an error if the provided cache configuration is not large enough\nto hold a single entry. An empty `active` and `idle` list causes NULL\ndereferences in `log_cache_get`. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright (c) 2021 Nordic Semiconductor ASA  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nfile|\"log_cache.h\"\nend_include\ninit|=\nname|config\noperator|->\nname|buf\ndecl_stmt|;\ncomment|/* Add all entries to idle list */\nfor|for\ncontrol|(\nname|uint32_t\nname|i",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<errno.h>\n+end_include\n+\n+comment|/* Ensure the cache has at least one entry */\n+if|if\n+condition|(\n+name|entry_cnt\n+operator|==\n+literal|0\n+condition|)\n+block|{\n+return|return\n+operator|-\n+name|EINVAL\n+return|;\n+block|}\nThe issue was with: logging: log_cache: ensure cache contains an entry\n\nReturn an error if the provided cache configuration is not large enough\nto hold a single entry. An empty `active` and `idle` list causes NULL\ndereferences in `log_cache_get`."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: regulator: npm6001: Fix compiler warning\n\nThis patch fixes a compiler warning about the val being used\nuninitialized. The previously present if check did not seem to satisfy\ncompiler. Hence the val is now explictly initialized. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|config\ndecl_stmt|;\nname|uint8_t\nname|val\ndecl_stmt|;\nname|size_t\nname|i\ndecl_stmt|;\nfor|for",
  "result": "I corrected the issue in the code by changing the following tokens:\n+init|=\n+literal|0U\nThe issue was with: drivers: regulator: npm6001: Fix compiler warning\n\nThis patch fixes a compiler warning about the val being used\nuninitialized. The previously present if check did not seem to satisfy\ncompiler. Hence the val is now explictly initialized."
},{
  "instruction": "There is an issue in the following code. It relates to tests: net: sockets: tls: Add missing teardown delays\n\nA few tests involving TCP were missing TCP teardown delay. Adding these\nimproves tests stability when testing in a loop for longer periods (i.\ne. with CONFIG_ZTEST_SHUFFLE enabled). Please fix this issue.",
  "input": "Faulty tokenized code:\nname|close_work_data\noperator|.\nname|work\nargument_list|)\nexpr_stmt|;\nblock|}\nend_block\n\nbegin_macro\nDECL|function|ZTEST (net_socket_tls,test_close_while_recv)\nargument_list|)\nexpr_stmt|;\nname|test_sockets_close\nargument_list|()\nexpr_stmt|;\nblock|}\nend_block\n\nbegin_macro\nDECL|function|ZTEST (net_socket_tls,test_accept_invalid_handshake_data)\nargument_list|)\nexpr_stmt|;\nname|test_sockets_close\nargument_list|()\nexpr_stmt|;\nblock|}\nend_block\n\nbegin_macro\nDECL|function|ZTEST (net_socket_tls,test_recv_non_block)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|k_sleep\n+argument_list|(\n+name|TCP_TEARDOWN_TIMEOUT\n+argument_list|)\n+expr_stmt|;\n+name|k_sleep\n+argument_list|(\n+name|TCP_TEARDOWN_TIMEOUT\n+argument_list|)\n+expr_stmt|;\n+name|k_sleep\n+argument_list|(\n+name|TCP_TEARDOWN_TIMEOUT\n+argument_list|)\n+expr_stmt|;\nThe issue was with: tests: net: sockets: tls: Add missing teardown delays\n\nA few tests involving TCP were missing TCP teardown delay. Adding these\nimproves tests stability when testing in a loop for longer periods (i.\ne. with CONFIG_ZTEST_SHUFFLE enabled)."
},{
  "instruction": "There is an issue in the following code. It relates to bluetooth: host: conn: Fix assertion failure in wait_for_tx_work\n\nCalling bt_disable in system workqueue context while BLE connected may\nlead to calling wait_for_tx_work in this context. Fix check in code to\navoid assertion failure. Please fix this issue.",
  "input": "Faulty tokenized code:\ncondition|(\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_BT_RECV_WORKQ_SYS\nargument_list|)\ncondition|)\nblock|{\nname|tx_notify\nargument_list|(\nname|conn\nname|sync\ndecl_stmt|;\nname|int\nname|err\ndecl_stmt|;\ncomment|/* API docs mention undefined behavior if syncing on work item \t\t * from wq execution context. \t\t */\nname|__ASSERT_NO_MSG\nargument_list|(\nname|k_current_get\nargument_list|()\noperator|!=\nname|k_work_queue_thread_get\nargument_list|(\noperator|&\nname|k_sys_work_q\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|err\noperator|=\nname|k_work_submit\nargument_list|(\noperator|&\nreturn|;\nblock|}\nend_function\n\nbegin_enum\nDECL|enum|__anon297ef7830103\nenum|enum\nblock|{\nDECL|enumerator|FRAG_START\nname|FRAG_START\nblock|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|||\n+name|k_current_get\n+argument_list|()\n+operator|==\n+name|k_work_queue_thread_get\n+argument_list|(\n+operator|&\n+name|k_sys_work_q\n+argument_list|)\n-comment|/* API docs mention undefined behavior if syncing on work item \t\t * from wq execution context. \t\t */\n-name|__ASSERT_NO_MSG\n-argument_list|(\n-name|k_current_get\n-argument_list|()\n-operator|!=\n-name|k_work_queue_thread_get\n-argument_list|(\n-operator|&\n-name|k_sys_work_q\n-argument_list|)\n-argument_list|)\n-expr_stmt|;\n-DECL|enum|__anon297ef7830103\n+DECL|enum|__anon2af2cd010103\nThe issue was with: bluetooth: host: conn: Fix assertion failure in wait_for_tx_work\n\nCalling bt_disable in system workqueue context while BLE connected may\nlead to calling wait_for_tx_work in this context. Fix check in code to\navoid assertion failure."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: counter: ll_stm32_timer: G4X changes\n\nUse \\\"const LL_TIM_OC_GetCompareCHx\\\" & \\\"const LL_TIM_IsEnabledIT_CCx\\\" with\nSTM32G4X series, following changes in stm32cube:stm32g4xx:drivers:\ninclude:stm32g4xx_ll_tim.h Please fix this issue.",
  "input": "Faulty tokenized code:\nif|#\ndirective|if\noperator|!\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_STM32G4X\nargument_list|)\noperator|&&\nexpr|\\\noperator|!\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_STM32MP1X\nargument_list|)\nend_if\n\nbegin_expr_stmt\nif|#\ndirective|if\noperator|!\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_STM32G4X\nargument_list|)\noperator|&&\nexpr|\\\noperator|!\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_STM32MP1X\nargument_list|)\nend_if\n\nbegin_expr_stmt",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_SOC_SERIES_STM32G4X\n-argument_list|)\n-operator|&&\n-expr|\\\n-operator|!\n-name|defined\n-argument_list|(\n-name|CONFIG_SOC_SERIES_STM32G4X\n-argument_list|)\n-operator|&&\n-expr|\\\n-operator|!\n-name|defined\n-argument_list|(\nThe issue was with: drivers: counter: ll_stm32_timer: G4X changes\n\nUse \\\"const LL_TIM_OC_GetCompareCHx\\\" & \\\"const LL_TIM_IsEnabledIT_CCx\\\" with\nSTM32G4X series, following changes in stm32cube:stm32g4xx:drivers:\ninclude:stm32g4xx_ll_tim.h"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: pwm: pwm_stm32: G4X changes\n\nUse \\\"const LL_TIM_IC_GetCaptureCHx\\\" & \\\"const LL_TIM_IsActiveFlag_CCx\\\"\nwith STM32G4X series, following changes in stm32cube:stm32g4xx:drivers:\ninclude:stm32g4xx_ll_tim.h Please fix this issue.",
  "input": "Faulty tokenized code:\nif|#\ndirective|if\noperator|!\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_STM32G4X\nargument_list|)\noperator|&&\nexpr|\\\noperator|!\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_STM32MP1X\nargument_list|)\nend_if\n\nbegin_decl_stmt\nif|#\ndirective|if\noperator|!\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_STM32G4X\nargument_list|)\noperator|&&\nexpr|\\\noperator|!\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_STM32MP1X\nargument_list|)\nDECL|variable|is_capture_active\nspecifier|static\nname|uint32_t",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_SOC_SERIES_STM32G4X\n-argument_list|)\n-operator|&&\n-expr|\\\n-operator|!\n-name|defined\n-argument_list|(\n-name|CONFIG_SOC_SERIES_STM32G4X\n-argument_list|)\n-operator|&&\n-expr|\\\n-operator|!\n-name|defined\n-argument_list|(\nThe issue was with: drivers: pwm: pwm_stm32: G4X changes\n\nUse \\\"const LL_TIM_IC_GetCaptureCHx\\\" & \\\"const LL_TIM_IsActiveFlag_CCx\\\"\nwith STM32G4X series, following changes in stm32cube:stm32g4xx:drivers:\ninclude:stm32g4xx_ll_tim.h"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: counter: ll_stm32_timer: F4X changes\n\nUse \\\"const LL_TIM_OC_GetCompareCHx\\\" & \\\"const LL_TIM_IsEnabledIT_CCx\\\" with\nSTM32F4X series, following changes in stm32cube:stm32f4xx:drivers:\ninclude:stm32f4xx_ll_tim.h Please fix this issue.",
  "input": "Faulty tokenized code:\nif|#\ndirective|if\noperator|!\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_STM32F4X\nargument_list|)\noperator|&&\nexpr|\\\noperator|!\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_STM32G4X\nargument_list|)\noperator|&&\nexpr|\\\noperator|!\nif|#\ndirective|if\noperator|!\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_STM32F4X\nargument_list|)\noperator|&&\nexpr|\\\noperator|!\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_STM32G4X\nargument_list|)\noperator|&&\nexpr|\\\noperator|!",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_SOC_SERIES_STM32F4X\n-argument_list|)\n-operator|&&\n-expr|\\\n-operator|!\n-name|defined\n-argument_list|(\n-name|CONFIG_SOC_SERIES_STM32F4X\n-argument_list|)\n-operator|&&\n-expr|\\\n-operator|!\n-name|defined\n-argument_list|(\nThe issue was with: drivers: counter: ll_stm32_timer: F4X changes\n\nUse \\\"const LL_TIM_OC_GetCompareCHx\\\" & \\\"const LL_TIM_IsEnabledIT_CCx\\\" with\nSTM32F4X series, following changes in stm32cube:stm32f4xx:drivers:\ninclude:stm32f4xx_ll_tim.h"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: pwm: pwm_stm32: F4X changes\n\nUse \\\"const LL_TIM_IC_GetCaptureCHx\\\" & \\\"const LL_TIM_IsActiveFlag_CCx\\\"\nwith STM32F4X series, following changes in stm32cube:stm32f4xx:drivers:\ninclude:stm32f4xx_ll_tim.h Please fix this issue.",
  "input": "Faulty tokenized code:\nif|#\ndirective|if\noperator|!\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_STM32F4X\nargument_list|)\noperator|&&\nexpr|\\\noperator|!\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_STM32G4X\nargument_list|)\noperator|&&\nexpr|\\\noperator|!\nif|#\ndirective|if\noperator|!\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_STM32F4X\nargument_list|)\noperator|&&\nexpr|\\\noperator|!\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_STM32G4X\nargument_list|)\noperator|&&\nexpr|\\\noperator|!",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_SOC_SERIES_STM32F4X\n-argument_list|)\n-operator|&&\n-expr|\\\n-operator|!\n-name|defined\n-argument_list|(\n-name|CONFIG_SOC_SERIES_STM32F4X\n-argument_list|)\n-operator|&&\n-expr|\\\n-operator|!\n-name|defined\n-argument_list|(\nThe issue was with: drivers: pwm: pwm_stm32: F4X changes\n\nUse \\\"const LL_TIM_IC_GetCaptureCHx\\\" & \\\"const LL_TIM_IsActiveFlag_CCx\\\"\nwith STM32F4X series, following changes in stm32cube:stm32f4xx:drivers:\ninclude:stm32f4xx_ll_tim.h"
},{
  "instruction": "There is an issue in the following code. It relates to tests: flash_simulator: move to subfolder\n\nMove the implementation test to a subfolder so an additional test can be\nadded. Please fix this issue.",
  "input": "Faulty tokenized code:\nsimilarity index 100%\nrename from tests/drivers/flash_simulator/CMakeLists.txt\nrename to tests/drivers/flash_simulator/flash_sim_impl/CMakeLists.txt\nsimilarity index 100%\nrename from tests/drivers/flash_simulator/boards/native_64_ev_0x00.overlay\nrename to tests/drivers/flash_simulator/flash_sim_impl/boards/native_64_ev_0x00.overlay\nsimilarity index 100%\nrename from tests/drivers/flash_simulator/boards/native_ev_0x00.overlay\nrename to tests/drivers/flash_simulator/flash_sim_impl/boards/native_ev_0x00.overlay\nsimilarity index 100%\nrename from tests/drivers/flash_simulator/boards/native_posix.overlay\nrename to tests/drivers/flash_simulator/flash_sim_impl/boards/native_posix.overlay\nsimilarity index 100%\nrename from tests/drivers/flash_simulator/boards/native_posix_native_64.overlay\nrename to tests/drivers/flash_simulator/flash_sim_impl/boards/native_posix_native_64.overlay\nsimilarity index 100%\nrename from tests/drivers/flash_simulator/boards/native_sim.overlay\nrename to tests/drivers/flash_simulator/flash_sim_impl/boards/native_sim.overlay\nsimilarity index 100%\nrename from tests/drivers/flash_simulator/boards/native_sim_native_64.overlay\nrename to tests/drivers/flash_simulator/flash_sim_impl/boards/native_sim_native_64.overlay\nsimilarity index 100%\nrename from tests/drivers/flash_simulator/boards/nucleo_f411re.overlay\nrename to tests/drivers/flash_simulator/flash_sim_impl/boards/nucleo_f411re.overlay\nsimilarity index 100%\nrename from tests/drivers/flash_simulator/boards/qemu_x86_ev_0x00.overlay\nrename to tests/drivers/flash_simulator/flash_sim_impl/boards/qemu_x86_ev_0x00.overlay\nsimilarity index 100%\nrename from tests/drivers/flash_simulator/prj.conf\nrename to tests/drivers/flash_simulator/flash_sim_impl/prj.conf\nsimilarity index 100%\nrename from tests/drivers/flash_simulator/src/main.c\nrename to tests/drivers/flash_simulator/flash_sim_impl/src/main.c\nsimilarity index 100%\nrename from tests/drivers/flash_simulator/testcase.yaml\nrename to tests/drivers/flash_simulator/flash_sim_impl/testcase.yaml",
  "result": "I corrected the issue in the code by changing the following tokens:\n\nThe issue was with: tests: flash_simulator: move to subfolder\n\nMove the implementation test to a subfolder so an additional test can be\nadded."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: udc_dwc2: handle interrupt IEPINT before the RXFLVL\n\nDuring a control read transfer host is able to start status stage as\nsoon as it receives last data packet. The time between last data packet\nand status stage can be approximately 1 us at High-Speed and 8 us at\nFull-Speed (exact timing depends on host but it is mostly constrained by\nbus turnaround time).\n\nWith sufficient interrupt latency it is therefore possible that both\nIEPINT (raised at end of Data Stage) and RXFLVL (raised at Status Stage)\nwould be set when dwc2 interrupt handler reads GINTSTS register. When\ndevice is operating at High-Speed, the latency introduced by UART logger\nbackend is enough to trigger this condition. If the RXFLVL is handled\nbefore IEPINT the stack will trigger \\\"Cannot determine the next stage\\\"\nerror.\n\nHandle IEPINT before RXFLVL to make the handler immune to increased\ninterrupt latencies.\n\nCo-authored-by: Tomasz Moń <tomasz.mon@nordicsemi.no> Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nif|if\ncondition|(\nname|int_status\noperator|&\nname|USB_DWC2_GINTSTS_RXFLVL\ncondition|)\nblock|{\ncomment|/* Handle RxFIFO Non-Empty interrupt */\nname|dwc2_handle_rxflvl\nargument_list|(\nname|dev\nargument_list|)\nexpr_stmt|;\nblock|}\nif|if\ncondition|(\nname|int_status\noperator|&\nname|USB_DWC2_GINTSTS_IEPINT\ncondition|)\nblock|{\ncomment|/* Handle IN Endpoints interrupt */\nname|dwc2_handle_iepint\nargument_list|(\nname|dev\nargument_list|)\nexpr_stmt|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|USB_DWC2_GINTSTS_RXFLVL\n+name|USB_DWC2_GINTSTS_IEPINT\n-comment|/* Handle RxFIFO Non-Empty interrupt */\n-name|dwc2_handle_rxflvl\n+comment|/* Handle IN Endpoints interrupt */\n+name|dwc2_handle_iepint\n-name|USB_DWC2_GINTSTS_IEPINT\n+name|USB_DWC2_GINTSTS_RXFLVL\n-comment|/* Handle IN Endpoints interrupt */\n-name|dwc2_handle_iepint\n+comment|/* Handle RxFIFO Non-Empty interrupt */\n+name|dwc2_handle_rxflvl\nThe issue was with: drivers: udc_dwc2: handle interrupt IEPINT before the RXFLVL\n\nDuring a control read transfer host is able to start status stage as\nsoon as it receives last data packet. The time between last data packet\nand status stage can be approximately 1 us at High-Speed and 8 us at\nFull-Speed (exact timing depends on host but it is mostly constrained by\nbus turnaround time).\n\nWith sufficient interrupt latency it is therefore possible that both\nIEPINT (raised at end of Data Stage) and RXFLVL (raised at Status Stage)\nwould be set when dwc2 interrupt handler reads GINTSTS register. When\ndevice is operating at High-Speed, the latency introduced by UART logger\nbackend is enough to trigger this condition. If the RXFLVL is handled\nbefore IEPINT the stack will trigger \\\"Cannot determine the next stage\\\"\nerror.\n\nHandle IEPINT before RXFLVL to make the handler immune to increased\ninterrupt latencies.\n\nCo-authored-by: Tomasz Moń <tomasz.mon@nordicsemi.no>"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: rtc: stm32: subsecond not supported by F2x\n\nsubsecond counting is not supported by STM32F2x SoC series. Please fix this issue.",
  "input": "Faulty tokenized code:\nend_expr_stmt\n\nbegin_if\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_STM32L1X\nargument_list|)\noperator|&&\noperator|!\nname|defined\nargument_list|(\nname|RTC_SUBSECOND_SUPPORT\nargument_list|)\nend_if\n\nbegin_comment\ncomment|/* subsecond counting is not supported by some STM32L1x MCUs */\nend_comment\n\nbegin_define\nDECL|macro|HW_SUBSECOND_SUPPORT\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+operator|)\n+expr|\\\n+operator|||\n+name|defined\n+argument_list|(\n+name|CONFIG_SOC_SERIES_STM32F2X\n+argument_list|)\n-comment|/* subsecond counting is not supported by some STM32L1x MCUs */\n+comment|/* subsecond counting is not supported by some STM32L1x MCUs (Cat.1)& by STM32F2x SoC series */\nThe issue was with: drivers: rtc: stm32: subsecond not supported by F2x\n\nsubsecond counting is not supported by STM32F2x SoC series."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: rtc: stm32: fix clk enable call\n\nOn STM32WBAX series, there is no bit in BCDR register to enable RTC.\nEnabling RTC is done directly via the RCC APB register bit. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|return\noperator|-\nname|EIO\nreturn|;\nblock|}\nname|z_stm32_hsem_lock\nargument_list|(\nname|CFG_HW_RCC_SEMID\nargument_list|,\nname|HSEM_LOCK_DEFAULT_RETRY\nname|z_stm32_hsem_unlock\nargument_list|(\nname|CFG_HW_RCC_SEMID\nargument_list|)\nexpr_stmt|;\nname|err\noperator|=\nname|rtc_stm32_configure\nargument_list|(\nname|dev",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/*  * On STM32WBAX series, there is no bit in BCDR register to enable RTC.  * Enabling RTC is done directly via the RCC APB register bit.  */\n+ifndef|#\n+directive|ifndef\n+name|CONFIG_SOC_SERIES_STM32WBAX\n+endif|#\n+directive|endif\n+comment|/* CONFIG_SOC_SERIES_STM32WBAX */\nThe issue was with: drivers: rtc: stm32: fix clk enable call\n\nOn STM32WBAX series, there is no bit in BCDR register to enable RTC.\nEnabling RTC is done directly via the RCC APB register bit."
},{
  "instruction": "There is an issue in the following code. It relates to tests: net: ipv6: Fix RA test\n\nDue to recent changes, as simple k_yield() is not enough on some\nplatforms (nRF platforms for example), as the entropy subsystem is now\nused because of PE, which may block, causing context switch before\nentire RA message is processed.\n\nFix this by adding small delay before checking if RA was processed\nproperly. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_block\nblock|{\nname|rs_message\nargument_list|()\nexpr_stmt|;\nname|ra_message\nargument_list|()\nexpr_stmt|;\nblock|}\nend_block",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Small delay to let the net stack process the generated RA message. */\n+name|k_sleep\n+argument_list|(\n+name|K_MSEC\n+argument_list|(\n+literal|10\n+argument_list|)\n+argument_list|)\n+expr_stmt|;\nThe issue was with: tests: net: ipv6: Fix RA test\n\nDue to recent changes, as simple k_yield() is not enough on some\nplatforms (nRF platforms for example), as the entropy subsystem is now\nused because of PE, which may block, causing context switch before\nentire RA message is processed.\n\nFix this by adding small delay before checking if RA was processed\nproperly."
},{
  "instruction": "There is an issue in the following code. It relates to Fixes small typo in log_backend_fs.c Please fix this issue.",
  "input": "Faulty tokenized code:\nendif|#\ndirective|endif\nend_endif\n\nbegin_function\nDECL|function|check_log_volumen_available (void)\nspecifier|static\nname|int\nname|check_log_volumen_available\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nname|int\nname|BACKEND_FS_NOT_INITIALIZED\ncondition|)\nblock|{\nif|if\ncondition|(\nname|check_log_volumen_available\nargument_list|()\ncondition|)\nblock|{\nreturn|return\nname|length",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|check_log_volumen_available (void)\n+DECL|function|check_log_volume_available (void)\n-name|check_log_volumen_available\n+name|check_log_volume_available\n-name|check_log_volumen_available\n+name|check_log_volume_available\nThe issue was with: Fixes small typo in log_backend_fs.c"
},{
  "instruction": "There is an issue in the following code. It relates to samples: drivers: crypto: Align error message\n\n'But got:' should be vertically aligned with the message 'Was waiting\nfor:'. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nblock|}\nblock|}\nname|printk\nargument_list|(\nliteral|\"\\n But got:\\n\"\nargument_list|)\nexpr_stmt|;\nfor|for\ncontrol|(\nname|i",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"\\n But got:\\n\"\n+literal|\"\\nBut got:\\n\"\nThe issue was with: samples: drivers: crypto: Align error message\n\n'But got:' should be vertically aligned with the message 'Was waiting\nfor:'."
},{
  "instruction": "There is an issue in the following code. It relates to lorawan: make possible to send empty frames\n\nEmpty frames are allowed by the LoRaWAN protocol and are actually useful\nto open new RX slots or flush MAC commands in stack. Therefore allow the\ndata pointer to be NULL if len is 0. Please fix this issue.",
  "input": "Faulty tokenized code:\nif|if\ncondition|(\nname|data\noperator|==\nname|NULL\ncondition|)\nblock|{\nreturn|return\noperator|-\nname|EINVAL",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|&&\n+name|len\n+operator|>\n+literal|0\nThe issue was with: lorawan: make possible to send empty frames\n\nEmpty frames are allowed by the LoRaWAN protocol and are actually useful\nto open new RX slots or flush MAC commands in stack. Therefore allow the\ndata pointer to be NULL if len is 0."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: video: csi: Drop pixel format config\n\nThe pixel format config is not used in the low level driver. Drop it. Please fix this issue.",
  "input": "Faulty tokenized code:\nDECL|member|fifo_out\nname|struct\nname|k_fifo\nname|fifo_out\ndecl_stmt|;\nDECL|member|pixelformat\nname|uint32_t\nname|pixelformat\ndecl_stmt|;\nDECL|member|signal\nname|struct\nname|k_poll_signal\nmodifier|*\nname|signal\nname|EINVAL\nreturn|;\nblock|}\nname|data\noperator|->\nname|pixelformat\noperator|=\nname|fmt\noperator|->\nname|pixelformat\nexpr_stmt|;\nname|data\noperator|->\nname|csi_config\noperator|.\nname|bytesPerPixel\noperator|=\nname|bpp",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|member|pixelformat\n-name|uint32_t\n-name|pixelformat\n-decl_stmt|;\n-name|pixelformat\n-operator|=\n-name|fmt\n-operator|->\n-name|pixelformat\n-expr_stmt|;\n-name|data\n-operator|->\nThe issue was with: drivers: video: csi: Drop pixel format config\n\nThe pixel format config is not used in the low level driver. Drop it."
},{
  "instruction": "There is an issue in the following code. It relates to soc: nxp: imxrt11xx: Enable clock for LPCI2C6\n\nEnable clock for LPCI2C6. This is needed to control some\nperipherals such as camera sensor. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\noperator|&\nname|rootCfg\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\nif|#\ndirective|if\nname|CONFIG_ETH_MCUX",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Configure Lpi2c6 using Osc24M */\n+name|rootCfg\n+operator|.\n+name|mux\n+operator|=\n+name|kCLOCK_LPI2C6_ClockRoot_MuxOsc24MOut\n+expr_stmt|;\n+name|rootCfg\n+operator|.\n+name|div\n+operator|=\n+literal|12\n+expr_stmt|;\n+name|CLOCK_SetRootClock\n+argument_list|(\n+name|kCLOCK_Root_Lpi2c6\n+argument_list|,\n+operator|&\n+name|rootCfg\n+argument_list|)\n+expr_stmt|;\nThe issue was with: soc: nxp: imxrt11xx: Enable clock for LPCI2C6\n\nEnable clock for LPCI2C6. This is needed to control some\nperipherals such as camera sensor."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: nxp_pit: check if top cb is null\n\ncheck if top cb is null to avoid hard fault\ntop cb is allowed to be null in api so this is required Please fix this issue.",
  "input": "Faulty tokenized code:\nname|channel\nargument_list|,\nname|flags\nargument_list|)\nexpr_stmt|;\nname|data\noperator|->\nname|top_callback\nargument_list|(\nname|dev\nname|top_user_data\nargument_list|)\nexpr_stmt|;\nblock|}\nblock|}\nend_function\n\nbegin_endif\nendif|#\ndirective|endif",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|data\n+operator|->\n+name|top_callback\n+condition|)\n+block|{\n+block|}\nThe issue was with: drivers: nxp_pit: check if top cb is null\n\ncheck if top cb is null to avoid hard fault\ntop cb is allowed to be null in api so this is required"
},{
  "instruction": "There is an issue in the following code. It relates to boards: nxp: Fix usage of DT_CHOSEN() macro to get chosen Zephyr Flash\n\nUsed multiple places in the tree. The idea is to determine if this node\ncorresponds to a specific node (e.g: flexspi) so that specific\nconfigurations can get done. Without the fix, the macro expansions were\ndefaulting to false. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|,\nname|DT_PARENT\nargument_list|(\nname|DT_CHOSEN\nargument_list|(\nname|flash\nargument_list|)\nargument_list|)\nargument_list|)\ncomment|/* AT25SF128A SPI Flash on the RT1010-EVK requires special alignment \t * considerations, so set the READADDROPT bit in the FlexSPI so it \t * will fetch more data than each AHB burst requires to meet alignment \t * requirements \t * \t * Without this, the FlexSPI will return corrupted data during early \t * boot, causing a hardfault. This can also be resolved by enabling \t * the instruction cache in very early boot. \t */\nname|FLEXSPI\noperator|,\nname|DT_PARENT\nargument_list|(\nname|DT_CHOSEN\nargument_list|(\nname|flash\nargument_list|)\nargument_list|)\nargument_list|)\ncomment|/* Wait for flexspi to be inactive, and gate the clock */\nwhile|while\noperator|,\nname|DT_PARENT\nargument_list|(\nname|DT_CHOSEN\nargument_list|(\nname|flash\nargument_list|)\nargument_list|)\nargument_list|)\ncomment|/* Wait for flexspi to be inactive, and gate the clock */\nwhile|while\noperator|,\nname|DT_PARENT\nargument_list|(\nname|DT_CHOSEN\nargument_list|(\nname|flash\nargument_list|)\nargument_list|)\nargument_list|)\ncomment|/* Enable clock gate of flexspi2. */\nname|CCM\noperator|,\nname|DT_PARENT\nargument_list|(\nname|DT_CHOSEN\nargument_list|(\nname|flash\nargument_list|)\nargument_list|)\nargument_list|)\ncomment|/* Enable clock of flexspi. */\nname|CCM\noperator|,\nname|DT_PARENT\nargument_list|(\nname|DT_CHOSEN\nargument_list|(\nname|flash\nargument_list|)\nargument_list|)\nargument_list|)\nname|clock_set_div\nargument_list|(\noperator|,\nname|DT_PARENT\nargument_list|(\nname|DT_CHOSEN\nargument_list|(\nname|flash\nargument_list|)\nargument_list|)\nargument_list|)\nname|clock_set_div\nargument_list|(\noperator|,\nname|DT_PARENT\nargument_list|(\nname|DT_CHOSEN\nargument_list|(\nname|flash\nargument_list|)\nargument_list|)\nargument_list|)\nname|clock_set_div\nargument_list|(\noperator|,\nname|DT_PARENT\nargument_list|(\nname|DT_CHOSEN\nargument_list|(\nname|flash\nargument_list|)\nargument_list|)\nargument_list|)\nname|clock_set_div\nargument_list|(\noperator|(\nname|DT_NODE_HAS_COMPAT\nargument_list|(\nname|DT_CHOSEN\nargument_list|(\nname|flash\nargument_list|)\noperator|,\nname|nxp_imx_flexspi\nargument_list|)\noperator|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|flash\n+name|zephyr_flash\n-name|flash\n+name|zephyr_flash\n-name|flash\n+name|zephyr_flash\n-name|flash\n+name|zephyr_flash\n-name|flash\n+name|zephyr_flash\n-name|flash\n+name|zephyr_flash\n-name|flash\n+name|zephyr_flash\n-name|flash\n+name|zephyr_flash\n-name|flash\n+name|zephyr_flash\n-name|flash\n+name|zephyr_flash\nThe issue was with: boards: nxp: Fix usage of DT_CHOSEN() macro to get chosen Zephyr Flash\n\nUsed multiple places in the tree. The idea is to determine if this node\ncorresponds to a specific node (e.g: flexspi) so that specific\nconfigurations can get done. Without the fix, the macro expansions were\ndefaulting to false."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: i2c: rtio: Remove extra clear of RTIO_SQE_TRANSACTION\n\nAlready handled within `i2c_rtio_copy()`. Not needed. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\ngoto|goto\nname|out\ngoto|;\nblock|}\nname|sqe\noperator|->\nname|flags\noperator|&=\noperator|~\nname|RTIO_SQE_TRANSACTION\nexpr_stmt|;\nname|rtio_submit\nargument_list|(\nname|r\nargument_list|,\nliteral|1",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|sqe\n-operator|->\n-name|flags\n-operator|&=\n-operator|~\n-name|RTIO_SQE_TRANSACTION\n-expr_stmt|;\nThe issue was with: drivers: i2c: rtio: Remove extra clear of RTIO_SQE_TRANSACTION\n\nAlready handled within `i2c_rtio_copy()`. Not needed."
},{
  "instruction": "There is an issue in the following code. It relates to tests: dma: loop transfer: Modernize zassert usage\n\nzassert_ok() is a more descriptive way to check for errors. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|transfer_count\nindex|]\nexpr_stmt|;\nendif|#\ndirective|endif\nname|zassert_false\nargument_list|(\nname|dma_config\nargument_list|(\nname|dev\nargument_list|,\nname|transfer_count\noperator|+\nliteral|1\nargument_list|)\nexpr_stmt|;\nname|zassert_false\nargument_list|(\nname|dma_start\nargument_list|(\nname|dev\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|zassert_false\n+name|zassert_ok\n-name|zassert_false\n+name|zassert_ok\nThe issue was with: tests: dma: loop transfer: Modernize zassert usage\n\nzassert_ok() is a more descriptive way to check for errors."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: regulator: shell: fix strcmp usage bug in cmd_adset\n\nBug in \\\"enable/disable\\\" argument parsing would cause\nthe oppostive of the requested setting to get\npassed to active discharge API invocation. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|2\nindex|]\nargument_list|,\nliteral|\"enable\"\nargument_list|)\ncondition|)\nblock|{\nname|ad\noperator|=\nname|true\nliteral|2\nindex|]\nargument_list|,\nliteral|\"disable\"\nargument_list|)\ncondition|)\nblock|{\nname|ad\noperator|=\nname|false",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|==\n+literal|0\n+operator|==\n+literal|0\nThe issue was with: drivers: regulator: shell: fix strcmp usage bug in cmd_adset\n\nBug in \\\"enable/disable\\\" argument parsing would cause\nthe oppostive of the requested setting to get\npassed to active discharge API invocation."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: controller: Prevent invalid compiler code reordering\n\nIn ull_disable, it is imperative that the callback is set up before a\nsecond reference counter check, otherwise it may happen that an LLL done\nevent has already passed when the disable callback and semaphore is\nassigned.\n\nThis causes the HCI thread to wait until timeout and assert after\null_ticker_stop_with_mark.\n\nFor certain compilers, due to compiler optimizations, it can be seen\nfrom the assembler code that the callback is assigned after the second\nreference counter check.\n\nBy adding memory barriers, the code correctly reorders code to the\nexpected sequence. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|)\nvalue|((_p) = (void *)(uint32_t)(_cmplt))\nend_define\n\nbegin_struct\nDECL|struct|__anon2baa007f0308\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|free\nname|void\ndefine|\\\nvalue|(sizeof(memq_link_t) *                                                 \\ \t (RX_CNT + 2 + BT_CTLR_MAX_CONN + BT_CTLR_ADV_SET +                    \\ \t  (BT_CTLR_ADV_ISO_SET * 2) + (BT_CTLR_SCAN_SYNC_SET * 2) +            \\ \t  (BT_CTLR_SCAN_SYNC_ISO_SET * 2) +                                    \\ \t  (IQ_REPORT_CNT)))\nend_define\n\nbegin_struct\nDECL|struct|__anon2baa007f0408\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|quota_pdu\nname|uint16_t\nreturn|return\noperator|-\nname|EALREADY\nreturn|;\nblock|}\nname|k_sem_init\nargument_list|(\noperator|&\nname|sem\nargument_list|,\noperator|->\nname|disabled_cb\noperator|=\nname|disabled_cb\nexpr_stmt|;\ncomment|/* ULL_HIGH can run after we have call `ull_ref_get` and it can \t * decrement the ref count. Hence, handle this race condition by \t * ensuring that `disabled_cb` has been set while the ref count is still \t * set. \t * No need to call `lll_disable` and take the semaphore thereafter if \t * reference count is zero. \t * If the `sem` is given when reference count was decremented, we do not \t * care. \t */\nif|if\ncondition|(\noperator|!\nname|ull_ref_get",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2baa007f0308\n+DECL|struct|__anon2a103bc90308\n-DECL|struct|__anon2baa007f0408\n+DECL|struct|__anon2a103bc90408\n+name|cpu_dmb\n+argument_list|()\n+expr_stmt|;\n+comment|/* Ensure synchronized data access */\n+name|cpu_dmb\n+argument_list|()\n+expr_stmt|;\n+comment|/* Ensure synchronized data access */\nThe issue was with: Bluetooth: controller: Prevent invalid compiler code reordering\n\nIn ull_disable, it is imperative that the callback is set up before a\nsecond reference counter check, otherwise it may happen that an LLL done\nevent has already passed when the disable callback and semaphore is\nassigned.\n\nThis causes the HCI thread to wait until timeout and assert after\null_ticker_stop_with_mark.\n\nFor certain compilers, due to compiler optimizations, it can be seen\nfrom the assembler code that the callback is assigned after the second\nreference counter check.\n\nBy adding memory barriers, the code correctly reorders code to the\nexpected sequence."
},{
  "instruction": "There is an issue in the following code. It relates to tests: net: mld: update MLDv2 tests after changes\n\nThis commit changes the expectations to checking for state transitions\nin MLDv2 reports. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|0\nindex|]\noperator|.\nname|record_type\nargument_list|,\nname|NET_IPV6_MLDv2_MODE_IS_EXCLUDE\nargument_list|,\nliteral|\"Invalid MLDv2 record type\"\nargument_list|)\nexpr_stmt|;\nname|zassert_mem_equal\nliteral|0\nindex|]\noperator|.\nname|record_type\nargument_list|,\nname|NET_IPV6_MLDv2_MODE_IS_INCLUDE\nargument_list|,\nliteral|\"Invalid MLDv2 record type\"\nargument_list|)\nexpr_stmt|;\nname|zassert_mem_equal",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|NET_IPV6_MLDv2_MODE_IS_EXCLUDE\n+name|NET_IPV6_MLDv2_CHANGE_TO_EXCLUDE_MODE\n-name|NET_IPV6_MLDv2_MODE_IS_INCLUDE\n+name|NET_IPV6_MLDv2_CHANGE_TO_INCLUDE_MODE\nThe issue was with: tests: net: mld: update MLDv2 tests after changes\n\nThis commit changes the expectations to checking for state transitions\nin MLDv2 reports."
},{
  "instruction": "There is an issue in the following code. It relates to net: ipv6: mld: use proper MLDv2 modes\n\nAccording to the RFC, MODE_IS_INCLUDE/MODE_IS_EXCLUDE codes should be\nused while sendling Multicast Listener Reports in response to a query.\nWhen performing a transition between states (e.g., when joining or\nleaving a multicast group) CHANGE_TO_INCLUDE_MODE/CHANGE_TO_EXCLUDE_MODE\nhave to be used. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|iface\nargument_list|,\nname|addr\nargument_list|,\nname|NET_IPV6_MLDv2_MODE_IS_EXCLUDE\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|ret\nargument_list|(\nname|iface\nargument_list|,\nname|addr\nargument_list|,\nname|NET_IPV6_MLDv2_MODE_IS_INCLUDE\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|ret\noperator|.\nname|mode\noperator|=\nname|route_added\ncondition|?\nname|NET_IPV6_MLDv2_MODE_IS_EXCLUDE\nelse|:\nname|NET_IPV6_MLDv2_MODE_IS_INCLUDE\nexpr_stmt|;\nname|net_if_foreach\nargument_list|(\nname|send_mld_event\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|NET_IPV6_MLDv2_MODE_IS_EXCLUDE\n+name|NET_IPV6_MLDv2_CHANGE_TO_EXCLUDE_MODE\n-name|NET_IPV6_MLDv2_MODE_IS_INCLUDE\n+name|NET_IPV6_MLDv2_CHANGE_TO_INCLUDE_MODE\n-name|NET_IPV6_MLDv2_MODE_IS_EXCLUDE\n+name|NET_IPV6_MLDv2_CHANGE_TO_EXCLUDE_MODE\n-name|NET_IPV6_MLDv2_MODE_IS_INCLUDE\n+name|NET_IPV6_MLDv2_CHANGE_TO_INCLUDE_MODE\nThe issue was with: net: ipv6: mld: use proper MLDv2 modes\n\nAccording to the RFC, MODE_IS_INCLUDE/MODE_IS_EXCLUDE codes should be\nused while sendling Multicast Listener Reports in response to a query.\nWhen performing a transition between states (e.g., when joining or\nleaving a multicast group) CHANGE_TO_INCLUDE_MODE/CHANGE_TO_EXCLUDE_MODE\nhave to be used."
},{
  "instruction": "There is an issue in the following code. It relates to riscv: FPU trap: test case thread typo fix\n\nNeed to wait for both threads. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|zassert_true\nargument_list|(\nname|k_thread_join\nargument_list|(\noperator|&\nname|thread1\nargument_list|,\nname|K_FOREVER\nargument_list|)\noperator|==\nliteral|0",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|thread1\n+name|thread2\nThe issue was with: riscv: FPU trap: test case thread typo fix\n\nNeed to wait for both threads."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: grow_r502a: fix in fps_read_template_table\n\nconsuming sensor_value struct instead of local device\ndriver variable. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|fps_read_template_table (const struct device * dev)\nspecifier|static\nname|int\nname|fps_read_template_table\nparameter_list|(\nspecifier|const\nname|struct\nname|device\nmodifier|*\nname|dev\nparameter_list|)\nblock|{\nname|struct\nname|grow_r502a_data\nmodifier|*\nliteral|0xff\ncondition|)\nblock|{\ncontinue|continue;\nblock|}\nname|drv_data\noperator|->\nname|free_idx\noperator|=\noperator|(\nname|group_idx\noperator|*\nname|ret\noperator|=\nname|fps_read_template_table\nargument_list|(\nname|dev\nargument_list|)\nexpr_stmt|;\nname|val\noperator|->\nname|val1\noperator|=\nname|drv_data\noperator|->\nname|free_idx\nexpr_stmt|;\nbreak|break;\ndefault|default:\nname|LOG_ERR\nargument_list|(\nbegin_union\nDECL|union|r502a_packet\nunion|union\nname|r502a_packet\nblock|{\nDECL|struct|__anon2b436f500108\nstruct|struct\nblock|{\nDECL|member|start\nname|uint8_t\nname|start\ndecl_stmt|;\nDECL|member|template_count\nname|uint16_t\nname|template_count\ndecl_stmt|;\nDECL|member|free_idx\nname|int8_t\nname|free_idx\ndecl_stmt|;\nblock|}\nstruct|;\nend_struct\n\nbegin_struct",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|fps_read_template_table (const struct device * dev)\n+DECL|function|fps_read_template_table (const struct device * dev,uint32_t * free_idx)\n+parameter_list|,\n+name|uint32_t\n+modifier|*\n+name|free_idx\n-name|drv_data\n-operator|->\n+operator|*\n-argument_list|)\n-expr_stmt|;\n+argument_list|,\n+operator|&\n-operator|=\n-name|drv_data\n-operator|->\n-name|free_idx\n+argument_list|)\n-DECL|struct|__anon2b436f500108\n+DECL|struct|__anon2a2113ac0108\n-DECL|member|free_idx\n-name|int8_t\n-name|free_idx\n-decl_stmt|;\nThe issue was with: drivers: sensor: grow_r502a: fix in fps_read_template_table\n\nconsuming sensor_value struct instead of local device\ndriver variable."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: grow_r502a: fix in checksum calculation\n\nchange checksum calculation to consider 2 bytes in pkg_len. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|+\nname|R502A_CHECKSUM_LEN\nexpr_stmt|;\nname|check_sum\noperator|=\nname|pkg_len\noperator|+\nname|tx_packet\noperator|->\nname|pid\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+name|pkg_len\n+operator|>>\n+literal|8\n+operator|)\n+operator|+\n+operator|(\n+operator|&\n+literal|0xFF\n+operator|)\nThe issue was with: drivers: sensor: grow_r502a: fix in checksum calculation\n\nchange checksum calculation to consider 2 bytes in pkg_len."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: grow_r502a: fix in fps_empty_db\n\nreturn ret; on goto unlock in fps_empty_db function. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|lock\nargument_list|)\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function\n\nbegin_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|0\n+name|ret\nThe issue was with: drivers: sensor: grow_r502a: fix in fps_empty_db\n\nreturn ret; on goto unlock in fps_empty_db function."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: grow_r502a: fix in fps_search\n\nreturn -ENOENT; when no record found on getting\nattribute SENSOR_ATTR_R502A_FIND and fix array indexing\nfor tx data in fps_search. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|&\nname|tx_packet\noperator|.\nname|data\nindex|[\nliteral|1\nindex|]\nargument_list|)\nexpr_stmt|;\nname|sys_put_be16\nargument_list|(\noperator|&\nname|tx_packet\noperator|.\nname|data\nindex|[\nliteral|3\nindex|]\nargument_list|)\nexpr_stmt|;\nname|transceive_packet\nargument_list|(\nname|LOG_ERR\nargument_list|(\nliteral|\"Did not find a match\"\nargument_list|)\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\nname|led_ctrl\noperator|.",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|1\n+literal|2\n-literal|3\n+literal|4\n+return|return\n+operator|-\n+name|ENOENT\n+return|;\nThe issue was with: drivers: sensor: grow_r502a: fix in fps_search\n\nreturn -ENOENT; when no record found on getting\nattribute SENSOR_ATTR_R502A_FIND and fix array indexing\nfor tx data in fps_search."
},{
  "instruction": "There is an issue in the following code. It relates to soc: nordic: nrf54h20: Use KERNEL_INIT_PRIORITY_DEFAULT\n\nMake the SoC initialization priority configurable. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|nordicsemi_nrf54h_init\nargument_list|,\nname|PRE_KERNEL_1\nargument_list|,\nliteral|0\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nend_unit",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|0\n+name|CONFIG_KERNEL_INIT_PRIORITY_DEFAULT\nThe issue was with: soc: nordic: nrf54h20: Use KERNEL_INIT_PRIORITY_DEFAULT\n\nMake the SoC initialization priority configurable."
},{
  "instruction": "There is an issue in the following code. It relates to soc: nordic: nrf54h20: Make HSFLL trims optional\n\nIf no HSFLL needs trimming, then `trim_hsfll()` should be compiled out.\nThis makes it easier to reuse the rest of `soc.c` out of tree.\n\nFurthermore, some HSFLL instances can be trimmed before booting Zephyr,\nso the FICR client properties in the DT binding should not be required. Please fix this issue.",
  "input": "Faulty tokenized code:\n      - 336000000\n      - 352000000\n      - 368000000\n      - 384000000\n      - 400000000\n\n nordic,ficrs:\n   required: true\n\n nordic,ficr-names:\n   required: true\nname|trim_hsfll\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nname|NRF_HSFLL_Type\nmodifier|*\nname|hsfll\ninit|=\noperator|(\nname|TRIM\noperator|.\nname|FINE\nargument_list|)\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-\n-  nordic,ficrs:\n-    required: true\n-\n-  nordic,ficr-names:\n-    required: true\n+if|#\n+directive|if\n+name|defined\n+argument_list|(\n+name|HSFLL_NODE\n+argument_list|)\n+endif|#\n+directive|endif\n+comment|/* defined(HSFLL_NODE) */\nThe issue was with: soc: nordic: nrf54h20: Make HSFLL trims optional\n\nIf no HSFLL needs trimming, then `trim_hsfll()` should be compiled out.\nThis makes it easier to reuse the rest of `soc.c` out of tree.\n\nFurthermore, some HSFLL instances can be trimmed before booting Zephyr,\nso the FICR client properties in the DT binding should not be required."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: sem: Remove constant expression\n\nlimit is unsigned int and K_SEM_MAX_LIMIT is defined as UINT_MAX this\nmeans that limit will never be greater K_SEM_MAX_LIMIT. Please fix this issue.",
  "input": "Faulty tokenized code:\ncomment|/* \t * Limit cannot be zero and count cannot be greater than limit \t */\nname|CHECKIF\nargument_list|(\nargument|limit ==\nliteral|0U\nargument||| limit> K_SEM_MAX_LIMIT || initial_count> limit\nargument_list|)\nblock|{\nname|SYS_PORT_TRACING_OBJ_FUNC\nargument_list|(\nname|k_sem",
  "result": "I corrected the issue in the code by changing the following tokens:\n-argument||| limit> K_SEM_MAX_LIMIT || initial_count> limit\n+argument||| initial_count> limit\nThe issue was with: kernel: sem: Remove constant expression\n\nlimit is unsigned int and K_SEM_MAX_LIMIT is defined as UINT_MAX this\nmeans that limit will never be greater K_SEM_MAX_LIMIT."
},{
  "instruction": "There is an issue in the following code. It relates to arch: x86: avoided increments/decrements with side effects\n\n- moved ++/-- before or after the value use Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|1\ndecl_stmt|;\nname|digs\nindex|[\nname|i\noperator|--\nindex|]\noperator|=\nliteral|0\nexpr_stmt|;\nwhile|while\ncondition|(\nname|v\noperator|||\nname|i\ncondition|)\nblock|{\nname|digs\nindex|[\nname|i\noperator|--\nindex|]\noperator|=\nliteral|'0'\noperator|+\noperator|(\nname|v\noperator|%\nliteral|10\noperator|)\nexpr_stmt|;\nname|v\noperator|/=\nliteral|10\nexpr_stmt|;\nblock|}\nwhile|while\ncondition|(\nname|digs\nindex|[\noperator|++\nname|i\nindex|]\noperator|!=\nliteral|'\\0'\ncondition|)\nindex|[\nname|i\nindex|]\nargument_list|)\nexpr_stmt|;\nblock|}\nblock|}\nend_function\n\nbegin_function\noperator|*\nname|s\noperator|!=\nliteral|'\\0'\ncondition|)\nname|pc\nargument_list|(\nname|r\nargument_list|,\noperator|*\nname|s\noperator|++\nargument_list|)\nexpr_stmt|;\nbreak|break;\nblock|}\ncase|case\nliteral|'p'\ncase|:\nexpr_stmt|;\nblock|}\nname|efibuf\nindex|[\nname|n\noperator|++\nindex|]\noperator|=\nname|c\nexpr_stmt|;\nif|if\ncondition|(\nname|c\noperator|==\nliteral|'\\n'",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|--\n+operator|--\n+name|i\n+expr_stmt|;\n-operator|--\n+operator|--\n+name|i\n+expr_stmt|;\n+operator|++\n+name|i\n+expr_stmt|;\n-operator|++\n+operator|++\n+name|i\n+expr_stmt|;\n+block|{\n-operator|++\n+operator|++\n+name|s\n+expr_stmt|;\n+block|}\n-operator|++\n+operator|++\n+name|n\n+expr_stmt|;\nThe issue was with: arch: x86: avoided increments/decrements with side effects\n\n- moved ++/-- before or after the value use"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: regulator: shell: print all 6-digits of micro values\n\nPreviously only the upper/first 3 digits of a micro value\nwould be printed, dropping the last 3 digits. This could cause\nmisleading output for cmds like vlist. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nname|shell_print\nargument_list|(\nname|sh\nargument_list|,\nliteral|\"%d.%03d %c\"\nargument_list|,\nname|val\noperator|/\nliteral|1000000\nargument_list|,\noperator|(\nname|val\noperator|%\nliteral|1000000\noperator|)\noperator|/\nliteral|1000\nargument_list|,\nname|unit\nargument_list|)\nexpr_stmt|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"%d.%03d %c\"\n+literal|\"%d.%06d %c\"\n-operator|(\n-operator|)\n-operator|/\n-literal|1000\nThe issue was with: drivers: regulator: shell: print all 6-digits of micro values\n\nPreviously only the upper/first 3 digits of a micro value\nwould be printed, dropping the last 3 digits. This could cause\nmisleading output for cmds like vlist."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: counter: stm32_rtc: fix clk disable for WBAX\n\nclock_control_on() was called instead of clock_control_off(). Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|0\ncondition|)\nblock|{\nname|LOG_ERR\nargument_list|(\nliteral|\"clock op failed\\n\"\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|EIO\ninit|=\nname|dev\noperator|->\nname|config\ndecl_stmt|;\ncomment|/* Enable RTC bus clock */\nif|if\ncondition|(\nname|clock_control_on\nargument_list|(\nname|clk\nargument_list|,\noperator|(\nname|clock_control_subsys_t\nliteral|0\ncondition|)\nblock|{\nname|LOG_ERR\nargument_list|(\nliteral|\"clock op failed\\n\"\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|EIO",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"clock op failed\\n\"\n+literal|\"RTC clock enabling failed\\n\"\n-comment|/* Enable RTC bus clock */\n+comment|/* Disable RTC bus clock */\n-name|clock_control_on\n+name|clock_control_off\n-literal|\"clock op failed\\n\"\n+literal|\"RTC clock disabling failed\\n\"\nThe issue was with: drivers: counter: stm32_rtc: fix clk disable for WBAX\n\nclock_control_on() was called instead of clock_control_off()."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: bluetooth: hci: Fix int conversion warning\n\nFix int conversion warning (-Wint-conversion), which is caused by\nparallel PRs. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nliteral|\"No available ISO buffers!\"\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|NULL\nreturn|;\nblock|}\nif|if\ncondition|(\nname|len\nargument_list|(\nname|buf\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|NULL\nreturn|;\nblock|}\nname|net_buf_add_mem\nargument_list|(\nname|buf",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|NULL\n+operator|-\n+name|ENOMEM\n-name|NULL\n+operator|-\n+name|ENOMEM\nThe issue was with: drivers: bluetooth: hci: Fix int conversion warning\n\nFix int conversion warning (-Wint-conversion), which is caused by\nparallel PRs."
},{
  "instruction": "There is an issue in the following code. It relates to net: tcp: use CS random generators to generate ISN\n\nUse only cryptographically secure random number generators for ISN. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|,\nname|uint16_t\nname|dport\nparameter_list|)\nblock|{\nDECL|struct|__anon27617de50108\nstruct|struct\nblock|{\nDECL|member|key\nname|uint8_t\nname|key\ncondition|(\noperator|!\nname|once\ncondition|)\nblock|{\nname|sys_rand_get\nargument_list|(\nname|unique_key\nargument_list|,\nsizeof|sizeof\nargument_list|(\nparameter_list|,\nname|uint16_t\nname|dport\nparameter_list|)\nblock|{\nDECL|struct|__anon27617de50208\nstruct|struct\nblock|{\nDECL|member|key\nname|uint8_t\nname|key\ncondition|(\noperator|!\nname|once\ncondition|)\nblock|{\nname|sys_rand_get\nargument_list|(\nname|unique_key\nargument_list|,\nsizeof|sizeof\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon27617de50108\n+DECL|struct|__anon2af0882d0108\n-name|sys_rand_get\n+name|sys_csrand_get\n-DECL|struct|__anon27617de50208\n+DECL|struct|__anon2af0882d0208\n-name|sys_rand_get\n+name|sys_csrand_get\nThe issue was with: net: tcp: use CS random generators to generate ISN\n\nUse only cryptographically secure random number generators for ISN."
},{
  "instruction": "There is an issue in the following code. It relates to net: shell: Pretty print websocket output\n\nFixing the websocket command output to align the fields and\nprinting interface index instead of a pointer value. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|0\ncondition|)\nblock|{\nname|PR\nargument_list|(\nliteral|\"     websocket/net_ctx\\tIface         \"\nliteral|\"Local              \\tRemote\\n\"\nargument_list|)\nexpr_stmt|;\nblock|}\nname|get_addresses\nargument_list|(\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|PR\nargument_list|(\nliteral|\"[%2d] %p/%p\\t%p   %16s\\t%16s\\n\"\nargument_list|,\noperator|(\noperator|*\nname|count\noperator|)\nargument_list|,\nname|context\nargument_list|,\nname|net_ctx\nargument_list|,\nname|net_context_get_iface\nargument_list|(\nname|net_ctx\nargument_list|)\nargument_list|,\nname|addr_local\nargument_list|,\nname|addr_remote\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"     websocket/net_ctx\\tIface         \"\n-literal|\"Local              \\tRemote\\n\"\n+literal|\"     websocket/net_ctx  \\tIface\\t\"\n+literal|\"%-16s\\t%-16s\\n\"\n+argument_list|,\n+literal|\"Local\"\n+argument_list|,\n+literal|\"Remote\"\n-literal|\"[%2d] %p/%p\\t%p   %16s\\t%16s\\n\"\n+literal|\"[%2d] %p/%p\\t%d\\t%-16s\\t%-16s\\n\"\n+name|net_if_get_by_iface\n+argument_list|(\n+argument_list|)\nThe issue was with: net: shell: Pretty print websocket output\n\nFixing the websocket command output to align the fields and\nprinting interface index instead of a pointer value."
},{
  "instruction": "There is an issue in the following code. It relates to net: websocket: Do not print error in closing\n\nIf the other end closes the connection, it is not exactly an\nerror so downgrade the print to debug level. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ret\noperator|<\nliteral|0\ncondition|)\nblock|{\nname|NET_ERR\nargument_list|(\nliteral|\"[%p] Failed to send close message (err %d).\"\nargument_list|,\nname|ctx\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|NET_ERR\n+name|NET_DBG\nThe issue was with: net: websocket: Do not print error in closing\n\nIf the other end closes the connection, it is not exactly an\nerror so downgrade the print to debug level."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: counter_nrfx_timer.c: Get frequency directly from DT\n\nInstead of working it from a macro from the HAL\nbased on the DT address, let's just get the maximum\nfrequency directly from DT. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|DT_DRV_COMPAT\nvalue|nordic_nrf_timer\nend_define\n\nbegin_define\nDECL|macro|TIMER_CLOCK (timer_instance)\ndefine|#\ndirective|define\nname|TIMER_CLOCK\nparameter_list|(\nname|timer_instance\nparameter_list|)\nvalue|NRF_TIMER_BASE_FREQUENCY_GET(timer_instance)\nend_define\n\nbegin_define\nDECL|macro|CC_TO_ID (cc_num)\ndefine|#\ndirective|define\nname|CC_TO_ID\nname|idx\nparameter_list|)\ndefine|\\\nvalue|BUILD_ASSERT(DT_INST_PROP(idx, prescaler)<=\t\t\t\t\t\t\\ \t\t\tTIMER_PRESCALER_PRESCALER_Msk,\t\t\t\t\t\t\\ \t\t     \"TIMER prescaler out of range\");\t\t\t\t\t\t\\ \tCOND_CODE_1(DT_INST_PROP(idx, zli), (\t\t\t\t\t\t\t\\ \t\tISR_DIRECT_DECLARE(counter_timer##idx##_isr_wrapper)\t\t\t\t\\ \t\t{\t\t\t\t\t\t\t\t\t\t\\ \t\t\tirq_handler(DEVICE_DT_INST_GET(idx));\t\t\t\t\t\\\ncomment|/* No rescheduling, it shall not access zephyr primitives. */\nvalue|\\ \t\t\treturn 0;\t\t\t\t\t\t\t\t\\ \t\t}), ())\t\t\t\t\t\t\t\t\t\t\\ \tstatic int counter_##idx##_init(const struct device *dev)\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\t\t\t\\ \t\tTIMER_IRQ_CONNECT(idx);\t\t\t\t\t\t\t\t\\ \t\tstatic const struct counter_timer_config config = {\t\t\t\t\\ \t\t\t.prescaler = DT_INST_PROP(idx, prescaler),\t\t\t\t\\ \t\t\t.mode = NRF_TIMER_MODE_TIMER,\t\t\t\t\t\t\\ \t\t\t.bit_width = (DT_INST_PROP(idx, max_bit_width) == 32) ?\t\t\t\\ \t\t\t\t\tNRF_TIMER_BIT_WIDTH_32 : NRF_TIMER_BIT_WIDTH_16,\t\\ \t\t};\t\t\t\t\t\t\t\t\t\t\\ \t\treturn init_timer(dev,&config);\t\t\t\t\t\t\\ \t}\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct counter_nrfx_data counter_##idx##_data;\t\t\t\t\t\\ \tstatic struct counter_nrfx_ch_data\t\t\t\t\t\t\t\\ \t\tcounter##idx##_ch_data[CC_TO_ID(DT_INST_PROP(idx, cc_num))];\t\t\t\\ \tLOG_INSTANCE_REGISTER(LOG_MODULE_NAME, idx, CONFIG_COUNTER_LOG_LEVEL);\t\t\t\\ \tstatic MAYBE_CONST_CONFIG struct counter_nrfx_config nrfx_counter_##idx##_config = {\t\\ \t\t.info = {\t\t\t\t\t\t\t\t\t\\ \t\t\t.max_top_value = (uint32_t)BIT64_MASK(DT_INST_PROP(idx, max_bit_width)),\\ \t\t\t.freq = TIMER_CLOCK((NRF_TIMER_Type *)DT_INST_REG_ADDR(idx)) /\t\t\\ \t\t\t\tBIT(DT_INST_PROP(idx, prescaler)),\t\t\t\t\\ \t\t\t.flags = COUNTER_CONFIG_INFO_COUNT_UP,\t\t\t\t\t\\ \t\t\t.channels = CC_TO_ID(DT_INST_PROP(idx, cc_num)),\t\t\t\\ \t\t},\t\t\t\t\t\t\t\t\t\t\\ \t\t.ch_data = counter##idx##_ch_data,\t\t\t\t\t\t\\ \t\t.timer = (NRF_TIMER_Type *)DT_INST_REG_ADDR(idx),\t\t\t\t\\ \t\tLOG_INSTANCE_PTR_INIT(log, LOG_MODULE_NAME, idx)\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(idx,\t\t\t\t\t\t\t\t\\ \t\t\t    counter_##idx##_init,\t\t\t\t\t\t\\ \t\t\t    NULL,\t\t\t\t\t\t\t\t\\&counter_##idx##_data,\t\t\t\t\t\t\\&nrfx_counter_##idx##_config.info,\t\t\t\t\t\\ \t\t\t    PRE_KERNEL_1, CONFIG_COUNTER_INIT_PRIORITY,\t\t\t\t\\&counter_nrfx_driver_api);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_define\n-DECL|macro|TIMER_CLOCK (timer_instance)\n-define|#\n-directive|define\n-name|TIMER_CLOCK\n-parameter_list|(\n-name|timer_instance\n-parameter_list|)\n-value|NRF_TIMER_BASE_FREQUENCY_GET(timer_instance)\n-end_define\n-\n-value|\\ \t\t\treturn 0;\t\t\t\t\t\t\t\t\\ \t\t}), ())\t\t\t\t\t\t\t\t\t\t\\ \tstatic int counter_##idx##_init(const struct device *dev)\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\t\t\t\\ \t\tTIMER_IRQ_CONNECT(idx);\t\t\t\t\t\t\t\t\\ \t\tstatic const struct counter_timer_config config = {\t\t\t\t\\ \t\t\t.prescaler = DT_INST_PROP(idx, prescaler),\t\t\t\t\\ \t\t\t.mode = NRF_TIMER_MODE_TIMER,\t\t\t\t\t\t\\ \t\t\t.bit_width = (DT_INST_PROP(idx, max_bit_width) == 32) ?\t\t\t\\ \t\t\t\t\tNRF_TIMER_BIT_WIDTH_32 : NRF_TIMER_BIT_WIDTH_16,\t\\ \t\t};\t\t\t\t\t\t\t\t\t\t\\ \t\treturn init_timer(dev,&config);\t\t\t\t\t\t\\ \t}\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct counter_nrfx_data counter_##idx##_data;\t\t\t\t\t\\ \tstatic struct counter_nrfx_ch_data\t\t\t\t\t\t\t\\ \t\tcounter##idx##_ch_data[CC_TO_ID(DT_INST_PROP(idx, cc_num))];\t\t\t\\ \tLOG_INSTANCE_REGISTER(LOG_MODULE_NAME, idx, CONFIG_COUNTER_LOG_LEVEL);\t\t\t\\ \tstatic MAYBE_CONST_CONFIG struct counter_nrfx_config nrfx_counter_##idx##_config = {\t\\ \t\t.info = {\t\t\t\t\t\t\t\t\t\\ \t\t\t.max_top_value = (uint32_t)BIT64_MASK(DT_INST_PROP(idx, max_bit_width)),\\ \t\t\t.freq = TIMER_CLOCK((NRF_TIMER_Type *)DT_INST_REG_ADDR(idx)) /\t\t\\ \t\t\t\tBIT(DT_INST_PROP(idx, prescaler)),\t\t\t\t\\ \t\t\t.flags = COUNTER_CONFIG_INFO_COUNT_UP,\t\t\t\t\t\\ \t\t\t.channels = CC_TO_ID(DT_INST_PROP(idx, cc_num)),\t\t\t\\ \t\t},\t\t\t\t\t\t\t\t\t\t\\ \t\t.ch_data = counter##idx##_ch_data,\t\t\t\t\t\t\\ \t\t.timer = (NRF_TIMER_Type *)DT_INST_REG_ADDR(idx),\t\t\t\t\\ \t\tLOG_INSTANCE_PTR_INIT(log, LOG_MODULE_NAME, idx)\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(idx,\t\t\t\t\t\t\t\t\\ \t\t\t    counter_##idx##_init,\t\t\t\t\t\t\\ \t\t\t    NULL,\t\t\t\t\t\t\t\t\\&counter_##idx##_data,\t\t\t\t\t\t\\&nrfx_counter_##idx##_config.info,\t\t\t\t\t\\ \t\t\t    PRE_KERNEL_1, CONFIG_COUNTER_INIT_PRIORITY,\t\t\t\t\\&counter_nrfx_driver_api);\n+value|\\ \t\t\treturn 0;\t\t\t\t\t\t\t\t\\ \t\t}), ())\t\t\t\t\t\t\t\t\t\t\\ \tstatic int counter_##idx##_init(const struct device *dev)\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\t\t\t\\ \t\tTIMER_IRQ_CONNECT(idx);\t\t\t\t\t\t\t\t\\ \t\tstatic const struct counter_timer_config config = {\t\t\t\t\\ \t\t\t.prescaler = DT_INST_PROP(idx, prescaler),\t\t\t\t\\ \t\t\t.mode = NRF_TIMER_MODE_TIMER,\t\t\t\t\t\t\\ \t\t\t.bit_width = (DT_INST_PROP(idx, max_bit_width) == 32) ?\t\t\t\\ \t\t\t\t\tNRF_TIMER_BIT_WIDTH_32 : NRF_TIMER_BIT_WIDTH_16,\t\\ \t\t};\t\t\t\t\t\t\t\t\t\t\\ \t\treturn init_timer(dev,&config);\t\t\t\t\t\t\\ \t}\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct counter_nrfx_data counter_##idx##_data;\t\t\t\t\t\\ \tstatic struct counter_nrfx_ch_data\t\t\t\t\t\t\t\\ \t\tcounter##idx##_ch_data[CC_TO_ID(DT_INST_PROP(idx, cc_num))];\t\t\t\\ \tLOG_INSTANCE_REGISTER(LOG_MODULE_NAME, idx, CONFIG_COUNTER_LOG_LEVEL);\t\t\t\\ \tstatic MAYBE_CONST_CONFIG struct counter_nrfx_config nrfx_counter_##idx##_config = {\t\\ \t\t.info = {\t\t\t\t\t\t\t\t\t\\ \t\t\t.max_top_value = (uint32_t)BIT64_MASK(DT_INST_PROP(idx, max_bit_width)),\\ \t\t\t.freq = DT_INST_PROP(idx, max_frequency) /\t\t\t\t\\ \t\t\t\tBIT(DT_INST_PROP(idx, prescaler)),\t\t\t\t\\ \t\t\t.flags = COUNTER_CONFIG_INFO_COUNT_UP,\t\t\t\t\t\\ \t\t\t.channels = CC_TO_ID(DT_INST_PROP(idx, cc_num)),\t\t\t\\ \t\t},\t\t\t\t\t\t\t\t\t\t\\ \t\t.ch_data = counter##idx##_ch_data,\t\t\t\t\t\t\\ \t\t.timer = (NRF_TIMER_Type *)DT_INST_REG_ADDR(idx),\t\t\t\t\\ \t\tLOG_INSTANCE_PTR_INIT(log, LOG_MODULE_NAME, idx)\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(idx,\t\t\t\t\t\t\t\t\\ \t\t\t    counter_##idx##_init,\t\t\t\t\t\t\\ \t\t\t    NULL,\t\t\t\t\t\t\t\t\\&counter_##idx##_data,\t\t\t\t\t\t\\&nrfx_counter_##idx##_config.info,\t\t\t\t\t\\ \t\t\t    PRE_KERNEL_1, CONFIG_COUNTER_INIT_PRIORITY,\t\t\t\t\\&counter_nrfx_driver_api);\nThe issue was with: drivers: counter_nrfx_timer.c: Get frequency directly from DT\n\nInstead of working it from a macro from the HAL\nbased on the DT address, let's just get the maximum\nfrequency directly from DT."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: Fixes Controller Mode for I2C DW Driver\n\n4996a9be262ca81bae717bdd8c2939db2a6876b7 adds Target Support for the\nDesignware I2C Driver\n\nBut the change missed guarding some places with\nCONFIG_I2C_TARGET\n\nThis commit fixes regressions caused by such change Please fix this issue.",
  "input": "Faulty tokenized code:\nname|data\noperator||=\nname|IC_DATA_CMD_STOP\nexpr_stmt|;\nblock|}\nname|clear_bit_intr_mask_tx_empty\nargument_list|(\nname|reg_base\nargument_list|)\nexpr_stmt|;\nname|write_cmd_data\nargument_list|(\nname|data\nargument_list|,\nname|reg_base\nargument_list|(\nname|port\nargument_list|)\nexpr_stmt|;\nblock|}\ncomment|/* Check if the TX FIFO is ready for commands. \t\t * TX FIFO also serves as command queue where read requests \t\t * are written to TX FIFO. \t\t */\nif|if\ncondition|(\noperator|(\nname|dw\nargument_list|(\nname|reg_base\nargument_list|)\nexpr_stmt|;\nblock|}\nif|if\ncondition|(\nname|intr_stat\noperator|.\nname|bits",
  "result": "I corrected the issue in the code by changing the following tokens:\n+ifdef|#\n+directive|ifdef\n+name|CONFIG_I2C_TARGET\n+endif|#\n+directive|endif\n+comment|/* CONFIG_I2C_TARGET */\n+ifdef|#\n+directive|ifdef\n+name|CONFIG_I2C_TARGET\n+endif|#\n+directive|endif\n+comment|/* CONFIG_I2C_TARGET */\nThe issue was with: drivers: Fixes Controller Mode for I2C DW Driver\n\n4996a9be262ca81bae717bdd8c2939db2a6876b7 adds Target Support for the\nDesignware I2C Driver\n\nBut the change missed guarding some places with\nCONFIG_I2C_TARGET\n\nThis commit fixes regressions caused by such change"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: adxl362: fix temperature conversion\n\nIt was missing the test condition for the temperature sensor. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/*  * Output data rate map with allowed frequencies:  * freq = freq_int + freq_milli / 1000  *  * Since we don't need a finer frequency resolution than milliHz, use uint16_t  * to save some flash.  */\nend_comment\n\nbegin_struct\nDECL|struct|__anon2a225b200108\nspecifier|static\nspecifier|const\nstruct|struct\nblock|{\nDECL|member|freq_int\noperator|-\nname|ADXL362_TEMP_BIAS_LSB\noperator|)\noperator|*\nname|ADXL362_TEMP_MC_PER_LSB\ndecl_stmt|;\nname|val\noperator|->\nname|val1\noperator|=\ndirective|define\nname|ADXL362_TEMP_BIAS_LSB\nvalue|350\nend_define\n\nbegin_struct\nDECL|struct|adxl362_config\nstruct|struct\nname|adxl362_config\nblock|{\nbegin_struct\nDECL|struct|adxl362_data\nstruct|struct\nname|adxl362_data\nblock|{\nDECL|union|__anon2ac782a6010a\nunion|union\nblock|{\nDECL|member|acc_xyz\nname|int16_t\nname|acc_xyz\nindex|[\nliteral|3\nindex|]\ndecl_stmt|;\nDECL|struct|__anon2ac782a60208\nstruct|struct\nblock|{\nDECL|member|acc_x\nname|int16_t\nname|acc_x",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2a225b200108\n+DECL|struct|__anon299c90190108\n+operator|+\n+operator|(\n+name|ADXL362_TEMP_BIAS_TEST_CONDITION\n+operator|*\n+literal|1000\n+operator|)\n+begin_define\n+DECL|macro|ADXL362_TEMP_BIAS_TEST_CONDITION\n+define|#\n+directive|define\n+name|ADXL362_TEMP_BIAS_TEST_CONDITION\n+value|25\n+end_define\n+\n-DECL|union|__anon2ac782a6010a\n+DECL|union|__anon2b527d53010a\n-DECL|struct|__anon2ac782a60208\n+DECL|struct|__anon2b527d530208\nThe issue was with: drivers: sensor: adxl362: fix temperature conversion\n\nIt was missing the test condition for the temperature sensor."
},{
  "instruction": "There is an issue in the following code. It relates to input: it8xxx2_kbd: fix col_size build warning range\n\nFix the range check for col_size to allow a configuration with less than\n16 columns. Not sure why the minimum was set so high but there's no\nreason I can tell for it. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|0\nargument_list|,\nname|col_size\nargument_list|)\nargument_list|,\nliteral|16\nargument_list|,\nliteral|18\nargument_list|)\nargument_list|,\nliteral|\"invalid col-size\"",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|16\n+literal|1\nThe issue was with: input: it8xxx2_kbd: fix col_size build warning range\n\nFix the range check for col_size to allow a configuration with less than\n16 columns. Not sure why the minimum was set so high but there's no\nreason I can tell for it."
},{
  "instruction": "There is an issue in the following code. It relates to tests: usb: add usb_set_config() call to desc_sections test\n\nWith the previous changes, usb_set_config() is no longer called by\ndefault at boot time, causing the test to fail. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|struct\nname|usb_desc_header\nmodifier|*\nname|head\ndecl_stmt|;\nname|TC_PRINT\nargument_list|(\nliteral|\"__usb_descriptor_start %p\\n\"\nargument_list|,\nname|__usb_descriptor_start",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|usb_set_config\n+argument_list|(\n+name|usb_get_device_descriptor\n+argument_list|()\n+argument_list|)\n+expr_stmt|;\nThe issue was with: tests: usb: add usb_set_config() call to desc_sections test\n\nWith the previous changes, usb_set_config() is no longer called by\ndefault at boot time, causing the test to fail."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: rtc: stm32: INF log msg to DBG\n\nTurn INF log msg to DBG. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nreturn|return\nname|err\nreturn|;\nblock|}\nname|LOG_INF\nargument_list|(\nliteral|\"Setting clock\"\nargument_list|)\nexpr_stmt|;\nif|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|LOG_INF\n+name|LOG_DBG\nThe issue was with: drivers: rtc: stm32: INF log msg to DBG\n\nTurn INF log msg to DBG."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: rtc: stm32: check for NULL pointer\n\nCheck for NULL rtc_time pointer in get_time() function. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|uint32_t\nname|rtc_subsecond\ndecl_stmt|;\nendif|#\ndirective|endif\nname|int\nname|err\ninit|=\nname|k_mutex_lock\nargument_list|(\nname|RTC\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\nblock|}\ndo|while\ncondition|(\nname|rtc_time\noperator|!=",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* HW_SUBSECOND_SUPPORT */\n+if|if\n+condition|(\n+name|timeptr\n+operator|==\n+name|NULL\n+condition|)\n+block|{\n+name|LOG_ERR\n+argument_list|(\n+literal|\"NULL rtc_time pointer\"\n+argument_list|)\n+expr_stmt|;\n+return|return\n+operator|-\n+name|EINVAL\n+return|;\n+block|}\n+comment|/* HW_SUBSECOND_SUPPORT */\nThe issue was with: drivers: rtc: stm32: check for NULL pointer\n\nCheck for NULL rtc_time pointer in get_time() function."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: regulator: Smartbond: Fix current and voltage get functions\n\nArgument to FIELD_GET macro was mixed up resulting in\nincorrect values being reported for voltage and current Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nname|idx\noperator|=\nname|FIELD_GET\nargument_list|(\nname|CRG_TOP\noperator|->\nname|POWER_CTRL_REG\nargument_list|,\nname|config\noperator|->\nname|desc\noperator|->\nname|voltage_idx_mask\nargument_list|)\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\nblock|}\nname|idx\noperator|=\nname|FIELD_GET\nargument_list|(\noperator|*\nname|config\noperator|->\nname|desc\noperator|->\nname|dcdc_register\nargument_list|,\nname|DCDC_DCDC_V14_REG_DCDC_V14_CUR_LIM_MAX_HV_Msk\nargument_list|)\nexpr_stmt|;\nname|ret\noperator|=\nname|linear_range_group_get_value",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CRG_TOP\n-operator|->\n-name|POWER_CTRL_REG\n-argument_list|,\n+argument_list|,\n+name|CRG_TOP\n+operator|->\n+name|POWER_CTRL_REG\n+name|DCDC_DCDC_V14_REG_DCDC_V14_CUR_LIM_MAX_HV_Msk\n+argument_list|,\n-argument_list|,\n-name|DCDC_DCDC_V14_REG_DCDC_V14_CUR_LIM_MAX_HV_Msk\nThe issue was with: drivers: regulator: Smartbond: Fix current and voltage get functions\n\nArgument to FIELD_GET macro was mixed up resulting in\nincorrect values being reported for voltage and current"
},{
  "instruction": "There is an issue in the following code. It relates to tests/kernel/context: Detect spurious wakes during timeout check\n\nIn b36d1e11f5cb6dc8d8d865646154f1651dbfd5c2 [formerly 972a4d9f6f82c811281fd53ef27a028bf2880955]\nthe test was relaxed to allow a possible parallel thread\nwaking the CPU during the idle timeout checks.\n\nHow this was done though, a system timer driver\nwhich wakes the kernel spuriously a bit before the\ncorrect deadline would not be detected, even\nthough it should.\n\nLet's fix this, ensuring the timer has been\ncalled when we check the wake time in inside the\nexpected range. Please fix this issue.",
  "input": "Faulty tokenized code:\nendif|#\ndirective|endif\nend_endif\n\nbegin_typedef\nDECL|struct|__anon2be1a4960108\ntypedef|typedef\nstruct|struct\nblock|{\nDECL|member|command\nname|int\nDECL|member|error\nname|int\nname|error\ndecl_stmt|;\ncomment|/* error value (if any) */\nDECL|union|__anon2be1a496020a\nunion|union\nblock|{\nDECL|member|data\nname|void\nmodifier|*\noperator|==\nname|false\noperator|)\ncondition|)\ndo|;\nname|dt\noperator|=\nname|k_uptime_ticks\nargument_list|()\noperator|-",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2be1a4960108\n+DECL|struct|__anon2c53eac20108\n-DECL|union|__anon2be1a496020a\n+DECL|union|__anon2c53eac2020a\n+name|zassert_true\n+argument_list|(\n+name|idle_timer_done\n+argument_list|,\n+literal|\"The CPU was waken spuriously too many times (%d> %d)\"\n+argument_list|,\n+name|idle_loops\n+argument_list|,\n+name|CONFIG_MAX_IDLE_WAKES\n+argument_list|)\n+expr_stmt|;\nThe issue was with: tests/kernel/context: Detect spurious wakes during timeout check\n\nIn b36d1e11f5cb6dc8d8d865646154f1651dbfd5c2 [formerly 972a4d9f6f82c811281fd53ef27a028bf2880955]\nthe test was relaxed to allow a possible parallel thread\nwaking the CPU during the idle timeout checks.\n\nHow this was done though, a system timer driver\nwhich wakes the kernel spuriously a bit before the\ncorrect deadline would not be detected, even\nthough it should.\n\nLet's fix this, ensuring the timer has been\ncalled when we check the wake time in inside the\nexpected range."
},{
  "instruction": "There is an issue in the following code. It relates to llext: add support for STT_OBJECT relocations\n\nThese relocations are needed e.g. when an LLEXT is built from\nmultiple files and they share data objects. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|st_name\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|stt\noperator|==\nname|STT_FUNC\noperator|&&\nname|stb\noperator|==\nname|STB_GLOBAL\ncondition|)\noperator|.\nname|st_shndx\ndecl_stmt|;\nif|if\ncondition|(\nname|stt\noperator|==\nname|STT_FUNC\noperator|&&\nname|stb\noperator|==\nname|STB_GLOBAL\noperator|&&\noperator|&&\nname|stt\noperator|!=\nname|STT_SECTION\noperator|&&\noperator|(\nname|stt\noperator|!=\nname|STT_NOTYPE\noperator|||",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+operator|||\n+name|stt\n+operator|==\n+name|STT_OBJECT\n+operator|)\n+operator|(\n+operator|||\n+name|stt\n+operator|==\n+name|STT_OBJECT\n+operator|)\n+name|stt\n+operator|!=\n+name|STT_OBJECT\n+operator|&&\nThe issue was with: llext: add support for STT_OBJECT relocations\n\nThese relocations are needed e.g. when an LLEXT is built from\nmultiple files and they share data objects."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: ethernet: ksz8863 Fix wrong register for tail tag enable\n\nA wrong register address was used to enable tail tagging for\nthe ksz8863 device. Please fix this issue.",
  "input": "Faulty tokenized code:\ncomment|/* Enable tail tag feature */\nname|dsa_ksz8xxx_read_reg\nargument_list|(\nname|pdev\nargument_list|,\nname|KSZ8863_GLOBAL_CTRL10\nargument_list|,\noperator|&\nname|tmp\nargument_list|)\nexpr_stmt|;\nexpr_stmt|;\nname|dsa_ksz8xxx_write_reg\nargument_list|(\nname|pdev\nargument_list|,\nname|KSZ8863_GLOBAL_CTRL10\nargument_list|,\nname|tmp\nargument_list|)\nexpr_stmt|;\nelse|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|KSZ8863_GLOBAL_CTRL10\n+name|KSZ8863_GLOBAL_CTRL1\n-name|KSZ8863_GLOBAL_CTRL10\n+name|KSZ8863_GLOBAL_CTRL1\nThe issue was with: drivers: ethernet: ksz8863 Fix wrong register for tail tag enable\n\nA wrong register address was used to enable tail tagging for\nthe ksz8863 device."
},{
  "instruction": "There is an issue in the following code. It relates to usb: device_next: Properly store enumeration speed\n\nAdd missing break inside switch statement to allow UDC context to\nindicate that current operating speed is High-Speed. Due to missing\nbreak statement, the stack always assumed Full-Speed. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|.\nname|speed\noperator|=\nname|USBD_SPEED_HS\nexpr_stmt|;\ndefault|default:\nname|uds_ctx\noperator|->\nname|status\noperator|.",
  "result": "I corrected the issue in the code by changing the following tokens:\n+break|break;\nThe issue was with: usb: device_next: Properly store enumeration speed\n\nAdd missing break inside switch statement to allow UDC context to\nindicate that current operating speed is High-Speed. Due to missing\nbreak statement, the stack always assumed Full-Speed."
},{
  "instruction": "There is an issue in the following code. It relates to pinctrl: stm32: add remap support for STM32C0\n\nAdd remap11 and remap12 support for STM32C0 series Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|!\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_STM32G0X\nargument_list|)\nerror|#\ndirective|error\nliteral|\"Pin remap property available only on STM32G0 SoC series\"\nendif|#\ndirective|endif\nname|LL_APB2_GRP1_EnableClock\nargument_list|(\nname|LL_APB2_GRP1_PERIPH_SYSCFG\n    required: true\n\n  remap-pa11:\n    type: boolean\n    description: Remaps the PA11 pin to operate as PA9 pin.\n     Use of this property is restricted to STM32G0 SoCs.\n\n  remap-pa12:\n    type: boolean\n    description: Remaps the PA12 pin to operate as PA10 pin.\n     Use of this property is restricted to STM32G0 SoCs.\n\n  remap-pa11-pa12:\n    type: boolean\n    description: Remaps the PA11/PA12 pin to operate as PA9/PA10 pin.\n      Use of this property is restricted to STM32F070x SoCs.",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|&&\n+operator|!\n+name|defined\n+argument_list|(\n+name|CONFIG_SOC_SERIES_STM32C0X\n+argument_list|)\n-literal|\"Pin remap property available only on STM32G0 SoC series\"\n+literal|\"Pin remap property available only on STM32G0 and STM32C0 SoC series\"\n-      Use of this property is restricted to STM32G0 SoCs.\n+      Use of this property is restricted to STM32G0 and STM32C0 SoCs.\n-      Use of this property is restricted to STM32G0 SoCs.\n+      Use of this property is restricted to STM32G0 and STM32C0 SoCs.\nThe issue was with: pinctrl: stm32: add remap support for STM32C0\n\nAdd remap11 and remap12 support for STM32C0 series"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: host: handle not getting a buffer\n\nnet_buf_alloc(K_FOREVER) can now fail (if run from the syswq). Propagate to\nthe caller instead of asserting. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|opcode\nargument_list|,\nname|param_len\nargument_list|)\nexpr_stmt|;\nname|buf\noperator|=\nname|net_buf_alloc\nargument_list|(\noperator|&\nname|hci_cmd_pool\nargument_list|,\nname|K_FOREVER\nargument_list|)\nexpr_stmt|;\nname|__ASSERT_NO_MSG\nargument_list|(\nname|buf\nargument_list|)\nexpr_stmt|;\nname|LOG_DBG\nargument_list|(\nliteral|\"buf %p\"\nargument_list|,\nname|buf\nname|hci_vs_init\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nDECL|union|__anon2744fa24010a\nunion|union\nblock|{\nDECL|member|info\nname|struct\nname|bt_hci_rp_vs_read_version_info",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* net_buf_alloc(K_FOREVER) can fail when run from the syswq */\n-name|__ASSERT_NO_MSG\n-argument_list|(\n+if|if\n+condition|(\n+operator|!\n+condition|)\n+block|{\n+name|LOG_DBG\n+argument_list|(\n+literal|\"Unable to allocate a command buffer\"\n+return|return\n+name|NULL\n+return|;\n+block|}\n-DECL|union|__anon2744fa24010a\n+DECL|union|__anon279271ec010a\nThe issue was with: Bluetooth: host: handle not getting a buffer\n\nnet_buf_alloc(K_FOREVER) can now fail (if run from the syswq). Propagate to\nthe caller instead of asserting."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: memc: memc_mcux_flexspi: support diff RX clock source on port B\n\nSome instances of the FlexSPI IP support a different clock source being\nused for port B of the FlexSPI instance. Add a devicetree property and\ndriver support to enable configuring this property of the hardware. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|read\noperator|-\nend_expr_stmt\n\nbegin_while\nwhile|while-write hazards. This configuration is not recommended.\" #endif  #define FLEXSPI_MAX_LUT 64U  LOG_MODULE_REGISTER(memc_flexspi, CONFIG_MEMC_LOG_LEVEL);  struct memc_flexspi_buf_cfg { \tuint16_t prefetch; \tuint16_t priority; \tuint16_t master_id; \tuint16_t buf_size; } __packed;  /* Structure tracking LUT offset and usage per each port */ struct port_lut { \tuint8_t lut_offset; \tuint8_t lut_used; };  /* flexspi device data should be stored in RAM to avoid read-while-write hazards */ struct memc_flexspi_data { \tFLEXSPI_Type *base; \tuint8_t *ahb_base; \tbool xip; \tbool ahb_bufferable; \tbool ahb_cacheable; \tbool ahb_prefetch; \tbool ahb_read_addr_opt; \tbool combination_mode; \tbool sck_differential_clock; \tflexspi_read_sample_clock_t rx_sample_clock; \tconst struct pinctrl_dev_config *pincfg; \tsize_t size[kFLEXSPI_PortCount]; \tstruct port_lut port_luts[kFLEXSPI_PortCount]; \tstruct memc_flexspi_buf_cfg *buf_cfg; \tuint8_t buf_cfg_cnt; \tconst struct device *clock_dev; \tclock_control_subsys_t clock_subsys; };  void memc_flexspi_wait_bus_idle(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \twhile (false == FLEXSPI_GetBusIdleStatus(data->base)) { \t} }  bool memc_flexspi_is_running_xip(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \treturn data->xip; }  int memc_flexspi_update_clock(const struct device *dev, \t\tflexspi_device_config_t *device_config, \t\tflexspi_port_t port, uint32_t freq_hz) { \tstruct memc_flexspi_data *data = dev->data; \tuint32_t rate; \tuint32_t key; \tint ret;  \t/* To reclock the FlexSPI, we should: \t * - disable the module \t * - set the new clock \t * - reenable the module \t * - reset the module \t * We CANNOT XIP at any point during this process \t */ \tkey = irq_lock(); \tmemc_flexspi_wait_bus_idle(dev);  \tret = clock_control_set_rate(data->clock_dev, data->clock_subsys, \t\t\t\t(clock_control_subsys_rate_t)freq_hz); \tif (ret< 0) { \t\tirq_unlock(key); \t\treturn ret; \t}  \t/* \t * We need to update the DLL value before we call clock_control_get_rate, \t * because this will cause XIP (flash reads) to occur. Although the \t * true flash clock is not known, assume the set_rate function programmed \t * a value close to what we requested. \t */ \tdevice_config->flexspiRootClk = freq_hz; \tFLEXSPI_UpdateDllValue(data->base, device_config, port); \tmemc_flexspi_reset(dev);  \tmemc_flexspi_wait_bus_idle(dev); \tret = clock_control_get_rate(data->clock_dev, data->clock_subsys,&rate); \tif (ret< 0) { \t\tirq_unlock(key); \t\treturn ret; \t}   \tdevice_config->flexspiRootClk = rate; \tFLEXSPI_UpdateDllValue(data->base, device_config, port);  \tmemc_flexspi_reset(dev);  \tirq_unlock(key);  \treturn 0; }  int memc_flexspi_set_device_config(const struct device *dev, \t\tconst flexspi_device_config_t *device_config, \t\tconst uint32_t *lut_array, \t\tuint8_t lut_count, \t\tflexspi_port_t port) { \tflexspi_device_config_t tmp_config; \tuint32_t tmp_lut[FLEXSPI_MAX_LUT]; \tstruct memc_flexspi_data *data = dev->data; \tconst uint32_t *lut_ptr = lut_array; \tuint8_t lut_used = 0U; \tunsigned int key = 0;  \tif (port>= kFLEXSPI_PortCount) { \t\tLOG_ERR(\"Invalid port number\"); \t\treturn -EINVAL; \t}  \tif (data->port_luts[port].lut_used< lut_count) { \t\t/* We cannot reuse the existing LUT slot, \t\t * Check if the LUT table will fit into the remaining LUT slots \t\t */ \t\tfor (uint8_t i = 0; i< kFLEXSPI_PortCount; i++) { \t\t\tlut_used += data->port_luts[i].lut_used; \t\t}  \t\tif ((lut_used + lut_count)> FLEXSPI_MAX_LUT) { \t\t\treturn -ENOBUFS; \t\t} \t}  \tdata->size[port] = device_config->flashSize * KB(1);  \tif (memc_flexspi_is_running_xip(dev)) { \t\t/* We need to avoid flash access while configuring the FlexSPI. \t\t * To do this, we will copy the LUT array into stack-allocated \t\t * temporary memory \t\t */ \t\tmemcpy(tmp_lut, lut_array, lut_count * MEMC_FLEXSPI_CMD_SIZE); \t\tlut_ptr = tmp_lut; \t}  \tmemcpy(&tmp_config, device_config, sizeof(tmp_config)); \t/* Update FlexSPI AWRSEQID and ARDSEQID values based on where the LUT \t * array will actually be loaded. \t */ \tif (data->port_luts[port].lut_used< lut_count) { \t\t/* Update lut offset with new value */ \t\tdata->port_luts[port].lut_offset = lut_used; \t} \tdata->port_luts[port].lut_used = lut_count; \ttmp_config.ARDSeqIndex += data->port_luts[port].lut_offset; \ttmp_config.AWRSeqIndex += data->port_luts[port].lut_offset;  \t/* Lock IRQs before reconfiguring FlexSPI, to prevent XIP */ \tkey = irq_lock();  \tFLEXSPI_SetFlashConfig(data->base,&tmp_config, port); \tFLEXSPI_UpdateLUT(data->base, data->port_luts[port].lut_offset, \t\t\t  lut_ptr, lut_count); \tirq_unlock(key);  \treturn 0; }  int memc_flexspi_reset(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \tFLEXSPI_SoftwareReset(data->base);  \treturn 0; }  int memc_flexspi_transfer(const struct device *dev, \t\tflexspi_transfer_t *transfer) { \tstruct memc_flexspi_data *data = dev->data; \tstatus_t status;  \t/* Adjust transfer LUT index based on port */ \ttransfer->seqIndex += data->port_luts[transfer->port].lut_offset; \tstatus = FLEXSPI_TransferBlocking(data->base, transfer);  \tif (status != kStatus_Success) { \t\tLOG_ERR(\"Transfer error: %d\", status); \t\treturn -EIO; \t}  \treturn 0; }  void *memc_flexspi_get_ahb_address(const struct device *dev, \t\tflexspi_port_t port, off_t offset) { \tstruct memc_flexspi_data *data = dev->data; \tint i;  \tif (port>= kFLEXSPI_PortCount) { \t\tLOG_ERR(\"Invalid port number: %u\", port); \t\treturn NULL; \t}  \tfor (i = 0; i< port; i++) { \t\toffset += data->size[i]; \t}  \treturn data->ahb_base + offset; }  static int memc_flexspi_init(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data; \tflexspi_config_t flexspi_config;  \t/* we should not configure the device we are running on */ \tif (memc_flexspi_is_running_xip(dev)) { \t\tLOG_DBG(\"XIP active on %s\noperator|,\nname|skipping\nname|init\nliteral|\", dev->name); \t\treturn 0; \t}  \t/* \t * SOCs such as the RT1064 and RT1024 have internal flash, and no pinmux \t * settings, continue if no pinctrl state found. \t */ \tint ret;  \tret = pinctrl_apply_state(data->pincfg, PINCTRL_STATE_DEFAULT); \tif (ret< 0&& ret != -ENOENT) { \t\treturn ret; \t}  \tFLEXSPI_GetDefaultConfig(&flexspi_config);  \tflexspi_config.ahbConfig.enableAHBBufferable = data->ahb_bufferable; \tflexspi_config.ahbConfig.enableAHBCachable = data->ahb_cacheable; \tflexspi_config.ahbConfig.enableAHBPrefetch = data->ahb_prefetch; \tflexspi_config.ahbConfig.enableReadAddressOpt = data->ahb_read_addr_opt; #if !(defined(FSL_FEATURE_FLEXSPI_HAS_NO_MCR0_COMBINATIONEN)&& \\ \tFSL_FEATURE_FLEXSPI_HAS_NO_MCR0_COMBINATIONEN) \tflexspi_config.enableCombination = data->combination_mode; #endif  #if !(defined(FSL_FEATURE_FLEXSPI_HAS_NO_MCR2_SCKBDIFFOPT)&& \\ \tFSL_FEATURE_FLEXSPI_HAS_NO_MCR2_SCKBDIFFOPT) \tflexspi_config.enableSckBDiffOpt = data->sck_differential_clock; #endif \tflexspi_config.rxSampleClock = data->rx_sample_clock;  \t/* Configure AHB RX buffers, if any configuration settings are present */ \t__ASSERT(data->buf_cfg_cnt< FSL_FEATURE_FLEXSPI_AHB_BUFFER_COUNT, \t\t\"\nname|Maximum\nname|RX\nname|buffer\nname|configuration\nname|count\nname|exceeded\nliteral|\"\nend_while\n\nunit|); \tfor (uint8_t i = 0; i< data->buf_cfg_cnt; i++) { \t\t/* Should AHB prefetch up to buffer size? */ \t\tflexspi_config.ahbConfig.buffer[i].enablePrefetch = data->buf_cfg[i].prefetch; \t\t/* AHB access priority (used for suspending control of AHB prefetching )*/ \t\tflexspi_config.ahbConfig.buffer[i].priority = data->buf_cfg[i].priority; \t\t/* AHB master index, SOC specific */ \t\tflexspi_config.ahbConfig.buffer[i].masterIndex = data->buf_cfg[i].master_id; \t\t/* RX buffer allocation (total available buffer space is instance/SOC specific) */ \t\tflexspi_config.ahbConfig.buffer[i].bufferSize = data->buf_cfg[i].buf_size; \t}  \tFLEXSPI_Init(data->base,&flexspi_config);  \treturn 0; }  #ifdef CONFIG_PM_DEVICE static int memc_flexspi_pm_action(const struct device *dev, enum pm_device_action action) { \tstruct memc_flexspi_data *data = dev->data; \tint ret;  \tswitch (action) { \tcase PM_DEVICE_ACTION_RESUME: \t\tret = pinctrl_apply_state(data->pincfg, PINCTRL_STATE_DEFAULT); \t\tif (ret< 0&& ret != -ENOENT) { \t\t\treturn ret; \t\t} \t\tbreak; \tcase PM_DEVICE_ACTION_SUSPEND: \t\tret = pinctrl_apply_state(data->pincfg, PINCTRL_STATE_SLEEP); \t\tif (ret< 0&& ret != -ENOENT) { \t\t\treturn ret; \t\t} \t\tbreak; \tdefault: \t\treturn -ENOTSUP; \t}  \treturn 0; } #endif  #if defined(CONFIG_XIP)&& defined(CONFIG_FLASH_MCUX_FLEXSPI_XIP) /* Checks if image flash base address is in the FlexSPI AHB base region */ #define MEMC_FLEXSPI_CFG_XIP(node_id)\t\t\t\t\t\t\\ \t((CONFIG_FLASH_BASE_ADDRESS)>= DT_REG_ADDR_BY_IDX(node_id, 1))&&\t\\ \t((CONFIG_FLASH_BASE_ADDRESS)< (DT_REG_ADDR_BY_IDX(node_id, 1) +\t\\ \t\t\t\t\tDT_REG_SIZE_BY_IDX(node_id, 1)))  #else #define MEMC_FLEXSPI_CFG_XIP(node_id) false #endif  #define MEMC_FLEXSPI(n)\t\t\t\t\t\t\t\\ \tPINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t\\ \tstatic uint16_t  buf_cfg_##n[] =\t\t\t\t\\ \t\tDT_INST_PROP_OR(n, rx_buffer_config, {0});\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic struct memc_flexspi_data\t\t\t\t\t\\ \t\tmemc_flexspi_data_##n = {\t\t\t\t\\ \t\t.base = (FLEXSPI_Type *) DT_INST_REG_ADDR(n),\t\t\\ \t\t.xip = MEMC_FLEXSPI_CFG_XIP(DT_DRV_INST(n)),\t\t\\ \t\t.ahb_base = (uint8_t *) DT_INST_REG_ADDR_BY_IDX(n, 1),\t\\ \t\t.ahb_bufferable = DT_INST_PROP(n, ahb_bufferable),\t\\ \t\t.ahb_cacheable = DT_INST_PROP(n, ahb_cacheable),\t\\ \t\t.ahb_prefetch = DT_INST_PROP(n, ahb_prefetch),\t\t\\ \t\t.ahb_read_addr_opt = DT_INST_PROP(n, ahb_read_addr_opt),\\ \t\t.combination_mode = DT_INST_PROP(n, combination_mode),\t\\ \t\t.sck_differential_clock = DT_INST_PROP(n, sck_differential_clock),\t\\ \t\t.rx_sample_clock = DT_INST_PROP(n, rx_clock_source),\t\\ \t\t.buf_cfg = (struct memc_flexspi_buf_cfg *)buf_cfg_##n,\t\\ \t\t.buf_cfg_cnt = sizeof(buf_cfg_##n) /\t\t\t\\ \t\t\tsizeof(struct memc_flexspi_buf_cfg),\t\t\\ \t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\\ \t\t.clock_dev = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(n)),     \\ \t\t.clock_subsys = (clock_control_subsys_t)                \\ \t\t\tDT_INST_CLOCKS_CELL(n, name),                   \\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(n, memc_flexspi_pm_action);\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n,\t\t\t\t\t\\ \t\t\t      memc_flexspi_init,\t\t\t\\ \t\t\t      PM_DEVICE_DT_INST_GET(n),\t\t\t\\&memc_flexspi_data_##n,\t\t\t\\ \t\t\t      NULL,\t\t\t\t\t\\ \t\t\t      POST_KERNEL,\t\t\t\t\\ \t\t\t      CONFIG_MEMC_INIT_PRIORITY,\t\\ \t\t\t      NULL);  DT_INST_FOREACH_STATUS_OKAY(MEMC_FLEXSPI)\nend_unit\n\n      - 3 # External input from DQS pad\n    description: |\n      Source clock for flash read. See the RXCLKSRC field in register MCR0.\n      The default corresponds to the reset value of the register field.\n\n  rx-buffer-config:\n    type: array\n    description: |\n      Array of tuples to configure AHB RX buffers. Format is the following:\n      <prefetch priority master_id buf_size>. Pass multiple tuples to configure",
  "result": "I corrected the issue in the code by changing the following tokens:\n-while|while-write hazards. This configuration is not recommended.\" #endif  #define FLEXSPI_MAX_LUT 64U  LOG_MODULE_REGISTER(memc_flexspi, CONFIG_MEMC_LOG_LEVEL);  struct memc_flexspi_buf_cfg { \tuint16_t prefetch; \tuint16_t priority; \tuint16_t master_id; \tuint16_t buf_size; } __packed;  /* Structure tracking LUT offset and usage per each port */ struct port_lut { \tuint8_t lut_offset; \tuint8_t lut_used; };  /* flexspi device data should be stored in RAM to avoid read-while-write hazards */ struct memc_flexspi_data { \tFLEXSPI_Type *base; \tuint8_t *ahb_base; \tbool xip; \tbool ahb_bufferable; \tbool ahb_cacheable; \tbool ahb_prefetch; \tbool ahb_read_addr_opt; \tbool combination_mode; \tbool sck_differential_clock; \tflexspi_read_sample_clock_t rx_sample_clock; \tconst struct pinctrl_dev_config *pincfg; \tsize_t size[kFLEXSPI_PortCount]; \tstruct port_lut port_luts[kFLEXSPI_PortCount]; \tstruct memc_flexspi_buf_cfg *buf_cfg; \tuint8_t buf_cfg_cnt; \tconst struct device *clock_dev; \tclock_control_subsys_t clock_subsys; };  void memc_flexspi_wait_bus_idle(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \twhile (false == FLEXSPI_GetBusIdleStatus(data->base)) { \t} }  bool memc_flexspi_is_running_xip(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \treturn data->xip; }  int memc_flexspi_update_clock(const struct device *dev, \t\tflexspi_device_config_t *device_config, \t\tflexspi_port_t port, uint32_t freq_hz) { \tstruct memc_flexspi_data *data = dev->data; \tuint32_t rate; \tuint32_t key; \tint ret;  \t/* To reclock the FlexSPI, we should: \t * - disable the module \t * - set the new clock \t * - reenable the module \t * - reset the module \t * We CANNOT XIP at any point during this process \t */ \tkey = irq_lock(); \tmemc_flexspi_wait_bus_idle(dev);  \tret = clock_control_set_rate(data->clock_dev, data->clock_subsys, \t\t\t\t(clock_control_subsys_rate_t)freq_hz); \tif (ret< 0) { \t\tirq_unlock(key); \t\treturn ret; \t}  \t/* \t * We need to update the DLL value before we call clock_control_get_rate, \t * because this will cause XIP (flash reads) to occur. Although the \t * true flash clock is not known, assume the set_rate function programmed \t * a value close to what we requested. \t */ \tdevice_config->flexspiRootClk = freq_hz; \tFLEXSPI_UpdateDllValue(data->base, device_config, port); \tmemc_flexspi_reset(dev);  \tmemc_flexspi_wait_bus_idle(dev); \tret = clock_control_get_rate(data->clock_dev, data->clock_subsys,&rate); \tif (ret< 0) { \t\tirq_unlock(key); \t\treturn ret; \t}   \tdevice_config->flexspiRootClk = rate; \tFLEXSPI_UpdateDllValue(data->base, device_config, port);  \tmemc_flexspi_reset(dev);  \tirq_unlock(key);  \treturn 0; }  int memc_flexspi_set_device_config(const struct device *dev, \t\tconst flexspi_device_config_t *device_config, \t\tconst uint32_t *lut_array, \t\tuint8_t lut_count, \t\tflexspi_port_t port) { \tflexspi_device_config_t tmp_config; \tuint32_t tmp_lut[FLEXSPI_MAX_LUT]; \tstruct memc_flexspi_data *data = dev->data; \tconst uint32_t *lut_ptr = lut_array; \tuint8_t lut_used = 0U; \tunsigned int key = 0;  \tif (port>= kFLEXSPI_PortCount) { \t\tLOG_ERR(\"Invalid port number\"); \t\treturn -EINVAL; \t}  \tif (data->port_luts[port].lut_used< lut_count) { \t\t/* We cannot reuse the existing LUT slot, \t\t * Check if the LUT table will fit into the remaining LUT slots \t\t */ \t\tfor (uint8_t i = 0; i< kFLEXSPI_PortCount; i++) { \t\t\tlut_used += data->port_luts[i].lut_used; \t\t}  \t\tif ((lut_used + lut_count)> FLEXSPI_MAX_LUT) { \t\t\treturn -ENOBUFS; \t\t} \t}  \tdata->size[port] = device_config->flashSize * KB(1);  \tif (memc_flexspi_is_running_xip(dev)) { \t\t/* We need to avoid flash access while configuring the FlexSPI. \t\t * To do this, we will copy the LUT array into stack-allocated \t\t * temporary memory \t\t */ \t\tmemcpy(tmp_lut, lut_array, lut_count * MEMC_FLEXSPI_CMD_SIZE); \t\tlut_ptr = tmp_lut; \t}  \tmemcpy(&tmp_config, device_config, sizeof(tmp_config)); \t/* Update FlexSPI AWRSEQID and ARDSEQID values based on where the LUT \t * array will actually be loaded. \t */ \tif (data->port_luts[port].lut_used< lut_count) { \t\t/* Update lut offset with new value */ \t\tdata->port_luts[port].lut_offset = lut_used; \t} \tdata->port_luts[port].lut_used = lut_count; \ttmp_config.ARDSeqIndex += data->port_luts[port].lut_offset; \ttmp_config.AWRSeqIndex += data->port_luts[port].lut_offset;  \t/* Lock IRQs before reconfiguring FlexSPI, to prevent XIP */ \tkey = irq_lock();  \tFLEXSPI_SetFlashConfig(data->base,&tmp_config, port); \tFLEXSPI_UpdateLUT(data->base, data->port_luts[port].lut_offset, \t\t\t  lut_ptr, lut_count); \tirq_unlock(key);  \treturn 0; }  int memc_flexspi_reset(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \tFLEXSPI_SoftwareReset(data->base);  \treturn 0; }  int memc_flexspi_transfer(const struct device *dev, \t\tflexspi_transfer_t *transfer) { \tstruct memc_flexspi_data *data = dev->data; \tstatus_t status;  \t/* Adjust transfer LUT index based on port */ \ttransfer->seqIndex += data->port_luts[transfer->port].lut_offset; \tstatus = FLEXSPI_TransferBlocking(data->base, transfer);  \tif (status != kStatus_Success) { \t\tLOG_ERR(\"Transfer error: %d\", status); \t\treturn -EIO; \t}  \treturn 0; }  void *memc_flexspi_get_ahb_address(const struct device *dev, \t\tflexspi_port_t port, off_t offset) { \tstruct memc_flexspi_data *data = dev->data; \tint i;  \tif (port>= kFLEXSPI_PortCount) { \t\tLOG_ERR(\"Invalid port number: %u\", port); \t\treturn NULL; \t}  \tfor (i = 0; i< port; i++) { \t\toffset += data->size[i]; \t}  \treturn data->ahb_base + offset; }  static int memc_flexspi_init(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data; \tflexspi_config_t flexspi_config;  \t/* we should not configure the device we are running on */ \tif (memc_flexspi_is_running_xip(dev)) { \t\tLOG_DBG(\"XIP active on %s\n+while|while-write hazards. This configuration is not recommended.\" #endif  #define FLEXSPI_MAX_LUT 64U  LOG_MODULE_REGISTER(memc_flexspi, CONFIG_MEMC_LOG_LEVEL);  struct memc_flexspi_buf_cfg { \tuint16_t prefetch; \tuint16_t priority; \tuint16_t master_id; \tuint16_t buf_size; } __packed;  /* Structure tracking LUT offset and usage per each port */ struct port_lut { \tuint8_t lut_offset; \tuint8_t lut_used; };  /* flexspi device data should be stored in RAM to avoid read-while-write hazards */ struct memc_flexspi_data { \tFLEXSPI_Type *base; \tuint8_t *ahb_base; \tbool xip; \tbool ahb_bufferable; \tbool ahb_cacheable; \tbool ahb_prefetch; \tbool ahb_read_addr_opt; \tbool combination_mode; \tbool sck_differential_clock; \tflexspi_read_sample_clock_t rx_sample_clock; #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB)&& \\ FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB \tflexspi_read_sample_clock_t rx_sample_clock_b; #endif \tconst struct pinctrl_dev_config *pincfg; \tsize_t size[kFLEXSPI_PortCount]; \tstruct port_lut port_luts[kFLEXSPI_PortCount]; \tstruct memc_flexspi_buf_cfg *buf_cfg; \tuint8_t buf_cfg_cnt; \tconst struct device *clock_dev; \tclock_control_subsys_t clock_subsys; };  void memc_flexspi_wait_bus_idle(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \twhile (false == FLEXSPI_GetBusIdleStatus(data->base)) { \t} }  bool memc_flexspi_is_running_xip(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \treturn data->xip; }  int memc_flexspi_update_clock(const struct device *dev, \t\tflexspi_device_config_t *device_config, \t\tflexspi_port_t port, uint32_t freq_hz) { \tstruct memc_flexspi_data *data = dev->data; \tuint32_t rate; \tuint32_t key; \tint ret;  \t/* To reclock the FlexSPI, we should: \t * - disable the module \t * - set the new clock \t * - reenable the module \t * - reset the module \t * We CANNOT XIP at any point during this process \t */ \tkey = irq_lock(); \tmemc_flexspi_wait_bus_idle(dev);  \tret = clock_control_set_rate(data->clock_dev, data->clock_subsys, \t\t\t\t(clock_control_subsys_rate_t)freq_hz); \tif (ret< 0) { \t\tirq_unlock(key); \t\treturn ret; \t}  \t/* \t * We need to update the DLL value before we call clock_control_get_rate, \t * because this will cause XIP (flash reads) to occur. Although the \t * true flash clock is not known, assume the set_rate function programmed \t * a value close to what we requested. \t */ \tdevice_config->flexspiRootClk = freq_hz; \tFLEXSPI_UpdateDllValue(data->base, device_config, port); \tmemc_flexspi_reset(dev);  \tmemc_flexspi_wait_bus_idle(dev); \tret = clock_control_get_rate(data->clock_dev, data->clock_subsys,&rate); \tif (ret< 0) { \t\tirq_unlock(key); \t\treturn ret; \t}   \tdevice_config->flexspiRootClk = rate; \tFLEXSPI_UpdateDllValue(data->base, device_config, port);  \tmemc_flexspi_reset(dev);  \tirq_unlock(key);  \treturn 0; }  int memc_flexspi_set_device_config(const struct device *dev, \t\tconst flexspi_device_config_t *device_config, \t\tconst uint32_t *lut_array, \t\tuint8_t lut_count, \t\tflexspi_port_t port) { \tflexspi_device_config_t tmp_config; \tuint32_t tmp_lut[FLEXSPI_MAX_LUT]; \tstruct memc_flexspi_data *data = dev->data; \tconst uint32_t *lut_ptr = lut_array; \tuint8_t lut_used = 0U; \tunsigned int key = 0;  \tif (port>= kFLEXSPI_PortCount) { \t\tLOG_ERR(\"Invalid port number\"); \t\treturn -EINVAL; \t}  \tif (data->port_luts[port].lut_used< lut_count) { \t\t/* We cannot reuse the existing LUT slot, \t\t * Check if the LUT table will fit into the remaining LUT slots \t\t */ \t\tfor (uint8_t i = 0; i< kFLEXSPI_PortCount; i++) { \t\t\tlut_used += data->port_luts[i].lut_used; \t\t}  \t\tif ((lut_used + lut_count)> FLEXSPI_MAX_LUT) { \t\t\treturn -ENOBUFS; \t\t} \t}  \tdata->size[port] = device_config->flashSize * KB(1);  \tif (memc_flexspi_is_running_xip(dev)) { \t\t/* We need to avoid flash access while configuring the FlexSPI. \t\t * To do this, we will copy the LUT array into stack-allocated \t\t * temporary memory \t\t */ \t\tmemcpy(tmp_lut, lut_array, lut_count * MEMC_FLEXSPI_CMD_SIZE); \t\tlut_ptr = tmp_lut; \t}  \tmemcpy(&tmp_config, device_config, sizeof(tmp_config)); \t/* Update FlexSPI AWRSEQID and ARDSEQID values based on where the LUT \t * array will actually be loaded. \t */ \tif (data->port_luts[port].lut_used< lut_count) { \t\t/* Update lut offset with new value */ \t\tdata->port_luts[port].lut_offset = lut_used; \t} \tdata->port_luts[port].lut_used = lut_count; \ttmp_config.ARDSeqIndex += data->port_luts[port].lut_offset; \ttmp_config.AWRSeqIndex += data->port_luts[port].lut_offset;  \t/* Lock IRQs before reconfiguring FlexSPI, to prevent XIP */ \tkey = irq_lock();  \tFLEXSPI_SetFlashConfig(data->base,&tmp_config, port); \tFLEXSPI_UpdateLUT(data->base, data->port_luts[port].lut_offset, \t\t\t  lut_ptr, lut_count); \tirq_unlock(key);  \treturn 0; }  int memc_flexspi_reset(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data;  \tFLEXSPI_SoftwareReset(data->base);  \treturn 0; }  int memc_flexspi_transfer(const struct device *dev, \t\tflexspi_transfer_t *transfer) { \tstruct memc_flexspi_data *data = dev->data; \tstatus_t status;  \t/* Adjust transfer LUT index based on port */ \ttransfer->seqIndex += data->port_luts[transfer->port].lut_offset; \tstatus = FLEXSPI_TransferBlocking(data->base, transfer);  \tif (status != kStatus_Success) { \t\tLOG_ERR(\"Transfer error: %d\", status); \t\treturn -EIO; \t}  \treturn 0; }  void *memc_flexspi_get_ahb_address(const struct device *dev, \t\tflexspi_port_t port, off_t offset) { \tstruct memc_flexspi_data *data = dev->data; \tint i;  \tif (port>= kFLEXSPI_PortCount) { \t\tLOG_ERR(\"Invalid port number: %u\", port); \t\treturn NULL; \t}  \tfor (i = 0; i< port; i++) { \t\toffset += data->size[i]; \t}  #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_ADDRESS_SHIFT)&& \\ \t(FSL_FEATURE_FLEXSPI_SUPPORT_ADDRESS_SHIFT) \tif (data->base->FLSHCR0[port]& FLEXSPI_FLSHCR0_ADDRSHIFT_MASK) { \t\t/* Address shift is set, add 0x1000_0000 to AHB address */ \t\toffset += 0x10000000; \t} #endif  \treturn data->ahb_base + offset; }  static int memc_flexspi_init(const struct device *dev) { \tstruct memc_flexspi_data *data = dev->data; \tflexspi_config_t flexspi_config;  \t/* we should not configure the device we are running on */ \tif (memc_flexspi_is_running_xip(dev)) { \t\tLOG_DBG(\"XIP active on %s\n-literal|\", dev->name); \t\treturn 0; \t}  \t/* \t * SOCs such as the RT1064 and RT1024 have internal flash, and no pinmux \t * settings, continue if no pinctrl state found. \t */ \tint ret;  \tret = pinctrl_apply_state(data->pincfg, PINCTRL_STATE_DEFAULT); \tif (ret< 0&& ret != -ENOENT) { \t\treturn ret; \t}  \tFLEXSPI_GetDefaultConfig(&flexspi_config);  \tflexspi_config.ahbConfig.enableAHBBufferable = data->ahb_bufferable; \tflexspi_config.ahbConfig.enableAHBCachable = data->ahb_cacheable; \tflexspi_config.ahbConfig.enableAHBPrefetch = data->ahb_prefetch; \tflexspi_config.ahbConfig.enableReadAddressOpt = data->ahb_read_addr_opt; #if !(defined(FSL_FEATURE_FLEXSPI_HAS_NO_MCR0_COMBINATIONEN)&& \\ \tFSL_FEATURE_FLEXSPI_HAS_NO_MCR0_COMBINATIONEN) \tflexspi_config.enableCombination = data->combination_mode; #endif  #if !(defined(FSL_FEATURE_FLEXSPI_HAS_NO_MCR2_SCKBDIFFOPT)&& \\ \tFSL_FEATURE_FLEXSPI_HAS_NO_MCR2_SCKBDIFFOPT) \tflexspi_config.enableSckBDiffOpt = data->sck_differential_clock; #endif \tflexspi_config.rxSampleClock = data->rx_sample_clock;  \t/* Configure AHB RX buffers, if any configuration settings are present */ \t__ASSERT(data->buf_cfg_cnt< FSL_FEATURE_FLEXSPI_AHB_BUFFER_COUNT, \t\t\"\n+literal|\", dev->name); \t\treturn 0; \t}  \t/* \t * SOCs such as the RT1064 and RT1024 have internal flash, and no pinmux \t * settings, continue if no pinctrl state found. \t */ \tint ret;  \tret = pinctrl_apply_state(data->pincfg, PINCTRL_STATE_DEFAULT); \tif (ret< 0&& ret != -ENOENT) { \t\treturn ret; \t}  \tFLEXSPI_GetDefaultConfig(&flexspi_config);  \tflexspi_config.ahbConfig.enableAHBBufferable = data->ahb_bufferable; \tflexspi_config.ahbConfig.enableAHBCachable = data->ahb_cacheable; \tflexspi_config.ahbConfig.enableAHBPrefetch = data->ahb_prefetch; \tflexspi_config.ahbConfig.enableReadAddressOpt = data->ahb_read_addr_opt; #if !(defined(FSL_FEATURE_FLEXSPI_HAS_NO_MCR0_COMBINATIONEN)&& \\ \tFSL_FEATURE_FLEXSPI_HAS_NO_MCR0_COMBINATIONEN) \tflexspi_config.enableCombination = data->combination_mode; #endif  #if !(defined(FSL_FEATURE_FLEXSPI_HAS_NO_MCR2_SCKBDIFFOPT)&& \\ \tFSL_FEATURE_FLEXSPI_HAS_NO_MCR2_SCKBDIFFOPT) \tflexspi_config.enableSckBDiffOpt = data->sck_differential_clock; #endif \tflexspi_config.rxSampleClock = data->rx_sample_clock; #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB)&& \\ FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB \tflexspi_config.rxSampleClockPortB = data->rx_sample_clock_b; #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_RXCLKSRC_DIFF)&& \\ \tFSL_FEATURE_FLEXSPI_SUPPORT_RXCLKSRC_DIFF \tif (flexspi_config.rxSampleClock != flexspi_config.rxSampleClockPortB) { \t\tflexspi_config.rxSampleClockDiff = true; \t} #endif #endif  \t/* Configure AHB RX buffers, if any configuration settings are present */ \t__ASSERT(data->buf_cfg_cnt< FSL_FEATURE_FLEXSPI_AHB_BUFFER_COUNT, \t\t\"\n-unit|); \tfor (uint8_t i = 0; i< data->buf_cfg_cnt; i++) { \t\t/* Should AHB prefetch up to buffer size? */ \t\tflexspi_config.ahbConfig.buffer[i].enablePrefetch = data->buf_cfg[i].prefetch; \t\t/* AHB access priority (used for suspending control of AHB prefetching )*/ \t\tflexspi_config.ahbConfig.buffer[i].priority = data->buf_cfg[i].priority; \t\t/* AHB master index, SOC specific */ \t\tflexspi_config.ahbConfig.buffer[i].masterIndex = data->buf_cfg[i].master_id; \t\t/* RX buffer allocation (total available buffer space is instance/SOC specific) */ \t\tflexspi_config.ahbConfig.buffer[i].bufferSize = data->buf_cfg[i].buf_size; \t}  \tFLEXSPI_Init(data->base,&flexspi_config);  \treturn 0; }  #ifdef CONFIG_PM_DEVICE static int memc_flexspi_pm_action(const struct device *dev, enum pm_device_action action) { \tstruct memc_flexspi_data *data = dev->data; \tint ret;  \tswitch (action) { \tcase PM_DEVICE_ACTION_RESUME: \t\tret = pinctrl_apply_state(data->pincfg, PINCTRL_STATE_DEFAULT); \t\tif (ret< 0&& ret != -ENOENT) { \t\t\treturn ret; \t\t} \t\tbreak; \tcase PM_DEVICE_ACTION_SUSPEND: \t\tret = pinctrl_apply_state(data->pincfg, PINCTRL_STATE_SLEEP); \t\tif (ret< 0&& ret != -ENOENT) { \t\t\treturn ret; \t\t} \t\tbreak; \tdefault: \t\treturn -ENOTSUP; \t}  \treturn 0; } #endif  #if defined(CONFIG_XIP)&& defined(CONFIG_FLASH_MCUX_FLEXSPI_XIP) /* Checks if image flash base address is in the FlexSPI AHB base region */ #define MEMC_FLEXSPI_CFG_XIP(node_id)\t\t\t\t\t\t\\ \t((CONFIG_FLASH_BASE_ADDRESS)>= DT_REG_ADDR_BY_IDX(node_id, 1))&&\t\\ \t((CONFIG_FLASH_BASE_ADDRESS)< (DT_REG_ADDR_BY_IDX(node_id, 1) +\t\\ \t\t\t\t\tDT_REG_SIZE_BY_IDX(node_id, 1)))  #else #define MEMC_FLEXSPI_CFG_XIP(node_id) false #endif  #define MEMC_FLEXSPI(n)\t\t\t\t\t\t\t\\ \tPINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t\\ \tstatic uint16_t  buf_cfg_##n[] =\t\t\t\t\\ \t\tDT_INST_PROP_OR(n, rx_buffer_config, {0});\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic struct memc_flexspi_data\t\t\t\t\t\\ \t\tmemc_flexspi_data_##n = {\t\t\t\t\\ \t\t.base = (FLEXSPI_Type *) DT_INST_REG_ADDR(n),\t\t\\ \t\t.xip = MEMC_FLEXSPI_CFG_XIP(DT_DRV_INST(n)),\t\t\\ \t\t.ahb_base = (uint8_t *) DT_INST_REG_ADDR_BY_IDX(n, 1),\t\\ \t\t.ahb_bufferable = DT_INST_PROP(n, ahb_bufferable),\t\\ \t\t.ahb_cacheable = DT_INST_PROP(n, ahb_cacheable),\t\\ \t\t.ahb_prefetch = DT_INST_PROP(n, ahb_prefetch),\t\t\\ \t\t.ahb_read_addr_opt = DT_INST_PROP(n, ahb_read_addr_opt),\\ \t\t.combination_mode = DT_INST_PROP(n, combination_mode),\t\\ \t\t.sck_differential_clock = DT_INST_PROP(n, sck_differential_clock),\t\\ \t\t.rx_sample_clock = DT_INST_PROP(n, rx_clock_source),\t\\ \t\t.buf_cfg = (struct memc_flexspi_buf_cfg *)buf_cfg_##n,\t\\ \t\t.buf_cfg_cnt = sizeof(buf_cfg_##n) /\t\t\t\\ \t\t\tsizeof(struct memc_flexspi_buf_cfg),\t\t\\ \t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\\ \t\t.clock_dev = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(n)),     \\ \t\t.clock_subsys = (clock_control_subsys_t)                \\ \t\t\tDT_INST_CLOCKS_CELL(n, name),                   \\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(n, memc_flexspi_pm_action);\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n,\t\t\t\t\t\\ \t\t\t      memc_flexspi_init,\t\t\t\\ \t\t\t      PM_DEVICE_DT_INST_GET(n),\t\t\t\\&memc_flexspi_data_##n,\t\t\t\\ \t\t\t      NULL,\t\t\t\t\t\\ \t\t\t      POST_KERNEL,\t\t\t\t\\ \t\t\t      CONFIG_MEMC_INIT_PRIORITY,\t\\ \t\t\t      NULL);  DT_INST_FOREACH_STATUS_OKAY(MEMC_FLEXSPI)\n+unit|); \tfor (uint8_t i = 0; i< data->buf_cfg_cnt; i++) { \t\t/* Should AHB prefetch up to buffer size? */ \t\tflexspi_config.ahbConfig.buffer[i].enablePrefetch = data->buf_cfg[i].prefetch; \t\t/* AHB access priority (used for suspending control of AHB prefetching )*/ \t\tflexspi_config.ahbConfig.buffer[i].priority = data->buf_cfg[i].priority; \t\t/* AHB master index, SOC specific */ \t\tflexspi_config.ahbConfig.buffer[i].masterIndex = data->buf_cfg[i].master_id; \t\t/* RX buffer allocation (total available buffer space is instance/SOC specific) */ \t\tflexspi_config.ahbConfig.buffer[i].bufferSize = data->buf_cfg[i].buf_size; \t}  \tFLEXSPI_Init(data->base,&flexspi_config);  \treturn 0; }  #ifdef CONFIG_PM_DEVICE static int memc_flexspi_pm_action(const struct device *dev, enum pm_device_action action) { \tstruct memc_flexspi_data *data = dev->data; \tint ret;  \tswitch (action) { \tcase PM_DEVICE_ACTION_RESUME: \t\tret = pinctrl_apply_state(data->pincfg, PINCTRL_STATE_DEFAULT); \t\tif (ret< 0&& ret != -ENOENT) { \t\t\treturn ret; \t\t} \t\tbreak; \tcase PM_DEVICE_ACTION_SUSPEND: \t\tret = pinctrl_apply_state(data->pincfg, PINCTRL_STATE_SLEEP); \t\tif (ret< 0&& ret != -ENOENT) { \t\t\treturn ret; \t\t} \t\tbreak; \tdefault: \t\treturn -ENOTSUP; \t}  \treturn 0; } #endif  #if defined(FSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB)&& \\ \tFSL_FEATURE_FLEXSPI_SUPPORT_SEPERATE_RXCLKSRC_PORTB #define MEMC_FLEXSPI_RXCLK_B(inst) .rx_sample_clock_b = DT_INST_PROP(inst, rx_clock_source_b), #else #define MEMC_FLEXSPI_RXCLK_B(inst) #endif  #if defined(CONFIG_XIP)&& defined(CONFIG_FLASH_MCUX_FLEXSPI_XIP) /* Checks if image flash base address is in the FlexSPI AHB base region */ #define MEMC_FLEXSPI_CFG_XIP(node_id)\t\t\t\t\t\t\\ \t((CONFIG_FLASH_BASE_ADDRESS)>= DT_REG_ADDR_BY_IDX(node_id, 1))&&\t\\ \t((CONFIG_FLASH_BASE_ADDRESS)< (DT_REG_ADDR_BY_IDX(node_id, 1) +\t\\ \t\t\t\t\tDT_REG_SIZE_BY_IDX(node_id, 1)))  #else #define MEMC_FLEXSPI_CFG_XIP(node_id) false #endif  #define MEMC_FLEXSPI(n)\t\t\t\t\t\t\t\\ \tPINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t\\ \tstatic uint16_t  buf_cfg_##n[] =\t\t\t\t\\ \t\tDT_INST_PROP_OR(n, rx_buffer_config, {0});\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic struct memc_flexspi_data\t\t\t\t\t\\ \t\tmemc_flexspi_data_##n = {\t\t\t\t\\ \t\t.base = (FLEXSPI_Type *) DT_INST_REG_ADDR(n),\t\t\\ \t\t.xip = MEMC_FLEXSPI_CFG_XIP(DT_DRV_INST(n)),\t\t\\ \t\t.ahb_base = (uint8_t *) DT_INST_REG_ADDR_BY_IDX(n, 1),\t\\ \t\t.ahb_bufferable = DT_INST_PROP(n, ahb_bufferable),\t\\ \t\t.ahb_cacheable = DT_INST_PROP(n, ahb_cacheable),\t\\ \t\t.ahb_prefetch = DT_INST_PROP(n, ahb_prefetch),\t\t\\ \t\t.ahb_read_addr_opt = DT_INST_PROP(n, ahb_read_addr_opt),\\ \t\t.combination_mode = DT_INST_PROP(n, combination_mode),\t\\ \t\t.sck_differential_clock = DT_INST_PROP(n, sck_differential_clock),\t\\ \t\t.rx_sample_clock = DT_INST_PROP(n, rx_clock_source),\t\\ \t\tMEMC_FLEXSPI_RXCLK_B(n)                                 \\ \t\t.buf_cfg = (struct memc_flexspi_buf_cfg *)buf_cfg_##n,\t\\ \t\t.buf_cfg_cnt = sizeof(buf_cfg_##n) /\t\t\t\\ \t\t\tsizeof(struct memc_flexspi_buf_cfg),\t\t\\ \t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\\ \t\t.clock_dev = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(n)),     \\ \t\t.clock_subsys = (clock_control_subsys_t)                \\ \t\t\tDT_INST_CLOCKS_CELL(n, name),                   \\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(n, memc_flexspi_pm_action);\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n,\t\t\t\t\t\\ \t\t\t      memc_flexspi_init,\t\t\t\\ \t\t\t      PM_DEVICE_DT_INST_GET(n),\t\t\t\\&memc_flexspi_data_##n,\t\t\t\\ \t\t\t      NULL,\t\t\t\t\t\\ \t\t\t      POST_KERNEL,\t\t\t\t\\ \t\t\t      CONFIG_MEMC_INIT_PRIORITY,\t\\ \t\t\t      NULL);  DT_INST_FOREACH_STATUS_OKAY(MEMC_FLEXSPI)\n+  rx-clock-source-b:\n+    type: int\n+    default: 0\n+    enum:\n+      - 0 # Loopback internally\n+      - 1 # Loopback from DQS pad\n+      - 2 # Loopback from SCK pad\n+      - 3 # External input from DQS pad\n+    description: |\n+      Source clock for flash read on port B. Only supported by some instances\n+      of this IP. See the RXCLKSRC_B field in register MCR2.\n+      The default corresponds to the reset value of the register field.\n+\nThe issue was with: drivers: memc: memc_mcux_flexspi: support diff RX clock source on port B\n\nSome instances of the FlexSPI IP support a different clock source being\nused for port B of the FlexSPI instance. Add a devicetree property and\ndriver support to enable configuring this property of the hardware."
},{
  "instruction": "There is an issue in the following code. It relates to mgmt: updatehub: Fix mark for update\n\nThis fixes compatibility with recent bootutils API. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|-\nname|EINVAL\nreturn|;\nblock|}\nreturn|return\nname|boot_request_upgrade_multi\nargument_list|(\nname|partition_id\nargument_list|,\nname|BOOT_UPGRADE_TEST\nargument_list|)\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|boot_request_upgrade_multi\n+name|boot_request_upgrade\n-name|partition_id\n-argument_list|,\nThe issue was with: mgmt: updatehub: Fix mark for update\n\nThis fixes compatibility with recent bootutils API."
},{
  "instruction": "There is an issue in the following code. It relates to soc/intel_adsp: ipc: initialize semaphore in driver init\n\nThe ipc driver device data (struct intel_adsp_ipc_data) contains a\nsemaphore. Upon device init, the device data is zeroed out. This is safe\nfor other fields, but the semaphore should be properly initialized\nbefore use.\n\nThis lack of initialization leads to a system crash when CONFIG_POLL is\nenabled (e.g. to enable CONFIG_SHELL), IPC driver handles an interrupt\nand executes k_sem_give() on a uninitialized semaphore object. This will\neventually lead to null dereference in z_handle_obj_poll_events(). Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|*\nname|devdata\nargument_list|)\nargument_list|)\nexpr_stmt|;\ncomment|/* ACK any latched interrupts (including TDA to clear IDA on \t * the other side!), then enable. \t */\nname|config\noperator|->\nname|regs\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|k_sem_init\n+argument_list|(\n+operator|&\n+name|devdata\n+operator|->\n+name|sem\n+argument_list|,\n+literal|0\n+argument_list|,\n+literal|1\n+argument_list|)\n+expr_stmt|;\nThe issue was with: soc/intel_adsp: ipc: initialize semaphore in driver init\n\nThe ipc driver device data (struct intel_adsp_ipc_data) contains a\nsemaphore. Upon device init, the device data is zeroed out. This is safe\nfor other fields, but the semaphore should be properly initialized\nbefore use.\n\nThis lack of initialization leads to a system crash when CONFIG_POLL is\nenabled (e.g. to enable CONFIG_SHELL), IPC driver handles an interrupt\nand executes k_sem_give() on a uninitialized semaphore object. This will\neventually lead to null dereference in z_handle_obj_poll_events()."
},{
  "instruction": "There is an issue in the following code. It relates to net: if: Print warning if there are no network interfaces\n\nWhen calling net_if_get_default(), print a warning if no\nnetwork interfaces are found. This helps debugging mysterious\ncrashes. Please fix this issue.",
  "input": "Faulty tokenized code:\nendif|#\ndirective|endif\nend_endif\n\nbegin_struct\nDECL|struct|__anon2bf5a3110108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|ipv6\nname|struct\nname|CONFIG_NET_NATIVE_IPV4\nargument_list|)\nend_if\n\nbegin_struct\nDECL|struct|__anon2bf5a3110208\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|ipv4\nname|struct\nindex|[\nliteral|0\nindex|]\ncondition|)\nblock|{\nreturn|return\nname|NULL\nreturn|;\nblock|}\nif|if",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2bf5a3110108\n+DECL|struct|__anon2b7923730108\n-DECL|struct|__anon2bf5a3110208\n+DECL|struct|__anon2b7923730208\n+name|NET_WARN\n+argument_list|(\n+literal|\"No default interface found!\"\n+argument_list|)\n+expr_stmt|;\nThe issue was with: net: if: Print warning if there are no network interfaces\n\nWhen calling net_if_get_default(), print a warning if no\nnetwork interfaces are found. This helps debugging mysterious\ncrashes."
},{
  "instruction": "There is an issue in the following code. It relates to net: if: ipv6: Do not crash if there are no network interfaces\n\nWhen trying to get IPv6 prefix, if there are no network interfaces\nthen the net_if_get_default() will return NULL but we should not\ncrash at that point but return gracefully. Please fix this issue.",
  "input": "Faulty tokenized code:\nendif|#\ndirective|endif\nend_endif\n\nbegin_struct\nDECL|struct|__anon28c55fec0108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|ipv6\nname|struct\nname|CONFIG_NET_NATIVE_IPV4\nargument_list|)\nend_if\n\nbegin_struct\nDECL|struct|__anon28c55fec0208\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|ipv4\nname|struct\noperator|=\nname|net_if_get_default\nargument_list|()\nexpr_stmt|;\nblock|}\nname|net_if_lock\nargument_list|(\nname|iface\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon28c55fec0108\n+DECL|struct|__anon2bf5a3110108\n-DECL|struct|__anon28c55fec0208\n+DECL|struct|__anon2bf5a3110208\n+if|if\n+condition|(\n+operator|!\n+name|iface\n+condition|)\n+block|{\n+return|return\n+name|NULL\n+return|;\n+block|}\nThe issue was with: net: if: ipv6: Do not crash if there are no network interfaces\n\nWhen trying to get IPv6 prefix, if there are no network interfaces\nthen the net_if_get_default() will return NULL but we should not\ncrash at that point but return gracefully."
},{
  "instruction": "There is an issue in the following code. It relates to net: ipv6: Tailor PE values for Zephyr\n\nMaking default preferred time much closer to default valid time\nso that the served addresses are much shorter time in deprecated\nstate where they cannot be utilized. This is important in Zephyr\nas there are limited number of IPv6 addresses that can be allocated\nto the network interface. Please fix this issue.",
  "input": "Faulty tokenized code:\n\thelp\n\t  Prefer public addresses over temporary addresses.\n\nconfig NET_IPV6_PE_TEMP_VALID_LIFETIME\n\tint \"Max lifetime for temporary address (in minutes)\"\n\tdefault 1800\n\thelp\n\t  No temporary address should ever remain valid for longer than this\n\t  value. The value is in minutes. Default value is 2 days (2*24*60).\n\nconfig NET_IPV6_PE_TEMP_PREFERRED_LIFETIME\n\tint \"Max preferred lifetime for temporary address (in minutes)\"\n\tdefault 1440\n\thelp\n\t  No temporary address should ever remain preferred for longer than this\n\t  value. The value is in minutes. Default value is 1 day (24*60).\n\nconfig NET_IPV6_PE_TEMP_IDGEN_RETRIES\n\tint \"Max amount of failed DAD attempts\"\n\tdefault 3\n\thelp\nname|TEMP_PREFERRED_LIFETIME\nvalue|temp_preferred_lifetime\nend_define\n\nbegin_comment\ncomment|/* This is the upper bound on DESYNC_FACTOR. The value is in seconds.  * See RFC 8981 ch 3.8 for details.  */\nend_comment\n\nbegin_define\nDECL|macro|MAX_DESYNC_FACTOR\ndefine|#\ndirective|define\nname|MAX_DESYNC_FACTOR\nvalue|((TEMP_PREFERRED_LIFETIME * 2U) / 5U)\nend_define\n\nbegin_define\nDECL|macro|DESYNC_FACTOR (ipv6)\ndefine|#\nindex|[\nliteral|16\nindex|]\ndecl_stmt|;\ncomment|/* Min 128 bits, RFC 8981 ch 3.3.2 */\nDECL|struct|__anon2ad1b8020108\nstruct|struct\nblock|{\nDECL|member|prefix\nname|struct\nname|in6_addr",
  "result": "I corrected the issue in the code by changing the following tokens:\n-\tdefault 1800\n+\tdefault 1440\n-\t  value. The value is in minutes. Default value is 2 days (2*24*60).\n+\t  value. The value is in minutes. Default value is 1 day (24*60).\n-\tdefault 1440\n+\tdefault 1380\n-\t  value. The value is in minutes. Default value is 1 day (24*60).\n+\t  value. The value is in minutes. Default value is 23 hours (23*60).\n-comment|/* This is the upper bound on DESYNC_FACTOR. The value is in seconds.  * See RFC 8981 ch 3.8 for details.  */\n+comment|/* This is the upper bound on DESYNC_FACTOR. The value is in seconds.  * See RFC 8981 ch 3.8 for details.  *  * RFC says the DESYNC_FACTOR should be 0.4 times the preferred lifetime.  * This is too short for Zephyr as it means that the address is very long  * time in deprecated state and not being used. Make this 7% of the preferred  * time to deprecate the addresses later.  */\n-value|((TEMP_PREFERRED_LIFETIME * 2U) / 5U)\n+value|((uint32_t)((uint64_t)TEMP_PREFERRED_LIFETIME * \\ \t\t\t\t       (uint64_t)7U) / (uint64_t)100U)\n-DECL|struct|__anon2ad1b8020108\n+DECL|struct|__anon2b0ca4470108\nThe issue was with: net: ipv6: Tailor PE values for Zephyr\n\nMaking default preferred time much closer to default valid time\nso that the served addresses are much shorter time in deprecated\nstate where they cannot be utilized. This is important in Zephyr\nas there are limited number of IPv6 addresses that can be allocated\nto the network interface."
},{
  "instruction": "There is an issue in the following code. It relates to libc: minimal: Add 'noreturn' attribute to abort() and exit()\n\nThis aligns abort() and exit() definitions with other libc.\n\nWithout 'noreturn' attribute, compilers have to assume that we will\nreturn from these functions which can lead to surprising errors like\n'error: non-void function does not return a value'. Please fix this issue.",
  "input": "Faulty tokenized code:\nfile|<zephyr/kernel.h>\nend_include\n\nbegin_function\nDECL|function|abort (void)\nname|void\nname|abort\nparameter_list|(\nname|void\nparameter_list|)\ninclude|#\ndirective|include\nfile|<limits.h>\nend_include\n\nbegin_ifdef\nifdef|#\ndirective|ifdef\nname|__cplusplus\nend_ifdef\nDECL|macro|EXIT_FAILURE\ndefine|#\ndirective|define\nname|EXIT_FAILURE\nvalue|1\nname|void\nname|_exit\nparameter_list|(\nname|int\nname|status\nparameter_list|)\nfunction_decl|;\nDECL|function|exit (int status)\nspecifier|static\nspecifier|inline\nname|void\nname|exit\nparameter_list|(\nargument_list|(\nname|status\nargument_list|)\nexpr_stmt|;\nblock|}\nname|void\nname|abort\nparameter_list|(\nname|void\nparameter_list|)\nfile|<zephyr/kernel.h>\nend_include\n\nbegin_function\nDECL|function|_exit (int status)\nname|void\nname|_exit\nparameter_list|(\nname|int\nname|status",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|FUNC_NORETURN\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/toolchain.h>\n+end_include\n+\n+name|FUNC_NORETURN\n+name|FUNC_NORETURN\n+name|FUNC_NORETURN\n+name|FUNC_NORETURN\nThe issue was with: libc: minimal: Add 'noreturn' attribute to abort() and exit()\n\nThis aligns abort() and exit() definitions with other libc.\n\nWithout 'noreturn' attribute, compilers have to assume that we will\nreturn from these functions which can lead to surprising errors like\n'error: non-void function does not return a value'."
},{
  "instruction": "There is an issue in the following code. It relates to pm: re-program timer HW only when the exit latency is not zero\n\nAvoid re-programming timer unnecessarily. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nendif|#\ndirective|endif\nif|if\ncondition|(\nname|ticks\noperator|!=\nname|K_TICKS_FOREVER\ncondition|)\nblock|{\ncomment|/* \t\t * We need to set the timer to interrupt a little bit early to \t\t * accommodate the time required by the CPU to fully wake up. \t\t */\nname|sys_clock_set_timeout\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+name|z_cpus_pm_state\n+index|[\n+name|id\n+index|]\n+operator|.\n+name|exit_latency_us\n+operator|!=\n+literal|0\n+operator|)\n+operator|&&\n+operator|(\n+operator|)\nThe issue was with: pm: re-program timer HW only when the exit latency is not zero\n\nAvoid re-programming timer unnecessarily."
},{
  "instruction": "There is an issue in the following code. It relates to coding guidelines: comply with MISRA Rule 20.9\n\n- avoid to use undefined macros in #if expressions Please fix this issue.",
  "input": "Faulty tokenized code:\nDECL|member|rx_timeout_timer\nname|struct\nname|k_timer\nname|rx_timeout_timer\ndecl_stmt|;\nDECL|union|__anon2a0aae6f010a\nunion|union\nblock|{\nDECL|member|ppi\nname|gppi_channel_t\nname|ppi\nname|get_uarte_instance\nargument_list|(\nname|dev\nargument_list|)\ndecl_stmt|;\nif|#\ndirective|if\nname|CONFIG_PM_DEVICE\nname|enum\nname|pm_device_state\nname|state\ndecl_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon2a0aae6f010a\n+DECL|union|__anon2bf403db010a\n-if|#\n-directive|if\n+ifdef|#\n+directive|ifdef\nThe issue was with: coding guidelines: comply with MISRA Rule 20.9\n\n- avoid to use undefined macros in #if expressions"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: hwinfo: shell: fix error message when no hardware support\n\nWhen there is no implementation for a particular hardware information\ndevice, the API return -ENOSYS, while the hardware information shell\nchecks for -ENOTSUP. This returns a non-user friendly message:\n\n  uart:~$ hwinfo devid\n  Error: -88\n\nThe API can't be changed easily without breaking things, so let's change\nthe shell instead. This gives:\n\n  uart:~$ hwinfo devid\n  Not supported by hardware Please fix this issue.",
  "input": "Faulty tokenized code:\nif|if\ncondition|(\nname|length\noperator|==\noperator|-\nname|ENOTSUP\ncondition|)\nblock|{\nname|shell_error\nargument_list|(\nname|sh\nliteral|\"Not supported by hardware\"\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|ENOTSUP\nreturn|;\nblock|}\nif|else if\ncondition|(\nname|length\nif|if\ncondition|(\nname|res\noperator|==\noperator|-\nname|ENOTSUP\ncondition|)\nblock|{\nname|shell_error\nargument_list|(\nname|sh\nif|if\ncondition|(\nname|res\noperator|==\noperator|-\nname|ENOTSUP\ncondition|)\nblock|{\nname|shell_error\nargument_list|(\nname|sh\nif|if\ncondition|(\nname|res\noperator|==\noperator|-\nname|ENOTSUP\ncondition|)\nblock|{\nname|shell_error\nargument_list|(\nname|sh",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|ENOTSUP\n+name|ENOSYS\n-name|ENOTSUP\n+name|ENOSYS\n-name|ENOTSUP\n+name|ENOSYS\n-name|ENOTSUP\n+name|ENOSYS\n-name|ENOTSUP\n+name|ENOSYS\nThe issue was with: drivers: hwinfo: shell: fix error message when no hardware support\n\nWhen there is no implementation for a particular hardware information\ndevice, the API return -ENOSYS, while the hardware information shell\nchecks for -ENOTSUP. This returns a non-user friendly message:\n\n  uart:~$ hwinfo devid\n  Error: -88\n\nThe API can't be changed easily without breaking things, so let's change\nthe shell instead. This gives:\n\n  uart:~$ hwinfo devid\n  Not supported by hardware"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: Fix BIS target_event truncated to 8 bits\n\nThe target_event value is up to 39-bits but was put into a uint8_t Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nelse|#\ndirective|else\ncomment|/* !CONFIG_BT_CTLR_ISOAL_PSN_IGNORE */\nname|uint8_t\nname|target_event\ndecl_stmt|;\nname|uint8_t\nname|event_offset\ndecl_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|uint8_t\n+name|uint64_t\nThe issue was with: Bluetooth: Controller: Fix BIS target_event truncated to 8 bits\n\nThe target_event value is up to 39-bits but was put into a uint8_t"
},{
  "instruction": "There is an issue in the following code. It relates to coding guidelines: comply with MISRA Rule 20.9\n\n- avoid to use undefined macros in #if expressions Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|exp\noperator|->\nname|timestamp\nargument_list|,\nif|#\ndirective|if\nname|CONFIG_LOG_TIMESTAMP_64BIT\nliteral|\"Got: %llu, expected: %llu\"\nargument_list|,\nelse|#\ndirective|else",
  "result": "I corrected the issue in the code by changing the following tokens:\n-if|#\n-directive|if\n+ifdef|#\n+directive|ifdef\nThe issue was with: coding guidelines: comply with MISRA Rule 20.9\n\n- avoid to use undefined macros in #if expressions"
},{
  "instruction": "There is an issue in the following code. It relates to hostap: Fix the function name to be more descriptive\n\nThe wpas_to_wifi_mgmt_diconn_status() was missing \\\"s\\\" char,\nso name it to wpas_to_wifi_mgmt_disconn_status() as that is\nmore descriptive. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nblock|}\nend_function\n\nbegin_function\nDECL|function|wpas_to_wifi_mgmt_diconn_status (int status)\nspecifier|static\nname|enum\nname|wifi_disconn_reason\nname|wpas_to_wifi_mgmt_diconn_status\nparameter_list|(\nname|int\nname|status\nparameter_list|)\nblock|{\nname|ctx\ndecl_stmt|;\nname|int\nname|status\ninit|=\nname|wpas_to_wifi_mgmt_diconn_status\nargument_list|(\nname|reason_code\nargument_list|)\ndecl_stmt|;\nname|enum",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|wpas_to_wifi_mgmt_diconn_status (int status)\n+DECL|function|wpas_to_wifi_mgmt_disconn_status (int status)\n-name|wpas_to_wifi_mgmt_diconn_status\n+name|wpas_to_wifi_mgmt_disconn_status\n-name|wpas_to_wifi_mgmt_diconn_status\n+name|wpas_to_wifi_mgmt_disconn_status\nThe issue was with: hostap: Fix the function name to be more descriptive\n\nThe wpas_to_wifi_mgmt_diconn_status() was missing \\\"s\\\" char,\nso name it to wpas_to_wifi_mgmt_disconn_status() as that is\nmore descriptive."
},{
  "instruction": "There is an issue in the following code. It relates to hostap: Handle CTRL-EVENT-SCAN-RESULTS event\n\nHandle scan results event in order to avoid warning print\nfor unhandled event. The event is not used for anything atm,\nthis just prevents unknown event printout. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|,\nname|SUPPLICANT_EVENT_SCAN_STARTED\nblock|}\nblock|,\nblock|{\nliteral|\"CTRL-EVENT-SCAN-FAILED\"\nblock|,\nname|SUPPLICANT_EVENT_SCAN_FAILED\nblock|}\nblock|,\ncase|:\ncase|case\nname|SUPPLICANT_EVENT_SCAN_STARTED\ncase|:\ncase|case\nname|SUPPLICANT_EVENT_SCAN_FAILED\ncase|:\ncase|case\nname|SUPPLICANT_EVENT_NETWORK_NOT_FOUND\ncase|:",
  "result": "I corrected the issue in the code by changing the following tokens:\n+literal|\"CTRL-EVENT-SCAN-RESULTS\"\n+block|,\n+name|SUPPLICANT_EVENT_SCAN_RESULTS\n+block|}\n+block|,\n+block|{\n+name|SUPPLICANT_EVENT_SCAN_RESULTS\n+case|:\n+case|case\nThe issue was with: hostap: Handle CTRL-EVENT-SCAN-RESULTS event\n\nHandle scan results event in order to avoid warning print\nfor unhandled event. The event is not used for anything atm,\nthis just prevents unknown event printout."
},{
  "instruction": "There is an issue in the following code. It relates to hostap: Fix handling channel 14\n\nChannel 14 in JP is still allowed (though OFDM is disabled), this wasn't\nhandled by operating class 81, so, add 82 to the list.\n\nWe still need to full implement regulatory support in the WPA\nsupplicant but that is handled in separate fix. Please fix this issue.",
  "input": "Faulty tokenized code:\nindex|[]\ninit|=\nblock|{\nliteral|81\nblock|,\nliteral|128\nblock|}\ndecl_stmt|;\nname|int\nname|op_classes_size",
  "result": "I corrected the issue in the code by changing the following tokens:\n+literal|82\n+block|,\nThe issue was with: hostap: Fix handling channel 14\n\nChannel 14 in JP is still allowed (though OFDM is disabled), this wasn't\nhandled by operating class 81, so, add 82 to the list.\n\nWe still need to full implement regulatory support in the WPA\nsupplicant but that is handled in separate fix."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: allow lis2dh anymotion triggers if no anymotion latching is active\n\nSince the interrupt state of the IA bit (interrupt source register) is\nchecked, it needs to be read out everytime, not only on latching.\n\nFixes #71245 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|uint8_t\nname|reg_val\ninit|=\nliteral|0\ndecl_stmt|;\nif|if\ncondition|(\nname|cfg\noperator|->\nname|hw\noperator|.\nname|anym_latch\ncondition|)\nblock|{\ncomment|/* clear interrupt to de-assert int line */\nname|status\noperator|=\nname|lis2dh\noperator|->\nname|hw_tf\nname|status\nargument_list|)\nexpr_stmt|;\nreturn|return;\nblock|}\nblock|}\nif|if\ncondition|(\nname|likely\nargument_list|(\nname|lis2dh",
  "result": "I corrected the issue in the code by changing the following tokens:\n-if|if\n-condition|(\n-name|cfg\n-operator|->\n-name|hw\n-operator|.\n-name|anym_latch\n-condition|)\n-block|{\n-comment|/* clear interrupt to de-assert int line */\n+comment|/* if necessary also clears an interrupt to de-assert int line */\n-block|}\nThe issue was with: drivers: allow lis2dh anymotion triggers if no anymotion latching is active\n\nSince the interrupt state of the IA bit (interrupt source register) is\nchecked, it needs to be read out everytime, not only on latching.\n\nFixes #71245"
},{
  "instruction": "There is an issue in the following code. It relates to usb: device: Do not claim to be USB 3.2 device\n\nThe bcdUSB value 0x0210 defined in USB 3.2 Specification indicates USB\n3.2 device operating in one of the USB 2.0 modes. USB 2.0 Link Power\nManagement Addendum defines bcdUSB value 0x0201 to indicate that USB 2.0\ndevice supports the request to read the BOS Descriptor.\n\nThe main difference between bcdUSB 0x0210 and 0x0201 is that the USB 3.2\ndevice must support LPM, while USB 2.0 devices can (but are not required\nto) support LPM.\n\nThe difference is respected by USB 3 Gen X Command Verifier (2.3.0.0)\nChapter 9 Tests [USB 2 devices], where the test behaves as follows:\n  * For bcdUSB 0x0200:\n      Checking Device Under Test for LPM L1 Compatibility...\n      USB version of device is 2.00.\n      DUT is NOT compatible with LPM.\n      LPM is NOT required for DUT\n      LPM is only supported in USB version 2.01 and above.\n\n  * For bcdUSB 0x0201:\n      Checking Device Under Test for LPM L1 Compatibility...\n      USB version of device is 2.01.\n      DUT IS compatible with LPM.\n      LPM is NOT required for DUT\n      USB 2.0 Extension Descriptor bmAttributes:\n        LPM Capable = 0\n        BESL and Alternate HIRD Supported = 0\n        Baseline BESL Valid = 0\n        Deep BESL Valid = 0\n        Baseline BESL: 0d\n        Deep BESL:  0d\n      LPM is not supported\n\n  * For bcdUSB 0x0210:\n      Checking Device Under Test for LPM L1 Compatibility...\n      USB version of device is 2.10.\n      DUT IS compatible with LPM.\n      LPM IS required for DUT\n      USB 2.0 Extension Descriptor bmAttributes:\n        LPM Capable = 0\n        BESL and Alternate HIRD Supported = 0\n        Baseline BESL Valid = 0\n        Deep BESL Valid = 0\n        Baseline BESL: 0d\n        Deep BESL:  0d\n      (USB: 9.6.2.1.6) Bit 1 in Attributes field of a USB 2.0 Extension\n      descriptor returned in response to a GetDescriptor(BOS) request\n      must be 1 for LS/FS/HS devices that support LPM L1.\n\nThe test fails when LPM bit is not set in USB 2.0 Extension Descriptor\nonly when bcdUSB is 0x0210. The test failure was incorrectly fixed in\ncommit 9e44dbfc5eb1 [formerly 312429be3c0c] (\\\"usb: samples: Add Extension descriptor to webUSB\nsample.\\\"). Properly fix the issue by changing bcdUSB to 0x0201 and\nremoving the false LPM support claim.\n\nThe false LPM claim was leading to device ceasing to work after some\ntime if there was no traffic from host to device (when the host is\nlikely to have executed the LPM L1 transition that was not properly\nhandled by the device). Please fix this issue.",
  "input": "Faulty tokenized code:\ncomment|/** USB Setup Data packet defined in spec. Table 9-2 */\nDECL|struct|usb_setup_packet\nstruct|struct\nname|usb_setup_packet\nblock|{\nDECL|union|__anon2778489e010a\nunion|union\nblock|{\nDECL|member|bmRequestType\nname|uint8_t\nname|bmRequestType\ndecl_stmt|;\nDECL|member|bEndpointAddress\nname|uint8_t\nname|bEndpointAddress\ndecl_stmt|;\nDECL|union|__anon2778489e020a\nunion|union\nblock|{\nDECL|member|bmAttributes\nname|uint8_t\nname|bmAttributes\nDECL|macro|USB_SRN_2_0\ndefine|#\ndirective|define\nname|USB_SRN_2_0\nvalue|0x0200\nDECL|macro|USB_SRN_2_1\ndefine|#\ndirective|define\nname|USB_SRN_2_1\nvalue|0x0210\noperator|.\nname|bDevCapabilityType\noperator|=\nname|USB_BOS_CAPABILITY_EXTENSION\nblock|,\ncomment|/** \t * BIT(1) - LPM support \t * BIT(2) - BESL support \t */\noperator|.\nname|bmAttributes\noperator|=\nname|BIT\nargument_list|(\nliteral|1\nargument_list|)\noperator||\nname|BIT\nargument_list|(\nliteral|2\nargument_list|)\nblock|, }\ndecl_stmt|;\nend_decl_stmt\n\nbegin_comment\noperator|.\nname|bcdUSB\noperator|=\nname|sys_cpu_to_le16\nargument_list|(\nname|USB_SRN_2_1\nargument_list|)\nblock|,\nelse|#\ndirective|else\noperator|.",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon2778489e010a\n+DECL|union|__anon2b7c3f2f010a\n-DECL|union|__anon2778489e020a\n+DECL|union|__anon2b7c3f2f020a\n+DECL|macro|USB_SRN_2_0_1\n+define|#\n+directive|define\n+name|USB_SRN_2_0_1\n+value|0x0201\n-comment|/** \t * BIT(1) - LPM support \t * BIT(2) - BESL support \t */\n+comment|/** \t * Currently there is not a single device driver in Zephyr that supports \t * LPM. Moreover, Zephyr USB stack does not have LPM support, so do not \t * falsely claim to support LPM. \t * BIT(1) - LPM support \t * BIT(2) - BESL support \t */\n-name|BIT\n-argument_list|(\n-literal|1\n-argument_list|)\n-operator||\n-name|BIT\n-argument_list|(\n-literal|2\n-argument_list|)\n+literal|0\n-name|USB_SRN_2_1\n+name|USB_SRN_2_0_1\nThe issue was with: usb: device: Do not claim to be USB 3.2 device\n\nThe bcdUSB value 0x0210 defined in USB 3.2 Specification indicates USB\n3.2 device operating in one of the USB 2.0 modes. USB 2.0 Link Power\nManagement Addendum defines bcdUSB value 0x0201 to indicate that USB 2.0\ndevice supports the request to read the BOS Descriptor.\n\nThe main difference between bcdUSB 0x0210 and 0x0201 is that the USB 3.2\ndevice must support LPM, while USB 2.0 devices can (but are not required\nto) support LPM.\n\nThe difference is respected by USB 3 Gen X Command Verifier (2.3.0.0)\nChapter 9 Tests [USB 2 devices], where the test behaves as follows:\n  * For bcdUSB 0x0200:\n      Checking Device Under Test for LPM L1 Compatibility...\n      USB version of device is 2.00.\n      DUT is NOT compatible with LPM.\n      LPM is NOT required for DUT\n      LPM is only supported in USB version 2.01 and above.\n\n  * For bcdUSB 0x0201:\n      Checking Device Under Test for LPM L1 Compatibility...\n      USB version of device is 2.01.\n      DUT IS compatible with LPM.\n      LPM is NOT required for DUT\n      USB 2.0 Extension Descriptor bmAttributes:\n        LPM Capable = 0\n        BESL and Alternate HIRD Supported = 0\n        Baseline BESL Valid = 0\n        Deep BESL Valid = 0\n        Baseline BESL: 0d\n        Deep BESL:  0d\n      LPM is not supported\n\n  * For bcdUSB 0x0210:\n      Checking Device Under Test for LPM L1 Compatibility...\n      USB version of device is 2.10.\n      DUT IS compatible with LPM.\n      LPM IS required for DUT\n      USB 2.0 Extension Descriptor bmAttributes:\n        LPM Capable = 0\n        BESL and Alternate HIRD Supported = 0\n        Baseline BESL Valid = 0\n        Deep BESL Valid = 0\n        Baseline BESL: 0d\n        Deep BESL:  0d\n      (USB: 9.6.2.1.6) Bit 1 in Attributes field of a USB 2.0 Extension\n      descriptor returned in response to a GetDescriptor(BOS) request\n      must be 1 for LS/FS/HS devices that support LPM L1.\n\nThe test fails when LPM bit is not set in USB 2.0 Extension Descriptor\nonly when bcdUSB is 0x0210. The test failure was incorrectly fixed in\ncommit 9e44dbfc5eb1 [formerly 312429be3c0c] (\\\"usb: samples: Add Extension descriptor to webUSB\nsample.\\\"). Properly fix the issue by changing bcdUSB to 0x0201 and\nremoving the false LPM support claim.\n\nThe false LPM claim was leading to device ceasing to work after some\ntime if there was no traffic from host to device (when the host is\nlikely to have executed the LPM L1 transition that was not properly\nhandled by the device)."
},{
  "instruction": "There is an issue in the following code. It relates to net: l2: ppp: Fix terminate requests\n\nWhen PPP moves to the 'Closing' state it sends up to configured number\nof 'Terminate-Request' packets. It only moves to the 'Initial' state,\nafter running out of retransmits or when it receives a 'Terminate-Ack'\npacket. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|wait_ppp_link_terminated\nargument_list|,\nname|K_MSEC\nargument_list|(\nname|CONFIG_NET_L2_PPP_TIMEOUT\nargument_list|)\nargument_list|)\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|*\n+operator|(\n+literal|1\n+operator|+\n+name|CONFIG_NET_L2_PPP_MAX_TERMINATE_REQ_RETRANSMITS\n+operator|)\nThe issue was with: net: l2: ppp: Fix terminate requests\n\nWhen PPP moves to the 'Closing' state it sends up to configured number\nof 'Terminate-Request' packets. It only moves to the 'Initial' state,\nafter running out of retransmits or when it receives a 'Terminate-Ack'\npacket."
},{
  "instruction": "There is an issue in the following code. It relates to Revert \\\"tests: kernel: update test case with sys_clock_hw_cycles_per_sec\\\"\n\nThis reverts commit e8b918d912cbb82f898f180f8605af737ec083fa [formerly fd8ca83e9a1c0aafa3f62bc185c9f4140d9164c5].\n\nhttps://github.com/zephyrproject-rtos/zephyr/pull/69705\nIntroduced a regression in main in which\ntests/subsys/logging/log_timestamp\nstarted failing. (See\nhttps://github.com/zephyrproject-rtos/zephyr/issues/72344\nfor more info).\nLet's revert the PR. It can be submitted after with the issue\nfixed. Please fix this issue.",
  "input": "Faulty tokenized code:\n\nbegin_block\nblock|{\nif|if\ncondition|(\nname|sys_clock_hw_cycles_per_sec\nargument_list|()\noperator|>\nliteral|1000000000\ncondition|)\nblock|{\ncomment|/* Systems with very fast counters (like the x86 TSC) \t\t * and long firmware startup (often 10+ seconds on a \t\t * EFI PC!)  can easily roll this over during startup, \t\t * and there's no way to detect that case with a 32 \t\t * bit OS API.  Just skip it if we have a GHz-scale \t\t * counter. \t\t */\nargument_list|()\ndecl_stmt|;\nname|uint32_t\nname|watchdog\ninit|=\nname|sys_clock_hw_cycles_per_sec\nargument_list|()\ndecl_stmt|;\nwhile|while\ncondition|(\nname|k_uptime_get\nargument_list|()",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|sys_clock_hw_cycles_per_sec\n-argument_list|()\n+name|CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC\n-name|sys_clock_hw_cycles_per_sec\n-argument_list|()\n+name|CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC\nThe issue was with: Revert \\\"tests: kernel: update test case with sys_clock_hw_cycles_per_sec\\\"\n\nThis reverts commit e8b918d912cbb82f898f180f8605af737ec083fa [formerly fd8ca83e9a1c0aafa3f62bc185c9f4140d9164c5].\n\nhttps://github.com/zephyrproject-rtos/zephyr/pull/69705\nIntroduced a regression in main in which\ntests/subsys/logging/log_timestamp\nstarted failing. (See\nhttps://github.com/zephyrproject-rtos/zephyr/issues/72344\nfor more info).\nLet's revert the PR. It can be submitted after with the issue\nfixed."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: ATT: add debug log for timeout override\n\nNice to know the stack's ain't having none of your timeouts. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_enum\nDECL|enum|__anon29f4bfdb0103\nenum|enum\nblock|{\nDECL|enumerator|ATT_CONNECTED\nname|ATT_CONNECTED\nblock|,\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_BT_EATT\nargument_list|)\nDECL|struct|__anon29f4bfdb0208\nstruct|struct\nblock|{\nDECL|member|connection_work\nname|struct\nname|k_work_delayable\nname|struct\nname|bt_att_find_info_rsp\nmodifier|*\nname|rsp\ndecl_stmt|;\nDECL|union|__anon29f4bfdb030a\nunion|union\nblock|{\nDECL|member|info16\nname|struct\nname|bt_att_info_16\ndecl_stmt|,\nname|end_handle\ndecl_stmt|,\nname|err_handle\ndecl_stmt|;\nDECL|union|__anon29f4bfdb040a\nunion|union\nblock|{\nDECL|member|uuid\nname|struct\nname|bt_uuid\ndecl_stmt|,\nname|end_handle\ndecl_stmt|,\nname|err_handle\ndecl_stmt|;\nDECL|union|__anon29f4bfdb050a\nunion|union\nblock|{\nDECL|member|uuid\nname|struct\nname|bt_uuid\noperator|==\nname|att_handle_rsp_thread\ncondition|)\nblock|{\ncomment|/* No req will be fulfilled while blocking on the bt_recv thread. \t\t * Blocking would cause deadlock. \t\t */\nname|timeout\noperator|=\nname|K_NO_WAIT\nexpr_stmt|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon29f4bfdb0103\n+DECL|enum|__anon2be1d1c40103\n-DECL|struct|__anon29f4bfdb0208\n+DECL|struct|__anon2be1d1c40208\n-DECL|union|__anon29f4bfdb030a\n+DECL|union|__anon2be1d1c4030a\n-DECL|union|__anon29f4bfdb040a\n+DECL|union|__anon2be1d1c4040a\n-DECL|union|__anon29f4bfdb050a\n+DECL|union|__anon2be1d1c4050a\n+name|LOG_DBG\n+argument_list|(\n+literal|\"Timeout discarded. No blocking on bt_recv thread.\"\n+argument_list|)\n+expr_stmt|;\nThe issue was with: Bluetooth: ATT: add debug log for timeout override\n\nNice to know the stack's ain't having none of your timeouts."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: conn: check `k_work_submit()` retcode\n\nWe still don't know how to handle it but at least it's checked now. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nname|struct\nname|k_work_sync\nname|sync\ndecl_stmt|;\ncomment|/* API docs mention undefined behavior if syncing on work item \t\t * from wq execution context. \t\t */\nname|__ASSERT_NO_MSG\nargument_list|(\nname|k_current_get\nargument_list|()\noperator|&\nname|k_sys_work_q\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|k_work_submit\nargument_list|(\noperator|&\nname|conn\noperator|->\nname|tx_complete_work\nargument_list|)\nexpr_stmt|;\nname|k_work_flush\nargument_list|(\noperator|&\nname|conn\noperator|->\noperator|&\nname|sync\nargument_list|)\nexpr_stmt|;\nblock|}\nelse|#\ndirective|else\nname|ARG_UNUSED\nargument_list|(\nname|conn\nreturn|;\nblock|}\nend_function\n\nbegin_enum\nDECL|enum|__anon288c1b330103\nenum|enum\nblock|{\nDECL|enumerator|FRAG_START\nname|FRAG_START\nblock|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|int\n+name|err\n+decl_stmt|;\n+name|err\n+operator|=\n+name|__ASSERT\n+argument_list|(\n+name|err\n+operator|>=\n+literal|0\n+argument_list|,\n+literal|\"couldn't submit (err %d)\"\n+argument_list|,\n+name|err\n+argument_list|)\n+expr_stmt|;\n+name|LOG_DBG\n+argument_list|(\n+literal|\"done\"\n+argument_list|)\n+expr_stmt|;\n-DECL|enum|__anon288c1b330103\n+DECL|enum|__anon297ef7830103\nThe issue was with: Bluetooth: conn: check `k_work_submit()` retcode\n\nWe still don't know how to handle it but at least it's checked now."
},{
  "instruction": "There is an issue in the following code. It relates to tests: kernel: update test case with sys_clock_hw_cycles_per_sec\n\nupdate test case with sys_clock_hw_cycles_per_sec() api to retrieve\nsystem clock frequency (HW cycle per sec) at runtime or statically Please fix this issue.",
  "input": "Faulty tokenized code:\n\nbegin_block\nblock|{\nif|if\ncondition|(\nname|CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC\noperator|>\nliteral|1000000000\ncondition|)\nblock|{\ncomment|/* Systems with very fast counters (like the x86 TSC) \t\t * and long firmware startup (often 10+ seconds on a \t\t * EFI PC!)  can easily roll this over during startup, \t\t * and there's no way to detect that case with a 32 \t\t * bit OS API.  Just skip it if we have a GHz-scale \t\t * counter. \t\t */\nargument_list|()\ndecl_stmt|;\nname|uint32_t\nname|watchdog\ninit|=\nname|CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC\ndecl_stmt|;\nwhile|while\ncondition|(\nname|k_uptime_get\nargument_list|()",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC\n+name|sys_clock_hw_cycles_per_sec\n+argument_list|()\n-name|CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC\n+name|sys_clock_hw_cycles_per_sec\n+argument_list|()\nThe issue was with: tests: kernel: update test case with sys_clock_hw_cycles_per_sec\n\nupdate test case with sys_clock_hw_cycles_per_sec() api to retrieve\nsystem clock frequency (HW cycle per sec) at runtime or statically"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: OTS: Fix calling obj_created callback with NULL conn\n\nCallback was always called with NULL conn. Now it is called with proper\npointer or NULL conforming to description. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|obj_created\nargument_list|(\nname|ots\nargument_list|,\nname|NULL\nargument_list|,\nname|new_obj\noperator|->\nname|id\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|NULL\n+name|conn\nThe issue was with: Bluetooth: OTS: Fix calling obj_created callback with NULL conn\n\nCallback was always called with NULL conn. Now it is called with proper\npointer or NULL conforming to description."
},{
  "instruction": "There is an issue in the following code. It relates to coding guidelines: comply with MISRA C:2012 Rule 17.7 in arch\n\n- added explicit cast to void when returned value is expectedly ignored Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ret\ninit|=\nliteral|0\ndecl_stmt|;\ncomment|/* addr/size arbitrary, fix this up into an aligned region */\nname|k_mem_region_align\nargument_list|(\noperator|(\nname|uintptr_t\noperator|*",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+name|void\n+operator|)\nThe issue was with: coding guidelines: comply with MISRA C:2012 Rule 17.7 in arch\n\n- added explicit cast to void when returned value is expectedly ignored"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: bbram: Rename emul_bbram_backend_api to emul_bbram_driver_api\n\nStructs with a __subsystem tag are required to have a _driver_api suffix. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_decl_stmt\nDECL|variable|it8xxx2_emul_backend_api\nspecifier|static\nspecifier|const\nname|struct\nname|emul_bbram_backend_api\nname|it8xxx2_emul_backend_api\ninit|=\nblock|{\noperator|.\nname|set_data\nbegin_decl_stmt\nDECL|variable|mcp7940n_emul_backend_api\nspecifier|static\nspecifier|const\nname|struct\nname|emul_bbram_backend_api\nname|mcp7940n_emul_backend_api\ninit|=\nblock|{\noperator|.\nname|set_data\nbegin_decl_stmt\nDECL|variable|npcx_emul_backend_api\nspecifier|static\nspecifier|const\nname|struct\nname|emul_bbram_backend_api\nname|npcx_emul_backend_api\ninit|=\nblock|{\noperator|.\nname|set_data\nbegin_comment\ncomment|/**  * @cond INTERNAL_HIDDEN  *  * These are for internal use only, so skip these in public documentation.  */\nend_comment\n\nbegin_macro\nDECL|struct|emul_bbram_backend_api\nname|__subsystem\nend_macro\n\nbegin_struct\nDECL|struct|emul_bbram_backend_api\nstruct|struct\nname|emul_bbram_backend_api\nblock|{\ncomment|/** Sets the data */\nDECL|member|set_data\nname|int\nfunction_decl|(\noperator|-\nname|ENOTSUP\nreturn|;\nblock|}\nname|struct\nname|emul_bbram_backend_api\nmodifier|*\nname|api\ninit|=\noperator|(\nexpr|struct\nname|emul_bbram_backend_api\noperator|*\noperator|)\nname|target\noperator|->\nname|backend_api\noperator|-\nname|ENOTSUP\nreturn|;\nblock|}\nname|struct\nname|emul_bbram_backend_api\nmodifier|*\nname|api\ninit|=\noperator|(\nexpr|struct\nname|emul_bbram_backend_api\noperator|*\noperator|)\nname|target\noperator|->\nname|backend_api",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|emul_bbram_backend_api\n+name|emul_bbram_driver_api\n-name|emul_bbram_backend_api\n+name|emul_bbram_driver_api\n-name|emul_bbram_backend_api\n+name|emul_bbram_driver_api\n-DECL|struct|emul_bbram_backend_api\n+DECL|struct|emul_bbram_driver_api\n-DECL|struct|emul_bbram_backend_api\n+DECL|struct|emul_bbram_driver_api\n-name|emul_bbram_backend_api\n+name|emul_bbram_driver_api\n-name|emul_bbram_backend_api\n+name|emul_bbram_driver_api\n-name|emul_bbram_backend_api\n+name|emul_bbram_driver_api\n-name|emul_bbram_backend_api\n+name|emul_bbram_driver_api\n-name|emul_bbram_backend_api\n+name|emul_bbram_driver_api\nThe issue was with: drivers: bbram: Rename emul_bbram_backend_api to emul_bbram_driver_api\n\nStructs with a __subsystem tag are required to have a _driver_api suffix."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: i2c: i2c_ll_stm32_v1\n\nIn rare cases, the I2C driver runs the N==2 logic\nfor I2C receives when N>2. This change breaks early\nwhen handling the last 2 bytes for transactions with N>2 Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nbreak|break;\ncase|case\nliteral|2\ncase|:\nname|LL_I2C_AcknowledgeNextData\nargument_list|(\nname|i2c\nargument_list|,\nname|LL_I2C_NACK",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* \t\t\t * 2-byte reception for N> 3 has already set the NACK \t\t\t * bit, and must not set the POS bit. See pg. 854 in \t\t\t * the F4 reference manual (RM0090). \t\t\t */\n+if|if\n+condition|(\n+name|data\n+operator|->\n+name|current\n+operator|.\n+name|msg\n+operator|->\n+name|len\n+operator|>\n+literal|2\n+condition|)\n+block|{\n+break|break;\n+block|}\nThe issue was with: drivers: i2c: i2c_ll_stm32_v1\n\nIn rare cases, the I2C driver runs the N==2 logic\nfor I2C receives when N>2. This change breaks early\nwhen handling the last 2 bytes for transactions with N>2"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: i2s: stm32: use length from i2s_write\n\nThe length parameter from `i2s_write` is not used correctly by\ni2s_ll_stm32.c. E.g. `i2s_write(dev, block, 0)` would work.\n\nUse the length from `i2s_write` in `dma_reload` to fix the issue. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|i2s\nargument_list|)\nargument_list|,\nendif|#\ndirective|endif\nname|stream\noperator|->\nname|cfg\noperator|.\nname|block_size\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|ret",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|stream\n-operator|->\n-name|cfg\n-operator|.\n-name|block_size\n+name|mem_block_size\nThe issue was with: drivers: i2s: stm32: use length from i2s_write\n\nThe length parameter from `i2s_write` is not used correctly by\ni2s_ll_stm32.c. E.g. `i2s_write(dev, block, 0)` would work.\n\nUse the length from `i2s_write` in `dma_reload` to fix the issue."
},{
  "instruction": "There is an issue in the following code. It relates to lib: os: coding guidelines: add explicit cast to void\n\n- added explicit cast to void when returned value is expectedly ignored Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}\nname|atomic_set\nargument_list|(\noperator|&\nname|sem\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+name|void\n+operator|)\nThe issue was with: lib: os: coding guidelines: add explicit cast to void\n\n- added explicit cast to void when returned value is expectedly ignored"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: ncp5623: check led_info for all LEDs\n\nWith the current code, when three separate monochrome LEDs are defined\nin DT, only the information from the first LED is checked during driver\ninitialization. This patch fixes the code to verify the information of\neach LED. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|=\nname|ncp5623_led_to_info\nargument_list|(\nname|config\nargument_list|,\nliteral|0\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\noperator|!",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|0\n+name|i\nThe issue was with: drivers: ncp5623: check led_info for all LEDs\n\nWith the current code, when three separate monochrome LEDs are defined\nin DT, only the information from the first LED is checked during driver\ninitialization. This patch fixes the code to verify the information of\neach LED."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: gpio: fix bug with Px15 pins\n\nFix condition in pin number check so that PA15, PB15, etc. can be properly\naccessed..\n\nCo-authored-by: Денис <baden.i.ua@gmail.com> Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\ncomment|/* Check for an invalid pin number */\nif|if\ncondition|(\nname|pin\noperator|>=\nliteral|15\ncondition|)\nblock|{\nreturn|return\noperator|-",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|>=\n+operator|>\nThe issue was with: drivers: gpio: fix bug with Px15 pins\n\nFix condition in pin number check so that PA15, PB15, etc. can be properly\naccessed..\n\nCo-authored-by: Денис <baden.i.ua@gmail.com>"
},{
  "instruction": "There is an issue in the following code. It relates to kernel/sched: Fix lockless ordering in halt_thread()\n\nWe've had threads spinning on the thread state bits, but weren't being\ncareful to ensure that those bits were the last things seen to change\nin a halting thread.  Move it to the end, and add a barrier for\ncorrectness. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|k_thread\nmodifier|*\nname|thread\nparameter_list|)\nblock|{\nname|thread\noperator|->\nname|base\noperator|.\nname|thread_state\noperator|.\nname|thread_state\noperator||=\nname|new_state\nexpr_stmt|;\nname|clear_halting\nargument_list|(\nname|thread\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|z_is_thread_queued\nargument_list|(\nname|thread\nname|new_state\noperator|==\nname|_THREAD_SUSPENDED\ncondition|)\nblock|{\nreturn|return;\nblock|}\nif|#\ndirective|if\nname|defined\noperator|&\nname|_thread_dummy\nargument_list|)\nexpr_stmt|;\nblock|}\nblock|}\nblock|}\nend_function\n\nbegin_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|barrier_dmem_fence_full\n+argument_list|()\n+expr_stmt|;\n+comment|/* Other cpus spin on this locklessly! */\n-name|clear_halting\n-argument_list|(\n-name|thread\n-argument_list|)\n-expr_stmt|;\n+name|clear_halting\n+argument_list|(\n+name|thread\n+argument_list|)\n+expr_stmt|;\n+comment|/* Finally update the halting thread state, on which \t\t * other CPUs might be spinning (see \t\t * thread_halt_spin()). \t\t */\n+name|clear_halting\n+argument_list|(\n+name|thread\n+argument_list|)\n+expr_stmt|;\nThe issue was with: kernel/sched: Fix lockless ordering in halt_thread()\n\nWe've had threads spinning on the thread state bits, but weren't being\ncareful to ensure that those bits were the last things seen to change\nin a halting thread.  Move it to the end, and add a barrier for\ncorrectness."
},{
  "instruction": "There is an issue in the following code. It relates to ipc_rpmsg_static_vrings: use names for WQ threads\n\nThis patch adds names to the threads created by `mbox_init` via\n`k_work_queue_start`. The name of the thread is the same as the name in\nthe device instance.\n\nThe main reason for this has to do with how `mcumgr` reports [thread\ninformation](https://docs.zephyrproject.org/latest/services/device_mgmt/smp_groups/smp_group_0.html#task-statistics-command).\nSpecifically, data about threads is sent in a CBOR encoded map where the\nmap keys are the thread names (at least in the default configuration). If\nthere's more than one IPC channel defined (one example of this being\n`samples/subsys/logging/multidomain`), both threads would be created\nwith an empty name and `mcumgr` will only return the data associated\nwith the thread created by the last call to `mbox_init`. Please fix this issue.",
  "input": "Faulty tokenized code:\ninit|=\nname|instance\noperator|->\nname|data\ndecl_stmt|;\nname|int\nname|prio\ndecl_stmt|,\nname|err\ndecl_stmt|;\nargument_list|,\nname|WQ_STACK_SIZE\nargument_list|,\nname|prio\nargument_list|,\nname|NULL\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|IS_ENABLED",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|struct\n+name|k_work_queue_config\n+name|wq_cfg\n+init|=\n+block|{\n+operator|.\n+name|name\n+operator|=\n+name|instance\n+operator|->\n+name|name\n+block|}\n+decl_stmt|;\n-name|NULL\n+operator|&\n+name|wq_cfg\nThe issue was with: ipc_rpmsg_static_vrings: use names for WQ threads\n\nThis patch adds names to the threads created by `mbox_init` via\n`k_work_queue_start`. The name of the thread is the same as the name in\nthe device instance.\n\nThe main reason for this has to do with how `mcumgr` reports [thread\ninformation](https://docs.zephyrproject.org/latest/services/device_mgmt/smp_groups/smp_group_0.html#task-statistics-command).\nSpecifically, data about threads is sent in a CBOR encoded map where the\nmap keys are the thread names (at least in the default configuration). If\nthere's more than one IPC channel defined (one example of this being\n`samples/subsys/logging/multidomain`), both threads would be created\nwith an empty name and `mcumgr` will only return the data associated\nwith the thread created by the last call to `mbox_init`."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Coverity fix dereference before null check\n\nhttps://scan9.scan.coverity.com/reports.htm#v45144/p12996/fileInstanceId=132890135&defectInstanceId=9972463&mergedDefectId=363710 Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<errno.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/sys/atomic.h>\nend_include\ninit|=\nliteral|0\ndecl_stmt|;\nname|size_t\nname|rem_len\ninit|=\nname|buf\noperator|->\nname|len\ndecl_stmt|;\nwhile|while\ncondition|(\nname|buf\noperator|&&\nname|sent\noperator|!=\nname|rem_len\ncondition|)\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/sys/__assert.h>\n+end_include\n+\n-init|=\n+decl_stmt|;\n+name|__ASSERT_NO_MSG\n+argument_list|(\n+name|buf\n+argument_list|)\n+expr_stmt|;\n+name|rem_len\n+operator|=\n-decl_stmt|;\n+expr_stmt|;\n-name|buf\n-operator|&&\nThe issue was with: Bluetooth: Coverity fix dereference before null check\n\nhttps://scan9.scan.coverity.com/reports.htm#v45144/p12996/fileInstanceId=132890135&defectInstanceId=9972463&mergedDefectId=363710"
},{
  "instruction": "There is an issue in the following code. It relates to kernel: coding guidelines: add explicit cast to void\n\n- added explicit cast to void when returned value is expectedly ignored Please fix this issue.",
  "input": "Faulty tokenized code:\nname|base\noperator|.\nname|global_lock_count\ncondition|)\nblock|{\nname|atomic_clear\nargument_list|(\noperator|&\nname|global_lock\nargument_list|)\nname|base\noperator|.\nname|global_lock_count\ncondition|)\nblock|{\nname|atomic_clear\nargument_list|(\noperator|&\nname|global_lock\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+name|void\n+operator|)\n+operator|(\n+name|void\n+operator|)\nThe issue was with: kernel: coding guidelines: add explicit cast to void\n\n- added explicit cast to void when returned value is expectedly ignored"
},{
  "instruction": "There is an issue in the following code. It relates to coding guidelines: comply with MISRA Rule 2.2\n\n- avoided dead stores Please fix this issue.",
  "input": "Faulty tokenized code:\nname|num_blocks\nparameter_list|)\nblock|{\nname|int\nname|rc\ninit|=\nliteral|0\ndecl_stmt|;\nname|slab\noperator|->\nname|info\noperator|.\nname|_sched_spinlock\nargument_list|)\ndecl_stmt|;\nname|int\nname|ret\ninit|=\nliteral|0\ndecl_stmt|;\nname|SYS_PORT_TRACING_OBJ_FUNC_ENTER\nargument_list|(\nname|k_thread\nargument_list|,\nname|timeout\nparameter_list|)\nblock|{\nname|int\nname|ret\ninit|=\nliteral|0\ndecl_stmt|;\nname|__ASSERT\nargument_list|(\noperator|(\noperator|(\nname|EINVAL\nreturn|;\nblock|}\nname|int\nname|ret\ninit|=\noperator|-\nname|EBUSY\ndecl_stmt|;\nname|bool\nname|chained\ninit|=\noperator|(\nname|delay\nargument_list|)\nexpr_stmt|;\nname|int\nname|ret\ninit|=\nliteral|0\ndecl_stmt|;\nname|k_spinlock_key_t\nname|key\ninit|=\nname|k_spin_lock",
  "result": "I corrected the issue in the code by changing the following tokens:\n-init|=\n-literal|0\n-init|=\n-literal|0\n-init|=\n-literal|0\n-init|=\n-operator|-\n-name|EBUSY\n-init|=\n-literal|0\nThe issue was with: coding guidelines: comply with MISRA Rule 2.2\n\n- avoided dead stores"
},{
  "instruction": "There is an issue in the following code. It relates to lorawan/nvm: do not call settings_save() after writing individual settings\n\nThe lorawan subsystem do not use settings handler, and instead uses\nindividual calls to settings_save_one(). With this strategy there is no\nneed to call settings_save() at the end. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nblock|}\nblock|}\nblock|}\nname|settings_save\nargument_list|()\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|lorawan_nvm_data_mgmt_event (uint16_t flags)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|settings_save\n-argument_list|()\n-expr_stmt|;\nThe issue was with: lorawan/nvm: do not call settings_save() after writing individual settings\n\nThe lorawan subsystem do not use settings handler, and instead uses\nindividual calls to settings_save_one(). With this strategy there is no\nneed to call settings_save() at the end."
},{
  "instruction": "There is an issue in the following code. It relates to input: analog_axis: use k_sem for locking\n\nSwap the mutex with a semaphore for locking the calibration data.\nLighter data structure, no need to use a mutex here. Please fix this issue.",
  "input": "Faulty tokenized code:\nstruct|struct\nname|analog_axis_data\nblock|{\nDECL|member|cal_lock\nname|struct\nname|k_mutex\nname|cal_lock\ndecl_stmt|;\nDECL|member|raw_data_cb\nname|analog_axis_raw_data_t\nname|raw_data_cb\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}\nname|k_mutex_lock\nargument_list|(\noperator|&\nname|data\noperator|->\nname|cal_lock\nexpr|struct\nname|analog_axis_calibration\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|k_mutex_unlock\nargument_list|(\noperator|&\nname|data\noperator|->\nname|cal_lock\ninit|=\nname|dev\noperator|->\nname|data\ndecl_stmt|;\nname|k_mutex_lock\nargument_list|(\noperator|&\nname|data\noperator|->\nname|cal_lock\noperator|->\nname|raw_data_cb\noperator|=\nname|cb\nexpr_stmt|;\nname|k_mutex_unlock\nargument_list|(\noperator|&\nname|data\noperator|->\nname|cal_lock\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}\nname|k_mutex_lock\nargument_list|(\noperator|&\nname|data\noperator|->\nname|cal_lock\nexpr|struct\nname|analog_axis_calibration\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|k_mutex_unlock\nargument_list|(\noperator|&\nname|data\noperator|->\nname|cal_lock\nname|err\nargument_list|)\nexpr_stmt|;\nreturn|return;\nblock|}\nname|k_mutex_lock\nargument_list|(\noperator|&\nname|data\noperator|->\nname|cal_lock\nname|last_out\noperator|=\nname|out\nexpr_stmt|;\nblock|}\nname|k_mutex_unlock\nargument_list|(\noperator|&\nname|data\noperator|->\nname|cal_lock\nname|data\ndecl_stmt|;\nname|k_tid_t\nname|tid\ndecl_stmt|;\nname|k_mutex_init\nargument_list|(\noperator|&\nname|data\noperator|->\nname|cal_lock\nargument_list|)\nexpr_stmt|;\nname|tid\noperator|=\nname|k_thread_create",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|k_mutex\n+name|k_sem\n-name|k_mutex_lock\n+name|k_sem_take\n-name|k_mutex_unlock\n+name|k_sem_give\n-name|k_mutex_lock\n+name|k_sem_take\n-name|k_mutex_unlock\n+name|k_sem_give\n-name|k_mutex_lock\n+name|k_sem_take\n-name|k_mutex_unlock\n+name|k_sem_give\n-name|k_mutex_lock\n+name|k_sem_take\n-name|k_mutex_unlock\n+name|k_sem_give\n-name|k_mutex_init\n+name|k_sem_init\n+argument_list|,\n+literal|1\n+argument_list|,\n+literal|1\nThe issue was with: input: analog_axis: use k_sem for locking\n\nSwap the mutex with a semaphore for locking the calibration data.\nLighter data structure, no need to use a mutex here."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: timeslicing: add time slice reset in slice per thread api\n\nThis will reset time slice in k_thread_time_slice_set()\nwhen slice per thread api is used.\n\nCurrently it will reset it only in standard slice_set Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|.\nname|slice_data\noperator|=\nname|data\nexpr_stmt|;\nblock|}\nblock|}\nend_function\n\nbegin_endif",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|z_reset_time_slice\n+argument_list|(\n+name|thread\n+argument_list|)\n+expr_stmt|;\nThe issue was with: kernel: timeslicing: add time slice reset in slice per thread api\n\nThis will reset time slice in k_thread_time_slice_set()\nwhen slice per thread api is used.\n\nCurrently it will reset it only in standard slice_set"
},{
  "instruction": "There is an issue in the following code. It relates to coding guidelines: comply with MISRA C:2012 Rule 11.2\n\navoid convert pointers to incomplete type using the pointer to first item Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_define\nDECL|macro|Z_KERNEL_VIRT_START\ndefine|#\ndirective|define\nname|Z_KERNEL_VIRT_START\nvalue|((uint8_t *)(&z_mapped_start))\nend_define\n\nbegin_define\nDECL|macro|Z_KERNEL_VIRT_END\ndefine|#\ndirective|define\nname|Z_KERNEL_VIRT_END\nvalue|((uint8_t *)(&z_mapped_end))\nend_define\n\nbegin_define\nDECL|macro|Z_KERNEL_VIRT_SIZE\ndefine|#\nbegin_struct\nDECL|struct|z_page_frame\nstruct|struct\nname|z_page_frame\nblock|{\nDECL|union|__anon2b188e0b010a\nunion|union\nblock|{\ncomment|/* If mapped, virtual address this page is mapped to */\nDECL|member|addr\nname|void\nname|z_app_region\noperator|*\noperator|)\noperator|&\nname|__app_shmem_regions_end\nexpr_stmt|;\nname|region\noperator|=\noperator|(\nexpr|struct\nname|z_app_region\noperator|*\noperator|)\noperator|&\nname|__app_shmem_regions_start\nexpr_stmt|;\nfor|for\ncontrol|(\ninit|;\nname|region",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|((uint8_t *)(&z_mapped_start))\n+value|((uint8_t *)&z_mapped_start[0])\n-value|((uint8_t *)(&z_mapped_end))\n+value|((uint8_t *)&z_mapped_end[0])\n-DECL|union|__anon2b188e0b010a\n+DECL|union|__anon2aa5aa86010a\n+index|[\n+literal|0\n+index|]\n+index|[\n+literal|0\n+index|]\nThe issue was with: coding guidelines: comply with MISRA C:2012 Rule 11.2\n\navoid convert pointers to incomplete type using the pointer to first item"
},{
  "instruction": "There is an issue in the following code. It relates to tests: bsim: Bluetooth: Reduce multiple id test execution iterations\n\nReduce the iterations in multiple id multiple simultaneous\nconnections test, and tune the buffer counts to catch any\nbuffer leak related regressions. Please fix this issue.",
  "input": "Faulty tokenized code:\n\nCONFIG_BT_CTLR_DATA_LENGTH_MAX=251\n\n# Each PHY update can pause connections for 6 interval hence to let other\n# parallel connection establishment to succeed increase Rx buffer count.\nCONFIG_BT_CTLR_RX_BUFFERS=6\n\n# Provide enough spacing between connections so that multiple peripheral roles\n# when connected to a single peer device (peripheral_identity sample) have\n# room for window widening and do not overlap with each other in that single\n# peer device. This can be tuned based on connection interval and clock\ninclude|#\ndirective|include\nfile|\"bstests.h\"\nend_include\n\nbegin_define\nDECL|macro|ITERATIONS\ndefine|#\ndirective|define\nname|ITERATIONS\nvalue|10\nend_define\n\nbegin_function_decl\nname|int\nname|init_central\nname|void\nparameter_list|)\nblock|{\nname|bst_ticker_set_next_tick_absolute\nargument_list|(\nliteral|4500e6\nargument_list|)\nexpr_stmt|;\nname|bst_result\noperator|=\nname|In_progress\nsource ${ZEPHYR_BASE}/tests/bsim/sh_common.source\n\n# Multiple connection between two devices with multiple peripheral identity\nsimulation_id=\"multiple\"\nverbosity_level=2\nEXECUTE_TIMEOUT=2200\n\ncd ${BSIM_OUT_PATH}/bin\n\nExecute ./bs_${BOARD_TS}_tests_bsim_bluetooth_ll_multiple_id_prj_conf \\\n  -v=${verbosity_level} -s=${simulation_id} -d=0 -testid=central\n\nExecute ./bs_${BOARD_TS}_tests_bsim_bluetooth_ll_multiple_id_prj_conf\\\n  -v=${verbosity_level} -s=${simulation_id} -d=1 -testid=peripheral\n\nExecute ./bs_2G4_phy_v1 -v=${verbosity_level} -s=${simulation_id} \\\n -D=2 -sim_length=4500e6 $@ -argschannel -at=40\n\nwait_for_background_jobs",
  "result": "I corrected the issue in the code by changing the following tokens:\n-CONFIG_BT_CTLR_RX_BUFFERS=6\n+# A minimum of 1 Rx buffer is required to receive data PDU, during control\n+# procedures Rx buffer could be held, preventing new connections to be\n+# established, a value of 3 is tuned based on this test case execution for 2\n+# iterations. If there is buffer leak, simulated by using value of 2 here, the\n+# test is failing.\n+# If there is buffer leak, this test now should catch it.\n+CONFIG_BT_CTLR_RX_BUFFERS=3\n+begin_comment\n+comment|/* The test case is performing 250 simultaneous connections and managing  * parallel control procedures utilizing the available/configured minimum  * buffer counts. Hence, two iterations of connect-disconnect should be  * sufficient to catch any regressions/buffer leaks.  */\n+end_comment\n+\n-value|10\n+value|2\n-literal|4500e6\n+literal|1500e6\n-EXECUTE_TIMEOUT=2200\n+EXECUTE_TIMEOUT=1600\n-  -D=2 -sim_length=4500e6 $@ -argschannel -at=40\n+  -D=2 -sim_length=1800e6 $@ -argschannel -at=40\nThe issue was with: tests: bsim: Bluetooth: Reduce multiple id test execution iterations\n\nReduce the iterations in multiple id multiple simultaneous\nconnections test, and tune the buffer counts to catch any\nbuffer leak related regressions."
},{
  "instruction": "There is an issue in the following code. It relates to coding guidelines: comply with MISRA Rule 21.15\n\n- made explicit the copied data type Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|msgq\noperator|->\nname|write_ptr\nargument_list|,\nname|data\nargument_list|,\nname|msgq\noperator|->\nname|msg_size\noperator|(\nname|void\noperator|)\nname|memcpy\nargument_list|(\nname|data\nargument_list|,\nname|msgq\noperator|->\nname|read_ptr\nargument_list|(\nname|msgq\noperator|->\nname|write_ptr\nargument_list|,\nname|pending_thread\noperator|->\nname|base\noperator|.\nname|swap_data\noperator|(\nname|void\noperator|)\nname|memcpy\nargument_list|(\nname|data\nargument_list|,\nname|msgq\noperator|->\nname|read_ptr",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+name|char\n+operator|*\n+operator|)\n+operator|(\n+name|char\n+operator|*\n+operator|)\n+operator|(\n+name|char\n+operator|*\n+operator|)\n+operator|(\n+name|char\n+operator|*\n+operator|)\nThe issue was with: coding guidelines: comply with MISRA Rule 21.15\n\n- made explicit the copied data type"
},{
  "instruction": "There is an issue in the following code. It relates to coding guidelines: comply with MISRA Rule 20.9\n\n- avoid to use undefined macros in #if expressions Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nendif|#\ndirective|endif\nendif|#\ndirective|endif\nif|#\ndirective|if\nname|CONFIG_X86_STACK_PROTECTION\nname|unsigned\nname|int\nname|num_cpus\ninit|=\nendif|#\ndirective|endif\nblock|}\nend_function\n\nbegin_if\nif|#\ndirective|if\nname|CONFIG_X86_STACK_PROTECTION\nend_if\n\nbegin_function\nname|__pinned_func\nDECL|function|z_x86_set_stack_guard (k_thread_stack_t * stack)\nname|void",
  "result": "I corrected the issue in the code by changing the following tokens:\n-if|#\n-directive|if\n+ifdef|#\n+directive|ifdef\n-begin_if\n-if|#\n-directive|if\n+begin_ifdef\n+ifdef|#\n+directive|ifdef\n-end_if\n+end_ifdef\nThe issue was with: coding guidelines: comply with MISRA Rule 20.9\n\n- avoid to use undefined macros in #if expressions"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: flash: andes_qspi: fix accessing error variable\n\nFix accessing error variable when using FLASH_ANDES_QSPI_SFDP_RUNTIME. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|uint8_t\nname|decl_nph\ninit|=\nliteral|2\ndecl_stmt|;\nDECL|union|__anon27602fd7010a\nunion|union\nblock|{\ncomment|/* We only process BFP so use one parameter block */\nDECL|member|raw\nname|uint8_t\nname|id\noperator|==\nname|JESD216_SFDP_PARAM_ID_BFP\ncondition|)\nblock|{\nDECL|union|__anon27602fd7020a\nunion|union\nblock|{\nDECL|member|dw\nname|uint32_t\nname|dw\nname|dev\nargument_list|,\noperator|&\nname|bfp_hdr\nargument_list|,\nname|cfg\noperator|->\nname|bfp\nargument_list|)\nexpr_stmt|;\nelse|#\ncondition|(\nname|memcmp\nargument_list|(\nname|jedec_id\nargument_list|,\nname|cfg\noperator|->\nname|jedec_id\nargument_list|,\nsizeof|sizeof\nargument_list|(\nname|jedec_id\nindex|[\nliteral|2\nindex|]\nargument_list|,\nname|cfg\noperator|->\nname|jedec_id\nindex|[\nliteral|0\nindex|]\nargument_list|,\nname|cfg\noperator|->\nname|jedec_id\nindex|[\nliteral|1\nindex|]\nargument_list|,\nname|cfg\noperator|->\nname|jedec_id\nindex|[\nliteral|2\nindex|]",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon27602fd7010a\n+DECL|union|__anon2ad1d6e7010a\n-DECL|union|__anon27602fd7020a\n+DECL|union|__anon2ad1d6e7020a\n-name|cfg\n+name|config\n-name|cfg\n+name|config\n-name|cfg\n+name|config\n-name|cfg\n+name|config\n-name|cfg\n+name|config\nThe issue was with: drivers: flash: andes_qspi: fix accessing error variable\n\nFix accessing error variable when using FLASH_ANDES_QSPI_SFDP_RUNTIME."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: flash: andes_qspi: fix shadow variable error\n\nMake the variables naming more specific. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|uint8_t\nname|decl_nph\ninit|=\nliteral|2\ndecl_stmt|;\nDECL|union|__anon2b2114cd010a\nunion|union\nblock|{\ncomment|/* We only process BFP so use one parameter block */\nDECL|member|raw\nname|uint8_t\nname|struct\nname|jesd216_sfdp_header\nname|sfdp\ndecl_stmt|;\nblock|}\nname|u\nunion|;\nspecifier|const\nname|struct\nname|jesd216_sfdp_header\nmodifier|*\nname|hp\ninit|=\noperator|&\nname|u\noperator|.\nname|sfdp\ndecl_stmt|;\nname|ret\noperator|=\nargument_list|(\nname|dev\nargument_list|,\nliteral|0\nargument_list|,\nname|u\noperator|.\nname|raw\nargument_list|,\nsizeof|sizeof\nargument_list|(\nname|u\noperator|.\nname|raw\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|id\noperator|==\nname|JESD216_SFDP_PARAM_ID_BFP\ncondition|)\nblock|{\nDECL|union|__anon2b2114cd020a\nunion|union\nblock|{\nDECL|member|dw\nname|uint32_t\nname|dw\nname|struct\nname|jesd216_bfp\nname|bfp\ndecl_stmt|;\nblock|}\nname|u\nunion|;\nspecifier|const\nname|struct\nname|jesd216_bfp\nmodifier|*\nname|bfp\ninit|=\noperator|&\nname|u\noperator|.\nname|bfp\ndecl_stmt|;\nname|ret\noperator|=\nname|jesd216_param_addr\nargument_list|(\nname|php\nargument_list|)\nargument_list|,\nname|u\noperator|.\nname|dw\nargument_list|,\nsizeof|sizeof\nargument_list|(\nname|u\noperator|.\nname|dw\nargument_list|)\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon2b2114cd010a\n+DECL|union|__anon27602fd7010a\n-name|u\n+name|u_header\n-name|u\n+name|u_header\n-name|u\n+name|u_header\n-name|u\n+name|u_header\n-DECL|union|__anon2b2114cd020a\n+DECL|union|__anon27602fd7020a\n-name|u\n+name|u_param\n-name|u\n+name|u_param\n-name|u\n+name|u_param\n-name|u\n+name|u_param\nThe issue was with: drivers: flash: andes_qspi: fix shadow variable error\n\nMake the variables naming more specific."
},{
  "instruction": "There is an issue in the following code. It relates to sensor: decoder: Use helper API to compute header size\n\nTo be consistent with the computed offset on sensor_submit_fallback()\nimplementation. This prevents falling in misalignment issues when the\nnumber of sensor channels changes. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|*\noperator|)\noperator|(\nname|buffer\noperator|+\nsizeof|sizeof\nargument_list|(\nexpr|struct\nname|sensor_data_generic_header\nargument_list|)\noperator|+\nname|header\noperator|->\nname|num_channels\noperator|*\nsizeof|sizeof\nargument_list|(\nexpr|enum\nname|sensor_channel\nargument_list|)\noperator|)\ndecl_stmt|;\nname|int\nname|count",
  "result": "I corrected the issue in the code by changing the following tokens:\n-sizeof|sizeof\n+name|compute_header_size\n-expr|struct\n-name|sensor_data_generic_header\n-argument_list|)\n-operator|+\n-operator|*\n-sizeof|sizeof\n-argument_list|(\n-expr|enum\n-name|sensor_channel\nThe issue was with: sensor: decoder: Use helper API to compute header size\n\nTo be consistent with the computed offset on sensor_submit_fallback()\nimplementation. This prevents falling in misalignment issues when the\nnumber of sensor channels changes."
},{
  "instruction": "There is an issue in the following code. It relates to sensor: rtio_default: Remove log when device does not contain channel\n\nSince this loops over all listed sensor channels, this makes more\ndifficult catching other debug log messages that might be of interest\n(e.g: Decoding results). Please fix this issue.",
  "input": "Faulty tokenized code:\nname|rc\noperator|!=\nliteral|0\ncondition|)\nblock|{\nname|LOG_DBG\nargument_list|(\nliteral|\"Failed to get channel %d, skipping\"\nargument_list|,\nname|channels\nindex|[\nname|i\nindex|]\nargument_list|)\nexpr_stmt|;\ncontinue|continue;\nblock|}\ncomment|/* Get the largest absolute value reading to set the scale for the channel */\nname|uint32_t\nname|header_scale",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|LOG_DBG\n-argument_list|(\n-literal|\"Failed to get channel %d, skipping\"\n-argument_list|,\n-name|channels\n-index|[\n-name|i\n-index|]\n-argument_list|)\n-expr_stmt|;\nThe issue was with: sensor: rtio_default: Remove log when device does not contain channel\n\nSince this loops over all listed sensor channels, this makes more\ndifficult catching other debug log messages that might be of interest\n(e.g: Decoding results)."
},{
  "instruction": "There is an issue in the following code. It relates to sensor: rtio_default: Add shift to sensor_submit_fallback DBG printout\n\nTo facilitate calculation verification between Q-number and value\nobtained through fetch/get APIs. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|shift\nexpr_stmt|;\nname|LOG_DBG\nargument_list|(\nliteral|\"value[%d]=%s%d.%06d, q[%d]@%p=%d\"\nargument_list|,\nname|sample\nargument_list|,\nname|value_u\noperator|<\nindex|[\nname|sample_idx\noperator|+\nname|sample\nindex|]\nargument_list|)\nexpr_stmt|;\nblock|}\nname|sample_idx\noperator|+=",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"value[%d]=%s%d.%06d, q[%d]@%p=%d\"\n+literal|\"value[%d]=%s%d.%06d, q[%d]@%p=%d, shift: %d\"\n+argument_list|,\n+name|header\n+operator|->\n+name|shift\nThe issue was with: sensor: rtio_default: Add shift to sensor_submit_fallback DBG printout\n\nTo facilitate calculation verification between Q-number and value\nobtained through fetch/get APIs."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: watchdog stm32 independent wdg when enable at boot\n\nWhen the CONFIG_WDT_DISABLE_AT_BOOT is not set, the iwdg\nshould be configured by iwdg_stm32_install_timeout\nand started by iwdg_stm32_setup Please fix this issue.",
  "input": "Faulty tokenized code:\nname|max\noperator|=\nname|CONFIG_IWDG_STM32_INITIAL_TIMEOUT\nblock|}\ndecl_stmt|;\nname|iwdg_stm32_install_timeout\nargument_list|(\nname|dev\nargument_list|,\noperator|&\nname|config\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\ncomment|/* \t * The ST production value for the option bytes where WDG_SW bit is \t * present is 0x00FF55AA, namely the Software watchdog mode is \t * enabled by default. \t * If the IWDG is started by either hardware option or software access, \t * the LSI oscillator is forced ON and cannot be disabled. \t * \t * t_IWDG(ms) = t_LSI(ms) x 4 x 2^(IWDG_PR[2:0]) x (IWDG_RLR[11:0] + 1) \t */\nreturn|return\nliteral|0",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Watchdog should be configured and started by `wdt_setup`*/\n+name|iwdg_stm32_setup\n+argument_list|(\n+name|dev\n+argument_list|,\n+literal|0\n+argument_list|)\n+expr_stmt|;\n+comment|/* no option specified */\nThe issue was with: drivers: watchdog stm32 independent wdg when enable at boot\n\nWhen the CONFIG_WDT_DISABLE_AT_BOOT is not set, the iwdg\nshould be configured by iwdg_stm32_install_timeout\nand started by iwdg_stm32_setup"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: display: sdl: Fix asserts in sdl_display_write\n\nThe asserts and validation code were incorrectly mixing pitch and\nwidth.  These incorrect checks were preventing rendering code from\nre-using a smaller section of a buffer allocated to fit the full\nscreen. We expect to be able to update a portion of the display from a\nportion of the buffer, in which case pitch must remain the screen\nwidth. Expecting x + pitch to be smaller than the screen width is\nincorrect. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|x\noperator|+\nname|desc\noperator|->\nname|pitch\noperator|<=\nname|config\noperator|->\nname|width\nargument_list|,\noperator|||\nname|x\noperator|+\nname|desc\noperator|->\nname|pitch\noperator|>\nname|config\noperator|->\nname|width\noperator|||",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|pitch\n+name|width\n-name|pitch\n+name|width\nThe issue was with: drivers: display: sdl: Fix asserts in sdl_display_write\n\nThe asserts and validation code were incorrectly mixing pitch and\nwidth.  These incorrect checks were preventing rendering code from\nre-using a smaller section of a buffer allocated to fit the full\nscreen. We expect to be able to update a portion of the display from a\nportion of the buffer, in which case pitch must remain the screen\nwidth. Expecting x + pitch to be smaller than the screen width is\nincorrect."
},{
  "instruction": "There is an issue in the following code. It relates to net: ipv6: mld: Fix improper reference drop\n\nIn case of successful submission, the reference shouldn't be put down,\nthis only should done on error cases.\n\nAs reference is put down on success, during the buffer unref, no action\nis taken due to an uint8 overflow (ref is now 255), so, the buf->frags\nisn't cleared properly and the next time the frags is used and when L2\ninserts a second frag, the first head frag and next frag are same (due\nto buffer re-use) causing an infinite loop in either net_buf_frag_last\nor net_pkt_get_len. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ret\noperator|<\nliteral|0\ncondition|)\nblock|{\nreturn|return\nname|ret\nreturn|;\nblock|}\nname|drop\nlabel|:\nname|net_pkt_unref\nargument_list|(\nname|pkt",
  "result": "I corrected the issue in the code by changing the following tokens:\n+goto|goto\n+name|drop\n+goto|;\n+block|}\n-name|ret\n+literal|0\n-block|}\nThe issue was with: net: ipv6: mld: Fix improper reference drop\n\nIn case of successful submission, the reference shouldn't be put down,\nthis only should done on error cases.\n\nAs reference is put down on success, during the buffer unref, no action\nis taken due to an uint8 overflow (ref is now 255), so, the buf->frags\nisn't cleared properly and the next time the frags is used and when L2\ninserts a second frag, the first head frag and next frag are same (due\nto buffer re-use) causing an infinite loop in either net_buf_frag_last\nor net_pkt_get_len."
},{
  "instruction": "There is an issue in the following code. It relates to tests: counter_basic_api: add imx93 evk support\n\nAdd i.MX 93 EVK support for counter_basic_api test application. Please fix this issue.",
  "input": "Faulty tokenized code:\nnew file mode 100644\nargument_list|)\nname|DEVS_FOR_DT_COMPAT\nargument_list|(\nargument|nxp_imx_gpt\nargument_list|)\nname|DEVS_FOR_DT_COMPAT\nargument_list|(\nargument|renesas_smartbond_timer\nargument_list|)\nifdef|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n+/*\n+ * Copyright 2024 NXP\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+&tpm2 {\n+\tstatus = \"okay\";\n+};\n+ifdef|#\n+directive|ifdef\n+name|CONFIG_COUNTER_MCUX_TPM\n+name|DEVS_FOR_DT_COMPAT\n+argument_list|(\n+argument|nxp_tpm_timer\n+argument_list|)\n+endif|#\n+directive|endif\nThe issue was with: tests: counter_basic_api: add imx93 evk support\n\nAdd i.MX 93 EVK support for counter_basic_api test application."
},{
  "instruction": "There is an issue in the following code. It relates to pm: device_runtime: Check busy status in runtime_enable\n\nWe can't enable device runtime power management in a device that is\nset busy since it may suspend this device. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|device\nmodifier|*\nname|dev\nparameter_list|)\nfunction_decl|;\ncomment|/**  * @brief Enable device runtime PM  *  * This function will enable runtime PM on the given device. If the device is  * in #PM_DEVICE_STATE_ACTIVE state, the device will be suspended.  *  * @funcprops \\pre_kernel_ok  *  * @param dev Device instance.  *  * @retval 0 If the device runtime PM is enabled successfully.  * @retval -EPERM If device has power state locked.  * @retval -ENOTSUP If the device does not support PM.  * @retval -errno Other negative errno, result of suspending the device.  *  * @see pm_device_init_suspended()  */\nname|int\nname|pm_device_runtime_enable\nparameter_list|(\nspecifier|const\nname|struct\nname|end\ngoto|;\nblock|}\nif|if\ncondition|(\nname|atomic_test_bit\nargument_list|(\noperator|&\nname|dev\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/**  * @brief Enable device runtime PM  *  * This function will enable runtime PM on the given device. If the device is  * in #PM_DEVICE_STATE_ACTIVE state, the device will be suspended.  *  * @funcprops \\pre_kernel_ok  *  * @param dev Device instance.  *  * @retval 0 If the device runtime PM is enabled successfully.  * @retval -EPERM If device has power state locked.  * @retval -ENOTSUP If the device does not support PM.  * @retval -errno Other negative errno, result of suspending the device.  *  * @see pm_device_init_suspended()  */\n+comment|/**  * @brief Enable device runtime PM  *  * This function will enable runtime PM on the given device. If the device is  * in #PM_DEVICE_STATE_ACTIVE state, the device will be suspended.  *  * @funcprops \\pre_kernel_ok  *  * @param dev Device instance.  *  * @retval 0 If the device runtime PM is enabled successfully.  * @retval -EPERM If device has power state locked.  * @retval -EBUSY If device is busy.  * @retval -ENOTSUP If the device does not support PM.  * @retval -errno Other negative errno, result of suspending the device.  *  * @see pm_device_init_suspended()  */\n+name|pm_device_is_busy\n+argument_list|(\n+name|dev\n+argument_list|)\n+condition|)\n+block|{\n+name|ret\n+operator|=\n+operator|-\n+name|EBUSY\n+expr_stmt|;\n+goto|goto\n+name|end\n+goto|;\n+block|}\n+if|if\n+condition|(\nThe issue was with: pm: device_runtime: Check busy status in runtime_enable\n\nWe can't enable device runtime power management in a device that is\nset busy since it may suspend this device."
},{
  "instruction": "There is an issue in the following code. It relates to Revert \\\"drivers: serial: uart_mcux_lpuart: fix IRQ-driven API with ASYNC_API\\\"\n\nThis reverts commit 485c926b15becc0f094190cb08a4b6072a336b94 [formerly a80fa5163bb162f12614dc792aa17016c0fa1ac6].\n\nThat commit broke the polling API when used with the interrupt driven,\nit is completely wrong to disable the receiver from irq_rx_disable,\nthe uart_basic_api test has been broken on all lpuart platforms because\nof this bug. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|base\nargument_list|,\nname|mask\nargument_list|)\nexpr_stmt|;\nname|LPUART_EnableRx\nargument_list|(\nname|config\noperator|->\nname|base\nargument_list|,\nname|true\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|mcux_lpuart_irq_rx_disable (const struct device * dev)\nname|uint32_t\nname|mask\ninit|=\nname|kLPUART_RxDataRegFullInterruptEnable\ndecl_stmt|;\nname|LPUART_EnableRx\nargument_list|(\nname|config\noperator|->\nname|base\nargument_list|,\nname|false\nargument_list|)\nexpr_stmt|;\nname|LPUART_DisableInterrupts\nargument_list|(\nname|config\noperator|->\nname|base",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|LPUART_EnableRx\n-argument_list|(\n-name|config\n-operator|->\n-name|base\n-argument_list|,\n-name|true\n-argument_list|)\n-expr_stmt|;\n-name|LPUART_EnableRx\n-argument_list|(\n-name|config\n-operator|->\n-name|base\n-argument_list|,\n-name|false\n-argument_list|)\n-expr_stmt|;\nThe issue was with: Revert \\\"drivers: serial: uart_mcux_lpuart: fix IRQ-driven API with ASYNC_API\\\"\n\nThis reverts commit 485c926b15becc0f094190cb08a4b6072a336b94 [formerly a80fa5163bb162f12614dc792aa17016c0fa1ac6].\n\nThat commit broke the polling API when used with the interrupt driven,\nit is completely wrong to disable the receiver from irq_rx_disable,\nthe uart_basic_api test has been broken on all lpuart platforms because\nof this bug."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: Update thread cpu in z_get_next_switch_handle()\n\nUpdates z_get_next_switch_handle() to set the new thread's base.cpu\nvalue as it is done in do_swap(). This helps to ensure that the\nlast CPU on which the thread executed remains current. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|swap_ok\noperator|=\nliteral|0\nexpr_stmt|;\nname|set_current\nargument_list|(\nname|new_thread\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|new_thread\n+operator|->\n+name|base\n+operator|.\n+name|cpu\n+operator|=\n+name|arch_curr_cpu\n+argument_list|()\n+operator|->\n+name|id\n+expr_stmt|;\nThe issue was with: kernel: Update thread cpu in z_get_next_switch_handle()\n\nUpdates z_get_next_switch_handle() to set the new thread's base.cpu\nvalue as it is done in do_swap(). This helps to ensure that the\nlast CPU on which the thread executed remains current."
},{
  "instruction": "There is an issue in the following code. It relates to ARC: fault: Fix uninitialized memory access\n\nFound via static analysis. In fault path when checking for stack\noverflows, if CONFIG_MULTITHREADING is not set, `guard_end` is left\nuninitialized and is subsequently used in a comparison.\n\nThe solution is to simply return `false` in this configuration as stack\nguards are not configured in the first place. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|,\nname|uint32_t\nname|sp\nparameter_list|)\nblock|{\nname|uint32_t\nname|guard_end\ndecl_stmt|,\nname|guard_start\ndecl_stmt|;\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_MULTITHREADING\nargument_list|)\nspecifier|const\nname|struct\nname|k_thread\nmodifier|*\nname|thread\nname|guard_end\noperator|-\nname|Z_ARC_STACK_GUARD_SIZE\nexpr_stmt|;\nblock|}\nendif|#\ndirective|endif\ncomment|/* CONFIG_MULTITHREADING */\ncomment|/* treat any MPU exceptions within the guard region as a stack \t  * overflow.As some instrustions \t  * (like enter_s {r13-r26, fp, blink}) push a collection of \t  * registers on to the stack. In this situation, the fault_addr \t  * will less than guard_end, but sp will greater than guard_end. \t  */\nif|if\ncondition|(\nname|fault_addr\noperator|<\nblock|{\nreturn|return\nname|true\nreturn|;\nblock|}\nreturn|return\nname|false\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|uint32_t\n-name|guard_end\n-decl_stmt|,\n-name|guard_start\n-decl_stmt|;\n+name|uint32_t\n+name|guard_end\n+decl_stmt|,\n+name|guard_start\n+decl_stmt|;\n-endif|#\n-directive|endif\n-comment|/* CONFIG_MULTITHREADING */\n+endif|#\n+directive|endif\n+comment|/* CONFIG_MULTITHREADING */\nThe issue was with: ARC: fault: Fix uninitialized memory access\n\nFound via static analysis. In fault path when checking for stack\noverflows, if CONFIG_MULTITHREADING is not set, `guard_end` is left\nuninitialized and is subsequently used in a comparison.\n\nThe solution is to simply return `false` in this configuration as stack\nguards are not configured in the first place."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: VCP: Remove bad busy flag set for vol ctlr\n\nThe volume controller always set the busy flag in\nbt_vcp_vol_ctlr_set_vol, where it should only set it\nif the GATT operation succeeds. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|=\nname|volume\nexpr_stmt|;\nname|vol_ctlr\noperator|->\nname|busy\noperator|=\nname|true\nexpr_stmt|;\nname|vol_ctlr\noperator|->\nname|write_params\noperator|.\nname|offset\noperator|=\nliteral|0",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|busy\n-operator|=\n-name|true\n-expr_stmt|;\n-name|vol_ctlr\n-operator|->\nThe issue was with: Bluetooth: VCP: Remove bad busy flag set for vol ctlr\n\nThe volume controller always set the busy flag in\nbt_vcp_vol_ctlr_set_vol, where it should only set it\nif the GATT operation succeeds."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Test: Update `hci_prop_evt`\n\nAccept LE Read Max Advertising Data Length command during HCI\ninitialization. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|bt_hci_cp_le_set_random_address\nargument_list|)\nblock|,\nname|generic_success\nblock|}\nblock|, }\ndecl_stmt|;\nend_decl_stmt\n\nbegin_comment",
  "result": "I corrected the issue in the code by changing the following tokens:\n+block|,\n+block|{\n+name|BT_HCI_OP_LE_READ_MAX_ADV_DATA_LEN\n+block|,\n+sizeof|sizeof\n+argument_list|(\n+expr|struct\n+name|bt_hci_rp_le_read_max_adv_data_len\n+argument_list|)\n+block|,\n+name|generic_success\n+block|}\nThe issue was with: Bluetooth: Test: Update `hci_prop_evt`\n\nAccept LE Read Max Advertising Data Length command during HCI\ninitialization."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Host: Document bt_le_scan_update()\n\nThis function is used in many places, but just by reading its\nname it is not obvious why it is needed.\nBy adding some documentation it will hopefully become a bit more\nclear that this function is mainly used for auto connection\nestablishment. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/* k_poll event tags */\nend_comment\n\nbegin_enum\nDECL|enum|__anon2781d7060103\nenum|enum\nblock|{\nDECL|enumerator|BT_EVENT_CMD_TX\nname|BT_EVENT_CMD_TX\nblock|,\nbegin_comment\ncomment|/* bt_dev flags: the flags defined here represent BT controller state */\nend_comment\n\nbegin_enum\nDECL|enum|__anon2781d7060203\nenum|enum\nblock|{\nDECL|enumerator|BT_DEV_ENABLE\nname|BT_DEV_ENABLE\nblock|,\nendif|#\ndirective|endif\nend_endif\n\nbegin_enum\nDECL|enum|__anon2781d7060303\nenum|enum\nblock|{\ncomment|/* Advertising set has been created in the host. */\nDECL|enumerator|BT_ADV_CREATED\nname|BT_ADV_CREATED\nblock|}\nstruct|;\nend_struct\n\nbegin_enum\nDECL|enum|__anon2781d7060403\nenum|enum\nblock|{\ncomment|/** Periodic Advertising Sync has been created in the host. */\nDECL|enumerator|BT_PER_ADV_SYNC_CREATED\nname|BT_PER_ADV_SYNC_CREATED\nname|CONFIG_BT_EXT_ADV_MAX_ADV_SET\noperator|>\nliteral|1\noperator|)\ncomment|/* When supporting multiple concurrent connectable advertising sets \t * with multiple identities, we need to know the identity of \t * the terminating advertising set to identify the connection object. \t * The identity of the advertising set is determined by its \t * advertising handle, which is part of the \t * LE Set Advertising Set Terminated event which is always sent \t * _after_ the LE Enhanced Connection complete event. \t * Therefore we need cache this event until its identity is known. \t */\nDECL|struct|__anon2781d7060508\nstruct|struct\nblock|{\nDECL|member|valid\nname|bool\nname|valid\nname|hci_cte_type\nparameter_list|)\nfunction_decl|;\nend_function_decl\n\nbegin_function_decl\nname|int\nname|bt_le_scan_update\nparameter_list|(\nname|bool\ndecl_stmt|;\nDECL|member|sid\nname|uint8_t\nname|sid\ndecl_stmt|;\nDECL|enum|__anon29beb4dc0103\nenum|enum\nblock|{\nDECL|enumerator|FRAG_ADV_INACTIVE\nname|FRAG_ADV_INACTIVE\nblock|,\nargument_list|,\nname|BT_DEV_EXPLICIT_SCAN\nargument_list|)\ncondition|)\nblock|{\nreturn|return\nliteral|0\nreturn|;\nblock|}\nif|if\nname|bt_conn_unref\nargument_list|(\nname|conn\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|start_passive_scan\nargument_list|(\nname|fast_scan\nargument_list|)\ncondition|(\nname|get_pending_per_adv_sync\nargument_list|()\ncondition|)\nblock|{\nreturn|return\nname|start_passive_scan\nargument_list|(\nname|fast_scan\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon2781d7060103\n+DECL|enum|__anon2876e8b20103\n-DECL|enum|__anon2781d7060203\n+DECL|enum|__anon2876e8b20203\n-DECL|enum|__anon2781d7060303\n+DECL|enum|__anon2876e8b20303\n-DECL|enum|__anon2781d7060403\n+DECL|enum|__anon2876e8b20403\n-DECL|struct|__anon2781d7060508\n+DECL|struct|__anon2876e8b20508\n+begin_comment\n+comment|/** Start or restart scanner if needed  *  * Examples of cases where it may be required to start/restart a scanner:  * - When the auto-connection establishement feature is used:  *   - When the host sets a connection context for auto-connection establishment.  *   - When a connection was established.  *     The host may now be able to retry to automatically set up a connection.  *   - When a connection was disconnected/lost.  *     The host may now be able to retry to automatically set up a connection.  *   - When the application stops explicit scanning.  *     The host may now be able to retry to automatically set up a connection.  *   - The application tries to connect to another device, but fails.  *     The host may now be able to retry to automatically set up a connection.  * - When the application wants to connect to a device, but we need  *   to fallback to host privacy.  * - When the application wants to establish a periodic sync to a device  *   and the application has not already started scanning.  *  * @param fast_scan Use fast scan parameters or slow scan parameters  *  * @return 0 in case of success, or a negative error code on failure.  */\n+end_comment\n+\n-DECL|enum|__anon29beb4dc0103\n+DECL|enum|__anon2893f8540103\n+comment|/* The application has already explicitly started scanning. \t\t * We should keep the scanner running to avoid changing scan parameters. \t\t */\n+comment|/* Start/Restart the scanner */\n+comment|/* Start/Restart the scanner. */\nThe issue was with: Bluetooth: Host: Document bt_le_scan_update()\n\nThis function is used in many places, but just by reading its\nname it is not obvious why it is needed.\nBy adding some documentation it will hopefully become a bit more\nclear that this function is mainly used for auto connection\nestablishment."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: shell: Fix incorrect check for error return\n\nThis line was clearly intended to check for the value returned by\nad_init(). The ad_len is unsigned, so checking for a negative value\nshowed up in a recent Coverity run (no GitHub issue for it yet). Please fix this issue.",
  "input": "Faulty tokenized code:\nname|CONFIG_BT_BROADCASTER\nargument_list|)\nend_if\n\nbegin_enum\nDECL|enum|__anon2a44ebbe0103\nenum|enum\nblock|{\nDECL|enumerator|SHELL_ADV_OPT_CONNECTABLE\nname|SHELL_ADV_OPT_CONNECTABLE\nblock|,\nname|adv_opt\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|ad_len\noperator|<\nliteral|0\ncondition|)\nblock|{\nreturn|return",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon2a44ebbe0103\n+DECL|enum|__anon275597210103\n-name|ad_len\n+name|err\nThe issue was with: Bluetooth: shell: Fix incorrect check for error return\n\nThis line was clearly intended to check for the value returned by\nad_init(). The ad_len is unsigned, so checking for a negative value\nshowed up in a recent Coverity run (no GitHub issue for it yet)."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: Remove duplicate execution_cycles write and improve docstring\n\nThere is a duplicate write in `z_sched_thread_usage()` that can be\nremoved. Also modified the docstrings to `k_thread_runtime_stats` to\nhelp better describe the differences between execution_cycles and\ntotal_cycles when getting stats for the CPU or a thread Please fix this issue.",
  "input": "Faulty tokenized code:\nDECL|struct|_thread_base\nstruct|struct\nname|_thread_base\nblock|{\ncomment|/* this thread's entry in a ready/wait queue */\nDECL|union|__anon2b6169a3010a\nunion|union\nblock|{\nDECL|member|qnode_dlist\nname|sys_dnode_t\nname|qnode_dlist\nDECL|member|thread_state\nname|uint8_t\nname|thread_state\ndecl_stmt|;\ncomment|/* \t * scheduler lock count and thread priority \t * \t * These two fields control the preemptibility of a thread. \t * \t * When the scheduler is locked, sched_locked is decremented, which \t * means that the scheduler is locked for values from 0xff to 0x01. A \t * thread is coop if its prio is negative, thus 0x80 to 0xff when \t * looked at the value as unsigned. \t * \t * By putting them end-to-end, this means that a thread is \t * non-preemptible if the bundled value is greater than or equal to \t * 0x0080. \t */\nDECL|union|__anon2b6169a3020a\nunion|union\nblock|{\nDECL|struct|__anon2b6169a30308\nstruct|struct\nblock|{\nifdef|#\ndirective|ifdef\nname|CONFIG_BIG_ENDIAN\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_THREAD_STACK_MEM_MAPPED\nargument_list|)\nDECL|struct|__anon2b6169a30408\nstruct|struct\nblock|{\ncomment|/** Base address of the memory mapped thread stack */\nDECL|member|addr\nname|k_thread_stack_t\nname|k_thread_runtime_stats\nblock|{\nifdef|#\ndirective|ifdef\nname|CONFIG_SCHED_THREAD_USAGE\nDECL|member|execution_cycles\nname|uint64_t\nname|execution_cycles\ndecl_stmt|;\nDECL|member|total_cycles\nname|uint64_t\nname|total_cycles\ndecl_stmt|;\ncomment|/* total # of non-idle cycles */\ncomment|/* \t * In the context of thread statistics, [execution_cycles] is the same \t * as the total # of non-idle cycles. In the context of CPU statistics, \t * it refers to the sum of non-idle + idle cycles. \t */\nendif|#\ndirective|endif\ncomment|/* CONFIG_SCHED_THREAD_USAGE */\nifdef|#\ndirective|ifdef\nliteral|0\nexpr_stmt|;\nendif|#\ndirective|endif\ncomment|/* CONFIG_SCHED_THREAD_USAGE_ALL */\nname|stats\noperator|->\nname|execution_cycles\noperator|=\nname|thread\noperator|->\nname|base\noperator|.\nname|usage\noperator|.\nname|total\nexpr_stmt|;\nname|k_spin_unlock\nargument_list|(\noperator|&\nname|usage_lock\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon2b6169a3010a\n+DECL|union|__anon27ce8e88010a\n-DECL|union|__anon2b6169a3020a\n+DECL|union|__anon27ce8e88020a\n-DECL|struct|__anon2b6169a30308\n+DECL|struct|__anon27ce8e880308\n-DECL|struct|__anon2b6169a30408\n+DECL|struct|__anon27ce8e880408\n+comment|/* \t * For CPU stats, execution_cycles is the sum of non-idle + idle cycles. \t * For thread stats, execution_cycles = total_cycles. \t */\n+comment|/* total # of cycles (cpu: non-idle + idle) */\n-comment|/* \t * In the context of thread statistics, [execution_cycles] is the same \t * as the total # of non-idle cycles. In the context of CPU statistics, \t * it refers to the sum of non-idle + idle cycles. \t */\n-name|stats\n-operator|->\n-name|execution_cycles\n-operator|=\n-name|thread\n-operator|->\n-name|base\n-operator|.\n-name|usage\n-operator|.\n-name|total\n-expr_stmt|;\nThe issue was with: kernel: Remove duplicate execution_cycles write and improve docstring\n\nThere is a duplicate write in `z_sched_thread_usage()` that can be\nremoved. Also modified the docstrings to `k_thread_runtime_stats` to\nhelp better describe the differences between execution_cycles and\ntotal_cycles when getting stats for the CPU or a thread"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: cache: nrf: Use CONFIG_DCACHE_LINE_SIZE\n\nUse Kconfig instead of fixed value in the driver code. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_endif\nendif|#\ndirective|endif\nend_endif\n\nbegin_define\nDECL|macro|CACHE_LINE_SIZE\ndefine|#\ndirective|define\nname|CACHE_LINE_SIZE\nvalue|32\nend_define\n\nbegin_define\nDECL|macro|CACHE_BUSY_RETRY_INTERVAL_US\ndefine|#\ndirective|define\nname|CACHE_BUSY_RETRY_INTERVAL_US\ncomment|/* \t * Align address to line size \t */\nname|line_addr\noperator|&=\noperator|~\noperator|(\nname|CACHE_LINE_SIZE\noperator|-\nliteral|1\noperator|)\nexpr_stmt|;\ndo|do\nname|line_addr\nargument_list|)\nexpr_stmt|;\nname|line_addr\noperator|+=\nname|CACHE_LINE_SIZE\nexpr_stmt|;\nblock|}\ndo|while\ncondition|(\nname|line_addr",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_define\n-DECL|macro|CACHE_LINE_SIZE\n-define|#\n-directive|define\n-name|CACHE_LINE_SIZE\n-value|32\n-end_define\n-\n-name|CACHE_LINE_SIZE\n+name|CONFIG_DCACHE_LINE_SIZE\n-name|CACHE_LINE_SIZE\n+name|CONFIG_DCACHE_LINE_SIZE\nThe issue was with: drivers: cache: nrf: Use CONFIG_DCACHE_LINE_SIZE\n\nUse Kconfig instead of fixed value in the driver code."
},{
  "instruction": "There is an issue in the following code. It relates to xtensa: mmu: Avoid unnecessary mapping\n\nWhen duplicating a page table, we don't need to copy\nthe mapping to the kernel l1 page table virtual address. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|source_table\nindex|[\nname|i\nindex|]\nargument_list|)\ncondition|)\nblock|{\nname|dst_table\nindex|[\nname|i",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|||\n+operator|(\n+name|i\n+operator|==\n+name|XTENSA_MMU_L1_POS\n+argument_list|(\n+name|XTENSA_MMU_PTEVADDR\n+argument_list|)\n+operator|)\nThe issue was with: xtensa: mmu: Avoid unnecessary mapping\n\nWhen duplicating a page table, we don't need to copy\nthe mapping to the kernel l1 page table virtual address."
},{
  "instruction": "There is an issue in the following code. It relates to soc: nxp: rw: Fix error if PMU reset not specified\n\nDon't build error if the reset causes is not specified on\nthe PMU node. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|kPOWER_ResetSourceWdt\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\nDECL|macro|PMU_RESET_CAUSES_\ndefine|#\ndirective|define\nname|PMU_RESET_CAUSES_\ndefine|\\\ndefine|#\ndirective|define\nname|RESET_CAUSES\ndefine|\\\nvalue|(PMU_RESET_CAUSES | WDT_RESET)\nname|POWER_EnableResetSource\nargument_list|(\nname|RESET_CAUSES\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|#\n+directive|if\n+name|DT_NODE_HAS_PROP\n+argument_list|(\n+name|DT_NODELABEL\n+argument_list|(\n+name|pmu\n+argument_list|)\n+operator|,\n+name|reset_causes_en\n+argument_list|)\n+else|#\n+directive|else\n+DECL|macro|RESET_CAUSES\n+define|#\n+directive|define\n+name|RESET_CAUSES\n+value|0\n+endif|#\n+directive|endif\nThe issue was with: soc: nxp: rw: Fix error if PMU reset not specified\n\nDon't build error if the reset causes is not specified on\nthe PMU node."
},{
  "instruction": "There is an issue in the following code. It relates to driver: uart: npcx: fix coding style\n\nFix the coding style by clang-format tool. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|uart_npcx_rx_fifo_available\nargument_list|(\nname|dev\nargument_list|)\ncondition|)\nname|scratch\noperator|=\nname|inst\noperator|->\nname|URBUF\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|uart_npcx_fifo_fill (const struct device * dev,const uint8_t * tx_data,int size)\nspecifier|static\nname|c\nargument_list|,\nliteral|1\nargument_list|)\ncondition|)\ncontinue|continue;\nblock|}\nend_function\n\nbegin_else\nelse|#\ndirective|else\nname|UICTRL\nargument_list|,\nname|NPCX_UICTRL_RBF\nargument_list|)\ncondition|)\nreturn|return\noperator|-\nliteral|1\nreturn|;\noperator|*\nname|c\noperator|=\nname|inst\noperator|->\nname|UICTRL\nargument_list|,\nname|NPCX_UICTRL_TBE\nargument_list|)\ncondition|)\ncontinue|continue;\nname|inst\noperator|->\nname|UTBUF\noperator|=\nname|c\nname|stat\nargument_list|,\nname|NPCX_USTAT_DOE\nargument_list|)\ncondition|)\nname|err\noperator||=\nname|UART_ERROR_OVERRUN\nexpr_stmt|;\nif|if\ncondition|(\nname|IS_BIT_SET\nargument_list|(\nname|stat\nargument_list|,\nname|NPCX_USTAT_PE\nargument_list|)\ncondition|)\nname|err\noperator||=\nname|UART_ERROR_PARITY\nexpr_stmt|;\nif|if\ncondition|(\nname|IS_BIT_SET\nargument_list|(\nname|stat\nargument_list|,\nname|NPCX_USTAT_FE\nargument_list|)\ncondition|)\nname|err\noperator||=\nname|UART_ERROR_FRAMING\nexpr_stmt|;\nreturn|return\nname|err\nreturn|;\nblock|}\nend_function\nname|NPCX_UART_INIT\nparameter_list|(\nname|i\nparameter_list|)\ndefine|\\\nvalue|NPCX_UART_IRQ_CONFIG_FUNC_DECL(i);                                                      \\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tPINCTRL_DT_INST_DEFINE(i);                                                              \\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct uart_npcx_config uart_npcx_cfg_##i = {                              \\ \t\t.inst = (struct uart_reg *)DT_INST_REG_ADDR(i),                                 \\ \t\t.clk_cfg = NPCX_DT_CLK_CFG_ITEM(i),                                             \\ \t\t.uart_rx_wui = NPCX_DT_WUI_ITEM_BY_NAME(0, uart_rx),                            \\ \t\t.pcfg = PINCTRL_DT_INST_DEV_CONFIG_GET(i),                                      \\ \t\tNPCX_UART_IRQ_CONFIG_FUNC_INIT(i)                                               \\ \t};                                                                                      \\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct uart_npcx_data uart_npcx_data_##i = { .baud_rate = DT_INST_PROP(          \\ \t\t\t\t\t\t\t\t       i, current_speed) };     \\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(i,&uart_npcx_init, NULL,&uart_npcx_data_##i,                    \\&uart_npcx_cfg_##i, PRE_KERNEL_1, CONFIG_SERIAL_INIT_PRIORITY,    \\&uart_npcx_driver_api);                                           \\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tNPCX_UART_IRQ_CONFIG_FUNC(i)\nend_define\n\nbegin_macro\nDECL|function|DT_INST_FOREACH_STATUS_OKAY (NPCX_UART_INIT)\nname|DT_INST_FOREACH_STATUS_OKAY\nname|ENABLE_MIWU_CRIN_IRQ\nparameter_list|(\nname|i\nparameter_list|)\ndefine|\\\nvalue|npcx_miwu_irq_get_and_clear_pending(&uart_npcx_cfg_##i.uart_rx_wui);                    \\ \tnpcx_miwu_irq_enable(&uart_npcx_cfg_##i.uart_rx_wui);\nend_define\n\nbegin_define\nDECL|macro|DISABLE_MIWU_CRIN_IRQ (i)\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n+block|{\n+block|}\n+block|{\n+block|}\n+block|{\n+block|}\n+block|{\n+block|}\n+block|{\n+block|}\n+block|{\n+block|}\n+block|{\n+block|}\n-value|NPCX_UART_IRQ_CONFIG_FUNC_DECL(i);                                                      \\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tPINCTRL_DT_INST_DEFINE(i);                                                              \\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct uart_npcx_config uart_npcx_cfg_##i = {                              \\ \t\t.inst = (struct uart_reg *)DT_INST_REG_ADDR(i),                                 \\ \t\t.clk_cfg = NPCX_DT_CLK_CFG_ITEM(i),                                             \\ \t\t.uart_rx_wui = NPCX_DT_WUI_ITEM_BY_NAME(0, uart_rx),                            \\ \t\t.pcfg = PINCTRL_DT_INST_DEV_CONFIG_GET(i),                                      \\ \t\tNPCX_UART_IRQ_CONFIG_FUNC_INIT(i)                                               \\ \t};                                                                                      \\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct uart_npcx_data uart_npcx_data_##i = { .baud_rate = DT_INST_PROP(          \\ \t\t\t\t\t\t\t\t       i, current_speed) };     \\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(i,&uart_npcx_init, NULL,&uart_npcx_data_##i,                    \\&uart_npcx_cfg_##i, PRE_KERNEL_1, CONFIG_SERIAL_INIT_PRIORITY,    \\&uart_npcx_driver_api);                                           \\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tNPCX_UART_IRQ_CONFIG_FUNC(i)\n+value|NPCX_UART_IRQ_CONFIG_FUNC_DECL(i);                                                         \\                                                                                                    \\ \tPINCTRL_DT_INST_DEFINE(i);                                                                 \\                                                                                                    \\ \tstatic const struct uart_npcx_config uart_npcx_cfg_##i = {                                 \\ \t\t.inst = (struct uart_reg *)DT_INST_REG_ADDR(i),                                    \\ \t\t.clk_cfg = NPCX_DT_CLK_CFG_ITEM(i),                                                \\ \t\t.uart_rx_wui = NPCX_DT_WUI_ITEM_BY_NAME(0, uart_rx),                               \\ \t\t.pcfg = PINCTRL_DT_INST_DEV_CONFIG_GET(i),                                         \\ \t\tNPCX_UART_IRQ_CONFIG_FUNC_INIT(i)};                                                \\                                                                                                    \\ \tstatic struct uart_npcx_data uart_npcx_data_##i = {                                        \\ \t\t.baud_rate = DT_INST_PROP(i, current_speed)};                                      \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(i,&uart_npcx_init, NULL,&uart_npcx_data_##i,&uart_npcx_cfg_##i,   \\ \t\t\t      PRE_KERNEL_1, CONFIG_SERIAL_INIT_PRIORITY,&uart_npcx_driver_api);   \\                                                                                                    \\ \tNPCX_UART_IRQ_CONFIG_FUNC(i)\n-value|npcx_miwu_irq_get_and_clear_pending(&uart_npcx_cfg_##i.uart_rx_wui);                    \\ \tnpcx_miwu_irq_enable(&uart_npcx_cfg_##i.uart_rx_wui);\n+value|npcx_miwu_irq_get_and_clear_pending(&uart_npcx_cfg_##i.uart_rx_wui);                       \\ \tnpcx_miwu_irq_enable(&uart_npcx_cfg_##i.uart_rx_wui);\nThe issue was with: driver: uart: npcx: fix coding style\n\nFix the coding style by clang-format tool."
},{
  "instruction": "There is an issue in the following code. It relates to logging: fix backend index caluculation\n\nBackend index must also be incremented, when backend is not an autostart\nbackend. Otherwise, the resulting bit field can not be used to address\na backend by index; autostart field would have to be taken into account. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nreturn|return\nliteral|0\nreturn|;\nblock|}\nname|int\nname|i\ninit|=\nliteral|0\ndecl_stmt|;\nif|if\ncondition|(\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_LOG_MULTIDOMAIN\nblock|{\nname|z_log_links_initiate\nargument_list|()\nexpr_stmt|;\nblock|}\ncomment|/* Assign ids to backends. */\nname|STRUCT_SECTION_FOREACH\nargument_list|(\nargument|log_backend\nargument_list|,\nargument|backend\nblock|{\nname|mask\noperator||=\nname|BIT\nargument_list|(\nname|i\nargument_list|)\nexpr_stmt|;\nblock|}\nname|i\noperator|++\nexpr_stmt|;\nblock|}\nblock|}\ncomment|/* If blocking init, wait until all backends are activated. */\nif|if\ncondition|(\nname|blocking\ncondition|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|int\n-name|i\n-init|=\n-literal|0\n-decl_stmt|;\n-comment|/* Assign ids to backends. */\n+name|int\n+name|backend_index\n+init|=\n+literal|0\n+decl_stmt|;\n+comment|/* Activate autostart backends */\n-name|i\n+name|backend_index\n-name|i\n+block|}\n+name|backend_index\n-block|}\nThe issue was with: logging: fix backend index caluculation\n\nBackend index must also be incremented, when backend is not an autostart\nbackend. Otherwise, the resulting bit field can not be used to address\na backend by index; autostart field would have to be taken into account."
},{
  "instruction": "There is an issue in the following code. It relates to regulator: cp9314: Tidies regulator enable conditional\n\nEnables the converter via I2C as the else case when the EN pin\nconditional fails. This used to not matter as no code followed,\nbut this will change in subsequent patches. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nliteral|1\nargument_list|)\nreturn|;\nblock|}\nname|ret\noperator|=\nname|i2c_reg_update_byte_dt\nargument_list|(\noperator|&\nexpr_stmt|;\nreturn|return\nname|ret\nreturn|;\nblock|}\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+else|else\n+block|{\n+block|}\nThe issue was with: regulator: cp9314: Tidies regulator enable conditional\n\nEnables the converter via I2C as the else case when the EN pin\nconditional fails. This used to not matter as no code followed,\nbut this will change in subsequent patches."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: Ignore failure to Broadcast ISO remove data path\n\nIgnore failure to Broadcast ISO remove data path when\nterminating a BIG without a data path being setup. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|LL_BIS_ADV_HANDLE_FROM_IDX\nargument_list|(\nname|stream_handle\nargument_list|)\nexpr_stmt|;\nname|err\noperator|=\nname|ll_remove_iso_path\nargument_list|(\nname|handle\nargument_list|,\nname|BIT\nargument_list|(\nname|BT_HCI_DATAPATH_DIR_HOST_TO_CTLR\nargument_list|)\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|err\ncondition|)\nblock|{\nreturn|return\nname|err\nreturn|;\nblock|}\nblock|}\nname|lll_adv_sync\noperator|=\nname|lll_adv\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|err\n-operator|=\n+operator|(\n+name|void\n+operator|)\n-if|if\n-condition|(\n-name|err\n-condition|)\n-block|{\n-return|return\n-name|err\n-return|;\n-block|}\nThe issue was with: Bluetooth: Controller: Ignore failure to Broadcast ISO remove data path\n\nIgnore failure to Broadcast ISO remove data path when\nterminating a BIG without a data path being setup."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: Increase ull_sched ticker_next_slot_get retries\n\nIncrease retries for ull_sched use of ticker_next_slot_get. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|EVENT_TICKER_RES_MARGIN_US\noperator|<<\nliteral|2\nargument_list|)\nexpr_stmt|;\ncomment|/* There is a possibility that ticker nodes expire during iterations in \t * this function causing the reference ticks_anchor returned for the \t * found ticker to change. In this case the iterations have to be \t * restarted with the new reference ticks_anchor value. \t * Simultaneous continuous scanning on 1M and Coded PHY, alongwith \t * directed advertising and one other state/role could expire in quick \t * succession, hence have a retry count of 4. \t */\nname|retry\noperator|=\nliteral|4U\nexpr_stmt|;\ncomment|/* Initialize variable required for iterations to find a free slot */\nname|ticker_id\noperator|=\nname|ticker_id_prev",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* There is a possibility that ticker nodes expire during iterations in \t * this function causing the reference ticks_anchor returned for the \t * found ticker to change. In this case the iterations have to be \t * restarted with the new reference ticks_anchor value. \t * Simultaneous continuous scanning on 1M and Coded PHY, alongwith \t * directed advertising and one other state/role could expire in quick \t * succession, hence have a retry count of 4. \t */\n+comment|/* There is a possibility that ticker nodes expire during iterations in \t * this function causing the reference ticks_anchor returned for the \t * found ticker to change. In this case the iterations have to be \t * restarted with the new reference ticks_anchor value. \t * Simultaneous continuous scanning on 1M and Coded PHY, alongwith \t * directed advertising and N other state/role could expire in quick \t * succession, hence have a retry count of UINT8_MAX, which is possible \t * maximum implementation limit for ticker nodes. \t */\n-literal|4U\n+name|UINT8_MAX\nThe issue was with: Bluetooth: Controller: Increase ull_sched ticker_next_slot_get retries\n\nIncrease retries for ull_sched use of ticker_next_slot_get."
},{
  "instruction": "There is an issue in the following code. It relates to Revert \\\"kernel/sched: Fix lockless ordering in halt_thread()\\\"\n\nThis reverts commit 060f2bdef8ff6fd25524a8b736f653e64eeb68fa [formerly 02b24911f770037ed6edd50b315a9d2189079044].\n\nThis PR introduced 2 regressions in main CI:\n71977 & 71978\nLet's revert it by now to get main's CI passing again. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|k_thread\nmodifier|*\nname|thread\nparameter_list|)\nblock|{\nname|barrier_dmem_fence_full\nargument_list|()\nexpr_stmt|;\ncomment|/* Other cpus spin on this locklessly! */\nname|thread\noperator|->\nname|base\noperator|.\nname|thread_state\noperator|.\nname|thread_state\noperator||=\nname|new_state\nexpr_stmt|;\nif|if\ncondition|(\nname|z_is_thread_queued\nargument_list|(\nname|thread\nname|new_state\noperator|==\nname|_THREAD_SUSPENDED\ncondition|)\nblock|{\nname|clear_halting\nargument_list|(\nname|thread\nargument_list|)\nexpr_stmt|;\nreturn|return;\nblock|}\nif|#\ndirective|if\nname|defined\noperator|&\nname|_thread_dummy\nargument_list|)\nexpr_stmt|;\nblock|}\ncomment|/* Finally update the halting thread state, on which \t\t * other CPUs might be spinning (see \t\t * thread_halt_spin()). \t\t */\nname|clear_halting\nargument_list|(\nname|thread\nargument_list|)\nexpr_stmt|;\nblock|}\nblock|}\nend_function\n\nbegin_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|barrier_dmem_fence_full\n-argument_list|()\n-expr_stmt|;\n-comment|/* Other cpus spin on this locklessly! */\n+name|clear_halting\n+argument_list|(\n+name|thread\n+argument_list|)\n+expr_stmt|;\n-name|clear_halting\n-argument_list|(\n-name|thread\n-argument_list|)\n-expr_stmt|;\n-comment|/* Finally update the halting thread state, on which \t\t * other CPUs might be spinning (see \t\t * thread_halt_spin()). \t\t */\n-name|clear_halting\n-argument_list|(\n-name|thread\n-argument_list|)\n-expr_stmt|;\nThe issue was with: Revert \\\"kernel/sched: Fix lockless ordering in halt_thread()\\\"\n\nThis reverts commit 060f2bdef8ff6fd25524a8b736f653e64eeb68fa [formerly 02b24911f770037ed6edd50b315a9d2189079044].\n\nThis PR introduced 2 regressions in main CI:\n71977 & 71978\nLet's revert it by now to get main's CI passing again."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Samples: Dev name in AD instead of SD\n\nWith the deprecation of `BT_LE_ADV_OPT_USE_NAME` and\n`BT_LE_ADV_OPT_FORCE_NAME_IN_AD` samples were updated to not use the\nmacro adding the device name in the advertising/scan response data\nanymore.\n\nInstead the name was explicitly added to the scan response data in\n`periodic_adv` sample. But because it was using an extended advertiser\nand was already adding data in the AD, the name should have been put in\nthe advertising data and not the scan response data.\n\nUpdate the sample to add the device name in the advertising data. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\ndecl_stmt|;\nend_decl_stmt\n\nbegin_decl_stmt\nDECL|variable|ad\nspecifier|static\nspecifier|const\nname|struct\nname|bt_data\nname|ad\nindex|[]\ninit|=\nblock|{\nname|BT_DATA\nargument_list|(\nblock|, }\ndecl_stmt|;\nend_decl_stmt\n\nbegin_decl_stmt\nDECL|variable|sd\nspecifier|static\nspecifier|const\nname|struct\nname|bt_data\nname|sd\nindex|[]\ninit|=\nblock|{\nname|BT_DATA\nargument_list|(\noperator|=\nname|bt_le_ext_adv_set_data\nargument_list|(\nname|adv\nargument_list|,\nname|NULL\nargument_list|,\nliteral|0\nargument_list|,\nname|sd\nargument_list|,\nname|ARRAY_SIZE\nargument_list|(\nname|sd\nargument_list|)\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|err\noperator|=\nname|bt_le_per_adv_set_data\nargument_list|(\nname|adv\nargument_list|,\nname|ad\nargument_list|,\nname|ARRAY_SIZE\nargument_list|(\nname|ad\nargument_list|)\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|variable|ad\n+DECL|variable|per_adv_ad\n-name|ad\n+name|per_adv_ad\n-DECL|variable|sd\n+DECL|variable|ad\n-name|sd\n+name|ad\n-name|NULL\n-argument_list|,\n-literal|0\n-argument_list|,\n-name|sd\n+name|ad\n-name|sd\n+name|ad\n+argument_list|,\n+name|NULL\n+argument_list|,\n+literal|0\n-name|ad\n+name|per_adv_ad\n-name|ad\n+name|per_adv_ad\nThe issue was with: Bluetooth: Samples: Dev name in AD instead of SD\n\nWith the deprecation of `BT_LE_ADV_OPT_USE_NAME` and\n`BT_LE_ADV_OPT_FORCE_NAME_IN_AD` samples were updated to not use the\nmacro adding the device name in the advertising/scan response data\nanymore.\n\nInstead the name was explicitly added to the scan response data in\n`periodic_adv` sample. But because it was using an extended advertiser\nand was already adding data in the AD, the name should have been put in\nthe advertising data and not the scan response data.\n\nUpdate the sample to add the device name in the advertising data."
},{
  "instruction": "There is an issue in the following code. It relates to pm: policy: Fix event integer overflow\n\nIn the follow expression:\n\ncyc_evt += UINT32_MAX + 1U\n\nfirst it is evaluated (UINT32_MAX + 1U), since both types\ninterpreted as uint32_t, this operation causes an overflow resulting\nin 0U.Then we have\n\ncyc_evt = (uint64_t)cyc_evt + 0U\n\nFix it casting of the operands in the first operation to uint64_t. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/**  * State and substate lock structure.  *  * This struct is associating a reference counting to each<state,substate>  * couple to be used with the pm_policy_substate_lock_* functions.  *  * Operations on this array are in the order of O(n) with the number of power  * states and this is mostly due to the random nature of the substate value  * (that can be anything from a small integer value to a bitmask). We can  * probably do better with an hashmap.  */\nend_comment\n\nbegin_struct\nDECL|struct|__anon2ae55b880108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|state\nname|enum\nname|cyc\ncondition|)\nblock|{\nname|cyc_evt\noperator|+=\nname|UINT32_MAX\noperator|+\nliteral|1U\nexpr_stmt|;\nblock|}\nname|UINT32_MAX\ncondition|)\nblock|{\nname|new_next_event_cyc\noperator|-=\nname|UINT32_MAX\noperator|+\nliteral|1U\nexpr_stmt|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2ae55b880108\n+DECL|struct|__anon2c851b7a0108\n+operator|(\n+name|uint64_t\n+operator|)\n+operator|(\n+name|uint64_t\n+operator|)\nThe issue was with: pm: policy: Fix event integer overflow\n\nIn the follow expression:\n\ncyc_evt += UINT32_MAX + 1U\n\nfirst it is evaluated (UINT32_MAX + 1U), since both types\ninterpreted as uint32_t, this operation causes an overflow resulting\nin 0U.Then we have\n\ncyc_evt = (uint64_t)cyc_evt + 0U\n\nFix it casting of the operands in the first operation to uint64_t."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: system_work_q: Mark queue thread as essential\n\nMarking sysworkq as essential, so when it fails, the system will halt\ninstead of continuously working, and dependent components stay\nin a broken state. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|=\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_SYSTEM_WORKQUEUE_NO_YIELD\nargument_list|)\nblock|, \t}\ndecl_stmt|;\nname|k_work_queue_start\nargument_list|(\noperator|&",
  "result": "I corrected the issue in the code by changing the following tokens:\n+block|,\n+operator|.\n+name|essential\n+operator|=\n+name|true\nThe issue was with: kernel: system_work_q: Mark queue thread as essential\n\nMarking sysworkq as essential, so when it fails, the system will halt\ninstead of continuously working, and dependent components stay\nin a broken state."
},{
  "instruction": "There is an issue in the following code. It relates to soc: arm: smartbond: Enable cache retainability in sleep\n\nThis enables cache retainability while in sleep so there's no penalty\nwhen executing from QSPI after wakeup. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|PMU_CTRL_REG\noperator|&=\noperator|~\nname|CRG_TOP_PMU_CTRL_REG_SYS_SLEEP_Msk\nexpr_stmt|;\ncomment|/* \t *\tDue to crosstalk issues any power rail can potentially \t *\tissue a fake event. This is typically observed upon \t *\tswitching power sources, that is DCDC<--> LDOs<--> Retention LDOs. \t */\nname|CRG_TOP\noperator|->\nname|BOD_CTRL_REG\noperator|&=",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|#\n+directive|if\n+name|defined\n+argument_list|(\n+name|CONFIG_PM\n+argument_list|)\n+comment|/* Enable cache retainability */\n+name|CRG_TOP\n+operator|->\n+name|PMU_CTRL_REG\n+operator||=\n+name|CRG_TOP_PMU_CTRL_REG_RETAIN_CACHE_Msk\n+expr_stmt|;\n+endif|#\n+directive|endif\nThe issue was with: soc: arm: smartbond: Enable cache retainability in sleep\n\nThis enables cache retainability while in sleep so there's no penalty\nwhen executing from QSPI after wakeup."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: adc: tla2021: Fix reference voltage\n\nThis fixes the problem that `adc_raw_to_millivolts` only returns half of\nthe actual voltage. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|tla2021_read\nblock|,\noperator|.\nname|ref_internal\noperator|=\nliteral|2048\nblock|,\nifdef|#\ndirective|ifdef\nname|CONFIG_ADC_ASYNC\noperator|.",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|2048\n+literal|4096\nThe issue was with: drivers: adc: tla2021: Fix reference voltage\n\nThis fixes the problem that `adc_raw_to_millivolts` only returns half of\nthe actual voltage."
},{
  "instruction": "There is an issue in the following code. It relates to kernel/sched: Fix lockless ordering in halt_thread()\n\nWe've had threads spinning on the thread state bits, but weren't being\ncareful to ensure that those bits were the last things seen to change\nin a halting thread.  Move it to the end, and add a barrier for\ncorrectness. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|k_thread\nmodifier|*\nname|thread\nparameter_list|)\nblock|{\nname|thread\noperator|->\nname|base\noperator|.\nname|thread_state\noperator|.\nname|thread_state\noperator||=\nname|new_state\nexpr_stmt|;\nname|clear_halting\nargument_list|(\nname|thread\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|z_is_thread_queued\nargument_list|(\nname|thread\nname|new_state\noperator|==\nname|_THREAD_SUSPENDED\ncondition|)\nblock|{\nreturn|return;\nblock|}\nif|#\ndirective|if\nname|defined\noperator|&\nname|_thread_dummy\nargument_list|)\nexpr_stmt|;\nblock|}\nblock|}\nblock|}\nend_function\n\nbegin_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|barrier_dmem_fence_full\n+argument_list|()\n+expr_stmt|;\n+comment|/* Other cpus spin on this locklessly! */\n-name|clear_halting\n-argument_list|(\n-name|thread\n-argument_list|)\n-expr_stmt|;\n+name|clear_halting\n+argument_list|(\n+name|thread\n+argument_list|)\n+expr_stmt|;\n+comment|/* Finally update the halting thread state, on which \t\t * other CPUs might be spinning (see \t\t * thread_halt_spin()). \t\t */\n+name|clear_halting\n+argument_list|(\n+name|thread\n+argument_list|)\n+expr_stmt|;\nThe issue was with: kernel/sched: Fix lockless ordering in halt_thread()\n\nWe've had threads spinning on the thread state bits, but weren't being\ncareful to ensure that those bits were the last things seen to change\nin a halting thread.  Move it to the end, and add a barrier for\ncorrectness."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Rename `num_complete_pool` -> `sync_evt_pool`\n\nRefactor only. The surrounding ifdefs are intentionally not changed in\nthis patch. They will be in the near future.\n\nRename the pool and generalize the documentation to allow using this\npool for other events that fit the same criteria. This pool can be used\nfor any buffer that is processed synchronously, without negatively\naffecting 'num complete' messages. E.g. 'cmd complete/status' can be put\nin this pool already.\n\nWe will be working towards making the host process all event buffers\nsynchronously. This is because events have no dedicated flow control,\nand discarding events in the driver without informing the host creates\nproblems. Discarding should instead happen in the host higher layers\nwhen unavoidable. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|NUM_COMLETE_EVENT_SIZE\nvalue|BT_BUF_EVT_SIZE(                        \\ \tsizeof(struct bt_hci_cp_host_num_completed_packets) +          \\ \tMAX_EVENT_COUNT * sizeof(struct bt_hci_handle_count))\nend_define\n\nbegin_comment\ncomment|/* Dedicated pool for HCI_Number_of_Completed_Packets. This event is always  * consumed synchronously by bt_recv_prio() so a single buffer is enough.  * Having a dedicated pool for it ensures that exhaustion of the RX pool  * cannot block the delivery of this priority event.  */\nend_comment\n\nbegin_expr_stmt\nname|NET_BUF_POOL_FIXED_DEFINE\nargument_list|(\nname|num_complete_pool\nargument_list|,\nliteral|1\nargument_list|,\nname|NUM_COMLETE_EVENT_SIZE\nargument_list|,\nsizeof|sizeof\nargument_list|(\nexpr|struct\nname|bt_buf_data\nname|buf\noperator|=\nname|net_buf_alloc\nargument_list|(\noperator|&\nname|num_complete_pool\nargument_list|,\nname|timeout\nargument_list|)\nexpr_stmt|;\nbreak|break;\nname|void\nparameter_list|)\nblock|{\nreturn|return\noperator|&\nname|num_complete_pool\nreturn|;\nblock|}\nend_function\n\nbegin_endif",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* Dedicated pool for HCI_Number_of_Completed_Packets. This event is always  * consumed synchronously by bt_recv_prio() so a single buffer is enough.  * Having a dedicated pool for it ensures that exhaustion of the RX pool  * cannot block the delivery of this priority event.  */\n+comment|/* Pool for RX HCI buffers that are always freed by `bt_recv`  * before it returns.  *  * A singleton buffer shall be sufficient for correct operation.  * The buffer count may be increased as an optimization to allow  * the HCI transport to fill buffers in parallel with `bt_recv`  * consuming them.  */\n+begin_define\n+DECL|macro|SYNC_EVT_SIZE\n+define|#\n+directive|define\n+name|SYNC_EVT_SIZE\n+value|NUM_COMLETE_EVENT_SIZE\n+end_define\n+\n-name|num_complete_pool\n+name|sync_evt_pool\n-name|NUM_COMLETE_EVENT_SIZE\n+name|SYNC_EVT_SIZE\n-name|num_complete_pool\n+name|sync_evt_pool\n-name|num_complete_pool\n+name|sync_evt_pool\nThe issue was with: Bluetooth: Rename `num_complete_pool` -> `sync_evt_pool`\n\nRefactor only. The surrounding ifdefs are intentionally not changed in\nthis patch. They will be in the near future.\n\nRename the pool and generalize the documentation to allow using this\npool for other events that fit the same criteria. This pool can be used\nfor any buffer that is processed synchronously, without negatively\naffecting 'num complete' messages. E.g. 'cmd complete/status' can be put\nin this pool already.\n\nWe will be working towards making the host process all event buffers\nsynchronously. This is because events have no dedicated flow control,\nand discarding events in the driver without informing the host creates\nproblems. Discarding should instead happen in the host higher layers\nwhen unavoidable."
},{
  "instruction": "There is an issue in the following code. It relates to arch: riscv: irq_manage: support ISR_OFFSET in dynamic IRQs\n\n`CONFIG_RISCV_RESERVED_IRQ_ISR_TABLES_OFFSET` shoud be taken into\naccount in `arch_irq_connect_dynamic`, same as it is done in\n`ARCH_IRQ_CONNECT` macro. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|)\nblock|{\nname|z_isr_install\nargument_list|(\nname|irq\nargument_list|,\nname|routine\nargument_list|,\nname|parameter\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|+\n+name|CONFIG_RISCV_RESERVED_IRQ_ISR_TABLES_OFFSET\nThe issue was with: arch: riscv: irq_manage: support ISR_OFFSET in dynamic IRQs\n\n`CONFIG_RISCV_RESERVED_IRQ_ISR_TABLES_OFFSET` shoud be taken into\naccount in `arch_irq_connect_dynamic`, same as it is done in\n`ARCH_IRQ_CONNECT` macro."
},{
  "instruction": "There is an issue in the following code. It relates to soc: nordic: nrf54h: Add DCACHE initialization\n\nAdd initialization of the data cache. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|)\nblock|{\nname|sys_cache_instr_enable\nargument_list|()\nexpr_stmt|;\nname|power_domain_init\nargument_list|()\nexpr_stmt|;\nname|trim_hsfll\nargument_list|()",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|sys_cache_data_enable\n+argument_list|()\n+expr_stmt|;\nThe issue was with: soc: nordic: nrf54h: Add DCACHE initialization\n\nAdd initialization of the data cache."
},{
  "instruction": "There is an issue in the following code. It relates to soc: nordic: nrf54h: Remove redundant ICACHE kconfig\n\nRemove CONFIG_NRF_ENABLE_ICACHE as it is not needed. There is CONFIG_ICACHE\nwhich is by default enabled for nrf54h. Please fix this issue.",
  "input": "Faulty tokenized code:\n\tselect CPU_HAS_FPU\n\tselect HAS_SEGGER_RTT if ZEPHYR_SEGGER_MODULE\n\nconfig SOC_NRF54H20_CPUPPR\n\tdepends on RISCV_CORE_NORDIC_VPR\n\nif SOC_NRF54H20\n\nconfig NRF_ENABLE_ICACHE\n\tbool \"Instruction cache (I-Cache)\"\n\tdefault y\n\nendif # SOC_NRF54H20\nname|nordicsemi_nrf54h_init\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_NRF_ENABLE_ICACHE\nargument_list|)\nname|sys_cache_instr_enable\nargument_list|()\nexpr_stmt|;\nendif|#\ndirective|endif\nname|power_domain_init\nargument_list|()\nexpr_stmt|;\nname|trim_hsfll\nargument_list|()",
  "result": "I corrected the issue in the code by changing the following tokens:\n-\n-if SOC_NRF54H20\n-\n-config NRF_ENABLE_ICACHE\n-\tbool \"Instruction cache (I-Cache)\"\n-\tdefault y\n-\n-endif # SOC_NRF54H20\n-if|#\n-directive|if\n-name|defined\n-argument_list|(\n-name|CONFIG_NRF_ENABLE_ICACHE\n-argument_list|)\n-endif|#\n-directive|endif\nThe issue was with: soc: nordic: nrf54h: Remove redundant ICACHE kconfig\n\nRemove CONFIG_NRF_ENABLE_ICACHE as it is not needed. There is CONFIG_ICACHE\nwhich is by default enabled for nrf54h."
},{
  "instruction": "There is an issue in the following code. It relates to arch: arm: cortex_m: enable interrupts before entering application’s main\n\nThis also fixes a typo in `z_arm_switch_to_main_no_multithreading` making\nit unlock irq instead of locking them when main returns. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|unsigned\nname|int\nname|key\nparameter_list|)\nblock|{\nname|arch_irq_unlock\nargument_list|(\nname|key\nargument_list|)\nexpr_stmt|;\ndirective|endif\nasm|\"msr  PSP, %[_psp]\\n\"\ncomment|/* __set_PSP(psp) */\nasm|\"mov r0, #0\\n\" \t\"ldr r1, =arch_irq_unlock_outlined\\n\" \t\"blx r1\\n\"  \t\"mov r0, %[_p1]\\n\" \t\"mov r1, %[_p2]\\n\" \t\"mov r2, %[_p3]\\n\" \t\"blx  %[_main_entry]\\n\"\ncomment|/* main_entry(p1, p2, p3) */\nasm|\"mov r0, #0\\n\" \t\"ldr r1, =arch_irq_unlock_outlined\\n\" \t\"blx r1\\n\" \t\"loop: b loop\\n\\t\"\ncomment|/* while (true); */\nasm|: \t: [_p1]\"r\" (p1), [_p2]\"r\" (p2), [_p3]\"r\" (p3), \t  [_psp]\"r\" (psp), [_main_entry]\"r\" (main_entry)\nifdef|#\ndirective|ifdef\nname|CONFIG_BUILTIN_STACK_GUARD",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|#\n+directive|if\n+name|defined\n+argument_list|(\n+name|CONFIG_ARMV7_M_ARMV8_M_MAINLINE\n+argument_list|)\n+name|__enable_fault_irq\n+argument_list|()\n+expr_stmt|;\n+comment|/* alters FAULTMASK */\n+name|__enable_irq\n+argument_list|()\n+expr_stmt|;\n+comment|/* alters PRIMASK */\n+endif|#\n+directive|endif\n-asm|\"mov r0, #0\\n\" \t\"ldr r1, =arch_irq_unlock_outlined\\n\" \t\"blx r1\\n\" \t\"loop: b loop\\n\\t\"\n+asm|\"ldr r0, =arch_irq_lock_outlined\\n\" \t\"blx r0\\n\" \t\"loop: b loop\\n\\t\"\nThe issue was with: arch: arm: cortex_m: enable interrupts before entering application’s main\n\nThis also fixes a typo in `z_arm_switch_to_main_no_multithreading` making\nit unlock irq instead of locking them when main returns."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: OTS: Fix checksum calculation support\n\nThere was a typo in Kconfig check (missing CONFIG_ prefix) which\nresulted in not setting OACP_FEAT_BIT_CRC bit in features.\n\nThis also resulted in checksum feature being disabled due to check\nin bt_ots_init().\n\nThis was affecting OTS/SR/OASP/BV-03-C qualificatio test case. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_if\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|BT_OTS_OACP_CHECKSUM_SUPPORT\nargument_list|)\nend_if\n\nbegin_define\nDECL|macro|OACP_FEAT_BIT_CRC",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|BT_OTS_OACP_CHECKSUM_SUPPORT\n+name|CONFIG_BT_OTS_OACP_CHECKSUM_SUPPORT\nThe issue was with: Bluetooth: OTS: Fix checksum calculation support\n\nThere was a typo in Kconfig check (missing CONFIG_ prefix) which\nresulted in not setting OACP_FEAT_BIT_CRC bit in features.\n\nThis also resulted in checksum feature being disabled due to check\nin bt_ots_init().\n\nThis was affecting OTS/SR/OASP/BV-03-C qualificatio test case."
},{
  "instruction": "There is an issue in the following code. It relates to spi: shell: fix copyright typo\n\nCorrected copyright header. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright (c) 2024 Astroligt  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/*  * Copyright (c) 2024 Astroligt  *  * SPDX-License-Identifier: Apache-2.0  */\n+comment|/*  * Copyright (c) 2024 Astrolight  *  * SPDX-License-Identifier: Apache-2.0  */\nThe issue was with: spi: shell: fix copyright typo\n\nCorrected copyright header."
},{
  "instruction": "There is an issue in the following code. It relates to ADC: kb1200: start_read returns uninitialzed value\n\nFound via static analyis. When `adc_kb1200_start_read` succeeds, no\nvalue is set for `error` so it is still uninitialized when it is\nreturned. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|data\ndecl_stmt|;\nname|int\nname|error\ndecl_stmt|;\nif|if\ncondition|(\noperator|!\nname|sequence",
  "result": "I corrected the issue in the code by changing the following tokens:\n+init|=\n+literal|0\nThe issue was with: ADC: kb1200: start_read returns uninitialzed value\n\nFound via static analyis. When `adc_kb1200_start_read` succeeds, no\nvalue is set for `error` so it is still uninitialized when it is\nreturned."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: adc: adc_ad559x: fix driver init\n\nk_thread_name_set() function returns an error if CONFIG_THREAD_NAME is\nnot enabled which may make the driver not functional.\n\nFix the issue by adding a check against CONFIG_THREAD_NAME avaliability\nbefore calling k_thread_name_set() function so the driver can operate\nproperly with CONFIG_THREAD_NAME disabled. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|0\nargument_list|,\nname|K_NO_WAIT\nargument_list|)\nexpr_stmt|;\nname|ret\noperator|=\nname|k_thread_name_set\nargument_list|(\nname|tid\nblock|{\nreturn|return\nname|ret\nreturn|;\nblock|}\nname|adc_context_unlock_unconditionally\nargument_list|(\noperator|&\nname|data\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|IS_ENABLED\n+argument_list|(\n+name|CONFIG_THREAD_NAME\n+argument_list|)\n+condition|)\n+block|{\n+block|}\nThe issue was with: drivers: adc: adc_ad559x: fix driver init\n\nk_thread_name_set() function returns an error if CONFIG_THREAD_NAME is\nnot enabled which may make the driver not functional.\n\nFix the issue by adding a check against CONFIG_THREAD_NAME avaliability\nbefore calling k_thread_name_set() function so the driver can operate\nproperly with CONFIG_THREAD_NAME disabled."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: adc: adc_ad559x: add invernal vref value\n\nAdd configuration of internal refference voltage value so raw ADC\nreadings can be converted to mV utilizing adc_raw_to_millivolts()\nADC API function. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|AD559X_ADC_RESOLUTION\nvalue|12U\nend_define\n\nbegin_struct\nDECL|struct|adc_ad559x_config\nstruct|struct\nname|adc_ad559x_config\nblock|{\noperator|=\nname|adc_ad559x_read_async\nblock|,\nendif|#\ndirective|endif\nblock|}\ndecl_stmt|;\nend_decl_stmt\n\nbegin_define\nDECL|macro|ADC_AD559X_DEFINE (inst)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_define\n+DECL|macro|AD559X_ADC_VREF_MV\n+define|#\n+directive|define\n+name|AD559X_ADC_VREF_MV\n+value|2500U\n+end_define\n+\n-block|}\n+operator|.\n+name|ref_internal\n+operator|=\n+name|AD559X_ADC_VREF_MV\n+block|, }\nThe issue was with: drivers: adc: adc_ad559x: add invernal vref value\n\nAdd configuration of internal refference voltage value so raw ADC\nreadings can be converted to mV utilizing adc_raw_to_millivolts()\nADC API function."
},{
  "instruction": "There is an issue in the following code. It relates to boards: frdm_mcxn947: Add clock setup for FlexSPI\n\nThe MEMC driver in memc_mcux_flexspi.c is initialized\nbefore the FlexSPI driver (flash_mcux_flexspi_nor.c)\nand hangs during FlexSPI init. Initialize the FlexSPI\nclock to 50MHz before the speed is set to the optimum\nspeed by the FlexSPI driver. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/device.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<fsl_clock.h>\nend_include\nname|kPLL0_to_CTIMER4\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\ncomment|/* Set SystemCoreClock variable. */\nname|SystemCoreClock\noperator|=\nname|CLOCK_INIT_CORE_CLOCK\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/dt-bindings/clock/mcux_lpc_syscon_clock.h>\n+end_include\n+\n+if|#\n+directive|if\n+name|CONFIG_FLASH_MCUX_FLEXSPI_NOR\n+comment|/* We downclock the FlexSPI to 50MHz, it will be set to the \t * optimum speed supported by the Flash device during FLEXSPI \t * Init \t */\n+name|flexspi_clock_set_freq\n+argument_list|(\n+name|MCUX_FLEXSPI_CLK\n+argument_list|,\n+name|MHZ\n+argument_list|(\n+literal|50\n+argument_list|)\n+argument_list|)\n+expr_stmt|;\n+endif|#\n+directive|endif\nThe issue was with: boards: frdm_mcxn947: Add clock setup for FlexSPI\n\nThe MEMC driver in memc_mcux_flexspi.c is initialized\nbefore the FlexSPI driver (flash_mcux_flexspi_nor.c)\nand hangs during FlexSPI init. Initialize the FlexSPI\nclock to 50MHz before the speed is set to the optimum\nspeed by the FlexSPI driver."
},{
  "instruction": "There is an issue in the following code. It relates to tracing: full reset during init\n\nI am using the tracing module using the RAM backend on a system with\nlimited RAM & a buffer that can only store 300ms of tracing data. Current\ntracing module starts recording during boot-up & we run out of memory prior\nto executing code we actually want to trace.\n\nBy reseting buffer metadata here, I can call init() at an arbitrary point\nof program execution & the tracing module will reset & start tracing.\n\nI tested on E2E on an ARM M-class MCU by calling init & then reading\nbuffered tracing data via GDB Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|0\nargument_list|,\nname|CONFIG_RAM_TRACING_BUFFER_SIZE\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_decl_stmt\nDECL|variable|tracing_backend_ram_api",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|pos\n+operator|=\n+literal|0\n+expr_stmt|;\n+name|buffer_full\n+operator|=\n+name|false\n+expr_stmt|;\nThe issue was with: tracing: full reset during init\n\nI am using the tracing module using the RAM backend on a system with\nlimited RAM & a buffer that can only store 300ms of tracing data. Current\ntracing module starts recording during boot-up & we run out of memory prior\nto executing code we actually want to trace.\n\nBy reseting buffer metadata here, I can call init() at an arbitrary point\nof program execution & the tracing module will reset & start tracing.\n\nI tested on E2E on an ARM M-class MCU by calling init & then reading\nbuffered tracing data via GDB"
},{
  "instruction": "There is an issue in the following code. It relates to drivers/flash_simulator: Fix write for 0x00 erase value\n\nThe commit adds missing binary or in write operation.\nAssuming that program-erase devices only allow switching bits\nfrom erase-value to opposite, in case of 0x00 erase value device\nonly ones can be written. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|offset\noperator|+\nname|i\nargument_list|)\noperator|)\noperator|=\noperator|*\noperator|(\noperator|(\nname|uint8_t\noperator|*",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|=\n+operator||=\nThe issue was with: drivers/flash_simulator: Fix write for 0x00 erase value\n\nThe commit adds missing binary or in write operation.\nAssuming that program-erase devices only allow switching bits\nfrom erase-value to opposite, in case of 0x00 erase value device\nonly ones can be written."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: i3c: i3c_shell: add alphabetical order constraint\n\nAdd /* zephyr-keep-sorted-start */ around DT_FOREACH_STATUS_OKAY. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|)\ndefine|\\\nvalue|I3C_ATTACHED_DEV_GET_FN(node_id)                                                           \\ \tI3C_LIST_DEV_GET_FN(node_id)\nend_define\n\nbegin_macro\nname|DT_FOREACH_STATUS_OKAY\nargument_list|(\nargument|cdns_i3c\nargument_list|,\nargument_list|,\nargument|I3C_CTRL_FN\nargument_list|)\nend_macro\n\nbegin_define\nDECL|macro|I3C_CTRL_LIST_ENTRY (node_id)\ndefine|#\ndirective|define\nname|I3C_CTRL_LIST_ENTRY",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_comment\n+comment|/* zephyr-keep-sorted-start */\n+end_comment\n+\n+begin_comment\n+comment|/* zephyr-keep-sorted-stop */\n+end_comment\n+\nThe issue was with: drivers: i3c: i3c_shell: add alphabetical order constraint\n\nAdd /* zephyr-keep-sorted-start */ around DT_FOREACH_STATUS_OKAY."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: i3c: i3c_shell: add nuvoton_npcx_i3c compat macro to i3c_shell.\n\nAs titile. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nargument|I3C_CTRL_FN\nargument_list|)\nend_macro\n\nbegin_macro\nname|DT_FOREACH_STATUS_OKAY\nargument_list|(\nargument|nxp_mcux_i3c\nargument_list|,\nargument_list|,\nargument|I3C_CTRL_LIST_ENTRY\nargument_list|)\nname|DT_FOREACH_STATUS_OKAY\nargument_list|(\nargument|nxp_mcux_i3c\nargument_list|,\nargument|I3C_CTRL_LIST_ENTRY\nargument_list|)\ncomment|/* zephyr-keep-sorted-stop */",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_macro\n+name|DT_FOREACH_STATUS_OKAY\n+argument_list|(\n+argument|nuvoton_npcx_i3c\n+argument_list|,\n+argument|I3C_CTRL_FN\n+argument_list|)\n+end_macro\n+\n+argument|nuvoton_npcx_i3c\n+argument_list|,\n+argument|I3C_CTRL_LIST_ENTRY\n+argument_list|)\n+name|DT_FOREACH_STATUS_OKAY\n+argument_list|(\nThe issue was with: drivers: i3c: i3c_shell: add nuvoton_npcx_i3c compat macro to i3c_shell.\n\nAs titile."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: i3c: update i3c_dev_list_daa_addr_helper()\n\nDuring DAA, the responding device might not be in the device list.\nThis CL adds target device descriptor's pointer checking to prevent\ngetting unexpected results. Please fix this issue.",
  "input": "Faulty tokenized code:\ngoto|;\nblock|}\nif|if\ncondition|(\nname|desc\noperator|->\nname|dynamic_addr\noperator|!=\nliteral|0U\ncondition|)\nblock|}\ncomment|/* \t * Use the desired dynamic address as the new dynamic address \t * if the slot is free. \t */\nif|if\ncondition|(\nname|desc\noperator|->\nname|init_dynamic_addr\noperator|!=\nliteral|0U\ncondition|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|!=\n+name|NULL\n+operator|&&\n+name|desc\n+operator|!=\n+name|NULL\n+operator|&&\n+name|desc\nThe issue was with: drivers: i3c: update i3c_dev_list_daa_addr_helper()\n\nDuring DAA, the responding device might not be in the device list.\nThis CL adds target device descriptor's pointer checking to prevent\ngetting unexpected results."
},{
  "instruction": "There is an issue in the following code. It relates to ite/it8xxx2: avoid cpu entering deep doze mode when JTAG is enabled\n\nPrevent the CPU from entering deep doze mode when JTAG debug is enabled.\nAdditionally, The CPU address from 0x80000800 to 0x800008FF should be\nreserved for JTAG debug usage. This commit reserves the area from the end\nof the reset section to 0x800008FF if JTAG debug is enabled.\n\nTested with:\n- west build -p always -b it82xx2_evb samples/hello_world/\n       -DCONFIG_SOC_IT8XXX2_JTAG_DEBUG_INTERFACE=y Please fix this issue.",
  "input": "Faulty tokenized code:\n    SECTION_PROLOGUE(_RESET_SECTION_NAME,,)\n    {\n\t\tKEEP(*(.reset.*))\n    } GROUP_LINK_IN(ROMABLE_REGION)\n\n#ifndef CONFIG_SOC_IT8XXX2_EXCEPTIONS_IN_RAM\n    SECTION_PROLOGUE(_EXCEPTION_SECTION_NAME,,)\n\t{\n\t\tKEEP(*(\".exception.entry.*\"))\n\t\t*(\".exception.other.*\")\nname|mode\nargument_list|)\nexpr_stmt|;\ndo|do\nblock|{\ncomment|/* Wait for interrupt */\nasm|__asm__\nspecifier|volatile\nasm|(\"wfi\");\ncomment|/* \t\t * Sometimes wfi instruction may fail due to CPU's MTIP@mip \t\t * register is non-zero. \t\t * If the ite_intc_no_irq() is true at this point, \t\t * it means that EC waked-up by the above issue not an \t\t * interrupt. Hence we loop running wfi instruction here until \t\t * wfi success. \t\t */\nblock|}\ndo|while\ncondition|(\nname|ite_intc_no_irq",
  "result": "I corrected the issue in the code by changing the following tokens:\n+#ifdef CONFIG_SOC_IT8XXX2_JTAG_DEBUG_INTERFACE\n+#define JTAG_DEBUG_RESERVED_ADDR_START 0x80000800\n+#define JTAG_DEBUG_RESERVED_ADDR_END 0x800008FF\n+\t/* The CPU address from 0x80000800 to 0x800008FF is reserved for JTAG\n+\t * debug usage. */\n+\tSECTION_PROLOGUE(jtag_dbg,,)\n+\t{\n+\t\t__jtag_dbg_pad_start = ABSOLUTE(.);\n+\t\tASSERT((__jtag_dbg_pad_start < JTAG_DEBUG_RESERVED_ADDR_START),\n+\t\t\t\"The start address of jtag debug section is incorrect.\");\n+\n+\t\t__jtag_dbg_pad_size = JTAG_DEBUG_RESERVED_ADDR_END - __jtag_dbg_pad_start;\n+\t\t. = . + __jtag_dbg_pad_size;\n+\n+\t\t__jtag_dbg_pad_end = ABSOLUTE(.);\n+\t\tASSERT((__jtag_dbg_pad_end == JTAG_DEBUG_RESERVED_ADDR_END),\n+\t\t\t\"The end address of jtag debug section is incorrect.\");\n+\t} GROUP_LINK_IN(ROMABLE_REGION)\n+#endif\n+\n+ifndef|#\n+directive|ifndef\n+name|CONFIG_SOC_IT8XXX2_JTAG_DEBUG_INTERFACE\n+endif|#\n+directive|endif\nThe issue was with: ite/it8xxx2: avoid cpu entering deep doze mode when JTAG is enabled\n\nPrevent the CPU from entering deep doze mode when JTAG debug is enabled.\nAdditionally, The CPU address from 0x80000800 to 0x800008FF should be\nreserved for JTAG debug usage. This commit reserves the area from the end\nof the reset section to 0x800008FF if JTAG debug is enabled.\n\nTested with:\n- west build -p always -b it82xx2_evb samples/hello_world/\n       -DCONFIG_SOC_IT8XXX2_JTAG_DEBUG_INTERFACE=y"
},{
  "instruction": "There is an issue in the following code. It relates to Can: mcan: Uninitialized access in state_change_handler\n\nFound via static analysis. In `can_mcan_state_change_handler`, the\nreturn value of `can_mcan_get_state` is not checked for error. In the\nevent of an error, both `err_cnt` and `state` are left unitialized and\naccessed downstream.\n\nThe correct behavior is to return early in that case. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|cccr\ndecl_stmt|;\nname|int\nname|err\ndecl_stmt|;\noperator|(\nname|void\noperator|)\nname|can_mcan_get_state\nargument_list|(\nname|dev\nargument_list|,\noperator|&\nname|err_cnt\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|state_cb\noperator|!=\nname|NULL\ncondition|)\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|(\n-name|void\n-operator|)\n+name|err\n+operator|=\n+name|err\n+operator|!=\n+literal|0\n+condition|)\n+block|{\n+return|return;\n+block|}\n+if|if\n+condition|(\nThe issue was with: Can: mcan: Uninitialized access in state_change_handler\n\nFound via static analysis. In `can_mcan_state_change_handler`, the\nreturn value of `can_mcan_get_state` is not checked for error. In the\nevent of an error, both `err_cnt` and `state` are left unitialized and\naccessed downstream.\n\nThe correct behavior is to return early in that case."
},{
  "instruction": "There is an issue in the following code. It relates to mcumgr/img_mgmt: Fix zcbor logic in os_mgmt_bootloader_info\n\nThere have been to problems with the code where zcbor_bool_encode\nhas been fed value instead of expected pointer and the result\nof previous zcbor_encode operations has not been taken to evaluate\nvalue of ok status.\nThe change also replaces usage of  #if IS_ENABLED with #ifdef, as\nIS_ENABLED should not be used outside if(). Please fix this issue.",
  "input": "Faulty tokenized code:\nname|zse\nargument_list|,\nname|BOOTLOADER_MODE\nargument_list|)\nexpr_stmt|;\nif|#\ndirective|if\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_MCUBOOT_BOOTLOADER_NO_DOWNGRADE\nargument_list|)\nname|ok\noperator|=\nname|zcbor_tstr_put_lit\nargument_list|(\nname|zse\nargument_list|,\nliteral|\"no-downgrade\"\nargument_list|)\noperator|&&\nname|zcbor_bool_encode\nargument_list|(\nname|zse\nargument_list|,\nname|true\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n-if|#\n-directive|if\n-name|IS_ENABLED\n-argument_list|(\n+ifdef|#\n+directive|ifdef\n-argument_list|)\n+name|ok\n+operator|&&\n-name|zse\n+argument|zse\n-name|true\n+argument|&(bool){true}\nThe issue was with: mcumgr/img_mgmt: Fix zcbor logic in os_mgmt_bootloader_info\n\nThere have been to problems with the code where zcbor_bool_encode\nhas been fed value instead of expected pointer and the result\nof previous zcbor_encode operations has not been taken to evaluate\nvalue of ok status.\nThe change also replaces usage of  #if IS_ENABLED with #ifdef, as\nIS_ENABLED should not be used outside if()."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: can: stm32_bxcan: fix CAN mailbox overwrite\n\nFixes overwriting a mailbox before sending it completes.\nOverwriting can occur when one thread has waited for\nanother thread to complete the send function and\nfills a mailbox selected based on\nthe transmit_status_register variable,\nwhich has not been updated after waiting and,\naccordingly, does not contain up-to-date information\nabout the mailboxes used. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|can\ndecl_stmt|;\nname|uint32_t\nname|transmit_status_register\ninit|=\nname|can\noperator|->\nname|TSR\ndecl_stmt|;\nname|CAN_TxMailBox_TypeDef\nmodifier|*\nname|mailbox\ninit|=\nname|inst_mutex\nargument_list|,\nname|K_FOREVER\nargument_list|)\nexpr_stmt|;\nwhile|while\ncondition|(\noperator|!\noperator|(\nname|transmit_status_register",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|can\n-operator|->\n-name|TSR\n+literal|0\n+name|transmit_status_register\n+operator|=\n+name|can\n+operator|->\n+name|TSR\n+expr_stmt|;\nThe issue was with: drivers: can: stm32_bxcan: fix CAN mailbox overwrite\n\nFixes overwriting a mailbox before sending it completes.\nOverwriting can occur when one thread has waited for\nanother thread to complete the send function and\nfills a mailbox selected based on\nthe transmit_status_register variable,\nwhich has not been updated after waiting and,\naccordingly, does not contain up-to-date information\nabout the mailboxes used."
},{
  "instruction": "There is an issue in the following code. It relates to samples: drivers: adc: naming adc sample\n\nThe adc sample was in the root directory of the adc samples.\nMove all the files to a subdirectory adc_dt. Please fix this issue.",
  "input": "Faulty tokenized code:\n    ('reference/usb/uds_testing', 'services/usb/uds_testing'),\n    ('reference/usermode/index', 'kernel/usermode/index'),\n    ('reference/usermode/overview', 'kernel/usermode/overview'),\n    ('reference/usermode/syscalls', 'kernel/usermode/syscalls'),\n    ('reference/util/index', 'kernel/util/index'),\n    ('samples/drivers/kscan_touch', 'samples/subsys/input/input'),\n    ('samples/drivers/led_apa102/README', 'samples/drivers/led_strip/README'),\n    ('samples/drivers/led_lpd8806/README', 'samples/drivers/led_strip/README'),\n    ('samples/drivers/led_ws2812/README', 'samples/drivers/led_strip/README'),\n    ('samples/net/cloud/google_iot_mqtt/README', 'samples/net/cloud/cloud'),\nsimilarity index 100%\nrename from samples/drivers/adc/CMakeLists.txt\nrename to samples/drivers/adc/adc_dt/CMakeLists.txt\nsimilarity index 89%\nrename from samples/drivers/adc/README.rst\nrename to samples/drivers/adc/adc_dt/README.rst\n.. zephyr:code-sample:: adc\n  :name: Analog-to-Digital Converter (ADC)\n   :relevant-api: adc_interface\n\n   Read analog inputs from ADC channels.\n\nOverview\n\nConfiguration of channels (settings like gain, reference, or acquisition time)\nalso needs to be specified in devicetree, in ADC controller child nodes. Also\nthe ADC resolution and oversampling setting (if used) need to be specified\nthere. See :zephyr_file:`boards/nrf52840dk_nrf52840.overlay\n<samples/drivers/adc/boards/nrf52840dk_nrf52840.overlay>` for an example of\nsuch setup.\n\nBuilding and Running for ST Nucleo L073RZ\n=========================================\n\nThe sample can be built and executed for the\n:ref:`nucleo_l073rz_board` as follows:\n\n.. zephyr-app-commands::\n  :zephyr-app: samples/drivers/adc\n   :board: nucleo_l073rz\n   :goals: build flash\n   :compact:\n\nTo build for another board, change \"nucleo_l073rz\" above to that board's name\nsimilarity index 100%\nrename from samples/drivers/adc/boards/cc1352r1_launchxl.overlay\nrename to samples/drivers/adc/adc_dt/boards/cc1352r1_launchxl.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/cc1352r_sensortag.overlay\nrename to samples/drivers/adc/adc_dt/boards/cc1352r_sensortag.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/cc26x2r1_launchxl.overlay\nrename to samples/drivers/adc/adc_dt/boards/cc26x2r1_launchxl.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/cc3220sf_launchxl.overlay\nrename to samples/drivers/adc/adc_dt/boards/cc3220sf_launchxl.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/cc3235sf_launchxl.overlay\nrename to samples/drivers/adc/adc_dt/boards/cc3235sf_launchxl.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/cy8cproto_062_4343w.overlay\nrename to samples/drivers/adc/adc_dt/boards/cy8cproto_062_4343w.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/cy8cproto_063_ble.overlay\nrename to samples/drivers/adc/adc_dt/boards/cy8cproto_063_ble.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/da1469x_dk_pro.overlay\nrename to samples/drivers/adc/adc_dt/boards/da1469x_dk_pro.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/disco_l475_iot1.overlay\nrename to samples/drivers/adc/adc_dt/boards/disco_l475_iot1.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/efm32pg_stk3402a.overlay\nrename to samples/drivers/adc/adc_dt/boards/efm32pg_stk3402a.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/esp32_devkitc_wroom_procpu.overlay\nrename to samples/drivers/adc/adc_dt/boards/esp32_devkitc_wroom_procpu.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/esp32_devkitc_wrover_procpu.overlay\nrename to samples/drivers/adc/adc_dt/boards/esp32_devkitc_wrover_procpu.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/esp32c3_devkitm.overlay\nrename to samples/drivers/adc/adc_dt/boards/esp32c3_devkitm.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/esp32c3_luatos_core.overlay\nrename to samples/drivers/adc/adc_dt/boards/esp32c3_luatos_core.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/esp32c3_luatos_core_esp32c3_usb.overlay\nrename to samples/drivers/adc/adc_dt/boards/esp32c3_luatos_core_esp32c3_usb.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/esp32s2_saola.overlay\nrename to samples/drivers/adc/adc_dt/boards/esp32s2_saola.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/esp32s3_devkitm_procpu.overlay\nrename to samples/drivers/adc/adc_dt/boards/esp32s3_devkitm_procpu.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/esp32s3_luatos_core_procpu.overlay\nrename to samples/drivers/adc/adc_dt/boards/esp32s3_luatos_core_procpu.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/esp32s3_luatos_core_procpu_usb.overlay\nrename to samples/drivers/adc/adc_dt/boards/esp32s3_luatos_core_procpu_usb.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/ev11l78a.overlay\nrename to samples/drivers/adc/adc_dt/boards/ev11l78a.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/frdm_k64f.overlay\nrename to samples/drivers/adc/adc_dt/boards/frdm_k64f.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/gd32a503v_eval.overlay\nrename to samples/drivers/adc/adc_dt/boards/gd32a503v_eval.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/gd32f350r_eval.overlay\nrename to samples/drivers/adc/adc_dt/boards/gd32f350r_eval.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/gd32f403z_eval.overlay\nrename to samples/drivers/adc/adc_dt/boards/gd32f403z_eval.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/gd32f450i_eval.overlay\nrename to samples/drivers/adc/adc_dt/boards/gd32f450i_eval.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/gd32l233r_eval.overlay\nrename to samples/drivers/adc/adc_dt/boards/gd32l233r_eval.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/gd32vf103v_eval.overlay\nrename to samples/drivers/adc/adc_dt/boards/gd32vf103v_eval.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/longan_nano.overlay\nrename to samples/drivers/adc/adc_dt/boards/longan_nano.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/longan_nano_gd32vf103_lite.overlay\nrename to samples/drivers/adc/adc_dt/boards/longan_nano_gd32vf103_lite.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/lpcxpresso55s36.overlay\nrename to samples/drivers/adc/adc_dt/boards/lpcxpresso55s36.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/lpcxpresso55s69_lpc55s69_cpu0.overlay\nrename to samples/drivers/adc/adc_dt/boards/lpcxpresso55s69_lpc55s69_cpu0.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/mec15xxevb_assy6853.overlay\nrename to samples/drivers/adc/adc_dt/boards/mec15xxevb_assy6853.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/mec172xevb_assy6906.overlay\nrename to samples/drivers/adc/adc_dt/boards/mec172xevb_assy6906.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/mimxrt1010_evk.overlay\nrename to samples/drivers/adc/adc_dt/boards/mimxrt1010_evk.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/mimxrt1015_evk.overlay\nrename to samples/drivers/adc/adc_dt/boards/mimxrt1015_evk.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/mimxrt1020_evk.overlay\nrename to samples/drivers/adc/adc_dt/boards/mimxrt1020_evk.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/mimxrt1024_evk.overlay\nrename to samples/drivers/adc/adc_dt/boards/mimxrt1024_evk.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/mimxrt1040_evk.overlay\nrename to samples/drivers/adc/adc_dt/boards/mimxrt1040_evk.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/mimxrt1050_evk.overlay\nrename to samples/drivers/adc/adc_dt/boards/mimxrt1050_evk.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/mimxrt1060_evk.overlay\nrename to samples/drivers/adc/adc_dt/boards/mimxrt1060_evk.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/mimxrt1064_evk.overlay\nrename to samples/drivers/adc/adc_dt/boards/mimxrt1064_evk.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/mimxrt1160_evk_mimxrt1166_cm7.overlay\nrename to samples/drivers/adc/adc_dt/boards/mimxrt1160_evk_mimxrt1166_cm7.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/mimxrt1170_evk_mimxrt1176_cm7_A.overlay\nrename to samples/drivers/adc/adc_dt/boards/mimxrt1170_evk_mimxrt1176_cm7_A.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/mimxrt1170_evk_mimxrt1176_cm7_B.overlay\nrename to samples/drivers/adc/adc_dt/boards/mimxrt1170_evk_mimxrt1176_cm7_B.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/mimxrt595_evk_mimxrt595s_cm33.overlay\nrename to samples/drivers/adc/adc_dt/boards/mimxrt595_evk_mimxrt595s_cm33.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/mimxrt685_evk_mimxrt685s_cm33.overlay\nrename to samples/drivers/adc/adc_dt/boards/mimxrt685_evk_mimxrt685s_cm33.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/mr_canhubk3.overlay\nrename to samples/drivers/adc/adc_dt/boards/mr_canhubk3.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/nrf51dk_nrf51822.overlay\nrename to samples/drivers/adc/adc_dt/boards/nrf51dk_nrf51822.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/nrf52840dk_nrf52840.overlay\nrename to samples/drivers/adc/adc_dt/boards/nrf52840dk_nrf52840.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/nucleo_c031c6.overlay\nrename to samples/drivers/adc/adc_dt/boards/nucleo_c031c6.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/nucleo_h7a3zi_q.overlay\nrename to samples/drivers/adc/adc_dt/boards/nucleo_h7a3zi_q.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/nucleo_l073rz.overlay\nrename to samples/drivers/adc/adc_dt/boards/nucleo_l073rz.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/nucleo_l552ze_q.overlay\nrename to samples/drivers/adc/adc_dt/boards/nucleo_l552ze_q.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/nucleo_u575zi_q.overlay\nrename to samples/drivers/adc/adc_dt/boards/nucleo_u575zi_q.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/nucleo_wba52cg.overlay\nrename to samples/drivers/adc/adc_dt/boards/nucleo_wba52cg.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/nucleo_wl55jc.overlay\nrename to samples/drivers/adc/adc_dt/boards/nucleo_wl55jc.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/robokit1.overlay\nrename to samples/drivers/adc/adc_dt/boards/robokit1.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/rpi_pico.overlay\nrename to samples/drivers/adc/adc_dt/boards/rpi_pico.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/sam4e_xpro.overlay\nrename to samples/drivers/adc/adc_dt/boards/sam4e_xpro.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/sam4s_xplained.overlay\nrename to samples/drivers/adc/adc_dt/boards/sam4s_xplained.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/sam_e70_xplained_same70q21.overlay\nrename to samples/drivers/adc/adc_dt/boards/sam_e70_xplained_same70q21.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/sam_v71_xult_samv71q21.overlay\nrename to samples/drivers/adc/adc_dt/boards/sam_v71_xult_samv71q21.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/samc21n_xpro.overlay\nrename to samples/drivers/adc/adc_dt/boards/samc21n_xpro.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/samd21_xpro.overlay\nrename to samples/drivers/adc/adc_dt/boards/samd21_xpro.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/same54_xpro.overlay\nrename to samples/drivers/adc/adc_dt/boards/same54_xpro.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/saml21_xpro.overlay\nrename to samples/drivers/adc/adc_dt/boards/saml21_xpro.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/samr21_xpro.overlay\nrename to samples/drivers/adc/adc_dt/boards/samr21_xpro.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/samr34_xpro.overlay\nrename to samples/drivers/adc/adc_dt/boards/samr34_xpro.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/stm32h573i_dk.overlay\nrename to samples/drivers/adc/adc_dt/boards/stm32h573i_dk.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/stm32h735g_disco.overlay\nrename to samples/drivers/adc/adc_dt/boards/stm32h735g_disco.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/stm32l496g_disco.overlay\nrename to samples/drivers/adc/adc_dt/boards/stm32l496g_disco.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/stm32l562e_dk.overlay\nrename to samples/drivers/adc/adc_dt/boards/stm32l562e_dk.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/tlsr9518adk80d.overlay\nrename to samples/drivers/adc/adc_dt/boards/tlsr9518adk80d.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/xiao_esp32s3_procpu.overlay\nrename to samples/drivers/adc/adc_dt/boards/xiao_esp32s3_procpu.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/xmc45_relax_kit.overlay\nrename to samples/drivers/adc/adc_dt/boards/xmc45_relax_kit.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/boards/yd_esp32_procpu.overlay\nrename to samples/drivers/adc/adc_dt/boards/yd_esp32_procpu.overlay\nsimilarity index 100%\nrename from samples/drivers/adc/prj.conf\nrename to samples/drivers/adc/adc_dt/prj.conf\nsimilarity index 93%\nrename from samples/drivers/adc/sample.yaml\nrename to samples/drivers/adc/adc_dt/sample.yaml\nsample:\n name: ADC driver sample\ntests:\n sample.drivers.adc:\n    tags:\n      - adc\n    depends_on: adc\n    platform_allow:\n      - nucleo_l073rz\nsimilarity index 100%\nrename from samples/drivers/adc/src/main.c\nrename to samples/drivers/adc/adc_dt/src/main.c",
  "result": "I corrected the issue in the code by changing the following tokens:\n+    ('samples/drivers/adc/README', 'samples/drivers/adc/adc_dt/README'),\n-.. zephyr:code-sample:: adc\n-   :name: Analog-to-Digital Converter (ADC)\n+.. zephyr:code-sample:: adc_dt\n+   :name: Analog-to-Digital Converter (ADC) with devicetree\n-<samples/drivers/adc/boards/nrf52840dk_nrf52840.overlay>` for an example of\n+<samples/drivers/adc/adc_dt/boards/nrf52840dk_nrf52840.overlay>` for an example of\n-   :zephyr-app: samples/drivers/adc\n+   :zephyr-app: samples/drivers/adc/adc_dt\n-  name: ADC driver sample\n+  name: ADC devicetree driver sample\n-  sample.drivers.adc:\n+  sample.drivers.adc.adc_dt:\nThe issue was with: samples: drivers: adc: naming adc sample\n\nThe adc sample was in the root directory of the adc samples.\nMove all the files to a subdirectory adc_dt."
},{
  "instruction": "There is an issue in the following code. It relates to net: l2: wifi: Fix for wrong return type\n\nThe function should return NULL instead of false in case of failure. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|iface\nargument_list|)\ncondition|)\nblock|{\nreturn|return\nname|false\nreturn|;\nblock|}\nname|k_mutex_lock\nargument_list|(\noperator|&",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|false\n+name|NULL\nThe issue was with: net: l2: wifi: Fix for wrong return type\n\nThe function should return NULL instead of false in case of failure."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: gnss: Use correct GGA Elevation field\n\nSwitching from using Geoid seperation to Elevation MSL field. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|(\nname|gnss_parse_dec_to_milli\nargument_list|(\nname|argv\nindex|[\nliteral|11\nindex|]\nargument_list|,\noperator|&\nname|tmp64\nargument_list|)\noperator|.\nname|nav_data\noperator|.\nname|altitude\nargument_list|,\nliteral|42371\nargument_list|,\nliteral|\"Incorrectly parsed altitude\"\nargument_list|)\nexpr_stmt|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|11\n+literal|9\n-literal|42371\n+literal|15234\nThe issue was with: drivers: gnss: Use correct GGA Elevation field\n\nSwitching from using Geoid seperation to Elevation MSL field."
},{
  "instruction": "There is an issue in the following code. It relates to tests: actually test NVMe disk access\n\nRAM disk access is always enabled on qemu_x86_64, so checking for it first\nmeans that NVMe is never selected. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_elif\nelif|#\ndirective|elif\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_DISK_DRIVER_RAM\nargument_list|)\nend_elif\n\nbegin_define\nDECL|macro|DISK_NAME_PHYS\ndefine|#\ndirective|define\nname|DISK_NAME_PHYS\nvalue|\"RAM\"\nend_define\n\nbegin_elif\nelif|#\ndirective|elif\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_DISK_DRIVER_FLASH\nargument_list|)\nend_elif\n\nbegin_define\nDECL|macro|DISK_NAME_PHYS\ndefine|#\ndirective|define\nname|DISK_NAME_PHYS\nvalue|\"NAND\"\nend_define\n\nbegin_elif\nelif|#\ndirective|elif\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_NVME\nargument_list|)\nend_elif\n\nbegin_define\nDECL|macro|DISK_NAME_PHYS\ndefine|#\ndirective|define\nname|DISK_NAME_PHYS\nvalue|\"nvme0n0\"\nend_define\n\nbegin_else\nelse|#\ndirective|else",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_DISK_DRIVER_RAM\n+name|CONFIG_DISK_DRIVER_FLASH\n-value|\"RAM\"\n+value|\"NAND\"\n-name|CONFIG_DISK_DRIVER_FLASH\n+name|CONFIG_NVME\n-value|\"NAND\"\n+value|\"nvme0n0\"\n-name|CONFIG_NVME\n+name|CONFIG_DISK_DRIVER_RAM\n+begin_comment\n+comment|/* Since ramdisk is enabled by default on e.g. qemu boards, it needs to be checked last to not  * override other backends.  */\n+end_comment\n+\n-value|\"nvme0n0\"\n+value|\"RAM\"\nThe issue was with: tests: actually test NVMe disk access\n\nRAM disk access is always enabled on qemu_x86_64, so checking for it first\nmeans that NVMe is never selected."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Fix minor whitespace issue\n\nFix minor whitespace issue Please fix this issue.",
  "input": "Faulty tokenized code:\nname|hci_vs_init\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nDECL|union|__anon28fe6e60010a\nunion|union\nblock|{\nDECL|member|info\nname|struct\nname|bt_hci_rp_vs_read_version_info",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon28fe6e60010a\n+DECL|union|__anon2c1abd29010a\nThe issue was with: Bluetooth: Fix minor whitespace issue\n\nFix minor whitespace issue"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: mbox: nrf_vevif_local: remove RT periph enable\n\nIt is done already at PRE_KERNEL stage. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|device\nmodifier|*\nname|dev\nparameter_list|)\nblock|{\nname|nrf_vpr_csr_rtperiph_enable_set\nargument_list|(\nname|true\nargument_list|)\nexpr_stmt|;\nname|nrf_vpr_csr_vevif_tasks_clear\nargument_list|(\nname|NRF_VPR_TASK_TRIGGER_ALL_MASK\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|nrf_vpr_csr_rtperiph_enable_set\n-argument_list|(\n-name|true\n-argument_list|)\n-expr_stmt|;\nThe issue was with: drivers: mbox: nrf_vevif_local: remove RT periph enable\n\nIt is done already at PRE_KERNEL stage."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: Ignore bit 1 set in Initiating_PHYs\n\nIgnore LE 2M PHY being set in Initiating_PHYs of the\nLE Extended Create Connection command. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|=\nname|cmd\noperator|->\nname|phys\nexpr_stmt|;\nif|if\ncondition|(\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_BT_CTLR_PARAM_CHECK",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Ignore Scan Interval and Scan Window, and ignore scanning if \t * Initiating PHY is set for LE 2M PHY \t * Refer to Bluetooth Core Specification Version 5.4 Vol 4, Part E \t * 7.8.66 LE Extended Create Connection command \t */\n+name|phys\n+operator|&=\n+operator|~\n+name|BT_HCI_LE_EXT_SCAN_PHY_2M\n+expr_stmt|;\n+comment|/* Check if unsupported PHY requested for scanning */\nThe issue was with: Bluetooth: Controller: Ignore bit 1 set in Initiating_PHYs\n\nIgnore LE 2M PHY being set in Initiating_PHYs of the\nLE Extended Create Connection command."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: bluetooth/cyw43xxx: check that hw_flow_control is set\n\nAdd BUILD_ASSERT to check that hw_flow_control is set. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<stdint.h>\nend_include\n\nbegin_define\nDECL|macro|DT_DRV_COMPAT\ndefine|#\ndirective|define\nname|DT_DRV_COMPAT\nname|brcm_patch_ram_length\ndecl_stmt|;\nend_decl_stmt\n\nbegin_enum\nDECL|enum|__anon295b1e400103\nenum|enum\nblock|{\nDECL|enumerator|BT_HCI_VND_OP_DOWNLOAD_MINIDRIVER\nname|BT_HCI_VND_OP_DOWNLOAD_MINIDRIVER\ninit|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_expr_stmt\n+name|BUILD_ASSERT\n+argument_list|(\n+name|DT_PROP\n+argument_list|(\n+name|DT_CHOSEN\n+argument_list|(\n+name|zephyr_bt_uart\n+argument_list|)\n+argument_list|,\n+name|hw_flow_control\n+argument_list|)\n+operator|==\n+literal|1\n+argument_list|,\n+literal|\"hw_flow_control must be enabled for HCI H4 UART\"\n+argument_list|)\n+expr_stmt|;\n+end_expr_stmt\n+\n-DECL|enum|__anon295b1e400103\n+DECL|enum|__anon2aea07850103\nThe issue was with: drivers: bluetooth/cyw43xxx: check that hw_flow_control is set\n\nAdd BUILD_ASSERT to check that hw_flow_control is set."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: L2CAP: don't use NULL buf\n\nAllocation of `buf` can fail. It just very rarely happens in practice. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|uint16_t\nargument_list|)\noperator|)\nargument_list|)\nexpr_stmt|;\nname|req\noperator|=\nname|net_buf_add\nargument_list|(\nname|buf\noperator|*\nname|rsp\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|rsp\noperator|=\nname|net_buf_add\nargument_list|(\nname|buf",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+operator|!\n+name|buf\n+condition|)\n+block|{\n+return|return\n+operator|-\n+name|ENOMEM\n+return|;\n+block|}\n+if|if\n+condition|(\n+operator|!\n+name|buf\n+condition|)\n+block|{\n+return|return;\n+block|}\nThe issue was with: Bluetooth: L2CAP: don't use NULL buf\n\nAllocation of `buf` can fail. It just very rarely happens in practice."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: ptp_clock_nxp_enet: misc fixes\n\n1. Correct node label in k64 overlay for ptp test\n   - Not sure if this actually matters since it appears\n     that actual hardware is no longer tested in net tests\n\n2. Include fsl_enet with <> instead of \\\"\\\".\n\n3. Build the ptp clock driver only if the ethernet driver is built\n   - Technically I think the 1588 timer should be able to be used\n     even if the ethernet mac is not used, but I would imagine this\n     to be an extraordinarily rare, weird, and niche use case, so to fix\n     the current CI error caused by net test disabling ethernet drivers,\n     couple the ptp clock driver to the ethernet driver in the build\n     configuration. Please fix this issue.",
  "input": "Faulty tokenized code:\n\nconfig PTP_CLOCK_NXP_ENET\n\tbool \"NXP ENET PTP Clock driver\"\n\tdefault y\n\tdepends on DT_HAS_NXP_ENET_PTP_CLOCK_ENABLED && NET_L2_PTP\n\thelp\n\t  Enable NXP ENET PTP clock support.\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|\"fsl_enet.h\"\nend_include\n\nbegin_struct\nDECL|struct|ptp_clock_nxp_enet_config\nstruct|struct\n * Copyright (c) 2021 Esco Medical Aps\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n&enet {\n\n\tptp {\n\t\tstatus = \"ok\";\n\t};\n};",
  "result": "I corrected the issue in the code by changing the following tokens:\n+\tdepends on ETH_NXP_ENET\n-file|\"fsl_enet.h\"\n+file|<fsl_enet.h>\n-&enet {\n-\n-\tptp {\n-\t\tstatus = \"ok\";\n-\t};\n+&enet_ptp_clock {\n+\tstatus = \"okay\";\nThe issue was with: drivers: ptp_clock_nxp_enet: misc fixes\n\n1. Correct node label in k64 overlay for ptp test\n   - Not sure if this actually matters since it appears\n     that actual hardware is no longer tested in net tests\n\n2. Include fsl_enet with <> instead of \\\"\\\".\n\n3. Build the ptp clock driver only if the ethernet driver is built\n   - Technically I think the 1588 timer should be able to be used\n     even if the ethernet mac is not used, but I would imagine this\n     to be an extraordinarily rare, weird, and niche use case, so to fix\n     the current CI error caused by net test disabling ethernet drivers,\n     couple the ptp clock driver to the ethernet driver in the build\n     configuration."
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: counter: counter_basic_api\n\nCorrectly show skips in final statistics. Please fix this issue.",
  "input": "Faulty tokenized code:\nindex|]\noperator|->\nname|name\nargument_list|)\nexpr_stmt|;\nblock|}\nname|counter_tear_down_instance\nargument_list|(\nname|devices\nindex|[",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|ztest_test_skip\n+argument_list|()\n+expr_stmt|;\nThe issue was with: tests: drivers: counter: counter_basic_api\n\nCorrectly show skips in final statistics."
},{
  "instruction": "There is an issue in the following code. It relates to usb: device_next: Fix uninitialized variable warning\n\nAssign default value to prevent possible uninitialized variable warning. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|bEndpointAddress\ndecl_stmt|;\nname|int\nname|ret\ndecl_stmt|;\nswitch|switch\ncondition|(\nname|op\ncondition|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+init|=\n+operator|-\n+name|ENOTSUP\nThe issue was with: usb: device_next: Fix uninitialized variable warning\n\nAssign default value to prevent possible uninitialized variable warning."
},{
  "instruction": "There is an issue in the following code. It relates to usb: device_next: Allow class to return NULL descriptor set\n\nSimply skip over the class if it returns NULL descriptor set for given\nspeed. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|dhp\noperator|==\nname|NULL\ncondition|)\nblock|{\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}\nwhile|while\ncondition|(\noperator|*\nname|dhp\noperator|==\nname|NULL\ncondition|)\nblock|{\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}\nname|tmp_nif\noperator|=\noperator|*",
  "result": "I corrected the issue in the code by changing the following tokens:\n-return|return\n-operator|-\n-name|EINVAL\n-return|;\n+continue|continue;\n-operator|-\n-name|EINVAL\n+literal|0\nThe issue was with: usb: device_next: Allow class to return NULL descriptor set\n\nSimply skip over the class if it returns NULL descriptor set for given\nspeed."
},{
  "instruction": "There is an issue in the following code. It relates to usb: device_next: allow terminating descriptor set with NULL\n\nDo not require nil descriptor at the end of descriptor set because it\nserves no other purpose than a sentinel. Just end processing on first\nNULL pointer within descriptor set. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|EINVAL\nreturn|;\nblock|}\nwhile|while\ncondition|(\noperator|(\noperator|*\nname|dhp\noperator|)\noperator|->\nname|NULL\noperator|&&\noperator|(\noperator|*\nname|dhp\noperator|)\noperator|->\nname|bLength\noperator|!=\nliteral|0U\noperator|=\nliteral|0U\nexpr_stmt|;\nwhile|while\ncondition|(\noperator|(\noperator|*\nname|dhp\noperator|)\noperator|->\nname|EINVAL\nreturn|;\nblock|}\nwhile|while\ncondition|(\noperator|(\noperator|*\nname|dhp\noperator|)\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|*\n+name|dhp\n+operator|!=\n+name|NULL\n+operator|&&\n+operator|!=\n+name|NULL\n+operator|)\n+operator|&&\n+operator|(\n+operator|*\n+name|dhp\n+operator|*\n+name|dhp\n+operator|!=\n+name|NULL\n+operator|&&\n+operator|*\n+name|dhp\n+operator|!=\n+name|NULL\n+operator|&&\nThe issue was with: usb: device_next: allow terminating descriptor set with NULL\n\nDo not require nil descriptor at the end of descriptor set because it\nserves no other purpose than a sentinel. Just end processing on first\nNULL pointer within descriptor set."
},{
  "instruction": "There is an issue in the following code. It relates to net: dsa: Fix DSA driver for KSZ8xxx to correctly initialize LAN devices\n\nThe commit \\\"drivers: ethernet: dsa_ksz8xxx: use\nNET_DEVICE_DT_DEFINE_INSTANCE\\\"\n(SHA1: fe1c41261f144174171231b29c931d011f01c900 [formerly f78a0810667b3b17706596a0ad2c53eb53a9400b]) replaced\nNET_DEVICE_INIT_INSTANCE() with NET_DEVICE_DT_DEFINE_INSTANCE() to\nfacilitate the removal of deprecated (from Zephyr's 3.2 release)\nDT_LABEL() macro.\n\nUnfortunately, the per LAN port initialization is necessary for correct\noperation of the DSA driver - otherwise following errors were visible\nwhen LLDP DSA sample (samples/net/dsa/src) was run on ip_k66f board:\n\n<wrn> net_if: iface 0x20001440 is down\n<inf> net_dsa_lldp_sample: LLDP pkt recv -> lan1\n<inf> net_dsa_lldp_sample:   CHASSIS ID:     38:05:43:69:XX:ZZ\n<inf> net_dsa_lldp_sample:   PORT ID:        38:05:43:69:XX:ZZ\n<inf> net_dsa_lldp_sample:   TTL:            120s\n<inf> net_dsa_lldp_sample:   SYSTEM NAME:    mtt\n<err> net_dsa_lldp_sample: Failed to send, errno 115\n\nThe fix is to use again NET_DEVICE_INIT_INSTANCE() with \\\"lan\\\"X name\nassigned (to avoid too long names when recommended DT_PROP() is\nused instead of DT_LABEL()).\n\nFixes: fe1c41261f144174171231b29c931d011f01c900 [formerly f78a0810667b3b17706596a0ad2c53eb53a9400b] Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/linker/sections.h>\nend_include\n\nbegin_if\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|slave\nparameter_list|,\nname|n\nparameter_list|)\ndefine|\\\nvalue|const struct dsa_slave_config dsa_0_slave_##slave##_config = {     \\ \t\t.mac_addr = DT_PROP_OR(slave, local_mac_address, {0})      \\ \t};                                                                 \\ \tNET_DEVICE_DT_DEFINE_INSTANCE(slave,                               \\ \tn,                                                                 \\ \tdsa_port_init,                                                     \\ \tNULL,                                                              \\&dsa_context_##n,                                                  \\&dsa_0_slave_##slave##_config,                                     \\ \tCONFIG_ETH_INIT_PRIORITY,                                          \\&dsa_eth_api_funcs,                                                \\ \tETHERNET_L2,                                                       \\ \tNET_L2_GET_CTX_TYPE(ETHERNET_L2),                                  \\ \tNET_ETH_MTU);\nend_define\n\nbegin_define\nDECL|macro|NET_SLAVE_DEVICE_0_INIT_INSTANCE (slave)\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/toolchain/common.h>\n+end_include\n+\n-value|const struct dsa_slave_config dsa_0_slave_##slave##_config = {     \\ \t\t.mac_addr = DT_PROP_OR(slave, local_mac_address, {0})      \\ \t};                                                                 \\ \tNET_DEVICE_DT_DEFINE_INSTANCE(slave,                               \\ \tn,                                                                 \\ \tdsa_port_init,                                                     \\ \tNULL,                                                              \\&dsa_context_##n,                                                  \\&dsa_0_slave_##slave##_config,                                     \\ \tCONFIG_ETH_INIT_PRIORITY,                                          \\&dsa_eth_api_funcs,                                                \\ \tETHERNET_L2,                                                       \\ \tNET_L2_GET_CTX_TYPE(ETHERNET_L2),                                  \\ \tNET_ETH_MTU);\n+value|const struct dsa_slave_config dsa_0_slave_##slave##_config = {     \\ \t\t.mac_addr = DT_PROP_OR(slave, local_mac_address, {0})      \\ \t};                                                                 \\ \tNET_DEVICE_INIT_INSTANCE(CONCAT(dsa_slave_port_, slave),           \\ \t\"lan\" STRINGIFY(n),                                                \\ \tn,                                                                 \\ \tdsa_port_init,                                                     \\ \tNULL,                                                              \\&dsa_context_##n,                                                  \\&dsa_0_slave_##slave##_config,                                     \\ \tCONFIG_ETH_INIT_PRIORITY,                                          \\&dsa_eth_api_funcs,                                                \\ \tETHERNET_L2,                                                       \\ \tNET_L2_GET_CTX_TYPE(ETHERNET_L2),                                  \\ \tNET_ETH_MTU);\nThe issue was with: net: dsa: Fix DSA driver for KSZ8xxx to correctly initialize LAN devices\n\nThe commit \\\"drivers: ethernet: dsa_ksz8xxx: use\nNET_DEVICE_DT_DEFINE_INSTANCE\\\"\n(SHA1: fe1c41261f144174171231b29c931d011f01c900 [formerly f78a0810667b3b17706596a0ad2c53eb53a9400b]) replaced\nNET_DEVICE_INIT_INSTANCE() with NET_DEVICE_DT_DEFINE_INSTANCE() to\nfacilitate the removal of deprecated (from Zephyr's 3.2 release)\nDT_LABEL() macro.\n\nUnfortunately, the per LAN port initialization is necessary for correct\noperation of the DSA driver - otherwise following errors were visible\nwhen LLDP DSA sample (samples/net/dsa/src) was run on ip_k66f board:\n\n<wrn> net_if: iface 0x20001440 is down\n<inf> net_dsa_lldp_sample: LLDP pkt recv -> lan1\n<inf> net_dsa_lldp_sample:   CHASSIS ID:     38:05:43:69:XX:ZZ\n<inf> net_dsa_lldp_sample:   PORT ID:        38:05:43:69:XX:ZZ\n<inf> net_dsa_lldp_sample:   TTL:            120s\n<inf> net_dsa_lldp_sample:   SYSTEM NAME:    mtt\n<err> net_dsa_lldp_sample: Failed to send, errno 115\n\nThe fix is to use again NET_DEVICE_INIT_INSTANCE() with \\\"lan\\\"X name\nassigned (to avoid too long names when recommended DT_PROP() is\nused instead of DT_LABEL()).\n\nFixes: fe1c41261f144174171231b29c931d011f01c900 [formerly f78a0810667b3b17706596a0ad2c53eb53a9400b]"
},{
  "instruction": "There is an issue in the following code. It relates to soc: st: stm32: adding option to enable prefetch buffer\n\nFor more effective code execution on STM32 devices is convenient\n to enable flash prefetch buffer.\nTo be enabled by default, possible to disable using kconfig. Please fix this issue.",
  "input": "Faulty tokenized code:\n\thelp\n\t  Initialization priority of the routine within the PRE_KERNEL1 level.\n\t  This priority must be greater than GPIO_INIT_PRIORITY and lower than\n\t  UART_INIT_PRIORITY.\n\nchoice POWER_SUPPLY_CHOICE\n\tprompt \"STM32 power supply configuration\"\n\tdefault POWER_SUPPLY_LDO\n\tdepends on SOC_SERIES_STM32H7X || SOC_SERIES_STM32U5X || \\\n\t\t   SOC_STM32WBA55XX\nrsource \"Kconfig.defconfig.stm32wba*\"\n\nconfig STM32_LPTIM_TIMER\n\tdefault y if PM\n\nchoice BT_HCI_BUS_TYPE\n\tdefault BT_STM32WBA\n\tdepends on BT\nendchoice\n\nargument_list|)\nexpr_stmt|;\nname|LL_ICACHE_Enable\nargument_list|()\nexpr_stmt|;\ncomment|/* Update CMSIS SystemCoreClock variable (HCLK) */\ncomment|/* At reset, system core clock is set to 16 MHz from HSI */\nname|SystemCoreClock\noperator|=\nliteral|16000000",
  "result": "I corrected the issue in the code by changing the following tokens:\n+config STM32_FLASH_PREFETCH\n+\tbool \"Flash prefetch buffer\"\n+\n+config STM32_FLASH_PREFETCH\n+\tdefault y\n+\n+ifdef|#\n+directive|ifdef\n+name|CONFIG_STM32_FLASH_PREFETCH\n+name|__HAL_FLASH_PREFETCH_BUFFER_ENABLE\n+argument_list|()\n+expr_stmt|;\n+endif|#\n+directive|endif\nThe issue was with: soc: st: stm32: adding option to enable prefetch buffer\n\nFor more effective code execution on STM32 devices is convenient\n to enable flash prefetch buffer.\nTo be enabled by default, possible to disable using kconfig."
},{
  "instruction": "There is an issue in the following code. It relates to ipc_service: backends: icbmsg: Silence maybe-uninitialized warning\n\nIf compiling with optimizations (-O2/-Ofast) gcc emits a\nmaybe-uninitialized warning for `size`.\n\nAs far as I can tell, `size` will always be initialized in the cases\nwhere it is used and only left uninitialized in error cases.\n\nReproduced on main with the multi_endpoint sample on\nnrf5340dk/nrf5340/cpuapp. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|conf\ndecl_stmt|;\nname|size_t\nname|size\ndecl_stmt|;\nname|int\nname|tx_block_index\ndecl_stmt|;\nname|tx_block_index",
  "result": "I corrected the issue in the code by changing the following tokens:\n+init|=\n+literal|0\nThe issue was with: ipc_service: backends: icbmsg: Silence maybe-uninitialized warning\n\nIf compiling with optimizations (-O2/-Ofast) gcc emits a\nmaybe-uninitialized warning for `size`.\n\nAs far as I can tell, `size` will always be initialized in the cases\nwhere it is used and only left uninitialized in error cases.\n\nReproduced on main with the multi_endpoint sample on\nnrf5340dk/nrf5340/cpuapp."
},{
  "instruction": "There is an issue in the following code. It relates to boards: nrf*bsim: Disable ubsan in bst_install\n\nUBSAN reports a bogus error in this function:\n\\\"load of address x with insufficient space for an\nobject of type '<unknown> *'\\\"\nas it seems unable to determine the size of\ntest_installers.\nLet's disable this check in this function. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nend_function\n\nbegin_function\nDECL|function|bst_install_tests (void)\nname|void\nname|bst_install_tests\nparameter_list|(\nname|void\nparameter_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|__noubsan\nThe issue was with: boards: nrf*bsim: Disable ubsan in bst_install\n\nUBSAN reports a bogus error in this function:\n\\\"load of address x with insufficient space for an\nobject of type '<unknown> *'\\\"\nas it seems unable to determine the size of\ntest_installers.\nLet's disable this check in this function."
},{
  "instruction": "There is an issue in the following code. It relates to tests: Update iterable sections test\n\nUpdates the test_ram/test_rom structures to use a 'long' instead\nof an 'int' so that the structure sizes will be 4-bytes on 32-bit\nplatforms and 8-bytes on 64-bit platforms. Please fix this issue.",
  "input": "Faulty tokenized code:\nDECL|struct|test_ram\nstruct|struct\nname|test_ram\nblock|{\nDECL|member|i\nname|int\nname|i\ndecl_stmt|;\nblock|}\nstruct|;\nend_struct\nDECL|struct|test_ram_named\nstruct|struct\nname|test_ram_named\nblock|{\nDECL|member|i\nname|int\nname|i\ndecl_stmt|;\nblock|}\nstruct|;\nend_struct\nDECL|struct|test_ram_numeric\nstruct|struct\nname|test_ram_numeric\nblock|{\nDECL|member|i\nname|int\nname|i\ndecl_stmt|;\nblock|}\nstruct|;\nend_struct\nDECL|struct|test_rom\nstruct|struct\nname|test_rom\nblock|{\nDECL|member|i\nname|int\nname|i\ndecl_stmt|;\nblock|}\nstruct|;\nend_struct\nDECL|struct|test_rom_named\nstruct|struct\nname|test_rom_named\nblock|{\nDECL|member|i\nname|int\nname|i\ndecl_stmt|;\nblock|}\nstruct|;\nend_struct\nDECL|struct|test_rom_numeric\nstruct|struct\nname|test_rom_numeric\nblock|{\nDECL|member|i\nname|int\nname|i\ndecl_stmt|;\nblock|}\nstruct|;\nend_struct",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|int\n+name|long\n-name|int\n+name|long\n-name|int\n+name|long\n-name|int\n+name|long\n-name|int\n+name|long\n-name|int\n+name|long\nThe issue was with: tests: Update iterable sections test\n\nUpdates the test_ram/test_rom structures to use a 'long' instead\nof an 'int' so that the structure sizes will be 4-bytes on 32-bit\nplatforms and 8-bytes on 64-bit platforms."
},{
  "instruction": "There is an issue in the following code. It relates to logging: Fix backend filter setting\n\nCall filter_set with backend-id instead of backend-index\nwhen applying a filter on all backends. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|uint32_t\nname|current\ninit|=\nname|filter_set\nargument_list|(\nname|i\nargument_list|,\nname|domain_id\nargument_list|,\nname|source_id\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|log_backend_id_get\n+argument_list|(\n+name|log_backend_get\n+argument_list|(\n+argument_list|)\n+argument_list|)\nThe issue was with: logging: Fix backend filter setting\n\nCall filter_set with backend-id instead of backend-index\nwhen applying a filter on all backends."
},{
  "instruction": "There is an issue in the following code. It relates to net: if: Do not add IPv6 address lifetime timer twice to list\n\nThe IPv6 address lifetime timers are kept in a slist, but\nthe code that adds the entry to the list does not check\nwhether the item is already in the list. This will cause\nproblems when trying to remove the address from the list.\n\nNormally this is not causing issues, but if the function\nnet_if_ipv6_addr_update_lifetime() is called multiple times\nbefore the address expires, then the item was added to the\nslist multiple times. Please fix this issue.",
  "input": "Faulty tokenized code:\nendif|#\ndirective|endif\nend_endif\n\nbegin_struct\nDECL|struct|__anon2bd307ad0108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|ipv6\nname|struct\nname|CONFIG_NET_NATIVE_IPV4\nargument_list|)\nend_if\n\nbegin_struct\nDECL|struct|__anon2bd307ad0208\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|ipv4\nname|struct\nparameter_list|,\nname|uint32_t\nname|vlifetime\nparameter_list|)\nblock|{\nname|sys_slist_append\nargument_list|(\noperator|&\nname|active_address_lifetime_timers\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2bd307ad0108\n+DECL|struct|__anon2b2d30b50108\n-DECL|struct|__anon2bd307ad0208\n+DECL|struct|__anon2b2d30b50208\n+comment|/* Make sure that we do not insert the address twice to \t * the lifetime timer list. \t */\n+name|sys_slist_find_and_remove\n+argument_list|(\n+operator|&\n+name|active_address_lifetime_timers\n+argument_list|,\n+operator|&\n+name|ifaddr\n+operator|->\n+name|lifetime\n+operator|.\n+name|node\n+argument_list|)\n+expr_stmt|;\nThe issue was with: net: if: Do not add IPv6 address lifetime timer twice to list\n\nThe IPv6 address lifetime timers are kept in a slist, but\nthe code that adds the entry to the list does not check\nwhether the item is already in the list. This will cause\nproblems when trying to remove the address from the list.\n\nNormally this is not causing issues, but if the function\nnet_if_ipv6_addr_update_lifetime() is called multiple times\nbefore the address expires, then the item was added to the\nslist multiple times."
},{
  "instruction": "There is an issue in the following code. It relates to drivers/timer grtc: Fix for ISR prototype\n\nInterrupt handlers are expected to have a pototype\nvoid (const void*)\nbut nrfx_grtc_irq_handler has just a void(void)\n(with no input parameter).\nFix it by using a trampoline. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|GRTC_NODE\nargument_list|,\nname|priority\nargument_list|)\nargument_list|,\nname|nrfx_grtc_irq_handler\nargument_list|,\nliteral|0\nargument_list|,\nliteral|0\nargument_list|)\nexpr_stmt|;\nname|err_code",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|nrfx_grtc_irq_handler\n+name|nrfx_isr\n-literal|0\n+name|nrfx_grtc_irq_handler\nThe issue was with: drivers/timer grtc: Fix for ISR prototype\n\nInterrupt handlers are expected to have a pototype\nvoid (const void*)\nbut nrfx_grtc_irq_handler has just a void(void)\n(with no input parameter).\nFix it by using a trampoline."
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: uart: uart_elementary: Fix RX handling\n\nRx_byte_offset was wrongly updated which could lead to test\nfailures. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|int\nname|rx_data_length\ninit|=\nliteral|0\ndecl_stmt|;\nname|int\nname|bytes_received\ninit|=\nliteral|0\ndecl_stmt|;\ndo|do\nblock|{\nname|rx_data_length\noperator|=\nname|uart_fifo_read\nname|rx_byte_offset\nargument_list|,\nname|TEST_BUFFER_LEN\nargument_list|)\nexpr_stmt|;\nname|bytes_received\noperator|+=\nname|rx_data_length\nexpr_stmt|;\nblock|}\ndo|while\ncondition|(\nname|rx_data_length\ncondition|)\ndo|;\noperator|*\nname|rx_byte_offset\noperator|+=\nname|bytes_received\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_comment\ncomment|/*  * Callback function for MAIN UART interrupt based transmission test  */",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|int\n-name|bytes_received\n-init|=\n-literal|0\n-decl_stmt|;\n-name|bytes_received\n+operator|*\n+name|rx_byte_offset\n-operator|*\n-name|rx_byte_offset\n-operator|+=\n-name|bytes_received\n-expr_stmt|;\nThe issue was with: tests: drivers: uart: uart_elementary: Fix RX handling\n\nRx_byte_offset was wrongly updated which could lead to test\nfailures."
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: uart: uart_pm: Minor adjustments in the test\n\nModifying arbitrary delay to cover for receivers with timeout.\nAdding a delay between polling and asynchronous checking to cover\nfor cases when CPU processing is fast enough so that both checks\nmay overlap.\nAllow error code for uart_rx_disable call. Please fix this issue.",
  "input": "Faulty tokenized code:\nindex|[\nname|i\nindex|]\nargument_list|)\nexpr_stmt|;\nname|k_busy_wait\nargument_list|(\nliteral|1000\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|active\nliteral|\"Unexpected err: %d\"\nargument_list|,\nname|err\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\noperator|!\nname|DISABLED_RX\ncondition|)\nname|uart_rx_disable\nargument_list|(\nname|dev\nargument_list|)\nexpr_stmt|;\nname|zassert_equal\nargument_list|(\nname|err\nargument_list|,\nliteral|0\nargument_list|,\nliteral|\"Unexpected err: %d\"\nargument_list|,\nname|err\nargument_list|)\nexpr_stmt|;\nname|k_busy_wait\nargument_list|(\nliteral|10000",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* We need to wait until receiver gets the data. Receiver may have \t\t * RX timeout so data is not received instantly. \t\t */\n-literal|1000\n+literal|5000\n+comment|/* Wait a bit to ensure that polling transfer is already finished otherwise \t * receiver might be enabled when there is an ongoing transfer and bytes \t * will get corrupted. \t */\n+name|k_busy_wait\n+argument_list|(\n+literal|1000\n+argument_list|)\n+expr_stmt|;\n-name|zassert_equal\n+name|zassert_true\n+operator|(\n-argument_list|,\n+operator|==\n-argument_list|,\n-literal|\"Unexpected err: %d\"\n-argument_list|,\n+operator|)\n+operator|||\n+operator|(\n+operator|==\n+operator|-\n+name|EFAULT\n+operator|)\nThe issue was with: tests: drivers: uart: uart_pm: Minor adjustments in the test\n\nModifying arbitrary delay to cover for receivers with timeout.\nAdding a delay between polling and asynchronous checking to cover\nfor cases when CPU processing is fast enough so that both checks\nmay overlap.\nAllow error code for uart_rx_disable call."
},{
  "instruction": "There is an issue in the following code. It relates to wifi: shell: Support WPA auto personal security mode\n\nApplications need to run a scan to identify the security\nmode before attempting the connection which adds to the time\ntaken for connection to be established.\nTo avoid the initial scan, support auto security mode which will\nenable STA to choose between WPA, WPA2 and WPA3, based on the\nnetwork configuration. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|,\ncomment|/** WPA-PSK security. */\nDECL|enumerator|WIFI_SECURITY_TYPE_WPA_PSK\nname|WIFI_SECURITY_TYPE_WPA_PSK\nblock|,\nDECL|enumerator|__WIFI_SECURITY_TYPE_AFTER_LAST\nname|__WIFI_SECURITY_TYPE_AFTER_LAST\nblock|,\nDECL|enumerator|WIFI_SECURITY_TYPE_MAX\nname|WIFI_SECURITY_TYPE_MAX\nname|params\noperator|->\nname|security\noperator|==\nname|WIFI_SECURITY_TYPE_PSK_SHA256\noperator|)\noperator|&&\noperator|(\noperator|(\nname|params\nname|MAX_BANDS_STR_LEN\nvalue|64\nend_define\n\nbegin_struct\nDECL|struct|__anon27aff8b20108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\ndecl_stmt|;\nDECL|member|scan_result\nname|uint32_t\nname|scan_result\ndecl_stmt|;\nDECL|union|__anon27aff8b2020a\nunion|union\nblock|{\nDECL|struct|__anon27aff8b20308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\nliteral|\"Connect to a Wi-Fi AP\\n\"\nliteral|\"<-s --ssid \\\"<SSID>\\\">: SSID.\\n\"\nliteral|\"[-c --channel]: Channel that needs to be scanned for connection. 0:any channel.\\n\"\nliteral|\"[-b, --band] 0: any band (2:2.4GHz, 5:5GHz, 6:6GHz]\\n\"\nliteral|\"[-p, --psk]: Passphrase (valid only for secure SSIDs)\\n\"\nliteral|\"[-k, --key-mgmt]: Key Management type\\n\"\nliteral|\"0:None, 1:WPA2-PSK, 2:WPA2-PSK-256, 3:SAE, 4:WAPI, 5:EAP, 6:WEP, 7: WPA-PSK\\n\"\nliteral|\"[-w, --ieee-80211w]: MFP (optional: needs security type to be specified)\\n\"\nliteral|\": 0:Disable, 1:Optional, 2:Required.\\n\"\nliteral|\"[-m, --bssid]: MAC address of the AP (BSSID).\\n\"\nliteral|\"[-h, --help]: Print out the help for the connect command.\\n\"\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/** WPA/WPA2/WPA3 PSK security. */\n+DECL|enumerator|WIFI_SECURITY_TYPE_WPA_AUTO_PERSONAL\n+name|WIFI_SECURITY_TYPE_WPA_AUTO_PERSONAL\n+block|,\n+operator|||\n+name|params\n+operator|->\n+name|security\n+operator|==\n+name|WIFI_SECURITY_TYPE_WPA_AUTO_PERSONAL\n-DECL|struct|__anon27aff8b20108\n+DECL|struct|__anon288a6e040108\n-DECL|union|__anon27aff8b2020a\n+DECL|union|__anon288a6e04020a\n-DECL|struct|__anon27aff8b20308\n+DECL|struct|__anon288a6e040308\n-literal|\"[-k, --key-mgmt]: Key Management type\\n\"\n-literal|\"0:None, 1:WPA2-PSK, 2:WPA2-PSK-256, 3:SAE, 4:WAPI, 5:EAP, 6:WEP, 7: WPA-PSK\\n\"\n+literal|\"[-k, --key-mgmt]: Key Management type (valid only for secure SSIDs)\\n\"\n+literal|\"0:None, 1:WPA2-PSK, 2:WPA2-PSK-256, 3:SAE, 4:WAPI, 5:EAP, 6:WEP,\"\n+literal|\" 7: WPA-PSK, 8: WPA-Auto-Personal\\n\"\nThe issue was with: wifi: shell: Support WPA auto personal security mode\n\nApplications need to run a scan to identify the security\nmode before attempting the connection which adds to the time\ntaken for connection to be established.\nTo avoid the initial scan, support auto security mode which will\nenable STA to choose between WPA, WPA2 and WPA3, based on the\nnetwork configuration."
},{
  "instruction": "There is an issue in the following code. It relates to mgmt: hawkbit: change Kconfig port to int\n\nPorts set by Kconfig are mostly defined\nas a int. This changes it for hawkbit too. Please fix this issue.",
  "input": "Faulty tokenized code:\n\tdefault \"\"\n\thelp\n\t  Configure the hawkbit server address.\n\nconfig HAWKBIT_PORT\n\tstring \"Port address for the hawkbit server\"\n\tdefault \"8080\"\n\thelp\n\t  Configure the hawkbit port number.\n\nchoice HAWKBIT_DDI_SECURITY\n\tprompt \"hawkBit DDI API authentication modes\"\nname|hb_context\nstruct|;\nend_struct\n\nbegin_union\nDECL|union|__anon2bc18166010a\nspecifier|static\nunion|union\nblock|{\nDECL|member|dep\nname|struct\noperator|=\nname|zsock_getaddrinfo\nargument_list|(\nname|CONFIG_HAWKBIT_SERVER\nargument_list|,\nname|CONFIG_HAWKBIT_PORT\nargument_list|,\noperator|&\nname|hints\nargument_list|,\noperator|&\noperator|.\nname|http_req\noperator|.\nname|port\noperator|=\nname|CONFIG_HAWKBIT_PORT\nexpr_stmt|;\nname|hb_context\noperator|.\nname|http_req\noperator|.",
  "result": "I corrected the issue in the code by changing the following tokens:\n-\tstring \"Port address for the hawkbit server\"\n-\tdefault \"8080\"\n+\tint \"Port number for the hawkbit server\"\n+\tdefault 8080\n-DECL|union|__anon2bc18166010a\n+DECL|union|__anon297d519f010a\n+name|STRINGIFY\n+argument_list|(\n+argument_list|)\n+name|STRINGIFY\n+argument_list|(\n+argument_list|)\nThe issue was with: mgmt: hawkbit: change Kconfig port to int\n\nPorts set by Kconfig are mostly defined\nas a int. This changes it for hawkbit too."
},{
  "instruction": "There is an issue in the following code. It relates to fs: ext2: Fix removing indirect blocks\n\nThis commit fixes removing indirect blocks (marking them as 0)\nin the inode structure. Previous version of the code was removing\nthe top-level blocks only when the first removed block was\none of the first 12 direct blocks. However, when the first removed\nblock is the first block in the referenced block list, its parent\n(indirect block) should also be removed. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nif|if\ncondition|(\nname|all_zero\nargument_list|(\nname|offsets\nargument_list|,\nname|max_lvl\nargument_list|)\ncondition|)\nblock|{\ncomment|/* We remove also the first block because all blocks referenced from it will be \t\t * deleted. \t\t */\nname|start\noperator|=\nname|offsets\nindex|[\nliteral|0",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|&\n+index|[\n+literal|1\n+index|]\n-comment|/* We remove also the first block because all blocks referenced from it will be \t\t * deleted. \t\t */\n+comment|/* The first block to remove is either: \t\t *  - one of the first 12 blocks in the indode \t\t *  - the first referenced block in the indirect block list; \t\t *    we remove also the indirect block \t\t */\nThe issue was with: fs: ext2: Fix removing indirect blocks\n\nThis commit fixes removing indirect blocks (marking them as 0)\nin the inode structure. Previous version of the code was removing\nthe top-level blocks only when the first removed block was\none of the first 12 direct blocks. However, when the first removed\nblock is the first block in the referenced block list, its parent\n(indirect block) should also be removed."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: fpga: shell: add shell load error handling\n\nCheck if the call was successful, print an error otherwise. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|dev\noperator|->\nname|name\nargument_list|)\nexpr_stmt|;\nname|fpga_load\nargument_list|(\nname|dev\nargument_list|,\noperator|(\nliteral|3\nindex|]\nargument_list|)\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|err\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|err\n+operator|=\n+if|if\n+condition|(\n+name|err\n+condition|)\n+block|{\n+name|shell_error\n+argument_list|(\n+name|sh\n+argument_list|,\n+literal|\"Error: %d\"\n+argument_list|,\n+name|err\n+argument_list|)\n+expr_stmt|;\n+block|}\nThe issue was with: drivers: fpga: shell: add shell load error handling\n\nCheck if the call was successful, print an error otherwise."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: net: nsos: pass addrlen by value in sockaddr_to_nsos_mid()\n\nThere is no reason to pass addrlen by pointer, since it is a read-only in\nthe context of sockaddr_to_nsos_mid(). Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|sockaddr_to_nsos_mid (const struct sockaddr * addr,socklen_t * addrlen,struct nsos_mid_sockaddr ** addr_mid,size_t * addrlen_mid)\nspecifier|static\nname|int\nname|sockaddr_to_nsos_mid\nparameter_list|(\nspecifier|const\nname|sockaddr\nmodifier|*\nname|addr\nparameter_list|,\nname|socklen_t\nmodifier|*\nname|addrlen\nparameter_list|,\nname|struct\nname|nsos_mid_sockaddr\nmodifier|*\noperator|*\nname|addr_mid\ndecl_stmt|;\nif|if\ncondition|(\noperator|*\nname|addrlen\noperator|<\nsizeof|sizeof\nargument_list|(\noperator|*\noperator|*\nname|addr_mid\ndecl_stmt|;\nif|if\ncondition|(\noperator|*\nname|addrlen\noperator|<\nsizeof|sizeof\nargument_list|(\noperator|*\noperator|=\nname|sockaddr_to_nsos_mid\nargument_list|(\nname|addr\nargument_list|,\noperator|&\nname|addrlen\nargument_list|,\noperator|&\nname|addr_mid\nargument_list|,\noperator|=\nname|sockaddr_to_nsos_mid\nargument_list|(\nname|addr\nargument_list|,\noperator|&\nname|addrlen\nargument_list|,\noperator|&\nname|addr_mid\nargument_list|,\noperator|=\nname|sockaddr_to_nsos_mid\nargument_list|(\nname|addr\nargument_list|,\noperator|&\nname|addrlen\nargument_list|,\noperator|&\nname|addr_mid\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|sockaddr_to_nsos_mid (const struct sockaddr * addr,socklen_t * addrlen,struct nsos_mid_sockaddr ** addr_mid,size_t * addrlen_mid)\n+DECL|function|sockaddr_to_nsos_mid (const struct sockaddr * addr,socklen_t addrlen,struct nsos_mid_sockaddr ** addr_mid,size_t * addrlen_mid)\n-modifier|*\n-operator|*\n-operator|*\n-operator|&\n-operator|&\n-operator|&\nThe issue was with: drivers: net: nsos: pass addrlen by value in sockaddr_to_nsos_mid()\n\nThere is no reason to pass addrlen by pointer, since it is a read-only in\nthe context of sockaddr_to_nsos_mid()."
},{
  "instruction": "There is an issue in the following code. It relates to net: wifi: shell: Remove redundant break\n\nHaving a `break` statement after `return` is redundant and\nneeds to be removed. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|MAX_BANDS_STR_LEN\nvalue|64\nend_define\n\nbegin_struct\nDECL|struct|__anon2c48a8e30108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\ndecl_stmt|;\nDECL|member|scan_result\nname|uint32_t\nname|scan_result\ndecl_stmt|;\nDECL|union|__anon2c48a8e3020a\nunion|union\nblock|{\nDECL|struct|__anon2c48a8e30308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\ncase|:\nreturn|return\noperator|-\nname|ENOEXEC\nreturn|;\nbreak|break;\ndefault|default:\nname|PR_ERROR\nargument_list|(\nliteral|\"Invalid option %c\\n\"\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2c48a8e30108\n+DECL|struct|__anon2ad7f8e00108\n-DECL|union|__anon2c48a8e3020a\n+DECL|union|__anon2ad7f8e0020a\n-DECL|struct|__anon2c48a8e30308\n+DECL|struct|__anon2ad7f8e00308\n-break|break;\nThe issue was with: net: wifi: shell: Remove redundant break\n\nHaving a `break` statement after `return` is redundant and\nneeds to be removed."
},{
  "instruction": "There is an issue in the following code. It relates to net: wifi: shell: Correct help text for `connect` command\n\nSince `NONE` is a valid option for key management in `connect`\ncommand, we should remove the part in help text which says:\n\\\"valid only for secure SSIDs\\\". Please fix this issue.",
  "input": "Faulty tokenized code:\nname|MAX_BANDS_STR_LEN\nvalue|64\nend_define\n\nbegin_struct\nDECL|struct|__anon28c967410108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\ndecl_stmt|;\nDECL|member|scan_result\nname|uint32_t\nname|scan_result\ndecl_stmt|;\nDECL|union|__anon28c96741020a\nunion|union\nblock|{\nDECL|struct|__anon28c967410308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\nliteral|\"Connect to a Wi-Fi AP\\n\"\nliteral|\"<-s --ssid \\\"<SSID>\\\">: SSID.\\n\"\nliteral|\"[-c --channel]: Channel that needs to be scanned for connection. 0:any channel.\\n\"\nliteral|\"[-b, --band] 0: any band (2:2.4GHz, 5:5GHz, 6:6GHz]\\n\"\nliteral|\"[-p, --psk]: Passphrase (valid only for secure SSIDs)\\n\"\nliteral|\"[-k, --key-mgmt]: Key Management type (valid only for secure SSIDs)\\n\"\nliteral|\"0:None, 1:WPA2-PSK, 2:WPA2-PSK-256, 3:SAE, 4:WAPI, 5:EAP, 6:WEP, 7: WPA-PSK\\n\"\nliteral|\"[-w, --ieee-80211w]: MFP (optional: needs security type to be specified)\\n\"\nliteral|\": 0:Disable, 1:Optional, 2:Required.\\n\"\nliteral|\"[-m, --bssid]: MAC address of the AP (BSSID).\\n\"\nliteral|\"[-h, --help]: Print out the help for the connect command.\\n\"",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon28c967410108\n+DECL|struct|__anon2c48a8e30108\n-DECL|union|__anon28c96741020a\n+DECL|union|__anon2c48a8e3020a\n-DECL|struct|__anon28c967410308\n+DECL|struct|__anon2c48a8e30308\n-literal|\"[-k, --key-mgmt]: Key Management type (valid only for secure SSIDs)\\n\"\n+literal|\"[-k, --key-mgmt]: Key Management type\\n\"\nThe issue was with: net: wifi: shell: Correct help text for `connect` command\n\nSince `NONE` is a valid option for key management in `connect`\ncommand, we should remove the part in help text which says:\n\\\"valid only for secure SSIDs\\\"."
},{
  "instruction": "There is an issue in the following code. It relates to driver: udc: trigger queued transfer on halt clear\n\nSubmit USBFSOTG_EVT_XFER on halt clear to allow queued\ntransfers to execute as soon as endpoint STALL is cleared. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_struct\nDECL|struct|usbfsotg_bd\nstruct|struct\nname|usbfsotg_bd\nblock|{\nDECL|union|__anon27b45e1c010a\nunion|union\nblock|{\nDECL|member|bd_fields\nname|uint32_t\nname|bd_fields\ndecl_stmt|;\nDECL|struct|__anon27b45e1c0208\nstruct|struct\nblock|{\nDECL|member|reserved_1_0\nname|uint32_t\nname|reserved_1_0\nDECL|member|__packed\nblock|}\nname|get\nname|__packed\nstruct|;\nDECL|struct|__anon27b45e1c0308\nstruct|struct\nblock|{\nDECL|member|reserved_1_0\nname|uint32_t\nname|reserved_1_0\nargument_list|)\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\ncomment|/* TODO: trigger queued transfers? */\nblock|}\nreturn|return\nliteral|0\nreturn|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon27b45e1c010a\n+DECL|union|__anon279f3877010a\n-DECL|struct|__anon27b45e1c0208\n+DECL|struct|__anon279f38770208\n-DECL|struct|__anon27b45e1c0308\n+DECL|struct|__anon279f38770308\n-comment|/* TODO: trigger queued transfers? */\n+comment|/* trigger queued transfers */\n+name|usbfsotg_event_submit\n+argument_list|(\n+name|dev\n+argument_list|,\n+name|cfg\n+operator|->\n+name|addr\n+argument_list|,\n+name|USBFSOTG_EVT_XFER\n+argument_list|)\n+expr_stmt|;\nThe issue was with: driver: udc: trigger queued transfer on halt clear\n\nSubmit USBFSOTG_EVT_XFER on halt clear to allow queued\ntransfers to execute as soon as endpoint STALL is cleared."
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: counter: nrf_rtc: Add nrf52_bsim overlay and adapt test\n\nAdd overlay for nrf52_bsim to the fixed_top test.\nFor bsim board RTC register address has to be translated. Please fix this issue.",
  "input": "Faulty tokenized code:\nnew file mode 100644\nname|flags\noperator|=\nliteral|0\nblock|}\ndecl_stmt|;\nname|top_cfg\noperator|.\nname|ticks\noperator|=\nname|counter_get_max_top_value",
  "result": "I corrected the issue in the code by changing the following tokens:\n+&rtc0 {\n+\tstatus = \"okay\";\n+\tfixed-top;\n+};\n+&rtc2 {\n+\tstatus = \"okay\";\n+\tfixed-top;\n+};\n+if|#\n+directive|if\n+name|defined\n+argument_list|(\n+name|CONFIG_SOC_SERIES_BSIM_NRFXX\n+argument_list|)\n+comment|/* For simulated devices we need to convert the hardcoded DT address from the real \t * peripheral into the correct one for simulation \t */\n+name|reg\n+operator|=\n+name|nhw_convert_periph_base_addr\n+argument_list|(\n+name|reg\n+argument_list|)\n+expr_stmt|;\n+endif|#\n+directive|endif\nThe issue was with: tests: drivers: counter: nrf_rtc: Add nrf52_bsim overlay and adapt test\n\nAdd overlay for nrf52_bsim to the fixed_top test.\nFor bsim board RTC register address has to be translated."
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: counter: nrf_rtc: Fail if no devices\n\nTest was passing if there were no RTCs enabled given the false positive. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|(\nname|counter_test_func_t\nname|func\nparameter_list|)\nblock|{\nfor|for\ncontrol|(\nname|int\nname|i\ninit|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|zassert_true\n+argument_list|(\n+name|ARRAY_SIZE\n+argument_list|(\n+name|devices\n+argument_list|)\n+operator|>\n+literal|0\n+argument_list|)\n+expr_stmt|;\nThe issue was with: tests: drivers: counter: nrf_rtc: Fail if no devices\n\nTest was passing if there were no RTCs enabled given the false positive."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: Fix UBSan error\n\nUBSan was showing the following error:\n\n```\nruntime error: left shift of 137 by 24 places cannot be represented in\ntype 'int'\n```\n\nCast the value to `uint32_t` to make UBSan happy. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|NRF_RADIO\noperator|->\nname|BASE0\noperator|=\noperator|(\nname|aa\nindex|[\nliteral|2\nindex|]\noperator|<<\nliteral|24\noperator|)\noperator||\noperator|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+operator|(\n+name|uint32_t\n+operator|)\n+operator|)\nThe issue was with: Bluetooth: Controller: Fix UBSan error\n\nUBSan was showing the following error:\n\n```\nruntime error: left shift of 137 by 24 places cannot be represented in\ntype 'int'\n```\n\nCast the value to `uint32_t` to make UBSan happy."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Remove rx < tx prio check\n\nThe comment states the reason for this requirement is to detect\nviolations by a remote peer. The ATT version of this was removed in\na6d3b2ad4638127cc3f0f6db0a01d2c968d1bd59 [formerly ea04fd95f939b8115358560df5887bb5f2baeab8]. TLDR: It's neither possible\nfor, nor the job of the host to police the remote device.\n\nWe remove this requirement to be more flexible about the number of\npriority levels in the system, and to avoid the temptation of using\npriorities as a synchronization mechanism. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|CONFIG_BT_HCI_HOST\nargument_list|)\nend_if\n\nbegin_comment\ncomment|/* The Bluetooth subsystem requires the Tx thread to execute at higher priority  * than the Rx thread as the Tx thread needs to process the acknowledgements  * before new Rx data is processed. This is a necessity to correctly detect  * transaction violations in ATT and SMP protocols.  */\nend_comment\n\nbegin_expr_stmt\nname|BUILD_ASSERT\nargument_list|(\nname|CONFIG_BT_HCI_TX_PRIO\noperator|<\nname|CONFIG_BT_RX_PRIO\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_comment\ncomment|/* The Bluetooth subsystem requires that higher priority events shall be given  * in a priority higher than the Bluetooth Host's Tx and the Controller's  * receive thread priority.  * This is required in order to dispatch Number of Completed Packets event  * before any new data arrives on a connection to the Host threads.  */\nend_comment\n\nbegin_expr_stmt",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_comment\n-comment|/* The Bluetooth subsystem requires the Tx thread to execute at higher priority  * than the Rx thread as the Tx thread needs to process the acknowledgements  * before new Rx data is processed. This is a necessity to correctly detect  * transaction violations in ATT and SMP protocols.  */\n-end_comment\n-\n-begin_expr_stmt\n-name|BUILD_ASSERT\n-argument_list|(\n-name|CONFIG_BT_HCI_TX_PRIO\n-operator|<\n-name|CONFIG_BT_RX_PRIO\n-argument_list|)\n-expr_stmt|;\n-end_expr_stmt\n-\nThe issue was with: Bluetooth: Remove rx < tx prio check\n\nThe comment states the reason for this requirement is to detect\nviolations by a remote peer. The ATT version of this was removed in\na6d3b2ad4638127cc3f0f6db0a01d2c968d1bd59 [formerly ea04fd95f939b8115358560df5887bb5f2baeab8]. TLDR: It's neither possible\nfor, nor the job of the host to police the remote device.\n\nWe remove this requirement to be more flexible about the number of\npriority levels in the system, and to avoid the temptation of using\npriorities as a synchronization mechanism."
},{
  "instruction": "There is an issue in the following code. It relates to samples/net socket_echo: Fix pointer type\n\nThe last parameter to getsockopt() should be a socklen_t *\nnot an int *.\nLet's fix it to avoid a build warning which breaks this tests\nin CI. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|void\nparameter_list|)\nblock|{\nname|int\nname|opt\ndecl_stmt|,\nname|optlen\ninit|=\nsizeof|sizeof\nargument_list|(\nname|int",
  "result": "I corrected the issue in the code by changing the following tokens:\n-decl_stmt|,\n+decl_stmt|;\n+name|socklen_t\nThe issue was with: samples/net socket_echo: Fix pointer type\n\nThe last parameter to getsockopt() should be a socklen_t *\nnot an int *.\nLet's fix it to avoid a build warning which breaks this tests\nin CI."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: nxp_enet: Correct PTP clock dependencies\n\nThe dependencies should be in a 'depends on' clause.\nAlso, 'depends on PTP_CLOCK' is redundant because this is\nwithin 'if PTP_CLOCK' already.\n\nAdditionally, conditionally include the PTP header in the mac driver. Please fix this issue.",
  "input": "Faulty tokenized code:\n# Copyright 2023 NXP\n# SPDX-License-Identifier: Apache-2.0\n\nconfig PTP_CLOCK_NXP_ENET\n\tbool \"NXP ENET PTP Clock driver\"\n\tdefault y if DT_HAS_NXP_ENET_PTP_CLOCK_ENABLED && \\\n\t\t\t(PTP_CLOCK || NET_L2_PTP)\n\thelp\n\t  Enable NXP ENET PTP clock support.\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_PTP_CLOCK_MCUX\nargument_list|)\noperator|.\nname|enableClkOutput25M\noperator|=\nname|true\nblock|,\ndirective|endif\nendif|#\ndirective|endif\nendif|#\ndirective|endif\nifdef|#\ndirective|ifdef\nname|CONFIG_PTP_CLOCK_MCUX\ncomment|/* 24MHz PTP clock */\nname|rootCfg\noperator|.\nname|mux\noperator|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n-\tdefault y if DT_HAS_NXP_ENET_PTP_CLOCK_ENABLED && \\\n-\t\t\t(PTP_CLOCK || NET_L2_PTP)\n+\tdefault y\n+\tdepends on DT_HAS_NXP_ENET_PTP_CLOCK_ENABLED && NET_L2_PTP\n+operator|||\n+name|defined\n+argument_list|(\n+name|CONFIG_PTP_CLOCK_NXP_ENET\n+argument_list|)\n-ifdef|#\n-directive|ifdef\n+if|#\n+directive|if\n+name|defined\n+argument_list|(\n+argument_list|)\n+operator|||\n+name|defined\n+argument_list|(\n+name|CONFIG_PTP_CLOCK_NXP_ENET\n+argument_list|)\nThe issue was with: drivers: nxp_enet: Correct PTP clock dependencies\n\nThe dependencies should be in a 'depends on' clause.\nAlso, 'depends on PTP_CLOCK' is redundant because this is\nwithin 'if PTP_CLOCK' already.\n\nAdditionally, conditionally include the PTP header in the mac driver."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: clock_control: mcux_sim: PTP clock\n\nAdd PTP clock get rate code Please fix this issue.",
  "input": "Faulty tokenized code:\nname|clock_name\noperator|=\nname|kCLOCK_CoreSysClk\nexpr_stmt|;\nbreak|break;\ndefault|default:\nname|clock_name\noperator|=\noperator|(\nname|clock_name_t\ndirective|define\nname|KINETIS_SIM_ENET_CLK\nvalue|4321\nend_define\n\nbegin_endif\nendif|#\ndirective|endif\nend_endif\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n+case|case\n+name|KINETIS_SIM_ENET_1588_CLK\n+case|:\n+name|clock_name\n+operator|=\n+name|kCLOCK_Osc0ErClk\n+expr_stmt|;\n+break|break;\n+begin_define\n+DECL|macro|KINETIS_SIM_ENET_1588_CLK\n+define|#\n+directive|define\n+name|KINETIS_SIM_ENET_1588_CLK\n+value|4322\n+end_define\n+\nThe issue was with: drivers: clock_control: mcux_sim: PTP clock\n\nAdd PTP clock get rate code"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: nrfx_uarte2: Clean error state on rx_enable\n\nClean error state on re-enabling RX. If previous transmission ended with\nan error it should not impact next receiving session. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nblock|}\ncomment|/* Store the buffer. It will be passed to the driver in the event handler. \t * We do that instead of calling nrfx_uarte_rx_buffer_set here to ensure \t * that nrfx_uarte_rx_buffer_set is called when RX enable configuration \t * flags are already known to the driver (e.g. if flushed data shall be \t * kept or not). \t */\nname|adata\noperator|->\nname|en_rx_buf\noperator|=\nname|buf\nexpr_stmt|;\nname|adata",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|err\n+operator|=\n+literal|0\n+expr_stmt|;\n+name|adata\n+operator|->\nThe issue was with: drivers: serial: nrfx_uarte2: Clean error state on rx_enable\n\nClean error state on re-enabling RX. If previous transmission ended with\nan error it should not impact next receiving session."
},{
  "instruction": "There is an issue in the following code. It relates to logging: multidomain_link: fix crash caused by drop notification\n\nThe remote domain may send unsolicited Z_LOG_MULTIDOMAIN_ID_DROPPED IPC\nmessages, which are not handled in log_multidomain_link_on_recv_cb().\nWith CONFIG_ASSERT=y, this will cause an assertion failure. With asserts\ndisabled, this message would be treated as a reply to any in progress\nrequest and cause getter_msg_process() to return early. In turn, this\ncan cause various kinds of memory corruption when the real reply arrives\nand the callback reads/writes stack variables that are no longer valid.\n\nFix this by explicitly ignoring Z_LOG_MULTIDOMAIN_ID_DROPPED, and also\ndon't treat unrecognized message types as replies. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|.\nname|runtime_level\nexpr_stmt|;\nbreak|break;\ncase|case\nname|Z_LOG_MULTIDOMAIN_ID_READY\ncase|:\nbreak|break;\ndefault|default:\nname|__ASSERT\nliteral|0\nargument_list|,\nliteral|\"Unexpected message\"\nargument_list|)\nexpr_stmt|;\nbreak|break;\nblock|}\nname|exit\nlabel|:\nname|k_sem_give\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|Z_LOG_MULTIDOMAIN_ID_DROPPED\n+case|:\n+return|return;\n+case|case\n-break|break;\n+return|return;\nThe issue was with: logging: multidomain_link: fix crash caused by drop notification\n\nThe remote domain may send unsolicited Z_LOG_MULTIDOMAIN_ID_DROPPED IPC\nmessages, which are not handled in log_multidomain_link_on_recv_cb().\nWith CONFIG_ASSERT=y, this will cause an assertion failure. With asserts\ndisabled, this message would be treated as a reply to any in progress\nrequest and cause getter_msg_process() to return early. In turn, this\ncan cause various kinds of memory corruption when the real reply arrives\nand the callback reads/writes stack variables that are no longer valid.\n\nFix this by explicitly ignoring Z_LOG_MULTIDOMAIN_ID_DROPPED, and also\ndon't treat unrecognized message types as replies."
},{
  "instruction": "There is an issue in the following code. It relates to samples: net: sockets: coap_server: fix separate response MID reuse\n\nFixes #71620 by generating a different CoAP message ID for the\nseparate response. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|token\nargument_list|,\nname|COAP_RESPONSE_CODE_CONTENT\nargument_list|,\nname|id\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|r",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|id\n+name|coap_next_id\n+argument_list|()\nThe issue was with: samples: net: sockets: coap_server: fix separate response MID reuse\n\nFixes #71620 by generating a different CoAP message ID for the\nseparate response."
},{
  "instruction": "There is an issue in the following code. It relates to ipc_service: backends: icbmsg: Fix strnlen warnings\n\nThis fixes warnings when building with icbmsg\nbackend for IPC service by defining\n_POSIX_C_SOURCE 200809L in source file. Please fix this issue.",
  "input": "Faulty tokenized code:\n\nbegin_comment\ncomment|/*  * ICBMsg backend.  *  * This is an IPC service backend that dynamically allocates buffers for data storage  * and uses ICMsg to send references to them.  *  * Shared memory organization  * --------------------------  *  * Single channel (RX or TX) of the shared memory is divided into two areas: ICMsg area  * followed by Blocks area. ICMsg is used to send and receive short 3-byte messages.  * Blocks area is evenly divided into aligned blocks. Blocks are used to allocate  * buffers containing actual data. Data buffers can span multiple blocks. The first block  * starts with the size of the following data.  *  *  +------------+-------------+  *  | ICMsg area | Blocks area |  *  +------------+-------------+  *       _______/               \\_________________________________________  *      /                                                                 \\  *      +-----------+-----------+-----------+-----------+-   -+-----------+  *      |  Block 0  |  Block 1  |  Block 2  |  Block 3  | ... | Block N-1 |  *      +-----------+-----------+-----------+-----------+-   -+-----------+  *            _____/                                     \\_____  *           /                                                 \\  *           +------+--------------------------------+---------+  *           | size | data_buffer[size] ...          | padding |  *           +------+--------------------------------+---------+  *  * The sender holds information about reserved blocks using bitarray and it is responsible  * for allocating and releasing the blocks. The receiver just tells the sender that it  * does not need a specific buffer anymore.  *  * Control messages  * ----------------  *  * ICMsg is used to send and receive small 3-byte control messages.  *  *  - Send data  *    | MSG_DATA | endpoint address | block index |  *    This message is used to send data buffer to specific endpoint.  *  *  - Release data  *    | MSG_RELEASE_DATA | 0 | block index |  *    This message is a response to the \"Send data\" message and it is used to inform that  *    specific buffer is not used anymore and can be released. Endpoint addresses does  *    not matter here, so it is zero.  *  *  - Bound endpoint  *    | MSG_BOUND | endpoint address | block index |  *    This message starts the bounding of the endpoint. The buffer contains a  *    null-terminated endpoint name.  *  *  - Release bound endpoint  *    | MSG_RELEASE_BOUND | endpoint address | block index |  *    This message is a response to the \"Bound endpoint\" message and it is used to inform  *    that a specific buffer (starting at \"block index\") is not used anymore and  *    a the endpoint is bounded and can now receive a data.  *  * Bounding endpoints  * ------------------  *  * When ICMsg is bounded and user registers an endpoint on initiator side, the backend  * sends \"Bound endpoint\". Endpoint address is assigned by the initiator. When follower  * gets the message and user on follower side also registered the same endpoint,  * the backend calls \"bound\" callback and sends back \"Release bound endpoint\".  * The follower saves the endpoint address. The follower's endpoint is ready to send  * and receive data. When the initiator gets \"Release bound endpoint\" message or any  * data messages, it calls bound endpoint and it is ready to send data.  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nfile|<string.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_undef\n+undef|#\n+directive|undef\n+name|_POSIX_C_SOURCE\n+end_undef\n+\n+begin_define\n+DECL|macro|_POSIX_C_SOURCE\n+define|#\n+directive|define\n+name|_POSIX_C_SOURCE\n+value|200809L\n+end_define\n+\n+begin_comment\n+DECL|macro|_POSIX_C_SOURCE\n+comment|/* For strnlen() */\n+end_comment\n+\nThe issue was with: ipc_service: backends: icbmsg: Fix strnlen warnings\n\nThis fixes warnings when building with icbmsg\nbackend for IPC service by defining\n_POSIX_C_SOURCE 200809L in source file."
},{
  "instruction": "There is an issue in the following code. It relates to arch: arm: cortex_m: fix inverted logic in cpu_idle\n\nThis mistake was introduced when converting from ASM to C.\nThis change also restores the associated comment from the ASM source. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|SLEEP_IF_ALLOWED\nparameter_list|(\nname|wait_instr\nparameter_list|)\nvalue|do { \\ \tif (!z_arm_on_enter_cpu_idle()) { \\ \t\t__DSB(); \\ \t\twait_instr(); \\ \t\tON_EXIT_IDLE_HOOK; \\ \t} \\ } while (false)\nend_define\n\nbegin_else\nelse|#\ndirective|else",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|do { \\ \tif (!z_arm_on_enter_cpu_idle()) { \\ \t\t__DSB(); \\ \t\twait_instr(); \\ \t\tON_EXIT_IDLE_HOOK; \\ \t} \\ } while (false)\n+value|do { \\\n+comment|/* Skip the wait instr if on_enter_cpu_idle returns false */\n+value|\\ \tif (z_arm_on_enter_cpu_idle()) { \\\n+comment|/* Wait for all memory transaction to complete */\n+value|\\\n+comment|/* before entering low power state. */\n+value|\\ \t\t__DSB(); \\ \t\twait_instr(); \\\n+comment|/* Inline the macro provided by SoC-specific code */\n+value|\\ \t\tON_EXIT_IDLE_HOOK; \\ \t} \\ } while (false)\nThe issue was with: arch: arm: cortex_m: fix inverted logic in cpu_idle\n\nThis mistake was introduced when converting from ASM to C.\nThis change also restores the associated comment from the ASM source."
},{
  "instruction": "There is an issue in the following code. It relates to net: ipv6: check if multicast packet was forwarded\n\nThis commit adds a check to determine if the packet wasn't already\nforwarded to a given interface. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|)\nname|hdr\noperator|->\nname|dst\nargument_list|)\ncondition|)\nblock|{\ncomment|/* If the packet is a multicast packet and multicast routing \t\t * is activated, we give the packet to the routing engine. \t\t * \t\t * But we only drop the packet if an error occurs, otherwise \t\t * it might be eminent to respond on the packet on application \t\t * layer. \t\t */\nif|if\ncondition|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|&&\n+operator|!\n+name|net_pkt_forwarding\n+argument_list|(\n+name|pkt\n+argument_list|)\nThe issue was with: net: ipv6: check if multicast packet was forwarded\n\nThis commit adds a check to determine if the packet wasn't already\nforwarded to a given interface."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: pinctrl_nrf: Configure QSPI IO3 pin as output set high\n\n... so that the pin is kept in a defined state when the IO3 line is\nnot controlled by the QSPI peripheral (when the peripheral is disabled\nor disconnected from the pin).\n\nThe IO3 pin in Quad SPI flash chips usually has dual functionality -\nit is an I/O line when the chip is configured to work in Quad (4 I/O)\nmode and it is a HOLD# or RESET# line when the chip is configured to\nwork in non-Quad (2 I/O) mode. In the latter case, it is important that\nthe line is kept in the inactive (high) state, otherwise communication\nwith the chip may be disrupted (and this actually happens when e.g.\nthe spi_flash sample is used on a brand new nRF5340 or nRF52840 DK -\nthe nrf_qspi_nor driver fails to initialize and the sample just ends\nup with the \\\"mx25r6435f@0: device not ready\\\" message).\n\nThis commit addresses the problem in the same way that it was done for\nthe CSN line in commit f8b6c52bfeb4af3eecd3a73b5e1c79f43c16077f [formerly 6d8172f4e997254a338b8b8eee92e1c1fb36229d]. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|IO3\nargument_list|)\noperator|=\nname|psel\nexpr_stmt|;\nname|dir\noperator|=\nname|NRF_GPIO_PIN_DIR_INPUT\nexpr_stmt|;\nname|input\noperator|=\nname|NRF_GPIO_PIN_INPUT_DISCONNECT\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|write\n+operator|=\n+literal|1U\n+expr_stmt|;\n-name|NRF_GPIO_PIN_DIR_INPUT\n+name|NRF_GPIO_PIN_DIR_OUTPUT\nThe issue was with: drivers: pinctrl_nrf: Configure QSPI IO3 pin as output set high\n\n... so that the pin is kept in a defined state when the IO3 line is\nnot controlled by the QSPI peripheral (when the peripheral is disabled\nor disconnected from the pin).\n\nThe IO3 pin in Quad SPI flash chips usually has dual functionality -\nit is an I/O line when the chip is configured to work in Quad (4 I/O)\nmode and it is a HOLD# or RESET# line when the chip is configured to\nwork in non-Quad (2 I/O) mode. In the latter case, it is important that\nthe line is kept in the inactive (high) state, otherwise communication\nwith the chip may be disrupted (and this actually happens when e.g.\nthe spi_flash sample is used on a brand new nRF5340 or nRF52840 DK -\nthe nrf_qspi_nor driver fails to initialize and the sample just ends\nup with the \\\"mx25r6435f@0: device not ready\\\" message).\n\nThis commit addresses the problem in the same way that it was done for\nthe CSN line in commit f8b6c52bfeb4af3eecd3a73b5e1c79f43c16077f [formerly 6d8172f4e997254a338b8b8eee92e1c1fb36229d]."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: uart_async_rx: Fix uart_async_rx_reset function\n\nAdd missing fields clearing to the resetting function. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|rd_idx\noperator|=\nliteral|0\nexpr_stmt|;\nfor|for\ncontrol|(\nname|uint8_t\nname|i\ninit|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|rx_data\n+operator|->\n+name|rd_buf_idx\n+operator|=\n+literal|0\n+expr_stmt|;\n+name|rx_data\n+operator|->\n+name|drv_buf_idx\n+operator|=\n+literal|0\n+expr_stmt|;\n+name|rx_data\n+operator|->\n+name|pending_bytes\n+operator|=\n+literal|0\n+expr_stmt|;\nThe issue was with: drivers: serial: uart_async_rx: Fix uart_async_rx_reset function\n\nAdd missing fields clearing to the resetting function."
},{
  "instruction": "There is an issue in the following code. It relates to llext: fix llext_find_sym() not to return a \\\"const\\\" value\n\nReturned values are copies, so trying to \\\"const\\\" return values cannot\nhave any effect.\n\nFixes the following compiler warning:\n```\nllext.h:165: warning: type qualifiers ignored on function return type\n```\n\nFixes commit 0c51cb84170f [formerly 41e0a4a37141] (\\\"llext: Linkable loadable extensions\\\") Please fix this issue.",
  "input": "Faulty tokenized code:\nfunction_decl|;\ncomment|/**  * @brief Find the address for an arbitrary symbol name.  *  * @param[in] sym_table Symbol table to lookup symbol in, if NULL uses base table  * @param[in] sym_name Symbol name to find  *  * @retval NULL if no symbol found  * @retval addr Address of symbol in memory if found  */\nspecifier|const\nname|void\nmodifier|*\nspecifier|const\nname|llext_find_sym\nparameter_list|(\nspecifier|const\nname|struct\nname|llext_symtable\nbegin_function\nDECL|function|llext_find_sym (const struct llext_symtable * sym_table,const char * sym_name)\nspecifier|const\nname|void\nmodifier|*\nspecifier|const\nname|llext_find_sym\nparameter_list|(\nspecifier|const\nname|struct\nname|llext_symtable",
  "result": "I corrected the issue in the code by changing the following tokens:\n-specifier|const\n-specifier|const\nThe issue was with: llext: fix llext_find_sym() not to return a \\\"const\\\" value\n\nReturned values are copies, so trying to \\\"const\\\" return values cannot\nhave any effect.\n\nFixes the following compiler warning:\n```\nllext.h:165: warning: type qualifiers ignored on function return type\n```\n\nFixes commit 0c51cb84170f [formerly 41e0a4a37141] (\\\"llext: Linkable loadable extensions\\\")"
},{
  "instruction": "There is an issue in the following code. It relates to arch: arm: cortex_m: Only trigger context switch if thread is preemptible\n\nThis is a fix for #61761 where a cooperative task is switched from at the\nend of an exception. A cooperative thread should only be switched from if\nthe thread exists the ready state. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|)\nblock|{\nifdef|#\ndirective|ifdef\nname|CONFIG_PREEMPT_ENABLED\nif|if\ncondition|(\nname|_kernel\noperator|.\nname|ready_q\nname|cpus\noperator|->\nname|current\ncondition|)\nblock|{\nname|SCB\noperator|->\nname|ICSR\noperator||=\nname|SCB_ICSR_PENDSVSET_Msk\nexpr_stmt|;\nblock|}\nendif|#\ndirective|endif\ncomment|/* CONFIG_PREEMPT_ENABLED */\nifdef|#\ndirective|ifdef",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* If thread is preemptible */\n+if|if\n+condition|(\n+name|_kernel\n+operator|.\n+name|cpus\n+operator|->\n+name|current\n+operator|->\n+name|base\n+operator|.\n+name|prio\n+operator|>=\n+literal|0\n+condition|)\n+block|{\n+comment|/* and cached thread is not current thread */\n+comment|/* trigger a context switch */\n+block|}\nThe issue was with: arch: arm: cortex_m: Only trigger context switch if thread is preemptible\n\nThis is a fix for #61761 where a cooperative task is switched from at the\nend of an exception. A cooperative thread should only be switched from if\nthe thread exists the ready state."
},{
  "instruction": "There is an issue in the following code. It relates to arch: arm: cortex_m: use cmsis API rather than assembly\n\nAsm is notoriously harder to maintain than C and requires core specific\nadaptation which impairs even more the readability of the code. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/irq_offload.h>\nend_include\n\nbegin_decl_stmt\nDECL|variable|offload_routine\nspecifier|volatile\nname|irq_offload_routine_t\nname|offload_routine\nname|defined\nargument_list|(\nname|CONFIG_ARMV6_M_ARMV8_M_BASELINE\nargument_list|)\noperator|&&\nname|defined\nargument_list|(\nname|CONFIG_ASSERT\nargument_list|)\ncomment|/* ARMv6-M/ARMv8-M Baseline HardFault if you make a SVC call with \t * interrupts locked. \t */\nname|unsigned\nname|int\nname|key\ndecl_stmt|;\nasm|__asm__\nspecifier|volatile\nasm|(\"mrs %0, PRIMASK;\" : \"=r\" (key) : : \"memory\");\nname|__ASSERT\nargument_list|(\nname|key\noperator|==\nliteral|0U\nargument_list|,\nliteral|\"irq_offload called with interrupts locked\\n\"\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<cmsis_core.h>\n+end_include\n+\n+operator|!\n+name|defined\n+argument_list|(\n+name|CONFIG_ARMV8_M_BASELINE\n+argument_list|)\n+expr|\\\n+operator|&&\n-comment|/* ARMv6-M/ARMv8-M Baseline HardFault if you make a SVC call with \t * interrupts locked. \t */\n-name|unsigned\n-name|int\n-name|key\n-decl_stmt|;\n-asm|__asm__\n-specifier|volatile\n-asm|(\"mrs %0, PRIMASK;\" : \"=r\" (key) : : \"memory\");\n+comment|/* ARMv6-M HardFault if you make a SVC call with interrupts locked. \t */\n-name|key\n+name|__get_PRIMASK\n+argument_list|()\nThe issue was with: arch: arm: cortex_m: use cmsis API rather than assembly\n\nAsm is notoriously harder to maintain than C and requires core specific\nadaptation which impairs even more the readability of the code."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: l2cap: Fix SDU buffer leak\n\n`ret` is the amount sent from the current buffer. `sent` contains the\ntotal amount that was transferred in the while loop. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ret\nexpr_stmt|;\ncomment|/* If the current buffer has been fully consumed, destroy it */\nif|if\ncondition|(\nname|ret\noperator|==\nname|rem_len\ncondition|)\nblock|{\nname|net_buf_unref",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|ret\n+name|sent\nThe issue was with: Bluetooth: l2cap: Fix SDU buffer leak\n\n`ret` is the amount sent from the current buffer. `sent` contains the\ntotal amount that was transferred in the while loop."
},{
  "instruction": "There is an issue in the following code. It relates to posix: eventfd: Fix unsetting internal flags in ioctl\n\nCommit 316b50cf29fb [formerly e6eb0a705bc8] (\\\"posix: eventfd: revise locking, signaling, and\nallocation\\\") introduced a regression where the internal flags of an\nevent file descriptor would be erased when calling the F_SETFL ioctl\noperation.\n\nThis includes the flag EFD_IN_USE_INTERNAL which determines whether\nthis file descriptor has been opened, thus effectively closing the\neventfd whenever one tries to change a flag. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|1\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\nname|efd\noperator|->\nname|flags\noperator|=\nname|flags\nexpr_stmt|;\nname|ret\noperator|=\nliteral|0\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|int\n+name|prev_flags\n+init|=\n+name|efd\n+operator|->\n+name|flags\n+operator|&\n+operator|~\n+name|EFD_FLAGS_SET_INTERNAL\n+decl_stmt|;\n+operator||\n+name|prev_flags\nThe issue was with: posix: eventfd: Fix unsetting internal flags in ioctl\n\nCommit 316b50cf29fb [formerly e6eb0a705bc8] (\\\"posix: eventfd: revise locking, signaling, and\nallocation\\\") introduced a regression where the internal flags of an\nevent file descriptor would be erased when calling the F_SETFL ioctl\noperation.\n\nThis includes the flag EFD_IN_USE_INTERNAL which determines whether\nthis file descriptor has been opened, thus effectively closing the\neventfd whenever one tries to change a flag."
},{
  "instruction": "There is an issue in the following code. It relates to regulator: regulator_common: Cleans sleep related preprocesor directives\n\nRemoves conditional calling k_busy_wait() on single threaded\nsystems and uses k_sleep for both single and multi threaded\nsystems.\n\nCommit e375d82 (\\\"kernel: Implement k_sleep for Single Thread\\\")\neliminated the need to call k_busy_wait() on single threaded\nsystems in place of k_sleep. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|delay_us\noperator|>\nliteral|0U\ncondition|)\nblock|{\nifdef|#\ndirective|ifdef\nname|CONFIG_MULTITHREADING\nname|k_sleep\nargument_list|(\nname|K_USEC\nargument_list|(\nname|delay_us\nargument_list|)\nargument_list|)\nexpr_stmt|;\nelse|#\ndirective|else\nname|k_busy_wait\nargument_list|(\nname|delay_us\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\nblock|}\nblock|}\nend_function\n\nbegin_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-ifdef|#\n-directive|ifdef\n-name|CONFIG_MULTITHREADING\n-else|#\n-directive|else\n-name|k_busy_wait\n-argument_list|(\n-name|delay_us\n-argument_list|)\n-expr_stmt|;\n-endif|#\n-directive|endif\nThe issue was with: regulator: regulator_common: Cleans sleep related preprocesor directives\n\nRemoves conditional calling k_busy_wait() on single threaded\nsystems and uses k_sleep for both single and multi threaded\nsystems.\n\nCommit e375d82 (\\\"kernel: Implement k_sleep for Single Thread\\\")\neliminated the need to call k_busy_wait() on single threaded\nsystems in place of k_sleep."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: wifi: esp_at: fix missing channel in scan result\n\nWiFi scan results were not updated with information about channel, after\nscan results parsing was updated. Fix that.\n\nFixes: 7c5d60170935 [formerly a6b06004c221] (\\\"drivers: wifi: esp_at: handle commas in SSIDs during\n  scan and status\\\") Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nreturn|return\nname|err\nreturn|;\nblock|}\nif|if\ncondition|(\nname|dev\noperator|->\nname|scan_cb",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|res\n+operator|.\n+name|channel\n+operator|=\n+name|strtol\n+argument_list|(\n+name|channel\n+argument_list|,\n+name|NULL\n+argument_list|,\n+literal|10\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: wifi: esp_at: fix missing channel in scan result\n\nWiFi scan results were not updated with information about channel, after\nscan results parsing was updated. Fix that.\n\nFixes: 7c5d60170935 [formerly a6b06004c221] (\\\"drivers: wifi: esp_at: handle commas in SSIDs during\n  scan and status\\\")"
},{
  "instruction": "There is an issue in the following code. It relates to boards: nrf_bsim: bst hooks: Call tests delete only once\n\nbst_delete() is called from an ON_EXIT hook, which can be called\nseveral times if an exit hook itself fails and calls exit on\nits own.\nThis is not what most tests destructors will expect, and they\nmay do weird things in this case. So let's not call into it again. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|bst_delete\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nif|if\ncondition|(\nname|current_test\noperator|&&\nname|current_test",
  "result": "I corrected the issue in the code by changing the following tokens:\n+specifier|static\n+name|bool\n+name|already_deleted\n+decl_stmt|;\n+if|if\n+condition|(\n+name|already_deleted\n+condition|)\n+block|{\n+return|return\n+name|bst_result\n+return|;\n+block|}\n+name|already_deleted\n+operator|=\n+name|true\n+expr_stmt|;\nThe issue was with: boards: nrf_bsim: bst hooks: Call tests delete only once\n\nbst_delete() is called from an ON_EXIT hook, which can be called\nseveral times if an exit hook itself fails and calls exit on\nits own.\nThis is not what most tests destructors will expect, and they\nmay do weird things in this case. So let's not call into it again."
},{
  "instruction": "There is an issue in the following code. It relates to samples: nrfx_prs: Add handling of SCK initial value based on mode\n\nAdd handling of SCK initial value based on the SPI mode used.\nIf mode is using CPOL then SCK needs to be set.\n\nFixes: #71154 Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_enum\nDECL|enum|__anon2b5d7c5f0103\nspecifier|static\nenum|enum\nblock|{\nDECL|enumerator|PERFORM_TRANSFER\nname|PERFORM_TRANSFER\nblock|{\nreturn|return\nname|ret\nreturn|;\nblock|}\nname|err\noperator|=\nname|nrfx_spim_init\nargument_list|(\noperator|&",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon2b5d7c5f0103\n+DECL|enum|__anon2b9f8c830103\n+comment|/* Set initial state of SCK according to the SPI mode. */\n+name|nrfy_gpio_pin_write\n+argument_list|(\n+name|nrfy_spim_sck_pin_get\n+argument_list|(\n+name|spim\n+operator|.\n+name|p_reg\n+argument_list|)\n+argument_list|,\n+operator|(\n+name|spim_config\n+operator|.\n+name|mode\n+operator|<=\n+name|NRF_SPIM_MODE_1\n+operator|)\n+condition|?\n+literal|0\n+else|:\n+literal|1\n+argument_list|)\n+expr_stmt|;\nThe issue was with: samples: nrfx_prs: Add handling of SCK initial value based on mode\n\nAdd handling of SCK initial value based on the SPI mode used.\nIf mode is using CPOL then SCK needs to be set.\n\nFixes: #71154"
},{
  "instruction": "There is an issue in the following code. It relates to samples: nrfx_prs: Fix sample frequency\n\nFix setting of sample frequency.\nThe nrfx drivers are now using raw integere values instead of nrf\ndefinitions.\n\nFixes: #71154 Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/irq.h>\nend_include\n\nbegin_define\nDECL|macro|TRANSFER_LENGTH\ndefine|#\ndirective|define\nname|TRANSFER_LENGTH\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_enum\nDECL|enum|__anon29080d130103\nspecifier|static\nenum|enum\nblock|{\nDECL|enumerator|PERFORM_TRANSFER\nname|PERFORM_TRANSFER\ndecl_stmt|;\nname|spim_config\noperator|.\nname|frequency\noperator|=\nname|NRF_SPIM_FREQ_1M\nexpr_stmt|;\nname|spim_config\noperator|.\nname|skip_gpio_cfg\noperator|=\nname|SPI_TRANSFER_MSB\nblock|,\noperator|.\nname|frequency\noperator|=\nliteral|1000000\nblock|,\noperator|.\nname|cs\noperator|=\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/sys/util.h>\n+end_include\n+\n-DECL|enum|__anon29080d130103\n+DECL|enum|__anon2b5d7c5f0103\n-name|NRF_SPIM_FREQ_1M\n+name|MHZ\n+argument_list|(\n+literal|1\n+argument_list|)\n-literal|1000000\n+name|MHZ\n+argument_list|(\n+literal|1\n+argument_list|)\nThe issue was with: samples: nrfx_prs: Fix sample frequency\n\nFix setting of sample frequency.\nThe nrfx drivers are now using raw integere values instead of nrf\ndefinitions.\n\nFixes: #71154"
},{
  "instruction": "There is an issue in the following code. It relates to soc: st: stm32: stm32l4x: enable ART flash cache accelerator\n\nEnable instruction cache, data cache and prefetching. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<cmsis_core.h>\nend_include\n\nbegin_define\nDECL|macro|LOG_LEVEL\ndefine|#\ndirective|define\nname|LOG_LEVEL\nname|stm32l4_init\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\ncomment|/* Update CMSIS SystemCoreClock variable (HCLK) */\ncomment|/* At reset, system core clock is set to 4 MHz from MSI */\nname|SystemCoreClock\noperator|=\nliteral|4000000",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<stm32_ll_system.h>\n+end_include\n+\n+comment|/* Enable the ART Accelerator I-cache, D-cache and prefetch */\n+name|LL_FLASH_EnableInstCache\n+argument_list|()\n+expr_stmt|;\n+name|LL_FLASH_EnableDataCache\n+argument_list|()\n+expr_stmt|;\n+name|LL_FLASH_EnablePrefetch\n+argument_list|()\n+expr_stmt|;\nThe issue was with: soc: st: stm32: stm32l4x: enable ART flash cache accelerator\n\nEnable instruction cache, data cache and prefetching."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: dai: intel: ssp: fix LOG_ERR level / false positive\n\nThere's no way this log level was intentional: this line is just the\ntitle / prefix of a multi-line section with mostly LOG_INF statements.\n\nFixes commit c2b403fee4c6 [formerly 6423bc3bc885] (\\\"drivers: dai: intel: ssp: Improve logging\noutput\\\") which was very large hence error-prone.\n\nFixes SOF bug https://github.com/thesofproject/sof/issues/9026 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|SSCR1_RSRE\noperator||\nname|SSCR1_TSRE\noperator|)\nexpr_stmt|;\nname|LOG_ERR\nargument_list|(\nliteral|\"SSP%d configuration:\"\nargument_list|,\nname|dp\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|LOG_ERR\n+name|LOG_INF\nThe issue was with: drivers: dai: intel: ssp: fix LOG_ERR level / false positive\n\nThere's no way this log level was intentional: this line is just the\ntitle / prefix of a multi-line section with mostly LOG_INF statements.\n\nFixes commit c2b403fee4c6 [formerly 6423bc3bc885] (\\\"drivers: dai: intel: ssp: Improve logging\noutput\\\") which was very large hence error-prone.\n\nFixes SOF bug https://github.com/thesofproject/sof/issues/9026"
},{
  "instruction": "There is an issue in the following code. It relates to refactor: adjust spacing by clang formatting\n\nThis commit clang-formats the file after the new additions Please fix this issue.",
  "input": "Faulty tokenized code:\nname|VEML7700_INIT\nparameter_list|(\nname|n\nparameter_list|)\ndefine|\\\nvalue|static struct veml7700_data veml7700_data_##n;                      \\ \t\t\t\t\t\t\t\t\t    \\ \tstatic const struct veml7700_config veml7700_config_##n = {         \\ \t\t.bus = I2C_DT_SPEC_INST_GET(n),                             \\ \t\t.psm = DT_INST_PROP(n, psm_mode)                            \\ \t};                                                                  \\                                                                             \\ \tPM_DEVICE_DT_INST_DEFINE(n, veml7700_pm_action);                    \\                                                                             \\ \tSENSOR_DEVICE_DT_INST_DEFINE(n,                                     \\ \t\t\t\t     veml7700_init,                         \\ \t\t\t\t     PM_DEVICE_DT_INST_GET(n),              \\&veml7700_data_##n,                    \\&veml7700_config_##n,                  \\ \t\t\t\t     POST_KERNEL,                           \\ \t\t\t\t     CONFIG_SENSOR_INIT_PRIORITY,           \\&veml7700_api);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|static struct veml7700_data veml7700_data_##n;                      \\ \t\t\t\t\t\t\t\t\t    \\ \tstatic const struct veml7700_config veml7700_config_##n = {         \\ \t\t.bus = I2C_DT_SPEC_INST_GET(n),                             \\ \t\t.psm = DT_INST_PROP(n, psm_mode)                            \\ \t};                                                                  \\                                                                             \\ \tPM_DEVICE_DT_INST_DEFINE(n, veml7700_pm_action);                    \\                                                                             \\ \tSENSOR_DEVICE_DT_INST_DEFINE(n,                                     \\ \t\t\t\t     veml7700_init,                         \\ \t\t\t\t     PM_DEVICE_DT_INST_GET(n),              \\&veml7700_data_##n,                    \\&veml7700_config_##n,                  \\ \t\t\t\t     POST_KERNEL,                           \\ \t\t\t\t     CONFIG_SENSOR_INIT_PRIORITY,           \\&veml7700_api);\n+value|static struct veml7700_data veml7700_data_##n;                                             \\                                                                                                    \\ \tstatic const struct veml7700_config veml7700_config_##n = {                                \\ \t\t.bus = I2C_DT_SPEC_INST_GET(n), .psm = DT_INST_PROP(n, psm_mode)};                 \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(n, veml7700_pm_action);                                           \\                                                                                                    \\ \tSENSOR_DEVICE_DT_INST_DEFINE(n, veml7700_init, PM_DEVICE_DT_INST_GET(n),                   \\&veml7700_data_##n,&veml7700_config_##n, POST_KERNEL,        \\ \t\t\t\t     CONFIG_SENSOR_INIT_PRIORITY,&veml7700_api);\nThe issue was with: refactor: adjust spacing by clang formatting\n\nThis commit clang-formats the file after the new additions"
},{
  "instruction": "There is an issue in the following code. It relates to llext: add a relocatable extension test to Xtensa\n\nLLEXT on Xtensa now supports both shared and relocatable (partially\nlinked) extensions. This commit adds a copy of the LLEXT test for the\nrelocatable case. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nargument|NULL\nargument_list|)\nend_macro\n\nbegin_decl_stmt\nspecifier|static\nname|LLEXT_CONST\nname|uint8_t\nname|syscalls_ext\nbegin_endif\nendif|#\ndirective|endif\nend_endif\n\nbegin_comment\ncomment|/* ! LOADER_BUILD_ONLY */\nend_comment\n\nbegin_comment\n    extra_configs:\n      - arch:arm:CONFIG_ARM_MPU=n\n      - CONFIG_MODULES=y\n      - CONFIG_LLEXT_STORAGE_WRITABLE=y\n      - CONFIG_LLEXT_TEST_HELLO=m\n  llext.simple.modules_enabled_readonly:\n    filter: not CONFIG_MPU and not CONFIG_MMU\n    arch_exclude: xtensa # for now\n    platform_key:\n      - simulation",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_ifndef\n+ifndef|#\n+directive|ifndef\n+name|CONFIG_LLEXT_TYPE_ELF_RELOCATABLE\n+end_ifndef\n+\n+begin_endif\n+endif|#\n+directive|endif\n+end_endif\n+\n+  llext.simple.modules_enabled_writable_relocatable:\n+    arch_exclude: arm arm64\n+    filter: not CONFIG_MPU and not CONFIG_MMU\n+    platform_key:\n+      - simulation\n+      - arch\n+    extra_configs:\n+      - CONFIG_MODULES=y\n+      - CONFIG_LLEXT_STORAGE_WRITABLE=y\n+      - CONFIG_LLEXT_TYPE_ELF_RELOCATABLE=y\n+      - CONFIG_LLEXT_TEST_HELLO=m\nThe issue was with: llext: add a relocatable extension test to Xtensa\n\nLLEXT on Xtensa now supports both shared and relocatable (partially\nlinked) extensions. This commit adds a copy of the LLEXT test for the\nrelocatable case."
},{
  "instruction": "There is an issue in the following code. It relates to llext: xtensa: add support for in-place relocatable extensions\n\nCurrently LLEXT on Xtensa supports relocatable extensions, linked for\na specific address range, while relocation itself takes place in a\ntemporary buffer. For this section addresses have to be set correctly\nby the linker for their target locations.\n\nThis commit adds support for relocatable extensions, built without\nusing specific memory addresses and run at the same addresses, where\nthey are loaded. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|sh_addr\noperator|=\nname|shdr\noperator|->\nname|sh_addr\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\nname|sh_addr",
  "result": "I corrected the issue in the code by changing the following tokens:\n+condition|?\n+else|:\n+operator|(\n+name|uintptr_t\n+operator|)\n+name|llext_peek\n+argument_list|(\n+name|ldr\n+argument_list|,\n+name|shdr\n+operator|->\n+name|sh_offset\n+argument_list|)\nThe issue was with: llext: xtensa: add support for in-place relocatable extensions\n\nCurrently LLEXT on Xtensa supports relocatable extensions, linked for\na specific address range, while relocation itself takes place in a\ntemporary buffer. For this section addresses have to be set correctly\nby the linker for their target locations.\n\nThis commit adds support for relocatable extensions, built without\nusing specific memory addresses and run at the same addresses, where\nthey are loaded."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: interrupt_controller: Enable PINT-irq when deepsleep is not used\n\nDisableDeepSleepIRQ() disables the NVIC irq, while PINT need it to fire an\nevent when the interrupt is used. So while the interrupt is not used in\nDeepSleep mode, it should still be available to be used. Please fix this issue.",
  "input": "Faulty tokenized code:\nindex|]\noperator|.\nname|irq\nargument_list|)\nexpr_stmt|;\nblock|}\nendif|#\ndirective|endif\nreturn|return\nliteral|0",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|irq_enable\n+argument_list|(\n+name|pint_irq_cfg\n+index|[\n+name|slot\n+index|]\n+operator|.\n+name|irq\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: interrupt_controller: Enable PINT-irq when deepsleep is not used\n\nDisableDeepSleepIRQ() disables the NVIC irq, while PINT need it to fire an\nevent when the interrupt is used. So while the interrupt is not used in\nDeepSleep mode, it should still be available to be used."
},{
  "instruction": "There is an issue in the following code. It relates to mgmt: smp: fix smp client with shell transport\n\nFix typo in mcumgr shell transport relating to SMP client. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|smp_client_transport\noperator|.\nname|smpt\noperator|=\noperator|&\nname|CONFIG_SMP_CLIENT\nexpr_stmt|;\nname|smp_client_transport\noperator|.\nname|smpt_type\noperator|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_SMP_CLIENT\n+name|smp_shell_transport\nThe issue was with: mgmt: smp: fix smp client with shell transport\n\nFix typo in mcumgr shell transport relating to SMP client."
},{
  "instruction": "There is an issue in the following code. It relates to net: lib: lwm2m: fix formula for expected next block\n\nBlock size is a 3-bit value mapping values [0, 6] to powers of 2 in the\nrange [16, 1024]. Value 7 is invalid.\nThe previous formula was not working in case the client's preferred size\nwas 4 (or more) times bigger than the server's.\nThis commit takes into account also the case the client's preferred size\nis smaller than the server's. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|last_block\noperator|=\nname|last_block\nexpr_stmt|;\ncomment|/* Initial block sent by the server might be larger than \t\t * our block size therefore it is needed to take this \t\t * into account when calculating next expected block \t\t * number. \t\t */\nname|block_ctx\noperator|->\nname|expected\noperator|+=\nname|GET_BLOCK_SIZE\nargument_list|(\nname|block_opt\nargument_list|)\noperator|-\nname|block_ctx\noperator|->\nname|ctx\noperator|.\nname|block_size\noperator|+\nliteral|1\nexpr_stmt|;\nblock|}\nname|r\noperator|=\nname|do_write_op",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* Initial block sent by the server might be larger than \t\t * our block size therefore it is needed to take this \t\t * into account when calculating next expected block \t\t * number. \t\t */\n+comment|/* Initial block sent by the server might be larger or smaller than \t\t * our block size, therefore it is needed to take this into account \t\t * when calculating next expected block number. \t\t */\n+literal|1\n+operator|<<\n+name|MAX\n+argument_list|(\n+literal|0\n+argument_list|,\n-operator|+\n-literal|1\n+argument_list|)\nThe issue was with: net: lib: lwm2m: fix formula for expected next block\n\nBlock size is a 3-bit value mapping values [0, 6] to powers of 2 in the\nrange [16, 1024]. Value 7 is invalid.\nThe previous formula was not working in case the client's preferred size\nwas 4 (or more) times bigger than the server's.\nThis commit takes into account also the case the client's preferred size\nis smaller than the server's."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: can: can_stm32_bxcan.c: Failed to exit sleep mode\n\nFixes the issue of CAN failing to exit sleep mode\ninside can_stm32_init() when a software reset is done.\nFor stm32 the CAN is first made to enter initialization\nmode first and then made to exit the sleep mode. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ret\nreturn|;\nblock|}\nname|ret\noperator|=\nname|can_stm32_leave_sleep_mode\nargument_list|(\nname|can\nargument_list|)\nexpr_stmt|;\nif|if\nname|ret\ncondition|)\nblock|{\nname|LOG_ERR\nargument_list|(\nliteral|\"Failed to exit sleep mode\"\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|ret\nreturn|;\nblock|}\nname|ret\noperator|=\nname|can_stm32_enter_init_mode\nargument_list|(\nname|can\nargument_list|)\nexpr_stmt|;\nif|if\nname|ret\ncondition|)\nblock|{\nname|LOG_ERR\nargument_list|(\nliteral|\"Failed to enter init mode\"\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|ret\nreturn|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|can_stm32_leave_sleep_mode\n+name|can_stm32_enter_init_mode\n-literal|\"Failed to exit sleep mode\"\n+literal|\"Failed to enter init mode\"\n-name|can_stm32_enter_init_mode\n+name|can_stm32_leave_sleep_mode\n-literal|\"Failed to enter init mode\"\n+literal|\"Failed to exit sleep mode\"\nThe issue was with: drivers: can: can_stm32_bxcan.c: Failed to exit sleep mode\n\nFixes the issue of CAN failing to exit sleep mode\ninside can_stm32_init() when a software reset is done.\nFor stm32 the CAN is first made to enter initialization\nmode first and then made to exit the sleep mode."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: adc: adc_ads1119: Fix configuration register access.\n\nThe adc_ads1119 driver is unable to overwrite the configuration register,\nthe chip therefore always works with its default settings. Register access\nmacros are fixed by this commit.\n\nFixes: #70091 Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|ADS1119_CONFIG_VREF\nparameter_list|(\nname|x\nparameter_list|)\nvalue|((x)& BIT(0))\nend_define\n\nbegin_define\nDECL|macro|ADS1119_CONFIG_CM (x)\ndefine|#\ndirective|define\nname|ADS1119_CONFIG_CM\nparameter_list|(\nname|x\nparameter_list|)\nvalue|((x)& BIT(1))\nend_define\n\nbegin_define\nDECL|macro|ADS1119_CONFIG_DR (x)\ndefine|#\ndirective|define\nname|ADS1119_CONFIG_DR\nparameter_list|(\nname|x\nparameter_list|)\nvalue|((x)& (BIT_MASK(2)<< 2))\nend_define\n\nbegin_define\nDECL|macro|ADS1119_CONFIG_GAIN (x)\ndefine|#\ndirective|define\nname|ADS1119_CONFIG_GAIN\nparameter_list|(\nname|x\nparameter_list|)\nvalue|((x)& BIT(4))\nend_define\n\nbegin_define\nDECL|macro|ADS1119_CONFIG_MUX (x)\ndefine|#\ndirective|define\nname|ADS1119_CONFIG_MUX\nparameter_list|(\nname|x\nparameter_list|)\nvalue|((x)& (BIT_MASK(3)<< 5))\nend_define\n\nbegin_define\nDECL|macro|ADS1119_STATUS_MASK_ID\ndefine|#\nblock|, }\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon294769290103\nenum|enum\nblock|{\nDECL|enumerator|ADS1119_CONFIG_VREF_INTERNAL\nname|ADS1119_CONFIG_VREF_INTERNAL\ninit|=\nblock|, }\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon294769290203\nenum|enum\nblock|{\nDECL|enumerator|ADS1119_CONFIG_MUX_DIFF_0_1\nname|ADS1119_CONFIG_MUX_DIFF_0_1\ninit|=\nblock|, }\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon294769290303\nenum|enum\nblock|{\nDECL|enumerator|ADS1119_CONFIG_DR_20\nname|ADS1119_CONFIG_DR_20\ninit|=\nblock|, }\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon294769290403\nenum|enum\nblock|{\nDECL|enumerator|ADS1119_CONFIG_GAIN_1\nname|ADS1119_CONFIG_GAIN_1\ninit|=\nblock|, }\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon294769290503\nenum|enum\nblock|{\nDECL|enumerator|ADS1119_CONFIG_CM_SINGLE\nname|ADS1119_CONFIG_CM_SINGLE\ninit|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|((x)& BIT(0))\n+value|(FIELD_PREP(BIT(0), x))\n-value|((x)& BIT(1))\n+value|(FIELD_PREP(BIT(1), x))\n-value|((x)& (BIT_MASK(2)<< 2))\n+value|(FIELD_PREP(BIT_MASK(2)<< 2, x))\n-value|((x)& BIT(4))\n+value|(FIELD_PREP(BIT(4), x))\n-value|((x)& (BIT_MASK(3)<< 5))\n+value|(FIELD_PREP(BIT_MASK(3)<< 5, x))\n-DECL|enum|__anon294769290103\n+DECL|enum|__anon29380d810103\n-DECL|enum|__anon294769290203\n+DECL|enum|__anon29380d810203\n-DECL|enum|__anon294769290303\n+DECL|enum|__anon29380d810303\n-DECL|enum|__anon294769290403\n+DECL|enum|__anon29380d810403\n-DECL|enum|__anon294769290503\n+DECL|enum|__anon29380d810503\nThe issue was with: drivers: adc: adc_ads1119: Fix configuration register access.\n\nThe adc_ads1119 driver is unable to overwrite the configuration register,\nthe chip therefore always works with its default settings. Register access\nmacros are fixed by this commit.\n\nFixes: #70091"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: usb: usb_dc_mcux: add case for RW6xx SOC series\n\nAdd case for RW6xx SOC series to indicate which device controller is in\nuse. Please fix this issue.",
  "input": "Faulty tokenized code:\n\nbegin_comment\ncomment|/* IMX RT */\nend_comment\n\nbegin_else\nelse|#\ndirective|else\nend_else\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_elif\n+elif|#\n+directive|elif\n+name|defined\n+argument_list|(\n+name|CONFIG_SOC_SERIES_RW6XX\n+argument_list|)\n+end_elif\n+\n+begin_define\n+DECL|macro|CONTROLLER_ID\n+define|#\n+directive|define\n+name|CONTROLLER_ID\n+value|kUSB_ControllerEhci0\n+end_define\n+\nThe issue was with: drivers: usb: usb_dc_mcux: add case for RW6xx SOC series\n\nAdd case for RW6xx SOC series to indicate which device controller is in\nuse."
},{
  "instruction": "There is an issue in the following code. It relates to fs: ext2: Fix calculating fs_memory in ext2_format\n\nFirst sector starts at CONFIG_EXT2_DISK_STARTING_SECTOR.\nThis commit fixes calculating free space, based on that value. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|return\noperator|-\nname|ENOSPC\nreturn|;\nblock|}\nname|uint32_t\nname|blocks_count\ninit|=\nname|fs_memory\noperator|/\nargument_list|,\noperator|&\nname|sector_count\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|sector_size\noperator|*\nname|sector_count\nreturn|;\nblock|}\nend_function\n\nend_unit",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Assume whole disk may be used minus CONFIG_EXT2_DISK_STARTING_SECTOR sectors. */\n+name|fs_memory\n+operator|-=\n+name|CONFIG_EXT2_DISK_STARTING_SECTOR\n+operator|*\n+name|fs\n+operator|->\n+name|write_size\n+expr_stmt|;\n+comment|/* Assume that partition occupies sectors from CONFIG_EXT2_DISK_STARTING_SECTOR to last. */\n+operator|(\n+operator|-\n+name|CONFIG_EXT2_DISK_STARTING_SECTOR\n+operator|)\nThe issue was with: fs: ext2: Fix calculating fs_memory in ext2_format\n\nFirst sector starts at CONFIG_EXT2_DISK_STARTING_SECTOR.\nThis commit fixes calculating free space, based on that value."
},{
  "instruction": "There is an issue in the following code. It relates to intel_adsp: ipc: Fix policy state lock usage\n\nIPC has inverted the usage of the state lock API.\nIn this API semantics, the get method disallow the policy of\nusing the given state, while the put() release this constraint. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|tx_ack_pending\noperator|=\nname|false\nexpr_stmt|;\ncomment|/* Allow the system to enter the runtime idle state after the IPC acknowledgment \t\t * is received. \t\t */\nname|pm_policy_state_lock_get\nargument_list|(\nname|PM_STATE_RUNTIME_IDLE\nargument_list|,\nname|PM_ALL_SUBSTATES\nargument_list|)\nargument_list|,\nliteral|1\nargument_list|)\nexpr_stmt|;\ncomment|/* Prevent entering runtime idle state until IPC acknowledgment is received. */\nname|pm_policy_state_lock_put\nargument_list|(\nname|PM_STATE_RUNTIME_IDLE\nargument_list|,\nname|PM_ALL_SUBSTATES\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|pm_policy_state_lock_get\n+name|pm_policy_state_lock_put\n-name|pm_policy_state_lock_put\n+name|pm_policy_state_lock_get\nThe issue was with: intel_adsp: ipc: Fix policy state lock usage\n\nIPC has inverted the usage of the state lock API.\nIn this API semantics, the get method disallow the policy of\nusing the given state, while the put() release this constraint."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: net: nsos: fix error message on EPOLL_CTL_DEL error\n\nFix a copy-pasted error message to reference proper epoll_ctl() operation. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|err\ncondition|)\nblock|{\nname|nsi_print_error_and_exit\nargument_list|(\nliteral|\"error in EPOLL_CTL_ADD: errno=%d\\n\"\nargument_list|,\nname|errno\nargument_list|)\nexpr_stmt|;\nreturn|return;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"error in EPOLL_CTL_ADD: errno=%d\\n\"\n+literal|\"error in EPOLL_CTL_DEL: errno=%d\\n\"\nThe issue was with: drivers: net: nsos: fix error message on EPOLL_CTL_DEL error\n\nFix a copy-pasted error message to reference proper epoll_ctl() operation."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: eth: stellaris: Fix build error\n\nApparently there was a typo in the last commit.\nLooks like it was refactored without trying to build. Please fix this issue.",
  "input": "Faulty tokenized code:\ninit|=\nliteral|0\ninit|;\nname|i\noperator|<\nname|np\ncondition|;\nname|i\noperator|++\ncontrol|)\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|np\n+name|num_packets\nThe issue was with: drivers: eth: stellaris: Fix build error\n\nApparently there was a typo in the last commit.\nLooks like it was refactored without trying to build."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: flash: stm32 ospi flash driver the correct erase instruction\n\nUse the most adapted instruction for the sector erase command\nIt can be 0x20 or ox21 or 0x21DE in octo - DTR mode.\nThe value is given by the SFDP table and  filled in the erase_types\n table the during the SFDP discovery process. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|SPI_NOR_CMD_SE_4B\nelse|:\nname|SPI_NOR_CMD_SE\nexpr_stmt|;\nblock|}\ncomment|/* Avoid using wrong erase type, \t\t\t\t\t * if zero entries are found in erase_types \t\t\t\t\t */\nname|bet\noperator|=\nname|NULL\nexpr_stmt|;\nblock|}\nblock|}\nname|LOG_DBG\nargument_list|(\nliteral|\"Sector/Block Erase addr 0x%x, asize 0x%x amode 0x%x  instr 0x%x\"\nargument_list|,\nname|cmd_erase\nname|uint8_t\nname|decl_nph\ninit|=\nliteral|2\ndecl_stmt|;\nDECL|union|__anon2c4cb620010a\nunion|union\nblock|{\ncomment|/* We only process BFP so use one parameter block */\nDECL|member|raw\nname|uint8_t\nname|id\noperator|==\nname|JESD216_SFDP_PARAM_ID_BFP\ncondition|)\nblock|{\nDECL|union|__anon2c4cb620020a\nunion|union\nblock|{\nDECL|member|dw\nname|uint32_t\nname|dw\noperator|==\nliteral|4U\ncondition|)\nblock|{\ncomment|/* \t\t\t\t * Check table 4 byte address instruction table to get supported \t\t\t\t * erase opcodes when running in 4 byte address mode \t\t\t\t */\nDECL|union|__anon2c4cb620030a\nunion|union\nblock|{\nDECL|member|dw\nname|uint32_t\nname|dw\nindex|[\nliteral|2\nindex|]\ndecl_stmt|;\nDECL|struct|__anon2c4cb6200408\nstruct|struct\nblock|{\nDECL|member|dummy\nname|uint32_t\nname|dummy",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* Avoid using wrong erase type, \t\t\t\t\t * if zero entries are found in erase_types \t\t\t\t\t */\n+block|}\n+comment|/* Avoid using wrong erase type, \t\t\t\t * if zero entries are found in erase_types \t\t\t\t */\n-block|}\n-DECL|union|__anon2c4cb620010a\n+DECL|union|__anon27b61a85010a\n-DECL|union|__anon2c4cb620020a\n+DECL|union|__anon27b61a85020a\n-DECL|union|__anon2c4cb620030a\n+DECL|union|__anon27b61a85030a\n-DECL|struct|__anon2c4cb6200408\n+DECL|struct|__anon27b61a850408\nThe issue was with: drivers: flash: stm32 ospi flash driver the correct erase instruction\n\nUse the most adapted instruction for the sector erase command\nIt can be 0x20 or ox21 or 0x21DE in octo - DTR mode.\nThe value is given by the SFDP table and  filled in the erase_types\n table the during the SFDP discovery process."
},{
  "instruction": "There is an issue in the following code. It relates to x86: correct size for stack bound check for privileged stack\n\nPrevious commit changed the privileged stack size to be using\nkconfig CONFIG_PRIVILEGED_STACK_SIZE instead of simply\nCONFIG_MMU_PAGE_SIZE. However, the stack bound check function\nwas still using the MMU page size, so fix that. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|stack_info\noperator|.\nname|start\noperator|-\nname|CONFIG_MMU_PAGE_SIZE\nexpr_stmt|;\nname|end\noperator|=\nname|_current\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_MMU_PAGE_SIZE\n+name|CONFIG_PRIVILEGED_STACK_SIZE\nThe issue was with: x86: correct size for stack bound check for privileged stack\n\nPrevious commit changed the privileged stack size to be using\nkconfig CONFIG_PRIVILEGED_STACK_SIZE instead of simply\nCONFIG_MMU_PAGE_SIZE. However, the stack bound check function\nwas still using the MMU page size, so fix that."
},{
  "instruction": "There is an issue in the following code. It relates to x86: synchronize usage of CONFIG_X86_STACK_PROTECTION\n\nMost places use CONFIG_X86_STACK_PROTECTION, but there are some\nplaces using CONFIG_HW_STACK_PROTECTION. So synchronize all\nto use CONFIG_X86_STACK_PROTECTION instead. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_HW_STACK_PROTECTION\nargument_list|)\ncomment|/* With hardware stack protection, the first page of stack \t * is a guard page. So need to skip it. \t */\nname|stack_start\noperator|+=\nname|CONFIG_MMU_PAGE_SIZE\n    # code/data segments. If we are doing stack protection, we are going to\n    # have two TSS to manage the main task and the special task for double\n    # fault exception handling\n    if \"CONFIG_USERSPACE\" in syms:\n        num_entries = 7\n   elif \"CONFIG_HW_STACK_PROTECTION\" in syms:\n        num_entries = 5\n    else:\n        num_entries = 3\n\n    use_tls = False\nend_comment\n\nbegin_ifdef\nifdef|#\ndirective|ifdef\nname|CONFIG_HW_STACK_PROTECTION\nend_ifdef\n\nbegin_comment\ncomment|/* Legacy function - set identity-mapped MMU stack guard page to RO in the  * kernel's page tables to prevent writes and generate an exception  */\nend_comment\nbegin_elif\nelif|#\ndirective|elif\nname|defined\nargument_list|(\nname|CONFIG_HW_STACK_PROTECTION\nargument_list|)\nend_elif\n\nbegin_define\nDECL|macro|GS_TLS_SEG\n#define GDT_NUM_TLS_ENTRIES 0\n#endif\n\n#ifdef CONFIG_USERSPACE\n    #define GDT_NUM_ENTRIES 7\n#elif defined(CONFIG_HW_STACK_PROTECTION)\n    #define GDT_NUM_ENTRIES 5\n#else\n    #define GDT_NUM_ENTRIES 3\n#endif /* CONFIG_X86_USERSPACE */\n\t. += (GDT_NUM_ENTRIES + GDT_NUM_TLS_ENTRIES) * 8;\nbegin_if\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_HW_STACK_PROTECTION\nargument_list|)\noperator|||\nname|defined\nargument_list|(\nname|CONFIG_USERSPACE\nstruct|struct\nname|z_x86_thread_stack_header\nblock|{\nifdef|#\ndirective|ifdef\nname|CONFIG_HW_STACK_PROTECTION\nDECL|member|guard_page\nname|char\nname|guard_page\nindex|[\nname|CONFIG_MMU_PAGE_SIZE\nend_define\n\nbegin_ifdef\nifdef|#\ndirective|ifdef\nname|CONFIG_HW_STACK_PROTECTION\nend_ifdef\n\nbegin_define\nDECL|macro|ARCH_KERNEL_STACK_RESERVED\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_HW_STACK_PROTECTION\n+name|CONFIG_X86_STACK_PROTECTION\n-    elif \"CONFIG_HW_STACK_PROTECTION\" in syms:\n+    elif \"CONFIG_X86_STACK_PROTECTION\" in syms:\n-name|CONFIG_HW_STACK_PROTECTION\n+name|CONFIG_X86_STACK_PROTECTION\n-name|CONFIG_HW_STACK_PROTECTION\n+name|CONFIG_X86_STACK_PROTECTION\n-#elif defined(CONFIG_HW_STACK_PROTECTION)\n+#elif defined(CONFIG_X86_STACK_PROTECTION)\n-name|CONFIG_HW_STACK_PROTECTION\n+name|CONFIG_X86_STACK_PROTECTION\n-name|CONFIG_HW_STACK_PROTECTION\n+name|CONFIG_X86_STACK_PROTECTION\n-name|CONFIG_HW_STACK_PROTECTION\n+name|CONFIG_X86_STACK_PROTECTION\nThe issue was with: x86: synchronize usage of CONFIG_X86_STACK_PROTECTION\n\nMost places use CONFIG_X86_STACK_PROTECTION, but there are some\nplaces using CONFIG_HW_STACK_PROTECTION. So synchronize all\nto use CONFIG_X86_STACK_PROTECTION instead."
},{
  "instruction": "There is an issue in the following code. It relates to net: dhcpv4_server: Fix positive error codes returned\n\nerrno values are positive, therefore they should be negated when\nassigned as return values for net_dhcpv4_server_start(). Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|0\ncondition|)\nblock|{\nname|ret\noperator|=\nname|errno\nexpr_stmt|;\nname|LOG_ERR\nargument_list|(\nliteral|\"Failed to create DHCPv4 server socket, %d\"\nliteral|0\ncondition|)\nblock|{\nname|ret\noperator|=\nname|errno\nexpr_stmt|;\nname|LOG_ERR\nargument_list|(\nliteral|\"Failed to bind DHCPv4 server socket with interface, %d\"\nliteral|0\ncondition|)\nblock|{\nname|ret\noperator|=\nname|errno\nexpr_stmt|;\nname|LOG_ERR\nargument_list|(\nliteral|\"Failed to bind DHCPv4 server socket, %d\"",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|-\n+operator|-\n+operator|-\nThe issue was with: net: dhcpv4_server: Fix positive error codes returned\n\nerrno values are positive, therefore they should be negated when\nassigned as return values for net_dhcpv4_server_start()."
},{
  "instruction": "There is an issue in the following code. It relates to samples: sensor: qdec: Allow coverage calculation\n\nSample must end to dump coverage data. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nname|qenc_emulate_init\nargument_list|()\nexpr_stmt|;\nwhile|while\ncondition|(\nname|true\ncondition|)\nblock|{\nname|rc\noperator|=\nname|sensor_sample_fetch\nargument_list|(\nname|dev",
  "result": "I corrected the issue in the code by changing the following tokens:\n+ifndef|#\n+directive|ifndef\n+name|CONFIG_COVERAGE\n+else|#\n+directive|else\n+for|for\n+control|(\n+name|int\n+name|i\n+init|=\n+literal|0\n+init|;\n+name|i\n+operator|<\n+literal|3\n+condition|;\n+name|i\n+operator|++\n+control|)\n+block|{\n+endif|#\n+directive|endif\nThe issue was with: samples: sensor: qdec: Allow coverage calculation\n\nSample must end to dump coverage data."
},{
  "instruction": "There is an issue in the following code. It relates to lib: smf: check for NULL\n\ndon't execute share_paren() if the target is NULL\nin smf_execute_ancestor_exit_actions() Please fix this issue.",
  "input": "Faulty tokenized code:\nname|parent\ncontrol|)\nblock|{\nif|if\ncondition|(\noperator|!\nname|share_paren\nargument_list|(\nname|target\noperator|->\nname|parent\nargument_list|,\nname|tmp_state\nargument_list|)\noperator|&&\nname|tmp_state\noperator|->\nname|exit\ncondition|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+name|target\n+operator|==\n+name|NULL\n+operator|||\n+operator|)\nThe issue was with: lib: smf: check for NULL\n\ndon't execute share_paren() if the target is NULL\nin smf_execute_ancestor_exit_actions()"
},{
  "instruction": "There is an issue in the following code. It relates to subsys/mgmt/hawkbit: use `zsock_setsockopt` instead of `setsockopt`\n\n`setsockopt` is enabled by `CONFIG_POSIX_API`, use\n`zsock_setsockopt` instead, otherwise there will be a\ncompilation error if `CONFIG_NET_SOCKETS_SOCKOPT_TLS` is\nenabled. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|hb_context\nstruct|;\nend_struct\n\nbegin_union\nDECL|union|__anon2797fdf6010a\nspecifier|static\nunion|union\nblock|{\nDECL|member|dep\nname|struct\nname|CA_CERTIFICATE_TAG\nblock|, \t}\ndecl_stmt|;\nif|if\ncondition|(\nname|setsockopt\nargument_list|(\nname|hb_context\noperator|.\nname|sock\nargument_list|,\nname|err_sock\ngoto|;\nblock|}\nif|if\ncondition|(\nname|setsockopt\nargument_list|(\nname|hb_context\noperator|.\nname|sock\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon2797fdf6010a\n+DECL|union|__anon2889165c010a\n-name|setsockopt\n+name|zsock_setsockopt\n-name|setsockopt\n+name|zsock_setsockopt\nThe issue was with: subsys/mgmt/hawkbit: use `zsock_setsockopt` instead of `setsockopt`\n\n`setsockopt` is enabled by `CONFIG_POSIX_API`, use\n`zsock_setsockopt` instead, otherwise there will be a\ncompilation error if `CONFIG_NET_SOCKETS_SOCKOPT_TLS` is\nenabled."
},{
  "instruction": "There is an issue in the following code. It relates to soc/intel_adsp: ipc: Remove fragile device state check\n\nChecking if the device state is locked is not correct, device runtime\nput / get is no longer checking for it and the only place that was\nlocking device's state was the pm action callback and if the idea\nwas to protect some concurrent call, using it is not enough. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ESHUTDOWN\nreturn|;\nblock|}\nendif|#\ndirective|endif\nif|if\ncondition|(\nname|pm_device_state_is_locked\nargument_list|(\nname|INTEL_ADSP_IPC_HOST_DEV\nargument_list|)\ncondition|)\nblock|{\nreturn|return\noperator|-\nname|EAGAIN\nreturn|;\nblock|}\nname|pm_device_busy_set\nargument_list|(\nname|dev\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-if|if\n-condition|(\n-name|pm_device_state_is_locked\n-argument_list|(\n-name|INTEL_ADSP_IPC_HOST_DEV\n-argument_list|)\n-condition|)\n-block|{\n-return|return\n-operator|-\n-name|EAGAIN\n-return|;\n-block|}\nThe issue was with: soc/intel_adsp: ipc: Remove fragile device state check\n\nChecking if the device state is locked is not correct, device runtime\nput / get is no longer checking for it and the only place that was\nlocking device's state was the pm action callback and if the idea\nwas to protect some concurrent call, using it is not enough."
},{
  "instruction": "There is an issue in the following code. It relates to soc/intel_adsp: ipc: Remove unnecessary device state lock\n\nThere is no needed to lock/unlock a device state in its pm action\ncallback. The power management subsystem should take care of\nserialize these calls. Please fix this issue.",
  "input": "Faulty tokenized code:\ncondition|)\nblock|{\ncase|case\nname|PM_DEVICE_ACTION_SUSPEND\ncase|:\nname|pm_device_state_lock\nargument_list|(\nname|dev\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|api\noperator|->\nname|suspend_fn\nblock|}\nbreak|break;\ncase|case\nname|PM_DEVICE_ACTION_RESUME\ncase|:\nname|pm_device_state_lock\nargument_list|(\nname|dev\nargument_list|)\nexpr_stmt|;\nname|irq_enable\nargument_list|(\nname|DT_IRQN\nargument_list|(\nname|INTEL_ADSP_IPC_HOST_DTNODE\nreturn|return\noperator|-\nname|ENOTSUP\nreturn|;\nblock|}\nname|pm_device_state_unlock\nargument_list|(\nname|dev\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|ret\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|pm_device_state_lock\n-argument_list|(\n-name|dev\n-argument_list|)\n-expr_stmt|;\n-name|pm_device_state_lock\n-argument_list|(\n-name|dev\n-argument_list|)\n-expr_stmt|;\n-name|pm_device_state_unlock\n-argument_list|(\n-name|dev\n-argument_list|)\n-expr_stmt|;\nThe issue was with: soc/intel_adsp: ipc: Remove unnecessary device state lock\n\nThere is no needed to lock/unlock a device state in its pm action\ncallback. The power management subsystem should take care of\nserialize these calls."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: timeout: Optimize setting next alarm\n\nNext timeout was set unconditionally at the end of sys_clock_announce.\nHowever, if one of the current expired timeouts was setting a new\ntimeout which is the first to execute then system clock was configured\ntwice. Lets configure system clock only once in the isr at the and of\nsys_clock_announce.\n\nIf timeouts are frequent this optimization can reduce CPU load. In\nmany cases setting the new sys_clock timeout is the most time\nconsuming operation in the sys_clock isr handler. As an example,\non the target I used setting new sys_clock timeout is taking 6 uS of\n9 uS spent in the isr and it takes 16 uS with the redundant call. Please fix this issue.",
  "input": "Faulty tokenized code:\ncondition|(\nname|to\noperator|==\nname|first\nargument_list|()\ncondition|)\nblock|{\nname|sys_clock_set_timeout\nargument_list|(\nname|next_timeout",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|&&\n+name|announce_remaining\n+operator|==\n+literal|0\nThe issue was with: kernel: timeout: Optimize setting next alarm\n\nNext timeout was set unconditionally at the end of sys_clock_announce.\nHowever, if one of the current expired timeouts was setting a new\ntimeout which is the first to execute then system clock was configured\ntwice. Lets configure system clock only once in the isr at the and of\nsys_clock_announce.\n\nIf timeouts are frequent this optimization can reduce CPU load. In\nmany cases setting the new sys_clock timeout is the most time\nconsuming operation in the sys_clock isr handler. As an example,\non the target I used setting new sys_clock timeout is taking 6 uS of\n9 uS spent in the isr and it takes 16 uS with the redundant call."
},{
  "instruction": "There is an issue in the following code. It relates to ipc: intel_adsp: Ensure IPC completion before runtime idle\n\nPrevent the system from entering runtime idle state during IPC\ntransactions until the HOST acknowledgment is received.\n\nThis patch modifies the IPC mechanism to:\n- Lock the runtime idle state immediately after sending an IPC message\n  to the HOST, preventing the system from entering a low-power state.\n- Unlock the runtime idle state once the IPC transaction is acknowledged\n  by the HOST, allowing the system to enter low-power states if\n  conditions permit.\n\nThe changes ensure that the DSP does not enter a power state that could\ninterrupt the IPC communication process, maintaining the integrity of\nthe IPC state machine. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/pm/device.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<errno.h>\nend_include\noperator|->\nname|tx_ack_pending\noperator|=\nname|false\nexpr_stmt|;\nname|k_sem_give\nargument_list|(\noperator|&\nname|devdata\noperator|->\nliteral|0\nargument_list|,\nliteral|1\nargument_list|)\nexpr_stmt|;\nname|devdata\noperator|->\nname|tx_ack_pending\noperator|=\nname|true",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/pm/policy.h>\n+end_include\n+\n+comment|/* Allow the system to enter the runtime idle state after the IPC acknowledgment \t\t * is received. \t\t */\n+name|pm_policy_state_lock_get\n+argument_list|(\n+name|PM_STATE_RUNTIME_IDLE\n+argument_list|,\n+name|PM_ALL_SUBSTATES\n+argument_list|)\n+expr_stmt|;\n+comment|/* Prevent entering runtime idle state until IPC acknowledgment is received. */\n+name|pm_policy_state_lock_put\n+argument_list|(\n+name|PM_STATE_RUNTIME_IDLE\n+argument_list|,\n+name|PM_ALL_SUBSTATES\n+argument_list|)\n+expr_stmt|;\nThe issue was with: ipc: intel_adsp: Ensure IPC completion before runtime idle\n\nPrevent the system from entering runtime idle state during IPC\ntransactions until the HOST acknowledgment is received.\n\nThis patch modifies the IPC mechanism to:\n- Lock the runtime idle state immediately after sending an IPC message\n  to the HOST, preventing the system from entering a low-power state.\n- Unlock the runtime idle state once the IPC transaction is acknowledged\n  by the HOST, allowing the system to enter low-power states if\n  conditions permit.\n\nThe changes ensure that the DSP does not enter a power state that could\ninterrupt the IPC communication process, maintaining the integrity of\nthe IPC state machine."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: usb: stm32: Dont disable ULPI clock on low power\n\nWhen running the cdc_acm demo on a board with an external ULPI\nphy, the device is unable to enumerate:\n\nusb 1-1.8.3.1: new full-speed USB device number 51 using ehci-pci\nusb 1-1.8.3.1: device descriptor read/64, error -32\nusb 1-1.8.3.1: device descriptor read/64, error -32\n\nthe console shows:\n\n[00:00:00.001,000] cdc_acm_echo: Wait for DTR\n[00:00:00.007,000] usb_cdc_acm: Device suspended\n[00:00:00.902,000] usb_cdc_acm: Device resumed\n[00:00:00.902,000] usb_cdc_acm: from suspend\n[00:00:25.526,000] usb_cdc_acm: Device suspended\n\nBy not disabling the ULPI clock in low power, the usb enumeration\nis working and we can run the cdc_acm demo. While touching\nthis code, add some comments to clarify the macro nesting. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nendif|#\ndirective|endif\nelse|#\ndirective|else\ncomment|/* Disable ULPI interface (for external high-speed PHY) clock in low \t * power mode. It is disabled by default in run power mode, no need to \t * disable it. \t */\nname|LL_AHB1_GRP1_DisableClockLowPower\nargument_list|(\nname|LL_AHB1_GRP1_PERIPH_OTGHSULPI\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\nendif|#\ndirective|endif\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function\nexpr_stmt|;\nendif|#\ndirective|endif\nelse|#\ndirective|else\ncomment|/* Disable ULPI interface (for external high-speed PHY) clock in low \t * power mode. It is disabled by default in run power mode, no need to \t * disable it. \t */\nname|LL_AHB1_GRP1_DisableClockLowPower\nargument_list|(\nname|LL_AHB1_GRP1_PERIPH_OTGHSULPI\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\nendif|#\ndirective|endif\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* DT_HAS_COMPAT_STATUS_OKAY(st_stm32_usbphyc) */\n+if|#\n+directive|if\n+operator|!\n+name|USB_OTG_HS_ULPI_PHY\n+comment|/* USB_OTG_HS_ULPI_PHY */\n+endif|#\n+directive|endif\n+comment|/* DT_HAS_COMPAT_STATUS_OKAY(st_stm32_usbphyc) */\n+comment|/* DT_HAS_COMPAT_STATUS_OKAY(st_stm32_otghs) */\n+comment|/* DT_HAS_COMPAT_STATUS_OKAY(st_stm32_usbphyc) */\n+if|#\n+directive|if\n+operator|!\n+name|USB_OTG_HS_ULPI_PHY\n+comment|/* USB_OTG_HS_ULPI_PHY */\n+endif|#\n+directive|endif\n+comment|/* DT_HAS_COMPAT_STATUS_OKAY(st_stm32_usbphyc) */\n+comment|/* DT_HAS_COMPAT_STATUS_OKAY(st_stm32_otghs) */\nThe issue was with: drivers: usb: stm32: Dont disable ULPI clock on low power\n\nWhen running the cdc_acm demo on a board with an external ULPI\nphy, the device is unable to enumerate:\n\nusb 1-1.8.3.1: new full-speed USB device number 51 using ehci-pci\nusb 1-1.8.3.1: device descriptor read/64, error -32\nusb 1-1.8.3.1: device descriptor read/64, error -32\n\nthe console shows:\n\n[00:00:00.001,000] cdc_acm_echo: Wait for DTR\n[00:00:00.007,000] usb_cdc_acm: Device suspended\n[00:00:00.902,000] usb_cdc_acm: Device resumed\n[00:00:00.902,000] usb_cdc_acm: from suspend\n[00:00:25.526,000] usb_cdc_acm: Device suspended\n\nBy not disabling the ULPI clock in low power, the usb enumeration\nis working and we can run the cdc_acm demo. While touching\nthis code, add some comments to clarify the macro nesting."
},{
  "instruction": "There is an issue in the following code. It relates to GNSS: Increase size of hdop\n\nThe valid range of hdop (horizontal diffusion of precision) goes\nfrom 0-100000, but because we are using a uint16_t, we truncate\nanything above UINT16_MAX.\n\nThis fix changes the size of the hdop member to a uint32_t, which\nallows us to capture valid (but admittedly very poor) readings. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|)\noperator|||\noperator|(\nname|tmp64\noperator|>\nname|UINT16_MAX\noperator|)\noperator|||\noperator|(\nname|tmp64\noperator|<\nname|uint16_t\nname|satellites_cnt\ndecl_stmt|;\ncomment|/** Horizontal dilution of precision in 1/1000 */\nDECL|member|hdop\nname|uint16_t\nname|hdop\ndecl_stmt|;\ncomment|/** The fix status */\nDECL|member|fix_status\nname|enum",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|UINT16_MAX\n+name|UINT32_MAX\n-name|uint16_t\n+name|uint32_t\nThe issue was with: GNSS: Increase size of hdop\n\nThe valid range of hdop (horizontal diffusion of precision) goes\nfrom 0-100000, but because we are using a uint16_t, we truncate\nanything above UINT16_MAX.\n\nThis fix changes the size of the hdop member to a uint32_t, which\nallows us to capture valid (but admittedly very poor) readings."
},{
  "instruction": "There is an issue in the following code. It relates to net: connection: Log an error when running out of contexts\n\nRunning out of connection contexts is most likely due to app\nmisconfiguration, therefore it's useful to get an explicit information\nthat context allocation failed. Please fix this issue.",
  "input": "Faulty tokenized code:\ncondition|(\noperator|!\nname|conn\ncondition|)\nblock|{\nreturn|return\noperator|-\nname|ENOENT\nreturn|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|NET_ERR\n+argument_list|(\n+literal|\"Not enough connection contexts. \"\n+literal|\"Consider increasing CONFIG_NET_MAX_CONN.\"\n+argument_list|)\n+expr_stmt|;\nThe issue was with: net: connection: Log an error when running out of contexts\n\nRunning out of connection contexts is most likely due to app\nmisconfiguration, therefore it's useful to get an explicit information\nthat context allocation failed."
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: rtc: rtc_api\n\nCorrect time check for get/set\nPrevious check would always pass as it checked get/get. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|alarm_time_get\noperator|.\nname|tm_min\nargument_list|,\nname|alarm_time_get\noperator|.\nname|tm_min\nargument_list|,\nliteral|\"Incorrect alarm time minute field\"\nargument_list|)\nargument_list|(\nname|alarm_time_get\noperator|.\nname|tm_hour\nargument_list|,\nname|alarm_time_get\noperator|.\nname|tm_hour\nargument_list|,\nliteral|\"Incorrect alarm time hour field\"\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|alarm_time_get\n+name|alarm_time_set\n-name|alarm_time_get\n+name|alarm_time_set\nThe issue was with: tests: drivers: rtc: rtc_api\n\nCorrect time check for get/set\nPrevious check would always pass as it checked get/get."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: CAP: Shell: Stop all streams by default\n\nThe cap_initiator unicast_stop command will now stop\nall streams by default, without supplying the \\\"all\\\" argument. Please fix this issue.",
  "input": "Faulty tokenized code:\n     discover        :Discover CAS\n     unicast_start   :Unicast Start [csip] [sinks <cnt> (default 1)] [sources <cnt>\n                      (default 1)] [conns (<cnt> | all) (default 1)]\n     unicast_list    :Unicast list streams\n     unicast_update  :Unicast Update <all | stream [stream [stream...]]>\n    unicast_stop    :Unicast stop streams <all | stream [stream [stream...]]>\n     unicast_cancel  :Unicast cancel current procedure\n\nBefore being able to perform any stream operation, the device must also perform the\n:code:`bap discover` operation to discover the ASEs and PAC records. The :code:`bap init`\ncommand also needs to be called.\nblock|}\nif|if\ncondition|(\nname|argc\noperator|==\nliteral|2\noperator|&&\nname|strcmp\nargument_list|(\nname|argv\nindex|[\nliteral|1\nindex|]\nargument_list|,\nliteral|\"all\"\nargument_list|)\noperator|==\nliteral|0\ncondition|)\nblock|{\nfor|for\ncontrol|(\nname|size_t\nargument_list|(\nname|unicast_stop\nargument_list|,\nname|NULL\nargument_list|,\nliteral|\"Unicast stop streams<all | stream [stream [stream...]]>\"\nargument_list|,\nname|cmd_cap_initiator_unicast_stop\nargument_list|,\nliteral|2\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-     unicast_stop    :Unicast stop streams <all | stream [stream [stream...]]>\n+     unicast_stop    :Unicast stop streams [stream [stream [stream...]]] (all by default)\n-literal|2\n-operator|&&\n-name|strcmp\n-argument_list|(\n-name|argv\n-index|[\n-index|]\n-argument_list|,\n-literal|\"all\"\n-argument_list|)\n-operator|==\n-literal|0\n-literal|\"Unicast stop streams<all | stream [stream [stream...]]>\"\n+literal|\"Unicast stop streams [stream [stream [stream...]]] (all by default)\"\nThe issue was with: Bluetooth: CAP: Shell: Stop all streams by default\n\nThe cap_initiator unicast_stop command will now stop\nall streams by default, without supplying the \\\"all\\\" argument."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: L2CAP: Reword K-frame comment\n\nThe terminology was not following the Spec wording. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}\ncomment|/* Prepend SDU \"header\". \t * \t * L2CAP LE CoC SDUs are segmented into PDUs and sent over so-called \t * K-frames that each have their own L2CAP header (ie channel, PDU \t * length). \t * \t * The SDU header is right before the data that will be segmented and is \t * only present in the first segment/PDU. Here's an example: \t * \t * Sent data payload of 50 bytes over channel 0x4040 with MPS of 30 bytes: \t * First PDU / segment / K-frame: \t * | L2CAP K-frame header        | K-frame payload                 | \t * | PDU length  | Channel ID    | SDU header   | SDU payload      | \t * | 30          | 0x4040        | 50           | 28 bytes of data | \t * \t * Second and last PDU / segment / K-frame: \t * | L2CAP K-frame header        | K-frame payload     | \t * | PDU length  | Channel ID    | rest of SDU payload | \t * | 22          | 0x4040        | 22 bytes of data    | \t */\nname|net_buf_push_le16\nargument_list|(\nname|buf\nargument_list|,\nname|sdu_len",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* Prepend SDU \"header\". \t * \t * L2CAP LE CoC SDUs are segmented into PDUs and sent over so-called \t * K-frames that each have their own L2CAP header (ie channel, PDU \t * length). \t * \t * The SDU header is right before the data that will be segmented and is \t * only present in the first segment/PDU. Here's an example: \t * \t * Sent data payload of 50 bytes over channel 0x4040 with MPS of 30 bytes: \t * First PDU / segment / K-frame: \t * | L2CAP K-frame header        | K-frame payload                 | \t * | PDU length  | Channel ID    | SDU header   | SDU payload      | \t * | 30          | 0x4040        | 50           | 28 bytes of data | \t * \t * Second and last PDU / segment / K-frame: \t * | L2CAP K-frame header        | K-frame payload     | \t * | PDU length  | Channel ID    | rest of SDU payload | \t * | 22          | 0x4040        | 22 bytes of data    | \t */\n+comment|/* Prepend SDU length. \t * \t * L2CAP LE CoC SDUs are segmented and put into K-frames PDUs which have \t * their own L2CAP header (i.e. PDU length, channel id). \t * \t * The SDU length is right before the data that will be segmented and is \t * only present in the first PDU. Here's an example: \t * \t * Sent data payload of 50 bytes over channel 0x4040 with MPS of 30 bytes: \t * First PDU (K-frame): \t * | L2CAP K-frame header        | K-frame payload                 | \t * | PDU length  | Channel ID    | SDU length   | SDU payload      | \t * | 0x001e      | 0x4040        | 0x0032       | 28 bytes of data | \t * \t * Second and last PDU (K-frame): \t * | L2CAP K-frame header        | K-frame payload     | \t * | PDU length  | Channel ID    | rest of SDU payload | \t * | 0x0016      | 0x4040        | 22 bytes of data    | \t */\nThe issue was with: Bluetooth: L2CAP: Reword K-frame comment\n\nThe terminology was not following the Spec wording."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: clock_control: esp32: Multiple fixes\n\n- update the console configuration defines references\n- add missing header file with flash capabilities\n- replace all console wait-until-ready calls by single one Please fix this issue.",
  "input": "Faulty tokenized code:\n\nbegin_comment\ncomment|/* CONFIG_SOC_SERIES_ESP32xx */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nfile|<esp_rom_sys.h>\nend_include\nname|new_config\ndecl_stmt|;\nname|bool\nname|res\ndecl_stmt|;\ncomment|/* reset default config to use dts config */\nif|if\ncondition|(\nname|rtc_clk_apb_freq_get\nargument_list|()\nreturn|return\noperator|-\nname|ENOTSUP\nreturn|;\nblock|}\ncomment|/* wait uart output to be cleared */\nname|esp_rom_uart_tx_wait_idle\nargument_list|(\nliteral|0\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|cfg\noperator|->\nname|xtal_div\nname|esp_clk_xtal_freq\nargument_list|()\nexpr_stmt|;\nendif|#\ndirective|endif\nname|esp_rom_uart_tx_wait_idle\nargument_list|(\nname|ESP_CONSOLE_UART_NUM\nargument_list|)\nexpr_stmt|;\nif|#\ndirective|if\noperator|!\nname|defined\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<esp_rom_caps.h>\n+end_include\n+\n+comment|/* wait uart output to be cleared */\n+name|esp_rom_uart_tx_wait_idle\n+argument_list|(\n+name|ESP_CONSOLE_UART_NUM\n+argument_list|)\n+expr_stmt|;\n-comment|/* wait uart output to be cleared */\n-name|esp_rom_uart_tx_wait_idle\n-argument_list|(\n-literal|0\n-argument_list|)\n-expr_stmt|;\n-name|esp_rom_uart_tx_wait_idle\n-argument_list|(\n-name|ESP_CONSOLE_UART_NUM\n-argument_list|)\n-expr_stmt|;\nThe issue was with: drivers: clock_control: esp32: Multiple fixes\n\n- update the console configuration defines references\n- add missing header file with flash capabilities\n- replace all console wait-until-ready calls by single one"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: meas: Move to vendor subdirectory\n\nOrganizes sensor drivers by vendor to distribute maintainership\nresponsibilities. Please fix this issue.",
  "input": "Faulty tokenized code:\nadd_subdirectory(espressif)\nadd_subdirectory(honeywell)\nadd_subdirectory(infineon)\nadd_subdirectory(ite)\nadd_subdirectory(maxim)\nadd_subdirectory(microchip)\nadd_subdirectory(nordic)\nadd_subdirectory(nuvoton)\nadd_subdirectory(nxp)\nadd_subdirectory(rohm)\nadd_subdirectory_ifdef(CONFIG_LTR_F216A ltrf216a)\nadd_subdirectory_ifdef(CONFIG_MC3419 mc3419)\nadd_subdirectory_ifdef(CONFIG_MHZ19B mhz19b)\nadd_subdirectory_ifdef(CONFIG_MPU6050 tdk/mpu6050)\nadd_subdirectory_ifdef(CONFIG_MPU9250 tdk/mpu9250)\nadd_subdirectory_ifdef(CONFIG_MS5607 ms5607)\nadd_subdirectory_ifdef(CONFIG_MS5837 ms5837)\nadd_subdirectory_ifdef(CONFIG_NTC_THERMISTOR ntc_thermistor)\nadd_subdirectory_ifdef(CONFIG_PMS7003 pms7003)\nadd_subdirectory_ifdef(CONFIG_QDEC_SAM qdec_sam)\nadd_subdirectory_ifdef(CONFIG_RPI_PICO_TEMP rpi_pico_temp)\nadd_subdirectory_ifdef(CONFIG_S11059 s11059)\nsource \"drivers/sensor/espressif/Kconfig\"\nsource \"drivers/sensor/honeywell/Kconfig\"\nsource \"drivers/sensor/infineon/Kconfig\"\nsource \"drivers/sensor/ite/Kconfig\"\nsource \"drivers/sensor/maxim/Kconfig\"\nsource \"drivers/sensor/microchip/Kconfig\"\nsource \"drivers/sensor/nordic/Kconfig\"\nsource \"drivers/sensor/nuvoton/Kconfig\"\nsource \"drivers/sensor/nxp/Kconfig\"\nsource \"drivers/sensor/rohm/Kconfig\"\nsource \"drivers/sensor/ltrf216a/Kconfig\"\nsource \"drivers/sensor/mc3419/Kconfig\"\nsource \"drivers/sensor/mhz19b/Kconfig\"\nsource \"drivers/sensor/tdk/mpu6050/Kconfig\"\nsource \"drivers/sensor/tdk/mpu9250/Kconfig\"\nsource \"drivers/sensor/ms5607/Kconfig\"\nsource \"drivers/sensor/ms5837/Kconfig\"\nsource \"drivers/sensor/ntc_thermistor/Kconfig\"\nsource \"drivers/sensor/pms7003/Kconfig\"\nsource \"drivers/sensor/qdec_sam/Kconfig\"\nsource \"drivers/sensor/rpi_pico_temp/Kconfig\"\nsource \"drivers/sensor/s11059/Kconfig\"\nnew file mode 100644\nnew file mode 100644\nsimilarity index 100%\nrename from drivers/sensor/ms5607/CMakeLists.txt\nrename to drivers/sensor/meas/ms5607/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/ms5607/Kconfig\nrename to drivers/sensor/meas/ms5607/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/ms5607/ms5607.c\nrename to drivers/sensor/meas/ms5607/ms5607.c\nsimilarity index 100%\nrename from drivers/sensor/ms5607/ms5607.h\nrename to drivers/sensor/meas/ms5607/ms5607.h\nsimilarity index 100%\nrename from drivers/sensor/ms5607/ms5607_i2c.c\nrename to drivers/sensor/meas/ms5607/ms5607_i2c.c\nsimilarity index 100%\nrename from drivers/sensor/ms5607/ms5607_spi.c\nrename to drivers/sensor/meas/ms5607/ms5607_spi.c\nsimilarity index 100%\nrename from drivers/sensor/ms5837/CMakeLists.txt\nrename to drivers/sensor/meas/ms5837/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/ms5837/Kconfig\nrename to drivers/sensor/meas/ms5837/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/ms5837/ms5837.c\nrename to drivers/sensor/meas/ms5837/ms5837.c\nsimilarity index 100%\nrename from drivers/sensor/ms5837/ms5837.h\nrename to drivers/sensor/meas/ms5837/ms5837.h",
  "result": "I corrected the issue in the code by changing the following tokens:\n+add_subdirectory(meas)\n-add_subdirectory_ifdef(CONFIG_MS5607 ms5607)\n-add_subdirectory_ifdef(CONFIG_MS5837 ms5837)\n+source \"drivers/sensor/meas/Kconfig\"\n-source \"drivers/sensor/ms5607/Kconfig\"\n-source \"drivers/sensor/ms5837/Kconfig\"\n+# Copyright (c) 2024 Analog Devices, Inc.\n+# SPDX-License-Identifier: Apache-2.0\n+\n+# zephyr-keep-sorted-start\n+add_subdirectory_ifdef(CONFIG_MS5607 ms5607)\n+add_subdirectory_ifdef(CONFIG_MS5837 ms5837)\n+# zephyr-keep-sorted-stop\n+# Copyright (c) 2024 Analog Devices, Inc.\n+# SPDX-License-Identifier: Apache-2.0\n+\n+# zephyr-keep-sorted-start\n+source \"drivers/sensor/meas/ms5607/Kconfig\"\n+source \"drivers/sensor/meas/ms5837/Kconfig\"\n+# zephyr-keep-sorted-stop\nThe issue was with: drivers: sensor: meas: Move to vendor subdirectory\n\nOrganizes sensor drivers by vendor to distribute maintainership\nresponsibilities."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: asahi_kasei: Move to vendor subdirectory\n\nOrganizes sensor drivers by vendor to distribute maintainership\nresponsibilities. Please fix this issue.",
  "input": "Faulty tokenized code:\n\n# zephyr-keep-sorted-start\nadd_subdirectory(adi)\nadd_subdirectory(ams)\nadd_subdirectory(aosong)\nadd_subdirectory(bosch)\nadd_subdirectory(espressif)\nadd_subdirectory(honeywell)\nadd_subdirectory(infineon)\nadd_subdirectory(ite)\nadd_subdirectory(vishay)\nadd_subdirectory(wsen)\n# zephyr-keep-sorted-stop\n\nadd_subdirectory_ifdef(CONFIG_A01NYUB a01nyub)\nadd_subdirectory_ifdef(CONFIG_AK8975 ak8975)\nadd_subdirectory_ifdef(CONFIG_AKM09918C akm09918c)\nadd_subdirectory_ifdef(CONFIG_AMD_SB_TSI amd_sb_tsi)\nadd_subdirectory_ifdef(CONFIG_AMG88XX amg88xx)\nadd_subdirectory_ifdef(CONFIG_APDS9960 apds9960)\nadd_subdirectory_ifdef(CONFIG_CURRENT_AMP current_amp)\nadd_subdirectory_ifdef(CONFIG_ENS160 ens160)\n\n# zephyr-keep-sorted-start\nsource \"drivers/sensor/adi/Kconfig\"\nsource \"drivers/sensor/ams/Kconfig\"\nsource \"drivers/sensor/aosong/Kconfig\"\nsource \"drivers/sensor/bosch/Kconfig\"\nsource \"drivers/sensor/espressif/Kconfig\"\nsource \"drivers/sensor/honeywell/Kconfig\"\nsource \"drivers/sensor/infineon/Kconfig\"\nsource \"drivers/sensor/ite/Kconfig\"\nsource \"drivers/sensor/vishay/Kconfig\"\nsource \"drivers/sensor/wsen/Kconfig\"\n# zephyr-keep-sorted-stop\n\nsource \"drivers/sensor/a01nyub/Kconfig\"\nsource \"drivers/sensor/ak8975/Kconfig\"\nsource \"drivers/sensor/akm09918c/Kconfig\"\nsource \"drivers/sensor/amd_sb_tsi/Kconfig\"\nsource \"drivers/sensor/amg88xx/Kconfig\"\nsource \"drivers/sensor/apds9960/Kconfig\"\nsource \"drivers/sensor/current_amp/Kconfig\"\nsource \"drivers/sensor/ens160/Kconfig\"\nnew file mode 100644\nnew file mode 100644\nsimilarity index 100%\nrename from drivers/sensor/ak8975/CMakeLists.txt\nrename to drivers/sensor/asahi_kasei/ak8975/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/ak8975/Kconfig\nrename to drivers/sensor/asahi_kasei/ak8975/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/ak8975/ak8975.c\nrename to drivers/sensor/asahi_kasei/ak8975/ak8975.c\nsimilarity index 100%\nrename from drivers/sensor/ak8975/ak8975.h\nrename to drivers/sensor/asahi_kasei/ak8975/ak8975.h\nsimilarity index 100%\nrename from drivers/sensor/akm09918c/CMakeLists.txt\nrename to drivers/sensor/asahi_kasei/akm09918c/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/akm09918c/Kconfig\nrename to drivers/sensor/asahi_kasei/akm09918c/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/akm09918c/akm09918c.c\nrename to drivers/sensor/asahi_kasei/akm09918c/akm09918c.c\nsimilarity index 100%\nrename from drivers/sensor/akm09918c/akm09918c.h\nrename to drivers/sensor/asahi_kasei/akm09918c/akm09918c.h\nsimilarity index 100%\nrename from drivers/sensor/akm09918c/akm09918c_async.c\nrename to drivers/sensor/asahi_kasei/akm09918c/akm09918c_async.c\nsimilarity index 100%\nrename from drivers/sensor/akm09918c/akm09918c_decoder.c\nrename to drivers/sensor/asahi_kasei/akm09918c/akm09918c_decoder.c\nsimilarity index 100%\nrename from drivers/sensor/akm09918c/akm09918c_emul.c\nrename to drivers/sensor/asahi_kasei/akm09918c/akm09918c_emul.c\nsimilarity index 100%\nrename from drivers/sensor/akm09918c/akm09918c_emul.h\nrename to drivers/sensor/asahi_kasei/akm09918c/akm09918c_emul.h\nsimilarity index 100%\nrename from drivers/sensor/akm09918c/akm09918c_reg.h\nrename to drivers/sensor/asahi_kasei/akm09918c/akm09918c_reg.h",
  "result": "I corrected the issue in the code by changing the following tokens:\n+add_subdirectory(asahi_kasei)\n-add_subdirectory_ifdef(CONFIG_AK8975 ak8975)\n-add_subdirectory_ifdef(CONFIG_AKM09918C akm09918c)\n+source \"drivers/sensor/asahi_kasei/Kconfig\"\n-source \"drivers/sensor/ak8975/Kconfig\"\n-source \"drivers/sensor/akm09918c/Kconfig\"\n+# Copyright (c) 2024 Analog Devices, Inc.\n+# SPDX-License-Identifier: Apache-2.0\n+\n+# zephyr-keep-sorted-start\n+add_subdirectory_ifdef(CONFIG_AK8975 ak8975)\n+add_subdirectory_ifdef(CONFIG_AKM09918C akm09918c)\n+# zephyr-keep-sorted-stop\n+# Copyright (c) 2024 Analog Devices, Inc.\n+# SPDX-License-Identifier: Apache-2.0\n+\n+# zephyr-keep-sorted-start\n+source \"drivers/sensor/asahi_kasei/ak8975/Kconfig\"\n+source \"drivers/sensor/asahi_kasei/akm09918c/Kconfig\"\n+# zephyr-keep-sorted-stop\nThe issue was with: drivers: sensor: asahi_kasei: Move to vendor subdirectory\n\nOrganizes sensor drivers by vendor to distribute maintainership\nresponsibilities."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: espressif: Move to vendor subdirectory\n\nOrganizes sensor drivers by vendor to distribute maintainership\nresponsibilities. Please fix this issue.",
  "input": "Faulty tokenized code:\n# zephyr-keep-sorted-start\nadd_subdirectory(adi)\nadd_subdirectory(ams)\nadd_subdirectory(aosong)\nadd_subdirectory(bosch)\nadd_subdirectory(honeywell)\nadd_subdirectory(infineon)\nadd_subdirectory(ite)\nadd_subdirectory(maxim)\nadd_subdirectory(microchip)\nadd_subdirectory_ifdef(CONFIG_AMD_SB_TSI amd_sb_tsi)\nadd_subdirectory_ifdef(CONFIG_AMG88XX amg88xx)\nadd_subdirectory_ifdef(CONFIG_APDS9960 apds9960)\nadd_subdirectory_ifdef(CONFIG_CURRENT_AMP current_amp)\nadd_subdirectory_ifdef(CONFIG_ENS160 ens160)\nadd_subdirectory_ifdef(CONFIG_ESP32_TEMP esp32_temp)\nadd_subdirectory_ifdef(CONFIG_EXPLORIR_M explorir_m)\nadd_subdirectory_ifdef(CONFIG_F75303 f75303)\nadd_subdirectory_ifdef(CONFIG_FCX_MLDX5 fcx_mldx5)\nadd_subdirectory_ifdef(CONFIG_GROW_R502A grow_r502a)\nadd_subdirectory_ifdef(CONFIG_HP206C hp206c)\nadd_subdirectory_ifdef(CONFIG_MPU6050 tdk/mpu6050)\nadd_subdirectory_ifdef(CONFIG_MPU9250 tdk/mpu9250)\nadd_subdirectory_ifdef(CONFIG_MS5607 ms5607)\nadd_subdirectory_ifdef(CONFIG_MS5837 ms5837)\nadd_subdirectory_ifdef(CONFIG_NTC_THERMISTOR ntc_thermistor)\nadd_subdirectory_ifdef(CONFIG_PCNT_ESP32 pcnt_esp32)\nadd_subdirectory_ifdef(CONFIG_PMS7003 pms7003)\nadd_subdirectory_ifdef(CONFIG_QDEC_SAM qdec_sam)\nadd_subdirectory_ifdef(CONFIG_RPI_PICO_TEMP rpi_pico_temp)\nadd_subdirectory_ifdef(CONFIG_S11059 s11059)\nadd_subdirectory_ifdef(CONFIG_SBS_GAUGE sbs_gauge)\n# zephyr-keep-sorted-start\nsource \"drivers/sensor/adi/Kconfig\"\nsource \"drivers/sensor/ams/Kconfig\"\nsource \"drivers/sensor/aosong/Kconfig\"\nsource \"drivers/sensor/bosch/Kconfig\"\nsource \"drivers/sensor/honeywell/Kconfig\"\nsource \"drivers/sensor/infineon/Kconfig\"\nsource \"drivers/sensor/ite/Kconfig\"\nsource \"drivers/sensor/maxim/Kconfig\"\nsource \"drivers/sensor/microchip/Kconfig\"\nsource \"drivers/sensor/amd_sb_tsi/Kconfig\"\nsource \"drivers/sensor/amg88xx/Kconfig\"\nsource \"drivers/sensor/apds9960/Kconfig\"\nsource \"drivers/sensor/current_amp/Kconfig\"\nsource \"drivers/sensor/ens160/Kconfig\"\nsource \"drivers/sensor/esp32_temp/Kconfig\"\nsource \"drivers/sensor/explorir_m/Kconfig\"\nsource \"drivers/sensor/f75303/Kconfig\"\nsource \"drivers/sensor/fcx_mldx5/Kconfig\"\nsource \"drivers/sensor/grow_r502a/Kconfig\"\nsource \"drivers/sensor/hp206c/Kconfig\"\nsource \"drivers/sensor/tdk/mpu6050/Kconfig\"\nsource \"drivers/sensor/tdk/mpu9250/Kconfig\"\nsource \"drivers/sensor/ms5607/Kconfig\"\nsource \"drivers/sensor/ms5837/Kconfig\"\nsource \"drivers/sensor/ntc_thermistor/Kconfig\"\nsource \"drivers/sensor/pcnt_esp32/Kconfig\"\nsource \"drivers/sensor/pms7003/Kconfig\"\nsource \"drivers/sensor/qdec_sam/Kconfig\"\nsource \"drivers/sensor/rpi_pico_temp/Kconfig\"\nsource \"drivers/sensor/s11059/Kconfig\"\nsource \"drivers/sensor/sbs_gauge/Kconfig\"\nnew file mode 100644\nnew file mode 100644\nsimilarity index 100%\nrename from drivers/sensor/esp32_temp/CMakeLists.txt\nrename to drivers/sensor/espressif/esp32_temp/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/esp32_temp/Kconfig\nrename to drivers/sensor/espressif/esp32_temp/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/esp32_temp/esp32_temp.c\nrename to drivers/sensor/espressif/esp32_temp/esp32_temp.c\nsimilarity index 100%\nrename from drivers/sensor/pcnt_esp32/CMakeLists.txt\nrename to drivers/sensor/espressif/pcnt_esp32/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/pcnt_esp32/Kconfig\nrename to drivers/sensor/espressif/pcnt_esp32/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/pcnt_esp32/pcnt_esp32.c\nrename to drivers/sensor/espressif/pcnt_esp32/pcnt_esp32.c",
  "result": "I corrected the issue in the code by changing the following tokens:\n+add_subdirectory(espressif)\n-add_subdirectory_ifdef(CONFIG_ESP32_TEMP esp32_temp)\n-add_subdirectory_ifdef(CONFIG_PCNT_ESP32 pcnt_esp32)\n+source \"drivers/sensor/espressif/Kconfig\"\n-source \"drivers/sensor/esp32_temp/Kconfig\"\n-source \"drivers/sensor/pcnt_esp32/Kconfig\"\n+# Copyright (c) 2024 Analog Devices, Inc.\n+# SPDX-License-Identifier: Apache-2.0\n+\n+# zephyr-keep-sorted-start\n+add_subdirectory_ifdef(CONFIG_ESP32_TEMP esp32_temp)\n+add_subdirectory_ifdef(CONFIG_PCNT_ESP32 pcnt_esp32)\n+# zephyr-keep-sorted-stop\n+# Copyright (c) 2024 Analog Devices, Inc.\n+# SPDX-License-Identifier: Apache-2.0\n+\n+# zephyr-keep-sorted-start\n+source \"drivers/sensor/espressif/esp32_temp/Kconfig\"\n+source \"drivers/sensor/espressif/pcnt_esp32/Kconfig\"\n+# zephyr-keep-sorted-stop\nThe issue was with: drivers: sensor: espressif: Move to vendor subdirectory\n\nOrganizes sensor drivers by vendor to distribute maintainership\nresponsibilities."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: infineon: Move to vendor subdirectory\n\nOrganizes sensor drivers by vendor to distribute maintainership\nresponsibilities. Please fix this issue.",
  "input": "Faulty tokenized code:\n    - boards/cypress/\n    - boards/infineon/\n    - drivers/*/*ifx_cat1*\n    - drivers/*/*xmc*/\n    - drivers/*/*xmc*.c\n   - drivers/*/*/*xmc*\n    - dts/arm/infineon/\n    - dts/arm/cypress/\n    - soc/cypress/\n    - dts/bindings/*/*infineon*\n    - soc/infineon/\nadd_subdirectory(adi)\nadd_subdirectory(ams)\nadd_subdirectory(aosong)\nadd_subdirectory(bosch)\nadd_subdirectory(honeywell)\nadd_subdirectory(ite)\nadd_subdirectory(maxim)\nadd_subdirectory(microchip)\nadd_subdirectory(nordic)\nadd_subdirectory(nuvoton)\nadd_subdirectory_ifdef(CONFIG_AKM09918C akm09918c)\nadd_subdirectory_ifdef(CONFIG_AMD_SB_TSI amd_sb_tsi)\nadd_subdirectory_ifdef(CONFIG_AMG88XX amg88xx)\nadd_subdirectory_ifdef(CONFIG_APDS9960 apds9960)\nadd_subdirectory_ifdef(CONFIG_CURRENT_AMP current_amp)\nadd_subdirectory_ifdef(CONFIG_DPS310 dps310)\nadd_subdirectory_ifdef(CONFIG_ENS160 ens160)\nadd_subdirectory_ifdef(CONFIG_ESP32_TEMP esp32_temp)\nadd_subdirectory_ifdef(CONFIG_EXPLORIR_M explorir_m)\nadd_subdirectory_ifdef(CONFIG_F75303 f75303)\nadd_subdirectory_ifdef(CONFIG_FCX_MLDX5 fcx_mldx5)\nadd_subdirectory_ifdef(CONFIG_S11059 s11059)\nadd_subdirectory_ifdef(CONFIG_SBS_GAUGE sbs_gauge)\nadd_subdirectory_ifdef(CONFIG_SX9500 sx9500)\nadd_subdirectory_ifdef(CONFIG_TH02 th02)\nadd_subdirectory_ifdef(CONFIG_VOLTAGE_DIVIDER voltage_divider)\nadd_subdirectory_ifdef(CONFIG_XMC4XXX_TEMP xmc4xxx_temp)\nadd_subdirectory_ifdef(CONFIG_TACH_ENE_KB1200 ene_tach_kb1200)\n\nzephyr_syscall_header(${ZEPHYR_BASE}/include/zephyr/drivers/sensor.h)\n\nzephyr_library()\nsource \"drivers/sensor/adi/Kconfig\"\nsource \"drivers/sensor/ams/Kconfig\"\nsource \"drivers/sensor/aosong/Kconfig\"\nsource \"drivers/sensor/bosch/Kconfig\"\nsource \"drivers/sensor/honeywell/Kconfig\"\nsource \"drivers/sensor/ite/Kconfig\"\nsource \"drivers/sensor/maxim/Kconfig\"\nsource \"drivers/sensor/microchip/Kconfig\"\nsource \"drivers/sensor/nordic/Kconfig\"\nsource \"drivers/sensor/nuvoton/Kconfig\"\nsource \"drivers/sensor/akm09918c/Kconfig\"\nsource \"drivers/sensor/amd_sb_tsi/Kconfig\"\nsource \"drivers/sensor/amg88xx/Kconfig\"\nsource \"drivers/sensor/apds9960/Kconfig\"\nsource \"drivers/sensor/current_amp/Kconfig\"\nsource \"drivers/sensor/dps310/Kconfig\"\nsource \"drivers/sensor/ens160/Kconfig\"\nsource \"drivers/sensor/esp32_temp/Kconfig\"\nsource \"drivers/sensor/explorir_m/Kconfig\"\nsource \"drivers/sensor/f75303/Kconfig\"\nsource \"drivers/sensor/fcx_mldx5/Kconfig\"\nsource \"drivers/sensor/s11059/Kconfig\"\nsource \"drivers/sensor/sbs_gauge/Kconfig\"\nsource \"drivers/sensor/sx9500/Kconfig\"\nsource \"drivers/sensor/th02/Kconfig\"\nsource \"drivers/sensor/voltage_divider/Kconfig\"\nsource \"drivers/sensor/xmc4xxx_temp/Kconfig\"\nsource \"drivers/sensor/ene_tach_kb1200/Kconfig\"\n\nendif # SENSOR\nnew file mode 100644\nnew file mode 100644\nsimilarity index 100%\nrename from drivers/sensor/dps310/CMakeLists.txt\nrename to drivers/sensor/infineon/dps310/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/dps310/Kconfig\nrename to drivers/sensor/infineon/dps310/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/dps310/dps310.c\nrename to drivers/sensor/infineon/dps310/dps310.c\nsimilarity index 100%\nrename from drivers/sensor/xmc4xxx_temp/CMakeLists.txt\nrename to drivers/sensor/infineon/xmc4xxx_temp/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/xmc4xxx_temp/Kconfig\nrename to drivers/sensor/infineon/xmc4xxx_temp/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/xmc4xxx_temp/xmc4xxx_temp.c\nrename to drivers/sensor/infineon/xmc4xxx_temp/xmc4xxx_temp.c",
  "result": "I corrected the issue in the code by changing the following tokens:\n-    - drivers/*/*/*xmc*\n+    - drivers/sensor/infineon/\n+add_subdirectory(infineon)\n-add_subdirectory_ifdef(CONFIG_DPS310 dps310)\n-add_subdirectory_ifdef(CONFIG_XMC4XXX_TEMP xmc4xxx_temp)\n+source \"drivers/sensor/infineon/Kconfig\"\n-source \"drivers/sensor/dps310/Kconfig\"\n-source \"drivers/sensor/xmc4xxx_temp/Kconfig\"\n+# Copyright (c) 2024 Analog Devices, Inc.\n+# SPDX-License-Identifier: Apache-2.0\n+\n+# zephyr-keep-sorted-start\n+add_subdirectory_ifdef(CONFIG_DPS310 dps310)\n+add_subdirectory_ifdef(CONFIG_XMC4XXX_TEMP xmc4xxx_temp)\n+# zephyr-keep-sorted-stop\n+# Copyright (c) 2024 Analog Devices, Inc.\n+# SPDX-License-Identifier: Apache-2.0\n+\n+# zephyr-keep-sorted-start\n+source \"drivers/sensor/infineon/dps310/Kconfig\"\n+source \"drivers/sensor/infineon/xmc4xxx_temp/Kconfig\"\n+# zephyr-keep-sorted-stop\nThe issue was with: drivers: sensor: infineon: Move to vendor subdirectory\n\nOrganizes sensor drivers by vendor to distribute maintainership\nresponsibilities."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: honeywell: Move to vendor subdirectory\n\nOrganizes sensor drivers by vendor to distribute maintainership\nresponsibilities. Please fix this issue.",
  "input": "Faulty tokenized code:\n# zephyr-keep-sorted-start\nadd_subdirectory(adi)\nadd_subdirectory(ams)\nadd_subdirectory(aosong)\nadd_subdirectory(bosch)\nadd_subdirectory(ite)\nadd_subdirectory(maxim)\nadd_subdirectory(microchip)\nadd_subdirectory(nordic)\nadd_subdirectory(nuvoton)\nadd_subdirectory_ifdef(CONFIG_ESP32_TEMP esp32_temp)\nadd_subdirectory_ifdef(CONFIG_EXPLORIR_M explorir_m)\nadd_subdirectory_ifdef(CONFIG_F75303 f75303)\nadd_subdirectory_ifdef(CONFIG_FCX_MLDX5 fcx_mldx5)\nadd_subdirectory_ifdef(CONFIG_GROW_R502A grow_r502a)\nadd_subdirectory_ifdef(CONFIG_HMC5883L hmc5883l)\nadd_subdirectory_ifdef(CONFIG_HP206C hp206c)\nadd_subdirectory_ifdef(CONFIG_HS300X hs300x)\nadd_subdirectory_ifdef(CONFIG_ICM42605 tdk/icm42605)\nadd_subdirectory_ifdef(CONFIG_ICM42670 tdk/icm42670)\nadd_subdirectory_ifdef(CONFIG_ICM42688 tdk/icm42688)\nadd_subdirectory_ifdef(CONFIG_LM75 lm75)\nadd_subdirectory_ifdef(CONFIG_LM77 lm77)\nadd_subdirectory_ifdef(CONFIG_LTR_F216A ltrf216a)\nadd_subdirectory_ifdef(CONFIG_MC3419 mc3419)\nadd_subdirectory_ifdef(CONFIG_MHZ19B mhz19b)\nadd_subdirectory_ifdef(CONFIG_MPR mpr)\nadd_subdirectory_ifdef(CONFIG_MPU6050 tdk/mpu6050)\nadd_subdirectory_ifdef(CONFIG_MPU9250 tdk/mpu9250)\nadd_subdirectory_ifdef(CONFIG_MS5607 ms5607)\nadd_subdirectory_ifdef(CONFIG_MS5837 ms5837)\nadd_subdirectory_ifdef(CONFIG_NTC_THERMISTOR ntc_thermistor)\nadd_subdirectory_ifdef(CONFIG_PMS7003 pms7003)\nadd_subdirectory_ifdef(CONFIG_QDEC_SAM qdec_sam)\nadd_subdirectory_ifdef(CONFIG_RPI_PICO_TEMP rpi_pico_temp)\nadd_subdirectory_ifdef(CONFIG_S11059 s11059)\nadd_subdirectory_ifdef(CONFIG_SBS_GAUGE sbs_gauge)\nadd_subdirectory_ifdef(CONFIG_SM351LT sm351lt)\nadd_subdirectory_ifdef(CONFIG_SX9500 sx9500)\nadd_subdirectory_ifdef(CONFIG_TH02 th02)\nadd_subdirectory_ifdef(CONFIG_VOLTAGE_DIVIDER voltage_divider)\nadd_subdirectory_ifdef(CONFIG_XMC4XXX_TEMP xmc4xxx_temp)\nadd_subdirectory_ifdef(CONFIG_TACH_ENE_KB1200 ene_tach_kb1200)\n# zephyr-keep-sorted-start\nsource \"drivers/sensor/adi/Kconfig\"\nsource \"drivers/sensor/ams/Kconfig\"\nsource \"drivers/sensor/aosong/Kconfig\"\nsource \"drivers/sensor/bosch/Kconfig\"\nsource \"drivers/sensor/ite/Kconfig\"\nsource \"drivers/sensor/maxim/Kconfig\"\nsource \"drivers/sensor/microchip/Kconfig\"\nsource \"drivers/sensor/nordic/Kconfig\"\nsource \"drivers/sensor/nuvoton/Kconfig\"\nsource \"drivers/sensor/esp32_temp/Kconfig\"\nsource \"drivers/sensor/explorir_m/Kconfig\"\nsource \"drivers/sensor/f75303/Kconfig\"\nsource \"drivers/sensor/fcx_mldx5/Kconfig\"\nsource \"drivers/sensor/grow_r502a/Kconfig\"\nsource \"drivers/sensor/hmc5883l/Kconfig\"\nsource \"drivers/sensor/hp206c/Kconfig\"\nsource \"drivers/sensor/hs300x/Kconfig\"\nsource \"drivers/sensor/tdk/icm42605/Kconfig\"\nsource \"drivers/sensor/tdk/icm42670/Kconfig\"\nsource \"drivers/sensor/tdk/icm42688/Kconfig\"\nsource \"drivers/sensor/lm75/Kconfig\"\nsource \"drivers/sensor/lm77/Kconfig\"\nsource \"drivers/sensor/ltrf216a/Kconfig\"\nsource \"drivers/sensor/mc3419/Kconfig\"\nsource \"drivers/sensor/mhz19b/Kconfig\"\nsource \"drivers/sensor/mpr/Kconfig\"\nsource \"drivers/sensor/tdk/mpu6050/Kconfig\"\nsource \"drivers/sensor/tdk/mpu9250/Kconfig\"\nsource \"drivers/sensor/ms5607/Kconfig\"\nsource \"drivers/sensor/ms5837/Kconfig\"\nsource \"drivers/sensor/ntc_thermistor/Kconfig\"\nsource \"drivers/sensor/pms7003/Kconfig\"\nsource \"drivers/sensor/qdec_sam/Kconfig\"\nsource \"drivers/sensor/rpi_pico_temp/Kconfig\"\nsource \"drivers/sensor/s11059/Kconfig\"\nsource \"drivers/sensor/sbs_gauge/Kconfig\"\nsource \"drivers/sensor/sm351lt/Kconfig\"\nsource \"drivers/sensor/sx9500/Kconfig\"\nsource \"drivers/sensor/th02/Kconfig\"\nsource \"drivers/sensor/voltage_divider/Kconfig\"\nsource \"drivers/sensor/xmc4xxx_temp/Kconfig\"\nsource \"drivers/sensor/ene_tach_kb1200/Kconfig\"\nnew file mode 100644\nnew file mode 100644\nsimilarity index 100%\nrename from drivers/sensor/hmc5883l/CMakeLists.txt\nrename to drivers/sensor/honeywell/hmc5883l/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/hmc5883l/Kconfig\nrename to drivers/sensor/honeywell/hmc5883l/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/hmc5883l/hmc5883l.c\nrename to drivers/sensor/honeywell/hmc5883l/hmc5883l.c\nsimilarity index 100%\nrename from drivers/sensor/hmc5883l/hmc5883l.h\nrename to drivers/sensor/honeywell/hmc5883l/hmc5883l.h\nsimilarity index 100%\nrename from drivers/sensor/hmc5883l/hmc5883l_trigger.c\nrename to drivers/sensor/honeywell/hmc5883l/hmc5883l_trigger.c\nsimilarity index 100%\nrename from drivers/sensor/mpr/CMakeLists.txt\nrename to drivers/sensor/honeywell/mpr/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/mpr/Kconfig\nrename to drivers/sensor/honeywell/mpr/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/mpr/mpr.c\nrename to drivers/sensor/honeywell/mpr/mpr.c\nsimilarity index 100%\nrename from drivers/sensor/mpr/mpr.h\nrename to drivers/sensor/honeywell/mpr/mpr.h\nsimilarity index 100%\nrename from drivers/sensor/mpr/mpr_configuration.h\nrename to drivers/sensor/honeywell/mpr/mpr_configuration.h\nsimilarity index 100%\nrename from drivers/sensor/sm351lt/CMakeLists.txt\nrename to drivers/sensor/honeywell/sm351lt/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/sm351lt/Kconfig\nrename to drivers/sensor/honeywell/sm351lt/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/sm351lt/sm351lt.c\nrename to drivers/sensor/honeywell/sm351lt/sm351lt.c\nsimilarity index 100%\nrename from drivers/sensor/sm351lt/sm351lt.h\nrename to drivers/sensor/honeywell/sm351lt/sm351lt.h",
  "result": "I corrected the issue in the code by changing the following tokens:\n+add_subdirectory(honeywell)\n-add_subdirectory_ifdef(CONFIG_HMC5883L hmc5883l)\n-add_subdirectory_ifdef(CONFIG_MPR mpr)\n-add_subdirectory_ifdef(CONFIG_SM351LT sm351lt)\n+source \"drivers/sensor/honeywell/Kconfig\"\n-source \"drivers/sensor/hmc5883l/Kconfig\"\n-source \"drivers/sensor/mpr/Kconfig\"\n-source \"drivers/sensor/sm351lt/Kconfig\"\n+# Copyright (c) 2024 Analog Devices, Inc.\n+# SPDX-License-Identifier: Apache-2.0\n+\n+# zephyr-keep-sorted-start\n+add_subdirectory_ifdef(CONFIG_HMC5883L hmc5883l)\n+add_subdirectory_ifdef(CONFIG_MPR mpr)\n+add_subdirectory_ifdef(CONFIG_SM351LT sm351lt)\n+# zephyr-keep-sorted-stop\n+# Copyright (c) 2024 Analog Devices, Inc.\n+# SPDX-License-Identifier: Apache-2.0\n+\n+# zephyr-keep-sorted-start\n+source \"drivers/sensor/honeywell/hmc5883l/Kconfig\"\n+source \"drivers/sensor/honeywell/mpr/Kconfig\"\n+source \"drivers/sensor/honeywell/sm351lt/Kconfig\"\n+# zephyr-keep-sorted-stop\nThe issue was with: drivers: sensor: honeywell: Move to vendor subdirectory\n\nOrganizes sensor drivers by vendor to distribute maintainership\nresponsibilities."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: aosong: Move to vendor subdirectory\n\nOrganizes sensor drivers by vendor to distribute maintainership\nresponsibilities. Please fix this issue.",
  "input": "Faulty tokenized code:\n# SPDX-License-Identifier: Apache-2.0\n\n# zephyr-keep-sorted-start\nadd_subdirectory(adi)\nadd_subdirectory(ams)\nadd_subdirectory(bosch)\nadd_subdirectory(ite)\nadd_subdirectory(maxim)\nadd_subdirectory(microchip)\nadd_subdirectory(nordic)\nadd_subdirectory(vishay)\nadd_subdirectory(wsen)\n# zephyr-keep-sorted-stop\n\nadd_subdirectory_ifdef(CONFIG_A01NYUB a01nyub)\nadd_subdirectory_ifdef(CONFIG_AGS10 ags10)\nadd_subdirectory_ifdef(CONFIG_AK8975 ak8975)\nadd_subdirectory_ifdef(CONFIG_AKM09918C akm09918c)\nadd_subdirectory_ifdef(CONFIG_AMD_SB_TSI amd_sb_tsi)\nadd_subdirectory_ifdef(CONFIG_AMG88XX amg88xx)\nadd_subdirectory_ifdef(CONFIG_APDS9960 apds9960)\nadd_subdirectory_ifdef(CONFIG_CURRENT_AMP current_amp)\nadd_subdirectory_ifdef(CONFIG_DHT dht)\nadd_subdirectory_ifdef(CONFIG_DHT20 dht20)\nadd_subdirectory_ifdef(CONFIG_DPS310 dps310)\nadd_subdirectory_ifdef(CONFIG_ENS160 ens160)\nadd_subdirectory_ifdef(CONFIG_ESP32_TEMP esp32_temp)\nadd_subdirectory_ifdef(CONFIG_EXPLORIR_M explorir_m)\nadd_subdirectory_ifdef(CONFIG_F75303 f75303)\ncomment \"Device Drivers\"\n\n# zephyr-keep-sorted-start\nsource \"drivers/sensor/adi/Kconfig\"\nsource \"drivers/sensor/ams/Kconfig\"\nsource \"drivers/sensor/bosch/Kconfig\"\nsource \"drivers/sensor/ite/Kconfig\"\nsource \"drivers/sensor/maxim/Kconfig\"\nsource \"drivers/sensor/microchip/Kconfig\"\nsource \"drivers/sensor/nordic/Kconfig\"\nsource \"drivers/sensor/vishay/Kconfig\"\nsource \"drivers/sensor/wsen/Kconfig\"\n# zephyr-keep-sorted-stop\n\nsource \"drivers/sensor/a01nyub/Kconfig\"\nsource \"drivers/sensor/ags10/Kconfig\"\nsource \"drivers/sensor/ak8975/Kconfig\"\nsource \"drivers/sensor/akm09918c/Kconfig\"\nsource \"drivers/sensor/amd_sb_tsi/Kconfig\"\nsource \"drivers/sensor/amg88xx/Kconfig\"\nsource \"drivers/sensor/apds9960/Kconfig\"\nsource \"drivers/sensor/current_amp/Kconfig\"\nsource \"drivers/sensor/dht/Kconfig\"\nsource \"drivers/sensor/dht20/Kconfig\"\nsource \"drivers/sensor/dps310/Kconfig\"\nsource \"drivers/sensor/ens160/Kconfig\"\nsource \"drivers/sensor/esp32_temp/Kconfig\"\nsource \"drivers/sensor/explorir_m/Kconfig\"\nsource \"drivers/sensor/f75303/Kconfig\"\nnew file mode 100644\nnew file mode 100644\nsimilarity index 100%\nrename from drivers/sensor/ags10/CMakeLists.txt\nrename to drivers/sensor/aosong/ags10/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/ags10/Kconfig\nrename to drivers/sensor/aosong/ags10/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/ags10/ags10.c\nrename to drivers/sensor/aosong/ags10/ags10.c\nsimilarity index 100%\nrename from drivers/sensor/ags10/ags10.h\nrename to drivers/sensor/aosong/ags10/ags10.h\nsimilarity index 100%\nrename from drivers/sensor/dht/CMakeLists.txt\nrename to drivers/sensor/aosong/dht/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/dht/Kconfig\nrename to drivers/sensor/aosong/dht/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/dht/dht.c\nrename to drivers/sensor/aosong/dht/dht.c\nsimilarity index 100%\nrename from drivers/sensor/dht/dht.h\nrename to drivers/sensor/aosong/dht/dht.h\nsimilarity index 100%\nrename from drivers/sensor/dht20/CMakeLists.txt\nrename to drivers/sensor/aosong/dht20/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/dht20/Kconfig\nrename to drivers/sensor/aosong/dht20/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/dht20/dht20.c\nrename to drivers/sensor/aosong/dht20/dht20.c",
  "result": "I corrected the issue in the code by changing the following tokens:\n+add_subdirectory(aosong)\n-add_subdirectory_ifdef(CONFIG_AGS10 ags10)\n-add_subdirectory_ifdef(CONFIG_DHT dht)\n-add_subdirectory_ifdef(CONFIG_DHT20 dht20)\n+source \"drivers/sensor/aosong/Kconfig\"\n-source \"drivers/sensor/ags10/Kconfig\"\n-source \"drivers/sensor/dht/Kconfig\"\n-source \"drivers/sensor/dht20/Kconfig\"\n+# Copyright (c) 2024 Analog Devices, Inc.\n+# SPDX-License-Identifier: Apache-2.0\n+\n+# zephyr-keep-sorted-start\n+add_subdirectory_ifdef(CONFIG_AGS10 ags10)\n+add_subdirectory_ifdef(CONFIG_DHT dht)\n+add_subdirectory_ifdef(CONFIG_DHT20 dht20)\n+# zephyr-keep-sorted-stop\n+# Copyright (c) 2024 Analog Devices, Inc.\n+# SPDX-License-Identifier: Apache-2.0\n+\n+# zephyr-keep-sorted-start\n+source \"drivers/sensor/aosong/ags10/Kconfig\"\n+source \"drivers/sensor/aosong/dht/Kconfig\"\n+source \"drivers/sensor/aosong/dht20/Kconfig\"\n+# zephyr-keep-sorted-stop\nThe issue was with: drivers: sensor: aosong: Move to vendor subdirectory\n\nOrganizes sensor drivers by vendor to distribute maintainership\nresponsibilities."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: vishay: Move to vendor subdirectory\n\nOrganizes sensor drivers by vendor to distribute maintainership\nresponsibilities. Please fix this issue.",
  "input": "Faulty tokenized code:\nadd_subdirectory(seeed)\nadd_subdirectory(sensirion)\nadd_subdirectory(silabs)\nadd_subdirectory(st)\nadd_subdirectory(ti)\nadd_subdirectory(wsen)\n# zephyr-keep-sorted-stop\n\nadd_subdirectory_ifdef(CONFIG_A01NYUB a01nyub)\nadd_subdirectory_ifdef(CONFIG_AGS10 ags10)\nadd_subdirectory_ifdef(CONFIG_S11059 s11059)\nadd_subdirectory_ifdef(CONFIG_SBS_GAUGE sbs_gauge)\nadd_subdirectory_ifdef(CONFIG_SM351LT sm351lt)\nadd_subdirectory_ifdef(CONFIG_SX9500 sx9500)\nadd_subdirectory_ifdef(CONFIG_TH02 th02)\nadd_subdirectory_ifdef(CONFIG_VCNL4040 vcnl4040)\nadd_subdirectory_ifdef(CONFIG_VCNL36825T vcnl36825t)\nadd_subdirectory_ifdef(CONFIG_VEML7700 veml7700)\nadd_subdirectory_ifdef(CONFIG_VOLTAGE_DIVIDER voltage_divider)\nadd_subdirectory_ifdef(CONFIG_XMC4XXX_TEMP xmc4xxx_temp)\nadd_subdirectory_ifdef(CONFIG_TACH_ENE_KB1200 ene_tach_kb1200)\n\nzephyr_syscall_header(${ZEPHYR_BASE}/include/zephyr/drivers/sensor.h)\nsource \"drivers/sensor/seeed/Kconfig\"\nsource \"drivers/sensor/sensirion/Kconfig\"\nsource \"drivers/sensor/silabs/Kconfig\"\nsource \"drivers/sensor/st/Kconfig\"\nsource \"drivers/sensor/ti/Kconfig\"\nsource \"drivers/sensor/wsen/Kconfig\"\n# zephyr-keep-sorted-stop\n\nsource \"drivers/sensor/a01nyub/Kconfig\"\nsource \"drivers/sensor/ags10/Kconfig\"\nsource \"drivers/sensor/s11059/Kconfig\"\nsource \"drivers/sensor/sbs_gauge/Kconfig\"\nsource \"drivers/sensor/sm351lt/Kconfig\"\nsource \"drivers/sensor/sx9500/Kconfig\"\nsource \"drivers/sensor/th02/Kconfig\"\nsource \"drivers/sensor/vcnl4040/Kconfig\"\nsource \"drivers/sensor/vcnl36825t/Kconfig\"\nsource \"drivers/sensor/veml7700/Kconfig\"\nsource \"drivers/sensor/voltage_divider/Kconfig\"\nsource \"drivers/sensor/xmc4xxx_temp/Kconfig\"\nsource \"drivers/sensor/ene_tach_kb1200/Kconfig\"\n\nendif # SENSOR\nnew file mode 100644\nnew file mode 100644\nsimilarity index 100%\nrename from drivers/sensor/vcnl36825t/CMakeLists.txt\nrename to drivers/sensor/vishay/vcnl36825t/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/vcnl36825t/Kconfig\nrename to drivers/sensor/vishay/vcnl36825t/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/vcnl36825t/vcnl36825t.c\nrename to drivers/sensor/vishay/vcnl36825t/vcnl36825t.c\nsimilarity index 100%\nrename from drivers/sensor/vcnl36825t/vcnl36825t.h\nrename to drivers/sensor/vishay/vcnl36825t/vcnl36825t.h\nsimilarity index 100%\nrename from drivers/sensor/vcnl4040/CMakeLists.txt\nrename to drivers/sensor/vishay/vcnl4040/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/vcnl4040/Kconfig\nrename to drivers/sensor/vishay/vcnl4040/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/vcnl4040/vcnl4040.c\nrename to drivers/sensor/vishay/vcnl4040/vcnl4040.c\nsimilarity index 100%\nrename from drivers/sensor/vcnl4040/vcnl4040.h\nrename to drivers/sensor/vishay/vcnl4040/vcnl4040.h\nsimilarity index 100%\nrename from drivers/sensor/vcnl4040/vcnl4040_trigger.c\nrename to drivers/sensor/vishay/vcnl4040/vcnl4040_trigger.c\nsimilarity index 100%\nrename from drivers/sensor/veml7700/CMakeLists.txt\nrename to drivers/sensor/vishay/veml7700/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/veml7700/Kconfig\nrename to drivers/sensor/vishay/veml7700/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/veml7700/veml7700.c\nrename to drivers/sensor/vishay/veml7700/veml7700.c",
  "result": "I corrected the issue in the code by changing the following tokens:\n+add_subdirectory(vishay)\n-add_subdirectory_ifdef(CONFIG_VCNL4040 vcnl4040)\n-add_subdirectory_ifdef(CONFIG_VCNL36825T vcnl36825t)\n-add_subdirectory_ifdef(CONFIG_VEML7700 veml7700)\n+source \"drivers/sensor/vishay/Kconfig\"\n-source \"drivers/sensor/vcnl4040/Kconfig\"\n-source \"drivers/sensor/vcnl36825t/Kconfig\"\n-source \"drivers/sensor/veml7700/Kconfig\"\n+# Copyright (c) 2024 Analog Devices, Inc.\n+# SPDX-License-Identifier: Apache-2.0\n+\n+# zephyr-keep-sorted-start\n+add_subdirectory_ifdef(CONFIG_VCNL36825T vcnl36825t)\n+add_subdirectory_ifdef(CONFIG_VCNL4040 vcnl4040)\n+add_subdirectory_ifdef(CONFIG_VEML7700 veml7700)\n+# zephyr-keep-sorted-stop\n+# Copyright (c) 2024 Analog Devices, Inc.\n+# SPDX-License-Identifier: Apache-2.0\n+\n+# zephyr-keep-sorted-start\n+source \"drivers/sensor/vishay/vcnl36825t/Kconfig\"\n+source \"drivers/sensor/vishay/vcnl4040/Kconfig\"\n+source \"drivers/sensor/vishay/veml7700/Kconfig\"\n+# zephyr-keep-sorted-stop\nThe issue was with: drivers: sensor: vishay: Move to vendor subdirectory\n\nOrganizes sensor drivers by vendor to distribute maintainership\nresponsibilities."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: seeed: Move to vendor subdirectory\n\nOrganizes sensor drivers by vendor to distribute maintainership\nresponsibilities. Please fix this issue.",
  "input": "Faulty tokenized code:\nadd_subdirectory(microchip)\nadd_subdirectory(nordic)\nadd_subdirectory(nuvoton)\nadd_subdirectory(nxp)\nadd_subdirectory(rohm)\nadd_subdirectory(sensirion)\nadd_subdirectory(silabs)\nadd_subdirectory(st)\nadd_subdirectory(ti)\nadd_subdirectory(wsen)\nadd_subdirectory_ifdef(CONFIG_ENS160 ens160)\nadd_subdirectory_ifdef(CONFIG_ESP32_TEMP esp32_temp)\nadd_subdirectory_ifdef(CONFIG_EXPLORIR_M explorir_m)\nadd_subdirectory_ifdef(CONFIG_F75303 f75303)\nadd_subdirectory_ifdef(CONFIG_FCX_MLDX5 fcx_mldx5)\nadd_subdirectory_ifdef(CONFIG_GROVE_SENSORS grove)\nadd_subdirectory_ifdef(CONFIG_GROW_R502A grow_r502a)\nadd_subdirectory_ifdef(CONFIG_HM330X hm330x)\nadd_subdirectory_ifdef(CONFIG_HMC5883L hmc5883l)\nadd_subdirectory_ifdef(CONFIG_HP206C hp206c)\nadd_subdirectory_ifdef(CONFIG_HS300X hs300x)\nadd_subdirectory_ifdef(CONFIG_ICM42605 tdk/icm42605)\nadd_subdirectory_ifdef(CONFIG_ICM42670 tdk/icm42670)\nsource \"drivers/sensor/microchip/Kconfig\"\nsource \"drivers/sensor/nordic/Kconfig\"\nsource \"drivers/sensor/nuvoton/Kconfig\"\nsource \"drivers/sensor/nxp/Kconfig\"\nsource \"drivers/sensor/rohm/Kconfig\"\nsource \"drivers/sensor/sensirion/Kconfig\"\nsource \"drivers/sensor/silabs/Kconfig\"\nsource \"drivers/sensor/st/Kconfig\"\nsource \"drivers/sensor/ti/Kconfig\"\nsource \"drivers/sensor/wsen/Kconfig\"\nsource \"drivers/sensor/ens160/Kconfig\"\nsource \"drivers/sensor/esp32_temp/Kconfig\"\nsource \"drivers/sensor/explorir_m/Kconfig\"\nsource \"drivers/sensor/f75303/Kconfig\"\nsource \"drivers/sensor/fcx_mldx5/Kconfig\"\nsource \"drivers/sensor/grove/Kconfig\"\nsource \"drivers/sensor/grow_r502a/Kconfig\"\nsource \"drivers/sensor/hm330x/Kconfig\"\nsource \"drivers/sensor/hmc5883l/Kconfig\"\nsource \"drivers/sensor/hp206c/Kconfig\"\nsource \"drivers/sensor/hs300x/Kconfig\"\nsource \"drivers/sensor/tdk/icm42605/Kconfig\"\nsource \"drivers/sensor/tdk/icm42670/Kconfig\"\nnew file mode 100644\nnew file mode 100644\nsimilarity index 100%\nrename from drivers/sensor/grove/CMakeLists.txt\nrename to drivers/sensor/seeed/grove/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/grove/Kconfig\nrename to drivers/sensor/seeed/grove/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/grove/light_sensor.c\nrename to drivers/sensor/seeed/grove/light_sensor.c\nsimilarity index 100%\nrename from drivers/sensor/grove/temperature_sensor.c\nrename to drivers/sensor/seeed/grove/temperature_sensor.c\nsimilarity index 100%\nrename from drivers/sensor/hm330x/CMakeLists.txt\nrename to drivers/sensor/seeed/hm330x/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/hm330x/Kconfig\nrename to drivers/sensor/seeed/hm330x/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/hm330x/hm330x.c\nrename to drivers/sensor/seeed/hm330x/hm330x.c",
  "result": "I corrected the issue in the code by changing the following tokens:\n+add_subdirectory(seeed)\n-add_subdirectory_ifdef(CONFIG_GROVE_SENSORS grove)\n-add_subdirectory_ifdef(CONFIG_HM330X hm330x)\n+source \"drivers/sensor/seeed/Kconfig\"\n-source \"drivers/sensor/grove/Kconfig\"\n-source \"drivers/sensor/hm330x/Kconfig\"\n+# Copyright (c) 2024 Analog Devices, Inc.\n+# SPDX-License-Identifier: Apache-2.0\n+\n+# zephyr-keep-sorted-start\n+add_subdirectory_ifdef(CONFIG_GROVE_SENSORS grove)\n+add_subdirectory_ifdef(CONFIG_HM330X hm330x)\n+# zephyr-keep-sorted-stop\n+# Copyright (c) 2024 Analog Devices, Inc.\n+# SPDX-License-Identifier: Apache-2.0\n+\n+# zephyr-keep-sorted-start\n+source \"drivers/sensor/seeed/grove/Kconfig\"\n+source \"drivers/sensor/seeed/hm330x/Kconfig\"\n+# zephyr-keep-sorted-stop\nThe issue was with: drivers: sensor: seeed: Move to vendor subdirectory\n\nOrganizes sensor drivers by vendor to distribute maintainership\nresponsibilities."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: rohm: Move to vendor subdirectory\n\nOrganizes sensor drivers by vendor to distribute maintainership\nresponsibilities. Please fix this issue.",
  "input": "Faulty tokenized code:\nadd_subdirectory(maxim)\nadd_subdirectory(microchip)\nadd_subdirectory(nordic)\nadd_subdirectory(nuvoton)\nadd_subdirectory(nxp)\nadd_subdirectory(sensirion)\nadd_subdirectory(silabs)\nadd_subdirectory(st)\nadd_subdirectory(ti)\nadd_subdirectory(wsen)\nadd_subdirectory_ifdef(CONFIG_AK8975 ak8975)\nadd_subdirectory_ifdef(CONFIG_AKM09918C akm09918c)\nadd_subdirectory_ifdef(CONFIG_AMD_SB_TSI amd_sb_tsi)\nadd_subdirectory_ifdef(CONFIG_AMG88XX amg88xx)\nadd_subdirectory_ifdef(CONFIG_APDS9960 apds9960)\nadd_subdirectory_ifdef(CONFIG_BD8LB600FS_DIAGNOSTICS bd8lb600fs)\nadd_subdirectory_ifdef(CONFIG_BH1750 bh1750)\nadd_subdirectory_ifdef(CONFIG_CURRENT_AMP current_amp)\nadd_subdirectory_ifdef(CONFIG_DHT dht)\nadd_subdirectory_ifdef(CONFIG_DHT20 dht20)\nadd_subdirectory_ifdef(CONFIG_DPS310 dps310)\nadd_subdirectory_ifdef(CONFIG_ENS160 ens160)\nsource \"drivers/sensor/maxim/Kconfig\"\nsource \"drivers/sensor/microchip/Kconfig\"\nsource \"drivers/sensor/nordic/Kconfig\"\nsource \"drivers/sensor/nuvoton/Kconfig\"\nsource \"drivers/sensor/nxp/Kconfig\"\nsource \"drivers/sensor/sensirion/Kconfig\"\nsource \"drivers/sensor/silabs/Kconfig\"\nsource \"drivers/sensor/st/Kconfig\"\nsource \"drivers/sensor/ti/Kconfig\"\nsource \"drivers/sensor/wsen/Kconfig\"\nsource \"drivers/sensor/ak8975/Kconfig\"\nsource \"drivers/sensor/akm09918c/Kconfig\"\nsource \"drivers/sensor/amd_sb_tsi/Kconfig\"\nsource \"drivers/sensor/amg88xx/Kconfig\"\nsource \"drivers/sensor/apds9960/Kconfig\"\nsource \"drivers/sensor/bd8lb600fs/Kconfig\"\nsource \"drivers/sensor/bh1750/Kconfig\"\nsource \"drivers/sensor/current_amp/Kconfig\"\nsource \"drivers/sensor/dht/Kconfig\"\nsource \"drivers/sensor/dht20/Kconfig\"\nsource \"drivers/sensor/dps310/Kconfig\"\nsource \"drivers/sensor/ens160/Kconfig\"\nnew file mode 100644\nnew file mode 100644\nsimilarity index 100%\nrename from drivers/sensor/bd8lb600fs/CMakeLists.txt\nrename to drivers/sensor/rohm/bd8lb600fs/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/bd8lb600fs/Kconfig\nrename to drivers/sensor/rohm/bd8lb600fs/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/bd8lb600fs/bd8lb600fs_diagnostics.c\nrename to drivers/sensor/rohm/bd8lb600fs/bd8lb600fs_diagnostics.c\nsimilarity index 100%\nrename from drivers/sensor/bd8lb600fs/bd8lb600fs_diagnostics.h\nrename to drivers/sensor/rohm/bd8lb600fs/bd8lb600fs_diagnostics.h\nsimilarity index 100%\nrename from drivers/sensor/bh1750/CMakeLists.txt\nrename to drivers/sensor/rohm/bh1750/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/bh1750/Kconfig\nrename to drivers/sensor/rohm/bh1750/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/bh1750/bh1750.c\nrename to drivers/sensor/rohm/bh1750/bh1750.c",
  "result": "I corrected the issue in the code by changing the following tokens:\n+add_subdirectory(rohm)\n-add_subdirectory_ifdef(CONFIG_BD8LB600FS_DIAGNOSTICS bd8lb600fs)\n-add_subdirectory_ifdef(CONFIG_BH1750 bh1750)\n+source \"drivers/sensor/rohm/Kconfig\"\n-source \"drivers/sensor/bd8lb600fs/Kconfig\"\n-source \"drivers/sensor/bh1750/Kconfig\"\n+# Copyright (c) 2024 Analog Devices, Inc.\n+# SPDX-License-Identifier: Apache-2.0\n+\n+# zephyr-keep-sorted-start\n+add_subdirectory_ifdef(CONFIG_BD8LB600FS_DIAGNOSTICS bd8lb600fs)\n+add_subdirectory_ifdef(CONFIG_BH1750 bh1750)\n+# zephyr-keep-sorted-stop\n+# Copyright (c) 2024 Analog Devices, Inc.\n+# SPDX-License-Identifier: Apache-2.0\n+\n+# zephyr-keep-sorted-start\n+source \"drivers/sensor/rohm/bd8lb600fs/Kconfig\"\n+source \"drivers/sensor/rohm/bh1750/Kconfig\"\n+# zephyr-keep-sorted-stop\nThe issue was with: drivers: sensor: rohm: Move to vendor subdirectory\n\nOrganizes sensor drivers by vendor to distribute maintainership\nresponsibilities."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: nuvoton: Move to vendor subdirectory\n\nOrganizes sensor drivers by vendor to distribute maintainership\nresponsibilities. Please fix this issue.",
  "input": "Faulty tokenized code:\nadd_subdirectory(bosch)\nadd_subdirectory(ite)\nadd_subdirectory(maxim)\nadd_subdirectory(microchip)\nadd_subdirectory(nordic)\nadd_subdirectory(nxp)\nadd_subdirectory(sensirion)\nadd_subdirectory(silabs)\nadd_subdirectory(st)\nadd_subdirectory(ti)\nadd_subdirectory(wsen)\n# zephyr-keep-sorted-stop\n\nadd_subdirectory_ifdef(CONFIG_A01NYUB a01nyub)\nadd_subdirectory_ifdef(CONFIG_ADC_CMP_NPCX nuvoton_adc_cmp_npcx)\nadd_subdirectory_ifdef(CONFIG_AGS10 ags10)\nadd_subdirectory_ifdef(CONFIG_AK8975 ak8975)\nadd_subdirectory_ifdef(CONFIG_AKM09918C akm09918c)\nadd_subdirectory_ifdef(CONFIG_AMD_SB_TSI amd_sb_tsi)\nadd_subdirectory_ifdef(CONFIG_AMG88XX amg88xx)\nadd_subdirectory_ifdef(CONFIG_RPI_PICO_TEMP rpi_pico_temp)\nadd_subdirectory_ifdef(CONFIG_S11059 s11059)\nadd_subdirectory_ifdef(CONFIG_SBS_GAUGE sbs_gauge)\nadd_subdirectory_ifdef(CONFIG_SM351LT sm351lt)\nadd_subdirectory_ifdef(CONFIG_SX9500 sx9500)\nadd_subdirectory_ifdef(CONFIG_TACH_NPCX nuvoton_tach_npcx)\nadd_subdirectory_ifdef(CONFIG_TH02 th02)\nadd_subdirectory_ifdef(CONFIG_VCNL4040 vcnl4040)\nadd_subdirectory_ifdef(CONFIG_VCNL36825T vcnl36825t)\nadd_subdirectory_ifdef(CONFIG_VEML7700 veml7700)\nadd_subdirectory_ifdef(CONFIG_VOLTAGE_DIVIDER voltage_divider)\nsource \"drivers/sensor/bosch/Kconfig\"\nsource \"drivers/sensor/ite/Kconfig\"\nsource \"drivers/sensor/maxim/Kconfig\"\nsource \"drivers/sensor/microchip/Kconfig\"\nsource \"drivers/sensor/nordic/Kconfig\"\nsource \"drivers/sensor/nxp/Kconfig\"\nsource \"drivers/sensor/sensirion/Kconfig\"\nsource \"drivers/sensor/silabs/Kconfig\"\nsource \"drivers/sensor/st/Kconfig\"\nsource \"drivers/sensor/ti/Kconfig\"\nsource \"drivers/sensor/tdk/mpu6050/Kconfig\"\nsource \"drivers/sensor/tdk/mpu9250/Kconfig\"\nsource \"drivers/sensor/ms5607/Kconfig\"\nsource \"drivers/sensor/ms5837/Kconfig\"\nsource \"drivers/sensor/ntc_thermistor/Kconfig\"\nsource \"drivers/sensor/nuvoton_adc_cmp_npcx/Kconfig\"\nsource \"drivers/sensor/nuvoton_tach_npcx/Kconfig\"\nsource \"drivers/sensor/pcnt_esp32/Kconfig\"\nsource \"drivers/sensor/pms7003/Kconfig\"\nsource \"drivers/sensor/qdec_sam/Kconfig\"\nsource \"drivers/sensor/rpi_pico_temp/Kconfig\"\nsource \"drivers/sensor/s11059/Kconfig\"\nnew file mode 100644\nnew file mode 100644\nsimilarity index 100%\nrename from drivers/sensor/nuvoton_adc_cmp_npcx/CMakeLists.txt\nrename to drivers/sensor/nuvoton/nuvoton_adc_cmp_npcx/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/nuvoton_adc_cmp_npcx/Kconfig\nrename to drivers/sensor/nuvoton/nuvoton_adc_cmp_npcx/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/nuvoton_adc_cmp_npcx/adc_cmp_npcx.c\nrename to drivers/sensor/nuvoton/nuvoton_adc_cmp_npcx/adc_cmp_npcx.c\nsimilarity index 100%\nrename from drivers/sensor/nuvoton_tach_npcx/CMakeLists.txt\nrename to drivers/sensor/nuvoton/nuvoton_tach_npcx/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/nuvoton_tach_npcx/Kconfig\nrename to drivers/sensor/nuvoton/nuvoton_tach_npcx/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/nuvoton_tach_npcx/tach_nuvoton_npcx.c\nrename to drivers/sensor/nuvoton/nuvoton_tach_npcx/tach_nuvoton_npcx.c",
  "result": "I corrected the issue in the code by changing the following tokens:\n+add_subdirectory(nuvoton)\n-add_subdirectory_ifdef(CONFIG_ADC_CMP_NPCX nuvoton_adc_cmp_npcx)\n-add_subdirectory_ifdef(CONFIG_TACH_NPCX nuvoton_tach_npcx)\n+source \"drivers/sensor/nuvoton/Kconfig\"\n-source \"drivers/sensor/nuvoton_adc_cmp_npcx/Kconfig\"\n-source \"drivers/sensor/nuvoton_tach_npcx/Kconfig\"\n+# Copyright (c) 2024 Analog Devices, Inc.\n+# SPDX-License-Identifier: Apache-2.0\n+\n+# zephyr-keep-sorted-start\n+add_subdirectory_ifdef(CONFIG_ADC_CMP_NPCX nuvoton_adc_cmp_npcx)\n+add_subdirectory_ifdef(CONFIG_TACH_NPCX nuvoton_tach_npcx)\n+# zephyr-keep-sorted-stop\n+# Copyright (c) 2024 Analog Devices, Inc.\n+# SPDX-License-Identifier: Apache-2.0\n+\n+# zephyr-keep-sorted-start\n+source \"drivers/sensor/nuvoton/nuvoton_adc_cmp_npcx/Kconfig\"\n+source \"drivers/sensor/nuvoton/nuvoton_tach_npcx/Kconfig\"\n+# zephyr-keep-sorted-stop\nThe issue was with: drivers: sensor: nuvoton: Move to vendor subdirectory\n\nOrganizes sensor drivers by vendor to distribute maintainership\nresponsibilities."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: nordic: Move to vendor subdirectory\n\nOrganizes sensor drivers by vendor to distribute maintainership\nresponsibilities. Please fix this issue.",
  "input": "Faulty tokenized code:\nadd_subdirectory(ams)\nadd_subdirectory(bosch)\nadd_subdirectory(ite)\nadd_subdirectory(maxim)\nadd_subdirectory(microchip)\nadd_subdirectory(nxp)\nadd_subdirectory(sensirion)\nadd_subdirectory(silabs)\nadd_subdirectory(st)\nadd_subdirectory(ti)\nadd_subdirectory_ifdef(CONFIG_MPR mpr)\nadd_subdirectory_ifdef(CONFIG_MPU6050 tdk/mpu6050)\nadd_subdirectory_ifdef(CONFIG_MPU9250 tdk/mpu9250)\nadd_subdirectory_ifdef(CONFIG_MS5607 ms5607)\nadd_subdirectory_ifdef(CONFIG_MS5837 ms5837)\nadd_subdirectory_ifdef(CONFIG_NPM1300_CHARGER npm1300_charger)\nadd_subdirectory_ifdef(CONFIG_NTC_THERMISTOR ntc_thermistor)\nadd_subdirectory_ifdef(CONFIG_PCNT_ESP32 pcnt_esp32)\nadd_subdirectory_ifdef(CONFIG_PMS7003 pms7003)\nadd_subdirectory_ifdef(CONFIG_QDEC_NRFX qdec_nrfx)\nadd_subdirectory_ifdef(CONFIG_QDEC_SAM qdec_sam)\nadd_subdirectory_ifdef(CONFIG_RPI_PICO_TEMP rpi_pico_temp)\nadd_subdirectory_ifdef(CONFIG_S11059 s11059)\nadd_subdirectory_ifdef(CONFIG_SBS_GAUGE sbs_gauge)\nadd_subdirectory_ifdef(CONFIG_SM351LT sm351lt)\nadd_subdirectory_ifdef(CONFIG_SX9500 sx9500)\nadd_subdirectory_ifdef(CONFIG_TACH_NPCX nuvoton_tach_npcx)\nadd_subdirectory_ifdef(CONFIG_TEMP_NRF5 nrf5)\nadd_subdirectory_ifdef(CONFIG_TH02 th02)\nadd_subdirectory_ifdef(CONFIG_VCNL4040 vcnl4040)\nadd_subdirectory_ifdef(CONFIG_VCNL36825T vcnl36825t)\nadd_subdirectory_ifdef(CONFIG_VEML7700 veml7700)\nadd_subdirectory_ifdef(CONFIG_VOLTAGE_DIVIDER voltage_divider)\nsource \"drivers/sensor/ams/Kconfig\"\nsource \"drivers/sensor/bosch/Kconfig\"\nsource \"drivers/sensor/ite/Kconfig\"\nsource \"drivers/sensor/maxim/Kconfig\"\nsource \"drivers/sensor/microchip/Kconfig\"\nsource \"drivers/sensor/nxp/Kconfig\"\nsource \"drivers/sensor/sensirion/Kconfig\"\nsource \"drivers/sensor/silabs/Kconfig\"\nsource \"drivers/sensor/st/Kconfig\"\nsource \"drivers/sensor/ti/Kconfig\"\nsource \"drivers/sensor/mpr/Kconfig\"\nsource \"drivers/sensor/tdk/mpu6050/Kconfig\"\nsource \"drivers/sensor/tdk/mpu9250/Kconfig\"\nsource \"drivers/sensor/ms5607/Kconfig\"\nsource \"drivers/sensor/ms5837/Kconfig\"\nsource \"drivers/sensor/npm1300_charger/Kconfig\"\nsource \"drivers/sensor/nrf5/Kconfig\"\nsource \"drivers/sensor/ntc_thermistor/Kconfig\"\nsource \"drivers/sensor/nuvoton_adc_cmp_npcx/Kconfig\"\nsource \"drivers/sensor/nuvoton_tach_npcx/Kconfig\"\nsource \"drivers/sensor/pcnt_esp32/Kconfig\"\nsource \"drivers/sensor/pms7003/Kconfig\"\nsource \"drivers/sensor/qdec_nrfx/Kconfig\"\nsource \"drivers/sensor/qdec_sam/Kconfig\"\nsource \"drivers/sensor/rpi_pico_temp/Kconfig\"\nsource \"drivers/sensor/s11059/Kconfig\"\nsource \"drivers/sensor/sbs_gauge/Kconfig\"\nsource \"drivers/sensor/sm351lt/Kconfig\"\nnew file mode 100644\nnew file mode 100644\nsimilarity index 100%\nrename from drivers/sensor/npm1300_charger/CMakeLists.txt\nrename to drivers/sensor/nordic/npm1300_charger/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/npm1300_charger/Kconfig\nrename to drivers/sensor/nordic/npm1300_charger/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/npm1300_charger/npm1300_charger.c\nrename to drivers/sensor/nordic/npm1300_charger/npm1300_charger.c\nsimilarity index 100%\nrename from drivers/sensor/nrf5/CMakeLists.txt\nrename to drivers/sensor/nordic/nrf5/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/nrf5/Kconfig\nrename to drivers/sensor/nordic/nrf5/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/nrf5/temp_nrf5.c\nrename to drivers/sensor/nordic/nrf5/temp_nrf5.c\nsimilarity index 100%\nrename from drivers/sensor/qdec_nrfx/CMakeLists.txt\nrename to drivers/sensor/nordic/qdec_nrfx/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/qdec_nrfx/Kconfig\nrename to drivers/sensor/nordic/qdec_nrfx/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/qdec_nrfx/qdec_nrfx.c\nrename to drivers/sensor/nordic/qdec_nrfx/qdec_nrfx.c",
  "result": "I corrected the issue in the code by changing the following tokens:\n+add_subdirectory(nordic)\n-add_subdirectory_ifdef(CONFIG_NPM1300_CHARGER npm1300_charger)\n-add_subdirectory_ifdef(CONFIG_QDEC_NRFX qdec_nrfx)\n-add_subdirectory_ifdef(CONFIG_TEMP_NRF5 nrf5)\n+source \"drivers/sensor/nordic/Kconfig\"\n-source \"drivers/sensor/npm1300_charger/Kconfig\"\n-source \"drivers/sensor/nrf5/Kconfig\"\n-source \"drivers/sensor/qdec_nrfx/Kconfig\"\n+# Copyright (c) 2024 Analog Devices, Inc.\n+# SPDX-License-Identifier: Apache-2.0\n+\n+# zephyr-keep-sorted-start\n+add_subdirectory_ifdef(CONFIG_NPM1300_CHARGER npm1300_charger)\n+add_subdirectory_ifdef(CONFIG_QDEC_NRFX qdec_nrfx)\n+add_subdirectory_ifdef(CONFIG_TEMP_NRF5 nrf5)\n+# zephyr-keep-sorted-stop\n+# Copyright (c) 2024 Analog Devices, Inc.\n+# SPDX-License-Identifier: Apache-2.0\n+\n+# zephyr-keep-sorted-start\n+source \"drivers/sensor/nordic/npm1300_charger/Kconfig\"\n+source \"drivers/sensor/nordic/nrf5/Kconfig\"\n+source \"drivers/sensor/nordic/qdec_nrfx/Kconfig\"\n+# zephyr-keep-sorted-stop\nThe issue was with: drivers: sensor: nordic: Move to vendor subdirectory\n\nOrganizes sensor drivers by vendor to distribute maintainership\nresponsibilities."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: ite: Move to vendor subdirectory\n\nOrganizes sensor drivers by vendor to distribute maintainership\nresponsibilities. Please fix this issue.",
  "input": "Faulty tokenized code:\n    - keith-zephyr\n    - brockus-zephyr\n    - sjg20\n  files:\n    - boards/ite/\n   - drivers/*/*/*it8xxx2*.c\n    - drivers/*/*it8xxx2*.c\n    - drivers/*/*_ite_*\n    - dts/bindings/*/*ite*\n    - dts/riscv/ite/\n    - soc/ite/\n\n# zephyr-keep-sorted-start\nadd_subdirectory(adi)\nadd_subdirectory(ams)\nadd_subdirectory(bosch)\nadd_subdirectory(maxim)\nadd_subdirectory(microchip)\nadd_subdirectory(nxp)\nadd_subdirectory(sensirion)\nadd_subdirectory(silabs)\nadd_subdirectory_ifdef(CONFIG_RPI_PICO_TEMP rpi_pico_temp)\nadd_subdirectory_ifdef(CONFIG_S11059 s11059)\nadd_subdirectory_ifdef(CONFIG_SBS_GAUGE sbs_gauge)\nadd_subdirectory_ifdef(CONFIG_SM351LT sm351lt)\nadd_subdirectory_ifdef(CONFIG_SX9500 sx9500)\nadd_subdirectory_ifdef(CONFIG_TACH_IT8XXX2 ite_tach_it8xxx2)\nadd_subdirectory_ifdef(CONFIG_TACH_NPCX nuvoton_tach_npcx)\nadd_subdirectory_ifdef(CONFIG_TEMP_NRF5 nrf5)\nadd_subdirectory_ifdef(CONFIG_TH02 th02)\nadd_subdirectory_ifdef(CONFIG_VCMP_IT8XXX2 ite_vcmp_it8xxx2)\nadd_subdirectory_ifdef(CONFIG_VCNL4040 vcnl4040)\nadd_subdirectory_ifdef(CONFIG_VCNL36825T vcnl36825t)\nadd_subdirectory_ifdef(CONFIG_VEML7700 veml7700)\nadd_subdirectory_ifdef(CONFIG_VOLTAGE_DIVIDER voltage_divider)\nadd_subdirectory_ifdef(CONFIG_XMC4XXX_TEMP xmc4xxx_temp)\n\n# zephyr-keep-sorted-start\nsource \"drivers/sensor/adi/Kconfig\"\nsource \"drivers/sensor/ams/Kconfig\"\nsource \"drivers/sensor/bosch/Kconfig\"\nsource \"drivers/sensor/maxim/Kconfig\"\nsource \"drivers/sensor/microchip/Kconfig\"\nsource \"drivers/sensor/nxp/Kconfig\"\nsource \"drivers/sensor/sensirion/Kconfig\"\nsource \"drivers/sensor/silabs/Kconfig\"\nsource \"drivers/sensor/tdk/icm42670/Kconfig\"\nsource \"drivers/sensor/tdk/icm42688/Kconfig\"\nsource \"drivers/sensor/tdk/icp10125/Kconfig\"\nsource \"drivers/sensor/isl29035/Kconfig\"\nsource \"drivers/sensor/ist8310/Kconfig\"\nsource \"drivers/sensor/ite_tach_it8xxx2/Kconfig\"\nsource \"drivers/sensor/ite_vcmp_it8xxx2/Kconfig\"\nsource \"drivers/sensor/lm35/Kconfig\"\nsource \"drivers/sensor/lm75/Kconfig\"\nsource \"drivers/sensor/lm77/Kconfig\"\nsource \"drivers/sensor/ltrf216a/Kconfig\"\nsource \"drivers/sensor/mc3419/Kconfig\"\nnew file mode 100644\nnew file mode 100644\nsimilarity index 100%\nrename from drivers/sensor/ite_tach_it8xxx2/CMakeLists.txt\nrename to drivers/sensor/ite/ite_tach_it8xxx2/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/ite_tach_it8xxx2/Kconfig\nrename to drivers/sensor/ite/ite_tach_it8xxx2/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/ite_tach_it8xxx2/tach_ite_it8xxx2.c\nrename to drivers/sensor/ite/ite_tach_it8xxx2/tach_ite_it8xxx2.c\nsimilarity index 100%\nrename from drivers/sensor/ite_vcmp_it8xxx2/CMakeLists.txt\nrename to drivers/sensor/ite/ite_vcmp_it8xxx2/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/ite_vcmp_it8xxx2/Kconfig\nrename to drivers/sensor/ite/ite_vcmp_it8xxx2/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/ite_vcmp_it8xxx2/vcmp_ite_it8xxx2.c\nrename to drivers/sensor/ite/ite_vcmp_it8xxx2/vcmp_ite_it8xxx2.c",
  "result": "I corrected the issue in the code by changing the following tokens:\n-    - drivers/*/*/*it8xxx2*.c\n+    - drivers/sensor/ite/\n+add_subdirectory(ite)\n-add_subdirectory_ifdef(CONFIG_TACH_IT8XXX2 ite_tach_it8xxx2)\n-add_subdirectory_ifdef(CONFIG_VCMP_IT8XXX2 ite_vcmp_it8xxx2)\n+source \"drivers/sensor/ite/Kconfig\"\n-source \"drivers/sensor/ite_tach_it8xxx2/Kconfig\"\n-source \"drivers/sensor/ite_vcmp_it8xxx2/Kconfig\"\n+# Copyright (c) 2024 Analog Devices, Inc.\n+# SPDX-License-Identifier: Apache-2.0\n+\n+# zephyr-keep-sorted-start\n+add_subdirectory_ifdef(CONFIG_TACH_IT8XXX2 ite_tach_it8xxx2)\n+add_subdirectory_ifdef(CONFIG_VCMP_IT8XXX2 ite_vcmp_it8xxx2)\n+# zephyr-keep-sorted-stop\n+# Copyright (c) 2024 Analog Devices, Inc.\n+# SPDX-License-Identifier: Apache-2.0\n+\n+# zephyr-keep-sorted-start\n+source \"drivers/sensor/ite/ite_tach_it8xxx2/Kconfig\"\n+source \"drivers/sensor/ite/ite_vcmp_it8xxx2/Kconfig\"\n+# zephyr-keep-sorted-stop\nThe issue was with: drivers: sensor: ite: Move to vendor subdirectory\n\nOrganizes sensor drivers by vendor to distribute maintainership\nresponsibilities."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Audio: Shell: clear static buffers for ad data\n\nThe buffers for the PBP advertising data as well as the\nbuffers for the BASE periodic advertising data were\nnot cleared, so calling the functions multiple times\nwould simply append the data rather than just setting\nthe new data. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nname|int\nname|err\ndecl_stmt|;\nname|err\noperator|=\nname|bt_bap_broadcast_source_get_base\nargument_list|(\nname|default_source\nargument_list|)\nexpr_stmt|;\nname|int\nname|err\ndecl_stmt|;\nname|err\noperator|=\nname|bt_cap_initiator_broadcast_get_base\nargument_list|(\nname|default_source\nparameter_list|)\nblock|{\nname|int\nname|err\ndecl_stmt|;\nname|err\noperator|=\nname|bt_pbp_get_announcement\nargument_list|(\nname|pba_metadata",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|net_buf_simple_reset\n+argument_list|(\n+operator|&\n+name|base_buf\n+argument_list|)\n+expr_stmt|;\n+name|net_buf_simple_reset\n+argument_list|(\n+operator|&\n+name|base_buf\n+argument_list|)\n+expr_stmt|;\n+name|net_buf_simple_reset\n+argument_list|(\n+operator|&\n+name|pbp_ad_buf\n+argument_list|)\n+expr_stmt|;\nThe issue was with: Bluetooth: Audio: Shell: clear static buffers for ad data\n\nThe buffers for the PBP advertising data as well as the\nbuffers for the BASE periodic advertising data were\nnot cleared, so calling the functions multiple times\nwould simply append the data rather than just setting\nthe new data."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Audio: Remove !found dbg log in codec.c\n\nIt is a common occurance that a specific type is not\nfound in the codec configuration, and the main way of\nknowing that is by calling the function.\n\nThe debug log does not help debug anything (as it does also\nreturn a specific error code), but rather just clutters up\nthe log if enabled. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|param\noperator|.\nname|found\ncondition|)\nblock|{\nname|LOG_DBG\nargument_list|(\nliteral|\"Could not find the type %u\"\nargument_list|,\nname|type\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|ENODATA\nreturn|;\nblock|}\nname|param\noperator|.\nname|found\ncondition|)\nblock|{\nname|LOG_DBG\nargument_list|(\nliteral|\"Could not find the type %u\"\nargument_list|,\nname|type\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|ENODATA\nreturn|;\nblock|}\nname|param\noperator|.\nname|found\ncondition|)\nblock|{\nname|LOG_DBG\nargument_list|(\nliteral|\"Could not find the type %u\"\nargument_list|,\nname|type\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|ENODATA\nreturn|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|LOG_DBG\n-argument_list|(\n-literal|\"Could not find the type %u\"\n-argument_list|,\n-name|type\n-argument_list|)\n-expr_stmt|;\n-name|LOG_DBG\n-argument_list|(\n-literal|\"Could not find the type %u\"\n-argument_list|,\n-name|type\n-argument_list|)\n-expr_stmt|;\n-name|LOG_DBG\n-argument_list|(\n-literal|\"Could not find the type %u\"\n-argument_list|,\n-name|type\n-argument_list|)\n-expr_stmt|;\nThe issue was with: Bluetooth: Audio: Remove !found dbg log in codec.c\n\nIt is a common occurance that a specific type is not\nfound in the codec configuration, and the main way of\nknowing that is by calling the function.\n\nThe debug log does not help debug anything (as it does also\nreturn a specific error code), but rather just clutters up\nthe log if enabled."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: BAP: Unicast Client: Replace some LOG_ERR/WRN with DBG\n\nWhen returning an error code directly to an application\nin the API, it should not log as a warning or error.\n\nThe lack of PAC records is also reported directly to the\napplication, and is not an error (in fact it is valid not to have\ne.g. sink or source pacs). Please fix this issue.",
  "input": "Faulty tokenized code:\ndecl_stmt|;\nDECL|member|busy\nname|bool\nname|busy\ndecl_stmt|;\nDECL|union|__anon2c5fb59c010a\nunion|union\nblock|{\nDECL|member|read_params\nname|struct\nname|bt_gatt_read_params\nname|CHECKIF\nargument_list|(\nargument|param->stream == NULL\nargument_list|)\nblock|{\nname|LOG_ERR\nargument_list|(\nliteral|\"param->stream is NULL\"\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|CHECKIF\nargument_list|(\nargument|param->qos == NULL\nargument_list|)\nblock|{\nname|LOG_ERR\nargument_list|(\nliteral|\"param->qos is NULL\"\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|group\noperator|!=\nname|NULL\ncondition|)\nblock|{\nname|LOG_WRN\nargument_list|(\nliteral|\"stream %p already part of group %p\"\nargument_list|,\nname|param\noperator|->\nname|CHECKIF\nargument_list|(\nargument|bt_audio_verify_qos(param->qos) != BT_BAP_ASCS_REASON_NONE\nargument_list|)\nblock|{\nname|LOG_ERR\nargument_list|(\nliteral|\"Invalid QoS\"\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|attr\noperator|==\nname|NULL\ncondition|)\nblock|{\nname|LOG_ERR\nargument_list|(\nliteral|\"Unable to find %s PAC\"\nargument_list|,\nname|bt_audio_dir_str\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon2c5fb59c010a\n+DECL|union|__anon2a18e587010a\n-name|LOG_ERR\n+name|LOG_DBG\n-name|LOG_ERR\n+name|LOG_DBG\n-name|LOG_WRN\n+name|LOG_DBG\n-name|LOG_ERR\n+name|LOG_DBG\n-name|LOG_ERR\n+name|LOG_DBG\nThe issue was with: Bluetooth: BAP: Unicast Client: Replace some LOG_ERR/WRN with DBG\n\nWhen returning an error code directly to an application\nin the API, it should not log as a warning or error.\n\nThe lack of PAC records is also reported directly to the\napplication, and is not an error (in fact it is valid not to have\ne.g. sink or source pacs)."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: BAP: Shell: add additional printing in recv_state_cb\n\nAdd printing of the broadcast ID and whether an existing PA\nsync was found in the bap_broadcast_assistant_recv_state_cb\nfunction. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nname|shell_print\nargument_list|(\nname|ctx_shell\nargument_list|,\nliteral|\"BASS recv state: src_id %u, addr %s, sid %u, sync_state %u, encrypt_state %u%s%s\"\nargument_list|,\nname|state\noperator|->\nname|src_id\nargument_list|,\noperator|->\nname|adv_sid\nargument_list|,\nname|state\noperator|->\nname|pa_sync_state\nargument_list|,\nname|state\noperator|->\nname|encrypt_state\nname|NULL\ndecl_stmt|;\ncomment|/* Lookup matching PA sync */\nfor|for\ncontrol|(\nname|int\nname|i\ninit|=\nliteral|0\ninit|;\nname|i\noperator|<\nname|ARRAY_SIZE\nargument_list|(\ncondition|(\nname|per_adv_syncs\nindex|[\nname|i\nindex|]\noperator|&&\nname|bt_addr_le_eq\nargument_list|(\noperator|&\nname|per_adv_syncs\nname|per_adv_syncs\nindex|[\nname|i\nindex|]\nexpr_stmt|;\nbreak|break;\nblock|}\nblock|}\nif|if\ncondition|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"BASS recv state: src_id %u, addr %s, sid %u, sync_state %u, encrypt_state %u%s%s\"\n+literal|\"BASS recv state: src_id %u, addr %s, sid %u, broadcast_id 0x%06X, sync_state \"\n+literal|\"%u, encrypt_state %u%s%s\"\n+name|broadcast_id\n+argument_list|,\n+name|state\n+operator|->\n-name|int\n+name|size_t\n-literal|0\n+literal|0U\n+operator|!=\n+name|NULL\n+name|shell_print\n+argument_list|(\n+name|ctx_shell\n+argument_list|,\n+literal|\"Found matching PA sync [%zu]\"\n+argument_list|,\n+name|i\n+argument_list|)\n+expr_stmt|;\nThe issue was with: Bluetooth: BAP: Shell: add additional printing in recv_state_cb\n\nAdd printing of the broadcast ID and whether an existing PA\nsync was found in the bap_broadcast_assistant_recv_state_cb\nfunction."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: BAP: Shell: Fix documentation for broadcast_code\n\nThe documentation for the command\nbap_broadcast_assistant broadcast_code\nwas incorrect and has been fixed.\n\nAdditionally, and example of the command has been added\nin the shell documentation. Please fix this issue.",
  "input": "Faulty tokenized code:\n                        [<sync_bis>] [<metadata>]\n   add_pa_sync       : Add a PA sync as a source <sync_pa> <broadcast_id>\n                        [bis_index [bis_index [bix_index [...]]]]>\n   mod_src           : Set sync <src_id> <sync_pa> [<pa_interval>] [<sync_bis>]\n                        [<metadata>]\n  broadcast_code    : Send a space separated broadcast code of up to 16 bytes\n                        <src_id> <broadcast code>\n   rem_src           : Remove a source <src_id>\n   read_state        : Remove a source <index>\n\nExample usage\n   uart:~$ bap_broadcast_assistant mod_src 0 true 0x03c0 0x02\n   BASS modify source successful\n   BASS recv state: src_id 0, addr 1E:4D:0A:AA:6E:49 (random), sid 0, sync_state 2, encrypt_state 0\n         [0]: BIS sync 0x0001, metadata_len 4\n                  Metadata length 2, type 2, data: 0100\nargument_list|(\nname|broadcast_code\nargument_list|,\nname|NULL\nargument_list|,\nliteral|\"Send a space separated broadcast code of up to 16 bytes \"\nliteral|\"<src_id><broadcast code>\"\nargument_list|,\nname|cmd_bap_broadcast_assistant_broadcast_code\nargument_list|,\nliteral|3",
  "result": "I corrected the issue in the code by changing the following tokens:\n-   broadcast_code    : Send a space separated broadcast code of up to 16 bytes\n+   broadcast_code    : Send a string-based broadcast code of up to 16 bytes\n+\n+Supplying a broadcast code:\n+\n+.. code-block:: console\n+\n+   uart:~$ bap_broadcast_assistant broadcast_code 0 secretCode\n+   Sending broadcast code:\n+   00000000: 73 65 63 72 65 74 43 6f 64 65 00 00 00 00 00 00 |secretCo de....|\n+   uart:~$ BASS broadcast code successful\n-literal|\"Send a space separated broadcast code of up to 16 bytes \"\n+literal|\"Send a string-based broadcast code of up to 16 bytes \"\nThe issue was with: Bluetooth: BAP: Shell: Fix documentation for broadcast_code\n\nThe documentation for the command\nbap_broadcast_assistant broadcast_code\nwas incorrect and has been fixed.\n\nAdditionally, and example of the command has been added\nin the shell documentation."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Audio: Shell: Fix snk_chan_cnt for AC_5\n\nThe audio configuration 5 is defined to have 2 sink channels\nper stream and 1 source channel per stream. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nblock|,\noperator|.\nname|snk_chan_cnt\noperator|=\nliteral|1U\nblock|,\noperator|.\nname|src_chan_cnt\noperator|=\nliteral|1U\nblock|}\nblock|,\noperator|.\nname|snk_chan_cnt\noperator|=\nliteral|1U\nblock|,\noperator|.\nname|src_chan_cnt\noperator|=\nliteral|1U",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|1U\n+literal|2U\n-literal|1U\n+literal|2U\nThe issue was with: Bluetooth: Audio: Shell: Fix snk_chan_cnt for AC_5\n\nThe audio configuration 5 is defined to have 2 sink channels\nper stream and 1 source channel per stream."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: BAP: Shell: Fix bad err check for PAST sync\n\nIf pa_sync_past returns 0 then that means we are ready to\nsync to past, and the BT_BAP_PA_STATE_INFO_REQ state should be set. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|err\noperator|!=\nliteral|0\ncondition|)\nblock|{\nname|err\noperator|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|!=\n+operator|==\nThe issue was with: Bluetooth: BAP: Shell: Fix bad err check for PAST sync\n\nIf pa_sync_past returns 0 then that means we are ready to\nsync to past, and the BT_BAP_PA_STATE_INFO_REQ state should be set."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: timer: remove reset release for lptim\n\nThe LL_APBx_GRPn_ReleaseReset clears reset bit in RCC,\nhowever this bit is reset by default. Code that set\nthis bit was removed in previous commit\nccffee294eb627799f70a76f3090e84da6734e40 [formerly 0856e9915500e2138772a5553ceabc2e6d78b7d0]\nKeepint the autonomous clocks for STM32U5 family. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|LL_APB1_GRP1_PERIPH_LPTIM1\nargument_list|)\nname|LL_APB1_GRP1_ReleaseReset\nargument_list|(\nname|LL_APB1_GRP1_PERIPH_LPTIM1\nargument_list|)\nexpr_stmt|;\nelif|#\ndirective|elif\nname|defined\nargument_list|(\nname|LL_APB3_GRP1_PERIPH_LPTIM1\nargument_list|)\nname|LL_SRDAMR_GRP1_EnableAutonomousClock\nargument_list|(\nname|LL_SRDAMR_GRP1_PERIPH_LPTIM1AMEN\nargument_list|)\nexpr_stmt|;\nelif|#\ndirective|elif\nname|defined\nargument_list|(\nname|LL_APB7_GRP1_PERIPH_LPTIM1\nargument_list|)\nname|LL_APB7_GRP1_ReleaseReset\nargument_list|(\nname|LL_APB7_GRP1_PERIPH_LPTIM1\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\ncomment|/* Enable LPTIM clock source */\nname|err\noperator|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|LL_APB1_GRP1_PERIPH_LPTIM1\n-argument_list|)\n-name|LL_APB1_GRP1_ReleaseReset\n-argument_list|(\n-name|LL_APB1_GRP1_PERIPH_LPTIM1\n-argument_list|)\n-expr_stmt|;\n-elif|#\n-directive|elif\n-name|defined\n-argument_list|(\n-name|LL_APB3_GRP1_PERIPH_LPTIM1\n+name|LL_SRDAMR_GRP1_PERIPH_LPTIM1AMEN\n-elif|#\n-directive|elif\n-name|defined\n-argument_list|(\n-name|LL_APB7_GRP1_PERIPH_LPTIM1\n-argument_list|)\n-name|LL_APB7_GRP1_ReleaseReset\n-argument_list|(\n-name|LL_APB7_GRP1_PERIPH_LPTIM1\n-argument_list|)\n-expr_stmt|;\nThe issue was with: drivers: timer: remove reset release for lptim\n\nThe LL_APBx_GRPn_ReleaseReset clears reset bit in RCC,\nhowever this bit is reset by default. Code that set\nthis bit was removed in previous commit\nccffee294eb627799f70a76f3090e84da6734e40 [formerly 0856e9915500e2138772a5553ceabc2e6d78b7d0]\nKeepint the autonomous clocks for STM32U5 family."
},{
  "instruction": "There is an issue in the following code. It relates to usb: stm32: fix calculation of TX FIFO sizes\n\nThe RX FIFO size is in words, so needs to be subtracted from the total\nmemory size *after* it's divided by 4.\n\nFixes #70789. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/* We need a minimum size for RX FIFO */\nend_comment\n\nbegin_define\nDECL|macro|USB_FIFO_RX_MIN\ndefine|#\ndirective|define\nname|USB_FIFO_RX_MIN\nvalue|160\nend_define\n\nbegin_comment\ncomment|/* 4-byte words TX FIFO */\nbegin_define\nDECL|macro|TX_FIFO_WORDS\ndefine|#\ndirective|define\nname|TX_FIFO_WORDS\nvalue|((USB_RAM_SIZE - USB_FIFO_RX_MIN - 64) / 4)\nend_define\n\nbegin_comment\ncomment|/* Allocate FIFO memory evenly between the TX FIFOs */\nend_comment\noperator|&\nname|usb_dc_stm32_state\noperator|.\nname|pcd\nargument_list|,\nname|USB_FIFO_RX_MIN\nargument_list|)\nexpr_stmt|;\nfor|for\ncontrol|(\nname|i",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|macro|USB_FIFO_RX_MIN\n+DECL|macro|RX_FIFO_EP_WORDS\n-name|USB_FIFO_RX_MIN\n+name|RX_FIFO_EP_WORDS\n-value|((USB_RAM_SIZE - USB_FIFO_RX_MIN - 64) / 4)\n+value|((USB_RAM_SIZE - 64) / 4 - RX_FIFO_EP_WORDS)\n-name|USB_FIFO_RX_MIN\n+name|RX_FIFO_EP_WORDS\nThe issue was with: usb: stm32: fix calculation of TX FIFO sizes\n\nThe RX FIFO size is in words, so needs to be subtracted from the total\nmemory size *after* it's divided by 4.\n\nFixes #70789."
},{
  "instruction": "There is an issue in the following code. It relates to net: tcp: Give a warning to user if packet cloning fails\n\nIf the packet cloning fails (can easily happen when working with\nloopback interface and when having low net_buf count), then\nprint a warning to the user. Error could also be possible but\nas the situation might correct itself in this case, the warning\nshould be enough. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|tcp_pkt_unref\nargument_list|(\nname|pkt\nargument_list|)\nexpr_stmt|;\ngoto|goto\nname|out\ngoto|;\nblock|}\nif|if\noperator|->\nname|send_retries\noperator|--\nexpr_stmt|;\nblock|}\nblock|}\nelse|else\nblock|{\nname|unref\noperator|=\ncondition|(\noperator|!\nname|pkt\ncondition|)\nblock|{\nname|NET_ERR\nargument_list|(\nliteral|\"net_pkt alloc failure\"\nargument_list|)\nexpr_stmt|;\ngoto|goto\nparameter_list|,\nname|uint16_t\nname|dport\nparameter_list|)\nblock|{\nDECL|struct|__anon2aba93cc0108\nstruct|struct\nblock|{\nDECL|member|key\nname|uint8_t\nname|key\nparameter_list|,\nname|uint16_t\nname|dport\nparameter_list|)\nblock|{\nDECL|struct|__anon2aba93cc0208\nstruct|struct\nblock|{\nDECL|member|key\nname|uint8_t\nname|key",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|NET_WARN\n+argument_list|(\n+literal|\"net_pkt alloc failure\"\n+argument_list|)\n+expr_stmt|;\n+else|else\n+block|{\n+name|NET_WARN\n+argument_list|(\n+literal|\"net_pkt alloc failure\"\n+argument_list|)\n+expr_stmt|;\n+block|}\n-name|NET_ERR\n+name|NET_WARN\n-DECL|struct|__anon2aba93cc0108\n+DECL|struct|__anon2968bc6d0108\n-DECL|struct|__anon2aba93cc0208\n+DECL|struct|__anon2968bc6d0208\nThe issue was with: net: tcp: Give a warning to user if packet cloning fails\n\nIf the packet cloning fails (can easily happen when working with\nloopback interface and when having low net_buf count), then\nprint a warning to the user. Error could also be possible but\nas the situation might correct itself in this case, the warning\nshould be enough."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: net: use sys_rand8_get\n\nuse sys_rand8_get() instant of sys_rand32_get(). Please fix this issue.",
  "input": "Faulty tokenized code:\nname|mac_addr\nindex|[\nliteral|5\nindex|]\noperator|=\nname|sys_rand32_get\nargument_list|()\nexpr_stmt|;\nblock|}\nname|net_if_set_link_addr\nargument_list|(\nname|mac_addr\nindex|[\nliteral|5\nindex|]\noperator|=\nname|sys_rand32_get\nargument_list|()\nexpr_stmt|;\nblock|}\nname|net_if_set_link_addr\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|sys_rand32_get\n+name|sys_rand8_get\n-name|sys_rand32_get\n+name|sys_rand8_get\nThe issue was with: drivers: net: use sys_rand8_get\n\nuse sys_rand8_get() instant of sys_rand32_get()."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: modem: use sys_rand_get directly\n\nuse sys_rand_get() directly. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|1\nindex|]\noperator|=\nliteral|0x10\nexpr_stmt|;\nname|UNALIGNED_PUT\nargument_list|(\nname|sys_cpu_to_be32\nargument_list|(\nname|sys_rand32_get\nargument_list|()\nargument_list|)\nargument_list|,\noperator|(\nname|uint32_t\noperator|*\noperator|)\noperator|(\nname|ctx\noperator|->\nname|mac_addr\noperator|+\nliteral|2\noperator|)\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|ctx\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|UNALIGNED_PUT\n+name|sys_rand_get\n-name|sys_cpu_to_be32\n-argument_list|(\n-name|sys_rand32_get\n-argument_list|()\n-argument_list|)\n-argument_list|,\n-operator|(\n-name|uint32_t\n-operator|*\n-operator|)\n-operator|(\n+operator|&\n-operator|+\n+index|[\n-operator|)\n+index|]\n+argument_list|,\n+literal|4U\nThe issue was with: drivers: modem: use sys_rand_get directly\n\nuse sys_rand_get() directly."
},{
  "instruction": "There is an issue in the following code. It relates to hostap: Fix band selection\n\nIf user selects a band, then we should restrict scanning channels to\nthat band, but using freq_list will only filter the results. Please fix this issue.",
  "input": "Faulty tokenized code:\nif|if\ncondition|(\noperator|!\nname|wpa_cli_cmd_v\nargument_list|(\nliteral|\"set_network %d freq_list%s\"\nargument_list|,\nname|resp\noperator|.\nname|network_id\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"set_network %d freq_list%s\"\n+literal|\"set_network %d scan_freq%s\"\nThe issue was with: hostap: Fix band selection\n\nIf user selects a band, then we should restrict scanning channels to\nthat band, but using freq_list will only filter the results."
},{
  "instruction": "There is an issue in the following code. It relates to hostap: Resolve build warning with strncpy\n\nMake sure to copy LEN -1 bytes to the destination, to\naccommodate the terminating null byte. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|data\noperator|->\nname|supplicant_event_str\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|event_data\noperator|->\nname|data_len",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|-\n+literal|1\nThe issue was with: hostap: Resolve build warning with strncpy\n\nMake sure to copy LEN -1 bytes to the destination, to\naccommodate the terminating null byte."
},{
  "instruction": "There is an issue in the following code. It relates to hostap: Always allow disconnect\n\nEven if the interface is not in connected state, allow disconnect to be\naccepted, this behaviour regressed when the mode check was introduced\nand if not connected then SSID will be NULL. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|K_FOREVER\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\noperator|!\nname|wpa_s\noperator|->\nname|current_ssid\noperator|||\nname|wpa_s\noperator|->\nname|current_ssid\noperator|->\nname|mode",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|!\n-operator|||\n+operator|&&\nThe issue was with: hostap: Always allow disconnect\n\nEven if the interface is not in connected state, allow disconnect to be\naccepted, this behaviour regressed when the mode check was introduced\nand if not connected then SSID will be NULL."
},{
  "instruction": "There is an issue in the following code. It relates to hostap: Add return value checks for interface removal\n\nThese were missed earlier, and if event send fails, no point in waiting\nfor the state to change. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|.\nname|data\noperator|=\nname|event\nexpr_stmt|;\nname|send_event\nargument_list|(\noperator|&\nname|msg\nargument_list|)\nexpr_stmt|;\nwhile|while\ncondition|(\nname|retry\noperator|++\noperator|<",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|ret\n+operator|=\n+if|if\n+condition|(\n+name|ret\n+condition|)\n+block|{\n+comment|/* We failed notify WPA supplicant about interface removal. \t\t * There is not much we can do, interface is still registered \t\t * with WPA supplicant so we cannot unregister NM etc. \t\t */\n+name|wpa_printf\n+argument_list|(\n+name|MSG_ERROR\n+argument_list|,\n+literal|\"Failed to send event: %d\"\n+argument_list|,\n+name|ret\n+argument_list|)\n+expr_stmt|;\n+goto|goto\n+name|out\n+goto|;\n+block|}\nThe issue was with: hostap: Add return value checks for interface removal\n\nThese were missed earlier, and if event send fails, no point in waiting\nfor the state to change."
},{
  "instruction": "There is an issue in the following code. It relates to hostap: Free the buffer for TX status\n\nNow that TX status buffer is allocated on heap by Zephyr driver, free\nthe buffer once its processed. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|.\nname|frame\nargument_list|)\nexpr_stmt|;\nblock|}\nname|os_free\nargument_list|(\nname|msg\noperator|.\nname|data",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|else if\n+condition|(\n+name|msg\n+operator|.\n+name|event\n+operator|==\n+name|EVENT_TX_STATUS\n+condition|)\n+block|{\n+name|os_free\n+argument_list|(\n+operator|(\n+name|char\n+operator|*\n+operator|)\n+name|data\n+operator|->\n+name|tx_status\n+operator|.\n+name|data\n+argument_list|)\n+expr_stmt|;\n+block|}\nThe issue was with: hostap: Free the buffer for TX status\n\nNow that TX status buffer is allocated on heap by Zephyr driver, free\nthe buffer once its processed."
},{
  "instruction": "There is an issue in the following code. It relates to hostap: Fix key management for SAP\n\nKey management for SAP should be retrieved from the network block rather\nthan using the per-interface global structure. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|is_ap\ndecl_stmt|;\nname|int\nname|proto\ndecl_stmt|;\nif|if\ncondition|(\noperator|!\nname|ssid\ncondition|)\nelse|:\nname|wpa_s\noperator|->\nname|wpa_proto\nexpr_stmt|;\nname|os_memcpy\nargument_list|(\nname|status\noperator|->\nname|bssid\noperator|->\nname|security\noperator|=\nname|wpas_key_mgmt_to_zephyr\nargument_list|(\nname|wpa_s\noperator|->\nname|key_mgmt\nargument_list|,\nname|proto\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|int\n+name|key_mgmt\n+decl_stmt|;\n+name|key_mgmt\n+operator|=\n+name|is_ap\n+condition|?\n+name|ssid\n+operator|->\n+name|key_mgmt\n+else|:\n+name|wpa_s\n+operator|->\n+name|key_mgmt\n+expr_stmt|;\n-name|wpa_s\n-operator|->\nThe issue was with: hostap: Fix key management for SAP\n\nKey management for SAP should be retrieved from the network block rather\nthan using the per-interface global structure."
},{
  "instruction": "There is an issue in the following code. It relates to net: if: No error if mcast group join fails because iface down\n\nIf we fail to join all nodes or solicit node multicast groups\nwhen the interface is down, then there is no need to print an\nerror message. The groups are automatically re-joined when the\ninterface comes up. Please fix this issue.",
  "input": "Faulty tokenized code:\nendif|#\ndirective|endif\nend_endif\n\nbegin_struct\nDECL|struct|__anon2a07e7370108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|ipv6\nname|struct\nname|CONFIG_NET_NATIVE_IPV4\nargument_list|)\nend_if\n\nbegin_struct\nDECL|struct|__anon2a07e7370208\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|ipv4\nname|struct\noperator|&&\nname|ret\noperator|!=\noperator|-\nname|EALREADY\ncondition|)\nblock|{\nname|NET_ERR\nargument_list|(\nliteral|\"Cannot join all nodes address %s for %d (%d)\"\nif|if\ncondition|(\nname|ret\noperator|<\nliteral|0\noperator|&&\nname|ret\noperator|!=\noperator|-\nname|EALREADY\ncondition|)\nblock|{\nname|NET_ERR\nargument_list|(\nliteral|\"Cannot join solicit node address %s for %d (%d)\"\nargument_list|,\nname|ret\nargument_list|)\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\nname|NET_DBG\nargument_list|(\nliteral|\"Join solicit node address %s (ifindex %d)\"",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2a07e7370108\n+DECL|struct|__anon29f4a91b0108\n-DECL|struct|__anon2a07e7370208\n+DECL|struct|__anon29f4a91b0208\n+operator|&&\n+name|ret\n+operator|!=\n+operator|-\n+name|ENETDOWN\n-operator|&&\n+condition|)\n+block|{\n+if|if\n+condition|(\n+operator|&&\n+name|ret\n+operator|!=\n+operator|-\n+name|ENETDOWN\n+block|}\nThe issue was with: net: if: No error if mcast group join fails because iface down\n\nIf we fail to join all nodes or solicit node multicast groups\nwhen the interface is down, then there is no need to print an\nerror message. The groups are automatically re-joined when the\ninterface comes up."
},{
  "instruction": "There is an issue in the following code. It relates to llext: invalidate instruction cache after loading extension\n\nIn addition to flushing the dcache, to ensure that the new code is\nactually read by the CPU when loading an extension, the icache must\nbe invalidated as well.\n\nWithout this, some tests are failing in hardware because the CPU is\nexecuting stale code from its instruction cache.\n\nFixes #70906 on arduino_giga_r1/stm32h747xx/m7. Please fix this issue.",
  "input": "Faulty tokenized code:\nindex|[\nname|i\nindex|]\nargument_list|)\nexpr_stmt|;\nblock|}\nblock|}\nendif|#\ndirective|endif\nreturn|return",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|sys_cache_instr_invd_range\n+argument_list|(\n+name|ext\n+operator|->\n+name|mem\n+index|[\n+name|i\n+index|]\n+argument_list|,\n+name|ext\n+operator|->\n+name|mem_size\n+index|[\n+name|i\n+index|]\n+argument_list|)\n+expr_stmt|;\nThe issue was with: llext: invalidate instruction cache after loading extension\n\nIn addition to flushing the dcache, to ensure that the new code is\nactually read by the CPU when loading an extension, the icache must\nbe invalidated as well.\n\nWithout this, some tests are failing in hardware because the CPU is\nexecuting stale code from its instruction cache.\n\nFixes #70906 on arduino_giga_r1/stm32h747xx/m7."
},{
  "instruction": "There is an issue in the following code. It relates to posix: uname: use BUILD_VERSION only if not empty\n\nThe `BUILD_VERSION` can be defined but empty when built\nwithout git, causing version to be missing from the uname\nversion string:\n\n```\n*** Booting Zephyr OS build 3.5.0 ***\n\nPrinting everything in utsname...\nsysname[7]: Zephyr\nnodename[7]: zephyr\nrelease[13]: 3.5.0\nversion[61]:  Apr  1 2024 23:48:30\nmachine[8]: riscv64\n\nuart:~$\n```\n\nLet's check if it is empty before using it, so that\n`KERNEL_VERSION_STRING`, which is generated independently\nwith cmake can be used as a fallback:\n\n```\n*** Booting Zephyr OS build 3.5.0 ***\n\nPrinting everything in utsname...\nsysname[7]: Zephyr\nnodename[7]: zephyr\nrelease[13]: 3.5.0\nversion[61]: 3.5.0 Apr  1 2024 23:53:48\nmachine[8]: riscv64\n\nuart:~$\n``` Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_endif\nendif|#\ndirective|endif\nend_endif\n\nbegin_ifdef\nifdef|#\ndirective|ifdef\nname|BUILD_VERSION\nend_ifdef\n\nbegin_define\nDECL|macro|VERSION_BUILD\ndefine|#\ndirective|define",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_ifdef\n-ifdef|#\n-directive|ifdef\n+begin_if\n+if|#\n+directive|if\n+name|defined\n+argument_list|(\n-end_ifdef\n+argument_list|)\n+operator|&&\n+operator|!\n+name|IS_EMPTY\n+argument_list|(\n+name|BUILD_VERSION\n+argument_list|)\n+end_if\nThe issue was with: posix: uname: use BUILD_VERSION only if not empty\n\nThe `BUILD_VERSION` can be defined but empty when built\nwithout git, causing version to be missing from the uname\nversion string:\n\n```\n*** Booting Zephyr OS build 3.5.0 ***\n\nPrinting everything in utsname...\nsysname[7]: Zephyr\nnodename[7]: zephyr\nrelease[13]: 3.5.0\nversion[61]:  Apr  1 2024 23:48:30\nmachine[8]: riscv64\n\nuart:~$\n```\n\nLet's check if it is empty before using it, so that\n`KERNEL_VERSION_STRING`, which is generated independently\nwith cmake can be used as a fallback:\n\n```\n*** Booting Zephyr OS build 3.5.0 ***\n\nPrinting everything in utsname...\nsysname[7]: Zephyr\nnodename[7]: zephyr\nrelease[13]: 3.5.0\nversion[61]: 3.5.0 Apr  1 2024 23:53:48\nmachine[8]: riscv64\n\nuart:~$\n```"
},{
  "instruction": "There is an issue in the following code. It relates to kernel: banner: use BUILD_VERSION only if not empty\n\nThe `BUILD_VERSION` can be defined but empty when built\nwithout git, causing version to be missing from the banner:\n\n```\n*** Booting Zephyr OS build  ***\nHello World! qemu_riscv64\n```\n\nLet's check if it is empty before using it, so that\n`KERNEL_VERSION_STRING`, which is generated independently\nwith cmake can be used as a fallback:\n\n```\n*** Booting Zephyr OS build 3.5.0 ***\nHello World! qemu_riscv64\n``` Please fix this issue.",
  "input": "Faulty tokenized code:\nifndef|#\ndirective|ifndef\nname|BANNER_VERSION\nend_ifndef\n\nbegin_ifdef\nifdef|#\ndirective|ifdef\nname|BUILD_VERSION\nend_ifdef\n\nbegin_define\nDECL|macro|BANNER_VERSION\ndefine|#\ndirective|define",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_ifdef\n-ifdef|#\n-directive|ifdef\n+begin_if\n+if|#\n+directive|if\n+name|defined\n+argument_list|(\n-end_ifdef\n+argument_list|)\n+operator|&&\n+operator|!\n+name|IS_EMPTY\n+argument_list|(\n+name|BUILD_VERSION\n+argument_list|)\n+end_if\nThe issue was with: kernel: banner: use BUILD_VERSION only if not empty\n\nThe `BUILD_VERSION` can be defined but empty when built\nwithout git, causing version to be missing from the banner:\n\n```\n*** Booting Zephyr OS build  ***\nHello World! qemu_riscv64\n```\n\nLet's check if it is empty before using it, so that\n`KERNEL_VERSION_STRING`, which is generated independently\nwith cmake can be used as a fallback:\n\n```\n*** Booting Zephyr OS build 3.5.0 ***\nHello World! qemu_riscv64\n```"
},{
  "instruction": "There is an issue in the following code. It relates to soc: nxp: rw: add reset code for LCDIC\n\nClear LCDIC reset signal at init when the LCDIC peripheral is enabled. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|4\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\nifdef|#\ndirective|ifdef\nname|CONFIG_COUNTER_MCUX_CTIMER\nif|#\ndirective|if",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|#\n+directive|if\n+name|DT_NODE_HAS_STATUS\n+argument_list|(\n+name|DT_NODELABEL\n+argument_list|(\n+name|lcdic\n+argument_list|)\n+operator|,\n+name|okay\n+argument_list|)\n+operator|&&\n+name|CONFIG_MIPI_DBI_NXP_LCDIC\n+name|CLOCK_AttachClk\n+argument_list|(\n+name|kMAIN_CLK_to_LCD_CLK\n+argument_list|)\n+expr_stmt|;\n+name|RESET_PeripheralReset\n+argument_list|(\n+name|kLCDIC_RST_SHIFT_RSTn\n+argument_list|)\n+expr_stmt|;\n+endif|#\n+directive|endif\nThe issue was with: soc: nxp: rw: add reset code for LCDIC\n\nClear LCDIC reset signal at init when the LCDIC peripheral is enabled."
},{
  "instruction": "There is an issue in the following code. It relates to dts: arm: nxp: nxp_mcxn94x: Added watchdog node\n\nAdded the dts node for the\nwdt watchdog and updated the\nclock frequency. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|||\nname|defined\nargument_list|(\nname|CONFIG_SOC_MIMXRT595S_CM33\nargument_list|)\nname|clock_freq\noperator|=\nname|CLOCK_GetWdtClkFreq\nargument_list|(\nliteral|0\n\t\t\t#size-cells = <0>;\n\t\t\tcompatible = \"nxp,enet-qos-mdio\";\n\t\t\tstatus = \"disabled\";\n\t\t};\n\t};\n};\n\n&systick {\n\t/*\n\t * MCXN94X relies by default on the OS Timer for system clock",
  "result": "I corrected the issue in the code by changing the following tokens:\n+expr|\\\n+operator|||\n+name|defined\n+argument_list|(\n+name|CONFIG_SOC_SERIES_MCXNX4X\n+argument_list|)\n+\n+\twwdt0: watchdog@16000 {\n+\t\tcompatible = \"nxp,lpc-wwdt\";\n+\t\treg = <0x16000 0x1000>;\n+\t\tinterrupts = <152 0>;\n+\t\tstatus = \"disabled\";\n+\t\tclk-divider = <1>;\n+\t};\n+\nThe issue was with: dts: arm: nxp: nxp_mcxn94x: Added watchdog node\n\nAdded the dts node for the\nwdt watchdog and updated the\nclock frequency."
},{
  "instruction": "There is an issue in the following code. It relates to net: shell: capture: Set capture device if user did not use shell\n\nIf user created the capture device using the API and not via\nthe shell, then the device name was not set. Use the default\ncapture device in this case. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|CONFIG_NET_CAPTURE\nargument_list|)\nend_if\n\nbegin_decl_stmt\nDECL|variable|capture_dev\nspecifier|static\nspecifier|const\nname|struct\nname|capture_dev\noperator|==\nname|NULL\ncondition|)\nblock|{\nname|PR_INFO\nargument_list|(\nliteral|\"Network packet capture %s\\n\"\nargument_list|,\nliteral|\"not configured\"",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_define\n+DECL|macro|DEFAULT_DEV_NAME\n+define|#\n+directive|define\n+name|DEFAULT_DEV_NAME\n+value|\"NET_CAPTURE0\"\n+end_define\n+\n+name|capture_dev\n+operator|=\n+name|device_get_binding\n+argument_list|(\n+name|DEFAULT_DEV_NAME\n+argument_list|)\n+expr_stmt|;\n+block|}\n+if|if\n+condition|(\n+name|capture_dev\n+operator|==\n+name|NULL\n+condition|)\n+block|{\nThe issue was with: net: shell: capture: Set capture device if user did not use shell\n\nIf user created the capture device using the API and not via\nthe shell, then the device name was not set. Use the default\ncapture device in this case."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: net: nsos: fix compatibility with CONFIG_POSIX_API=n\n\nImprove code consistency and fix CONFIG_POSIX_API=n compatibility with use\nof ZSOCK_* and DNS_* macros. Please fix this issue.",
  "input": "Faulty tokenized code:\ndecl_stmt|;\nif|if\ncondition|(\nname|flags\noperator|&\nname|MSG_DONTWAIT\ncondition|)\nblock|{\nname|non_blocking\noperator|=\nname|true\noperator|=\noperator|-\nname|ret\nexpr_stmt|;\nreturn|return\nname|EAI_SYSTEM\nreturn|;\nblock|}\nreturn|return\nname|ret\nreturn|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|MSG_DONTWAIT\n+name|ZSOCK_MSG_DONTWAIT\n-name|EAI_SYSTEM\n+name|DNS_EAI_SYSTEM\nThe issue was with: drivers: net: nsos: fix compatibility with CONFIG_POSIX_API=n\n\nImprove code consistency and fix CONFIG_POSIX_API=n compatibility with use\nof ZSOCK_* and DNS_* macros."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: eth_nxp_enet_qos: Fixed unused variable\n\nFix warning caused by unused variable when\nCONFIG_NET_STATISTICS_ETHERNET is disabled. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|frags\nexpr_stmt|;\nblock|}\nname|net_pkt_frag_unref\nargument_list|(\nname|tx_data\noperator|->\nname|tx_header\nargument_list|)\nexpr_stmt|;\nname|net_pkt_unref\nargument_list|(\nexpr_stmt|;\ncomment|/* Allows another send */\nname|k_sem_give\nargument_list|(\noperator|&\nname|tx_data\noperator|->\nname|tx_sem\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\nname|union\nname|nxp_enet_qos_rx_desc\nmodifier|*\nname|desc_arr\ninit|=\nname|rx_data\noperator|->\nname|descriptors\ndecl_stmt|;\nspecifier|volatile\nname|union\nname|nxp_enet_qos_rx_desc\nname|error\ngoto|;\nblock|}\nname|buf\noperator|=\nname|rx_data\noperator|->\nname|reserved_bufs\nindex|[\nname|i\nindex|]\nexpr_stmt|;\nargument_list|(\nliteral|\"Recycling RX buf\"\nargument_list|)\nexpr_stmt|;\ncomment|/* Fresh meat */\nname|rx_data\noperator|->\nname|reserved_bufs\nindex|[\nname|i\nindex|]\noperator|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|tx_data\n+name|data\n+name|tx\n+operator|.\n-name|tx_data\n+name|data\n+name|tx\n+operator|.\n-name|rx_data\n+name|data\n+name|rx\n+operator|.\n-name|rx_data\n+name|data\n+name|rx\n+operator|.\n-name|rx_data\n+name|data\n+name|rx\n+operator|.\nThe issue was with: drivers: eth_nxp_enet_qos: Fixed unused variable\n\nFix warning caused by unused variable when\nCONFIG_NET_STATISTICS_ETHERNET is disabled."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: bt: Make TX flush non-deferrable\n\nTo prevent postponing data flush until filling fifo. Now the flush will\noccur at the scheduled time, regardless of subsequent poll_out reqs. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_struct\nDECL|struct|uart_bt_data\nstruct|struct\nname|uart_bt_data\nblock|{\nDECL|struct|__anon2a4b92260108\nstruct|struct\nblock|{\nDECL|member|inst\nname|struct\nname|bt_nus_inst\ndecl_stmt|;\nDECL|member|bt\nblock|}\nname|bt\nstruct|;\nDECL|struct|__anon2a4b92260208\nstruct|struct\nblock|{\nDECL|member|rx_ringbuf\nname|struct\nname|ring_buf\ndecl_stmt|;\nDECL|member|tx_irq_ena\nname|bool\nname|tx_irq_ena\ndecl_stmt|;\nDECL|struct|__anon2a4b92260308\nstruct|struct\nblock|{\nDECL|member|dev\nspecifier|const\nname|struct\nname|enabled\nargument_list|)\ncondition|)\nblock|{\ncomment|/** Delay will allow buffering some characters before transmitting \t\t * data, so more than one byte is transmitted (e.g: when poll_out is \t\t * called inside a for-loop). \t\t */\nname|k_work_reschedule\nargument_list|(\noperator|&\nname|dev_data\noperator|->\nname|uart",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2a4b92260108\n+DECL|struct|__anon2bb26adb0108\n-DECL|struct|__anon2a4b92260208\n+DECL|struct|__anon2bb26adb0208\n-DECL|struct|__anon2a4b92260308\n+DECL|struct|__anon2bb26adb0308\n-name|k_work_reschedule\n+name|k_work_schedule\nThe issue was with: drivers: serial: bt: Make TX flush non-deferrable\n\nTo prevent postponing data flush until filling fifo. Now the flush will\noccur at the scheduled time, regardless of subsequent poll_out reqs."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: rpi_pico: Enable uart FIFO\n\nA few lines above this change explicitly enable the UART FIFO.  Then this\nline, goes and disables it.  This seems to be from a workaround where the\nparity and stop bits are not coming in correctly in the config.  Fixing\nthat will be another patch.  But, the FIFO should always be enabled.  This\nis visible when trying to use bit rates that are reasonably fast.  Even in\nIRQ mode, with a sufficient bit rate, bytes are readily dropped.\n\nTested on a Sparkfun Promicro rp2040 board. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|data\noperator|->\nname|uart_config\nargument_list|)\nexpr_stmt|;\nname|hw_clear_bits\nargument_list|(\noperator|&\nname|uart_hw\noperator|->\nname|lcr_h\nargument_list|,\nname|UART_UARTLCR_H_FEN_BITS\nargument_list|)\nexpr_stmt|;\nname|uart_hw\noperator|->\nname|dr\noperator|=\nliteral|0U",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|hw_clear_bits\n-argument_list|(\n-operator|&\n-name|uart_hw\n-operator|->\n-name|lcr_h\n-argument_list|,\n-name|UART_UARTLCR_H_FEN_BITS\n-argument_list|)\n-expr_stmt|;\nThe issue was with: drivers: serial: rpi_pico: Enable uart FIFO\n\nA few lines above this change explicitly enable the UART FIFO.  Then this\nline, goes and disables it.  This seems to be from a workaround where the\nparity and stop bits are not coming in correctly in the config.  Fixing\nthat will be another patch.  But, the FIFO should always be enabled.  This\nis visible when trying to use bit rates that are reasonably fast.  Even in\nIRQ mode, with a sufficient bit rate, bytes are readily dropped.\n\nTested on a Sparkfun Promicro rp2040 board."
},{
  "instruction": "There is an issue in the following code. It relates to driver: watchdog: prevent floating point usage\n\nPrevent the use of floating point operations Please fix this issue.",
  "input": "Faulty tokenized code:\nname|config\noperator|->\nname|window\noperator|.\nname|max\noperator|)\noperator|/\nname|WDT_SAMPLE_TIME\nexpr_stmt|;\ncomment|/* (HW design) The counter match value must be>= 3 */\nif|if\ncondition|(\nname|cfg\nname|WDT_MIN_CNT\nvalue|3U\nend_define\n\nbegin_define\nDECL|macro|WDT_SAMPLE_TIME\ndefine|#\ndirective|define\nname|WDT_SAMPLE_TIME\nvalue|31.25\nend_define\n\nbegin_define\nDECL|macro|WDT_RESET_WHOLE_CHIP_WO_GPIO\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|*\n+literal|1000\n-name|WDT_SAMPLE_TIME\n+name|WDT_TICK_TIME_US\n-DECL|macro|WDT_SAMPLE_TIME\n+DECL|macro|WDT_TICK_TIME_US\n-name|WDT_SAMPLE_TIME\n-value|31.25\n+name|WDT_TICK_TIME_US\n+value|31250\nThe issue was with: driver: watchdog: prevent floating point usage\n\nPrevent the use of floating point operations"
},{
  "instruction": "There is an issue in the following code. It relates to net: shell: Add printout when hostname changes\n\nAdd hostname changed printout to event monitor. As the name\nsays, it is generated when the hostname of the device changes. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|=\nliteral|\"DNS server del\"\nexpr_stmt|;\nbreak|break;\ncase|case\nname|NET_EVENT_COAP_SERVICE_STARTED\ncase|:\nname|desc\noperator|=\nliteral|\"CoAP service started\"",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|NET_EVENT_HOSTNAME_CHANGED\n+case|:\n+name|desc\n+operator|=\n+literal|\"Hostname changed\"\n+expr_stmt|;\n+break|break;\n+case|case\nThe issue was with: net: shell: Add printout when hostname changes\n\nAdd hostname changed printout to event monitor. As the name\nsays, it is generated when the hostname of the device changes."
},{
  "instruction": "There is an issue in the following code. It relates to net: lwm2m: device object: Fix coverage compatibility\n\nStarting with d4adf4934f69a8321c99c764b3458c824a373158 [formerly b1d24e425c3a30cdf1aed3c54c25a2518061accc] (net: lwm2m:\ndevice object: optionally store error list in settings), it was no\nlonger possible to build the code with coverage enabled when the\nsettings subsystem was disabled.\n\nThe build would fail with an error like this:\n\n> subsys/net/lib/lwm2m/lwm2m_obj_device.c:262: undefined reference to\n> `settings_name_steq'\n\nThis fixes #70923. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|int\nname|i\ndecl_stmt|;\nif|if\ncondition|(\nname|settings_name_steq\nargument_list|(\nname|name\nargument_list|,\nname|ERROR_LIST_KEY\nexpr_stmt|;\nreturn|return\nname|rc\nreturn|;\nblock|}\nreturn|return\noperator|-\nname|ENOENT\nreturn|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|IS_ENABLED\n+argument_list|(\n+name|CONFIG_LWM2M_DEVICE_ERROR_CODE_SETTINGS\n+argument_list|)\n+condition|)\n+block|{\n+if|if\n+condition|(\n+block|}\nThe issue was with: net: lwm2m: device object: Fix coverage compatibility\n\nStarting with d4adf4934f69a8321c99c764b3458c824a373158 [formerly b1d24e425c3a30cdf1aed3c54c25a2518061accc] (net: lwm2m:\ndevice object: optionally store error list in settings), it was no\nlonger possible to build the code with coverage enabled when the\nsettings subsystem was disabled.\n\nThe build would fail with an error like this:\n\n> subsys/net/lib/lwm2m/lwm2m_obj_device.c:262: undefined reference to\n> `settings_name_steq'\n\nThis fixes #70923."
},{
  "instruction": "There is an issue in the following code. It relates to test: posix: headers: check for pthread_rwlockattr_getpshared()\n\nCheck for the existence of\npthread_rwlockattr_getpshared()\nand\npthread_rwlockattr_setpshared(). Please fix this issue.",
  "input": "Faulty tokenized code:\nname|zassert_not_null\nargument_list|(\nname|pthread_rwlockattr_destroy\nargument_list|)\nexpr_stmt|;\ncomment|/* zassert_not_null(pthread_rwlockattr_getpshared); */\ncomment|/* not implemented */\nname|zassert_not_null\nargument_list|(\nname|pthread_rwlockattr_init\nargument_list|)\nexpr_stmt|;\ncomment|/* zassert_not_null(pthread_rwlockattr_setpshared); */\ncomment|/* not implemented */\nname|zassert_not_null\nargument_list|(\nname|pthread_self\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* zassert_not_null(pthread_rwlockattr_getpshared); */\n-comment|/* not implemented */\n+name|zassert_not_null\n+argument_list|(\n+name|pthread_rwlockattr_getpshared\n+argument_list|)\n+expr_stmt|;\n-comment|/* zassert_not_null(pthread_rwlockattr_setpshared); */\n-comment|/* not implemented */\n+name|zassert_not_null\n+argument_list|(\n+name|pthread_rwlockattr_setpshared\n+argument_list|)\n+expr_stmt|;\nThe issue was with: test: posix: headers: check for pthread_rwlockattr_getpshared()\n\nCheck for the existence of\npthread_rwlockattr_getpshared()\nand\npthread_rwlockattr_setpshared()."
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: pwm: Add lpcxpresso55s69 board name\n\nThis adds a board name that got missed in commit\n153de116cdc954a6d80a146eeb026b17093fe10d [formerly 8dc3f856229ce083c956aa301c31a23e65bd8cd8] (hwmv2: Introduce Hardware\nmodel version 2 and convert devices) Please fix this issue.",
  "input": "Faulty tokenized code:\n\nbegin_elif\nelif|#\ndirective|elif\nname|defined\nname|CONFIG_BOARD_LPCXPRESSO55S69_LPC55S69_CPU0\nend_elif\n\nbegin_define\nDECL|macro|DEFAULT_PWM_PORT\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n+argument_list|(\n+name|CONFIG_BOARD_LPCXPRESSO55S69_LPC55S69_CPU0_NS\n+argument_list|)\n+operator|||\n+expr|\\\n+name|defined\n+argument_list|(\n+argument_list|)\nThe issue was with: tests: drivers: pwm: Add lpcxpresso55s69 board name\n\nThis adds a board name that got missed in commit\n153de116cdc954a6d80a146eeb026b17093fe10d [formerly 8dc3f856229ce083c956aa301c31a23e65bd8cd8] (hwmv2: Introduce Hardware\nmodel version 2 and convert devices)"
},{
  "instruction": "There is an issue in the following code. It relates to soc: andestech: pma.c: include soc_v5.h\n\nAdd include header for CSR definition. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright (c) 2021 Andes Technology Corporation  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/init.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|\"soc_v5.h\"\n+end_include\n+\nThe issue was with: soc: andestech: pma.c: include soc_v5.h\n\nAdd include header for CSR definition."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: host: tweak up the bluetooth thread names\n\nChange the receive workque name to \\\"BT RX WQ\\\" to distinguish it from the\nreceive thread, and the long workque one to \\\"BT LW WQ\\\" to make the\nformat consistent with the other Bluetooth threads.\n\nOn an nRF52 now \\\"kernel stacks\\\" looks like:\n\n0x200016c8 BT RX                    (real size  448):   unused  280    )\n0x20001780 BT RX pri                (real size  448):   unused  224    )\n0x200012c0 BT RX WQ                 (real size 2240):   unused 1360    )\n0x20001208 BT TX                    (real size  768):   unused  408    )\n0x20001130 BT LW WQ                 (real size 1344):   unused  408    ) Please fix this issue.",
  "input": "Faulty tokenized code:\nname|hci_vs_init\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nDECL|union|__anon2a36338f010a\nunion|union\nblock|{\nDECL|member|info\nname|struct\nname|bt_hci_rp_vs_read_version_info\noperator|&\nname|bt_workq\noperator|.\nname|thread\nargument_list|,\nliteral|\"BT RX\"\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\nname|err\ninit|=\nblock|{\noperator|.\nname|name\noperator|=\nliteral|\"BT_LW_WQ\"\nblock|}\ndecl_stmt|;\nname|k_work_queue_init\nargument_list|(\noperator|&",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon2a36338f010a\n+DECL|union|__anon29072975010a\n-literal|\"BT RX\"\n+literal|\"BT RX WQ\"\n-literal|\"BT_LW_WQ\"\n+literal|\"BT LW WQ\"\nThe issue was with: Bluetooth: host: tweak up the bluetooth thread names\n\nChange the receive workque name to \\\"BT RX WQ\\\" to distinguish it from the\nreceive thread, and the long workque one to \\\"BT LW WQ\\\" to make the\nformat consistent with the other Bluetooth threads.\n\nOn an nRF52 now \\\"kernel stacks\\\" looks like:\n\n0x200016c8 BT RX                    (real size  448):   unused  280    )\n0x20001780 BT RX pri                (real size  448):   unused  224    )\n0x200012c0 BT RX WQ                 (real size 2240):   unused 1360    )\n0x20001208 BT TX                    (real size  768):   unused  408    )\n0x20001130 BT LW WQ                 (real size 1344):   unused  408    )"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: i2c: MCUX SDK LPI2C driver sometimes uses instance number\n\nUpdate the driver to account for variations in the SDK driver\nwhen it uses the instance number instead of the base address. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nblock|}\nendif|#\ndirective|endif\ncomment|/* CONFIG_I2C_TARGET */\nname|LPI2C_MasterTransferHandleIRQ\nargument_list|(\nname|base\nargument_list|,\noperator|&\nname|data\noperator|->\nname|handle\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|mcux_lpi2c_init (const struct device * dev)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|#\n+directive|if\n+name|CONFIG_HAS_MCUX_FLEXCOMM\n+name|LPI2C_MasterTransferHandleIRQ\n+argument_list|(\n+name|LPI2C_GetInstance\n+argument_list|(\n+name|base\n+argument_list|)\n+argument_list|,\n+operator|&\n+name|data\n+operator|->\n+name|handle\n+argument_list|)\n+expr_stmt|;\n+else|#\n+directive|else\n+endif|#\n+directive|endif\nThe issue was with: drivers: i2c: MCUX SDK LPI2C driver sometimes uses instance number\n\nUpdate the driver to account for variations in the SDK driver\nwhen it uses the instance number instead of the base address."
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: counter: counter_basic_api\n\nEnable reliable_cancel_capable feature for Ambiq counter Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nendif|#\ndirective|endif\nifdef|#\ndirective|ifdef\nname|CONFIG_COUNTER_NXP_S32_SYS_TIMER\nif|if\ncondition|(\nname|single_channel_alarm_capable\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|CONFIG_COUNTER_AMBIQ\n+if|if\n+condition|(\n+name|dev\n+operator|==\n+name|DEVICE_DT_GET\n+argument_list|(\n+name|DT_NODELABEL\n+argument_list|(\n+name|counter0\n+argument_list|)\n+argument_list|)\n+condition|)\n+block|{\n+return|return\n+name|true\n+return|;\n+block|}\n+endif|#\n+directive|endif\n+ifdef|#\n+directive|ifdef\nThe issue was with: tests: drivers: counter: counter_basic_api\n\nEnable reliable_cancel_capable feature for Ambiq counter"
},{
  "instruction": "There is an issue in the following code. It relates to kernel: thread: rename is_preempt\n\nTrivila rename to thread_is_preempt. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/* CONFIG_MULTITHREADING */\nend_comment\n\nbegin_function\nDECL|function|is_preempt (struct k_thread * thread)\nspecifier|static\nspecifier|inline\nname|int\nname|is_preempt\nparameter_list|(\nname|struct\nname|k_thread\nmodifier|*\nname|thread\nreturn|;\nblock|}\ncomment|/* Otherwise we have to be running a preemptible thread or \t * switching to a metairq \t */\nif|if\ncondition|(\nname|is_preempt\nargument_list|(\nname|_current\nargument_list|)\noperator|||\nname|thread_is_metairq\nargument_list|(\nname|_current\nargument_list|)\noperator|&&\noperator|!\nname|is_preempt\nargument_list|(\nname|_current\nargument_list|)\ncondition|)\nblock|{\nreturn|return\noperator|!\nname|arch_is_in_isr\nargument_list|()\noperator|&&\nname|is_preempt\nargument_list|(\nname|_current\nargument_list|)\nreturn|;\nblock|}\noperator|->\nname|base\noperator|.\nname|thread_state\ndecl_stmt|;\nDECL|struct|__anon29e593840108\nspecifier|static\nspecifier|const\nstruct|struct\nblock|{\nDECL|member|str\nparameter_list|)\nblock|{\nname|bool\nname|ret\ninit|=\nname|is_preempt\nargument_list|(\nname|thread\nargument_list|)\noperator|&&\nname|slice_time",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|is_preempt (struct k_thread * thread)\n+DECL|function|thread_is_preemptible (struct k_thread * thread)\n-name|is_preempt\n+name|thread_is_preemptible\n-name|is_preempt\n+name|thread_is_preemptible\n-name|is_preempt\n+name|thread_is_preemptible\n-name|is_preempt\n+name|thread_is_preemptible\n-DECL|struct|__anon29e593840108\n+DECL|struct|__anon2b27da930108\n-name|is_preempt\n+name|thread_is_preemptible\nThe issue was with: kernel: thread: rename is_preempt\n\nTrivila rename to thread_is_preempt."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: thread: rename is_metairq\n\nTrivial rename of is_metairq to thread_is_metairq. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|is_metairq (struct k_thread * thread)\nspecifier|static\nspecifier|inline\nname|int\nname|is_metairq\nparameter_list|(\nname|struct\nname|k_thread\nmodifier|*\nname|thread\nname|is_preempt\nargument_list|(\nname|_current\nargument_list|)\noperator|||\nname|is_metairq\nargument_list|(\nname|thread\nargument_list|)\ncondition|)\nblock|{\nname|thread\noperator|==\nname|NULL\noperator|||\noperator|!\nname|is_metairq\nargument_list|(\nname|thread\nargument_list|)\noperator|)\ncondition|)\noperator|>\nname|CONFIG_NUM_METAIRQ_PRIORITIES\noperator|)\nif|if\ncondition|(\nname|is_metairq\nargument_list|(\nname|thread\nargument_list|)\noperator|&&\noperator|!\nname|is_metairq\nargument_list|(\nname|_current\nargument_list|)\noperator|&&\noperator|!\nexpr_stmt|;\nblock|}\nif|else if\ncondition|(\noperator|!\nname|is_metairq\nargument_list|(\nname|thread\nargument_list|)\noperator|&&\noperator|!",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|is_metairq (struct k_thread * thread)\n+DECL|function|thread_is_metairq (struct k_thread * thread)\n-name|is_metairq\n+name|thread_is_metairq\n-name|is_metairq\n+name|thread_is_metairq\n-name|is_metairq\n+name|thread_is_metairq\n-name|is_metairq\n+name|thread_is_metairq\n-name|is_metairq\n+name|thread_is_metairq\n-name|is_metairq\n+name|thread_is_metairq\nThe issue was with: kernel: thread: rename is_metairq\n\nTrivial rename of is_metairq to thread_is_metairq."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: rename sliceable -> thread_is_sliceable\n\nTrivial rename of sliceable function. Please fix this issue.",
  "input": "Faulty tokenized code:\nifdef|#\ndirective|ifdef\nname|CONFIG_TIMESLICING\nif|if\ncondition|(\nname|sliceable\nargument_list|(\nname|_current\nargument_list|)\ncondition|)\nblock|{\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|sliceable (struct k_thread * thread)\nname|bool\nname|sliceable\nparameter_list|(\nname|struct\nname|k_thread\nmodifier|*\nname|thread\noperator|=\nname|false\nexpr_stmt|;\nif|if\ncondition|(\nname|sliceable\nargument_list|(\nname|thread\nargument_list|)\ncondition|)\nblock|{\nname|_current_cpu\noperator|->\nname|id\nindex|]\noperator|&&\nname|sliceable\nargument_list|(\nname|curr\nargument_list|)\ncondition|)\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|sliceable\n+name|thread_is_sliceable\n-DECL|function|sliceable (struct k_thread * thread)\n+DECL|function|thread_is_sliceable (struct k_thread * thread)\n-name|sliceable\n+name|thread_is_sliceable\n-name|sliceable\n+name|thread_is_sliceable\n-name|sliceable\n+name|thread_is_sliceable\nThe issue was with: kernel: rename sliceable -> thread_is_sliceable\n\nTrivial rename of sliceable function."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: qdec_stm32: clang-format qdec_stm32.c\n\nRun clang-format on qdec_stm32.c.\n\nThis moves '\\' in macros to line index 100, which ensures '\\' still\naligns if a macro is edited with a new line that is longer than the\nprevious longest line. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|QDEC_STM32_INIT\nparameter_list|(\nname|n\nparameter_list|)\ndefine|\\\nvalue|PINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t\t\t\\ \tstatic const struct qdec_stm32_dev_cfg qdec##n##_stm32_config = {\t\t\\ \t\t.pin_config = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\t\\ \t\t.timer_inst = ((TIM_TypeDef *)DT_REG_ADDR(DT_INST_PARENT(n))),\t\t\\ \t\t.pclken = {\t\t\t\t\t\t\t\t\\ \t\t\t.bus = DT_CLOCKS_CELL(DT_INST_PARENT(n), bus),\t\t\t\\ \t\t\t.enr = DT_CLOCKS_CELL(DT_INST_PARENT(n), bits)\t\t\t\\ \t\t},\t\t\t\t\t\t\t\t\t\\ \t\t.is_input_polarity_inverted = DT_INST_PROP(n, st_input_polarity_inverted),\t\\ \t\t.input_filtering_level = DT_INST_PROP(n, st_input_filter_level),\t\t\\ \t\t.counts_per_revolution = DT_INST_PROP(n, st_counts_per_revolution),\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct qdec_stm32_dev_data qdec##n##_stm32_data;\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tSENSOR_DEVICE_DT_INST_DEFINE(n, qdec_stm32_initialize, NULL,\t\t\t\\&qdec##n##_stm32_data,&qdec##n##_stm32_config,\t\t\\ \t\t\t\tPOST_KERNEL, CONFIG_SENSOR_INIT_PRIORITY,\t\t\\&qdec_stm32_driver_api);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|PINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t\t\t\\ \tstatic const struct qdec_stm32_dev_cfg qdec##n##_stm32_config = {\t\t\\ \t\t.pin_config = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\t\\ \t\t.timer_inst = ((TIM_TypeDef *)DT_REG_ADDR(DT_INST_PARENT(n))),\t\t\\ \t\t.pclken = {\t\t\t\t\t\t\t\t\\ \t\t\t.bus = DT_CLOCKS_CELL(DT_INST_PARENT(n), bus),\t\t\t\\ \t\t\t.enr = DT_CLOCKS_CELL(DT_INST_PARENT(n), bits)\t\t\t\\ \t\t},\t\t\t\t\t\t\t\t\t\\ \t\t.is_input_polarity_inverted = DT_INST_PROP(n, st_input_polarity_inverted),\t\\ \t\t.input_filtering_level = DT_INST_PROP(n, st_input_filter_level),\t\t\\ \t\t.counts_per_revolution = DT_INST_PROP(n, st_counts_per_revolution),\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct qdec_stm32_dev_data qdec##n##_stm32_data;\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tSENSOR_DEVICE_DT_INST_DEFINE(n, qdec_stm32_initialize, NULL,\t\t\t\\&qdec##n##_stm32_data,&qdec##n##_stm32_config,\t\t\\ \t\t\t\tPOST_KERNEL, CONFIG_SENSOR_INIT_PRIORITY,\t\t\\&qdec_stm32_driver_api);\n+value|PINCTRL_DT_INST_DEFINE(n);                                                                 \\ \tstatic const struct qdec_stm32_dev_cfg qdec##n##_stm32_config = {                          \\ \t\t.pin_config = PINCTRL_DT_INST_DEV_CONFIG_GET(n),                                   \\ \t\t.timer_inst = ((TIM_TypeDef *)DT_REG_ADDR(DT_INST_PARENT(n))),                     \\ \t\t.pclken = {.bus = DT_CLOCKS_CELL(DT_INST_PARENT(n), bus),                          \\ \t\t\t   .enr = DT_CLOCKS_CELL(DT_INST_PARENT(n), bits)},                        \\ \t\t.is_input_polarity_inverted = DT_INST_PROP(n, st_input_polarity_inverted),         \\ \t\t.input_filtering_level = DT_INST_PROP(n, st_input_filter_level),                   \\ \t\t.counts_per_revolution = DT_INST_PROP(n, st_counts_per_revolution),                \\ \t};                                                                                         \\                                                                                                    \\ \tstatic struct qdec_stm32_dev_data qdec##n##_stm32_data;                                    \\                                                                                                    \\ \tSENSOR_DEVICE_DT_INST_DEFINE(n, qdec_stm32_initialize, NULL,&qdec##n##_stm32_data,        \\&qdec##n##_stm32_config, POST_KERNEL,                         \\ \t\t\t\t     CONFIG_SENSOR_INIT_PRIORITY,&qdec_stm32_driver_api);\nThe issue was with: drivers: sensor: qdec_stm32: clang-format qdec_stm32.c\n\nRun clang-format on qdec_stm32.c.\n\nThis moves '\\' in macros to line index 100, which ensures '\\' still\naligns if a macro is edited with a new line that is longer than the\nprevious longest line."
},{
  "instruction": "There is an issue in the following code. It relates to input: utils: rename the input dump callback\n\nChange the input callback function name to make it easier to identify\nwhat it belongs to. This clears some ambiguity when observing the symbol\nnames corresponding to the function pointers in the callback section. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/* CONFIG_INPUT_SHELL */\nend_comment\n\nbegin_function\nDECL|function|input_cb (struct input_event * evt)\nspecifier|static\nname|void\nname|input_cb\nparameter_list|(\nname|struct\nname|input_event\nmodifier|*\nname|evt\nbegin_expr_stmt\nname|INPUT_CALLBACK_DEFINE\nargument_list|(\nname|NULL\nargument_list|,\nname|input_cb\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_endif",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|input_cb (struct input_event * evt)\n+DECL|function|input_dump_cb (struct input_event * evt)\n-name|input_cb\n+name|input_dump_cb\n-name|input_cb\n+name|input_dump_cb\nThe issue was with: input: utils: rename the input dump callback\n\nChange the input callback function name to make it easier to identify\nwhat it belongs to. This clears some ambiguity when observing the symbol\nnames corresponding to the function pointers in the callback section."
},{
  "instruction": "There is an issue in the following code. It relates to fs: allow fs_mkfs() for FATFS without auto-format on mounting\n\nUsers should be able to call fs_mkfs() manually even if FS_FATFS_MOUNT_MKFS\nis disabled. Please fix this issue.",
  "input": "Faulty tokenized code:\n\t  reduce code size.\n\t  This option affects FF_FS_READONLY defined in ffconf.h, inside\n\t  ELM FAT module.\n\nconfig FS_FATFS_MKFS\n\tbool\n\thelp\n\t  Adds code for creating disks with FAT file system.\n\t  This option affects FF_USE_MKFS defined in ffconf.h, inside\n\t  ELM FAT module.\n\n\t  system, it may be worth disabling this option.\n\t  When this option is disabled, disk needs to be FAT formatted\n\t  prior to connecting to a device, otherwise it will not be\n\t  mountable.\n\nif FS_FATFS_MOUNT_MKFS\n\nconfig FS_FATFS_MAX_ROOT_ENTRIES\n\tint \"Max number of entries in FAT FS root directory\"\n\tdefault 512\n\trange 1 32768\n\thelp\n\t  Sets how many root directory entries will be allocated when\n\t  formatting new FAT system to a device.\n\t  Note that this should be multiply of FS_FATFS_MAX_SS / 32.\n\nendif # FS_FATFS_MOUNT_MKFS\n\nconfig FS_FATFS_EXFAT\n\tbool \"ExFAT support\"\n\tselect FS_FATFS_LFN\n\thelp\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_FILE_SYSTEM_MKFS\nargument_list|)\nend_if\n\nbegin_decl_stmt\nDECL|variable|def_cfg\nspecifier|static\nendif|#\ndirective|endif\nend_endif\n\nbegin_comment\ncomment|/* CONFIG_FILE_SYSTEM_MKFS */\nend_comment\n\nbegin_comment\ncomment|/* File system interface */\nend_comment\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_FILE_SYSTEM_MKFS\nargument_list|)\noperator|.\nname|mkfs\noperator|=\nname|fatfs_mkfs\nblock|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-\tbool\n+\tbool \"mkfs support for FAT FS\"\n+\tdefault y if FILE_SYSTEM_MKFS\n-if FS_FATFS_MOUNT_MKFS\n+if FS_FATFS_MKFS\n-endif # FS_FATFS_MOUNT_MKFS\n+endif # FS_FATFS_MKFS\n+operator|&&\n+name|defined\n+argument_list|(\n+name|CONFIG_FS_FATFS_MKFS\n+argument_list|)\n-comment|/* CONFIG_FILE_SYSTEM_MKFS */\n+comment|/* CONFIG_FILE_SYSTEM_MKFS&& FS_FATFS_MKFS */\n+operator|&&\n+name|defined\n+argument_list|(\n+name|CONFIG_FS_FATFS_MKFS\n+argument_list|)\nThe issue was with: fs: allow fs_mkfs() for FATFS without auto-format on mounting\n\nUsers should be able to call fs_mkfs() manually even if FS_FATFS_MOUNT_MKFS\nis disabled."
},{
  "instruction": "There is an issue in the following code. It relates to samples: ipc: openamp_rsc_table: Do not create null shared memory pool\n\nWe are always the remote client in this example. The shared pool is only\nused for allocating ring descriptors when we are the host. Do not create\na shared pool with a NULL base address, simply do no pass in a pool. Please fix this issue.",
  "input": "Faulty tokenized code:\nmodifier|*\nname|shm_io\ndecl_stmt|;\nend_decl_stmt\n\nbegin_decl_stmt\nDECL|variable|shpool\nspecifier|static\nname|struct\nname|rpmsg_virtio_shm_pool\nname|shpool\ndecl_stmt|;\nend_decl_stmt\n\nbegin_decl_stmt\nDECL|variable|rsc_io\nspecifier|static\nname|struct\nname|metal_io_region\nexpr_stmt|;\ngoto|goto\nname|failed\ngoto|;\nblock|}\nname|rpmsg_virtio_init_shm_pool\nargument_list|(\noperator|&\nname|shpool\nargument_list|,\nname|NULL\nargument_list|,\nname|SHM_SIZE\nargument_list|)\nexpr_stmt|;\nname|ret\noperator|=\nname|rpmsg_init_vdev\nargument_list|(\noperator|&\nargument_list|,\nname|ns_cb\nargument_list|,\nname|shm_io\nargument_list|,\noperator|&\nname|shpool\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|ret",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_decl_stmt\n-DECL|variable|shpool\n-specifier|static\n-name|struct\n-name|rpmsg_virtio_shm_pool\n-name|shpool\n-decl_stmt|;\n-end_decl_stmt\n-\n-name|rpmsg_virtio_init_shm_pool\n-argument_list|(\n-operator|&\n-name|shpool\n-argument_list|,\n-name|NULL\n-argument_list|,\n-name|SHM_SIZE\n-argument_list|)\n-expr_stmt|;\n-operator|&\n-name|shpool\n+name|NULL\nThe issue was with: samples: ipc: openamp_rsc_table: Do not create null shared memory pool\n\nWe are always the remote client in this example. The shared pool is only\nused for allocating ring descriptors when we are the host. Do not create\na shared pool with a NULL base address, simply do no pass in a pool."
},{
  "instruction": "There is an issue in the following code. It relates to intel_adsp: ace: Fix sparse error\n\nFixes the following errors when sparse (SCA) is enabled:\n\nsoc/intel/intel_adsp/ace/power.c:46:12: warning:\n    cast removes address space '__cache' of expression\n/soc/intel/intel_adsp/ace/power.c:48:9: warning:\n    incorrect type in argument 1 (different address spaces)\n\nFixes #70725 Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|if\nname|CONFIG_SOC_INTEL_ACE15_MTPM\noperator|*\noperator|(\noperator|(\nname|uint32_t\noperator|*\noperator|)\nname|sys_cache_cached_ptr_get\nargument_list|(\noperator|=\nname|INTEL_ADSP_ACE15_MAGIC_KEY\nexpr_stmt|;\nname|cache_data_flush_range\nargument_list|(\nname|sys_cache_cached_ptr_get\nargument_list|(\noperator|&\nname|adsp_pending_buffer\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|__sparse_force\n+operator|(\n+name|__sparse_force\n+name|void\n+operator|*\n+operator|)\nThe issue was with: intel_adsp: ace: Fix sparse error\n\nFixes the following errors when sparse (SCA) is enabled:\n\nsoc/intel/intel_adsp/ace/power.c:46:12: warning:\n    cast removes address space '__cache' of expression\n/soc/intel/intel_adsp/ace/power.c:48:9: warning:\n    incorrect type in argument 1 (different address spaces)\n\nFixes #70725"
},{
  "instruction": "There is an issue in the following code. It relates to Samples: Bluetooth: Fix PAwR sample failed to set subevent data\n\nBe respectful of PAwR subevents while scheduling scan activities.\nThe radio will be swtiched from scan to PAwR when it is closed to\nthe next subevent interval. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|num_synced\noperator|<\nname|MAX_SYNCS\ncondition|)\nblock|{\nname|err\noperator|=\nname|bt_le_scan_start\nargument_list|(\nname|BT_LE_SCAN_PASSIVE\nargument_list|,\nname|device_found\nargument_list|)\nexpr_stmt|;\nif|if",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Enable continuous scanning */\n-name|BT_LE_SCAN_PASSIVE\n+name|BT_LE_SCAN_PASSIVE_CONTINUOUS\nThe issue was with: Samples: Bluetooth: Fix PAwR sample failed to set subevent data\n\nBe respectful of PAwR subevents while scheduling scan activities.\nThe radio will be swtiched from scan to PAwR when it is closed to\nthe next subevent interval."
},{
  "instruction": "There is an issue in the following code. It relates to pm: runtime: fix race when waiting for suspended event\n\nTo wait for the asynchronous suspending work item to complete, a\ncombination of semaphores and events is used. First, the semaphore is\nreleased, then the events are cleared (through the boolean argument to\nk_event_wait), then events are awaited.\n\nHowever, if the event flag happens to be set by the work handler in the\nshort time between k_sem_give and k_event_wait, it is then cleared by\nk_event_wait and k_event_wait blocks forever waiting for the event.\n\nMake sure that we clear the event flag before releasing the semaphore. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|state\noperator|==\nname|PM_DEVICE_STATE_SUSPENDING\ncondition|)\nblock|{\nname|k_sem_give\nargument_list|(\noperator|&\nname|pm\noperator|->\noperator|->\nname|event\nargument_list|,\nname|EVENT_MASK\nargument_list|,\nname|true\nargument_list|,\nname|K_FOREVER\nargument_list|)\nexpr_stmt|;\noperator|(\nname|state\noperator|==\nname|PM_DEVICE_STATE_SUSPENDING\ncondition|)\nblock|{\nname|k_sem_give\nargument_list|(\noperator|&\nname|pm\noperator|->\noperator|->\nname|event\nargument_list|,\nname|EVENT_MASK\nargument_list|,\nname|true\nargument_list|,\nname|K_FOREVER\nargument_list|)\nexpr_stmt|;\noperator|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|k_event_clear\n+argument_list|(\n+operator|&\n+name|pm\n+operator|->\n+name|event\n+argument_list|,\n+name|EVENT_MASK\n+argument_list|)\n+expr_stmt|;\n-name|true\n+name|false\n+name|k_event_clear\n+argument_list|(\n+operator|&\n+name|pm\n+operator|->\n+name|event\n+argument_list|,\n+name|EVENT_MASK\n+argument_list|)\n+expr_stmt|;\n-name|true\n+name|false\nThe issue was with: pm: runtime: fix race when waiting for suspended event\n\nTo wait for the asynchronous suspending work item to complete, a\ncombination of semaphores and events is used. First, the semaphore is\nreleased, then the events are cleared (through the boolean argument to\nk_event_wait), then events are awaited.\n\nHowever, if the event flag happens to be set by the work handler in the\nshort time between k_sem_give and k_event_wait, it is then cleared by\nk_event_wait and k_event_wait blocks forever waiting for the event.\n\nMake sure that we clear the event flag before releasing the semaphore."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: iis2dlpc: fix typo in function name\n\niis2dlpc, not ii2sdlpc. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|ifdef\nname|CONFIG_IIS2DLPC_ACTIVITY\nend_ifdef\n\nbegin_function\nDECL|function|ii2sdlpc_set_slope_th (const struct device * dev,uint16_t th)\nspecifier|static\nname|int\nname|ii2sdlpc_set_slope_th\nparameter_list|(\nspecifier|const\nname|struct\nname|device\nmodifier|*\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|ii2sdlpc_set_slope_dur (const struct device * dev,uint16_t dur)\nspecifier|static\nname|int\nname|ii2sdlpc_set_slope_dur\nparameter_list|(\nspecifier|const\nname|struct\nname|device\nmodifier|*\nname|CONFIG_IIS2DLPC_ACTIVITY\ncase|case\nname|SENSOR_ATTR_SLOPE_TH\ncase|:\nreturn|return\nname|ii2sdlpc_set_slope_th\nargument_list|(\nname|dev\nargument_list|,\nname|val\noperator|->\nreturn|;\ncase|case\nname|SENSOR_ATTR_SLOPE_DUR\ncase|:\nreturn|return\nname|ii2sdlpc_set_slope_dur\nargument_list|(\nname|dev\nargument_list|,\nname|val\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|ii2sdlpc_set_slope_th (const struct device * dev,uint16_t th)\n+DECL|function|iis2dlpc_set_slope_th (const struct device * dev,uint16_t th)\n-name|ii2sdlpc_set_slope_th\n+name|iis2dlpc_set_slope_th\n-DECL|function|ii2sdlpc_set_slope_dur (const struct device * dev,uint16_t dur)\n+DECL|function|iis2dlpc_set_slope_dur (const struct device * dev,uint16_t dur)\n-name|ii2sdlpc_set_slope_dur\n+name|iis2dlpc_set_slope_dur\n-name|ii2sdlpc_set_slope_th\n+name|iis2dlpc_set_slope_th\n-name|ii2sdlpc_set_slope_dur\n+name|iis2dlpc_set_slope_dur\nThe issue was with: drivers: iis2dlpc: fix typo in function name\n\niis2dlpc, not ii2sdlpc."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: iis2dlpc: fix typo in log message\n\nProbably copy-pasted from another line. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nliteral|\"Could not set WK_THS to 0x%02X, error %d\"\nargument_list|,\nname|th\noperator|&\nliteral|0x03\nargument_list|,\nname|err\nargument_list|)\nexpr_stmt|;\nreturn|return",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|0x03\n+literal|0x3F\nThe issue was with: drivers: iis2dlpc: fix typo in log message\n\nProbably copy-pasted from another line."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: dma_mcux_lpc: Fix omitted interrupt config\n\nAdd the invocation of an interrupt config function\n(config->irq_config_func). Absence of this call results in the DMA\ndriver not being able to service interrupts raised by the DMA\nperipheral.\n\nThis case was observed on the i.MX RT685's HiFi 4 DSP domain, where DMA\nwas not functional because of this. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|INPUTMUX_Init\nargument_list|(\nname|INPUTMUX\nargument_list|)\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|config\n+operator|->\n+name|irq_config_func\n+argument_list|(\n+name|dev\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: dma_mcux_lpc: Fix omitted interrupt config\n\nAdd the invocation of an interrupt config function\n(config->irq_config_func). Absence of this call results in the DMA\ndriver not being able to service interrupts raised by the DMA\nperipheral.\n\nThis case was observed on the i.MX RT685's HiFi 4 DSP domain, where DMA\nwas not functional because of this."
},{
  "instruction": "There is an issue in the following code. It relates to net: wifi: Fix the Wi-Fi state check\n\nOnce Wi-Fi is associated few parameters like listen interval and\npower-save mode cannot be changed. The state for association is\n\\\"ASSOCIATED\\\" and not completed. Even after state transitions to\nCOMPLETE, it can still go back to other states, e.g., PTK/GTK renewal.\n\nFix the state check. Please fix this issue.",
  "input": "Faulty tokenized code:\nif|if\ncondition|(\nname|info\noperator|.\nname|state\noperator|==\nname|WIFI_STATE_COMPLETED\ncondition|)\nblock|{\nname|ps_params\noperator|->\nname|fail_reason",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|==\n-name|WIFI_STATE_COMPLETED\n+operator|>=\n+name|WIFI_STATE_ASSOCIATED\nThe issue was with: net: wifi: Fix the Wi-Fi state check\n\nOnce Wi-Fi is associated few parameters like listen interval and\npower-save mode cannot be changed. The state for association is\n\\\"ASSOCIATED\\\" and not completed. Even after state transitions to\nCOMPLETE, it can still go back to other states, e.g., PTK/GTK renewal.\n\nFix the state check."
},{
  "instruction": "There is an issue in the following code. It relates to soc: nordic: vpr: finish pending transactions before calling `wfi`\n\nTo minimize time the CPU spends when preparing for sleep, make sure\nthe pending transactions are finished before calling `wfi`. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/irq.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/tracing/tracing.h>\nend_include\nparameter_list|)\nblock|{\nname|sys_trace_idle\nargument_list|()\nexpr_stmt|;\nname|irq_unlock\nargument_list|(\nname|MSTATUS_IEN\nargument_list|)\nexpr_stmt|;\nparameter_list|)\nblock|{\nname|sys_trace_idle\nargument_list|()\nexpr_stmt|;\nname|irq_unlock\nargument_list|(\nname|MSTATUS_IEN\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/sys/barrier.h>\n+end_include\n+\n+name|barrier_dsync_fence_full\n+argument_list|()\n+expr_stmt|;\n+name|barrier_dsync_fence_full\n+argument_list|()\n+expr_stmt|;\nThe issue was with: soc: nordic: vpr: finish pending transactions before calling `wfi`\n\nTo minimize time the CPU spends when preparing for sleep, make sure\nthe pending transactions are finished before calling `wfi`."
},{
  "instruction": "There is an issue in the following code. It relates to tests: net: vlan: Fix the socket API usage\n\nThe tests should use zsock_ APIs after the commit\n15462fb5a45b114952511859624807531ede1154 [formerly 0512e7ffaead7eeb2d3599cc71e439180e221e4a] Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|\"Cannot add neighbor\"\nargument_list|)\nexpr_stmt|;\nname|ret\noperator|=\nname|bind\nargument_list|(\nname|server_sock\nargument_list|,\noperator|(\nexpr|struct\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|ret\noperator|=\nname|close\nargument_list|(\nname|client_sock\nargument_list|)\nexpr_stmt|;\nname|zassert_equal\nliteral|\"close failed\"\nargument_list|)\nexpr_stmt|;\nname|ret\noperator|=\nname|close\nargument_list|(\nname|server_sock\nargument_list|)\nexpr_stmt|;\nname|zassert_equal",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|bind\n+name|zsock_bind\n-name|close\n+name|zsock_close\n-name|close\n+name|zsock_close\nThe issue was with: tests: net: vlan: Fix the socket API usage\n\nThe tests should use zsock_ APIs after the commit\n15462fb5a45b114952511859624807531ede1154 [formerly 0512e7ffaead7eeb2d3599cc71e439180e221e4a]"
},{
  "instruction": "There is an issue in the following code. It relates to random: Rename source files\n\ns/rand32/random. Please fix this issue.",
  "input": "Faulty tokenized code:\nif (CONFIG_ENTROPY_DEVICE_RANDOM_GENERATOR OR\n    CONFIG_TIMER_RANDOM_GENERATOR OR\n    CONFIG_XOSHIRO_RANDOM_GENERATOR)\nzephyr_syscall_header(${ZEPHYR_BASE}/include/zephyr/random/random.h)\nzephyr_library()\nzephyr_library_sources_ifdef(CONFIG_USERSPACE           rand32_handlers.c)\nendif()\n\nif (CONFIG_TIMER_RANDOM_GENERATOR)\n  message(WARNING \"\n    Warning: CONFIG_TIMER_RANDOM_GENERATOR is not a truly random generator.\n    This capability is not secure and it is provided for testing purposes only.\n    Use it carefully.\")\nendif()\n\nzephyr_library_sources_ifdef(CONFIG_TIMER_RANDOM_GENERATOR          rand32_timer.c)\nzephyr_library_sources_ifdef(CONFIG_XOSHIRO_RANDOM_GENERATOR        rand32_xoshiro128.c)\nzephyr_library_sources_ifdef(CONFIG_CTR_DRBG_CSPRNG_GENERATOR       rand32_ctr_drbg.c)\n\nif (CONFIG_ENTROPY_DEVICE_RANDOM_GENERATOR OR CONFIG_HARDWARE_DEVICE_CS_GENERATOR)\nzephyr_library_sources(rand32_entropy_device.c)\nendif()\n\nif (CONFIG_CTR_DRBG_CSPRNG_GENERATOR)\nzephyr_library_link_libraries_ifdef(CONFIG_MBEDTLS mbedTLS)\nendif()\nsimilarity index 100%\nrename from subsys/random/rand32_ctr_drbg.c\nrename to subsys/random/random_ctr_drbg.c\nsimilarity index 100%\nrename from subsys/random/rand32_entropy_device.c\nrename to subsys/random/random_entropy_device.c\nsimilarity index 100%\nrename from subsys/random/rand32_handlers.c\nrename to subsys/random/random_handlers.c\nsimilarity index 100%\nrename from subsys/random/rand32_timer.c\nrename to subsys/random/random_timer.c\nsimilarity index 100%\nrename from subsys/random/rand32_xoshiro128.c\nrename to subsys/random/random_xoshiro128.c",
  "result": "I corrected the issue in the code by changing the following tokens:\n-zephyr_library_sources_ifdef(CONFIG_USERSPACE           rand32_handlers.c)\n+zephyr_library_sources_ifdef(CONFIG_USERSPACE           random_handlers.c)\n-zephyr_library_sources_ifdef(CONFIG_TIMER_RANDOM_GENERATOR          rand32_timer.c)\n-zephyr_library_sources_ifdef(CONFIG_XOSHIRO_RANDOM_GENERATOR        rand32_xoshiro128.c)\n-zephyr_library_sources_ifdef(CONFIG_CTR_DRBG_CSPRNG_GENERATOR       rand32_ctr_drbg.c)\n+zephyr_library_sources_ifdef(CONFIG_TIMER_RANDOM_GENERATOR          random_timer.c)\n+zephyr_library_sources_ifdef(CONFIG_XOSHIRO_RANDOM_GENERATOR        random_xoshiro128.c)\n+zephyr_library_sources_ifdef(CONFIG_CTR_DRBG_CSPRNG_GENERATOR       random_ctr_drbg.c)\n-zephyr_library_sources(rand32_entropy_device.c)\n+zephyr_library_sources(random_entropy_device.c)\nThe issue was with: random: Rename source files\n\ns/rand32/random."
},{
  "instruction": "There is an issue in the following code. It relates to net: shell: Print multicast join status for iface cmd\n\nPrint information whether a multicast address is properly\njoined to a multicast group when print addresses using\n\\\"net iface\\\" command. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\ncontinue|continue;\nblock|}\nname|PR\nargument_list|(\nliteral|\"\\t%s\\n\"\nargument_list|,\nname|net_sprint_ipv6_addr\nargument_list|(\noperator|&\nname|mcast\noperator|->\nname|address\noperator|.\nname|in6_addr\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|count\noperator|++\nexpr_stmt|;\nblock|{\ncontinue|continue;\nblock|}\nname|PR\nargument_list|(\nliteral|\"\\t%s\\n\"\nargument_list|,\nname|net_sprint_ipv4_addr\nargument_list|(\noperator|&\nname|mcast\noperator|->\nname|address\noperator|.\nname|in_addr\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|count\noperator|++\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"\\t%s\\n\"\n+literal|\"\\t%s%s\\n\"\n+argument_list|,\n+name|net_if_ipv6_maddr_is_joined\n+argument_list|(\n+name|mcast\n+argument_list|)\n+condition|?\n+literal|\"\"\n+else|:\n+literal|\"<not joined>\"\n-literal|\"\\t%s\\n\"\n+literal|\"\\t%s%s\\n\"\n+argument_list|,\n+name|net_if_ipv4_maddr_is_joined\n+argument_list|(\n+name|mcast\n+argument_list|)\n+condition|?\n+literal|\"\"\n+else|:\n+literal|\"<not joined>\"\nThe issue was with: net: shell: Print multicast join status for iface cmd\n\nPrint information whether a multicast address is properly\njoined to a multicast group when print addresses using\n\\\"net iface\\\" command."
},{
  "instruction": "There is an issue in the following code. It relates to net: virtual: Do not try to send data if interface is down\n\nMake sure the interface is up before trying to send data to\nlower level interface. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ENOENT\nreturn|;\nblock|}\nif|if\ncondition|(\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_NET_STATISTICS\nargument_list|)\ncondition|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|!\n+name|net_if_is_up\n+argument_list|(\n+name|iface\n+argument_list|)\n+condition|)\n+block|{\n+name|NET_DBG\n+argument_list|(\n+literal|\"Interface %d is down.\"\n+argument_list|,\n+name|net_if_get_by_iface\n+argument_list|(\n+name|iface\n+argument_list|)\n+argument_list|)\n+expr_stmt|;\n+return|return\n+operator|-\n+name|ENETDOWN\n+return|;\n+block|}\n+if|if\n+condition|(\nThe issue was with: net: virtual: Do not try to send data if interface is down\n\nMake sure the interface is up before trying to send data to\nlower level interface."
},{
  "instruction": "There is an issue in the following code. It relates to net: virtual: Force LAA bit for link address\n\nMake sure LAA (locally administred address) bit is set for the\ngenerated link address. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|=\nname|sys_rand32_get\nargument_list|()\nexpr_stmt|;\nblock|}\nblock|}\nend_function\n\nbegin_function\nDECL|function|net_virtual_interface_attach (struct net_if * virtual_iface,struct net_if * iface)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|linkaddr\n+index|[\n+literal|0\n+index|]\n+operator||=\n+literal|0x02\n+expr_stmt|;\n+comment|/* force LAA bit */\nThe issue was with: net: virtual: Force LAA bit for link address\n\nMake sure LAA (locally administred address) bit is set for the\ngenerated link address."
},{
  "instruction": "There is an issue in the following code. It relates to net: if: We can only rejoin mcast groups for native IP stack\n\nNo point trying to join multicast groups if the network interface\nis offloaded one. Please fix this issue.",
  "input": "Faulty tokenized code:\nendif|#\ndirective|endif\nend_endif\n\nbegin_struct\nDECL|struct|__anon2be1910a0108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|ipv6\nname|struct\nname|CONFIG_NET_NATIVE_IPV4\nargument_list|)\nend_if\n\nbegin_struct\nDECL|struct|__anon2be1910a0208\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|ipv4\nname|struct\nname|update_operational_state\nargument_list|(\nname|iface\nargument_list|)\nexpr_stmt|;\ncomment|/* Make sure that we update the IPv6 addresses and join the \t * multicast groups. \t */\nname|rejoin_multicast_groups\nargument_list|(\nname|iface\nargument_list|)\nexpr_stmt|;\nname|net_if_start_dad\nargument_list|(\nname|iface\nargument_list|)\nexpr_stmt|;\nname|out\nlabel|:\nname|net_if_unlock\nargument_list|(\nname|iface",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2be1910a0108\n+DECL|struct|__anon2a07e7370108\n-DECL|struct|__anon2be1910a0208\n+DECL|struct|__anon2a07e7370208\n-comment|/* Make sure that we update the IPv6 addresses and join the \t * multicast groups. \t */\n+if|if\n+condition|(\n+operator|!\n+name|net_if_is_offloaded\n+argument_list|(\n+name|iface\n+argument_list|)\n+condition|)\n+block|{\n+comment|/* Make sure that we update the IPv6 addresses and join the \t\t * multicast groups. \t\t */\n+block|}\nThe issue was with: net: if: We can only rejoin mcast groups for native IP stack\n\nNo point trying to join multicast groups if the network interface\nis offloaded one."
},{
  "instruction": "There is an issue in the following code. It relates to net: if: Add debug print when interface is taken up\n\nAdd debug information to print when the network L2 enable\ncallback is called and fails. Useful to see this information\nas at that point the interface goes down. Please fix this issue.",
  "input": "Faulty tokenized code:\nendif|#\ndirective|endif\nend_endif\n\nbegin_struct\nDECL|struct|__anon2a0d8d950108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|ipv6\nname|struct\nname|CONFIG_NET_NATIVE_IPV4\nargument_list|)\nend_if\n\nbegin_struct\nDECL|struct|__anon2a0d8d950208\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|ipv4\nname|struct\ngoto|goto\nname|out\ngoto|;\nblock|}\nblock|}\ncomment|/* Notify L2 to enable the interface */\nname|status\noperator|=\nname|net_if_l2\nargument_list|(\nname|iface\nname|status\noperator|<\nliteral|0\ncondition|)\nblock|{\ngoto|goto\nname|out\ngoto|;\nblock|}\nname|init_igmp",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2a0d8d950108\n+DECL|struct|__anon2a1f58040108\n-DECL|struct|__anon2a0d8d950208\n+DECL|struct|__anon2a1f58040208\n-comment|/* Notify L2 to enable the interface */\n+comment|/* Notify L2 to enable the interface. Note that the interface is still down \t * at this point from network interface point of view i.e., the NET_IF_UP \t * flag has not been set yet. \t */\n+name|NET_DBG\n+argument_list|(\n+literal|\"Cannot take interface %d up (%d)\"\n+argument_list|,\n+name|net_if_get_by_iface\n+argument_list|(\n+name|iface\n+argument_list|)\n+argument_list|,\n+name|status\n+argument_list|)\n+expr_stmt|;\nThe issue was with: net: if: Add debug print when interface is taken up\n\nAdd debug information to print when the network L2 enable\ncallback is called and fails. Useful to see this information\nas at that point the interface goes down."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: align kernel stack size declaration\n\nWhen kernel stack is defined as an array, K_KERNEL_STACK_LEN()\nis used to calculate the size for each stack in the array.\nHowever, standalone kernel stack has its size calculated by\nZ_KERNEL_STACK_SIZE_ADJUST() instead. Depending on the arch\nalignment requirement, they may not be the same... which\ncould cause some confusions. So align them both to use\nK_KERNEL_STACK_LEN(). Please fix this issue.",
  "input": "Faulty tokenized code:\nname|z_interrupt_stacks\nindex|[\nliteral|0\nindex|]\noperator|+\nname|Z_KERNEL_STACK_SIZE_ADJUST\nargument_list|(\nname|CONFIG_ISR_STACK_SIZE\nargument_list|)\nblock|,\noperator|.\nname|stack_size\noperator|=\nname|Z_KERNEL_STACK_SIZE_ADJUST\nargument_list|(\nname|CONFIG_ISR_STACK_SIZE\nargument_list|)\nblock|,\noperator|.\nname|sym\nparameter_list|,\nname|size\nparameter_list|)\ndefine|\\\nvalue|extern struct z_thread_stack_element \\ \t\tsym[Z_KERNEL_STACK_SIZE_ADJUST(size)]\ncomment|/**  * @brief Declare a reference to a thread stack array  *  * This macro declares the symbol of a thread stack array defined elsewhere in  * the current scope.  *  * @param sym Thread stack symbol name  * @param nmemb Number of stacks defined  * @param size Size of the stack memory region  */\nDECL|macro|K_KERNEL_STACK_ARRAY_DECLARE (sym,nmemb,size)\ndefine|#\ndirective|define\nname|K_KERNEL_STACK_ARRAY_DECLARE\nname|size\nparameter_list|,\nname|lsect\nparameter_list|)\ndefine|\\\nvalue|struct z_thread_stack_element lsect \\ \t\t__aligned(Z_KERNEL_STACK_OBJ_ALIGN) \\ \t\tsym[Z_KERNEL_STACK_SIZE_ADJUST(size)]\ncomment|/**  * @brief Define a toplevel array of kernel stack memory regions in specified section  *  * @param sym Kernel stack array symbol name  * @param nmemb Number of stacks to define  * @param size Size of the stack memory region  * @param lsect Linker section for this array of stacks  */\nDECL|macro|Z_KERNEL_STACK_ARRAY_DEFINE_IN (sym,nmemb,size,lsect)\ndefine|#\ndirective|define\nname|Z_KERNEL_STACK_ARRAY_DEFINE_IN\ncomment|/* The minimum allowable stack size */\nDECL|macro|PTHREAD_STACK_MIN\ndefine|#\ndirective|define\nname|PTHREAD_STACK_MIN\nvalue|Z_KERNEL_STACK_SIZE_ADJUST(0)\ncomment|/**  * @brief Declare a condition variable as initialized  *  * Initialize a condition variable with the default condition variable attributes.  */\nDECL|macro|PTHREAD_COND_INITIALIZER\ndefine|#\ndirective|define\nname|PTHREAD_COND_INITIALIZER\nreturn|return\nname|z_thread_stack_alloc_dyn\nargument_list|(\nname|Z_KERNEL_STACK_OBJ_ALIGN\nargument_list|,\nname|Z_KERNEL_STACK_SIZE_ADJUST\nargument_list|(\nname|size\nargument_list|)\nargument_list|)\nreturn|;\noperator|->\nname|base\noperator|.\nname|thread_state\ndecl_stmt|;\nDECL|struct|__anon2a3da3a40108\nspecifier|static\nspecifier|const\nstruct|struct\nblock|{\nDECL|member|str\ncomment|/* CONFIG_USERSPACE */\nblock|{\ncomment|/* Object cannot host a user mode thread */\nname|stack_obj_size\noperator|=\nname|Z_KERNEL_STACK_SIZE_ADJUST\nargument_list|(\nname|stack_size\nargument_list|)\nexpr_stmt|;\nname|stack_buf_start\noperator|=\nname|k_aligned_alloc\nargument_list|(\nname|Z_KERNEL_STACK_OBJ_ALIGN\nargument_list|,\nname|Z_KERNEL_STACK_SIZE_ADJUST\nargument_list|(\nname|stack_size\nargument_list|)\nargument_list|)\nexpr_stmt|;\nbegin_define\nDECL|macro|STACK_OBJ_SIZE\ndefine|#\ndirective|define\nname|STACK_OBJ_SIZE\nvalue|Z_KERNEL_STACK_SIZE_ADJUST(CONFIG_DYNAMIC_THREAD_STACK_SIZE)\nend_define\n\nbegin_endif\nendif|#\ndirective|endif\nname|scenario_data\noperator|.\nname|is_array\ncondition|)\nblock|{\ncomment|/* These should be exactly the same. We have an equivalence relation: \t\t * For some stack declared with: \t\t * \t\t * K_THREAD_STACK_DEFINE(my_stack, X); \t\t * Z_THREAD_STACK_SIZE_ADJUST(X) - K_THREAD_STACK_RESERVED == \t\t * \tK_THREAD_STACK_SIZEOF(my_stack) \t\t * \t\t * K_KERNEL_STACK_DEFINE(my_kern_stack, Y): \t\t * Z_KERNEL_STACK_SIZE_ADJUST(Y) - K_KERNEL_STACK_RESERVED == \t\t *\tK_KERNEL_STACK_SIZEOF(my_stack) \t\t */\nifdef|#\ndirective|ifdef\nname|CONFIG_USERSPACE\ncomment|/* Not defined if user mode disabled, all stacks are kernel stacks */\nif|if\nendif|#\ndirective|endif\nblock|{\nname|adjusted\noperator|=\nname|Z_KERNEL_STACK_SIZE_ADJUST\nargument_list|(\nname|scenario_data\noperator|.\nname|declared_size\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|Z_KERNEL_STACK_SIZE_ADJUST\n+name|K_KERNEL_STACK_LEN\n-name|Z_KERNEL_STACK_SIZE_ADJUST\n+name|K_KERNEL_STACK_LEN\n-value|extern struct z_thread_stack_element \\ \t\tsym[Z_KERNEL_STACK_SIZE_ADJUST(size)]\n+value|extern struct z_thread_stack_element \\ \t\tsym[K_KERNEL_STACK_LEN(size)]\n-value|struct z_thread_stack_element lsect \\ \t\t__aligned(Z_KERNEL_STACK_OBJ_ALIGN) \\ \t\tsym[Z_KERNEL_STACK_SIZE_ADJUST(size)]\n+value|struct z_thread_stack_element lsect \\ \t\t__aligned(Z_KERNEL_STACK_OBJ_ALIGN) \\ \t\tsym[K_KERNEL_STACK_LEN(size)]\n-value|Z_KERNEL_STACK_SIZE_ADJUST(0)\n+value|K_KERNEL_STACK_LEN(0)\n-name|Z_KERNEL_STACK_SIZE_ADJUST\n+name|K_KERNEL_STACK_LEN\n-DECL|struct|__anon2a3da3a40108\n+DECL|struct|__anon289279a30108\n-name|Z_KERNEL_STACK_SIZE_ADJUST\n+name|K_KERNEL_STACK_LEN\n-name|Z_KERNEL_STACK_SIZE_ADJUST\n+name|K_KERNEL_STACK_LEN\n-value|Z_KERNEL_STACK_SIZE_ADJUST(CONFIG_DYNAMIC_THREAD_STACK_SIZE)\n+value|K_KERNEL_STACK_LEN(CONFIG_DYNAMIC_THREAD_STACK_SIZE)\n-comment|/* These should be exactly the same. We have an equivalence relation: \t\t * For some stack declared with: \t\t * \t\t * K_THREAD_STACK_DEFINE(my_stack, X); \t\t * Z_THREAD_STACK_SIZE_ADJUST(X) - K_THREAD_STACK_RESERVED == \t\t * \tK_THREAD_STACK_SIZEOF(my_stack) \t\t * \t\t * K_KERNEL_STACK_DEFINE(my_kern_stack, Y): \t\t * Z_KERNEL_STACK_SIZE_ADJUST(Y) - K_KERNEL_STACK_RESERVED == \t\t *\tK_KERNEL_STACK_SIZEOF(my_stack) \t\t */\n+comment|/* These should be exactly the same. We have an equivalence relation: \t\t * For some stack declared with: \t\t * \t\t * K_THREAD_STACK_DEFINE(my_stack, X); \t\t * Z_THREAD_STACK_SIZE_ADJUST(X) - K_THREAD_STACK_RESERVED == \t\t * \tK_THREAD_STACK_SIZEOF(my_stack) \t\t * \t\t * K_KERNEL_STACK_DEFINE(my_kern_stack, Y): \t\t * K_KERNEL_STACK_LEN(Y) - K_KERNEL_STACK_RESERVED == \t\t *\tK_KERNEL_STACK_SIZEOF(my_stack) \t\t */\n-name|Z_KERNEL_STACK_SIZE_ADJUST\n+name|K_KERNEL_STACK_LEN\nThe issue was with: kernel: align kernel stack size declaration\n\nWhen kernel stack is defined as an array, K_KERNEL_STACK_LEN()\nis used to calculate the size for each stack in the array.\nHowever, standalone kernel stack has its size calculated by\nZ_KERNEL_STACK_SIZE_ADJUST() instead. Depending on the arch\nalignment requirement, they may not be the same... which\ncould cause some confusions. So align them both to use\nK_KERNEL_STACK_LEN()."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: rename Z_KERNEL_STACK_LEN to K_KERNEL_STACK_LEN\n\nSince there is a K_THREAD_STACK_LEN, its kernel counterpart\nshould also be prefixed with K_ for consistency. Please fix this issue.",
  "input": "Faulty tokenized code:\ncomment|/* !CONFIG_MPU_STACK_GUARD */\ncomment|/* Userspace enabled, but supervisor stack guards are not in use */\nifdef|#\ndirective|ifdef\nname|CONFIG_MPU_REQUIRES_POWER_OF_TWO_ALIGNMENT\ncomment|/* Use defaults for everything. The privilege elevation stack is located  * in another area of memory generated at build time by gen_kobject_list.py  *  * +------------+<- thread.arch.priv_stack_start  * | Priv Stack | } Z_KERNEL_STACK_LEN(CONFIG_PRIVILEGED_STACK_SIZE)  * +------------+  *  * +------------+<- thread.stack_obj = thread.stack_info.start  * | Thread     |  * | stack      |  * |            |  * +............|  * | TLS        | } thread.stack_info.delta  * +------------+<- thread.stack_info.start + thread.stack_info.size  */\nDECL|macro|ARCH_THREAD_STACK_SIZE_ADJUST (size)\ndefine|#\ndirective|define\nname|ARCH_THREAD_STACK_SIZE_ADJUST\nparameter_list|(\nname|Z_KERNEL_STACK_OBJ_ALIGN\nvalue|ARCH_STACK_PTR_ALIGN\nendif|#\ndirective|endif\ncomment|/* ARCH_KERNEL_STACK_OBJ_ALIGN */\nDECL|macro|Z_KERNEL_STACK_LEN (size)\ndefine|#\ndirective|define\nname|Z_KERNEL_STACK_LEN\nparameter_list|(\nname|size\nparameter_list|)\ndefine|\\\nvalue|ROUND_UP(Z_KERNEL_STACK_SIZE_ADJUST(size), Z_KERNEL_STACK_OBJ_ALIGN)\nname|nmemb\nparameter_list|,\nname|size\nparameter_list|)\ndefine|\\\nvalue|extern struct z_thread_stack_element \\ \t\tsym[nmemb][Z_KERNEL_STACK_LEN(size)]\ncomment|/**  * @brief Declare a reference to a pinned thread stack array  *  * This macro declares the symbol of a pinned thread stack array defined  * elsewhere in the current scope.  *  * @param sym Thread stack symbol name  * @param nmemb Number of stacks defined  * @param size Size of the stack memory region  */\nDECL|macro|K_KERNEL_PINNED_STACK_ARRAY_DECLARE (sym,nmemb,size)\ndefine|#\ndirective|define\nname|K_KERNEL_PINNED_STACK_ARRAY_DECLARE\nname|nmemb\nparameter_list|,\nname|size\nparameter_list|)\ndefine|\\\nvalue|extern struct z_thread_stack_element \\ \t\tsym[nmemb][Z_KERNEL_STACK_LEN(size)]\ncomment|/**  * @brief Define a toplevel kernel stack memory region in specified section  *  * This defines a region of memory for use as a thread stack in  * the specified linker section.  *  * It is legal to precede this definition with the 'static' keyword.  *  * It is NOT legal to take the sizeof(sym) and pass that to the stackSize  * parameter of k_thread_create(), it may not be the same as the  * 'size' parameter. Use K_KERNEL_STACK_SIZEOF() instead.  *  * The total amount of memory allocated may be increased to accommodate  * fixed-size stack overflow guards.  *  * @param sym Thread stack symbol name  * @param size Size of the stack memory region  * @param lsect Linker section for this stack  */\nDECL|macro|Z_KERNEL_STACK_DEFINE_IN (sym,size,lsect)\ndefine|#\ndirective|define\nname|Z_KERNEL_STACK_DEFINE_IN\nname|size\nparameter_list|,\nname|lsect\nparameter_list|)\ndefine|\\\nvalue|struct z_thread_stack_element lsect \\ \t\t__aligned(Z_KERNEL_STACK_OBJ_ALIGN) \\ \t\tsym[nmemb][Z_KERNEL_STACK_LEN(size)]\ncomment|/**  * @brief Define a toplevel kernel stack memory region  *  * This defines a region of memory for use as a thread stack, for threads  * that exclusively run in supervisor mode. This is also suitable for  * declaring special stacks for interrupt or exception handling.  *  * Stacks defined with this macro may not host user mode threads.  *  * It is legal to precede this definition with the 'static' keyword.  *  * It is NOT legal to take the sizeof(sym) and pass that to the stackSize  * parameter of k_thread_create(), it may not be the same as the  * 'size' parameter. Use K_KERNEL_STACK_SIZEOF() instead.  *  * The total amount of memory allocated may be increased to accommodate  * fixed-size stack overflow guards.  *  * @param sym Thread stack symbol name  * @param size Size of the stack memory region  */\nDECL|macro|K_KERNEL_STACK_DEFINE (sym,size)\ndefine|#\ndirective|define\nname|K_KERNEL_STACK_DEFINE\nvalue|K_KERNEL_STACK_SIZEOF\nDECL|macro|K_THREAD_STACK_LEN\ndefine|#\ndirective|define\nname|K_THREAD_STACK_LEN\nvalue|Z_KERNEL_STACK_LEN\nDECL|macro|K_THREAD_STACK_DEFINE\ndefine|#\ndirective|define\nname|K_THREAD_STACK_DEFINE\nvalue|K_KERNEL_STACK_DEFINE\n        if stack_counter != 0:\n            # Same as K_KERNEL_STACK_ARRAY_DEFINE, but routed to a different\n            # memory section.\n            fp.write(\"static uint8_t Z_GENERIC_SECTION(.priv_stacks.noinit) \"\n                     \" __aligned(Z_KERNEL_STACK_OBJ_ALIGN)\"\n                    \" priv_stacks[%d][Z_KERNEL_STACK_LEN(CONFIG_PRIVILEGED_STACK_SIZE)];\\n\"\n                     % stack_counter)\n\n            fp.write(\"static const struct z_stack_data stack_data[%d] = {\\n\"\n                     % stack_counter)\n            counter = 0\nblock|}\nelse|else\nblock|{\nname|adjusted\noperator|=\nname|Z_KERNEL_STACK_LEN\nargument_list|(\nname|scenario_data\noperator|.\nname|declared_size\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* Use defaults for everything. The privilege elevation stack is located  * in another area of memory generated at build time by gen_kobject_list.py  *  * +------------+<- thread.arch.priv_stack_start  * | Priv Stack | } Z_KERNEL_STACK_LEN(CONFIG_PRIVILEGED_STACK_SIZE)  * +------------+  *  * +------------+<- thread.stack_obj = thread.stack_info.start  * | Thread     |  * | stack      |  * |            |  * +............|  * | TLS        | } thread.stack_info.delta  * +------------+<- thread.stack_info.start + thread.stack_info.size  */\n+comment|/* Use defaults for everything. The privilege elevation stack is located  * in another area of memory generated at build time by gen_kobject_list.py  *  * +------------+<- thread.arch.priv_stack_start  * | Priv Stack | } K_KERNEL_STACK_LEN(CONFIG_PRIVILEGED_STACK_SIZE)  * +------------+  *  * +------------+<- thread.stack_obj = thread.stack_info.start  * | Thread     |  * | stack      |  * |            |  * +............|  * | TLS        | } thread.stack_info.delta  * +------------+<- thread.stack_info.start + thread.stack_info.size  */\n-DECL|macro|Z_KERNEL_STACK_LEN (size)\n+DECL|macro|K_KERNEL_STACK_LEN (size)\n-name|Z_KERNEL_STACK_LEN\n+name|K_KERNEL_STACK_LEN\n-value|extern struct z_thread_stack_element \\ \t\tsym[nmemb][Z_KERNEL_STACK_LEN(size)]\n+value|extern struct z_thread_stack_element \\ \t\tsym[nmemb][K_KERNEL_STACK_LEN(size)]\n-value|extern struct z_thread_stack_element \\ \t\tsym[nmemb][Z_KERNEL_STACK_LEN(size)]\n+value|extern struct z_thread_stack_element \\ \t\tsym[nmemb][K_KERNEL_STACK_LEN(size)]\n-value|struct z_thread_stack_element lsect \\ \t\t__aligned(Z_KERNEL_STACK_OBJ_ALIGN) \\ \t\tsym[nmemb][Z_KERNEL_STACK_LEN(size)]\n+value|struct z_thread_stack_element lsect \\ \t\t__aligned(Z_KERNEL_STACK_OBJ_ALIGN) \\ \t\tsym[nmemb][K_KERNEL_STACK_LEN(size)]\n-value|Z_KERNEL_STACK_LEN\n+value|K_KERNEL_STACK_LEN\n-                     \" priv_stacks[%d][Z_KERNEL_STACK_LEN(CONFIG_PRIVILEGED_STACK_SIZE)];\\n\"\n+                     \" priv_stacks[%d][K_KERNEL_STACK_LEN(CONFIG_PRIVILEGED_STACK_SIZE)];\\n\"\n-name|Z_KERNEL_STACK_LEN\n+name|K_KERNEL_STACK_LEN\nThe issue was with: kernel: rename Z_KERNEL_STACK_LEN to K_KERNEL_STACK_LEN\n\nSince there is a K_THREAD_STACK_LEN, its kernel counterpart\nshould also be prefixed with K_ for consistency."
},{
  "instruction": "There is an issue in the following code. It relates to net: wifi: shell: Avoid declaring variables after case statement\n\nSome compilers have trouble parsing variables directly after a case\nstatement.\n\nFixes: #70792 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|MAX_BANDS_STR_LEN\nvalue|64\nend_define\n\nbegin_struct\nDECL|struct|__anon2a301cf50108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\ndecl_stmt|;\nDECL|member|scan_result\nname|uint32_t\nname|scan_result\ndecl_stmt|;\nDECL|union|__anon2a301cf5020a\nunion|union\nblock|{\nDECL|struct|__anon2a301cf50308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\nname|size_t\nname|offset\ninit|=\nliteral|0\ndecl_stmt|;\ncomment|/* Defaults */\nname|params\noperator|->\nname|band\noperator|=\nblock|}\nbreak|break;\ncase|case\nliteral|'c'\ncase|:\nname|long\nname|channel\ninit|=\nname|strtol\nargument_list|(\nname|optarg\nargument_list|,\noperator|&\nname|endptr\nargument_list|,\nliteral|10\nargument_list|)\ndecl_stmt|;\nfor|for\ncontrol|(\nname|band\noperator|=\nliteral|0",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2a301cf50108\n+DECL|struct|__anon28fbfc110108\n-DECL|union|__anon2a301cf5020a\n+DECL|union|__anon28fbfc11020a\n-DECL|struct|__anon2a301cf50308\n+DECL|struct|__anon28fbfc110308\n+name|long\n+name|channel\n+decl_stmt|;\n-name|long\n-init|=\n+operator|=\n-decl_stmt|;\n+expr_stmt|;\nThe issue was with: net: wifi: shell: Avoid declaring variables after case statement\n\nSome compilers have trouble parsing variables directly after a case\nstatement.\n\nFixes: #70792"
},{
  "instruction": "There is an issue in the following code. It relates to net: sockets: Use only Zephyr POSIX headers\n\nUse only Zephyr specific POSIX header files so that the whole\nsystem is getting values from the same files. There was an issue with\nnative_sim run of tests/net/socket/af_packet which had O_BLOCKING set\nto 0x4000 from include/zephyr/posix/fcntl.h, but then the file\nsubsys/net/lib/socket/sockets.c was having O_BLOCKING set to 0x0800\nbecause different header files were used. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/net/socket_types.h>\nend_include\n\nbegin_ifdef\nifdef|#\ndirective|ifdef\nname|CONFIG_ARCH_POSIX\nend_ifdef\n\nbegin_include\ninclude|#\ndirective|include\nfile|<fcntl.h>\nend_include\n\nbegin_else\nelse|#\ndirective|else\nend_else\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/posix/fcntl.h>\nend_include\n\nbegin_endif\nendif|#\ndirective|endif\nend_endif\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/internal/syscall_handler.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_ifdef\n-ifdef|#\n-directive|ifdef\n-name|CONFIG_ARCH_POSIX\n-end_ifdef\n-\n-begin_include\n-include|#\n-directive|include\n-file|<fcntl.h>\n-end_include\n-\n-begin_else\n-else|#\n-directive|else\n-end_else\n-\n-begin_endif\n-endif|#\n-directive|endif\n-end_endif\n-\nThe issue was with: net: sockets: Use only Zephyr POSIX headers\n\nUse only Zephyr specific POSIX header files so that the whole\nsystem is getting values from the same files. There was an issue with\nnative_sim run of tests/net/socket/af_packet which had O_BLOCKING set\nto 0x4000 from include/zephyr/posix/fcntl.h, but then the file\nsubsys/net/lib/socket/sockets.c was having O_BLOCKING set to 0x0800\nbecause different header files were used."
},{
  "instruction": "There is an issue in the following code. It relates to tests: net: lwm2m: Fix zsock_fcntl impl name\n\nThe syscall name has _impl postfix so adjusting the stub\nname.\n\nzephyr-sdk-0.16.5-1/x86_64-zephyr-elf/bin/../lib/gcc/\n  x86_64-zephyr-elf/12.2.0/../../../../x86_64-zephyr-elf/bin/ld.bfd:\n  app/libapp.a(lwm2m_engine.c.obj): in function `zsock_fcntl_impl':\n.../syscalls/socket.h:363: undefined reference to `z_impl_zsock_fcntl_impl' Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|z_impl_zsock_fcntl (int sock,int cmd,int flags)\nname|int\nname|z_impl_zsock_fcntl\nparameter_list|(\nname|int\nname|sock\nparameter_list|,\nname|int",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|z_impl_zsock_fcntl (int sock,int cmd,int flags)\n+DECL|function|z_impl_zsock_fcntl_impl (int sock,int cmd,int flags)\n-name|z_impl_zsock_fcntl\n+name|z_impl_zsock_fcntl_impl\nThe issue was with: tests: net: lwm2m: Fix zsock_fcntl impl name\n\nThe syscall name has _impl postfix so adjusting the stub\nname.\n\nzephyr-sdk-0.16.5-1/x86_64-zephyr-elf/bin/../lib/gcc/\n  x86_64-zephyr-elf/12.2.0/../../../../x86_64-zephyr-elf/bin/ld.bfd:\n  app/libapp.a(lwm2m_engine.c.obj): in function `zsock_fcntl_impl':\n.../syscalls/socket.h:363: undefined reference to `z_impl_zsock_fcntl_impl'"
},{
  "instruction": "There is an issue in the following code. It relates to shell: mqtt: Avoid using POSIX function names\n\nThis commit fixes this error seen in CI so that things\nwork even if CONFIG_POSIX_API is enabled.\n\nsubsys/shell/backends/shell_mqtt.c:727:12: error:\n  conflicting types for 'write'; have\n 'int(const struct shell_transport *, const void *, size_t,  size_t *)'\n  727 | static int write(const struct shell_transport *transport,\n                         const void *data, size_t length)\n\ninclude/zephyr/posix/unistd.h:230:9: note: previous declaration\n of 'write' with type\n 'ssize_t(int,  const void *, size_t)'\n  230 | ssize_t write(int file, const void *buffer, size_t count);\n\nsubsys/shell/backends/shell_mqtt.c:787:12: error:\n conflicting types for 'read'; have\n 'int(const struct shell_transport *, void *, size_t,  size_t *)'\n  787 | static int read(const struct shell_transport *transport,\n                        void *data, size_t length, size_t *cnt)\n\ninclude/zephyr/posix/unistd.h:231:9: note: previous declaration\n of 'read' with type\n 'ssize_t(int,  void *, size_t)'\n  231 | ssize_t read(int file, void *buffer, size_t count); Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|write (const struct shell_transport * transport,const void * data,size_t length,size_t * cnt)\nspecifier|static\nname|int\nname|write\nparameter_list|(\nspecifier|const\nname|struct\nname|shell_transport\nmodifier|*\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|read (const struct shell_transport * transport,void * data,size_t length,size_t * cnt)\nspecifier|static\nname|int\nname|read\nparameter_list|(\nspecifier|const\nname|struct\nname|shell_transport\nmodifier|*\nname|enable\nblock|,\noperator|.\nname|write\noperator|=\nname|write\nblock|,\noperator|.\nname|read\noperator|=\nname|read\nblock|}\ndecl_stmt|;\nend_decl_stmt\n\nbegin_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|write (const struct shell_transport * transport,const void * data,size_t length,size_t * cnt)\n+DECL|function|write_data (const struct shell_transport * transport,const void * data,size_t length,size_t * cnt)\n-name|write\n+name|write_data\n-DECL|function|read (const struct shell_transport * transport,void * data,size_t length,size_t * cnt)\n+DECL|function|read_data (const struct shell_transport * transport,void * data,size_t length,size_t * cnt)\n-name|read\n+name|read_data\n-name|write\n+name|write_data\n-name|read\n+name|read_data\nThe issue was with: shell: mqtt: Avoid using POSIX function names\n\nThis commit fixes this error seen in CI so that things\nwork even if CONFIG_POSIX_API is enabled.\n\nsubsys/shell/backends/shell_mqtt.c:727:12: error:\n  conflicting types for 'write'; have\n 'int(const struct shell_transport *, const void *, size_t,  size_t *)'\n  727 | static int write(const struct shell_transport *transport,\n                         const void *data, size_t length)\n\ninclude/zephyr/posix/unistd.h:230:9: note: previous declaration\n of 'write' with type\n 'ssize_t(int,  const void *, size_t)'\n  230 | ssize_t write(int file, const void *buffer, size_t count);\n\nsubsys/shell/backends/shell_mqtt.c:787:12: error:\n conflicting types for 'read'; have\n 'int(const struct shell_transport *, void *, size_t,  size_t *)'\n  787 | static int read(const struct shell_transport *transport,\n                        void *data, size_t length, size_t *cnt)\n\ninclude/zephyr/posix/unistd.h:231:9: note: previous declaration\n of 'read' with type\n 'ssize_t(int,  void *, size_t)'\n  231 | ssize_t read(int file, void *buffer, size_t count);"
},{
  "instruction": "There is an issue in the following code. It relates to net: websocket: Use zsock_ API calls\n\nUse zsock_ API calls so that we do not need to enable POSIX_API. Please fix this issue.",
  "input": "Faulty tokenized code:\ncondition|)\nblock|{\noperator|(\nname|void\noperator|)\nname|close\nargument_list|(\nname|fd\nargument_list|)\nexpr_stmt|;\nblock|}\nname|int\nname|ws_sock\nparameter_list|)\nblock|{\nreturn|return\nname|close\nargument_list|(\nname|ws_sock\nargument_list|)\nreturn|;\nblock|}\nliteral|0\ncondition|)\nblock|{\nname|ret\noperator|=\nname|recv\nargument_list|(\nname|ctx\noperator|->\nname|real_sock\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|close\n+name|zsock_close\n-name|close\n+name|zsock_close\n-name|recv\n+name|zsock_recv\nThe issue was with: net: websocket: Use zsock_ API calls\n\nUse zsock_ API calls so that we do not need to enable POSIX_API."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: systimer: Removed mention to ESP32C3\n\nRemoved mention to C3 SoC, so files are not SoC specific. Ready for C6\nintegration. Please fix this issue.",
  "input": "Faulty tokenized code:\n/drivers/timer/*cavs*                     @dcpleung\n/drivers/timer/*stm32_lptim*              @FRASTM\n/drivers/timer/*leon_gptimer*             @julius-barendt\n/drivers/timer/*mips_cp0*                 @frantony\n/drivers/timer/*rcar_cmt*                 @aaillet\n/drivers/timer/*esp32c3_sys*              @uLipe\n/drivers/timer/*sam0_rtc*                 @bendiscz\n/drivers/timer/*arcv2*                    @ruuddw\n/drivers/timer/*xtensa*                   @dcpleung\n/drivers/timer/*rv32m1_lptmr*             @mbolivar\n/drivers/timer/*nrf_rtc*                  @anangl\nzephyr_library_sources_ifdef(CONFIG_ARCV2_TIMER arcv2_timer0.c)\nzephyr_library_sources_ifdef(CONFIG_ARM_ARCH_TIMER arm_arch_timer.c)\nzephyr_library_sources_ifdef(CONFIG_INTEL_ADSP_TIMER intel_adsp_timer.c)\nzephyr_library_sources_ifdef(CONFIG_CC13XX_CC26XX_RTC_TIMER cc13xx_cc26xx_rtc_timer.c)\nzephyr_library_sources_ifdef(CONFIG_CORTEX_M_SYSTICK cortex_m_systick.c)\nzephyr_library_sources_ifdef(CONFIG_ESP32C3_SYS_TIMER esp32c3_sys_timer.c)\nzephyr_library_sources_ifdef(CONFIG_GECKO_BURTC_TIMER gecko_burtc_timer.c)\nzephyr_library_sources_ifdef(CONFIG_HPET_TIMER hpet.c)\nzephyr_library_sources_ifdef(CONFIG_ITE_IT8XXX2_TIMER ite_it8xxx2_timer.c)\nzephyr_library_sources_ifdef(CONFIG_LEON_GPTIMER leon_gptimer.c)\nzephyr_library_sources_ifdef(CONFIG_LITEX_TIMER litex_timer.c)\nsource \"drivers/timer/Kconfig.arcv2\"\nsource \"drivers/timer/Kconfig.arm_arch\"\nsource \"drivers/timer/Kconfig.cavs\"\nsource \"drivers/timer/Kconfig.cc13xx_cc26xx_rtc\"\nsource \"drivers/timer/Kconfig.cortex_m_systick\"\nsource \"drivers/timer/Kconfig.esp32c3_sys\"\nsource \"drivers/timer/Kconfig.gecko\"\nsource \"drivers/timer/Kconfig.ite_it8xxx2\"\nsource \"drivers/timer/Kconfig.leon_gptimer\"\nsource \"drivers/timer/Kconfig.litex\"\nsource \"drivers/timer/Kconfig.mchp_xec_rtos\"\nsimilarity index 83%\nrename from drivers/timer/Kconfig.esp32c3_sys\nrename to drivers/timer/Kconfig.esp32\n# Copyright (c) 2014-2015 Wind River Systems, Inc.\n# Copyright (c) 2016 Cadence Design Systems, Inc.\n# Copyright (c) 2019 Intel Corp.\n# SPDX-License-Identifier: Apache-2.0\n\nconfig ESP32C3_SYS_TIMER\n\tbool \"ESP32C3 sys-timer support\"\n\tdepends on SOC_SERIES_ESP32C3\n\tdefault y\n\tselect TICKLESS_CAPABLE\n\tselect TIMER_HAS_64BIT_CYCLE_COUNTER\n\thelp\n\t  This option enables the system timer driver for the Espressif ESP32C3\n\t  and provides the standard \"system clock driver\" interface.\nsimilarity index 100%\nrename from drivers/timer/esp32c3_sys_timer.c\nrename to drivers/timer/esp32_sys_timer.c\n    *libkernel.a:(.literal .text .literal.* .text.*)\n    *libgcc.a:lib2funcs.*(.literal .text .literal.* .text.*)\n    *libdrivers__flash.a:flash_esp32.*(.literal .text .literal.* .text.*)\n    *libzephyr.a:spi_flash_rom_patch.*(.literal .text .literal.* .text.*)\n    *libzephyr.a:log_noos.*(.literal .text .literal.* .text.*)\n   *libdrivers__timer.a:esp32c3_sys_timer.*(.literal .text .literal.* .text.*)\n    *libzephyr.a:log_core.*(.literal .text .literal.* .text.*)\n    *libzephyr.a:cbprintf_complete.*(.literal .text .literal.* .text.*)\n    *libzephyr.a:printk.*(.literal.printk .literal.vprintk .literal.char_out .text.printk .text.vprintk .text.char_out)\n    *libzephyr.a:log_msg.*(.literal .text .literal.* .text.*)\n    *libzephyr.a:log_list.*(.literal .text .literal.* .text.*)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-/drivers/timer/*esp32c3_sys*              @uLipe\n+/drivers/timer/*esp32_sys*                @uLipe\n-zephyr_library_sources_ifdef(CONFIG_ESP32C3_SYS_TIMER esp32c3_sys_timer.c)\n+zephyr_library_sources_ifdef(CONFIG_ESP32_SYS_TIMER esp32_sys_timer.c)\n-source \"drivers/timer/Kconfig.esp32c3_sys\"\n+source \"drivers/timer/Kconfig.esp32\"\n-config ESP32C3_SYS_TIMER\n-\tbool \"ESP32C3 sys-timer support\"\n+config ESP32_SYS_TIMER\n+\tbool \"ESP32 sys-timer support (ESP32Cx series)\"\n-\t  This option enables the system timer driver for the Espressif ESP32C3\n+\t  This option enables the system timer driver for the Espressif ESP32Cx\n-    *libdrivers__timer.a:esp32c3_sys_timer.*(.literal .text .literal.* .text.*)\n+    *libdrivers__timer.a:esp32_sys_timer.*(.literal .text .literal.* .text.*)\nThe issue was with: drivers: systimer: Removed mention to ESP32C3\n\nRemoved mention to C3 SoC, so files are not SoC specific. Ready for C6\nintegration."
},{
  "instruction": "There is an issue in the following code. It relates to serial: uart_native_tty: Polling thread fix\n\nAddresses an issue where attempts to transmit data fail.\nThe identified cause of this failure is the handling of the\n`rx_irq_enable` and `tx_irq_enable` flags. The `else if` handling the\n`tx_irq_enable` was replaced by an `if` so both flags can be true,\nand both functions can be called. This fix was tested with the\n`cellular_modem` example successfully. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nargument_list|)\nexpr_stmt|;\nblock|}\nblock|}\nif|else if\ncondition|(\nname|data\noperator|->\nname|tx_irq_enabled\ncondition|)\nargument_list|(\nname|dev\nargument_list|)\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\nname|k_sleep\nargument_list|(\nname|K_MSEC\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-if|else if\n+if|if\n-else|else\n+if|if\n+condition|(\n+name|data\n+operator|->\n+name|tx_irq_enabled\n+operator|==\n+name|false\n+operator|&&\n+name|data\n+operator|->\n+name|rx_irq_enabled\n+operator|==\n+name|false\n+condition|)\nThe issue was with: serial: uart_native_tty: Polling thread fix\n\nAddresses an issue where attempts to transmit data fail.\nThe identified cause of this failure is the handling of the\n`rx_irq_enable` and `tx_irq_enable` flags. The `else if` handling the\n`tx_irq_enable` was replaced by an `if` so both flags can be true,\nand both functions can be called. This fix was tested with the\n`cellular_modem` example successfully."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Audio: Scan Delegator: update bass_source_is_duplicate fn\n\nAddress type is passed as an argument instead of the entire address. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|err\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|bass_source_is_duplicate (uint32_t broadcast_id,uint8_t adv_sid,bt_addr_le_t addr)\nspecifier|static\nname|bool\nname|bass_source_is_duplicate\nparameter_list|(\nname|uint32_t\nname|broadcast_id\nparameter_list|,\nname|uint8_t\nname|adv_sid\nparameter_list|,\nname|bt_addr_le_t\nname|addr\nparameter_list|)\nblock|{\nname|struct\nname|bass_recv_state_internal\nmodifier|*\noperator|.\nname|addr\noperator|.\nname|type\noperator|==\nname|addr\noperator|.\nname|type\ncondition|)\nblock|{\nname|LOG_DBG\nargument_list|(\nliteral|\"recv_state already exists at src_id=0x%02X\"\nname|adv_sid\nargument_list|,\nname|state\noperator|->\nname|addr\nargument_list|)\ncondition|)\nblock|{\nname|LOG_DBG\nargument_list|(\nexpr_stmt|;\nreturn|return\nname|ret_val\nreturn|;\nblock|}\nelse|else\nblock|{\nname|LOG_DBG\nargument_list|(\nliteral|\"Index %u: Not active\"\nargument_list|,\nname|idx\nargument_list|,\nliteral|0\nargument_list|)\nreturn|;\nblock|}\nblock|}\nend_function\n\nbegin_define\nDECL|macro|RECEIVE_STATE_CHARACTERISTIC (idx)\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_comment\n+comment|/* BAP 6.5.4 states that the Broadcast Assistant shall not initiate the Add Source operation  * if the operation would result in duplicate values for the combined Source_Address_Type,  * Source_Adv_SID, and Broadcast_ID fields of any Broadcast Receive State characteristic exposed  * by the Scan Delegator.  */\n+end_comment\n+\n-DECL|function|bass_source_is_duplicate (uint32_t broadcast_id,uint8_t adv_sid,bt_addr_le_t addr)\n+DECL|function|bass_source_is_duplicate (uint32_t broadcast_id,uint8_t adv_sid,uint8_t addr_type)\n-name|bt_addr_le_t\n-name|addr\n+name|uint8_t\n+name|addr_type\n-name|addr\n-operator|.\n-name|type\n+name|addr_type\n+operator|.\n+name|type\n-else|else\n-block|{\n-block|}\nThe issue was with: Bluetooth: Audio: Scan Delegator: update bass_source_is_duplicate fn\n\nAddress type is passed as an argument instead of the entire address."
},{
  "instruction": "There is an issue in the following code. It relates to net: wifi: shell: apply `struct option` as `static const`\n\nThis change marks each instance of the `struct option` as `static const`.\n\nThe rationale is that `struct option` is a read-only variable.\nBy using `static const`, we ensure immutability, leading to usage of only\nthe `.rodata` section and a reduction in the `.data` area. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|MAX_BANDS_STR_LEN\nvalue|64\nend_define\n\nbegin_struct\nDECL|struct|__anon2c8184da0108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\ndecl_stmt|;\nDECL|member|scan_result\nname|uint32_t\nname|scan_result\ndecl_stmt|;\nDECL|union|__anon2c8184da020a\nunion|union\nblock|{\nDECL|struct|__anon2c8184da0308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\ndecl_stmt|;\nname|int\nname|opt\ndecl_stmt|;\nspecifier|static\nname|struct\nname|option\nname|long_options\nindex|[]\ninit|=\nname|option_index\ninit|=\nliteral|0\ndecl_stmt|;\nspecifier|static\nname|struct\nname|option\nname|long_options\nindex|[]\ninit|=\nname|option_index\ninit|=\nliteral|0\ndecl_stmt|;\nspecifier|static\nname|struct\nname|option\nname|long_options\nindex|[]\ninit|=\nname|option_index\ninit|=\nliteral|0\ndecl_stmt|;\nspecifier|static\nname|struct\nname|option\nname|long_options\nindex|[]\ninit|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2c8184da0108\n+DECL|struct|__anon2aa086e40108\n-DECL|union|__anon2c8184da020a\n+DECL|union|__anon2aa086e4020a\n-DECL|struct|__anon2c8184da0308\n+DECL|struct|__anon2aa086e40308\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\nThe issue was with: net: wifi: shell: apply `struct option` as `static const`\n\nThis change marks each instance of the `struct option` as `static const`.\n\nThe rationale is that `struct option` is a read-only variable.\nBy using `static const`, we ensure immutability, leading to usage of only\nthe `.rodata` section and a reduction in the `.data` area."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: ethernet: eth_adin2111: use NET_ETH_ADDR_LEN\n\nUse new NET_ETH_ADDR_LEN definition. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|)\ndecl_stmt|;\nname|uint8_t\nname|mm\nindex|[\nliteral|6\nindex|]\ninit|=\nblock|{\nname|BIT\nargument_list|(\nblock|}\ndecl_stmt|;\nname|uint8_t\nname|mmask\nindex|[\nliteral|6\nindex|]\ninit|=\nblock|{\nliteral|0xFFU\nblock|,\nname|ADIN2111_MAC\noperator|)\ndecl_stmt|;\nname|uint8_t\nname|mac\nindex|[]\ninit|=\nblock|{\nliteral|0xFFU\nblock|,\nliteral|0xFFU",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|6\n+name|NET_ETH_ADDR_LEN\n-literal|6\n+name|NET_ETH_ADDR_LEN\n-index|[]\n+index|[\n+name|NET_ETH_ADDR_LEN\n+index|]\nThe issue was with: drivers: ethernet: eth_adin2111: use NET_ETH_ADDR_LEN\n\nUse new NET_ETH_ADDR_LEN definition."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: ethernet: eth_adin2111: adjust multicast filter\n\nMulticast rule as 01:00:00:00:00:00 is actually shadowing\nbroadcast rule, enabling broadcast packets to be received/forwarded\neven if broadcast rule/filter is not set.\n\nSet the multicast filter with an appropriate mask. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|0U\nblock|,\nliteral|0U\nblock|}\ndecl_stmt|;\nname|uint32_t\nname|rules\ninit|=\nname|ADIN2111_ADDR_APPLY2PORT1\noperator||\nargument_list|(\nname|dev\nargument_list|,\nname|mm\nargument_list|,\nname|mm\nargument_list|,\nname|rules\nargument_list|,\nname|ADIN2111_MULTICAST_ADDR_SLOT\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|uint8_t\n+name|mmask\n+index|[\n+literal|6\n+index|]\n+init|=\n+block|{\n+literal|0xFFU\n+block|,\n+literal|0U\n+block|,\n+literal|0U\n+block|,\n+literal|0U\n+block|,\n+literal|0U\n+block|,\n+literal|0U\n+block|}\n+decl_stmt|;\n-name|mm\n+name|mmask\nThe issue was with: drivers: ethernet: eth_adin2111: adjust multicast filter\n\nMulticast rule as 01:00:00:00:00:00 is actually shadowing\nbroadcast rule, enabling broadcast packets to be received/forwarded\neven if broadcast rule/filter is not set.\n\nSet the multicast filter with an appropriate mask."
},{
  "instruction": "There is an issue in the following code. It relates to tests: posix: headers: uncomment check for sockatmark()\n\nUncomment the check for sockatmark() to ensure that the function\nis declared in sys/socket.h, as a stub implementation was added\nin the previous commit. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|zassert_not_null\nargument_list|(\nname|shutdown\nargument_list|)\nexpr_stmt|;\ncomment|/* zassert_not_null(sockatmark); */\ncomment|/* not implemented */\nname|zassert_not_null\nargument_list|(\nname|socket\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* zassert_not_null(sockatmark); */\n-comment|/* not implemented */\n+name|zassert_not_null\n+argument_list|(\n+name|sockatmark\n+argument_list|)\n+expr_stmt|;\nThe issue was with: tests: posix: headers: uncomment check for sockatmark()\n\nUncomment the check for sockatmark() to ensure that the function\nis declared in sys/socket.h, as a stub implementation was added\nin the previous commit."
},{
  "instruction": "There is an issue in the following code. It relates to tests: posix: common: reorder headers to avoid LOG_ERR conflict\n\nThe log subsystem defines LOG_ERR as a macro, which conflicts\nwith the standard POSIX LOG_ERR log level (3).\n\nReorder includes to avoid errors. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/posix/syslog.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/posix/unistd.h>\nend_include\n\nbegin_undef\nundef|#\ndirective|undef\nname|LOG_ERR\nend_undef\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/ztest.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_include\n-include|#\n-directive|include\n-file|<zephyr/posix/unistd.h>\n-end_include\n-\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/posix/unistd.h>\n+end_include\n+\nThe issue was with: tests: posix: common: reorder headers to avoid LOG_ERR conflict\n\nThe log subsystem defines LOG_ERR as a macro, which conflicts\nwith the standard POSIX LOG_ERR log level (3).\n\nReorder includes to avoid errors."
},{
  "instruction": "There is an issue in the following code. It relates to net: buf: Fix cloning of zero-sized buffers\n\nFor zero sized buffers, instead of pointing to a buffer, net_buf->__buf\nis NULL. For this reason, when cloning a buffer, the code needs to check\n__buf before dereferencing it. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nname|clone\noperator|->\nname|__buf\noperator|=\nname|data_ref\nargument_list|(\nname|buf\nargument_list|,\nname|buf\noperator|->\nname|__buf\nargument_list|)\nexpr_stmt|;\nname|clone\noperator|->\nname|data\noperator|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|buf\n+operator|->\n+name|__buf\n+condition|?\n+else|:\n+name|NULL\nThe issue was with: net: buf: Fix cloning of zero-sized buffers\n\nFor zero sized buffers, instead of pointing to a buffer, net_buf->__buf\nis NULL. For this reason, when cloning a buffer, the code needs to check\n__buf before dereferencing it."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: spi: NXP LPSPI driver sometimes uses instance number\n\nUpdate the driver to account for variations in the SDK driver\nwhen it uses the instance number instead of the base address. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|dev\nargument_list|,\nname|reg_base\nargument_list|)\ndecl_stmt|;\nname|LPSPI_MasterTransferHandleIRQ\nargument_list|(\nname|base\nargument_list|,\noperator|&\nname|data\noperator|->\nname|handle\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_ifdef\nifdef|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|#\n+directive|if\n+name|CONFIG_NXP_LP_FLEXCOMM\n+name|LPSPI_MasterTransferHandleIRQ\n+argument_list|(\n+name|LPSPI_GetInstance\n+argument_list|(\n+name|base\n+argument_list|)\n+argument_list|,\n+operator|&\n+name|data\n+operator|->\n+name|handle\n+argument_list|)\n+expr_stmt|;\n+else|#\n+directive|else\n+endif|#\n+directive|endif\nThe issue was with: drivers: spi: NXP LPSPI driver sometimes uses instance number\n\nUpdate the driver to account for variations in the SDK driver\nwhen it uses the instance number instead of the base address."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: charger: charger_max20335: rename macro to reduce ambiguity\n\nThe ILimCntl name can be understood as both register name and its field\nname. Therefore it is better to change macro name so it contains both\nregister and field name. Second field of this register will be also\nutilized by this driver in the future and new code will be aligned to\nthis naming convention. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|MAX20335_CHGCNTLA_BAT_REG_CFG_MASK\nvalue|GENMASK(4, 1)\nend_define\n\nbegin_define\nDECL|macro|MAX20335_ILIMCNTL_MASK\ndefine|#\ndirective|define\nname|MAX20335_ILIMCNTL_MASK\nvalue|GENMASK(1, 0)\nend_define\n\nbegin_define\nDECL|macro|MAX20335_STATUS_A_CHG_STAT_MASK\nname|charger_status\nmodifier|*\nname|status\nparameter_list|)\nblock|{\nDECL|enum|__anon2bcdd5fe0103\nenum|enum\nblock|{\nDECL|enumerator|MAX20335_CHARGER_OFF\nname|MAX20335_CHARGER_OFF\nblock|,\nname|charger_online\nmodifier|*\nname|online\nparameter_list|)\nblock|{\nDECL|enum|__anon2bcdd5fe0203\nenum|enum\nblock|{\nDECL|enumerator|MAX20335_CHGIN_IN_NOT_PRESENT_OR_INVALID\nname|MAX20335_CHGIN_IN_NOT_PRESENT_OR_INVALID\nblock|,\nempty_stmt|;\nname|val\noperator|=\nname|FIELD_PREP\nargument_list|(\nname|MAX20335_ILIMCNTL_MASK\nargument_list|,\nname|val\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|->\nname|bus\nargument_list|,\nname|MAX20335_REG_ILIMCNTL\nargument_list|,\nname|MAX20335_ILIMCNTL_MASK\nargument_list|,\nname|val\nargument_list|)\nreturn|;\nblock|}\nname|device\nmodifier|*\nname|dev\nparameter_list|)\nblock|{\nDECL|enum|__anon2bcdd5fe0303\nDECL|enumerator|MASK_A_VAL_ENABLE\nenum|enum\nblock|{\nname|MASK_A_VAL_ENABLE\ninit|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|macro|MAX20335_ILIMCNTL_MASK\n+DECL|macro|MAX20335_ILIMCNTL_ILIMCNTL_MASK\n-name|MAX20335_ILIMCNTL_MASK\n+name|MAX20335_ILIMCNTL_ILIMCNTL_MASK\n-DECL|enum|__anon2bcdd5fe0103\n+DECL|enum|__anon2b2834dd0103\n-DECL|enum|__anon2bcdd5fe0203\n+DECL|enum|__anon2b2834dd0203\n-name|MAX20335_ILIMCNTL_MASK\n+name|MAX20335_ILIMCNTL_ILIMCNTL_MASK\n-name|MAX20335_ILIMCNTL_MASK\n+name|MAX20335_ILIMCNTL_ILIMCNTL_MASK\n-DECL|enum|__anon2bcdd5fe0303\n+DECL|enum|__anon2b2834dd0303\nThe issue was with: drivers: charger: charger_max20335: rename macro to reduce ambiguity\n\nThe ILimCntl name can be understood as both register name and its field\nname. Therefore it is better to change macro name so it contains both\nregister and field name. Second field of this register will be also\nutilized by this driver in the future and new code will be aligned to\nthis naming convention."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: charger: charger_max20335: fix linear range usage\n\nFix validation of `linear_range_get_index()` results.\nThe function can resturn both 0 or -ERANGE but -EINVAL is never\nreturned. Use comparison against 0 to make the validation robust.\n\nUse valid maximum index for the linear range. The 0x0C is reserved\nvalue and should not be used. Therefore replace it with 0x0B. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_define\nDECL|macro|MAX20335_REG_CVC_VREG_MAX_IDX\ndefine|#\ndirective|define\nname|MAX20335_REG_CVC_VREG_MAX_IDX\nvalue|0x0CU\nend_define\n\nbegin_define\nDECL|macro|INT_ENABLE_DELAY\ndefine|#\nname|charger_status\nmodifier|*\nname|status\nparameter_list|)\nblock|{\nDECL|enum|__anon28e4a2e20103\nenum|enum\nblock|{\nDECL|enumerator|MAX20335_CHARGER_OFF\nname|MAX20335_CHARGER_OFF\nblock|,\nname|charger_online\nmodifier|*\nname|online\nparameter_list|)\nblock|{\nDECL|enum|__anon28e4a2e20203\nenum|enum\nblock|{\nDECL|enumerator|MAX20335_CHGIN_IN_NOT_PRESENT_OR_INVALID\nname|MAX20335_CHGIN_IN_NOT_PRESENT_OR_INVALID\nblock|,\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|ret\noperator|==\noperator|-\nname|EINVAL\ncondition|)\nblock|{\nreturn|return\nname|ret\nreturn|;\nname|device\nmodifier|*\nname|dev\nparameter_list|)\nblock|{\nDECL|enum|__anon28e4a2e20303\nDECL|enumerator|MASK_A_VAL_ENABLE\nenum|enum\nblock|{\nname|MASK_A_VAL_ENABLE\ninit|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|0x0CU\n+value|0x0BU\n-DECL|enum|__anon28e4a2e20103\n+DECL|enum|__anon2bcdd5fe0103\n-DECL|enum|__anon28e4a2e20203\n+DECL|enum|__anon2bcdd5fe0203\n-operator|==\n-operator|-\n-name|EINVAL\n+operator|<\n+literal|0\n-DECL|enum|__anon28e4a2e20303\n+DECL|enum|__anon2bcdd5fe0303\nThe issue was with: drivers: charger: charger_max20335: fix linear range usage\n\nFix validation of `linear_range_get_index()` results.\nThe function can resturn both 0 or -ERANGE but -EINVAL is never\nreturned. Use comparison against 0 to make the validation robust.\n\nUse valid maximum index for the linear range. The 0x0C is reserved\nvalue and should not be used. Therefore replace it with 0x0B."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: video: mt9m114: Run clang format\n\nRun clang format before making any changes Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|2\nblock|,\nliteral|0x1000\nblock|}\nblock|,\nblock|{\nliteral|0xC97E\nblock|,\nliteral|2\nblock|,\nname|height\nparameter_list|,\nname|format\nparameter_list|)\ndefine|\\\nvalue|{ \\ \t\t.pixelformat = (format), \\ \t\t.width_min = (width), \\ \t\t.width_max = (width), \\ \t\t.height_min = (height), \\ \t\t.height_max = (height), \\ \t\t.width_step = 0, \\ \t\t.height_step = 0 \\ \t}\nend_define\n\nbegin_decl_stmt\nDECL|variable|fmts\nspecifier|static\nliteral|480\nargument_list|,\nname|VIDEO_PIX_FMT_RGB565\nargument_list|)\nblock|,\ncomment|/* VGA  RGB565 \t*/\nname|MT9M114_VIDEO_FORMAT_CAP\nargument_list|(\nliteral|640\nargument_list|,\nliteral|480\nargument_list|,\nname|VIDEO_PIX_FMT_YUYV\nargument_list|)\nblock|,\ncomment|/* VGA  YUYV \t*/\nblock|{\nliteral|0\nblock|}\nblock|}\ndecl_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* logical_address_access = 0x1000 */\n-value|{ \\ \t\t.pixelformat = (format), \\ \t\t.width_min = (width), \\ \t\t.width_max = (width), \\ \t\t.height_min = (height), \\ \t\t.height_max = (height), \\ \t\t.width_step = 0, \\ \t\t.height_step = 0 \\ \t}\n+value|{                                                                                          \\ \t\t.pixelformat = (format), .width_min = (width), .width_max = (width),               \\ \t\t.height_min = (height), .height_max = (height), .width_step = 0, .height_step = 0  \\ \t}\n-comment|/* VGA  RGB565 \t*/\n+comment|/* VGA RGB565 */\n-comment|/* VGA  YUYV \t*/\n+comment|/* VGA YUYV */\nThe issue was with: drivers: video: mt9m114: Run clang format\n\nRun clang format before making any changes"
},{
  "instruction": "There is an issue in the following code. It relates to input: analog_axis: fix the variable name for calibration\n\nUse a coherent name for the calibration data structure variable name. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ANALOG_AXIS_INIT\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|static const struct analog_axis_channel_config analog_axis_channel_cfg_##inst[] = {\t\\ \t\tDT_INST_FOREACH_CHILD_STATUS_OKAY_SEP(inst, ANALOG_AXIS_CHANNEL_CFG_DEF, (,))\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct analog_axis_channel_data\t\t\t\t\t\t\t\\ \t\tanalog_axis_channel_data_##inst[ARRAY_SIZE(analog_axis_channel_cfg_##inst)];\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct analog_axis_calibration\t\t\t\t\t\t\t\\ \t\tanalog_axis_calibration##inst[ARRAY_SIZE(analog_axis_channel_cfg_##inst)] = {\t\\ \t\t\tDT_INST_FOREACH_CHILD_STATUS_OKAY_SEP(\t\t\t\t\t\\ \t\t\t\tinst, ANALOG_AXIS_CHANNEL_CAL_DEF, (,))\t\t\t\t\\ \t\t};\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct analog_axis_config analog_axis_cfg_##inst = {\t\t\t\\ \t\t.poll_period_ms = DT_INST_PROP(inst, poll_period_ms),\t\t\t\t\\ \t\t.channel_cfg = analog_axis_channel_cfg_##inst,\t\t\t\t\t\\ \t\t.channel_data = analog_axis_channel_data_##inst,\t\t\t\t\\ \t\t.calibration = analog_axis_calibration##inst,\t\t\t\t\t\\ \t\t.num_channels = ARRAY_SIZE(analog_axis_channel_cfg_##inst),\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct analog_axis_data analog_axis_data_##inst;\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst, analog_axis_init, NULL,\t\t\t\t\t\\&analog_axis_data_##inst,&analog_axis_cfg_##inst,\t\t\\ \t\t\t      POST_KERNEL, CONFIG_INPUT_INIT_PRIORITY, NULL);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|static const struct analog_axis_channel_config analog_axis_channel_cfg_##inst[] = {\t\\ \t\tDT_INST_FOREACH_CHILD_STATUS_OKAY_SEP(inst, ANALOG_AXIS_CHANNEL_CFG_DEF, (,))\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct analog_axis_channel_data\t\t\t\t\t\t\t\\ \t\tanalog_axis_channel_data_##inst[ARRAY_SIZE(analog_axis_channel_cfg_##inst)];\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct analog_axis_calibration\t\t\t\t\t\t\t\\ \t\tanalog_axis_calibration##inst[ARRAY_SIZE(analog_axis_channel_cfg_##inst)] = {\t\\ \t\t\tDT_INST_FOREACH_CHILD_STATUS_OKAY_SEP(\t\t\t\t\t\\ \t\t\t\tinst, ANALOG_AXIS_CHANNEL_CAL_DEF, (,))\t\t\t\t\\ \t\t};\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct analog_axis_config analog_axis_cfg_##inst = {\t\t\t\\ \t\t.poll_period_ms = DT_INST_PROP(inst, poll_period_ms),\t\t\t\t\\ \t\t.channel_cfg = analog_axis_channel_cfg_##inst,\t\t\t\t\t\\ \t\t.channel_data = analog_axis_channel_data_##inst,\t\t\t\t\\ \t\t.calibration = analog_axis_calibration##inst,\t\t\t\t\t\\ \t\t.num_channels = ARRAY_SIZE(analog_axis_channel_cfg_##inst),\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct analog_axis_data analog_axis_data_##inst;\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst, analog_axis_init, NULL,\t\t\t\t\t\\&analog_axis_data_##inst,&analog_axis_cfg_##inst,\t\t\\ \t\t\t      POST_KERNEL, CONFIG_INPUT_INIT_PRIORITY, NULL);\n+value|static const struct analog_axis_channel_config analog_axis_channel_cfg_##inst[] = {\t\\ \t\tDT_INST_FOREACH_CHILD_STATUS_OKAY_SEP(inst, ANALOG_AXIS_CHANNEL_CFG_DEF, (,))\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct analog_axis_channel_data\t\t\t\t\t\t\t\\ \t\tanalog_axis_channel_data_##inst[ARRAY_SIZE(analog_axis_channel_cfg_##inst)];\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct analog_axis_calibration\t\t\t\t\t\t\t\\ \t\tanalog_axis_calibration_##inst[ARRAY_SIZE(analog_axis_channel_cfg_##inst)] = {\t\\ \t\t\tDT_INST_FOREACH_CHILD_STATUS_OKAY_SEP(\t\t\t\t\t\\ \t\t\t\tinst, ANALOG_AXIS_CHANNEL_CAL_DEF, (,))\t\t\t\t\\ \t\t};\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct analog_axis_config analog_axis_cfg_##inst = {\t\t\t\\ \t\t.poll_period_ms = DT_INST_PROP(inst, poll_period_ms),\t\t\t\t\\ \t\t.channel_cfg = analog_axis_channel_cfg_##inst,\t\t\t\t\t\\ \t\t.channel_data = analog_axis_channel_data_##inst,\t\t\t\t\\ \t\t.calibration = analog_axis_calibration_##inst,\t\t\t\t\t\\ \t\t.num_channels = ARRAY_SIZE(analog_axis_channel_cfg_##inst),\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct analog_axis_data analog_axis_data_##inst;\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst, analog_axis_init, NULL,\t\t\t\t\t\\&analog_axis_data_##inst,&analog_axis_cfg_##inst,\t\t\\ \t\t\t      POST_KERNEL, CONFIG_INPUT_INIT_PRIORITY, NULL);\nThe issue was with: input: analog_axis: fix the variable name for calibration\n\nUse a coherent name for the calibration data structure variable name."
},{
  "instruction": "There is an issue in the following code. It relates to sensor: tmag5273: fix switched mask/value argument in FIELD_GET\n\nThis somehow worked without problems during the test runs, but we found a\ncorner case where this leads to an error. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|TMAG5273_T_CONVERSION_US\nargument_list|(\noperator|(\nname|FIELD_GET\nargument_list|(\nname|regdata\nargument_list|,\nname|TMAG5273_CONV_AVB_MSK\nargument_list|)\noperator|)\nargument_list|,\noperator|(\nname|nb_captured_channels",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|regdata\n-argument_list|,\n+argument_list|,\n+name|regdata\nThe issue was with: sensor: tmag5273: fix switched mask/value argument in FIELD_GET\n\nThis somehow worked without problems during the test runs, but we found a\ncorner case where this leads to an error."
},{
  "instruction": "There is an issue in the following code. It relates to sensors: Move TDK sensors to a subdirectory\n\nMove all tdk/invensense sensors to a subdirectory named after the\nvendor. Please fix this issue.",
  "input": "Faulty tokenized code:\nadd_subdirectory_ifdef(CONFIG_HMC5883L hmc5883l)\nadd_subdirectory_ifdef(CONFIG_HP206C hp206c)\nadd_subdirectory_ifdef(CONFIG_HS300X hs300x)\nadd_subdirectory_ifdef(CONFIG_HTS221 hts221)\nadd_subdirectory_ifdef(CONFIG_I3G4250D i3g4250d)\nadd_subdirectory_ifdef(CONFIG_ICM42605 icm42605)\nadd_subdirectory_ifdef(CONFIG_ICM42670 icm42670)\nadd_subdirectory_ifdef(CONFIG_ICM42688 icm42688)\nadd_subdirectory_ifdef(CONFIG_ICP10125 icp10125)\nadd_subdirectory_ifdef(CONFIG_IIS2DH iis2dh)\nadd_subdirectory_ifdef(CONFIG_IIS2DLPC iis2dlpc)\nadd_subdirectory_ifdef(CONFIG_IIS2ICLX iis2iclx)\nadd_subdirectory_ifdef(CONFIG_IIS2MDC iis2mdc)\nadd_subdirectory_ifdef(CONFIG_IIS3DHHC iis3dhhc)\nadd_subdirectory_ifdef(CONFIG_MCP970X mcp970x)\nadd_subdirectory_ifdef(CONFIG_MCP9808 mcp9808)\nadd_subdirectory_ifdef(CONFIG_MCUX_ACMP mcux_acmp)\nadd_subdirectory_ifdef(CONFIG_MHZ19B mhz19b)\nadd_subdirectory_ifdef(CONFIG_MPR mpr)\nadd_subdirectory_ifdef(CONFIG_MPU6050 mpu6050)\nadd_subdirectory_ifdef(CONFIG_MPU9250 mpu9250)\nadd_subdirectory_ifdef(CONFIG_MS5607 ms5607)\nadd_subdirectory_ifdef(CONFIG_MS5837 ms5837)\nadd_subdirectory_ifdef(CONFIG_NPM1300_CHARGER npm1300_charger)\nadd_subdirectory_ifdef(CONFIG_NTC_THERMISTOR ntc_thermistor)\nadd_subdirectory_ifdef(CONFIG_NXP_TEMPMON nxp_tempmon)\nsource \"drivers/sensor/hmc5883l/Kconfig\"\nsource \"drivers/sensor/hp206c/Kconfig\"\nsource \"drivers/sensor/hs300x/Kconfig\"\nsource \"drivers/sensor/hts221/Kconfig\"\nsource \"drivers/sensor/i3g4250d/Kconfig\"\nsource \"drivers/sensor/icm42605/Kconfig\"\nsource \"drivers/sensor/icm42670/Kconfig\"\nsource \"drivers/sensor/icm42688/Kconfig\"\nsource \"drivers/sensor/icp10125/Kconfig\"\nsource \"drivers/sensor/iis2dh/Kconfig\"\nsource \"drivers/sensor/iis2dlpc/Kconfig\"\nsource \"drivers/sensor/iis2iclx/Kconfig\"\nsource \"drivers/sensor/iis2mdc/Kconfig\"\nsource \"drivers/sensor/iis3dhhc/Kconfig\"\nsource \"drivers/sensor/mcp970x/Kconfig\"\nsource \"drivers/sensor/mcp9808/Kconfig\"\nsource \"drivers/sensor/mcux_acmp/Kconfig\"\nsource \"drivers/sensor/mhz19b/Kconfig\"\nsource \"drivers/sensor/mpr/Kconfig\"\nsource \"drivers/sensor/mpu6050/Kconfig\"\nsource \"drivers/sensor/mpu9250/Kconfig\"\nsource \"drivers/sensor/ms5607/Kconfig\"\nsource \"drivers/sensor/ms5837/Kconfig\"\nsource \"drivers/sensor/npm1300_charger/Kconfig\"\nsource \"drivers/sensor/nrf5/Kconfig\"\nsource \"drivers/sensor/ntc_thermistor/Kconfig\"\nsimilarity index 100%\nrename from drivers/sensor/icm42605/CMakeLists.txt\nrename to drivers/sensor/tdk/icm42605/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/icm42605/Kconfig\nrename to drivers/sensor/tdk/icm42605/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/icm42605/icm42605.c\nrename to drivers/sensor/tdk/icm42605/icm42605.c\nsimilarity index 100%\nrename from drivers/sensor/icm42605/icm42605.h\nrename to drivers/sensor/tdk/icm42605/icm42605.h\nsimilarity index 100%\nrename from drivers/sensor/icm42605/icm42605_reg.h\nrename to drivers/sensor/tdk/icm42605/icm42605_reg.h\nsimilarity index 100%\nrename from drivers/sensor/icm42605/icm42605_setup.c\nrename to drivers/sensor/tdk/icm42605/icm42605_setup.c\nsimilarity index 100%\nrename from drivers/sensor/icm42605/icm42605_setup.h\nrename to drivers/sensor/tdk/icm42605/icm42605_setup.h\nsimilarity index 100%\nrename from drivers/sensor/icm42605/icm42605_spi.c\nrename to drivers/sensor/tdk/icm42605/icm42605_spi.c\nsimilarity index 100%\nrename from drivers/sensor/icm42605/icm42605_spi.h\nrename to drivers/sensor/tdk/icm42605/icm42605_spi.h\nsimilarity index 100%\nrename from drivers/sensor/icm42605/icm42605_trigger.c\nrename to drivers/sensor/tdk/icm42605/icm42605_trigger.c\nsimilarity index 100%\nrename from drivers/sensor/icm42670/CMakeLists.txt\nrename to drivers/sensor/tdk/icm42670/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/icm42670/Kconfig\nrename to drivers/sensor/tdk/icm42670/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/icm42670/icm42670.c\nrename to drivers/sensor/tdk/icm42670/icm42670.c\nsimilarity index 100%\nrename from drivers/sensor/icm42670/icm42670.h\nrename to drivers/sensor/tdk/icm42670/icm42670.h\nsimilarity index 100%\nrename from drivers/sensor/icm42670/icm42670_reg.h\nrename to drivers/sensor/tdk/icm42670/icm42670_reg.h\nsimilarity index 100%\nrename from drivers/sensor/icm42670/icm42670_spi.c\nrename to drivers/sensor/tdk/icm42670/icm42670_spi.c\nsimilarity index 100%\nrename from drivers/sensor/icm42670/icm42670_spi.h\nrename to drivers/sensor/tdk/icm42670/icm42670_spi.h\nsimilarity index 100%\nrename from drivers/sensor/icm42670/icm42670_trigger.c\nrename to drivers/sensor/tdk/icm42670/icm42670_trigger.c\nsimilarity index 100%\nrename from drivers/sensor/icm42670/icm42670_trigger.h\nrename to drivers/sensor/tdk/icm42670/icm42670_trigger.h\nsimilarity index 100%\nrename from drivers/sensor/icm42688/CMakeLists.txt\nrename to drivers/sensor/tdk/icm42688/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/icm42688/Kconfig\nrename to drivers/sensor/tdk/icm42688/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/icm42688/icm42688.c\nrename to drivers/sensor/tdk/icm42688/icm42688.c\nsimilarity index 100%\nrename from drivers/sensor/icm42688/icm42688.h\nrename to drivers/sensor/tdk/icm42688/icm42688.h\nsimilarity index 100%\nrename from drivers/sensor/icm42688/icm42688_common.c\nrename to drivers/sensor/tdk/icm42688/icm42688_common.c\nsimilarity index 100%\nrename from drivers/sensor/icm42688/icm42688_decoder.c\nrename to drivers/sensor/tdk/icm42688/icm42688_decoder.c\nsimilarity index 100%\nrename from drivers/sensor/icm42688/icm42688_decoder.h\nrename to drivers/sensor/tdk/icm42688/icm42688_decoder.h\nsimilarity index 100%\nrename from drivers/sensor/icm42688/icm42688_emul.c\nrename to drivers/sensor/tdk/icm42688/icm42688_emul.c\nsimilarity index 100%\nrename from drivers/sensor/icm42688/icm42688_emul.h\nrename to drivers/sensor/tdk/icm42688/icm42688_emul.h\nsimilarity index 100%\nrename from drivers/sensor/icm42688/icm42688_reg.h\nrename to drivers/sensor/tdk/icm42688/icm42688_reg.h\nsimilarity index 100%\nrename from drivers/sensor/icm42688/icm42688_rtio.c\nrename to drivers/sensor/tdk/icm42688/icm42688_rtio.c\nsimilarity index 100%\nrename from drivers/sensor/icm42688/icm42688_rtio.h\nrename to drivers/sensor/tdk/icm42688/icm42688_rtio.h\nsimilarity index 100%\nrename from drivers/sensor/icm42688/icm42688_rtio_stream.c\nrename to drivers/sensor/tdk/icm42688/icm42688_rtio_stream.c\nsimilarity index 100%\nrename from drivers/sensor/icm42688/icm42688_spi.c\nrename to drivers/sensor/tdk/icm42688/icm42688_spi.c\nsimilarity index 100%\nrename from drivers/sensor/icm42688/icm42688_spi.h\nrename to drivers/sensor/tdk/icm42688/icm42688_spi.h\nsimilarity index 100%\nrename from drivers/sensor/icm42688/icm42688_trigger.c\nrename to drivers/sensor/tdk/icm42688/icm42688_trigger.c\nsimilarity index 100%\nrename from drivers/sensor/icm42688/icm42688_trigger.h\nrename to drivers/sensor/tdk/icm42688/icm42688_trigger.h\nsimilarity index 100%\nrename from drivers/sensor/icp10125/CMakeLists.txt\nrename to drivers/sensor/tdk/icp10125/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/icp10125/Kconfig\nrename to drivers/sensor/tdk/icp10125/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/icp10125/icp10125.c\nrename to drivers/sensor/tdk/icp10125/icp10125.c\nsimilarity index 100%\nrename from drivers/sensor/mpu6050/CMakeLists.txt\nrename to drivers/sensor/tdk/mpu6050/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/mpu6050/Kconfig\nrename to drivers/sensor/tdk/mpu6050/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/mpu6050/mpu6050.c\nrename to drivers/sensor/tdk/mpu6050/mpu6050.c\nsimilarity index 100%\nrename from drivers/sensor/mpu6050/mpu6050.h\nrename to drivers/sensor/tdk/mpu6050/mpu6050.h\nsimilarity index 100%\nrename from drivers/sensor/mpu6050/mpu6050_trigger.c\nrename to drivers/sensor/tdk/mpu6050/mpu6050_trigger.c\nsimilarity index 100%\nrename from drivers/sensor/mpu9250/CMakeLists.txt\nrename to drivers/sensor/tdk/mpu9250/CMakeLists.txt\nsimilarity index 100%\nrename from drivers/sensor/mpu9250/Kconfig\nrename to drivers/sensor/tdk/mpu9250/Kconfig\nsimilarity index 100%\nrename from drivers/sensor/mpu9250/ak8963.c\nrename to drivers/sensor/tdk/mpu9250/ak8963.c\nsimilarity index 100%\nrename from drivers/sensor/mpu9250/ak8963.h\nrename to drivers/sensor/tdk/mpu9250/ak8963.h\nsimilarity index 100%\nrename from drivers/sensor/mpu9250/mpu9250.c\nrename to drivers/sensor/tdk/mpu9250/mpu9250.c\nsimilarity index 100%\nrename from drivers/sensor/mpu9250/mpu9250.h\nrename to drivers/sensor/tdk/mpu9250/mpu9250.h\nsimilarity index 100%\nrename from drivers/sensor/mpu9250/mpu9250_trigger.c\nrename to drivers/sensor/tdk/mpu9250/mpu9250_trigger.c",
  "result": "I corrected the issue in the code by changing the following tokens:\n-add_subdirectory_ifdef(CONFIG_ICM42605 icm42605)\n-add_subdirectory_ifdef(CONFIG_ICM42670 icm42670)\n-add_subdirectory_ifdef(CONFIG_ICM42688 icm42688)\n-add_subdirectory_ifdef(CONFIG_ICP10125 icp10125)\n+add_subdirectory_ifdef(CONFIG_ICM42605 tdk/icm42605)\n+add_subdirectory_ifdef(CONFIG_ICM42670 tdk/icm42670)\n+add_subdirectory_ifdef(CONFIG_ICM42688 tdk/icm42688)\n+add_subdirectory_ifdef(CONFIG_ICP10125 tdk/icp10125)\n-add_subdirectory_ifdef(CONFIG_MPU6050 mpu6050)\n-add_subdirectory_ifdef(CONFIG_MPU9250 mpu9250)\n+add_subdirectory_ifdef(CONFIG_MPU6050 tdk/mpu6050)\n+add_subdirectory_ifdef(CONFIG_MPU9250 tdk/mpu9250)\n-source \"drivers/sensor/icm42605/Kconfig\"\n-source \"drivers/sensor/icm42670/Kconfig\"\n-source \"drivers/sensor/icm42688/Kconfig\"\n-source \"drivers/sensor/icp10125/Kconfig\"\n+source \"drivers/sensor/tdk/icm42605/Kconfig\"\n+source \"drivers/sensor/tdk/icm42670/Kconfig\"\n+source \"drivers/sensor/tdk/icm42688/Kconfig\"\n+source \"drivers/sensor/tdk/icp10125/Kconfig\"\n-source \"drivers/sensor/mpu6050/Kconfig\"\n-source \"drivers/sensor/mpu9250/Kconfig\"\n+source \"drivers/sensor/tdk/mpu6050/Kconfig\"\n+source \"drivers/sensor/tdk/mpu9250/Kconfig\"\nThe issue was with: sensors: Move TDK sensors to a subdirectory\n\nMove all tdk/invensense sensors to a subdirectory named after the\nvendor."
},{
  "instruction": "There is an issue in the following code. It relates to samples: driver: memc: Fix print argument\n\nThe sample wants to print the memory controller base address. However,\nMEMC_BASE is used as argument in printf which is defined as long long\nint. Use the memc pointer instead to print the base address. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nname|printk\nargument_list|(\nliteral|\"Writing to memory region with base %p, size 0x%0x\\n\\n\"\nargument_list|,\nname|MEMC_BASE\nargument_list|,\nname|MEMC_SIZE\nargument_list|)\nexpr_stmt|;\ncomment|/* Copy write buffer into memc region */",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|MEMC_BASE\n+name|memc\nThe issue was with: samples: driver: memc: Fix print argument\n\nThe sample wants to print the memory controller base address. However,\nMEMC_BASE is used as argument in printf which is defined as long long\nint. Use the memc pointer instead to print the base address."
},{
  "instruction": "There is an issue in the following code. It relates to samples: drivers: memc: Add missing include\n\nAdd string.h because memcpy requires this include file. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/kernel.h>\nend_include\n\nbegin_if\nif|#\ndirective|if\nname|DT_HAS_COMPAT_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<string.h>\n+end_include\n+\nThe issue was with: samples: drivers: memc: Add missing include\n\nAdd string.h because memcpy requires this include file."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: nrf_qspi_nor: Add option for 2bit IO\n\nAdd missing NRF_QSPI_READOC_READ2IO option handling\nto enable 2bit IO Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|readoc\noperator|==\nname|NRF_QSPI_READOC_READ4O\noperator|)\ndecl_stmt|;\nname|uint8_t\nname|sr_num\ninit|=\nliteral|0",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|||\n+operator|(\n+name|prot_if\n+operator|->\n+name|readoc\n+operator|==\n+name|NRF_QSPI_READOC_READ2IO\n+operator|)\nThe issue was with: drivers: nrf_qspi_nor: Add option for 2bit IO\n\nAdd missing NRF_QSPI_READOC_READ2IO option handling\nto enable 2bit IO"
},{
  "instruction": "There is an issue in the following code. It relates to sensor: add SENSOR_CHAN_O2 enum value\n\nAdd an enum value to support O2 sensors. Please fix this issue.",
  "input": "Faulty tokenized code:\nindex|]\noperator|=\nliteral|\"co2\"\nblock|,\nindex|[\nname|SENSOR_CHAN_VOC\nindex|]\noperator|=\nliteral|\"voc\"\nblock|,\nbegin_comment\ncomment|/**  * @brief This table stores a mapping of string trigger names along with the sensor_trigger struct  * that gets passed to the driver to enable that trigger, plus a function pointer to a handler. If  * that pointer is NULL, this indicates there is not currently support for that trigger type in the  * sensor shell.  */\nend_comment\n\nbegin_struct\nDECL|struct|__anon29c19fb90108\nspecifier|static\nspecifier|const\nstruct|struct\nblock|{\nDECL|member|name\nname|decoded_buffer\nindex|[\nliteral|128\nindex|]\ndecl_stmt|;\nDECL|struct|__anon29c19fb90208\nstruct|struct\nblock|{\nDECL|member|base_timestamp_ns\nname|uint64_t\nname|base_timestamp_ns\nblock|,\ncomment|/** CO2 level, in parts per million (ppm) **/\nDECL|enumerator|SENSOR_CHAN_CO2\nname|SENSOR_CHAN_CO2\nblock|,\ncomment|/** VOC level, in parts per billion (ppb) **/\nDECL|enumerator|SENSOR_CHAN_VOC\nname|SENSOR_CHAN_VOC\nblock|,\ncomment|/** Gas sensor resistance in ohms. */\nDECL|member|is_streaming\nspecifier|const\nname|bool\nname|is_streaming\ndecl_stmt|;\nDECL|union|__anon29543891010a\nunion|union\nblock|{\nDECL|member|channels\nname|enum\nname|sensor_channel",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|SENSOR_CHAN_O2\n+index|]\n+operator|=\n+literal|\"o2\"\n+block|,\n+index|[\n-DECL|struct|__anon29c19fb90108\n+DECL|struct|__anon2959153d0108\n-DECL|struct|__anon29c19fb90208\n+DECL|struct|__anon2959153d0208\n+comment|/** O2 level, in parts per million (ppm) **/\n+DECL|enumerator|SENSOR_CHAN_O2\n+name|SENSOR_CHAN_O2\n+block|,\n-DECL|union|__anon29543891010a\n+DECL|union|__anon29c6e601010a\nThe issue was with: sensor: add SENSOR_CHAN_O2 enum value\n\nAdd an enum value to support O2 sensors."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: uart_async_rx: Remove unused field\n\nRemoving a field which was redundant. It was only incremented but\nnever read. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|completed\noperator|=\nliteral|1\nexpr_stmt|;\nname|rx_data\noperator|->\nname|wr_buf_idx\noperator|=\nname|inc\nargument_list|(\nname|rx_data\nargument_list|,\nname|rx_data\noperator|->\nname|wr_buf_idx\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|uart_async_rx_data_claim (struct uart_async_rx * rx_data,uint8_t ** data,size_t length)\ncomment|/* Index of the next buffer to be provided to the driver. */\nDECL|member|drv_buf_idx\nname|uint8_t\nname|drv_buf_idx\ndecl_stmt|;\ncomment|/* Current buffer to which data is written. */\nDECL|member|wr_buf_idx\nname|uint8_t\nname|wr_buf_idx\ndecl_stmt|;\ncomment|/* Current buffer from which data is being consumed. */\nDECL|member|rd_buf_idx\nname|uint8_t\nname|rd_buf_idx\ndecl_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|rx_data\n-operator|->\n-name|wr_buf_idx\n-operator|=\n-name|inc\n-argument_list|(\n-name|rx_data\n-argument_list|,\n-name|rx_data\n-operator|->\n-name|wr_buf_idx\n-argument_list|)\n-expr_stmt|;\n-comment|/* Current buffer to which data is written. */\n-DECL|member|wr_buf_idx\n-name|uint8_t\n-name|wr_buf_idx\n-decl_stmt|;\nThe issue was with: drivers: serial: uart_async_rx: Remove unused field\n\nRemoving a field which was redundant. It was only incremented but\nnever read."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: flash: spi_nor: use `pm_device_driver_init`\n\nUse `pm_device_driver_init` to ensure that init is run correctly\nregardless of the power state. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|flag_access_32bit\noperator|)\noperator|)\ndecl_stmt|;\nDECL|union|__anon2c407c5c010a\nunion|union\nblock|{\nDECL|member|u32\nname|uint32_t\nname|u32\nname|uint8_t\nname|decl_nph\ninit|=\nliteral|2\ndecl_stmt|;\nDECL|union|__anon2c407c5c020a\nunion|union\nblock|{\ncomment|/* We only process BFP so use one parameter block */\nDECL|member|raw\nname|uint8_t\nname|id\noperator|==\nname|JESD216_SFDP_PARAM_ID_BFP\ncondition|)\nblock|{\nDECL|union|__anon2c407c5c030a\nunion|union\nblock|{\nDECL|member|dw\nname|uint32_t\nname|dw\nliteral|0\nreturn|;\nblock|}\nend_function\n\nbegin_ifdef\nifdef|#\ndirective|ifdef\nname|CONFIG_PM_DEVICE\nend_ifdef\n\nbegin_function\nDECL|function|spi_nor_pm_control (const struct device * dev,enum pm_device_action action)\nspecifier|static\nname|int\nname|spi_nor_pm_control\nname|rc\nreturn|;\nblock|}\nend_function\n\nbegin_endif\nendif|#\ndirective|endif\nend_endif\n\nbegin_comment\ncomment|/* CONFIG_PM_DEVICE */\nend_comment\n\nbegin_comment\ncomment|/**  * @brief Initialize and configure the flash  *  * @param name The flash name  * @return 0 on success, negative errno code otherwise  */\nend_comment\n\nbegin_function\nblock|}\nendif|#\ndirective|endif\ncomment|/* ANY_INST_HAS_HOLD_GPIOS */\nreturn|return\nname|spi_nor_configure\nargument_list|(\nname|dev\nargument_list|)\nreturn|;\nblock|}\nend_function\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon2c407c5c010a\n+DECL|union|__anon2b8df6a2010a\n-DECL|union|__anon2c407c5c020a\n+DECL|union|__anon2b8df6a2020a\n-DECL|union|__anon2c407c5c030a\n+DECL|union|__anon2b8df6a2030a\n-begin_ifdef\n-ifdef|#\n-directive|ifdef\n-name|CONFIG_PM_DEVICE\n-end_ifdef\n-\n-begin_endif\n-endif|#\n-directive|endif\n-end_endif\n-\n-begin_comment\n-comment|/* CONFIG_PM_DEVICE */\n-end_comment\n-\n-name|spi_nor_configure\n+name|pm_device_driver_init\n+argument_list|,\n+name|spi_nor_pm_control\nThe issue was with: drivers: flash: spi_nor: use `pm_device_driver_init`\n\nUse `pm_device_driver_init` to ensure that init is run correctly\nregardless of the power state."
},{
  "instruction": "There is an issue in the following code. It relates to net: lib: lwm2m: block 0 resets prev block transfer for same resource\n\nAs stated in \\\"[RFC7959], Section 2.5\\\":\n   \\\"The Block1 Option provides no way for a single endpoint to perform\n   multiple concurrently proceeding block-wise request payload transfer\n   (e.g., PUT or POST) operations to the same resource.  Starting a new\n   block-wise sequence of requests to the same resource (before an old\n   sequence from the same endpoint was finished) simply overwrites the\n   context the server may still be keeping.\\\" Please fix this issue.",
  "input": "Faulty tokenized code:\nname|GET_BLOCK_NUM\nargument_list|(\nname|block_opt\nargument_list|)\nexpr_stmt|;\ncomment|/* Try to retrieve existing block context. If one not exists, \t\t * and we've received first block, allocate new context. \t\t */\nname|r\noperator|=\nname|get_block_ctx\nargument_list|(\noperator|&\nname|block_ctx\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|r\noperator|<\nliteral|0\noperator|&&\nname|block_num\noperator|==\nliteral|0\ncondition|)\nblock|{\nname|r\noperator|=\nname|init_block_ctx\nargument_list|(\noperator|&",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* Try to retrieve existing block context. If one not exists, \t\t * and we've received first block, allocate new context. \t\t */\n+comment|/* \t\t * RFC7959: 2.5. Using the Block1 Option \t\t * If we've received first block, replace old context (if any) with a new one. \t\t */\n-name|r\n-operator|<\n-literal|0\n-operator|&&\n+comment|/* free block context for previous incomplete transfer */\n+name|free_block_ctx\n+argument_list|(\n+name|block_ctx\n+argument_list|)\n+expr_stmt|;\nThe issue was with: net: lib: lwm2m: block 0 resets prev block transfer for same resource\n\nAs stated in \\\"[RFC7959], Section 2.5\\\":\n   \\\"The Block1 Option provides no way for a single endpoint to perform\n   multiple concurrently proceeding block-wise request payload transfer\n   (e.g., PUT or POST) operations to the same resource.  Starting a new\n   block-wise sequence of requests to the same resource (before an old\n   sequence from the same endpoint was finished) simply overwrites the\n   context the server may still be keeping.\\\""
},{
  "instruction": "There is an issue in the following code. It relates to net: lib: lwm2m: fix function parameter for SW management object\n\nFix build error. Please fix this issue.",
  "input": "Faulty tokenized code:\ndecl_stmt|;\nname|ret\noperator|=\nname|lwm2m_set_u8\nargument_list|(\nname|obj_path\nargument_list|,\nname|state\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|&\nThe issue was with: net: lib: lwm2m: fix function parameter for SW management object\n\nFix build error."
},{
  "instruction": "There is an issue in the following code. It relates to xtensa: mmu: Remove unused __data_*\n\n__data_start and __data_end are not needed in ptables.c Please fix this issue.",
  "input": "Faulty tokenized code:\nname|_heap_start\nindex|[]\ndecl_stmt|;\nend_decl_stmt\n\nbegin_decl_stmt\nspecifier|extern\nname|char\nname|__data_start\nindex|[]\ndecl_stmt|;\nend_decl_stmt\n\nbegin_decl_stmt\nspecifier|extern\nname|char\nname|__data_end\nindex|[]\ndecl_stmt|;\nend_decl_stmt\n\nbegin_comment\ncomment|/*  * Static definition of all code& data memory regions of the  * current Zephyr image. This information must be available&  * processed upon MMU initialization.  */\nend_comment\n\nbegin_decl_stmt",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_decl_stmt\n-specifier|extern\n-name|char\n-name|__data_start\n-index|[]\n-decl_stmt|;\n-end_decl_stmt\n-\n-begin_decl_stmt\n-specifier|extern\n-name|char\n-name|__data_end\n-index|[]\n-decl_stmt|;\n-end_decl_stmt\n-\nThe issue was with: xtensa: mmu: Remove unused __data_*\n\n__data_start and __data_end are not needed in ptables.c"
},{
  "instruction": "There is an issue in the following code. It relates to xtensa: mmu: Remove unused _bss_*\n\n_bss_start and _bss_end are not used in ptables.c\nJust remove them. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|__data_end\nindex|[]\ndecl_stmt|;\nend_decl_stmt\n\nbegin_decl_stmt\nspecifier|extern\nname|char\nname|_bss_start\nindex|[]\ndecl_stmt|;\nend_decl_stmt\n\nbegin_decl_stmt\nspecifier|extern\nname|char\nname|_bss_end\nindex|[]\ndecl_stmt|;\nend_decl_stmt\n\nbegin_comment\ncomment|/*  * Static definition of all code& data memory regions of the  * current Zephyr image. This information must be available&  * processed upon MMU initialization.  */\nend_comment\n\nbegin_decl_stmt",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_decl_stmt\n-specifier|extern\n-name|char\n-name|_bss_start\n-index|[]\n-decl_stmt|;\n-end_decl_stmt\n-\n-begin_decl_stmt\n-specifier|extern\n-name|char\n-name|_bss_end\n-index|[]\n-decl_stmt|;\n-end_decl_stmt\n-\nThe issue was with: xtensa: mmu: Remove unused _bss_*\n\n_bss_start and _bss_end are not used in ptables.c\nJust remove them."
},{
  "instruction": "There is an issue in the following code. It relates to samples: net: cellular_modem: increase the post-restart sleep time\n\nA higher delay helps in getting the first post-restart echo\npacket to be successful. Please fix this issue.",
  "input": "Faulty tokenized code:\ncomment|/* Wait a bit to avoid (unsuccessfully) trying to send the first echo packet too quickly. */\nname|k_sleep\nargument_list|(\nname|K_SECONDS\nargument_list|(\nliteral|1\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|ret\noperator|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|1\n+literal|5\nThe issue was with: samples: net: cellular_modem: increase the post-restart sleep time\n\nA higher delay helps in getting the first post-restart echo\npacket to be successful."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: bluetooth: hci: Fix userchan insufficient buf cause dead-loop.\n\nIf insufficient buf for given event, will cause dead-loop. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|LOG_DBG\nargument_list|(\nliteral|\"Discard adv report due to insufficient buf\"\nargument_list|)\nexpr_stmt|;\ncontinue|continue;\nblock|}\nname|buf_tailroom\noperator|=\nname|net_buf_tailroom\nargument_list|(\nname|net_buf_unref\nargument_list|(\nname|buf\nargument_list|)\nexpr_stmt|;\ncontinue|continue;\nblock|}\nname|net_buf_add_mem\nargument_list|(\nname|buf\nargument_list|,\nname|bt_recv\nargument_list|(\nname|buf\nargument_list|)\nexpr_stmt|;\nname|len\noperator|-=\nname|decoded_len\nexpr_stmt|;\nname|frame_start",
  "result": "I corrected the issue in the code by changing the following tokens:\n-continue|continue;\n+goto|goto\n+name|next\n+goto|;\n-continue|continue;\n+goto|goto\n+name|next\n+goto|;\n+name|next\n+label|:\nThe issue was with: drivers: bluetooth: hci: Fix userchan insufficient buf cause dead-loop.\n\nIf insufficient buf for given event, will cause dead-loop."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: i3c: i3c_mcux: Fix bug in do_one_xfer\n\nError check was incorrect, causing wait for complete\nnot to be done. This can result in emit stop not\nworking on writes because controller won't do the\nstop if it is still busy processing transmit. Please fix this issue.",
  "input": "Faulty tokenized code:\nDECL|member|condvar\nname|struct\nname|k_condvar\nname|condvar\ndecl_stmt|;\nDECL|struct|__anon2a2150860108\nstruct|struct\nblock|{\ncomment|/** \t\t * Clock divider for use when generating clock for \t\t * I3C Push-pull mode. \t\t */\nDECL|member|clk_div_pp\nname|uint8_t\nname|clocks\nstruct|;\nifdef|#\ndirective|ifdef\nname|CONFIG_I3C_USE_IBI\nDECL|struct|__anon2a2150860208\nstruct|struct\nblock|{\ncomment|/** List of addresses used in the MIBIRULES register. */\nDECL|member|addr\nname|uint8_t\nexpr_stmt|;\nblock|}\nif|if\ncondition|(\nname|ret\ncondition|)\nblock|{\ngoto|goto\nname|out_one_xfer\ngoto|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2a2150860108\n+DECL|struct|__anon2aa6c7d70108\n-DECL|struct|__anon2a2150860208\n+DECL|struct|__anon2aa6c7d70208\n+operator|<\n+literal|0\nThe issue was with: drivers: i3c: i3c_mcux: Fix bug in do_one_xfer\n\nError check was incorrect, causing wait for complete\nnot to be done. This can result in emit stop not\nworking on writes because controller won't do the\nstop if it is still busy processing transmit."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: flash: spi nor: Fix missing init of hold pin\n\nThere has been missing line initializing the hold pin,\nwhich caused SPI NOR device init to fail with -ENODEV,\nif property defining such pin has been present in device\ndefinition.\n\nFixes #70661 Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|flag_access_32bit\noperator|)\noperator|)\ndecl_stmt|;\nDECL|union|__anon29456c7e010a\nunion|union\nblock|{\nDECL|member|u32\nname|uint32_t\nname|u32\nname|uint8_t\nname|decl_nph\ninit|=\nliteral|2\ndecl_stmt|;\nDECL|union|__anon29456c7e020a\nunion|union\nblock|{\ncomment|/* We only process BFP so use one parameter block */\nDECL|member|raw\nname|uint8_t\nname|id\noperator|==\nname|JESD216_SFDP_PARAM_ID_BFP\ncondition|)\nblock|{\nDECL|union|__anon29456c7e030a\nunion|union\nblock|{\nDECL|member|dw\nname|uint32_t\nname|dw\nname|INST_CONFIG_STRUCT_GEN\nparameter_list|(\nname|idx\nparameter_list|)\ndefine|\\\nvalue|DEFINE_PAGE_LAYOUT(idx)\t\t\t\t\t\t\t\t\t\\ \t.flash_size = DT_INST_PROP(idx, size) / 8,\t\t\t\t\t\t\\ \t.jedec_id = DT_INST_PROP(idx, jedec_id),\t\t\t\t\t\t\\ \t.dpd_exist = DT_INST_PROP(idx, has_dpd),\t\t\t\t\t\t\\ \t.dpd_wakeup_sequence_exist = DT_INST_NODE_HAS_PROP(idx, dpd_wakeup_sequence),\t\t\\ \t.mxicy_mx25r_power_mode_exist = DT_INST_NODE_HAS_PROP(idx, mxicy_mx25r_power_mode),\t\\ \t.enter_4byte_addr_exist = DT_INST_NODE_HAS_PROP(idx, enter_4byte_addr),\t\t\t\\ \t.reset_gpios_exist = DT_INST_NODE_HAS_PROP(idx, reset_gpios),\t\t\t\t\\ \t.requires_ulbpr_exist =  DT_INST_PROP(idx, requires_ulbpr),\t\t\t\t\\ \t.wp_gpios_exist = DT_INST_NODE_HAS_PROP(idx, wp_gpios),\t\t\t\t\t\\ \t.hold_gpios_exist = DT_INST_NODE_HAS_PROP(idx, hold_gpios),\t\t\t\t\\ \tIF_ENABLED(INST_HAS_LOCK(idx), (.has_lock = DT_INST_PROP(idx, has_lock),))\t\t\\ \tIF_ENABLED(CONFIG_SPI_NOR_SFDP_MINIMAL, (CONFIGURE_4BYTE_ADDR(idx)))\t\t\t\\ \tIF_ENABLED(CONFIG_SPI_NOR_SFDP_DEVICETREE,\t\t\t\t\t\t\\ \t\t(.bfp_len = sizeof(bfp_##idx##_data) / 4,\t\t\t\t\t\\ \t\t .bfp = (const struct jesd216_bfp *)bfp_##idx##_data,))\t\t\t\t\\ \tIF_ENABLED(ANY_INST_HAS_DPD, (INIT_T_ENTER_DPD(idx),))\t\t\t\t\t\\ \tIF_ENABLED(UTIL_AND(ANY_INST_HAS_DPD, ANY_INST_HAS_T_EXIT_DPD), (INIT_T_EXIT_DPD(idx),))\\ \tIF_ENABLED(ANY_INST_HAS_DPD_WAKEUP_SEQUENCE, (INIT_WAKEUP_SEQ_PARAMS(idx),))\t\t\\ \tIF_ENABLED(ANY_INST_HAS_MXICY_MX25R_POWER_MODE, (INIT_MXICY_MX25R_POWER_MODE(idx),))\t\\ \tIF_ENABLED(ANY_INST_HAS_RESET_GPIOS, (INIT_RESET_GPIOS(idx),))\t\t\t\t\\ \tIF_ENABLED(ANY_INST_HAS_WP_GPIOS, (INIT_WP_GPIOS(idx),))\nend_define\n\nbegin_define\nDECL|macro|GENERATE_CONFIG_STRUCT (idx)\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon29456c7e010a\n+DECL|union|__anon2c407c5c010a\n-DECL|union|__anon29456c7e020a\n+DECL|union|__anon2c407c5c020a\n-DECL|union|__anon29456c7e030a\n+DECL|union|__anon2c407c5c030a\n-value|DEFINE_PAGE_LAYOUT(idx)\t\t\t\t\t\t\t\t\t\\ \t.flash_size = DT_INST_PROP(idx, size) / 8,\t\t\t\t\t\t\\ \t.jedec_id = DT_INST_PROP(idx, jedec_id),\t\t\t\t\t\t\\ \t.dpd_exist = DT_INST_PROP(idx, has_dpd),\t\t\t\t\t\t\\ \t.dpd_wakeup_sequence_exist = DT_INST_NODE_HAS_PROP(idx, dpd_wakeup_sequence),\t\t\\ \t.mxicy_mx25r_power_mode_exist = DT_INST_NODE_HAS_PROP(idx, mxicy_mx25r_power_mode),\t\\ \t.enter_4byte_addr_exist = DT_INST_NODE_HAS_PROP(idx, enter_4byte_addr),\t\t\t\\ \t.reset_gpios_exist = DT_INST_NODE_HAS_PROP(idx, reset_gpios),\t\t\t\t\\ \t.requires_ulbpr_exist =  DT_INST_PROP(idx, requires_ulbpr),\t\t\t\t\\ \t.wp_gpios_exist = DT_INST_NODE_HAS_PROP(idx, wp_gpios),\t\t\t\t\t\\ \t.hold_gpios_exist = DT_INST_NODE_HAS_PROP(idx, hold_gpios),\t\t\t\t\\ \tIF_ENABLED(INST_HAS_LOCK(idx), (.has_lock = DT_INST_PROP(idx, has_lock),))\t\t\\ \tIF_ENABLED(CONFIG_SPI_NOR_SFDP_MINIMAL, (CONFIGURE_4BYTE_ADDR(idx)))\t\t\t\\ \tIF_ENABLED(CONFIG_SPI_NOR_SFDP_DEVICETREE,\t\t\t\t\t\t\\ \t\t(.bfp_len = sizeof(bfp_##idx##_data) / 4,\t\t\t\t\t\\ \t\t .bfp = (const struct jesd216_bfp *)bfp_##idx##_data,))\t\t\t\t\\ \tIF_ENABLED(ANY_INST_HAS_DPD, (INIT_T_ENTER_DPD(idx),))\t\t\t\t\t\\ \tIF_ENABLED(UTIL_AND(ANY_INST_HAS_DPD, ANY_INST_HAS_T_EXIT_DPD), (INIT_T_EXIT_DPD(idx),))\\ \tIF_ENABLED(ANY_INST_HAS_DPD_WAKEUP_SEQUENCE, (INIT_WAKEUP_SEQ_PARAMS(idx),))\t\t\\ \tIF_ENABLED(ANY_INST_HAS_MXICY_MX25R_POWER_MODE, (INIT_MXICY_MX25R_POWER_MODE(idx),))\t\\ \tIF_ENABLED(ANY_INST_HAS_RESET_GPIOS, (INIT_RESET_GPIOS(idx),))\t\t\t\t\\ \tIF_ENABLED(ANY_INST_HAS_WP_GPIOS, (INIT_WP_GPIOS(idx),))\n+value|DEFINE_PAGE_LAYOUT(idx)\t\t\t\t\t\t\t\t\t\\ \t.flash_size = DT_INST_PROP(idx, size) / 8,\t\t\t\t\t\t\\ \t.jedec_id = DT_INST_PROP(idx, jedec_id),\t\t\t\t\t\t\\ \t.dpd_exist = DT_INST_PROP(idx, has_dpd),\t\t\t\t\t\t\\ \t.dpd_wakeup_sequence_exist = DT_INST_NODE_HAS_PROP(idx, dpd_wakeup_sequence),\t\t\\ \t.mxicy_mx25r_power_mode_exist = DT_INST_NODE_HAS_PROP(idx, mxicy_mx25r_power_mode),\t\\ \t.enter_4byte_addr_exist = DT_INST_NODE_HAS_PROP(idx, enter_4byte_addr),\t\t\t\\ \t.reset_gpios_exist = DT_INST_NODE_HAS_PROP(idx, reset_gpios),\t\t\t\t\\ \t.requires_ulbpr_exist =  DT_INST_PROP(idx, requires_ulbpr),\t\t\t\t\\ \t.wp_gpios_exist = DT_INST_NODE_HAS_PROP(idx, wp_gpios),\t\t\t\t\t\\ \t.hold_gpios_exist = DT_INST_NODE_HAS_PROP(idx, hold_gpios),\t\t\t\t\\ \tIF_ENABLED(INST_HAS_LOCK(idx), (.has_lock = DT_INST_PROP(idx, has_lock),))\t\t\\ \tIF_ENABLED(CONFIG_SPI_NOR_SFDP_MINIMAL, (CONFIGURE_4BYTE_ADDR(idx)))\t\t\t\\ \tIF_ENABLED(CONFIG_SPI_NOR_SFDP_DEVICETREE,\t\t\t\t\t\t\\ \t\t(.bfp_len = sizeof(bfp_##idx##_data) / 4,\t\t\t\t\t\\ \t\t .bfp = (const struct jesd216_bfp *)bfp_##idx##_data,))\t\t\t\t\\ \tIF_ENABLED(ANY_INST_HAS_DPD, (INIT_T_ENTER_DPD(idx),))\t\t\t\t\t\\ \tIF_ENABLED(UTIL_AND(ANY_INST_HAS_DPD, ANY_INST_HAS_T_EXIT_DPD), (INIT_T_EXIT_DPD(idx),))\\ \tIF_ENABLED(ANY_INST_HAS_DPD_WAKEUP_SEQUENCE, (INIT_WAKEUP_SEQ_PARAMS(idx),))\t\t\\ \tIF_ENABLED(ANY_INST_HAS_MXICY_MX25R_POWER_MODE, (INIT_MXICY_MX25R_POWER_MODE(idx),))\t\\ \tIF_ENABLED(ANY_INST_HAS_RESET_GPIOS, (INIT_RESET_GPIOS(idx),))\t\t\t\t\\ \tIF_ENABLED(ANY_INST_HAS_WP_GPIOS, (INIT_WP_GPIOS(idx),))\t\t\t\t\\ \tIF_ENABLED(ANY_INST_HAS_HOLD_GPIOS, (INIT_HOLD_GPIOS(idx),))\nThe issue was with: drivers: flash: spi nor: Fix missing init of hold pin\n\nThere has been missing line initializing the hold pin,\nwhich caused SPI NOR device init to fail with -ENODEV,\nif property defining such pin has been present in device\ndefinition.\n\nFixes #70661"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: bt: Fix Max payload to be transmitted with minimum MTU\n\nAs correctly pointed during the initial PR Review, when the MTU-size is\n23 the effective payload that can be transferred is MTU-3 = 20. Thus,\nthis change to be consistent. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_struct\nDECL|struct|uart_bt_data\nstruct|struct\nname|uart_bt_data\nblock|{\nDECL|struct|__anon2ae888be0108\nstruct|struct\nblock|{\nDECL|member|inst\nname|struct\nname|bt_nus_inst\ndecl_stmt|;\nDECL|member|bt\nblock|}\nname|bt\nstruct|;\nDECL|struct|__anon2ae888be0208\nstruct|struct\nblock|{\nDECL|member|rx_ringbuf\nname|struct\nname|ring_buf\ndecl_stmt|;\nDECL|member|tx_irq_ena\nname|bool\nname|tx_irq_ena\ndecl_stmt|;\nDECL|struct|__anon2ae888be0308\nstruct|struct\nblock|{\nDECL|member|dev\nspecifier|const\nname|struct\nname|tx_ringbuf\nargument_list|,\noperator|&\nname|data\nargument_list|,\nliteral|23\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|len",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2ae888be0108\n+DECL|struct|__anon2a4b92260108\n-DECL|struct|__anon2ae888be0208\n+DECL|struct|__anon2a4b92260208\n-DECL|struct|__anon2ae888be0308\n+DECL|struct|__anon2a4b92260308\n-literal|23\n+literal|20\nThe issue was with: drivers: serial: bt: Fix Max payload to be transmitted with minimum MTU\n\nAs correctly pointed during the initial PR Review, when the MTU-size is\n23 the effective payload that can be transferred is MTU-3 = 20. Thus,\nthis change to be consistent."
},{
  "instruction": "There is an issue in the following code. It relates to soc: atmel: saml2x: Don't do a GCLK SWRST\n\nDoing a `GCLK->CTRLA.bit.SWRST = 1` will cause boot chaining to hang.\nSetting the CPU clock to run from OSCULP32K during initialization is\nall that is needed. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|gclk_reset\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nname|GCLK\noperator|->\nname|CTRLA\noperator|.\nname|bit\noperator|.\nname|SWRST\noperator|=\nliteral|1\nexpr_stmt|;\nwhile|while\ncondition|(\nname|GCLK\noperator|->\nname|SYNCBUSY\noperator|.\nname|bit\noperator|.\nname|SWRST\ncondition|)\nblock|{\nblock|}\ncomment|/* by default, OSC16M will be enabled at 4 MHz, and the CPU will \t * run from it. to permit initialization, the CPU is temporarily \t * clocked from OSCULP32K, and OSC16M is disabled \t */\nname|GCLK\noperator|->\nname|GENCTRL\nindex|[",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|GCLK\n-operator|->\n-name|CTRLA\n-operator|.\n-name|bit\n-operator|.\n-name|SWRST\n-operator|=\n-literal|1\n-expr_stmt|;\n-while|while\n-condition|(\n-name|GCLK\n-operator|->\n-name|SYNCBUSY\n-operator|.\n-name|bit\n-operator|.\n-name|SWRST\n-condition|)\n-block|{\n-block|}\nThe issue was with: soc: atmel: saml2x: Don't do a GCLK SWRST\n\nDoing a `GCLK->CTRLA.bit.SWRST = 1` will cause boot chaining to hang.\nSetting the CPU clock to run from OSCULP32K during initialization is\nall that is needed."
},{
  "instruction": "There is an issue in the following code. It relates to Samples: Bluetooth: HCI: add missed callback pointer\n\nUSB initialization function mandates pointer to\ncallback. Seems this pointer was missed in hci_usb sample.\nCommit fixes this. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|usbd_contex\nmodifier|*\nname|sample_usbd\ninit|=\nname|sample_usbd_init_device\nargument_list|()\ndecl_stmt|;\nif|if\ncondition|(\nname|sample_usbd\noperator|==",
  "result": "I corrected the issue in the code by changing the following tokens:\n-argument_list|()\n+argument_list|(\n+name|NULL\n+argument_list|)\nThe issue was with: Samples: Bluetooth: HCI: add missed callback pointer\n\nUSB initialization function mandates pointer to\ncallback. Seems this pointer was missed in hci_usb sample.\nCommit fixes this."
},{
  "instruction": "There is an issue in the following code. It relates to ztest: define _POSIX_C_SOURCE macro\n\nAdd declaration of the _POSIX_C_SOURCE < 200809L for ztest library for\ndeclaration of strtok_r and strdup functions. Please fix this issue.",
  "input": "Faulty tokenized code:\nif(DEFINED TC_RUNID)\n  zephyr_compile_definitions(TC_RUNID=${TC_RUNID})\nendif()\n\nzephyr_library()\nzephyr_library_sources(\n  src/ztest.c\n  src/ztest_error_hook.c\n  src/ztest_rules.c\n\t)\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright (c) 2022 Google LLC  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_undef\nundef|#\ndirective|undef\nname|_POSIX_C_SOURCE\nend_undef\n\nbegin_define\nDECL|macro|_POSIX_C_SOURCE\ndefine|#\ndirective|define\nname|_POSIX_C_SOURCE\nvalue|200809L\nend_define\n\nbegin_include\ninclude|#\ndirective|include\nfile|<stdio.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+\n+# For strtok_r() and strdup()\n+zephyr_library_compile_options(-D_POSIX_C_SOURCE=200809L)\n+\n-begin_undef\n-undef|#\n-directive|undef\n-name|_POSIX_C_SOURCE\n-end_undef\n-\n-begin_define\n-DECL|macro|_POSIX_C_SOURCE\n-define|#\n-directive|define\n-name|_POSIX_C_SOURCE\n-value|200809L\n-end_define\n-\nThe issue was with: ztest: define _POSIX_C_SOURCE macro\n\nAdd declaration of the _POSIX_C_SOURCE < 200809L for ztest library for\ndeclaration of strtok_r and strdup functions."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: gpio: dw: Address warning of unused `gpio_dw_isr`\n\nThis commit conditionally masks out `gpio_dw_isr` to prevent a build\nwarning if none of the instances of this driver are connected to an IRQ. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|gpio_dw_isr (const struct device * port)\nspecifier|static\nname|void\nname|gpio_dw_isr\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_decl_stmt\nDECL|variable|api_funcs\nspecifier|static\nspecifier|const\nname|struct",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_if\n+if|#\n+directive|if\n+name|DT_ANY_INST_HAS_PROP_STATUS_OKAY\n+argument_list|(\n+name|interrupts\n+argument_list|)\n+end_if\n+\n+begin_endif\n+endif|#\n+directive|endif\n+end_endif\n+\n+begin_comment\n+comment|/* DT_ANY_INST_HAS_PROP_STATUS_OKAY(interrupts) */\n+end_comment\n+\nThe issue was with: drivers: gpio: dw: Address warning of unused `gpio_dw_isr`\n\nThis commit conditionally masks out `gpio_dw_isr` to prevent a build\nwarning if none of the instances of this driver are connected to an IRQ."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: gpio: dw: Switch to `DT_INST_IRQN_BY_IDX`\n\nSwitch to using `DT_*IRQN` helpers for obtaining the IRQ number instead of\ndirectly accessing the `irq` cell. This change ensures that the encoded\nvalues for multi-level interrupts are correctly retrieved. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|idx\nparameter_list|,\nname|n\nparameter_list|)\ndefine|\\\nvalue|IRQ_CONNECT(DT_INST_IRQ_BY_IDX(n, idx, irq),\t\t\t\t\t\\ \t\t\t    DT_INST_IRQ(n, priority), gpio_dw_isr,\t\t\t\t\\ \t\t\t    DEVICE_DT_INST_GET(n), INST_IRQ_FLAGS(n));\t\t\t\t\\ \t\tirq_enable(DT_INST_IRQ_BY_IDX(n, idx, irq));\t\t\t\t\t\\  #define GPIO_DW_INIT(n)\t\t\t\t\t\t\t\t\t\t\\ \tstatic void gpio_config_##n##_irq(const struct device *port)\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\t\t\t\\ \t\tARG_UNUSED(port);\t\t\t                                        \\ \t\tLISTIFY(DT_NUM_IRQS(DT_DRV_INST(n)), GPIO_CFG_IRQ, (), n)                       \\ \t}\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct gpio_dw_config gpio_dw_config_##n = {\t\t\t\t\\ \t\t.common = {\t\t\t\t\t\t\t\t\t\\ \t\t\t.port_pin_mask = GPIO_PORT_PIN_MASK_FROM_DT_INST(n),\t\t\t\\ \t\t},\t\t\t\t\t\t\t\t\t\t\\ \t\t.irq_num = COND_CODE_1(DT_INST_IRQ_HAS_IDX(n, 0), (DT_INST_IRQN(n)), (0)),\t\\ \t\t.ngpios = DT_INST_PROP(n, ngpios),\t\t\t\t\t\t\\ \t\t.config_func = gpio_config_##n##_irq,\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct gpio_dw_runtime gpio_##n##_runtime = {\t\t\t\t\t\\ \t\t.base_addr = DT_INST_REG_ADDR(n),\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n, gpio_dw_initialize, NULL,&gpio_##n##_runtime,\t\t\t\\&gpio_dw_config_##n, PRE_KERNEL_1,\t\t\t\t\t\\ \t\t      CONFIG_GPIO_INIT_PRIORITY,&api_funcs);\t\t\t\t\t\\  DT_INST_FOREACH_STATUS_OKAY(GPIO_DW_INIT)\nend_define\n\nend_unit\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|IRQ_CONNECT(DT_INST_IRQ_BY_IDX(n, idx, irq),\t\t\t\t\t\\ \t\t\t    DT_INST_IRQ(n, priority), gpio_dw_isr,\t\t\t\t\\ \t\t\t    DEVICE_DT_INST_GET(n), INST_IRQ_FLAGS(n));\t\t\t\t\\ \t\tirq_enable(DT_INST_IRQ_BY_IDX(n, idx, irq));\t\t\t\t\t\\  #define GPIO_DW_INIT(n)\t\t\t\t\t\t\t\t\t\t\\ \tstatic void gpio_config_##n##_irq(const struct device *port)\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\t\t\t\\ \t\tARG_UNUSED(port);\t\t\t                                        \\ \t\tLISTIFY(DT_NUM_IRQS(DT_DRV_INST(n)), GPIO_CFG_IRQ, (), n)                       \\ \t}\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct gpio_dw_config gpio_dw_config_##n = {\t\t\t\t\\ \t\t.common = {\t\t\t\t\t\t\t\t\t\\ \t\t\t.port_pin_mask = GPIO_PORT_PIN_MASK_FROM_DT_INST(n),\t\t\t\\ \t\t},\t\t\t\t\t\t\t\t\t\t\\ \t\t.irq_num = COND_CODE_1(DT_INST_IRQ_HAS_IDX(n, 0), (DT_INST_IRQN(n)), (0)),\t\\ \t\t.ngpios = DT_INST_PROP(n, ngpios),\t\t\t\t\t\t\\ \t\t.config_func = gpio_config_##n##_irq,\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct gpio_dw_runtime gpio_##n##_runtime = {\t\t\t\t\t\\ \t\t.base_addr = DT_INST_REG_ADDR(n),\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n, gpio_dw_initialize, NULL,&gpio_##n##_runtime,\t\t\t\\&gpio_dw_config_##n, PRE_KERNEL_1,\t\t\t\t\t\\ \t\t      CONFIG_GPIO_INIT_PRIORITY,&api_funcs);\t\t\t\t\t\\  DT_INST_FOREACH_STATUS_OKAY(GPIO_DW_INIT)\n+value|IRQ_CONNECT(DT_INST_IRQN_BY_IDX(n, idx),\t\t\t\t\t\\ \t\t\t    DT_INST_IRQ(n, priority), gpio_dw_isr,\t\t\t\t\\ \t\t\t    DEVICE_DT_INST_GET(n), INST_IRQ_FLAGS(n));\t\t\t\t\\ \t\tirq_enable(DT_INST_IRQN_BY_IDX(n, idx));\t\t\t\t\t\\  #define GPIO_DW_INIT(n)\t\t\t\t\t\t\t\t\t\t\\ \tstatic void gpio_config_##n##_irq(const struct device *port)\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\t\t\t\\ \t\tARG_UNUSED(port);\t\t\t                                        \\ \t\tLISTIFY(DT_NUM_IRQS(DT_DRV_INST(n)), GPIO_CFG_IRQ, (), n)                       \\ \t}\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct gpio_dw_config gpio_dw_config_##n = {\t\t\t\t\\ \t\t.common = {\t\t\t\t\t\t\t\t\t\\ \t\t\t.port_pin_mask = GPIO_PORT_PIN_MASK_FROM_DT_INST(n),\t\t\t\\ \t\t},\t\t\t\t\t\t\t\t\t\t\\ \t\t.irq_num = COND_CODE_1(DT_INST_IRQ_HAS_IDX(n, 0), (DT_INST_IRQN(n)), (0)),\t\\ \t\t.ngpios = DT_INST_PROP(n, ngpios),\t\t\t\t\t\t\\ \t\t.config_func = gpio_config_##n##_irq,\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct gpio_dw_runtime gpio_##n##_runtime = {\t\t\t\t\t\\ \t\t.base_addr = DT_INST_REG_ADDR(n),\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n, gpio_dw_initialize, NULL,&gpio_##n##_runtime,\t\t\t\\&gpio_dw_config_##n, PRE_KERNEL_1,\t\t\t\t\t\\ \t\t      CONFIG_GPIO_INIT_PRIORITY,&api_funcs);\t\t\t\t\t\\  DT_INST_FOREACH_STATUS_OKAY(GPIO_DW_INIT)\nThe issue was with: drivers: gpio: dw: Switch to `DT_INST_IRQN_BY_IDX`\n\nSwitch to using `DT_*IRQN` helpers for obtaining the IRQ number instead of\ndirectly accessing the `irq` cell. This change ensures that the encoded\nvalues for multi-level interrupts are correctly retrieved."
},{
  "instruction": "There is an issue in the following code. It relates to tests: coredump: Disable optimizations to prevent unexpected failures\n\ndebug.coredump.logging_backend is currently failing for most of the targets\nI have tried when building with clang. Depending on the target, func_3\ninvokes undefined behavior by dereferencing addr (which is NULL) which\ncan lead to the compiler optimizing out significant portions of the code,\nresulting in unexpected/incorrect failures.\n\nHere, clang seems to inline func_3 into main then marks the inlined\nimplementation as unreachable (due to the UB) and removes it and everything\nafter it in main. So, we fall through to whatever code lies past main,\nresulting in a test failure (timeout) from what I've seen. GCC seems to do\nsimilar things, but creates an invalid opcode instruction so the test still\nsucceeds.\n\nclang is correct in both optimizing this behavior out and leaving\nbuggy code behind, so disable optimizations for func_3 to keep things under\ncontrol and prevent the incorrect failures. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|func_3 (uint32_t * addr)\nname|void\nname|func_3\nparameter_list|(\nname|uint32_t\nmodifier|*",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_comment\n+comment|/* Turn off optimizations to prevent the compiler from optimizing this away  * due to the null pointer dereference.  */\n+end_comment\n+\n+name|__no_optimization\nThe issue was with: tests: coredump: Disable optimizations to prevent unexpected failures\n\ndebug.coredump.logging_backend is currently failing for most of the targets\nI have tried when building with clang. Depending on the target, func_3\ninvokes undefined behavior by dereferencing addr (which is NULL) which\ncan lead to the compiler optimizing out significant portions of the code,\nresulting in unexpected/incorrect failures.\n\nHere, clang seems to inline func_3 into main then marks the inlined\nimplementation as unreachable (due to the UB) and removes it and everything\nafter it in main. So, we fall through to whatever code lies past main,\nresulting in a test failure (timeout) from what I've seen. GCC seems to do\nsimilar things, but creates an invalid opcode instruction so the test still\nsucceeds.\n\nclang is correct in both optimizing this behavior out and leaving\nbuggy code behind, so disable optimizations for func_3 to keep things under\ncontrol and prevent the incorrect failures."
},{
  "instruction": "There is an issue in the following code. It relates to tests: coredump: Change additional boards to directly call k_panic()\n\nThe riscv_virtual, hifive_unleashed, and hifive_unmatched boards all\ntimeout on this test if they actually perform the null dereference when\nthey are simulated. Whether the null dereference happens seems to depend\non the compiler used as well as whether optimizations are enabled though.\n\nTo make this more consistent, handle these boards in the same way as others\nwhich use Renode simulation and have them directly call k_panic(). Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\noperator|||\nexpr|\\\nname|defined\nargument_list|(\nname|CONFIG_BOARD_LONGAN_NANO\nargument_list|)\noperator|||\nexpr|\\\nname|defined\nargument_list|)\noperator|||\nexpr|\\\nname|defined\nargument_list|(\nname|CONFIG_SOC_FAMILY_INTEL_ADSP\nargument_list|)\nname|ARG_UNUSED\nargument_list|(\nname|addr",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|CONFIG_BOARD_HIFIVE_UNLEASHED\n+argument_list|)\n+operator|||\n+expr|\\\n+name|defined\n+argument_list|(\n+name|CONFIG_BOARD_HIFIVE_UNMATCHED\n+argument_list|)\n+operator|||\n+expr|\\\n+name|defined\n+argument_list|(\n+name|CONFIG_BOARD_RISCV32_VIRTUAL\n+argument_list|)\n+operator|||\n+expr|\\\n+name|defined\n+argument_list|(\nThe issue was with: tests: coredump: Change additional boards to directly call k_panic()\n\nThe riscv_virtual, hifive_unleashed, and hifive_unmatched boards all\ntimeout on this test if they actually perform the null dereference when\nthey are simulated. Whether the null dereference happens seems to depend\non the compiler used as well as whether optimizations are enabled though.\n\nTo make this more consistent, handle these boards in the same way as others\nwhich use Renode simulation and have them directly call k_panic()."
},{
  "instruction": "There is an issue in the following code. It relates to net: shell: Do not print DHCPv4 info if IPv4 is not available\n\nIf the network interface does not enable IPv4, then it is pointless\nto print DHCPv4 information when invoking \\\"iface\\\" shell command. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_NET_DHCPV4\nargument_list|)\nname|PR\nargument_list|(\nliteral|\"DHCPv4 lease time : %u\\n\"\nargument_list|,\nname|iface\nname|dhcpv4\noperator|.\nname|attempts\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\ncomment|/* CONFIG_NET_DHCPV4 */\nelse|#\ndirective|else",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|net_if_flag_is_set\n+argument_list|(\n+name|iface\n+argument_list|,\n+name|NET_IF_IPV4\n+argument_list|)\n+condition|)\n+block|{\n+block|}\nThe issue was with: net: shell: Do not print DHCPv4 info if IPv4 is not available\n\nIf the network interface does not enable IPv4, then it is pointless\nto print DHCPv4 information when invoking \\\"iface\\\" shell command."
},{
  "instruction": "There is an issue in the following code. It relates to net: wifi: Set default values of dwell time\n\nDwell time Active or Passive is optional in wifi scan.\nIf user don't set the Dwell time value, it will be set\nas 0. We are adding a range check in scan extensions\nfor dwell time. So need to set default values. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|MAX_BANDS_STR_LEN\nvalue|64\nend_define\n\nbegin_struct\nDECL|struct|__anon290907270108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\ndecl_stmt|;\nDECL|member|scan_result\nname|uint32_t\nname|scan_result\ndecl_stmt|;\nDECL|union|__anon29090727020a\nunion|union\nblock|{\nDECL|struct|__anon290907270308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\nname|struct\nname|wifi_scan_params\nname|params\ninit|=\nblock|{\nliteral|0\nblock|}\ndecl_stmt|;\nname|bool\nname|do_scan\ninit|=\nname|true",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon290907270108\n+DECL|struct|__anon2b1fbdd10108\n-DECL|union|__anon29090727020a\n+DECL|union|__anon2b1fbdd1020a\n-DECL|struct|__anon290907270308\n+DECL|struct|__anon2b1fbdd10308\n-literal|0\n-block|}\n+operator|.\n+name|dwell_time_active\n+operator|=\n+literal|50\n+block|,\n+operator|.\n+name|dwell_time_passive\n+operator|=\n+literal|130\n+block|, }\nThe issue was with: net: wifi: Set default values of dwell time\n\nDwell time Active or Passive is optional in wifi scan.\nIf user don't set the Dwell time value, it will be set\nas 0. We are adding a range check in scan extensions\nfor dwell time. So need to set default values."
},{
  "instruction": "There is an issue in the following code. It relates to net: sockets: tls: Add error log when cert parse fails\n\nAdd an error log if there's a failure when attempting to load\ncertificates during socket connect. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|k_mutex\nmodifier|*\nname|lock\ndecl_stmt|;\ncomment|/** TLS specific option values. */\nDECL|struct|__anon27a375170108\nstruct|struct\nblock|{\ncomment|/** Select which credentials to use with TLS. */\nDECL|member|sec_tag_list\nname|struct\nname|err\noperator|!=\nliteral|0\ncondition|)\nblock|{\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon27a375170108\n+DECL|struct|__anon29b264b20108\n+name|NET_ERR\n+argument_list|(\n+literal|\"Failed to parse CA certificate, err: -0x%x\"\n+argument_list|,\n+operator|-\n+name|err\n+argument_list|)\n+expr_stmt|;\nThe issue was with: net: sockets: tls: Add error log when cert parse fails\n\nAdd an error log if there's a failure when attempting to load\ncertificates during socket connect."
},{
  "instruction": "There is an issue in the following code. It relates to samples: hci_uart_async: Dont try to receive 0 bytes\n\nIt is not necessary and it ends up in an nrfx assert. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|payload_size\noperator|<=\nname|net_buf_tailroom\nargument_list|(\nname|buf\nargument_list|)\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_struct\nDECL|struct|__anon29570b120108\nspecifier|const\nstruct|struct\nblock|{\nDECL|member|h4\nname|uint8_t",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|==\n+literal|0\n+condition|)\n+block|{\n+comment|/* Done, dont rx zero bytes */\n+block|}\n+if|else if\n+condition|(\n+name|payload_size\n-DECL|struct|__anon29570b120108\n+DECL|struct|__anon2a0a0d2c0108\nThe issue was with: samples: hci_uart_async: Dont try to receive 0 bytes\n\nIt is not necessary and it ends up in an nrfx assert."
},{
  "instruction": "There is an issue in the following code. It relates to net: dhcpv4_server: Add option to NAK Request from unrecognized client\n\nZephyr's DHCPv4 server does not implement persistent storage of address\nleases. In result, all leases are lost on reboot, which can cause\ndelays with clients starting in INIT-REBOOT state and thus sending\n(potentially several) Requests before attempting full Discover-Request\nprocedure.\nAdd option to override RFC defined behavior, which states that if we\ndon't recognize the client sending the Request, the server shall remain\nsilent. Enabling that option allows the server to send NAK reply in case\nclient is not recognized, informing the client it should proceed with\nfull procedure. Please fix this issue.",
  "input": "Faulty tokenized code:\n\thelp\n\t  DHCPv4 server will probe the offered IP address (send ICMP echo\n\t  request) and wait for the time specific by this config before offering\n\t  the address. If set to 0, ICMP probing will be disabled.\n\nendif # NET_DHCPV4_SERVER\nblock|}\nblock|}\nif|else if\ncondition|(\nname|IS_ENABLED\nargument_list|()\ncondition|)\nblock|{\nname|dhcpv4_send_nak\nargument_list|(\nname|ctx",
  "result": "I corrected the issue in the code by changing the following tokens:\n+config NET_DHCPV4_SERVER_NAK_UNRECOGNIZED_REQUESTS\n+\tbool \"Reply with NAK for DHCP Requests from clients we do not recognize\"\n+\tdefault y\n+\thelp\n+\t  Zephyr's DHCPv4 server does not implement persistent storage of address\n+\t  leases. As a result, all leases are lost on reboot, which can cause\n+\t  delays with clients starting in INIT-REBOOT state and thus sending\n+\t  (potentially several) Requests before attempting full Discover-Request\n+\t  procedure. Enabling this config will violate the RFC in this regard, as\n+\t  instead of staying silent for unrecognized Request messages, the server\n+\t  will send a NAK, informing the client it should proceed with a full\n+\t  procedure.\n+\n-argument_list|()\n+argument_list|(\n+name|CONFIG_NET_DHCPV4_SERVER_NAK_UNRECOGNIZED_REQUESTS\n+argument_list|)\nThe issue was with: net: dhcpv4_server: Add option to NAK Request from unrecognized client\n\nZephyr's DHCPv4 server does not implement persistent storage of address\nleases. In result, all leases are lost on reboot, which can cause\ndelays with clients starting in INIT-REBOOT state and thus sending\n(potentially several) Requests before attempting full Discover-Request\nprocedure.\nAdd option to override RFC defined behavior, which states that if we\ndon't recognize the client sending the Request, the server shall remain\nsilent. Enabling that option allows the server to send NAK reply in case\nclient is not recognized, informing the client it should proceed with\nfull procedure."
},{
  "instruction": "There is an issue in the following code. It relates to net: dhcpv4_server: Improve DHCP Request retransmission handling\n\nIn case ACK from the server was lost, we'd not reply Request\nretransmissions, as the lease state is already in allocated state on the\nserver side. Therefore we also need to allow to reply with ACK in such\ncase. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|len\nargument_list|)\noperator|==\nliteral|0\noperator|&&\nname|slot\noperator|->\nname|state\noperator|==\nname|DHCPV4_SERVER_ADDR_RESERVED\ncondition|)\nblock|{\nname|selected\noperator|=\nname|slot",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+operator|||\n+name|slot\n+operator|->\n+name|state\n+operator|==\n+name|DHCPV4_SERVER_ADDR_ALLOCATED\n+operator|)\nThe issue was with: net: dhcpv4_server: Improve DHCP Request retransmission handling\n\nIn case ACK from the server was lost, we'd not reply Request\nretransmissions, as the lease state is already in allocated state on the\nserver side. Therefore we also need to allow to reply with ACK in such\ncase."
},{
  "instruction": "There is an issue in the following code. It relates to net: dhcpv4_server: Increase reserved address timeout\n\n5 seconds turned out to be too short timeout in case retransmissions\nkicked in at DHCP level, hence increase the timeout. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_define\nDECL|macro|ADDRESS_RESERVED_TIMEOUT\ndefine|#\ndirective|define\nname|ADDRESS_RESERVED_TIMEOUT\nvalue|K_SECONDS(5)\nend_define\n\nbegin_define\nDECL|macro|ADDRESS_PROBE_TIMEOUT\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|K_SECONDS(5)\n+value|K_SECONDS(30)\nThe issue was with: net: dhcpv4_server: Increase reserved address timeout\n\n5 seconds turned out to be too short timeout in case retransmissions\nkicked in at DHCP level, hence increase the timeout."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: pwm: pwm_mcux_ctimer: use correct clock subsystem ID\n\nWith the merge of zephyrproject-rtos/zephyr/pull/70254,\nMCUX_CTIMER_CLK_OFFSET is no longer defined nor needed. Remove this from\nthe macro getting the clock subsystem in the ctimer PWM driver. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|PWM_MCUX_CTIMER_DEVICE_INIT_MCUX\nparameter_list|(\nname|n\nparameter_list|)\ndefine|\\\nvalue|static struct pwm_mcux_ctimer_data pwm_mcux_ctimer_data_##n = {                            \\ \t\t.channel_states =                                                                  \\ \t\t\t{                                                                          \\ \t\t\t\t[kCTIMER_Match_0] = {.role = PWM_CTIMER_CHANNEL_ROLE_NONE,         \\ \t\t\t\t\t\t     .cycles = 0},                                 \\ \t\t\t\t[kCTIMER_Match_1] = {.role = PWM_CTIMER_CHANNEL_ROLE_NONE,         \\ \t\t\t\t\t\t     .cycles = 0},                                 \\ \t\t\t\t[kCTIMER_Match_2] = {.role = PWM_CTIMER_CHANNEL_ROLE_NONE,         \\ \t\t\t\t\t\t     .cycles = 0},                                 \\ \t\t\t\t[kCTIMER_Match_3] = {.role = PWM_CTIMER_CHANNEL_ROLE_NONE,         \\ \t\t\t\t\t\t     .cycles = 0},                                 \\ \t\t\t},                                                                         \\ \t\t.current_period_channel = kCTIMER_Match_0,                                         \\ \t\t.is_period_channel_set = false,                                                    \\ \t};                                                                                         \\ \tPWM_MCUX_CTIMER_PINCTRL_DEFINE(n)                                                          \\ \tstatic const struct pwm_mcux_ctimer_config pwm_mcux_ctimer_config_##n = {                  \\ \t\t.base = (CTIMER_Type *)DT_INST_REG_ADDR(n),                                        \\ \t\t.prescale = DT_INST_PROP(n, prescaler),                                            \\ \t\t.clock_control = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(n)),                            \\ \t\t.clock_id = (clock_control_subsys_t)(DT_INST_CLOCKS_CELL(n, name) +                \\ \t\t\t\t\t\t     MCUX_CTIMER_CLK_OFFSET),                      \\ \t\tPWM_MCUX_CTIMER_PINCTRL_INIT(n)};                                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(n, mcux_ctimer_pwm_init, NULL,&pwm_mcux_ctimer_data_##n,            \\&pwm_mcux_ctimer_config_##n, POST_KERNEL,                            \\ \t\t\t      CONFIG_KERNEL_INIT_PRIORITY_DEVICE,&pwm_mcux_ctimer_driver_api);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|static struct pwm_mcux_ctimer_data pwm_mcux_ctimer_data_##n = {                            \\ \t\t.channel_states =                                                                  \\ \t\t\t{                                                                          \\ \t\t\t\t[kCTIMER_Match_0] = {.role = PWM_CTIMER_CHANNEL_ROLE_NONE,         \\ \t\t\t\t\t\t     .cycles = 0},                                 \\ \t\t\t\t[kCTIMER_Match_1] = {.role = PWM_CTIMER_CHANNEL_ROLE_NONE,         \\ \t\t\t\t\t\t     .cycles = 0},                                 \\ \t\t\t\t[kCTIMER_Match_2] = {.role = PWM_CTIMER_CHANNEL_ROLE_NONE,         \\ \t\t\t\t\t\t     .cycles = 0},                                 \\ \t\t\t\t[kCTIMER_Match_3] = {.role = PWM_CTIMER_CHANNEL_ROLE_NONE,         \\ \t\t\t\t\t\t     .cycles = 0},                                 \\ \t\t\t},                                                                         \\ \t\t.current_period_channel = kCTIMER_Match_0,                                         \\ \t\t.is_period_channel_set = false,                                                    \\ \t};                                                                                         \\ \tPWM_MCUX_CTIMER_PINCTRL_DEFINE(n)                                                          \\ \tstatic const struct pwm_mcux_ctimer_config pwm_mcux_ctimer_config_##n = {                  \\ \t\t.base = (CTIMER_Type *)DT_INST_REG_ADDR(n),                                        \\ \t\t.prescale = DT_INST_PROP(n, prescaler),                                            \\ \t\t.clock_control = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(n)),                            \\ \t\t.clock_id = (clock_control_subsys_t)(DT_INST_CLOCKS_CELL(n, name) +                \\ \t\t\t\t\t\t     MCUX_CTIMER_CLK_OFFSET),                      \\ \t\tPWM_MCUX_CTIMER_PINCTRL_INIT(n)};                                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(n, mcux_ctimer_pwm_init, NULL,&pwm_mcux_ctimer_data_##n,            \\&pwm_mcux_ctimer_config_##n, POST_KERNEL,                            \\ \t\t\t      CONFIG_KERNEL_INIT_PRIORITY_DEVICE,&pwm_mcux_ctimer_driver_api);\n+value|static struct pwm_mcux_ctimer_data pwm_mcux_ctimer_data_##n = {                            \\ \t\t.channel_states =                                                                  \\ \t\t\t{                                                                          \\ \t\t\t\t[kCTIMER_Match_0] = {.role = PWM_CTIMER_CHANNEL_ROLE_NONE,         \\ \t\t\t\t\t\t     .cycles = 0},                                 \\ \t\t\t\t[kCTIMER_Match_1] = {.role = PWM_CTIMER_CHANNEL_ROLE_NONE,         \\ \t\t\t\t\t\t     .cycles = 0},                                 \\ \t\t\t\t[kCTIMER_Match_2] = {.role = PWM_CTIMER_CHANNEL_ROLE_NONE,         \\ \t\t\t\t\t\t     .cycles = 0},                                 \\ \t\t\t\t[kCTIMER_Match_3] = {.role = PWM_CTIMER_CHANNEL_ROLE_NONE,         \\ \t\t\t\t\t\t     .cycles = 0},                                 \\ \t\t\t},                                                                         \\ \t\t.current_period_channel = kCTIMER_Match_0,                                         \\ \t\t.is_period_channel_set = false,                                                    \\ \t};                                                                                         \\ \tPWM_MCUX_CTIMER_PINCTRL_DEFINE(n)                                                          \\ \tstatic const struct pwm_mcux_ctimer_config pwm_mcux_ctimer_config_##n = {                  \\ \t\t.base = (CTIMER_Type *)DT_INST_REG_ADDR(n),                                        \\ \t\t.prescale = DT_INST_PROP(n, prescaler),                                            \\ \t\t.clock_control = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(n)),                            \\ \t\t.clock_id = (clock_control_subsys_t)(DT_INST_CLOCKS_CELL(n, name)),                \\ \t\tPWM_MCUX_CTIMER_PINCTRL_INIT(n)};                                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(n, mcux_ctimer_pwm_init, NULL,&pwm_mcux_ctimer_data_##n,            \\&pwm_mcux_ctimer_config_##n, POST_KERNEL,                            \\ \t\t\t      CONFIG_KERNEL_INIT_PRIORITY_DEVICE,&pwm_mcux_ctimer_driver_api);\nThe issue was with: drivers: pwm: pwm_mcux_ctimer: use correct clock subsystem ID\n\nWith the merge of zephyrproject-rtos/zephyr/pull/70254,\nMCUX_CTIMER_CLK_OFFSET is no longer defined nor needed. Remove this from\nthe macro getting the clock subsystem in the ctimer PWM driver."
},{
  "instruction": "There is an issue in the following code. It relates to disk/nvme: Update copyright headers\n\nMost of the code is a port of FreeBSD's NVMe's driver, made by Jim\nHarris (Intel).\n\nThough all subsequent contributions that happened on this original\ndriver were made on files copyrighted by Intel, and under BSD-2 clause,\nlet's update the copyright header to point out Jim's original work and\nmajor contributors were relevant. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright (c) 2022 Intel Corporation  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_ifndef\nifndef|#\ndirective|ifndef\nindex|[\nliteral|484\nindex|]\ndecl_stmt|;\ncomment|/* E1Ch - FFFh */\nDECL|struct|__anon27611e310108\nstruct|struct\nblock|{\nDECL|member|sq_tdbl\nname|uint32_t\nname|sq_tdbl\nDECL|member|hmmin\nname|uint32_t\nname|hmmin\ndecl_stmt|;\ncomment|/** Name space capabilities  */\nDECL|struct|__anon27611e310208\nstruct|struct\nblock|{\ncomment|/* if nsmgmt, report tnvmcap and unvmcap */\nDECL|member|tnvmcap\nname|uint8_t\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * SPDX-License-Identifier: Apache-2.0  * Copyright (c) 2022 Intel Corp.  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * SPDX-License-Identifier: Apache-2.0  * Copyright (c) 2022 Intel Corp.  */\nend_comment\n\nbegin_ifndef\nifndef|#\ndirective|ifndef\nblock|}\nname|dptr\nstruct|;\ncomment|/* data pointer */\ncomment|/* dword 10 */\nDECL|union|__anon27d9ec84010a\nunion|union\nblock|{\nDECL|member|cdw10\nname|uint32_t\nname|cdw10\ndecl_stmt|;\ncomment|/* Number of Dwords in Data transfer */\nblock|}\nunion|;\ncomment|/* dword 11 */\nDECL|union|__anon27d9ec84020a\nunion|union\nblock|{\nDECL|member|cdw11\nname|uint32_t\nname|cdw11\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright (c) 2022 Intel Corporation  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_define\nDECL|macro|DT_DRV_COMPAT\ndefine|#\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * SPDX-License-Identifier: Apache-2.0  * Copyright (c) 2022 Intel Corp.  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * SPDX-License-Identifier: Apache-2.0  * Copyright (c) 2022 Intel Corp.  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * SPDX-License-Identifier: Apache-2.0  * Copyright (c) 2022 Intel Corp.  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright (c) 2022 Intel Corporation  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_ifndef\nifndef|#\ndirective|ifndef",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/*  * Copyright (c) 2022 Intel Corporation  *  * SPDX-License-Identifier: Apache-2.0  */\n+comment|/*  * Copyright (c) 2022 Intel Corporation  * SPDX-License-Identifier: Apache-2.0  *  * Derived from FreeBSD original driver made by Jim Harris  * with contributions from Alexander Motin and Wojciech Macek  */\n-DECL|struct|__anon27611e310108\n+DECL|struct|__anon276d3b5f0108\n-DECL|struct|__anon27611e310208\n+DECL|struct|__anon276d3b5f0208\n-comment|/*  * SPDX-License-Identifier: Apache-2.0  * Copyright (c) 2022 Intel Corp.  */\n+comment|/*  * Copyright (c) 2022 Intel Corporation  * SPDX-License-Identifier: Apache-2.0  *  * Derived from FreeBSD original driver made by Jim Harris  * with contributions from Alexander Motin, Wojciech Macek, and Warner Losh  */\n-comment|/*  * SPDX-License-Identifier: Apache-2.0  * Copyright (c) 2022 Intel Corp.  */\n+comment|/*  * Copyright (c) 2022 Intel Corporation  * SPDX-License-Identifier: Apache-2.0  *  * Derived from FreeBSD original driver made by Jim Harris  * with contributions from Alexander Motin and Wojciech Macek  */\n-DECL|union|__anon27d9ec84010a\n+DECL|union|__anon28d586f7010a\n-DECL|union|__anon27d9ec84020a\n+DECL|union|__anon28d586f7020a\n-comment|/*  * Copyright (c) 2022 Intel Corporation  *  * SPDX-License-Identifier: Apache-2.0  */\n+comment|/*  * Copyright (c) 2022 Intel Corporation  * SPDX-License-Identifier: Apache-2.0  *  * Derived from FreeBSD original driver made by Jim Harris  * with contributions from Alexander Motin, Wojciech Macek, and Warner Losh  */\n-comment|/*  * SPDX-License-Identifier: Apache-2.0  * Copyright (c) 2022 Intel Corp.  */\n+comment|/*  * Copyright (c) 2022 Intel Corporation  * SPDX-License-Identifier: Apache-2.0  *  * Derived from FreeBSD original driver made by Jim Harris  */\n-comment|/*  * SPDX-License-Identifier: Apache-2.0  * Copyright (c) 2022 Intel Corp.  */\n+comment|/*  * Copyright (c) 2022 Intel Corporation  * SPDX-License-Identifier: Apache-2.0  */\n-comment|/*  * SPDX-License-Identifier: Apache-2.0  * Copyright (c) 2022 Intel Corp.  */\n+comment|/*  * Copyright (c) 2022 Intel Corporation  * SPDX-License-Identifier: Apache-2.0  *  * Derived from FreeBSD original driver made by Jim Harris  */\n-comment|/*  * Copyright (c) 2022 Intel Corporation  *  * SPDX-License-Identifier: Apache-2.0  */\n+comment|/*  * Copyright (c) 2022 Intel Corporation  * SPDX-License-Identifier: Apache-2.0  *  * Derived from FreeBSD original driver made by Jim Harris  * with contributions from Alexander Motin and Wojciech Macek  */\nThe issue was with: disk/nvme: Update copyright headers\n\nMost of the code is a port of FreeBSD's NVMe's driver, made by Jim\nHarris (Intel).\n\nThough all subsequent contributions that happened on this original\ndriver were made on files copyrighted by Intel, and under BSD-2 clause,\nlet's update the copyright header to point out Jim's original work and\nmajor contributors were relevant."
},{
  "instruction": "There is an issue in the following code. It relates to soc: Move non-grouped qemu boards into qemu folder\n\nFor the 2 SoCs without a vendor, put them into a generic qemu\nfolder Please fix this issue.",
  "input": "Faulty tokenized code:\nsimilarity index 100%\nrename from soc/qemu_malta/CMakeLists.txt\nrename to soc/qemu/malta/CMakeLists.txt\nsimilarity index 100%\nrename from soc/qemu_malta/Kconfig\nrename to soc/qemu/malta/Kconfig\nsimilarity index 100%\nrename from soc/qemu_malta/Kconfig.defconfig\nrename to soc/qemu/malta/Kconfig.defconfig\nsimilarity index 100%\nrename from soc/qemu_malta/Kconfig.soc\nrename to soc/qemu/malta/Kconfig.soc\nsimilarity index 100%\nrename from soc/qemu_malta/soc.h\nrename to soc/qemu/malta/soc.h\nsimilarity index 100%\nrename from soc/qemu_malta/soc.yml\nrename to soc/qemu/malta/soc.yml\nsimilarity index 100%\nrename from soc/qemu_malta/vector.S\nrename to soc/qemu/malta/vector.S\nsimilarity index 100%\nrename from soc/riscv/qemu_virt_riscv/CMakeLists.txt\nrename to soc/qemu/virt_riscv/CMakeLists.txt\nsimilarity index 100%\nrename from soc/riscv/qemu_virt_riscv/Kconfig\nrename to soc/qemu/virt_riscv/Kconfig\nsimilarity index 100%\nrename from soc/riscv/qemu_virt_riscv/Kconfig.defconfig\nrename to soc/qemu/virt_riscv/Kconfig.defconfig\nsimilarity index 100%\nrename from soc/riscv/qemu_virt_riscv/Kconfig.soc\nrename to soc/qemu/virt_riscv/Kconfig.soc\nsimilarity index 100%\nrename from soc/riscv/qemu_virt_riscv/common/CMakeLists.txt\nrename to soc/qemu/virt_riscv/common/CMakeLists.txt\nsimilarity index 100%\nrename from soc/riscv/qemu_virt_riscv/common/soc.c\nrename to soc/qemu/virt_riscv/common/soc.c\nsimilarity index 100%\nrename from soc/riscv/qemu_virt_riscv/qemu_virt_riscv32/Kconfig\nrename to soc/qemu/virt_riscv/qemu_virt_riscv32/Kconfig\nsimilarity index 100%\nrename from soc/riscv/qemu_virt_riscv/qemu_virt_riscv32/Kconfig.soc\nrename to soc/qemu/virt_riscv/qemu_virt_riscv32/Kconfig.soc\nsimilarity index 100%\nrename from soc/riscv/qemu_virt_riscv/qemu_virt_riscv32e/Kconfig\nrename to soc/qemu/virt_riscv/qemu_virt_riscv32e/Kconfig\nsimilarity index 100%\nrename from soc/riscv/qemu_virt_riscv/qemu_virt_riscv32e/Kconfig.soc\nrename to soc/qemu/virt_riscv/qemu_virt_riscv32e/Kconfig.soc\nsimilarity index 100%\nrename from soc/riscv/qemu_virt_riscv/qemu_virt_riscv64/Kconfig\nrename to soc/qemu/virt_riscv/qemu_virt_riscv64/Kconfig\nsimilarity index 100%\nrename from soc/riscv/qemu_virt_riscv/qemu_virt_riscv64/Kconfig.soc\nrename to soc/qemu/virt_riscv/qemu_virt_riscv64/Kconfig.soc\nsimilarity index 100%\nrename from soc/riscv/qemu_virt_riscv/soc.yml\nrename to soc/qemu/virt_riscv/soc.yml",
  "result": "I corrected the issue in the code by changing the following tokens:\n\nThe issue was with: soc: Move non-grouped qemu boards into qemu folder\n\nFor the 2 SoCs without a vendor, put them into a generic qemu\nfolder"
},{
  "instruction": "There is an issue in the following code. It relates to boards/socs: Rename folders to have proper vendor prefix in\n\nReplaces inaccurate or wrong vendor prefixes in board and soc\nfolder names with those from thr vendor prefix file Please fix this issue.",
  "input": "Faulty tokenized code:\ndeleted file mode 100644\n.. _boards-arturo182:\n\nArturo182\n#########\n\n.. toctree::\n  :maxdepth: 1\n  :glob:\n\n  **/*\nsimilarity index 100%\nrename from boards/atmark_techno/degu_evk/Kconfig\nrename to boards/atmarktechno/degu_evk/Kconfig\nsimilarity index 100%\nrename from boards/atmark_techno/degu_evk/Kconfig.defconfig\nrename to boards/atmarktechno/degu_evk/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/atmark_techno/degu_evk/Kconfig.degu_evk\nrename to boards/atmarktechno/degu_evk/Kconfig.degu_evk\nsimilarity index 100%\nrename from boards/atmark_techno/degu_evk/board.cmake\nrename to boards/atmarktechno/degu_evk/board.cmake\nsimilarity index 100%\nrename from boards/atmark_techno/degu_evk/board.yml\nrename to boards/atmarktechno/degu_evk/board.yml\nsimilarity index 100%\nrename from boards/atmark_techno/degu_evk/degu_evk-pinctrl.dtsi\nrename to boards/atmarktechno/degu_evk/degu_evk-pinctrl.dtsi\nsimilarity index 100%\nrename from boards/atmark_techno/degu_evk/degu_evk.dts\nrename to boards/atmarktechno/degu_evk/degu_evk.dts\nsimilarity index 100%\nrename from boards/atmark_techno/degu_evk/degu_evk.yaml\nrename to boards/atmarktechno/degu_evk/degu_evk.yaml\nsimilarity index 100%\nrename from boards/atmark_techno/degu_evk/degu_evk_defconfig\nrename to boards/atmarktechno/degu_evk/degu_evk_defconfig\nsimilarity index 100%\nrename from boards/atmark_techno/degu_evk/doc/img/degu_evk.jpg\nrename to boards/atmarktechno/degu_evk/doc/img/degu_evk.jpg\nsimilarity index 100%\nrename from boards/atmark_techno/degu_evk/doc/index.rst\nrename to boards/atmarktechno/degu_evk/doc/index.rst\nsimilarity index 100%\nrename from boards/atmark_techno/degu_evk/pre_dt_board.cmake\nrename to boards/atmarktechno/degu_evk/pre_dt_board.cmake\nsimilarity index 100%\nrename from boards/atmark_techno/index.rst\nrename to boards/atmarktechno/index.rst\nsimilarity index 100%\nrename from boards/blue_clover/index.rst\nrename to boards/bcdevices/index.rst\nsimilarity index 100%\nrename from boards/blue_clover/plt_demo_v2/Kconfig\nrename to boards/bcdevices/plt_demo_v2/Kconfig\nsimilarity index 100%\nrename from boards/blue_clover/plt_demo_v2/Kconfig.blueclover_plt_demo_v2\nrename to boards/bcdevices/plt_demo_v2/Kconfig.blueclover_plt_demo_v2\nsimilarity index 100%\nrename from boards/blue_clover/plt_demo_v2/Kconfig.defconfig\nrename to boards/bcdevices/plt_demo_v2/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/blue_clover/plt_demo_v2/blueclover_plt_demo_v2_nrf52832-pinctrl.dtsi\nrename to boards/bcdevices/plt_demo_v2/blueclover_plt_demo_v2_nrf52832-pinctrl.dtsi\nsimilarity index 100%\nrename from boards/blue_clover/plt_demo_v2/blueclover_plt_demo_v2_nrf52832.dts\nrename to boards/bcdevices/plt_demo_v2/blueclover_plt_demo_v2_nrf52832.dts\nsimilarity index 100%\nrename from boards/blue_clover/plt_demo_v2/blueclover_plt_demo_v2_nrf52832.yaml\nrename to boards/bcdevices/plt_demo_v2/blueclover_plt_demo_v2_nrf52832.yaml\nsimilarity index 100%\nrename from boards/blue_clover/plt_demo_v2/blueclover_plt_demo_v2_nrf52832_defconfig\nrename to boards/bcdevices/plt_demo_v2/blueclover_plt_demo_v2_nrf52832_defconfig\nsimilarity index 100%\nrename from boards/blue_clover/plt_demo_v2/board.cmake\nrename to boards/bcdevices/plt_demo_v2/board.cmake\nsimilarity index 100%\nrename from boards/blue_clover/plt_demo_v2/board.yml\nrename to boards/bcdevices/plt_demo_v2/board.yml\nsimilarity index 100%\nrename from boards/blue_clover/plt_demo_v2/doc/img/blueclover_plt_demo_v2.jpg\nrename to boards/bcdevices/plt_demo_v2/doc/img/blueclover_plt_demo_v2.jpg\nsimilarity index 100%\nrename from boards/blue_clover/plt_demo_v2/doc/index.rst\nrename to boards/bcdevices/plt_demo_v2/doc/index.rst\nsimilarity index 100%\nrename from boards/blue_clover/plt_demo_v2/pre_dt_board.cmake\nrename to boards/bcdevices/plt_demo_v2/pre_dt_board.cmake\nsimilarity index 100%\nrename from boards/circuit_dojo/feather/Kconfig.circuitdojo_feather\nrename to boards/circuitdojo/feather/Kconfig.circuitdojo_feather\nsimilarity index 100%\nrename from boards/circuit_dojo/feather/Kconfig.defconfig\nrename to boards/circuitdojo/feather/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/circuit_dojo/feather/board.cmake\nrename to boards/circuitdojo/feather/board.cmake\nsimilarity index 100%\nrename from boards/circuit_dojo/feather/board.yml\nrename to boards/circuitdojo/feather/board.yml\nsimilarity index 100%\nrename from boards/circuit_dojo/feather/circuitdojo_feather_nrf9160.dts\nrename to boards/circuitdojo/feather/circuitdojo_feather_nrf9160.dts\nsimilarity index 100%\nrename from boards/circuit_dojo/feather/circuitdojo_feather_nrf9160.yaml\nrename to boards/circuitdojo/feather/circuitdojo_feather_nrf9160.yaml\nsimilarity index 100%\nrename from boards/circuit_dojo/feather/circuitdojo_feather_nrf9160_common-pinctrl.dtsi\nrename to boards/circuitdojo/feather/circuitdojo_feather_nrf9160_common-pinctrl.dtsi\nsimilarity index 100%\nrename from boards/circuit_dojo/feather/circuitdojo_feather_nrf9160_common.dtsi\nrename to boards/circuitdojo/feather/circuitdojo_feather_nrf9160_common.dtsi\nsimilarity index 100%\nrename from boards/circuit_dojo/feather/circuitdojo_feather_nrf9160_defconfig\nrename to boards/circuitdojo/feather/circuitdojo_feather_nrf9160_defconfig\nsimilarity index 100%\nrename from boards/circuit_dojo/feather/circuitdojo_feather_nrf9160_ns.dts\nrename to boards/circuitdojo/feather/circuitdojo_feather_nrf9160_ns.dts\nsimilarity index 100%\nrename from boards/circuit_dojo/feather/circuitdojo_feather_nrf9160_ns.yaml\nrename to boards/circuitdojo/feather/circuitdojo_feather_nrf9160_ns.yaml\nsimilarity index 100%\nrename from boards/circuit_dojo/feather/circuitdojo_feather_nrf9160_ns_defconfig\nrename to boards/circuitdojo/feather/circuitdojo_feather_nrf9160_ns_defconfig\nsimilarity index 100%\nrename from boards/circuit_dojo/feather/circuitdojo_feather_nrf9160_partition_conf.dtsi\nrename to boards/circuitdojo/feather/circuitdojo_feather_nrf9160_partition_conf.dtsi\nsimilarity index 100%\nrename from boards/circuit_dojo/feather/doc/img/circuitdojo_feather_nrf9160.jpg\nrename to boards/circuitdojo/feather/doc/img/circuitdojo_feather_nrf9160.jpg\nsimilarity index 100%\nrename from boards/circuit_dojo/feather/doc/img/nrf9160-feather-v31-features.jpg\nrename to boards/circuitdojo/feather/doc/img/nrf9160-feather-v31-features.jpg\nsimilarity index 100%\nrename from boards/circuit_dojo/feather/doc/index.rst\nrename to boards/circuitdojo/feather/doc/index.rst\nsimilarity index 100%\nrename from boards/circuit_dojo/feather/pre_dt_board.cmake\nrename to boards/circuitdojo/feather/pre_dt_board.cmake\nsimilarity index 100%\nrename from boards/circuit_dojo/index.rst\nrename to boards/circuitdojo/index.rst\nsimilarity index 100%\nrename from boards/contextual_electronics/abc/Kconfig\nrename to boards/contextualelectronics/abc/Kconfig\nsimilarity index 100%\nrename from boards/contextual_electronics/abc/Kconfig.contextualelectronics_abc\nrename to boards/contextualelectronics/abc/Kconfig.contextualelectronics_abc\nsimilarity index 100%\nrename from boards/contextual_electronics/abc/Kconfig.defconfig\nrename to boards/contextualelectronics/abc/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/contextual_electronics/abc/board.cmake\nrename to boards/contextualelectronics/abc/board.cmake\nsimilarity index 100%\nrename from boards/contextual_electronics/abc/board.yml\nrename to boards/contextualelectronics/abc/board.yml\nsimilarity index 100%\nrename from boards/contextual_electronics/abc/contextualelectronics_abc-pinctrl.dtsi\nrename to boards/contextualelectronics/abc/contextualelectronics_abc-pinctrl.dtsi\nsimilarity index 100%\nrename from boards/contextual_electronics/abc/contextualelectronics_abc.dts\nrename to boards/contextualelectronics/abc/contextualelectronics_abc.dts\nsimilarity index 100%\nrename from boards/contextual_electronics/abc/contextualelectronics_abc.yaml\nrename to boards/contextualelectronics/abc/contextualelectronics_abc.yaml\nsimilarity index 100%\nrename from boards/contextual_electronics/abc/contextualelectronics_abc_defconfig\nrename to boards/contextualelectronics/abc/contextualelectronics_abc_defconfig\nsimilarity index 100%\nrename from boards/contextual_electronics/abc/doc/img/contextualelectronics_abc.jpg\nrename to boards/contextualelectronics/abc/doc/img/contextualelectronics_abc.jpg\nsimilarity index 100%\nrename from boards/contextual_electronics/abc/doc/index.rst\nrename to boards/contextualelectronics/abc/doc/index.rst\nsimilarity index 100%\nrename from boards/contextual_electronics/abc/pre_dt_board.cmake\nrename to boards/contextualelectronics/abc/pre_dt_board.cmake\nsimilarity index 100%\nrename from boards/contextual_electronics/index.rst\nrename to boards/contextualelectronics/index.rst\nsimilarity index 100%\nrename from boards/electronut_labs/index.rst\nrename to boards/electronut/index.rst\nsimilarity index 100%\nrename from boards/electronut_labs/nrf52840_blip/Kconfig\nrename to boards/electronut/nrf52840_blip/Kconfig\nsimilarity index 100%\nrename from boards/electronut_labs/nrf52840_blip/Kconfig.defconfig\nrename to boards/electronut/nrf52840_blip/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/electronut_labs/nrf52840_blip/Kconfig.nrf52840_blip\nrename to boards/electronut/nrf52840_blip/Kconfig.nrf52840_blip\nsimilarity index 100%\nrename from boards/electronut_labs/nrf52840_blip/board.cmake\nrename to boards/electronut/nrf52840_blip/board.cmake\nsimilarity index 100%\nrename from boards/electronut_labs/nrf52840_blip/board.yml\nrename to boards/electronut/nrf52840_blip/board.yml\nsimilarity index 100%\nrename from boards/electronut_labs/nrf52840_blip/doc/img/nrf52840_blip.jpg\nrename to boards/electronut/nrf52840_blip/doc/img/nrf52840_blip.jpg\nsimilarity index 100%\nrename from boards/electronut_labs/nrf52840_blip/doc/index.rst\nrename to boards/electronut/nrf52840_blip/doc/index.rst\nsimilarity index 100%\nrename from boards/electronut_labs/nrf52840_blip/nrf52840_blip-pinctrl.dtsi\nrename to boards/electronut/nrf52840_blip/nrf52840_blip-pinctrl.dtsi\nsimilarity index 100%\nrename from boards/electronut_labs/nrf52840_blip/nrf52840_blip.dts\nrename to boards/electronut/nrf52840_blip/nrf52840_blip.dts\nsimilarity index 100%\nrename from boards/electronut_labs/nrf52840_blip/nrf52840_blip.yaml\nrename to boards/electronut/nrf52840_blip/nrf52840_blip.yaml\nsimilarity index 100%\nrename from boards/electronut_labs/nrf52840_blip/nrf52840_blip_defconfig\nrename to boards/electronut/nrf52840_blip/nrf52840_blip_defconfig\nsimilarity index 100%\nrename from boards/electronut_labs/nrf52840_blip/pre_dt_board.cmake\nrename to boards/electronut/nrf52840_blip/pre_dt_board.cmake\nsimilarity index 100%\nrename from boards/electronut_labs/nrf52840_papyr/Kconfig\nrename to boards/electronut/nrf52840_papyr/Kconfig\nsimilarity index 100%\nrename from boards/electronut_labs/nrf52840_papyr/Kconfig.defconfig\nrename to boards/electronut/nrf52840_papyr/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/electronut_labs/nrf52840_papyr/Kconfig.nrf52840_papyr\nrename to boards/electronut/nrf52840_papyr/Kconfig.nrf52840_papyr\nsimilarity index 100%\nrename from boards/electronut_labs/nrf52840_papyr/board.cmake\nrename to boards/electronut/nrf52840_papyr/board.cmake\nsimilarity index 100%\nrename from boards/electronut_labs/nrf52840_papyr/board.yml\nrename to boards/electronut/nrf52840_papyr/board.yml\nsimilarity index 100%\nrename from boards/electronut_labs/nrf52840_papyr/doc/img/nrf52840_papyr.jpg\nrename to boards/electronut/nrf52840_papyr/doc/img/nrf52840_papyr.jpg\nsimilarity index 100%\nrename from boards/electronut_labs/nrf52840_papyr/doc/nrf52840_papyr.rst\nrename to boards/electronut/nrf52840_papyr/doc/nrf52840_papyr.rst\nsimilarity index 100%\nrename from boards/electronut_labs/nrf52840_papyr/nrf52840_papyr-pinctrl.dtsi\nrename to boards/electronut/nrf52840_papyr/nrf52840_papyr-pinctrl.dtsi\nsimilarity index 100%\nrename from boards/electronut_labs/nrf52840_papyr/nrf52840_papyr.dts\nrename to boards/electronut/nrf52840_papyr/nrf52840_papyr.dts\nsimilarity index 100%\nrename from boards/electronut_labs/nrf52840_papyr/nrf52840_papyr.yaml\nrename to boards/electronut/nrf52840_papyr/nrf52840_papyr.yaml\nsimilarity index 100%\nrename from boards/electronut_labs/nrf52840_papyr/nrf52840_papyr_defconfig\nrename to boards/electronut/nrf52840_papyr/nrf52840_papyr_defconfig\nsimilarity index 100%\nrename from boards/electronut_labs/nrf52840_papyr/pre_dt_board.cmake\nrename to boards/electronut/nrf52840_papyr/pre_dt_board.cmake\nsimilarity index 100%\nrename from boards/enjoy_digital/index.rst\nrename to boards/enjoydigital/index.rst\nsimilarity index 100%\nrename from boards/enjoy_digital/litex_vexriscv/Kconfig.defconfig\nrename to boards/enjoydigital/litex_vexriscv/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/enjoy_digital/litex_vexriscv/Kconfig.litex_vexriscv\nrename to boards/enjoydigital/litex_vexriscv/Kconfig.litex_vexriscv\nsimilarity index 100%\nrename from boards/enjoy_digital/litex_vexriscv/board.yml\nrename to boards/enjoydigital/litex_vexriscv/board.yml\nsimilarity index 100%\nrename from boards/enjoy_digital/litex_vexriscv/doc/img/litex_vexriscv.jpg\nrename to boards/enjoydigital/litex_vexriscv/doc/img/litex_vexriscv.jpg\nsimilarity index 100%\nrename from boards/enjoy_digital/litex_vexriscv/doc/img/symbiflow.svg\nrename to boards/enjoydigital/litex_vexriscv/doc/img/symbiflow.svg\nsimilarity index 100%\nrename from boards/enjoy_digital/litex_vexriscv/doc/index.rst\nrename to boards/enjoydigital/litex_vexriscv/doc/index.rst\nsimilarity index 100%\nrename from boards/enjoy_digital/litex_vexriscv/litex_vexriscv.dts\nrename to boards/enjoydigital/litex_vexriscv/litex_vexriscv.dts\nsimilarity index 100%\nrename from boards/enjoy_digital/litex_vexriscv/litex_vexriscv.yaml\nrename to boards/enjoydigital/litex_vexriscv/litex_vexriscv.yaml\nsimilarity index 100%\nrename from boards/enjoy_digital/litex_vexriscv/litex_vexriscv_defconfig\nrename to boards/enjoydigital/litex_vexriscv/litex_vexriscv_defconfig\nsimilarity index 100%\nrename from boards/maker_diary/index.rst\nrename to boards/makerdiary/index.rst\nsimilarity index 100%\nrename from boards/maker_diary/nrf52832_mdk/Kconfig\nrename to boards/makerdiary/nrf52832_mdk/Kconfig\nsimilarity index 100%\nrename from boards/maker_diary/nrf52832_mdk/Kconfig.defconfig\nrename to boards/makerdiary/nrf52832_mdk/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/maker_diary/nrf52832_mdk/Kconfig.nrf52832_mdk\nrename to boards/makerdiary/nrf52832_mdk/Kconfig.nrf52832_mdk\nsimilarity index 100%\nrename from boards/maker_diary/nrf52832_mdk/board.cmake\nrename to boards/makerdiary/nrf52832_mdk/board.cmake\nsimilarity index 100%\nrename from boards/maker_diary/nrf52832_mdk/board.yml\nrename to boards/makerdiary/nrf52832_mdk/board.yml\nsimilarity index 100%\nrename from boards/maker_diary/nrf52832_mdk/doc/index.rst\nrename to boards/makerdiary/nrf52832_mdk/doc/index.rst\nsimilarity index 100%\nrename from boards/maker_diary/nrf52832_mdk/nrf52832_mdk-pinctrl.dtsi\nrename to boards/makerdiary/nrf52832_mdk/nrf52832_mdk-pinctrl.dtsi\nsimilarity index 100%\nrename from boards/maker_diary/nrf52832_mdk/nrf52832_mdk.dts\nrename to boards/makerdiary/nrf52832_mdk/nrf52832_mdk.dts\nsimilarity index 100%\nrename from boards/maker_diary/nrf52832_mdk/nrf52832_mdk.yaml\nrename to boards/makerdiary/nrf52832_mdk/nrf52832_mdk.yaml\nsimilarity index 100%\nrename from boards/maker_diary/nrf52832_mdk/nrf52832_mdk_defconfig\nrename to boards/makerdiary/nrf52832_mdk/nrf52832_mdk_defconfig\nsimilarity index 100%\nrename from boards/maker_diary/nrf52832_mdk/pre_dt_board.cmake\nrename to boards/makerdiary/nrf52832_mdk/pre_dt_board.cmake\nsimilarity index 100%\nrename from boards/maker_diary/nrf52840_mdk/Kconfig\nrename to boards/makerdiary/nrf52840_mdk/Kconfig\nsimilarity index 100%\nrename from boards/maker_diary/nrf52840_mdk/Kconfig.defconfig\nrename to boards/makerdiary/nrf52840_mdk/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/maker_diary/nrf52840_mdk/Kconfig.nrf52840_mdk\nrename to boards/makerdiary/nrf52840_mdk/Kconfig.nrf52840_mdk\nsimilarity index 100%\nrename from boards/maker_diary/nrf52840_mdk/board.cmake\nrename to boards/makerdiary/nrf52840_mdk/board.cmake\nsimilarity index 100%\nrename from boards/maker_diary/nrf52840_mdk/board.yml\nrename to boards/makerdiary/nrf52840_mdk/board.yml\nsimilarity index 100%\nrename from boards/maker_diary/nrf52840_mdk/doc/index.rst\nrename to boards/makerdiary/nrf52840_mdk/doc/index.rst\nsimilarity index 100%\nrename from boards/maker_diary/nrf52840_mdk/nrf52840_mdk-pinctrl.dtsi\nrename to boards/makerdiary/nrf52840_mdk/nrf52840_mdk-pinctrl.dtsi\nsimilarity index 100%\nrename from boards/maker_diary/nrf52840_mdk/nrf52840_mdk.dts\nrename to boards/makerdiary/nrf52840_mdk/nrf52840_mdk.dts\nsimilarity index 100%\nrename from boards/maker_diary/nrf52840_mdk/nrf52840_mdk.yaml\nrename to boards/makerdiary/nrf52840_mdk/nrf52840_mdk.yaml\nsimilarity index 100%\nrename from boards/maker_diary/nrf52840_mdk/nrf52840_mdk_defconfig\nrename to boards/makerdiary/nrf52840_mdk/nrf52840_mdk_defconfig\nsimilarity index 100%\nrename from boards/maker_diary/nrf52840_mdk/pre_dt_board.cmake\nrename to boards/makerdiary/nrf52840_mdk/pre_dt_board.cmake\nsimilarity index 100%\nrename from boards/maker_diary/nrf52840_mdk_usb_dongle/Kconfig\nrename to boards/makerdiary/nrf52840_mdk_usb_dongle/Kconfig\nsimilarity index 100%\nrename from boards/maker_diary/nrf52840_mdk_usb_dongle/Kconfig.defconfig\nrename to boards/makerdiary/nrf52840_mdk_usb_dongle/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/maker_diary/nrf52840_mdk_usb_dongle/Kconfig.nrf52840_mdk_usb_dongle\nrename to boards/makerdiary/nrf52840_mdk_usb_dongle/Kconfig.nrf52840_mdk_usb_dongle\nsimilarity index 100%\nrename from boards/maker_diary/nrf52840_mdk_usb_dongle/board.cmake\nrename to boards/makerdiary/nrf52840_mdk_usb_dongle/board.cmake\nsimilarity index 100%\nrename from boards/maker_diary/nrf52840_mdk_usb_dongle/board.yml\nrename to boards/makerdiary/nrf52840_mdk_usb_dongle/board.yml\nsimilarity index 100%\nrename from boards/maker_diary/nrf52840_mdk_usb_dongle/doc/index.rst\nrename to boards/makerdiary/nrf52840_mdk_usb_dongle/doc/index.rst\nsimilarity index 100%\nrename from boards/maker_diary/nrf52840_mdk_usb_dongle/doc/nrf52840-mdk-usb-dongle-pinout.jpg\nrename to boards/makerdiary/nrf52840_mdk_usb_dongle/doc/nrf52840-mdk-usb-dongle-pinout.jpg\nsimilarity index 100%\nrename from boards/maker_diary/nrf52840_mdk_usb_dongle/fstab-debugger.dtsi\nrename to boards/makerdiary/nrf52840_mdk_usb_dongle/fstab-debugger.dtsi\nsimilarity index 100%\nrename from boards/maker_diary/nrf52840_mdk_usb_dongle/fstab-stock.dtsi\nrename to boards/makerdiary/nrf52840_mdk_usb_dongle/fstab-stock.dtsi\nsimilarity index 100%\nrename from boards/maker_diary/nrf52840_mdk_usb_dongle/nrf52840_mdk_usb_dongle-pinctrl.dtsi\nrename to boards/makerdiary/nrf52840_mdk_usb_dongle/nrf52840_mdk_usb_dongle-pinctrl.dtsi\nsimilarity index 100%\nrename from boards/maker_diary/nrf52840_mdk_usb_dongle/nrf52840_mdk_usb_dongle.dts\nrename to boards/makerdiary/nrf52840_mdk_usb_dongle/nrf52840_mdk_usb_dongle.dts\nsimilarity index 100%\nrename from boards/maker_diary/nrf52840_mdk_usb_dongle/nrf52840_mdk_usb_dongle.yaml\nrename to boards/makerdiary/nrf52840_mdk_usb_dongle/nrf52840_mdk_usb_dongle.yaml\nsimilarity index 100%\nrename from boards/maker_diary/nrf52840_mdk_usb_dongle/nrf52840_mdk_usb_dongle_defconfig\nrename to boards/makerdiary/nrf52840_mdk_usb_dongle/nrf52840_mdk_usb_dongle_defconfig\nsimilarity index 100%\nrename from boards/maker_diary/nrf52840_mdk_usb_dongle/pre_dt_board.cmake\nrename to boards/makerdiary/nrf52840_mdk_usb_dongle/pre_dt_board.cmake\nsimilarity index 100%\nrename from boards/arturo182/serpente/Kconfig.serpente\nrename to boards/others/serpente/Kconfig.serpente\nsimilarity index 100%\nrename from boards/arturo182/serpente/board.cmake\nrename to boards/others/serpente/board.cmake\nsimilarity index 100%\nrename from boards/arturo182/serpente/board.yml\nrename to boards/others/serpente/board.yml\nsimilarity index 100%\nrename from boards/arturo182/serpente/doc/img/serpente.jpg\nrename to boards/others/serpente/doc/img/serpente.jpg\nsimilarity index 100%\nrename from boards/arturo182/serpente/doc/index.rst\nrename to boards/others/serpente/doc/index.rst\nsimilarity index 100%\nrename from boards/arturo182/serpente/pre_dt_board.cmake\nrename to boards/others/serpente/pre_dt_board.cmake\nsimilarity index 100%\nrename from boards/arturo182/serpente/serpente-pinctrl.dtsi\nrename to boards/others/serpente/serpente-pinctrl.dtsi\nsimilarity index 100%\nrename from boards/arturo182/serpente/serpente.dts\nrename to boards/others/serpente/serpente.dts\nsimilarity index 100%\nrename from boards/arturo182/serpente/serpente.yaml\nrename to boards/others/serpente/serpente.yaml\nsimilarity index 100%\nrename from boards/arturo182/serpente/serpente_defconfig\nrename to boards/others/serpente/serpente_defconfig\nsimilarity index 100%\nrename from boards/synopsys/em_starterkit/CMakeLists.txt\nrename to boards/snps/em_starterkit/CMakeLists.txt\nsimilarity index 100%\nrename from boards/synopsys/em_starterkit/Kconfig.defconfig\nrename to boards/snps/em_starterkit/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/synopsys/em_starterkit/Kconfig.em_starterkit\nrename to boards/snps/em_starterkit/Kconfig.em_starterkit\nsimilarity index 100%\nrename from boards/synopsys/em_starterkit/arc_mpu_regions.c\nrename to boards/snps/em_starterkit/arc_mpu_regions.c\nsimilarity index 100%\nrename from boards/synopsys/em_starterkit/board.cmake\nrename to boards/snps/em_starterkit/board.cmake\nsimilarity index 100%\nrename from boards/synopsys/em_starterkit/board.dtsi\nrename to boards/snps/em_starterkit/board.dtsi\nsimilarity index 100%\nrename from boards/synopsys/em_starterkit/board.yml\nrename to boards/snps/em_starterkit/board.yml\nsimilarity index 100%\nrename from boards/synopsys/em_starterkit/doc/em_starterkit.jpg\nrename to boards/snps/em_starterkit/doc/em_starterkit.jpg\nsimilarity index 100%\nrename from boards/synopsys/em_starterkit/doc/index.rst\nrename to boards/snps/em_starterkit/doc/index.rst\nsimilarity index 100%\nrename from boards/synopsys/em_starterkit/em_starterkit_defconfig\nrename to boards/snps/em_starterkit/em_starterkit_defconfig\nsimilarity index 100%\nrename from boards/synopsys/em_starterkit/em_starterkit_emsk_em11d.dts\nrename to boards/snps/em_starterkit/em_starterkit_emsk_em11d.dts\nsimilarity index 100%\nrename from boards/synopsys/em_starterkit/em_starterkit_emsk_em11d.yaml\nrename to boards/snps/em_starterkit/em_starterkit_emsk_em11d.yaml\nsimilarity index 100%\nrename from boards/synopsys/em_starterkit/em_starterkit_emsk_em7d.dts\nrename to boards/snps/em_starterkit/em_starterkit_emsk_em7d.dts\nsimilarity index 100%\nrename from boards/synopsys/em_starterkit/em_starterkit_emsk_em7d.yaml\nrename to boards/snps/em_starterkit/em_starterkit_emsk_em7d.yaml\nsimilarity index 100%\nrename from boards/synopsys/em_starterkit/em_starterkit_emsk_em7d_2_2.overlay\nrename to boards/snps/em_starterkit/em_starterkit_emsk_em7d_2_2.overlay\nsimilarity index 100%\nrename from boards/synopsys/em_starterkit/em_starterkit_emsk_em7d_2_2.yaml\nrename to boards/snps/em_starterkit/em_starterkit_emsk_em7d_2_2.yaml\nsimilarity index 100%\nrename from boards/synopsys/em_starterkit/em_starterkit_emsk_em7d_2_3.overlay\nrename to boards/snps/em_starterkit/em_starterkit_emsk_em7d_2_3.overlay\nsimilarity index 100%\nrename from boards/synopsys/em_starterkit/em_starterkit_emsk_em7d_2_3_defconfig\nrename to boards/snps/em_starterkit/em_starterkit_emsk_em7d_2_3_defconfig\nsimilarity index 100%\nrename from boards/synopsys/em_starterkit/em_starterkit_emsk_em7d_defconfig\nrename to boards/snps/em_starterkit/em_starterkit_emsk_em7d_defconfig\nsimilarity index 100%\nrename from boards/synopsys/em_starterkit/em_starterkit_emsk_em9d.dts\nrename to boards/snps/em_starterkit/em_starterkit_emsk_em9d.dts\nsimilarity index 100%\nrename from boards/synopsys/em_starterkit/em_starterkit_emsk_em9d.yaml\nrename to boards/snps/em_starterkit/em_starterkit_emsk_em9d.yaml\nsimilarity index 100%\nrename from boards/synopsys/em_starterkit/em_starterkit_r22.dtsi\nrename to boards/snps/em_starterkit/em_starterkit_r22.dtsi\nsimilarity index 100%\nrename from boards/synopsys/em_starterkit/em_starterkit_r23.dtsi\nrename to boards/snps/em_starterkit/em_starterkit_r23.dtsi\nsimilarity index 100%\nrename from boards/synopsys/em_starterkit/pmodmux.c\nrename to boards/snps/em_starterkit/pmodmux.c\nsimilarity index 100%\nrename from boards/synopsys/em_starterkit/support/openocd.cfg\nrename to boards/snps/em_starterkit/support/openocd.cfg\nsimilarity index 100%\nrename from boards/synopsys/emsdp/CMakeLists.txt\nrename to boards/snps/emsdp/CMakeLists.txt\nsimilarity index 100%\nrename from boards/synopsys/emsdp/Kconfig.defconfig\nrename to boards/snps/emsdp/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/synopsys/emsdp/Kconfig.emsdp\nrename to boards/snps/emsdp/Kconfig.emsdp\nsimilarity index 100%\nrename from boards/synopsys/emsdp/arc_mpu_regions.c\nrename to boards/snps/emsdp/arc_mpu_regions.c\nsimilarity index 100%\nrename from boards/synopsys/emsdp/board.cmake\nrename to boards/snps/emsdp/board.cmake\nsimilarity index 100%\nrename from boards/synopsys/emsdp/board.dtsi\nrename to boards/snps/emsdp/board.dtsi\nsimilarity index 100%\nrename from boards/synopsys/emsdp/board.yml\nrename to boards/snps/emsdp/board.yml\nsimilarity index 100%\nrename from boards/synopsys/emsdp/doc/emsdp.jpg\nrename to boards/snps/emsdp/doc/emsdp.jpg\nsimilarity index 100%\nrename from boards/synopsys/emsdp/doc/index.rst\nrename to boards/snps/emsdp/doc/index.rst\nsimilarity index 100%\nrename from boards/synopsys/emsdp/emsdp-pinctrl.dtsi\nrename to boards/snps/emsdp/emsdp-pinctrl.dtsi\nsimilarity index 100%\nrename from boards/synopsys/emsdp/emsdp_defconfig\nrename to boards/snps/emsdp/emsdp_defconfig\nsimilarity index 100%\nrename from boards/synopsys/emsdp/emsdp_emsdp_em11d.dts\nrename to boards/snps/emsdp/emsdp_emsdp_em11d.dts\nsimilarity index 100%\nrename from boards/synopsys/emsdp/emsdp_emsdp_em11d.yaml\nrename to boards/snps/emsdp/emsdp_emsdp_em11d.yaml\nsimilarity index 100%\nrename from boards/synopsys/emsdp/emsdp_emsdp_em11d_defconfig\nrename to boards/snps/emsdp/emsdp_emsdp_em11d_defconfig\nsimilarity index 100%\nrename from boards/synopsys/emsdp/emsdp_emsdp_em4.dts\nrename to boards/snps/emsdp/emsdp_emsdp_em4.dts\nsimilarity index 100%\nrename from boards/synopsys/emsdp/emsdp_emsdp_em4.yaml\nrename to boards/snps/emsdp/emsdp_emsdp_em4.yaml\nsimilarity index 100%\nrename from boards/synopsys/emsdp/emsdp_emsdp_em5d.dts\nrename to boards/snps/emsdp/emsdp_emsdp_em5d.dts\nsimilarity index 100%\nrename from boards/synopsys/emsdp/emsdp_emsdp_em5d.yaml\nrename to boards/snps/emsdp/emsdp_emsdp_em5d.yaml\nsimilarity index 100%\nrename from boards/synopsys/emsdp/emsdp_emsdp_em5d_defconfig\nrename to boards/snps/emsdp/emsdp_emsdp_em5d_defconfig\nsimilarity index 100%\nrename from boards/synopsys/emsdp/emsdp_emsdp_em6.dts\nrename to boards/snps/emsdp/emsdp_emsdp_em6.dts\nsimilarity index 100%\nrename from boards/synopsys/emsdp/emsdp_emsdp_em6.yaml\nrename to boards/snps/emsdp/emsdp_emsdp_em6.yaml\nsimilarity index 100%\nrename from boards/synopsys/emsdp/emsdp_emsdp_em6_defconfig\nrename to boards/snps/emsdp/emsdp_emsdp_em6_defconfig\nsimilarity index 100%\nrename from boards/synopsys/emsdp/emsdp_emsdp_em7d.dts\nrename to boards/snps/emsdp/emsdp_emsdp_em7d.dts\nsimilarity index 100%\nrename from boards/synopsys/emsdp/emsdp_emsdp_em7d.yaml\nrename to boards/snps/emsdp/emsdp_emsdp_em7d.yaml\nsimilarity index 100%\nrename from boards/synopsys/emsdp/emsdp_emsdp_em7d_esp.dts\nrename to boards/snps/emsdp/emsdp_emsdp_em7d_esp.dts\nsimilarity index 100%\nrename from boards/synopsys/emsdp/emsdp_emsdp_em7d_esp.yaml\nrename to boards/snps/emsdp/emsdp_emsdp_em7d_esp.yaml\nsimilarity index 100%\nrename from boards/synopsys/emsdp/emsdp_emsdp_em7d_esp_defconfig\nrename to boards/snps/emsdp/emsdp_emsdp_em7d_esp_defconfig\nsimilarity index 100%\nrename from boards/synopsys/emsdp/emsdp_emsdp_em9d.dts\nrename to boards/snps/emsdp/emsdp_emsdp_em9d.dts\nsimilarity index 100%\nrename from boards/synopsys/emsdp/emsdp_emsdp_em9d.yaml\nrename to boards/snps/emsdp/emsdp_emsdp_em9d.yaml\nsimilarity index 100%\nrename from boards/synopsys/emsdp/emsdp_emsdp_em9d_defconfig\nrename to boards/snps/emsdp/emsdp_emsdp_em9d_defconfig\nsimilarity index 100%\nrename from boards/synopsys/emsdp/platform.c\nrename to boards/snps/emsdp/platform.c\nsimilarity index 100%\nrename from boards/synopsys/emsdp/support/openocd.cfg\nrename to boards/snps/emsdp/support/openocd.cfg\nsimilarity index 100%\nrename from boards/synopsys/hsdk/CMakeLists.txt\nrename to boards/snps/hsdk/CMakeLists.txt\nsimilarity index 100%\nrename from boards/synopsys/hsdk/Kconfig.defconfig\nrename to boards/snps/hsdk/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/synopsys/hsdk/Kconfig.hsdk\nrename to boards/snps/hsdk/Kconfig.hsdk\nsimilarity index 100%\nrename from boards/synopsys/hsdk/board.cmake\nrename to boards/snps/hsdk/board.cmake\nsimilarity index 100%\nrename from boards/synopsys/hsdk/board.yml\nrename to boards/snps/hsdk/board.yml\nsimilarity index 100%\nrename from boards/synopsys/hsdk/doc/arduino_shield_interface.jpg\nrename to boards/snps/hsdk/doc/arduino_shield_interface.jpg\nsimilarity index 100%\nrename from boards/synopsys/hsdk/doc/hsdk.jpg\nrename to boards/snps/hsdk/doc/hsdk.jpg\nsimilarity index 100%\nrename from boards/synopsys/hsdk/doc/index.rst\nrename to boards/snps/hsdk/doc/index.rst\nsimilarity index 100%\nrename from boards/synopsys/hsdk/doc/mikrobus_header.jpg\nrename to boards/snps/hsdk/doc/mikrobus_header.jpg\nsimilarity index 100%\nrename from boards/synopsys/hsdk/doc/pinout_diagram_of_the_pmod.jpg\nrename to boards/snps/hsdk/doc/pinout_diagram_of_the_pmod.jpg\nsimilarity index 100%\nrename from boards/synopsys/hsdk/hsdk.dts\nrename to boards/snps/hsdk/hsdk.dts\nsimilarity index 100%\nrename from boards/synopsys/hsdk/hsdk.dtsi\nrename to boards/snps/hsdk/hsdk.dtsi\nsimilarity index 100%\nrename from boards/synopsys/hsdk/hsdk.yaml\nrename to boards/snps/hsdk/hsdk.yaml\nsimilarity index 100%\nrename from boards/synopsys/hsdk/hsdk_arc_hsdk_2cores.dts\nrename to boards/snps/hsdk/hsdk_arc_hsdk_2cores.dts\nsimilarity index 100%\nrename from boards/synopsys/hsdk/hsdk_arc_hsdk_2cores.yaml\nrename to boards/snps/hsdk/hsdk_arc_hsdk_2cores.yaml\nsimilarity index 100%\nrename from boards/synopsys/hsdk/hsdk_arc_hsdk_2cores_defconfig\nrename to boards/snps/hsdk/hsdk_arc_hsdk_2cores_defconfig\nsimilarity index 100%\nrename from boards/synopsys/hsdk/hsdk_defconfig\nrename to boards/snps/hsdk/hsdk_defconfig\nsimilarity index 100%\nrename from boards/synopsys/hsdk/platform.c\nrename to boards/snps/hsdk/platform.c\nsimilarity index 100%\nrename from boards/synopsys/hsdk/support/openocd-2-cores.cfg\nrename to boards/snps/hsdk/support/openocd-2-cores.cfg\nsimilarity index 100%\nrename from boards/synopsys/hsdk/support/openocd.cfg\nrename to boards/snps/hsdk/support/openocd.cfg\nsimilarity index 100%\nrename from boards/synopsys/hsdk4xd/CMakeLists.txt\nrename to boards/snps/hsdk4xd/CMakeLists.txt\nsimilarity index 100%\nrename from boards/synopsys/hsdk4xd/Kconfig.hsdk4xd\nrename to boards/snps/hsdk4xd/Kconfig.hsdk4xd\nsimilarity index 100%\nrename from boards/synopsys/hsdk4xd/board.cmake\nrename to boards/snps/hsdk4xd/board.cmake\nsimilarity index 100%\nrename from boards/synopsys/hsdk4xd/board.yml\nrename to boards/snps/hsdk4xd/board.yml\nsimilarity index 100%\nrename from boards/synopsys/hsdk4xd/doc/arduino_shield_interface.jpg\nrename to boards/snps/hsdk4xd/doc/arduino_shield_interface.jpg\nsimilarity index 100%\nrename from boards/synopsys/hsdk4xd/doc/hsdk4xd.jpg\nrename to boards/snps/hsdk4xd/doc/hsdk4xd.jpg\nsimilarity index 100%\nrename from boards/synopsys/hsdk4xd/doc/index.rst\nrename to boards/snps/hsdk4xd/doc/index.rst\nsimilarity index 100%\nrename from boards/synopsys/hsdk4xd/doc/mikrobus_header.jpg\nrename to boards/snps/hsdk4xd/doc/mikrobus_header.jpg\nsimilarity index 100%\nrename from boards/synopsys/hsdk4xd/doc/pinout_diagram_of_the_pmod.jpg\nrename to boards/snps/hsdk4xd/doc/pinout_diagram_of_the_pmod.jpg\nsimilarity index 100%\nrename from boards/synopsys/hsdk4xd/hsdk4xd.dts\nrename to boards/snps/hsdk4xd/hsdk4xd.dts\nsimilarity index 100%\nrename from boards/synopsys/hsdk4xd/hsdk4xd.yaml\nrename to boards/snps/hsdk4xd/hsdk4xd.yaml\nsimilarity index 100%\nrename from boards/synopsys/hsdk4xd/hsdk4xd_defconfig\nrename to boards/snps/hsdk4xd/hsdk4xd_defconfig\nsimilarity index 100%\nrename from boards/synopsys/hsdk4xd/support/openocd.cfg\nrename to boards/snps/hsdk4xd/support/openocd.cfg\nsimilarity index 100%\nrename from boards/synopsys/index.rst\nrename to boards/snps/index.rst\nsimilarity index 100%\nrename from boards/synopsys/iotdk/CMakeLists.txt\nrename to boards/snps/iotdk/CMakeLists.txt\nsimilarity index 100%\nrename from boards/synopsys/iotdk/Kconfig.iotdk\nrename to boards/snps/iotdk/Kconfig.iotdk\nsimilarity index 100%\nrename from boards/synopsys/iotdk/arc_mpu_regions.c\nrename to boards/snps/iotdk/arc_mpu_regions.c\nsimilarity index 100%\nrename from boards/synopsys/iotdk/board.cmake\nrename to boards/snps/iotdk/board.cmake\nsimilarity index 100%\nrename from boards/synopsys/iotdk/board.yml\nrename to boards/snps/iotdk/board.yml\nsimilarity index 100%\nrename from boards/synopsys/iotdk/doc/index.rst\nrename to boards/snps/iotdk/doc/index.rst\nsimilarity index 100%\nrename from boards/synopsys/iotdk/doc/iotdk.jpg\nrename to boards/snps/iotdk/doc/iotdk.jpg\nsimilarity index 100%\nrename from boards/synopsys/iotdk/iotdk.dts\nrename to boards/snps/iotdk/iotdk.dts\nsimilarity index 100%\nrename from boards/synopsys/iotdk/iotdk.yaml\nrename to boards/snps/iotdk/iotdk.yaml\nsimilarity index 100%\nrename from boards/synopsys/iotdk/iotdk_defconfig\nrename to boards/snps/iotdk/iotdk_defconfig\nsimilarity index 100%\nrename from boards/synopsys/iotdk/support/openocd.cfg\nrename to boards/snps/iotdk/support/openocd.cfg\nsimilarity index 100%\nrename from boards/synopsys/nsim/CMakeLists.txt\nrename to boards/snps/nsim/CMakeLists.txt\nsimilarity index 100%\nrename from boards/synopsys/nsim/Kconfig\nrename to boards/snps/nsim/Kconfig\nsimilarity index 100%\nrename from boards/synopsys/nsim/Kconfig.nsim\nrename to boards/snps/nsim/Kconfig.nsim\nsimilarity index 100%\nrename from boards/synopsys/nsim/arc_mpu_regions.c\nrename to boards/snps/nsim/arc_mpu_regions.c\nsimilarity index 100%\nrename from boards/synopsys/nsim/board.cmake\nrename to boards/snps/nsim/board.cmake\nsimilarity index 100%\nrename from boards/synopsys/nsim/board.yml\nrename to boards/snps/nsim/board.yml\nsimilarity index 100%\nrename from boards/synopsys/nsim/doc/index.rst\nrename to boards/snps/nsim/doc/index.rst\nsimilarity index 100%\nrename from boards/synopsys/nsim/haps_arcv3_init.c\nrename to boards/snps/nsim/haps_arcv3_init.c\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim-ccm-mem.dtsi\nrename to boards/snps/nsim/nsim-ccm-mem.dtsi\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim-flash-sram-mem.dtsi\nrename to boards/snps/nsim/nsim-flash-sram-mem.dtsi\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim-flat-mem.dtsi\nrename to boards/snps/nsim/nsim-flat-mem.dtsi\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim-smp.dtsi\nrename to boards/snps/nsim/nsim-smp.dtsi\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim-uart-hostlink.dtsi\nrename to boards/snps/nsim/nsim-uart-hostlink.dtsi\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim-uart-ns16550.dtsi\nrename to boards/snps/nsim/nsim-uart-ns16550.dtsi\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim.dtsi\nrename to boards/snps/nsim/nsim.dtsi\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_em-sec.dtsi\nrename to boards/snps/nsim/nsim_em-sec.dtsi\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_em.dtsi\nrename to boards/snps/nsim/nsim_em.dtsi\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_em.dts\nrename to boards/snps/nsim/nsim_nsim_em.dts\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_em.yaml\nrename to boards/snps/nsim/nsim_nsim_em.yaml\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_em11d.dts\nrename to boards/snps/nsim/nsim_nsim_em11d.dts\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_em11d.yaml\nrename to boards/snps/nsim/nsim_nsim_em11d.yaml\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_em11d_defconfig\nrename to boards/snps/nsim/nsim_nsim_em11d_defconfig\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_em7d_v22.dts\nrename to boards/snps/nsim/nsim_nsim_em7d_v22.dts\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_em7d_v22.yaml\nrename to boards/snps/nsim/nsim_nsim_em7d_v22.yaml\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_em7d_v22_defconfig\nrename to boards/snps/nsim/nsim_nsim_em7d_v22_defconfig\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_em_defconfig\nrename to boards/snps/nsim/nsim_nsim_em_defconfig\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs.dts\nrename to boards/snps/nsim/nsim_nsim_hs.dts\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs.yaml\nrename to boards/snps/nsim/nsim_nsim_hs.yaml\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs5x.dts\nrename to boards/snps/nsim/nsim_nsim_hs5x.dts\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs5x.yaml\nrename to boards/snps/nsim/nsim_nsim_hs5x.yaml\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs5x_defconfig\nrename to boards/snps/nsim/nsim_nsim_hs5x_defconfig\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs5x_smp.dts\nrename to boards/snps/nsim/nsim_nsim_hs5x_smp.dts\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs5x_smp.yaml\nrename to boards/snps/nsim/nsim_nsim_hs5x_smp.yaml\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs5x_smp_12cores.dts\nrename to boards/snps/nsim/nsim_nsim_hs5x_smp_12cores.dts\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs5x_smp_12cores.yaml\nrename to boards/snps/nsim/nsim_nsim_hs5x_smp_12cores.yaml\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs5x_smp_12cores_defconfig\nrename to boards/snps/nsim/nsim_nsim_hs5x_smp_12cores_defconfig\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs5x_smp_defconfig\nrename to boards/snps/nsim/nsim_nsim_hs5x_smp_defconfig\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs6x.dts\nrename to boards/snps/nsim/nsim_nsim_hs6x.dts\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs6x.yaml\nrename to boards/snps/nsim/nsim_nsim_hs6x.yaml\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs6x_defconfig\nrename to boards/snps/nsim/nsim_nsim_hs6x_defconfig\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs6x_smp.dts\nrename to boards/snps/nsim/nsim_nsim_hs6x_smp.dts\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs6x_smp.yaml\nrename to boards/snps/nsim/nsim_nsim_hs6x_smp.yaml\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs6x_smp_12cores.dts\nrename to boards/snps/nsim/nsim_nsim_hs6x_smp_12cores.dts\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs6x_smp_12cores.yaml\nrename to boards/snps/nsim/nsim_nsim_hs6x_smp_12cores.yaml\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs6x_smp_12cores_defconfig\nrename to boards/snps/nsim/nsim_nsim_hs6x_smp_12cores_defconfig\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs6x_smp_defconfig\nrename to boards/snps/nsim/nsim_nsim_hs6x_smp_defconfig\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs_defconfig\nrename to boards/snps/nsim/nsim_nsim_hs_defconfig\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs_flash_xip.dts\nrename to boards/snps/nsim/nsim_nsim_hs_flash_xip.dts\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs_flash_xip.yaml\nrename to boards/snps/nsim/nsim_nsim_hs_flash_xip.yaml\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs_flash_xip_defconfig\nrename to boards/snps/nsim/nsim_nsim_hs_flash_xip_defconfig\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs_hostlink.dts\nrename to boards/snps/nsim/nsim_nsim_hs_hostlink.dts\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs_hostlink.yaml\nrename to boards/snps/nsim/nsim_nsim_hs_hostlink.yaml\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs_mpuv6.dts\nrename to boards/snps/nsim/nsim_nsim_hs_mpuv6.dts\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs_mpuv6.yaml\nrename to boards/snps/nsim/nsim_nsim_hs_mpuv6.yaml\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs_smp.dts\nrename to boards/snps/nsim/nsim_nsim_hs_smp.dts\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs_smp.yaml\nrename to boards/snps/nsim/nsim_nsim_hs_smp.yaml\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs_smp_defconfig\nrename to boards/snps/nsim/nsim_nsim_hs_smp_defconfig\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs_sram.dts\nrename to boards/snps/nsim/nsim_nsim_hs_sram.dts\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs_sram.yaml\nrename to boards/snps/nsim/nsim_nsim_hs_sram.yaml\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_hs_sram_defconfig\nrename to boards/snps/nsim/nsim_nsim_hs_sram_defconfig\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_sem.dts\nrename to boards/snps/nsim/nsim_nsim_sem.dts\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_sem.yaml\nrename to boards/snps/nsim/nsim_nsim_sem.yaml\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_sem_defconfig\nrename to boards/snps/nsim/nsim_nsim_sem_defconfig\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_sem_mpu_stack_guard.dts\nrename to boards/snps/nsim/nsim_nsim_sem_mpu_stack_guard.dts\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_sem_mpu_stack_guard.yaml\nrename to boards/snps/nsim/nsim_nsim_sem_mpu_stack_guard.yaml\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_sem_mpu_stack_guard_defconfig\nrename to boards/snps/nsim/nsim_nsim_sem_mpu_stack_guard_defconfig\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_vpx5.dts\nrename to boards/snps/nsim/nsim_nsim_vpx5.dts\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_vpx5.yaml\nrename to boards/snps/nsim/nsim_nsim_vpx5.yaml\nsimilarity index 100%\nrename from boards/synopsys/nsim/nsim_nsim_vpx5_defconfig\nrename to boards/snps/nsim/nsim_nsim_vpx5_defconfig\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/mdb_em.args\nrename to boards/snps/nsim/support/mdb_em.args\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/mdb_em11d.args\nrename to boards/snps/nsim/support/mdb_em11d.args\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/mdb_em7d_v22.args\nrename to boards/snps/nsim/support/mdb_em7d_v22.args\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/mdb_hs.args\nrename to boards/snps/nsim/support/mdb_hs.args\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/mdb_hs5x.args\nrename to boards/snps/nsim/support/mdb_hs5x.args\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/mdb_hs5x_smp.args\nrename to boards/snps/nsim/support/mdb_hs5x_smp.args\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/mdb_hs5x_smp_12cores.args\nrename to boards/snps/nsim/support/mdb_hs5x_smp_12cores.args\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/mdb_hs6x.args\nrename to boards/snps/nsim/support/mdb_hs6x.args\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/mdb_hs6x_smp.args\nrename to boards/snps/nsim/support/mdb_hs6x_smp.args\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/mdb_hs6x_smp_12cores.args\nrename to boards/snps/nsim/support/mdb_hs6x_smp_12cores.args\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/mdb_hs_flash_xip.args\nrename to boards/snps/nsim/support/mdb_hs_flash_xip.args\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/mdb_hs_hostlink.args\nrename to boards/snps/nsim/support/mdb_hs_hostlink.args\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/mdb_hs_mpuv6.args\nrename to boards/snps/nsim/support/mdb_hs_mpuv6.args\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/mdb_hs_smp.args\nrename to boards/snps/nsim/support/mdb_hs_smp.args\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/mdb_hs_sram.args\nrename to boards/snps/nsim/support/mdb_hs_sram.args\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/mdb_sem.args\nrename to boards/snps/nsim/support/mdb_sem.args\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/mdb_sem_mpu_stack_guard.args\nrename to boards/snps/nsim/support/mdb_sem_mpu_stack_guard.args\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/mdb_vpx5.args\nrename to boards/snps/nsim/support/mdb_vpx5.args\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/nsim_em.props\nrename to boards/snps/nsim/support/nsim_em.props\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/nsim_em11d.props\nrename to boards/snps/nsim/support/nsim_em11d.props\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/nsim_em7d_v22.props\nrename to boards/snps/nsim/support/nsim_em7d_v22.props\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/nsim_hs.props\nrename to boards/snps/nsim/support/nsim_hs.props\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/nsim_hs5x.props\nrename to boards/snps/nsim/support/nsim_hs5x.props\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/nsim_hs6x.props\nrename to boards/snps/nsim/support/nsim_hs6x.props\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/nsim_hs_flash_xip.props\nrename to boards/snps/nsim/support/nsim_hs_flash_xip.props\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/nsim_hs_hostlink.props\nrename to boards/snps/nsim/support/nsim_hs_hostlink.props\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/nsim_hs_mpuv6.props\nrename to boards/snps/nsim/support/nsim_hs_mpuv6.props\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/nsim_hs_sram.props\nrename to boards/snps/nsim/support/nsim_hs_sram.props\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/nsim_sem.props\nrename to boards/snps/nsim/support/nsim_sem.props\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/nsim_sem_mpu_stack_guard.props\nrename to boards/snps/nsim/support/nsim_sem_mpu_stack_guard.props\nsimilarity index 100%\nrename from boards/synopsys/nsim/support/nsim_vpx5.props\nrename to boards/snps/nsim/support/nsim_vpx5.props\nsimilarity index 100%\nrename from boards/up/index.rst\nrename to boards/up-bridge-the-gap/index.rst\nsimilarity index 100%\nrename from boards/up/up_squared/CMakeLists.txt\nrename to boards/up-bridge-the-gap/up_squared/CMakeLists.txt\nsimilarity index 100%\nrename from boards/up/up_squared/Kconfig.defconfig\nrename to boards/up-bridge-the-gap/up_squared/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/up/up_squared/Kconfig.up_squared\nrename to boards/up-bridge-the-gap/up_squared/Kconfig.up_squared\nsimilarity index 100%\nrename from boards/up/up_squared/board.cmake\nrename to boards/up-bridge-the-gap/up_squared/board.cmake\nsimilarity index 100%\nrename from boards/up/up_squared/board.h\nrename to boards/up-bridge-the-gap/up_squared/board.h\nsimilarity index 100%\nrename from boards/up/up_squared/board.yml\nrename to boards/up-bridge-the-gap/up_squared/board.yml\nsimilarity index 100%\nrename from boards/up/up_squared/doc/img/up_squared.jpg\nrename to boards/up-bridge-the-gap/up_squared/doc/img/up_squared.jpg\nsimilarity index 100%\nrename from boards/up/up_squared/doc/index.rst\nrename to boards/up-bridge-the-gap/up_squared/doc/index.rst\nsimilarity index 100%\nrename from boards/up/up_squared/up_squared.dts\nrename to boards/up-bridge-the-gap/up_squared/up_squared.dts\nsimilarity index 100%\nrename from boards/up/up_squared/up_squared.yaml\nrename to boards/up-bridge-the-gap/up_squared/up_squared.yaml\nsimilarity index 100%\nrename from boards/up/up_squared/up_squared_defconfig\nrename to boards/up-bridge-the-gap/up_squared/up_squared_defconfig\nsimilarity index 100%\nrename from boards/up/up_squared_pro_7000/CMakeLists.txt\nrename to boards/up-bridge-the-gap/up_squared_pro_7000/CMakeLists.txt\nsimilarity index 100%\nrename from boards/up/up_squared_pro_7000/Kconfig.defconfig\nrename to boards/up-bridge-the-gap/up_squared_pro_7000/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/up/up_squared_pro_7000/Kconfig.up_squared_pro_7000\nrename to boards/up-bridge-the-gap/up_squared_pro_7000/Kconfig.up_squared_pro_7000\nsimilarity index 100%\nrename from boards/up/up_squared_pro_7000/board.cmake\nrename to boards/up-bridge-the-gap/up_squared_pro_7000/board.cmake\nsimilarity index 100%\nrename from boards/up/up_squared_pro_7000/board.yml\nrename to boards/up-bridge-the-gap/up_squared_pro_7000/board.yml\nsimilarity index 100%\nrename from boards/up/up_squared_pro_7000/doc/up_squared_pro_7000.rst\nrename to boards/up-bridge-the-gap/up_squared_pro_7000/doc/up_squared_pro_7000.rst\nsimilarity index 100%\nrename from boards/up/up_squared_pro_7000/up_squared_pro_7000.dts\nrename to boards/up-bridge-the-gap/up_squared_pro_7000/up_squared_pro_7000.dts\nsimilarity index 100%\nrename from boards/up/up_squared_pro_7000/up_squared_pro_7000.yaml\nrename to boards/up-bridge-the-gap/up_squared_pro_7000/up_squared_pro_7000.yaml\nsimilarity index 100%\nrename from boards/up/up_squared_pro_7000/up_squared_pro_7000_defconfig\nrename to boards/up-bridge-the-gap/up_squared_pro_7000/up_squared_pro_7000_defconfig\nsimilarity index 100%\nrename from boards/vng/index.rst\nrename to boards/vngiotlab/index.rst\nsimilarity index 100%\nrename from boards/vng/nrf51_vbluno51/Kconfig.defconfig\nrename to boards/vngiotlab/nrf51_vbluno51/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/vng/nrf51_vbluno51/Kconfig.nrf51_vbluno51\nrename to boards/vngiotlab/nrf51_vbluno51/Kconfig.nrf51_vbluno51\nsimilarity index 100%\nrename from boards/vng/nrf51_vbluno51/board.cmake\nrename to boards/vngiotlab/nrf51_vbluno51/board.cmake\nsimilarity index 100%\nrename from boards/vng/nrf51_vbluno51/board.yml\nrename to boards/vngiotlab/nrf51_vbluno51/board.yml\nsimilarity index 100%\nrename from boards/vng/nrf51_vbluno51/doc/img/nrf51_vbluno51.jpg\nrename to boards/vngiotlab/nrf51_vbluno51/doc/img/nrf51_vbluno51.jpg\nsimilarity index 100%\nrename from boards/vng/nrf51_vbluno51/doc/img/nrf51_vbluno51_bot.jpg\nrename to boards/vngiotlab/nrf51_vbluno51/doc/img/nrf51_vbluno51_bot.jpg\nsimilarity index 100%\nrename from boards/vng/nrf51_vbluno51/doc/img/vbluno51_frizting.jpg\nrename to boards/vngiotlab/nrf51_vbluno51/doc/img/vbluno51_frizting.jpg\nsimilarity index 100%\nrename from boards/vng/nrf51_vbluno51/doc/img/vbluno51_nordic_pinout.jpg\nrename to boards/vngiotlab/nrf51_vbluno51/doc/img/vbluno51_nordic_pinout.jpg\nsimilarity index 100%\nrename from boards/vng/nrf51_vbluno51/doc/index.rst\nrename to boards/vngiotlab/nrf51_vbluno51/doc/index.rst\nsimilarity index 100%\nrename from boards/vng/nrf51_vbluno51/nrf51_vbluno51-pinctrl.dtsi\nrename to boards/vngiotlab/nrf51_vbluno51/nrf51_vbluno51-pinctrl.dtsi\nsimilarity index 100%\nrename from boards/vng/nrf51_vbluno51/nrf51_vbluno51.dts\nrename to boards/vngiotlab/nrf51_vbluno51/nrf51_vbluno51.dts\nsimilarity index 100%\nrename from boards/vng/nrf51_vbluno51/nrf51_vbluno51.yaml\nrename to boards/vngiotlab/nrf51_vbluno51/nrf51_vbluno51.yaml\nsimilarity index 100%\nrename from boards/vng/nrf51_vbluno51/nrf51_vbluno51_defconfig\nrename to boards/vngiotlab/nrf51_vbluno51/nrf51_vbluno51_defconfig\nsimilarity index 100%\nrename from boards/vng/nrf51_vbluno51/pre_dt_board.cmake\nrename to boards/vngiotlab/nrf51_vbluno51/pre_dt_board.cmake\nsimilarity index 100%\nrename from boards/vng/nrf52_vbluno52/Kconfig.defconfig\nrename to boards/vngiotlab/nrf52_vbluno52/Kconfig.defconfig\nsimilarity index 100%\nrename from boards/vng/nrf52_vbluno52/Kconfig.nrf52_vbluno52\nrename to boards/vngiotlab/nrf52_vbluno52/Kconfig.nrf52_vbluno52\nsimilarity index 100%\nrename from boards/vng/nrf52_vbluno52/board.cmake\nrename to boards/vngiotlab/nrf52_vbluno52/board.cmake\nsimilarity index 100%\nrename from boards/vng/nrf52_vbluno52/board.yml\nrename to boards/vngiotlab/nrf52_vbluno52/board.yml\nsimilarity index 100%\nrename from boards/vng/nrf52_vbluno52/doc/img/nrf52_vbluno52.jpg\nrename to boards/vngiotlab/nrf52_vbluno52/doc/img/nrf52_vbluno52.jpg\nsimilarity index 100%\nrename from boards/vng/nrf52_vbluno52/doc/index.rst\nrename to boards/vngiotlab/nrf52_vbluno52/doc/index.rst\nsimilarity index 100%\nrename from boards/vng/nrf52_vbluno52/nrf52_vbluno52-pinctrl.dtsi\nrename to boards/vngiotlab/nrf52_vbluno52/nrf52_vbluno52-pinctrl.dtsi\nsimilarity index 100%\nrename from boards/vng/nrf52_vbluno52/nrf52_vbluno52.dts\nrename to boards/vngiotlab/nrf52_vbluno52/nrf52_vbluno52.dts\nsimilarity index 100%\nrename from boards/vng/nrf52_vbluno52/nrf52_vbluno52.yaml\nrename to boards/vngiotlab/nrf52_vbluno52/nrf52_vbluno52.yaml\nsimilarity index 100%\nrename from boards/vng/nrf52_vbluno52/nrf52_vbluno52_defconfig\nrename to boards/vngiotlab/nrf52_vbluno52/nrf52_vbluno52_defconfig\nsimilarity index 100%\nrename from boards/vng/nrf52_vbluno52/pre_dt_board.cmake\nrename to boards/vngiotlab/nrf52_vbluno52/pre_dt_board.cmake\nsimilarity index 100%\nrename from soc/synopsys/arc_iot/CMakeLists.txt\nrename to soc/snps/arc_iot/CMakeLists.txt\nsimilarity index 100%\nrename from soc/synopsys/arc_iot/Kconfig\nrename to soc/snps/arc_iot/Kconfig\nsimilarity index 100%\nrename from soc/synopsys/arc_iot/Kconfig.defconfig\nrename to soc/snps/arc_iot/Kconfig.defconfig\nsimilarity index 100%\nrename from soc/synopsys/arc_iot/Kconfig.soc\nrename to soc/snps/arc_iot/Kconfig.soc\nsimilarity index 100%\nrename from soc/synopsys/arc_iot/linker.ld\nrename to soc/snps/arc_iot/linker.ld\nsimilarity index 100%\nrename from soc/synopsys/arc_iot/soc.c\nrename to soc/snps/arc_iot/soc.c\nsimilarity index 100%\nrename from soc/synopsys/arc_iot/soc.yml\nrename to soc/snps/arc_iot/soc.yml\nsimilarity index 100%\nrename from soc/synopsys/arc_iot/sysconf.c\nrename to soc/snps/arc_iot/sysconf.c\nsimilarity index 100%\nrename from soc/synopsys/arc_iot/sysconf.h\nrename to soc/snps/arc_iot/sysconf.h\nsimilarity index 100%\nrename from soc/synopsys/emsdp/CMakeLists.txt\nrename to soc/snps/emsdp/CMakeLists.txt\nsimilarity index 100%\nrename from soc/synopsys/emsdp/Kconfig\nrename to soc/snps/emsdp/Kconfig\nsimilarity index 100%\nrename from soc/synopsys/emsdp/Kconfig.defconfig\nrename to soc/snps/emsdp/Kconfig.defconfig\nsimilarity index 100%\nrename from soc/synopsys/emsdp/Kconfig.defconfig.em11d\nrename to soc/snps/emsdp/Kconfig.defconfig.em11d\nsimilarity index 100%\nrename from soc/synopsys/emsdp/Kconfig.defconfig.em4\nrename to soc/snps/emsdp/Kconfig.defconfig.em4\nsimilarity index 100%\nrename from soc/synopsys/emsdp/Kconfig.defconfig.em5d\nrename to soc/snps/emsdp/Kconfig.defconfig.em5d\nsimilarity index 100%\nrename from soc/synopsys/emsdp/Kconfig.defconfig.em6\nrename to soc/snps/emsdp/Kconfig.defconfig.em6\nsimilarity index 100%\nrename from soc/synopsys/emsdp/Kconfig.defconfig.em7d\nrename to soc/snps/emsdp/Kconfig.defconfig.em7d\nsimilarity index 100%\nrename from soc/synopsys/emsdp/Kconfig.defconfig.em7d_esp\nrename to soc/snps/emsdp/Kconfig.defconfig.em7d_esp\nsimilarity index 100%\nrename from soc/synopsys/emsdp/Kconfig.defconfig.em9d\nrename to soc/snps/emsdp/Kconfig.defconfig.em9d\nsimilarity index 100%\nrename from soc/synopsys/emsdp/Kconfig.soc\nrename to soc/snps/emsdp/Kconfig.soc\nsimilarity index 100%\nrename from soc/synopsys/emsdp/linker.ld\nrename to soc/snps/emsdp/linker.ld\nsimilarity index 100%\nrename from soc/synopsys/emsdp/pinctrl_soc.h\nrename to soc/snps/emsdp/pinctrl_soc.h\nsimilarity index 100%\nrename from soc/synopsys/emsdp/soc.yml\nrename to soc/snps/emsdp/soc.yml\nsimilarity index 100%\nrename from soc/synopsys/emsk/CMakeLists.txt\nrename to soc/snps/emsk/CMakeLists.txt\nsimilarity index 100%\nrename from soc/synopsys/emsk/Kconfig\nrename to soc/snps/emsk/Kconfig\nsimilarity index 100%\nrename from soc/synopsys/emsk/Kconfig.defconfig\nrename to soc/snps/emsk/Kconfig.defconfig\nsimilarity index 100%\nrename from soc/synopsys/emsk/Kconfig.defconfig.em11d\nrename to soc/snps/emsk/Kconfig.defconfig.em11d\nsimilarity index 100%\nrename from soc/synopsys/emsk/Kconfig.defconfig.em7d\nrename to soc/snps/emsk/Kconfig.defconfig.em7d\nsimilarity index 100%\nrename from soc/synopsys/emsk/Kconfig.defconfig.em9d\nrename to soc/snps/emsk/Kconfig.defconfig.em9d\nsimilarity index 100%\nrename from soc/synopsys/emsk/Kconfig.soc\nrename to soc/snps/emsk/Kconfig.soc\nsimilarity index 100%\nrename from soc/synopsys/emsk/linker.ld\nrename to soc/snps/emsk/linker.ld\nsimilarity index 100%\nrename from soc/synopsys/emsk/soc.yml\nrename to soc/snps/emsk/soc.yml\nsimilarity index 100%\nrename from soc/synopsys/emsk/soc_config.c\nrename to soc/snps/emsk/soc_config.c\nsimilarity index 100%\nrename from soc/synopsys/hsdk/CMakeLists.txt\nrename to soc/snps/hsdk/CMakeLists.txt\nsimilarity index 100%\nrename from soc/synopsys/hsdk/Kconfig\nrename to soc/snps/hsdk/Kconfig\nsimilarity index 100%\nrename from soc/synopsys/hsdk/Kconfig.defconfig\nrename to soc/snps/hsdk/Kconfig.defconfig\nsimilarity index 100%\nrename from soc/synopsys/hsdk/Kconfig.soc\nrename to soc/snps/hsdk/Kconfig.soc\nsimilarity index 100%\nrename from soc/synopsys/hsdk/linker.ld\nrename to soc/snps/hsdk/linker.ld\nsimilarity index 100%\nrename from soc/synopsys/hsdk/soc.yml\nrename to soc/snps/hsdk/soc.yml\nsimilarity index 100%\nrename from soc/synopsys/hsdk4xd/CMakeLists.txt\nrename to soc/snps/hsdk4xd/CMakeLists.txt\nsimilarity index 100%\nrename from soc/synopsys/hsdk4xd/Kconfig\nrename to soc/snps/hsdk4xd/Kconfig\nsimilarity index 100%\nrename from soc/synopsys/hsdk4xd/Kconfig.defconfig\nrename to soc/snps/hsdk4xd/Kconfig.defconfig\nsimilarity index 100%\nrename from soc/synopsys/hsdk4xd/Kconfig.soc\nrename to soc/snps/hsdk4xd/Kconfig.soc\nsimilarity index 100%\nrename from soc/synopsys/hsdk4xd/linker.ld\nrename to soc/snps/hsdk4xd/linker.ld\nsimilarity index 100%\nrename from soc/synopsys/hsdk4xd/soc.yml\nrename to soc/snps/hsdk4xd/soc.yml\nsimilarity index 100%\nrename from soc/synopsys/hsdk4xd/soc_ctrl.h\nrename to soc/snps/hsdk4xd/soc_ctrl.h\nsimilarity index 100%\nrename from soc/synopsys/hsdk4xd/tune_build_ops.cmake\nrename to soc/snps/hsdk4xd/tune_build_ops.cmake\nsimilarity index 100%\nrename from soc/synopsys/nsim/CMakeLists.txt\nrename to soc/snps/nsim/CMakeLists.txt\nsimilarity index 100%\nrename from soc/synopsys/nsim/Kconfig\nrename to soc/snps/nsim/Kconfig\nsimilarity index 100%\nrename from soc/synopsys/nsim/Kconfig.defconfig\nrename to soc/snps/nsim/Kconfig.defconfig\nsimilarity index 100%\nrename from soc/synopsys/nsim/Kconfig.defconfig.em\nrename to soc/snps/nsim/Kconfig.defconfig.em\nsimilarity index 100%\nrename from soc/synopsys/nsim/Kconfig.defconfig.em11d\nrename to soc/snps/nsim/Kconfig.defconfig.em11d\nsimilarity index 100%\nrename from soc/synopsys/nsim/Kconfig.defconfig.em7d_v22\nrename to soc/snps/nsim/Kconfig.defconfig.em7d_v22\nsimilarity index 100%\nrename from soc/synopsys/nsim/Kconfig.defconfig.hs\nrename to soc/snps/nsim/Kconfig.defconfig.hs\nsimilarity index 100%\nrename from soc/synopsys/nsim/Kconfig.defconfig.hs5x\nrename to soc/snps/nsim/Kconfig.defconfig.hs5x\nsimilarity index 100%\nrename from soc/synopsys/nsim/Kconfig.defconfig.hs5x_smp\nrename to soc/snps/nsim/Kconfig.defconfig.hs5x_smp\nsimilarity index 100%\nrename from soc/synopsys/nsim/Kconfig.defconfig.hs6x\nrename to soc/snps/nsim/Kconfig.defconfig.hs6x\nsimilarity index 100%\nrename from soc/synopsys/nsim/Kconfig.defconfig.hs6x_smp\nrename to soc/snps/nsim/Kconfig.defconfig.hs6x_smp\nsimilarity index 100%\nrename from soc/synopsys/nsim/Kconfig.defconfig.hs_mpuv6\nrename to soc/snps/nsim/Kconfig.defconfig.hs_mpuv6\nsimilarity index 100%\nrename from soc/synopsys/nsim/Kconfig.defconfig.hs_smp\nrename to soc/snps/nsim/Kconfig.defconfig.hs_smp\nsimilarity index 100%\nrename from soc/synopsys/nsim/Kconfig.defconfig.sem\nrename to soc/snps/nsim/Kconfig.defconfig.sem\nsimilarity index 100%\nrename from soc/synopsys/nsim/Kconfig.defconfig.vpx5\nrename to soc/snps/nsim/Kconfig.defconfig.vpx5\nsimilarity index 100%\nrename from soc/synopsys/nsim/Kconfig.soc\nrename to soc/snps/nsim/Kconfig.soc\nsimilarity index 100%\nrename from soc/synopsys/nsim/linker.ld\nrename to soc/snps/nsim/linker.ld\nsimilarity index 100%\nrename from soc/synopsys/nsim/soc.yml\nrename to soc/snps/nsim/soc.yml\nsimilarity index 100%\nrename from soc/synopsys/qemu_arc/CMakeLists.txt\nrename to soc/snps/qemu_arc/CMakeLists.txt\nsimilarity index 100%\nrename from soc/synopsys/qemu_arc/Kconfig\nrename to soc/snps/qemu_arc/Kconfig\nsimilarity index 100%\nrename from soc/synopsys/qemu_arc/Kconfig.defconfig\nrename to soc/snps/qemu_arc/Kconfig.defconfig\nsimilarity index 100%\nrename from soc/synopsys/qemu_arc/Kconfig.soc\nrename to soc/snps/qemu_arc/Kconfig.soc\nsimilarity index 100%\nrename from soc/synopsys/qemu_arc/linker.ld\nrename to soc/snps/qemu_arc/linker.ld\nsimilarity index 100%\nrename from soc/synopsys/qemu_arc/soc.yml\nrename to soc/snps/qemu_arc/soc.yml",
  "result": "I corrected the issue in the code by changing the following tokens:\n-.. _boards-arturo182:\n-\n-Arturo182\n-#########\n-\n-.. toctree::\n-   :maxdepth: 1\n-   :glob:\n-\n-   **/*\nThe issue was with: boards/socs: Rename folders to have proper vendor prefix in\n\nReplaces inaccurate or wrong vendor prefixes in board and soc\nfolder names with those from thr vendor prefix file"
},{
  "instruction": "There is an issue in the following code. It relates to samples: hello_world: Use full board target string for hwmv2 boards\n\nOutputs the full board target string (including qualifiers) when\nusing a hwmv2 board Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nname|printf\nargument_list|(\nliteral|\"Hello World! %s\\n\"\nargument_list|,\nname|CONFIG_BOARD\nargument_list|)\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_BOARD\n+name|CONFIG_BOARD_TARGET\nThe issue was with: samples: hello_world: Use full board target string for hwmv2 boards\n\nOutputs the full board target string (including qualifiers) when\nusing a hwmv2 board"
},{
  "instruction": "There is an issue in the following code. It relates to net: ipv6: Introduce separate logger module for IPv6 ND\n\nDebugging IPv6 Neighbor Discovery issues requires to enable full IPv6\nlogs, which can get bloated given it provides logs for every single\npacket. We should be able to focus on IPv6 ND logs only, hence introduce\na separate log module for IPv6 ND. Please fix this issue.",
  "input": "Faulty tokenized code:\nmodule-dep = NET_LOG\nmodule-str = Log level for core IPv6\nmodule-help = Enables core IPv6 code to output debug messages.\nsource \"subsys/net/Kconfig.template.log_config.net\"\n\nmodule = NET_ICMPV6\nmodule-dep = NET_LOG\nmodule-str = Log level for ICMPv6\nmodule-help = Enables ICMPv6 code to output debug messages.\nsource \"subsys/net/Kconfig.template.log_config.net\"\ndirective|include\nfile|<zephyr/logging/log.h>\nend_include\n\nbegin_expr_stmt\nname|LOG_MODULE_DECLARE\nargument_list|(\nname|net_ipv6\nargument_list|,\nname|CONFIG_NET_IPV6_LOG_LEVEL\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+module = NET_IPV6_ND\n+module-dep = NET_LOG\n+module-str = Log level for IPv6 Neighbor Discovery\n+module-help = Enables IPv6 Neighbor Discovery code to output debug messages.\n+source \"subsys/net/Kconfig.template.log_config.net\"\n+\n-name|LOG_MODULE_DECLARE\n+name|LOG_MODULE_REGISTER\n-name|net_ipv6\n+name|net_ipv6_nd\n-name|CONFIG_NET_IPV6_LOG_LEVEL\n+name|CONFIG_NET_IPV6_ND_LOG_LEVEL\nThe issue was with: net: ipv6: Introduce separate logger module for IPv6 ND\n\nDebugging IPv6 Neighbor Discovery issues requires to enable full IPv6\nlogs, which can get bloated given it provides logs for every single\npacket. We should be able to focus on IPv6 ND logs only, hence introduce\na separate log module for IPv6 ND."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Add wrn on `BT_HCI_ERR_CONN_FAIL_TO_ESTAB`\n\nRecently (during Bluetooth UPF), a lot of developers experience\nconfusion due to weird errors in SMP, etc, which are actually irrelevant\nand caused by the connection never having existed.\n\nAs a stop-gap measure, until upper layers properly report lower layer\nfailures, add a warning in the logs to stop wasting developer time. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|;\nblock|}\nend_function\n\nbegin_enum\nDECL|enum|__anon2b0cf6f90103\nenum|enum\nblock|{\nDECL|enumerator|FRAG_START\nname|FRAG_START\nblock|,\ndirective|endif\ncomment|/* CONFIG_BT_CONN */\ncase|case\nname|BT_CONN_DISCONNECT_COMPLETE\ncase|:\nname|process_unack_tx\nargument_list|(\nname|conn\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon2b0cf6f90103\n+DECL|enum|__anon2778e1720103\n+if|if\n+condition|(\n+name|conn\n+operator|->\n+name|err\n+operator|==\n+name|BT_HCI_ERR_CONN_FAIL_TO_ESTAB\n+condition|)\n+block|{\n+comment|/* No ACK or data was ever received. The peripheral may be \t\t\t * unaware of the connection attempt. \t\t\t * \t\t\t * Beware of confusing higher layer errors. Anything that looks \t\t\t * like it's from the remote is synthetic. \t\t\t */\n+name|LOG_WRN\n+argument_list|(\n+literal|\"conn %p failed to establish. RF noise?\"\n+argument_list|,\n+name|conn\n+argument_list|)\n+expr_stmt|;\n+block|}\nThe issue was with: Bluetooth: Add wrn on `BT_HCI_ERR_CONN_FAIL_TO_ESTAB`\n\nRecently (during Bluetooth UPF), a lot of developers experience\nconfusion due to weird errors in SMP, etc, which are actually irrelevant\nand caused by the connection never having existed.\n\nAs a stop-gap measure, until upper layers properly report lower layer\nfailures, add a warning in the logs to stop wasting developer time."
},{
  "instruction": "There is an issue in the following code. It relates to arch: riscv: disable interrupts before `wfi`\n\nAccording to RISC-V Instruction Set Manual Chapter 3.3.2:\n\\\"The operation of WFI must be unaffected by the global interrupt\nbits in mstatus\n[...]\nWFI is also required to resume execution for locally enabled\ninterrupts pending at any privilege level,\nregardless of the global interrupt enable at each privilege level.\\\"\n\nDisabling interrupts before executing `wfi` prevents a corner case\nwhere an IRQ is presented just before executing `wfi`,\nwhich would cause it to return directly into `wfi` and potentially\nget stuck in sleep, instead of continuing to background processing.\n\nWhen execution is resumed, interrupts are reenabled\nand appropriate IRQ Handlers should be executed. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|)\nblock|{\nname|sys_trace_idle\nargument_list|()\nexpr_stmt|;\nname|irq_unlock\nargument_list|(\nname|MSTATUS_IEN\nargument_list|)\nexpr_stmt|;\nasm|__asm__\nspecifier|volatile\nasm|(\"wfi\");\nblock|}\nend_function\n\nbegin_function\nDECL|function|arch_cpu_atomic_idle (unsigned int key)\nparameter_list|)\nblock|{\nname|sys_trace_idle\nargument_list|()\nexpr_stmt|;\nname|irq_unlock\nargument_list|(\nname|key\nargument_list|)\nexpr_stmt|;\nasm|__asm__\nspecifier|volatile\nasm|(\"wfi\");\nblock|}\nend_function\n\nend_unit\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n+asm|__asm__\n+specifier|volatile\n+asm|(\"wfi\");\n-asm|__asm__\n-specifier|volatile\n-asm|(\"wfi\");\n+asm|__asm__\n+specifier|volatile\n+asm|(\"wfi\");\n-asm|__asm__\n-specifier|volatile\n-asm|(\"wfi\");\nThe issue was with: arch: riscv: disable interrupts before `wfi`\n\nAccording to RISC-V Instruction Set Manual Chapter 3.3.2:\n\\\"The operation of WFI must be unaffected by the global interrupt\nbits in mstatus\n[...]\nWFI is also required to resume execution for locally enabled\ninterrupts pending at any privilege level,\nregardless of the global interrupt enable at each privilege level.\\\"\n\nDisabling interrupts before executing `wfi` prevents a corner case\nwhere an IRQ is presented just before executing `wfi`,\nwhich would cause it to return directly into `wfi` and potentially\nget stuck in sleep, instead of continuing to background processing.\n\nWhen execution is resumed, interrupts are reenabled\nand appropriate IRQ Handlers should be executed."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: uart_mcux_flexcomm: fix invalid use of status bits.\n\nuart flexcomm driver incorrectly used kStatus enum as mask when\nchecking for errors and enabling the error interrupts. Please fix this issue.",
  "input": "Faulty tokenized code:\ndecl_stmt|;\nif|if\ncondition|(\nname|flags\noperator|&\nname|kStatus_USART_RxRingBufferOverrun\ncondition|)\nblock|{\nname|err\noperator||=\nname|UART_ERROR_OVERRUN\nblock|}\nif|if\ncondition|(\nname|flags\noperator|&\nname|kStatus_USART_ParityError\ncondition|)\nblock|{\nname|err\noperator||=\nname|UART_ERROR_PARITY\nblock|}\nif|if\ncondition|(\nname|flags\noperator|&\nname|kStatus_USART_FramingError\ncondition|)\nblock|{\nname|err\noperator||=\nname|UART_ERROR_FRAMING\nargument_list|(\nname|config\noperator|->\nname|base\nargument_list|,\nname|kStatus_USART_RxRingBufferOverrun\noperator||\nname|kStatus_USART_ParityError\noperator||\nname|kStatus_USART_FramingError\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|err\nreturn|;\nname|config\ndecl_stmt|;\nname|uint32_t\nname|mask\ninit|=\nname|kStatus_USART_NoiseError\noperator||\nname|kStatus_USART_FramingError\noperator||\nname|kStatus_USART_ParityError\ndecl_stmt|;\nname|USART_EnableInterrupts\nargument_list|(\nname|config\noperator|->\nname|config\ndecl_stmt|;\nname|uint32_t\nname|mask\ninit|=\nname|kStatus_USART_NoiseError\noperator||\nname|kStatus_USART_FramingError\noperator||\nname|kStatus_USART_ParityError\ndecl_stmt|;\nname|USART_DisableInterrupts\nargument_list|(\nname|config\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|kStatus_USART_RxRingBufferOverrun\n+name|kUSART_RxError\n-name|kStatus_USART_ParityError\n+name|kUSART_ParityErrorFlag\n-name|kStatus_USART_FramingError\n+name|kUSART_FramingErrorFlag\n-name|kStatus_USART_RxRingBufferOverrun\n+name|kUSART_RxError\n-name|kStatus_USART_ParityError\n+name|kUSART_ParityErrorFlag\n-name|kStatus_USART_FramingError\n+name|kUSART_FramingErrorFlag\n-name|kStatus_USART_NoiseError\n+name|kUSART_NoiseErrorInterruptEnable\n-name|kStatus_USART_FramingError\n+name|kUSART_FramingErrorInterruptEnable\n-name|kStatus_USART_ParityError\n+name|kUSART_ParityErrorInterruptEnable\n-name|kStatus_USART_NoiseError\n+name|kUSART_NoiseErrorInterruptEnable\n-name|kStatus_USART_FramingError\n+name|kUSART_FramingErrorInterruptEnable\n-name|kStatus_USART_ParityError\n+name|kUSART_ParityErrorInterruptEnable\nThe issue was with: drivers: uart_mcux_flexcomm: fix invalid use of status bits.\n\nuart flexcomm driver incorrectly used kStatus enum as mask when\nchecking for errors and enabling the error interrupts."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: wdt_mcux_wwdt: Support RW\n\nSupport RW soc series in wwdt driver Please fix this issue.",
  "input": "Faulty tokenized code:\nname|CLOCK_GetWdtClkFreq\nargument_list|(\nliteral|0\nargument_list|)\nexpr_stmt|;\nelse|#\ndirective|else\nspecifier|const\nname|struct\nname|mcux_wwdt_config",
  "result": "I corrected the issue in the code by changing the following tokens:\n+elif|#\n+directive|elif\n+name|defined\n+argument_list|(\n+name|CONFIG_SOC_SERIES_RW6XX\n+argument_list|)\n+name|clock_freq\n+operator|=\n+name|CLOCK_GetWdtClkFreq\n+argument_list|()\n+expr_stmt|;\nThe issue was with: drivers: wdt_mcux_wwdt: Support RW\n\nSupport RW soc series in wwdt driver"
},{
  "instruction": "There is an issue in the following code. It relates to subsys/testsuite/ztest: Replace native_posix in one comment\n\nAs we are replacing native_posix with native_sim, let's\nrefer to native_sim instead of native_posix in the comments. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|include\nfile|\"cmdline.h\"\nend_include\n\nbegin_comment\ncomment|/* native_posix command line options header */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* native_posix command line options header */\n+comment|/* native_sim command line options header */\nThe issue was with: subsys/testsuite/ztest: Replace native_posix in one comment\n\nAs we are replacing native_posix with native_sim, let's\nrefer to native_sim instead of native_posix in the comments."
},{
  "instruction": "There is an issue in the following code. It relates to tests|scripts/net: Change native_posix references to native_sim\n\n* As we are replacing native_posix with native_sim, let's\n  refer to native_sim instead of native_posix in the comments\n  of why we have 1 extra interface.\n\n* scripts/net/run-sample-tests.sh builds for native_sim now,\n  not native_posix => let's fix it Please fix this issue.",
  "input": "Faulty tokenized code:\nUser can see what samples are supported like this:\n\n   $ZEPHYR_BASE/scripts/net/run-sample-tests.sh --scan\n\nThe Docker container and a corresponding 'net-tools0' Docker network is started\nby the script, as well as Zephyr using native_posix board. IP addresses are\nassigned to the Docker network, which is a Linux network bridge interface.\nThe default IP addresses are:\n\n * Zephyr uses addresses 192.0.2.1 and 2001:db8::1\n * Docker net-tools image uses addresses 192.0.2.2 and 2001:db8::2\nblock|}\ndecl_stmt|;\nend_decl_stmt\n\nbegin_comment\ncomment|/* Keep track of all ethernet interfaces. For native_posix board, we need  * to increase the count as it has one extra network interface defined in  * eth_native_posix driver.  */\nend_comment\n\nbegin_decl_stmt\nDECL|variable|eth_interfaces\nspecifier|static\nname|iface\nargument_list|)\noperator|->\nname|api\ndecl_stmt|;\ncomment|/* As native_posix board will introduce another ethernet \t\t * interface, make sure that we only use our own in this test. \t\t */\nif|if\ncondition|(\nname|api\noperator|->\nname|get_capabilities\nname|iface\nargument_list|)\noperator|->\nname|api\ndecl_stmt|;\ncomment|/* As native_posix board will introduce another ethernet \t\t * interface, make sure that we only use our own in this test. \t\t */\nif|if\ncondition|(\nname|api\noperator|->\nname|get_capabilities",
  "result": "I corrected the issue in the code by changing the following tokens:\n-by the script, as well as Zephyr using native_posix board. IP addresses are\n+by the script, as well as Zephyr using native_sim board. IP addresses are\n-comment|/* Keep track of all ethernet interfaces. For native_posix board, we need  * to increase the count as it has one extra network interface defined in  * eth_native_posix driver.  */\n+comment|/* Keep track of all ethernet interfaces. For native_sim board, we need  * to increase the count as it has one extra network interface defined in  * eth_native_posix driver.  */\n-comment|/* As native_posix board will introduce another ethernet \t\t * interface, make sure that we only use our own in this test. \t\t */\n+comment|/* As native_sim board will introduce another ethernet \t\t * interface, make sure that we only use our own in this test. \t\t */\n-comment|/* As native_posix board will introduce another ethernet \t\t * interface, make sure that we only use our own in this test. \t\t */\n+comment|/* As native_sim board will introduce another ethernet \t\t * interface, make sure that we only use our own in this test. \t\t */\nThe issue was with: tests|scripts/net: Change native_posix references to native_sim\n\n* As we are replacing native_posix with native_sim, let's\n  refer to native_sim instead of native_posix in the comments\n  of why we have 1 extra interface.\n\n* scripts/net/run-sample-tests.sh builds for native_sim now,\n  not native_posix => let's fix it"
},{
  "instruction": "There is an issue in the following code. It relates to bluetooth: audio: broadcast source: Add missing check condition\n\nThere is no need to validate stream_param->data if it is NULL.\nFixes failing PTS BAP/BSRC test cases. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|false\nreturn|;\nblock|}\nname|CHECKIF\nargument_list|(\nargument|subgroup_param->codec_cfg->id == BT_HCI_CODING_FORMAT_LC3&& \t\t\t\t!bt_audio_valid_ltv(stream_param->data, stream_param->data_len)\nargument_list|)\nblock|{\nname|LOG_DBG\nargument_list|(\nliteral|\"subgroup_params[%zu].stream_params[%zu]->data not valid \"",
  "result": "I corrected the issue in the code by changing the following tokens:\n-argument|subgroup_param->codec_cfg->id == BT_HCI_CODING_FORMAT_LC3&& \t\t\t\t!bt_audio_valid_ltv(stream_param->data, stream_param->data_len)\n+argument|stream_param->data != NULL&& \t\t\t\tsubgroup_param->codec_cfg->id == BT_HCI_CODING_FORMAT_LC3&& \t\t\t\t!bt_audio_valid_ltv(stream_param->data, stream_param->data_len)\nThe issue was with: bluetooth: audio: broadcast source: Add missing check condition\n\nThere is no need to validate stream_param->data if it is NULL.\nFixes failing PTS BAP/BSRC test cases."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: ethernet: adin2111: Use ethernet init macro\n\nUse the ethernet specific init macro. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|phy_n\nparameter_list|,\nname|name\nparameter_list|)\ndefine|\\\nvalue|static struct adin2111_port_data name##_port_data_##port_n = {\t\t\t\t\\ \t\t.mac_addr = ADIN2111_PORT_MAC(parent_n, phy_n),\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct adin2111_port_config name##_port_config_##port_n = {\t\t\\ \t\t.adin = DEVICE_DT_INST_GET(parent_n),\t\t\t\t\t\t\\ \t\t.phy = ADIN2111_MDIO_PHY_BY_ADDR(parent_n, phy_n),\t\t\t\t\\ \t\t.port_idx = port_n,\t\t\t\t\t\t\t\t\\ \t\t.phy_addr = phy_n,\t\t\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \tNET_DEVICE_INIT_INSTANCE(name##_port_##port_n, \"port_\" ADIN2111_XSTR(port_n), port_n,\t\\ \t\t\t\t NULL, NULL,&name##_port_data_##port_n,\t\t\t\\&name##_port_config_##port_n, CONFIG_ETH_INIT_PRIORITY,\t\\&adin2111_port_api, ETHERNET_L2,\t\t\t\t\\ \t\t\t\t NET_L2_GET_CTX_TYPE(ETHERNET_L2), NET_ETH_MTU);\nend_define\n\nbegin_define\nDECL|macro|ADIN2111_SPI_OPERATION\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|static struct adin2111_port_data name##_port_data_##port_n = {\t\t\t\t\\ \t\t.mac_addr = ADIN2111_PORT_MAC(parent_n, phy_n),\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct adin2111_port_config name##_port_config_##port_n = {\t\t\\ \t\t.adin = DEVICE_DT_INST_GET(parent_n),\t\t\t\t\t\t\\ \t\t.phy = ADIN2111_MDIO_PHY_BY_ADDR(parent_n, phy_n),\t\t\t\t\\ \t\t.port_idx = port_n,\t\t\t\t\t\t\t\t\\ \t\t.phy_addr = phy_n,\t\t\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \tNET_DEVICE_INIT_INSTANCE(name##_port_##port_n, \"port_\" ADIN2111_XSTR(port_n), port_n,\t\\ \t\t\t\t NULL, NULL,&name##_port_data_##port_n,\t\t\t\\&name##_port_config_##port_n, CONFIG_ETH_INIT_PRIORITY,\t\\&adin2111_port_api, ETHERNET_L2,\t\t\t\t\\ \t\t\t\t NET_L2_GET_CTX_TYPE(ETHERNET_L2), NET_ETH_MTU);\n+value|static struct adin2111_port_data name##_port_data_##port_n = {\t\t\t\t\\ \t\t.mac_addr = ADIN2111_PORT_MAC(parent_n, phy_n),\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct adin2111_port_config name##_port_config_##port_n = {\t\t\\ \t\t.adin = DEVICE_DT_INST_GET(parent_n),\t\t\t\t\t\t\\ \t\t.phy = ADIN2111_MDIO_PHY_BY_ADDR(parent_n, phy_n),\t\t\t\t\\ \t\t.port_idx = port_n,\t\t\t\t\t\t\t\t\\ \t\t.phy_addr = phy_n,\t\t\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \tETH_NET_DEVICE_INIT_INSTANCE(name##_port_##port_n, \"port_\" ADIN2111_XSTR(port_n),\t\\ \t\t\t\t     port_n, NULL, NULL,&name##_port_data_##port_n,\t\t\\&name##_port_config_##port_n, CONFIG_ETH_INIT_PRIORITY,\t\\&adin2111_port_api, NET_ETH_MTU);\nThe issue was with: drivers: ethernet: adin2111: Use ethernet init macro\n\nUse the ethernet specific init macro."
},{
  "instruction": "There is an issue in the following code. It relates to pm: Fix a corner case when policy returns NULL\n\nWhen the policy returns NULL pm_system_suspend was assuming that\nthe current state in z_cpus_pm_state was ACTIVE, since that is the\nstate set after the core wakes and return to this function. The\nproblem is that in cases where the cpu does not preserve the context,\nand returns to this function, z_cpus_pm_state has the value of the\nlast state used and the cpu use it again.\n\nFix it setting z_cpus_pm_state to ACTIVE every time the policy returns\nNULL. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|=\noperator|*\nname|info\nexpr_stmt|;\nblock|}\nblock|}\nname|k_spin_unlock\nargument_list|(\noperator|&\nname|pm_forced_state_lock",
  "result": "I corrected the issue in the code by changing the following tokens:\n+else|else\n+block|{\n+name|z_cpus_pm_state\n+index|[\n+name|id\n+index|]\n+operator|.\n+name|state\n+operator|=\n+name|PM_STATE_ACTIVE\n+expr_stmt|;\n+block|}\nThe issue was with: pm: Fix a corner case when policy returns NULL\n\nWhen the policy returns NULL pm_system_suspend was assuming that\nthe current state in z_cpus_pm_state was ACTIVE, since that is the\nstate set after the core wakes and return to this function. The\nproblem is that in cases where the cpu does not preserve the context,\nand returns to this function, z_cpus_pm_state has the value of the\nlast state used and the cpu use it again.\n\nFix it setting z_cpus_pm_state to ACTIVE every time the policy returns\nNULL."
},{
  "instruction": "There is an issue in the following code. It relates to hostap: Fix channel comparison\n\nDue to a typo, channel and frequency were compared causing the\nconnection to fail for any combination. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|channels\nindex|[\nname|i\nindex|]\noperator|.\nname|freq\noperator|==\nname|channel\ncondition|)\nblock|{\nreturn|return",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|freq\n+name|chan\nThe issue was with: hostap: Fix channel comparison\n\nDue to a typo, channel and frequency were compared causing the\nconnection to fail for any combination."
},{
  "instruction": "There is an issue in the following code. It relates to hostap: Add interactive keyword for commands\n\nThe keyword is added into array argv of wpa_cli.\nThe commands which require to be interactive\nthis keyword will allow ro print output for them. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}\ncomment|/* Remove wpa_cli from the argument list */\nreturn|return\nname|z_wpa_ctrl_zephyr_cmd\nargument_list|(\nname|argc",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|argv\n+index|[\n+name|argc\n+index|]\n+operator|=\n+literal|\"interactive\"\n+expr_stmt|;\n+name|argc\n+operator|++\n+expr_stmt|;\nThe issue was with: hostap: Add interactive keyword for commands\n\nThe keyword is added into array argv of wpa_cli.\nThe commands which require to be interactive\nthis keyword will allow ro print output for them."
},{
  "instruction": "There is an issue in the following code. It relates to hostap: Convert the unsupported event to warning\n\nThis is a implementation gap and shouldn't be exposed to customers.\nBut when we run with debug it still helps to identify any important\nevents that are not handled. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|supplicant_event_map\nargument_list|)\ncondition|)\nblock|{\nname|wpa_printf\nargument_list|(\nname|MSG_ERROR\nargument_list|,\nliteral|\"Event not supported: %s\\n\"\nargument_list|,\nname|supplicant_status\nargument_list|)\nexpr_stmt|;\nreturn|return",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* This is not a bug but rather implementation gap (intentional or not) */\n-name|MSG_ERROR\n+name|MSG_DEBUG\n-literal|\"Event not supported: %s\\n\"\n+literal|\"Event not supported: %s\"\nThe issue was with: hostap: Convert the unsupported event to warning\n\nThis is a implementation gap and shouldn't be exposed to customers.\nBut when we run with debug it still helps to identify any important\nevents that are not handled."
},{
  "instruction": "There is an issue in the following code. It relates to hostap: Use the new enum for timeout\n\nFor connection timeout use the newly added enumeration. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|WLAN_REASON_4WAY_HANDSHAKE_TIMEOUT\ncase|:\nreturn|return\nname|WIFI_STATUS_CONN_WRONG_PASSWORD\nreturn|;\ndefault|default:\nreturn|return\nname|WIFI_STATUS_CONN_FAIL\nreturn|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Handle non-supplicant errors */\n+case|case\n+operator|-\n+name|ETIMEDOUT\n+case|:\n+return|return\n+name|WIFI_STATUS_CONN_TIMEOUT\n+return|;\nThe issue was with: hostap: Use the new enum for timeout\n\nFor connection timeout use the newly added enumeration."
},{
  "instruction": "There is an issue in the following code. It relates to hostap: Fix supported channels for unknown band\n\nBy default Wi-Fi works on all bands, so, the band will be unknown, in\nwhich case no need to configure a specific frequency list to WPA\nsupplicant.\n\nOnly when a use provides a specific band then this is needed. Please fix this issue.",
  "input": "Faulty tokenized code:\ncondition|(\noperator|!\nname|mode\ncondition|)\nblock|{\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}\nif|if\ncondition|(\nname|params\noperator|->\nname|band\ncondition|)\nblock|{\nname|ret\noperator|=\nname|wpa_supp_supported_channels",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|wpa_printf\n+argument_list|(\n+name|MSG_ERROR\n+argument_list|,\n+literal|\"Unsupported or invalid band: %d\"\n+argument_list|,\n+name|band\n+argument_list|)\n+expr_stmt|;\n+operator|!=\n+name|WIFI_FREQ_BAND_UNKNOWN\nThe issue was with: hostap: Fix supported channels for unknown band\n\nBy default Wi-Fi works on all bands, so, the band will be unknown, in\nwhich case no need to configure a specific frequency list to WPA\nsupplicant.\n\nOnly when a use provides a specific band then this is needed."
},{
  "instruction": "There is an issue in the following code. It relates to hostap: Fix memory leak\n\nThe control interface is initialized on every interface add but only\nde-initialized on WPA supplicant termination. This leaks all cleanups in\nthe control interface dei-init. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\ngoto|goto\nname|out\ngoto|;\nblock|}\nname|ret\noperator|=\nname|zephyr_wpa_cli_global_cmd_v\nargument_list|(\nliteral|\"interface_remove %s\"\nindex|[\nliteral|0\nindex|]\nargument_list|)\nexpr_stmt|;\nname|zephyr_wpa_ctrl_deinit\nargument_list|(\nname|ctx\noperator|->\nname|supplicant\nargument_list|)\nexpr_stmt|;\nname|zephyr_global_wpa_ctrl_deinit\nargument_list|()\nexpr_stmt|;\nname|fst_global_deinit\nargument_list|()",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|zephyr_wpa_ctrl_deinit\n+argument_list|(\n+name|wpa_s\n+argument_list|)\n+expr_stmt|;\n-name|zephyr_wpa_ctrl_deinit\n-argument_list|(\n-name|ctx\n-operator|->\n-name|supplicant\n-argument_list|)\n-expr_stmt|;\nThe issue was with: hostap: Fix memory leak\n\nThe control interface is initialized on every interface add but only\nde-initialized on WPA supplicant termination. This leaks all cleanups in\nthe control interface dei-init."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: watchdog: wdt_nrfx.c: Fix error code value\n\nAlign driver implementation to the watchdog driver API.\nhttps://docs.zephyrproject.org/latest/hardware/peripherals/watchdog.html\n\nint wdt_disable(const struct device *dev)\nshall return:\n    0 – If successful.\n    -EFAULT – If watchdog instance is not enabled.\n    -EPERM – If watchdog can not be disabled directly by application code.\n    -errno – In case of any other failure. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|err_code\noperator|!=\nname|NRFX_SUCCESS\ncondition|)\nblock|{\nreturn|return\noperator|-\nname|ENOTSUP\nreturn|;\nblock|}\nreturn|return\nliteral|0\nreturn|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* This can only happen if wdt_nrf_setup() is not called first. */\n-name|ENOTSUP\n+name|EFAULT\nThe issue was with: drivers: watchdog: wdt_nrfx.c: Fix error code value\n\nAlign driver implementation to the watchdog driver API.\nhttps://docs.zephyrproject.org/latest/hardware/peripherals/watchdog.html\n\nint wdt_disable(const struct device *dev)\nshall return:\n    0 – If successful.\n    -EFAULT – If watchdog instance is not enabled.\n    -EPERM – If watchdog can not be disabled directly by application code.\n    -errno – In case of any other failure."
},{
  "instruction": "There is an issue in the following code. It relates to net: trickle: Rename interval function\n\nThe function inteval_timeout() was missing \\\"r\\\", the function\nshould be called interval_timeout() Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|inteval_timeout (struct net_trickle * trickle)\nspecifier|static\nname|void\nname|inteval_timeout\nparameter_list|(\nname|struct\nname|net_trickle\nmodifier|*\nname|trickle\nargument_list|)\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\nname|inteval_timeout\nargument_list|(\nname|trickle\nargument_list|)\nexpr_stmt|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|inteval_timeout (struct net_trickle * trickle)\n+DECL|function|interval_timeout (struct net_trickle * trickle)\n-name|inteval_timeout\n+name|interval_timeout\n-name|inteval_timeout\n+name|interval_timeout\nThe issue was with: net: trickle: Rename interval function\n\nThe function inteval_timeout() was missing \\\"r\\\", the function\nshould be called interval_timeout()"
},{
  "instruction": "There is an issue in the following code. It relates to arm: cortex_m: tracing for custom thread abort func\n\nARM/Cortex-M has a custom implementation for thread abort\n(z_impl_k_thread_abort) which lacks the tracing function\ncalls as in the generic version. So add them. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|(\nname|k_tid_t\nname|thread\nparameter_list|)\nblock|{\nif|if\ncondition|(\nname|_current\noperator|==\nname|thread\nname|z_thread_abort\nargument_list|(\nname|thread\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nend_unit\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|SYS_PORT_TRACING_OBJ_FUNC_ENTER\n+argument_list|(\n+name|k_thread\n+argument_list|,\n+name|abort\n+argument_list|,\n+name|thread\n+argument_list|)\n+expr_stmt|;\n+name|SYS_PORT_TRACING_OBJ_FUNC_EXIT\n+argument_list|(\n+name|k_thread\n+argument_list|,\n+name|abort\n+argument_list|,\n+name|thread\n+argument_list|)\n+expr_stmt|;\nThe issue was with: arm: cortex_m: tracing for custom thread abort func\n\nARM/Cortex-M has a custom implementation for thread abort\n(z_impl_k_thread_abort) which lacks the tracing function\ncalls as in the generic version. So add them."
},{
  "instruction": "There is an issue in the following code. It relates to tests/bsim/bt l2cap/stress: Be more silent\n\nThis test was way too verbose (produced a log over 65000 lines\nlong).\nLet's mute it a bit. If the test fails, developers\ncan raise the log level as needed. Please fix this issue.",
  "input": "Faulty tokenized code:\n\nCONFIG_LOG=y\nCONFIG_ASSERT=y\nCONFIG_NET_BUF_POOL_USAGE=y\n\nCONFIG_BT_L2CAP_LOG_LEVEL_DBG=y\n# CONFIG_BT_CONN_LOG_LEVEL_DBG=y\nCONFIG_LOG_THREAD_ID_PREFIX=y\nCONFIG_THREAD_NAME=y\n\nCONFIG_ARCH_POSIX_TRAP_ON_FATAL=y\nbegin_expr_stmt\nname|LOG_MODULE_REGISTER\nargument_list|(\nname|LOG_MODULE_NAME\nargument_list|,\nname|LOG_LEVEL_DBG\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_expr_stmt",
  "result": "I corrected the issue in the code by changing the following tokens:\n-CONFIG_BT_L2CAP_LOG_LEVEL_DBG=y\n+# CONFIG_BT_L2CAP_LOG_LEVEL_DBG=y\n-name|LOG_LEVEL_DBG\n+name|LOG_LEVEL_INF\nThe issue was with: tests/bsim/bt l2cap/stress: Be more silent\n\nThis test was way too verbose (produced a log over 65000 lines\nlong).\nLet's mute it a bit. If the test fails, developers\ncan raise the log level as needed."
},{
  "instruction": "There is an issue in the following code. It relates to ADSP: don't use timer interrupts on secondary cores\n\nWhen running SOF on Intel ADSP we choose to only serve the timer\ninterrupt on the primary core. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|smp_timer_init\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nname|irq_init\nargument_list|()\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_comment\ncomment|/* Runs on core 0 only */",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|irq_init\n-argument_list|()\n-expr_stmt|;\nThe issue was with: ADSP: don't use timer interrupts on secondary cores\n\nWhen running SOF on Intel ADSP we choose to only serve the timer\ninterrupt on the primary core."
},{
  "instruction": "There is an issue in the following code. It relates to input: rename the internal callback struct to input_callback\n\nRename the internal input callback structure to input_callback. This is\nfor coherency with \\\"INPUT_CALLBACK_DEFINE\\\" and other similar code paths\nin Zephyr, and also to avoid confusion with terminology.\n\nThis is an internal structure, applications should not have any\nreferences to it so there should be no need for any release note\nentries. Please fix this issue.",
  "input": "Faulty tokenized code:\nif (CONFIG_HTTP_SERVER)\n  zephyr_iterable_section(NAME http_service_desc KVMA RAM_REGION GROUP RODATA_REGION SUBALIGN 4)\nendif()\n\nif(CONFIG_INPUT)\n zephyr_iterable_section(NAME input_listener KVMA RAM_REGION GROUP RODATA_REGION SUBALIGN 4)\nendif()\n\nif(CONFIG_USBD_MSC_CLASS)\n  zephyr_iterable_section(NAME usbd_msc_lun KVMA RAM_REGION GROUP RODATA_REGION SUBALIGN 4)\nendif()\nname|int32_t\nname|value\ndecl_stmt|;\nblock|}\nstruct|;\ncomment|/**  * @brief Report a new input event.  *  * This causes all the listeners for the specified device to be triggered,  * either synchronously or through the input thread if utilized.  *  * @param dev Device generating the event or NULL.  * @param type Event type (see @ref INPUT_EV_CODES).  * @param code Event code (see @ref INPUT_KEY_CODES, @ref INPUT_BTN_CODES,  *        @ref INPUT_ABS_CODES, @ref INPUT_REL_CODES, @ref INPUT_MSC_CODES).  * @param value Event value.  * @param sync Set the synchronization bit for the event.  * @param timeout Timeout for reporting the event, ignored if  *                @kconfig{CONFIG_INPUT_MODE_SYNCHRONOUS} is used.  * @retval 0 if the message has been processed.  * @retval negative if @kconfig{CONFIG_INPUT_MODE_THREAD} is enabled and the  *         message failed to be enqueued.  */\nname|int\nname|input_report\nparameter_list|(\nspecifier|const\nname|struct\nname|input_queue_empty\nparameter_list|(\nname|void\nparameter_list|)\nfunction_decl|;\ncomment|/**  * @brief Input listener callback structure.  */\nDECL|struct|input_listener\nstruct|struct\nname|input_listener\nblock|{\ncomment|/** @ref device pointer or NULL. */\nDECL|member|dev\nspecifier|const\nname|struct\nname|_dev\nparameter_list|,\nname|_callback\nparameter_list|)\ndefine|\\\nvalue|static const STRUCT_SECTION_ITERABLE(input_listener,                   \\ \t\t\t\t\t     _input_listener__##_callback) = { \\ \t\t.dev = _dev,                                                   \\ \t\t.callback = _callback,                                         \\ \t}\nifdef|#\ndirective|ifdef\nname|__cplusplus\nblock|}\nend_extern\n#if defined(CONFIG_MCUMGR)\n\tITERABLE_SECTION_ROM(mcumgr_handler, 4)\n#endif\n\n#if defined(CONFIG_INPUT)\n\tITERABLE_SECTION_ROM(input_listener, 4)\n#endif\n\n#if defined(CONFIG_EMUL)\n\tITERABLE_SECTION_ROM(emul, 4)\n#endif /* CONFIG_EMUL */\nname|evt\nparameter_list|)\nblock|{\nname|STRUCT_SECTION_FOREACH\nargument_list|(\nargument|input_listener\nargument_list|,\nargument|listener\nargument_list|)\nblock|{\nif|if\ncondition|(\nname|listener\noperator|->\nname|dev\noperator|==\nname|NULL\noperator|||\nname|listener\noperator|->\nname|dev\noperator|==\nname|evt\noperator|->\nname|dev\ncondition|)\nblock|{\nname|listener\noperator|->\nname|callback\nargument_list|(\nname|evt\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-  zephyr_iterable_section(NAME input_listener KVMA RAM_REGION GROUP RODATA_REGION SUBALIGN 4)\n+  zephyr_iterable_section(NAME input_callback KVMA RAM_REGION GROUP RODATA_REGION SUBALIGN 4)\n-comment|/**  * @brief Report a new input event.  *  * This causes all the listeners for the specified device to be triggered,  * either synchronously or through the input thread if utilized.  *  * @param dev Device generating the event or NULL.  * @param type Event type (see @ref INPUT_EV_CODES).  * @param code Event code (see @ref INPUT_KEY_CODES, @ref INPUT_BTN_CODES,  *        @ref INPUT_ABS_CODES, @ref INPUT_REL_CODES, @ref INPUT_MSC_CODES).  * @param value Event value.  * @param sync Set the synchronization bit for the event.  * @param timeout Timeout for reporting the event, ignored if  *                @kconfig{CONFIG_INPUT_MODE_SYNCHRONOUS} is used.  * @retval 0 if the message has been processed.  * @retval negative if @kconfig{CONFIG_INPUT_MODE_THREAD} is enabled and the  *         message failed to be enqueued.  */\n+comment|/**  * @brief Report a new input event.  *  * This causes all the callbacks for the specified device to be executed,  * either synchronously or through the input thread if utilized.  *  * @param dev Device generating the event or NULL.  * @param type Event type (see @ref INPUT_EV_CODES).  * @param code Event code (see @ref INPUT_KEY_CODES, @ref INPUT_BTN_CODES,  *        @ref INPUT_ABS_CODES, @ref INPUT_REL_CODES, @ref INPUT_MSC_CODES).  * @param value Event value.  * @param sync Set the synchronization bit for the event.  * @param timeout Timeout for reporting the event, ignored if  *                @kconfig{CONFIG_INPUT_MODE_SYNCHRONOUS} is used.  * @retval 0 if the message has been processed.  * @retval negative if @kconfig{CONFIG_INPUT_MODE_THREAD} is enabled and the  *         message failed to be enqueued.  */\n-comment|/**  * @brief Input listener callback structure.  */\n-DECL|struct|input_listener\n+comment|/**  * @brief Input callback structure.  */\n+DECL|struct|input_callback\n-name|input_listener\n+name|input_callback\n-value|static const STRUCT_SECTION_ITERABLE(input_listener,                   \\ \t\t\t\t\t     _input_listener__##_callback) = { \\ \t\t.dev = _dev,                                                   \\ \t\t.callback = _callback,                                         \\ \t}\n+value|static const STRUCT_SECTION_ITERABLE(input_callback,                   \\ \t\t\t\t\t     _input_callback__##_callback) = { \\ \t\t.dev = _dev,                                                   \\ \t\t.callback = _callback,                                         \\ \t}\n-\tITERABLE_SECTION_ROM(input_listener, 4)\n+\tITERABLE_SECTION_ROM(input_callback, 4)\n-argument|input_listener\n+argument|input_callback\n-argument|listener\n+argument|callback\n-name|listener\n+name|callback\n-name|listener\n+name|callback\n-name|listener\n+name|callback\nThe issue was with: input: rename the internal callback struct to input_callback\n\nRename the internal input callback structure to input_callback. This is\nfor coherency with \\\"INPUT_CALLBACK_DEFINE\\\" and other similar code paths\nin Zephyr, and also to avoid confusion with terminology.\n\nThis is an internal structure, applications should not have any\nreferences to it so there should be no need for any release note\nentries."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: can: loopback: remove info log at driver initialization\n\nRemove the LOG_INF() at driver initialization. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|return\noperator|-\nliteral|1\nreturn|;\nblock|}\nname|LOG_INF\nargument_list|(\nliteral|\"Init of %s done\"\nargument_list|,\nname|dev\noperator|->\nname|name\nargument_list|)\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|LOG_INF\n-argument_list|(\n-literal|\"Init of %s done\"\n-argument_list|,\n-name|dev\n-operator|->\n-name|name\n-argument_list|)\n-expr_stmt|;\nThe issue was with: drivers: can: loopback: remove info log at driver initialization\n\nRemove the LOG_INF() at driver initialization."
},{
  "instruction": "There is an issue in the following code. It relates to tests: llext: fix conflict between BUILD_ONLY and \\\"object\\\" case\n\nFix conflict between commit a771d01ff1d5 [formerly ce243944375e] (\\\"llext: add object test case\\\")\nand commit 4d7eeddf23f2 [formerly 1408d1e5b8ce] (\\\"tests: llext: compile architectures not\nsupported yet\\\") which were tested separately but merged at the same\ntime.\n\nGithub \\\"Merge Queues\\\" can avoid this (and save resources) but:\n- they're not used by Zephyr CI\n- they provide confusing feedback Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nargument|true\nargument_list|)\nend_macro\n\nbegin_endif\nendif|#\ndirective|endif\nend_endif\n\nbegin_comment\ncomment|/* ! LOADER_BUILD_ONLY */\nend_comment\n\nbegin_decl_stmt\nspecifier|static\nname|LLEXT_CONST\nname|uint8_t\nname|object_ext\nargument_list|,\nargument|true\nargument_list|)\nend_macro\n\nbegin_comment\ncomment|/*  * Ensure that EXPORT_SYMBOL does indeed provide a symbol and a valid address  * to it.  */\nend_comment\n\nbegin_macro",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_endif\n-endif|#\n-directive|endif\n-end_endif\n-\n-begin_comment\n-comment|/* ! LOADER_BUILD_ONLY */\n-end_comment\n-\n+begin_endif\n+endif|#\n+directive|endif\n+end_endif\n+\n+begin_comment\n+comment|/* ! LOADER_BUILD_ONLY */\n+end_comment\n+\nThe issue was with: tests: llext: fix conflict between BUILD_ONLY and \\\"object\\\" case\n\nFix conflict between commit a771d01ff1d5 [formerly ce243944375e] (\\\"llext: add object test case\\\")\nand commit 4d7eeddf23f2 [formerly 1408d1e5b8ce] (\\\"tests: llext: compile architectures not\nsupported yet\\\") which were tested separately but merged at the same\ntime.\n\nGithub \\\"Merge Queues\\\" can avoid this (and save resources) but:\n- they're not used by Zephyr CI\n- they provide confusing feedback"
},{
  "instruction": "There is an issue in the following code. It relates to net: ipv4: Allow IGMP packets with zero src address\n\nIGMP queries sent out by a proxy querier can have\na source IP address 0.0.0.0\nAllow these incoming packets.\n\nFixes #69917 Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|)\nname|hdr\noperator|->\nname|dst\nargument_list|)\ncondition|)\nblock|{\nname|NET_DBG\nargument_list|(\nliteral|\"DROP: src addr is %s\"",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|&&\n+operator|(\n+name|hdr\n+operator|->\n+name|proto\n+operator|!=\n+name|IPPROTO_IGMP\n+operator|)\nThe issue was with: net: ipv4: Allow IGMP packets with zero src address\n\nIGMP queries sent out by a proxy querier can have\na source IP address 0.0.0.0\nAllow these incoming packets.\n\nFixes #69917"
},{
  "instruction": "There is an issue in the following code. It relates to mgmt: hawkbit: Fix condition in hawkbit_probe\n\nFix send_request condition in hawkbit_probe function Please fix this issue.",
  "input": "Faulty tokenized code:\nname|hb_context\nstruct|;\nend_struct\n\nbegin_union\nDECL|union|__anon2c5fae14010a\nspecifier|static\nunion|union\nblock|{\nDECL|member|dep\nname|struct\nname|flash_ctx\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|send_request\nargument_list|(\nname|HTTP_GET\nargument_list|,\nname|HAWKBIT_DOWNLOAD",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon2c5fae14010a\n+DECL|union|__anon2b0dadd3010a\n+operator|!\nThe issue was with: mgmt: hawkbit: Fix condition in hawkbit_probe\n\nFix send_request condition in hawkbit_probe function"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Mesh: Warn if can't listen to unprov beacons until proved\n\nWhen calling `mesh prov beacon-listen on` shell command before\nprovisioning the local device, the stack won't report unprovisioned\nbeacons. This is because the scanner has not been started yet. This\nbehavior confuses users. Print a warning that the device needs to be\nprovisioned first before it can listen to unprovisioned beacons. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|err\nreturn|;\nblock|}\nif|if\ncondition|(\nname|val\ncondition|)\nblock|{\nname|bt_mesh_shell_prov\noperator|.",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|!\n+name|bt_mesh_is_provisioned\n+argument_list|()\n+condition|)\n+block|{\n+name|shell_error\n+argument_list|(\n+name|sh\n+argument_list|,\n+literal|\"Not yet provisioned\"\n+argument_list|)\n+expr_stmt|;\n+return|return\n+operator|-\n+name|EINVAL\n+return|;\n+block|}\n+if|if\n+condition|(\nThe issue was with: Bluetooth: Mesh: Warn if can't listen to unprov beacons until proved\n\nWhen calling `mesh prov beacon-listen on` shell command before\nprovisioning the local device, the stack won't report unprovisioned\nbeacons. This is because the scanner has not been started yet. This\nbehavior confuses users. Print a warning that the device needs to be\nprovisioned first before it can listen to unprovisioned beacons."
},{
  "instruction": "There is an issue in the following code. It relates to net: iface: Allow catch-all multicast monitor\n\nRegistering a multicast monitor with a NULL interface will receive all\nevents. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|net_if_mcast_callback_t\nname|cb\ndecl_stmt|;\nblock|}\nstruct|;\ncomment|/**  * @brief Register a multicast monitor  *  * @param mon Monitor handle. This is a pointer to a monitor storage structure  * which should be allocated by caller, but does not need to be initialized.  * @param iface Network interface  * @param cb Monitor callback  */\nname|void\nname|net_if_mcast_mon_register\nparameter_list|(\nname|struct\nname|net_if_mcast_monitor\nendif|#\ndirective|endif\nend_endif\n\nbegin_struct\nDECL|struct|__anon2b0bc7770108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|ipv6\nname|struct\nname|CONFIG_NET_NATIVE_IPV4\nargument_list|)\nend_if\n\nbegin_struct\nDECL|struct|__anon2b0bc7770208\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|ipv4\nname|struct\nname|iface\noperator|==\nname|mon\noperator|->\nname|iface\ncondition|)\nblock|{\nname|mon\noperator|->\nname|cb",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/**  * @brief Register a multicast monitor  *  * @param mon Monitor handle. This is a pointer to a monitor storage structure  * which should be allocated by caller, but does not need to be initialized.  * @param iface Network interface  * @param cb Monitor callback  */\n+comment|/**  * @brief Register a multicast monitor  *  * @param mon Monitor handle. This is a pointer to a monitor storage structure  * which should be allocated by caller, but does not need to be initialized.  * @param iface Network interface or NULL for all interfaces  * @param cb Monitor callback  */\n-DECL|struct|__anon2b0bc7770108\n+DECL|struct|__anon2af08c070108\n-DECL|struct|__anon2b0bc7770208\n+DECL|struct|__anon2af08c070208\n+operator|||\n+name|mon\n+operator|->\n+name|iface\n+operator|==\n+name|NULL\nThe issue was with: net: iface: Allow catch-all multicast monitor\n\nRegistering a multicast monitor with a NULL interface will receive all\nevents."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: misc: nordic_vpr_launcher: Update src/exec memory size check\n\nFirstly, build-asserting the execution/source memory sizes to be equal\nwasn't working, due to the wrong (non-inst) DT API being used.\n\nSecondly, this assert can be relaxed so that the source memory region\nonly needs to have greater than or equal size to the execution region,\nas VPR firmware needs to fit into execution memory first and foremost.\nThis will come in handy, since MRAM partitions (typical source memory)\nhave stricter alignment requirements than RAM regions. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nDECL|member|src_addr\nname|uintptr_t\nname|src_addr\ndecl_stmt|;\nDECL|member|src_size\nname|size_t\nname|src_size\ndecl_stmt|;\nendif|#\ndirective|endif\nblock|}\nstruct|;\nargument_list|)\nif|if\ncondition|(\nname|config\noperator|->\nname|src_size\noperator|>\nliteral|0U\ncondition|)\nblock|{\nname|LOG_DBG\noperator|->\nname|exec_addr\nargument_list|,\nname|config\noperator|->\nname|src_size\nargument_list|)\nexpr_stmt|;\nname|memcpy\nargument_list|(\noperator|(\noperator|->\nname|src_addr\nargument_list|,\nname|config\noperator|->\nname|src_size\nargument_list|)\nexpr_stmt|;\nblock|}\nendif|#\ndirective|endif\nname|NORDIC_VPR_LAUNCHER_DEFINE\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|COND_CODE_1(DT_NODE_HAS_PROP(inst, source_memory),                                         \\ \t\t    (BUILD_ASSERT((DT_REG_SIZE(DT_INST_PHANDLE(inst, execution_memory)) ==         \\ \t\t\t\t   DT_REG_SIZE(DT_INST_PHANDLE(inst, source_memory))),             \\ \t\t\t\t  \"Source/execution memory sizes mismatch\");),                     \\ \t\t    ())                                                                            \\                                                                                                    \\ \tstatic const struct nordic_vpr_launcher_config config##inst = {                            \\ \t\t.vpr = (NRF_VPR_Type *)DT_INST_REG_ADDR(inst),                                     \\ \t\t.exec_addr = VPR_ADDR(DT_INST_PHANDLE(inst, execution_memory)),                    \\ \t\tCOND_CODE_1(DT_INST_NODE_HAS_PROP(inst, source_memory),                            \\ \t\t\t    (.src_addr = VPR_ADDR(DT_INST_PHANDLE(inst, source_memory)),           \\ \t\t\t     .src_size = DT_REG_SIZE(DT_INST_PHANDLE(inst, source_memory)),),      \\ \t\t\t    ())};                                                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, nordic_vpr_launcher_init, NULL, NULL,&config##inst,           \\ \t\t\t      POST_KERNEL, CONFIG_NORDIC_VPR_LAUNCHER_INIT_PRIORITY, NULL);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|member|src_size\n+DECL|member|size\n-name|src_size\n+name|size\n-name|src_size\n+name|size\n-name|src_size\n+name|size\n-name|src_size\n+name|size\n-value|COND_CODE_1(DT_NODE_HAS_PROP(inst, source_memory),                                         \\ \t\t    (BUILD_ASSERT((DT_REG_SIZE(DT_INST_PHANDLE(inst, execution_memory)) ==         \\ \t\t\t\t   DT_REG_SIZE(DT_INST_PHANDLE(inst, source_memory))),             \\ \t\t\t\t  \"Source/execution memory sizes mismatch\");),                     \\ \t\t    ())                                                                            \\                                                                                                    \\ \tstatic const struct nordic_vpr_launcher_config config##inst = {                            \\ \t\t.vpr = (NRF_VPR_Type *)DT_INST_REG_ADDR(inst),                                     \\ \t\t.exec_addr = VPR_ADDR(DT_INST_PHANDLE(inst, execution_memory)),                    \\ \t\tCOND_CODE_1(DT_INST_NODE_HAS_PROP(inst, source_memory),                            \\ \t\t\t    (.src_addr = VPR_ADDR(DT_INST_PHANDLE(inst, source_memory)),           \\ \t\t\t     .src_size = DT_REG_SIZE(DT_INST_PHANDLE(inst, source_memory)),),      \\ \t\t\t    ())};                                                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, nordic_vpr_launcher_init, NULL, NULL,&config##inst,           \\ \t\t\t      POST_KERNEL, CONFIG_NORDIC_VPR_LAUNCHER_INIT_PRIORITY, NULL);\n+value|IF_ENABLED(DT_INST_NODE_HAS_PROP(inst, source_memory),                                     \\ \t\t   (BUILD_ASSERT((DT_REG_SIZE(DT_INST_PHANDLE(inst, execution_memory))<=          \\ \t\t\t\t  DT_REG_SIZE(DT_INST_PHANDLE(inst, source_memory))),              \\ \t\t\t\t \"Execution memory exceeds source memory size\");))                 \\                                                                                                    \\ \tstatic const struct nordic_vpr_launcher_config config##inst = {                            \\ \t\t.vpr = (NRF_VPR_Type *)DT_INST_REG_ADDR(inst),                                     \\ \t\t.exec_addr = VPR_ADDR(DT_INST_PHANDLE(inst, execution_memory)),                    \\ \t\tIF_ENABLED(DT_INST_NODE_HAS_PROP(inst, source_memory),                             \\ \t\t\t   (.src_addr = VPR_ADDR(DT_INST_PHANDLE(inst, source_memory)),            \\ \t\t\t    .size = DT_REG_SIZE(DT_INST_PHANDLE(inst, execution_memory)),))};      \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, nordic_vpr_launcher_init, NULL, NULL,&config##inst,           \\ \t\t\t      POST_KERNEL, CONFIG_NORDIC_VPR_LAUNCHER_INIT_PRIORITY, NULL);\nThe issue was with: drivers: misc: nordic_vpr_launcher: Update src/exec memory size check\n\nFirstly, build-asserting the execution/source memory sizes to be equal\nwasn't working, due to the wrong (non-inst) DT API being used.\n\nSecondly, this assert can be relaxed so that the source memory region\nonly needs to have greater than or equal size to the execution region,\nas VPR firmware needs to fit into execution memory first and foremost.\nThis will come in handy, since MRAM partitions (typical source memory)\nhave stricter alignment requirements than RAM regions."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: counter: counter_nxp_mrt: include soc.h for MRT CMSIS defines\n\nInclude soc.h in nxp MRT driver, so that CMSIS register definitions will\nbe available in this file Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/irq.h>\nend_include\n\nbegin_define\nDECL|macro|LOG_MODULE_NAME\ndefine|#\ndirective|define\nname|LOG_MODULE_NAME",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<soc.h>\n+end_include\n+\nThe issue was with: drivers: counter: counter_nxp_mrt: include soc.h for MRT CMSIS defines\n\nInclude soc.h in nxp MRT driver, so that CMSIS register definitions will\nbe available in this file"
},{
  "instruction": "There is an issue in the following code. It relates to tests: sprintf: Avoid buffer overrun\n\nfwrite parameters are \\\"size_t size\\\" and \\\"size_t nmemb\\\",\nwhen writing a string we should set sizeof(char) and len(string).\nThe test is doing it wrongly and making the function read more\nmemory than it should. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nDECL|member|d\nname|double\nname|d\ndecl_stmt|;\nDECL|struct|__anon28d89d5c0108\nstruct|struct\nblock|{\nDECL|member|fraction\nname|uint32_t\nname|fraction\nblock|{\nDECL|member|d\nname|double\nname|d\ndecl_stmt|;\nDECL|struct|__anon28d89d5c0208\nstruct|struct\nblock|{\nDECL|member|exponent\nname|uint32_t\nname|exponent\noperator|=\nname|fwrite\nargument_list|(\nliteral|\"This 3\"\nargument_list|,\nliteral|4\nargument_list|,\nliteral|4\nargument_list|,\nname|stdout\nargument_list|)\noperator|=\nname|fwrite\nargument_list|(\nliteral|\"This 3\"\nargument_list|,\nliteral|4\nargument_list|,\nliteral|4\nargument_list|,\nname|stdin\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon28d89d5c0108\n+DECL|struct|__anon28daf9b50108\n-DECL|struct|__anon28d89d5c0208\n+DECL|struct|__anon28daf9b50208\n-literal|4\n+literal|1\n-literal|4\n+literal|1\nThe issue was with: tests: sprintf: Avoid buffer overrun\n\nfwrite parameters are \\\"size_t size\\\" and \\\"size_t nmemb\\\",\nwhen writing a string we should set sizeof(char) and len(string).\nThe test is doing it wrongly and making the function read more\nmemory than it should."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: qdec_stm32: fix inverted polarity\n\nUse the Polarity member instead of the ActivityInput. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|is_input_polarity_inverted\ncondition|)\nblock|{\nname|init_props\noperator|.\nname|IC1ActiveInput\noperator|=\nname|LL_TIM_IC_POLARITY_FALLING\nexpr_stmt|;\nname|init_props\noperator|.\nname|IC2ActiveInput\noperator|=\nname|LL_TIM_IC_POLARITY_FALLING\nexpr_stmt|;\nblock|}\nname|init_props",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|IC1ActiveInput\n+name|IC1Polarity\n-name|IC2ActiveInput\n+name|IC2Polarity\nThe issue was with: drivers: sensor: qdec_stm32: fix inverted polarity\n\nUse the Polarity member instead of the ActivityInput."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: TMAP: Shell: Improve logging of role\n\nThe role is a 16-bit value, and is best logged as %04X. Please fix this issue.",
  "input": "Faulty tokenized code:\ndecl_stmt|;\nname|shell_info\nargument_list|(\nname|sh\nargument_list|,\nliteral|\"Registering TMAS with role: %u\"\nargument_list|,\nname|role\nargument_list|)\nexpr_stmt|;\nname|err\nblock|}\nname|shell_print\nargument_list|(\nname|ctx_shell\nargument_list|,\nliteral|\"tmap discovered for conn %p: role 0x%02x\"\nargument_list|,\nname|conn\nargument_list|,\nname|role\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"Registering TMAS with role: %u\"\n+literal|\"Registering TMAS with role: 0x%04X\"\n-literal|\"tmap discovered for conn %p: role 0x%02x\"\n+literal|\"tmap discovered for conn %p: role 0x%04x\"\nThe issue was with: Bluetooth: TMAP: Shell: Improve logging of role\n\nThe role is a 16-bit value, and is best logged as %04X."
},{
  "instruction": "There is an issue in the following code. It relates to net: igmp: Fix double unref of igmp packet\n\nIf send the igmp packet when lower interface is down, the packet will be\nfreed twice and show error log. Remove the net_pkt_unref in igmp_send(),\nand let the caller free it. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|pkt\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|net_pkt_unref\nargument_list|(\nname|pkt\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|ret\nreturn|;\nblock|}\nname|net_stats_update_ipv4_igmp_sent",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|net_pkt_unref\n-argument_list|(\n-name|pkt\n-argument_list|)\n-expr_stmt|;\nThe issue was with: net: igmp: Fix double unref of igmp packet\n\nIf send the igmp packet when lower interface is down, the packet will be\nfreed twice and show error log. Remove the net_pkt_unref in igmp_send(),\nand let the caller free it."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: watchdog: fix wdt_counter_setup option checking condition\n\nThe expression (options & WDT_OPT_PAUSE_IN_SLEEP) is duplicated. Fix it\nby replacing the second one with (options &WDT_OPT_PAUSE_HALTED_BY_DBG). Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|)\noperator|||\noperator|(\nname|options\noperator|&\nname|WDT_OPT_PAUSE_IN_SLEEP\noperator|)\ncondition|)\nblock|{\nreturn|return\noperator|-",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|WDT_OPT_PAUSE_IN_SLEEP\n+name|WDT_OPT_PAUSE_HALTED_BY_DBG\nThe issue was with: drivers: watchdog: fix wdt_counter_setup option checking condition\n\nThe expression (options & WDT_OPT_PAUSE_IN_SLEEP) is duplicated. Fix it\nby replacing the second one with (options &WDT_OPT_PAUSE_HALTED_BY_DBG)."
},{
  "instruction": "There is an issue in the following code. It relates to logging: backends: multidomain: Fix compilation warning\n\nFix compilation warning due to taking member from a packed structure\nand assigning it to a pointer. Compiler warns that it may be\nunaligned. However, it is ensured that it will be aligned by\noperations preceding this assignment. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|false\nargument_list|)\nexpr_stmt|;\nreturn|return;\nblock|}\ncomment|/* Need to ensure that package is aligned to a pointer size. */\nname|uint32_t\nname|msg_len\ninit|=\nname|Z_LOG_MSG_LEN\nargument_list|(\nargument_list|)\noperator|-\nname|msg_offset\nindex|]\ndecl_stmt|;\nname|struct\nname|log_msg\nmodifier|*\nname|out_log_msg\ninit|=\noperator|(\nexpr|struct\nname|log_msg\noperator|*\noperator|)\nname|out_msg\noperator|->\nname|data\noperator|.\nname|log_msg\noperator|.\nname|data\ndecl_stmt|;\ncomment|/* Set ipc message id. */\nname|out_msg\noperator|->\nname|id\noperator|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* Need to ensure that package is aligned to a pointer size. */\n+comment|/* Need to ensure that package is aligned to a pointer size even though \t * it is in the packed structured. \t */\n-name|struct\n-name|log_msg\n-modifier|*\n-name|out_log_msg\n+name|uintptr_t\n+name|out_log_msg_ptr\n-expr|struct\n-name|log_msg\n-operator|*\n+name|uintptr_t\n+name|struct\n+name|log_msg\n+modifier|*\n+name|out_log_msg\n+init|=\n+operator|(\n+expr|struct\n+name|log_msg\n+operator|*\n+operator|)\n+name|out_log_msg_ptr\n+decl_stmt|;\nThe issue was with: logging: backends: multidomain: Fix compilation warning\n\nFix compilation warning due to taking member from a packed structure\nand assigning it to a pointer. Compiler warns that it may be\nunaligned. However, it is ensured that it will be aligned by\noperations preceding this assignment."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: Fix CIS accept fails with unsupp parameters\n\nFix CIS accepted by Host being failed in the Controller with\nreason 0x20 Unsupported LL Parameter Value, by relaxing the\ncheck that the ACL connection is sufficiently placed such\nthat the time reservation using in the Controller\nimplementation does not overlap with the CIG event. Please fix this issue.",
  "input": "Faulty tokenized code:\n\tdepends on BT_OBSERVER\n\thelp\n\t  Enforce returning HCI Error Command Disallowed on enabling/disabling\n\t  already enabled/disabled scanning.\n\nconfig BT_CTLR_ISOAL_SN_STRICT\n\tbool \"Enforce Strict Tx ISO Data Sequence Number use\"\n\tdepends on !BT_CTLR_ISOAL_PSN_IGNORE && (BT_CTLR_ADV_ISO || \\\n\t\t\t\t\t\t BT_CTLR_CONN_ISO)\n\tdefault y\ncondition|(\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_BT_CTLR_PERIPHERAL_ISO_EARLY_CIG_START\nargument_list|)\ncondition|)\nblock|{\ncomment|/* Early start allows offset down to spec defined minimum */\nname|cis_offset_min\noperator|=\nCONFIG_BT_CTLR_SCAN_INDICATION=y\nCONFIG_BT_CTLR_ADV_RESERVE_MAX=n\nCONFIG_BT_CTLR_ADV_ISO_RESERVE_MAX=n\nCONFIG_BT_CTLR_SYNC_ISO_RESERVE_MAX=n\nCONFIG_BT_CTLR_CENTRAL_RESERVE_MAX=n\nCONFIG_BT_CTLR_EVENT_OVERHEAD_RESERVE_MAX=n\nCONFIG_BT_CTLR_PROFILE_ISR=y\nCONFIG_BT_CTLR_DEBUG_PINS=y\nCONFIG_BT_CTLR_TEST=y\nCONFIG_BT_HCI_VS_EXT=y\nCONFIG_BT_CTLR_ADV_AUX_PDU_BACK2BACK=y\nCONFIG_BT_CTLR_LLL_PRIO=0\nCONFIG_BT_CTLR_ULL_HIGH_PRIO=1\nCONFIG_BT_CTLR_XTAL_ADVANCED=n\nCONFIG_BT_CTLR_SCHED_ADVANCED=n\nCONFIG_BT_CTLR_RADIO_ENABLE_FAST=y\nCONFIG_BT_CTLR_TIFS_HW=n\nCONFIG_BT_CTLR_TX_RETRY_DISABLE=y\nCONFIG_BT_CTLR_CONN_RSSI=y\nCONFIG_BT_CTLR_ADV_INDICATION=y",
  "result": "I corrected the issue in the code by changing the following tokens:\n+config BT_CTLR_CIS_ACCEPT_MIN_OFFSET_STRICT\n+\tbool \"Enforce Strict CIS Minimum Offset Check\"\n+\tdepends on BT_CTLR_PERIPHERAL_ISO\n+\thelp\n+\t  Enforce strict check of CIS minimum offset accepted by the peripheral\n+\t  considering that there will be no overlap of ACL connection with the\n+\t  CIG events. Radio and CPU overheads for an ACL connection event is\n+\t  considered and checks the CIS minimum offset is greater than the time\n+\t  reservation for the ACL connection.\n+\n+operator|||\n+operator|!\n+name|IS_ENABLED\n+argument_list|(\n+name|CONFIG_BT_CTLR_CIS_ACCEPT_MIN_OFFSET_STRICT\n+argument_list|)\n+CONFIG_BT_CTLR_CIS_ACCEPT_MIN_OFFSET_STRICT=y\n+CONFIG_BT_CTLR_CIS_ACCEPT_MIN_OFFSET_STRICT=n\n+CONFIG_BT_CTLR_EVENT_OVERHEAD_RESERVE_MAX=y\nThe issue was with: Bluetooth: Controller: Fix CIS accept fails with unsupp parameters\n\nFix CIS accepted by Host being failed in the Controller with\nreason 0x20 Unsupported LL Parameter Value, by relaxing the\ncheck that the ACL connection is sufficiently placed such\nthat the time reservation using in the Controller\nimplementation does not overlap with the CIG event."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: Fix Broadcast ISO context get function\n\nFix Broadcast ISO context get function for out-of-bound\naccess. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nif|if\ncondition|(\nname|handle\noperator|>=\nname|CONFIG_BT_CTLR_ADV_SET\ncondition|)\nblock|{\nreturn|return\nname|NULL\nreturn|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_BT_CTLR_ADV_SET\n+name|CONFIG_BT_CTLR_ADV_ISO_SET\nThe issue was with: Bluetooth: Controller: Fix Broadcast ISO context get function\n\nFix Broadcast ISO context get function for out-of-bound\naccess."
},{
  "instruction": "There is an issue in the following code. It relates to llext: add STT_OBJECT relocation\n\nAdds STT_OBJECT relocation.\n\nFixes #67701. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|.\nname|st_info\nargument_list|)\noperator|==\nname|STT_FUNC\ncondition|)\nblock|{\ncomment|/* Link address is relative to the start of the section */\nname|link_addr\noperator|=\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\ncomment|/* Nothing to relocate here */\ncontinue|continue;\nblock|}\nname|LOG_INF\nargument_list|(\nliteral|\"relocating (linking) symbol %s type %d binding %d ndx %d offset \"",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|||\n+name|ELF_ST_TYPE\n+argument_list|(\n+name|sym\n+operator|.\n+name|st_info\n+argument_list|)\n+operator|==\n+name|STT_OBJECT\n+name|LOG_DBG\n+argument_list|(\n+literal|\"not relocated\"\n+argument_list|)\n+expr_stmt|;\nThe issue was with: llext: add STT_OBJECT relocation\n\nAdds STT_OBJECT relocation.\n\nFixes #67701."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: video: sw_generator: Fix minor macro usage\n\nVIDEO_PATTERN_FPS should be coherently used across the entire code file. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|buf_work\nargument_list|,\nname|K_MSEC\nargument_list|(\nliteral|33\nargument_list|)\nargument_list|)\nexpr_stmt|;\nreturn|return\nliteral|0",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|33\n+literal|1000\n+operator|/\n+name|VIDEO_PATTERN_FPS\nThe issue was with: drivers: video: sw_generator: Fix minor macro usage\n\nVIDEO_PATTERN_FPS should be coherently used across the entire code file."
},{
  "instruction": "There is an issue in the following code. It relates to llext: arch_elf_relocate: pass opval unmodified\n\nThe opval argument of arch_elf_relocate() was modified by\nadding the value stored at opaddr before passing it to\narch_elf_relocate(). This presumed that the addend would\nalways be stored as a raw value at opaddr, which is not the\ncase for all relocation types.\n\nThis PR modifies opval to be the absolute address of opval,\nand moves the addition of the addend from llext_link_plt()\nto the implementation of arch_elf_relocate(). Please fix this issue.",
  "input": "Faulty tokenized code:\ncondition|)\nblock|{\ncase|case\nname|R_ARM_ABS32\ncase|:\ncomment|/* Update the absolute address of a load/store instruction */\noperator|*\noperator|(\noperator|(\nname|uint32_t\nargument_list|)\noperator|==\nname|STT_FUNC\ncondition|)\nblock|{\ncomment|/* Current relocation location holds an offset into the section */\nname|link_addr\noperator|=\noperator|(\nname|uintptr_t\noperator|)\nindex|]\noperator|+\nname|sym\noperator|.\nname|st_value\noperator|+\noperator|*\noperator|(\noperator|(\nname|uintptr_t\noperator|*\noperator|)\nname|op_loc\noperator|)\nexpr_stmt|;\nname|LOG_INF\nargument_list|(\nliteral|\"found section symbol %s addr 0x%lx\"\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Add the addend stored at opaddr to opval */\n+name|opval\n+operator|+=\n+operator|*\n+operator|(\n+operator|(\n+name|uint32_t\n+operator|*\n+operator|)\n+name|opaddr\n+operator|)\n+expr_stmt|;\n-comment|/* Current relocation location holds an offset into the section */\n+comment|/* Link address is relative to the start of the section */\n-operator|+\n-operator|*\n-operator|(\n-operator|(\n-name|uintptr_t\n-operator|*\n-operator|)\n-name|op_loc\n-operator|)\nThe issue was with: llext: arch_elf_relocate: pass opval unmodified\n\nThe opval argument of arch_elf_relocate() was modified by\nadding the value stored at opaddr before passing it to\narch_elf_relocate(). This presumed that the addend would\nalways be stored as a raw value at opaddr, which is not the\ncase for all relocation types.\n\nThis PR modifies opval to be the absolute address of opval,\nand moves the addition of the addend from llext_link_plt()\nto the implementation of arch_elf_relocate()."
},{
  "instruction": "There is an issue in the following code. It relates to xtensa: mmu: Fix rasid initial value\n\nRASID must not use 0 for any slot. According with documentation:\n\n\\\"\\\"\\\"The operation of the processor is undefined if any two of the\nfour ASIDs are equal or if it contains an ASID of zero\\\"\\\"\\\" Please fix this issue.",
  "input": "Faulty tokenized code:\ncomment|/* defined in asm below */\nname|struct\nname|tlb_regs\nname|regs\ndecl_stmt|;\nif|#\ndirective|if\nname|CONFIG_MP_MAX_NUM_CPUS\noperator|>\nliteral|1\ncomment|/* invalidate stk */\nasm|\"isync\\n\" \t\t\t \"iitlb %8\\n\"\ncomment|/* invalidate pc */\nasm|\"isync\\n\"\ncomment|/*<--- traps a ITLB miss */\nasm|:: \"r\"(regs.ptevaddr), \"r\"(regs.rasid), \t\t\t    \"r\"(regs.ptepin_at), \"r\"(regs.ptepin_as), \t\t\t    \"r\"(regs.vecpin_at), \"r\"(regs.vecpin_as), \t\t\t    \"r\"(idtlb_pte), \"r\"(idtlb_stk), \"r\"(iitlb_pc));\ncomment|/* Invalidate the remaining (unused by this function) \t * initialization entries. Now we're flying free with our own \t * page table. \t */\nfor|for\ncontrol|(\nname|uint32_t\nname|i",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|unsigned\n+name|int\n+name|initial_rasid\n+decl_stmt|;\n+comment|/* The initial rasid after hardware initialization is 0x04030201. \t * 1 is hardwired to ring 0, other slots must be different \t * from each other and must not be 0. \t * \t * For our initial implementation we just set the 4th slot (ring 3), \t * to use the ASID value used for memory that is shared with all threads. \t */\n+name|initial_rasid\n+operator|=\n+literal|0xff030201\n+expr_stmt|;\n-asm|:: \"r\"(regs.ptevaddr), \"r\"(regs.rasid), \t\t\t    \"r\"(regs.ptepin_at), \"r\"(regs.ptepin_as), \t\t\t    \"r\"(regs.vecpin_at), \"r\"(regs.vecpin_as), \t\t\t    \"r\"(idtlb_pte), \"r\"(idtlb_stk), \"r\"(iitlb_pc));\n+asm|:: \"r\"(regs.ptevaddr), \"r\"(initial_rasid), \t\t\t    \"r\"(regs.ptepin_at), \"r\"(regs.ptepin_as), \t\t\t    \"r\"(regs.vecpin_at), \"r\"(regs.vecpin_as), \t\t\t    \"r\"(idtlb_pte), \"r\"(idtlb_stk), \"r\"(iitlb_pc));\nThe issue was with: xtensa: mmu: Fix rasid initial value\n\nRASID must not use 0 for any slot. According with documentation:\n\n\\\"\\\"\\\"The operation of the processor is undefined if any two of the\nfour ASIDs are equal or if it contains an ASID of zero\\\"\\\"\\\""
},{
  "instruction": "There is an issue in the following code. It relates to soc: nordic: Fix validation of base addresses\n\nUse `DT_REG_HAS_IDX()` instead of `DT_NODE_EXISTS()` when checking\nif for a given nodelabel the base address of the associated node\nshould be validated, so that the validation is performed only if\nthe base address is available. This prevents build failures in cases\nlike the os_mgmt_datetime test where the `rtc` nodelabel is used for\nan emulated RTC. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|lbl\nparameter_list|,\nname|mdk_addr\nparameter_list|)\ndefine|\\\nvalue|BUILD_ASSERT(\t\t\t\t\t\t\t\\ \t\tUTIL_OR(UTIL_NOT(DT_NODE_EXISTS(DT_NODELABEL(lbl))),\t\\ \t\t\t(DT_REG_ADDR(DT_NODELABEL(lbl)) == (uint32_t)(mdk_addr))))\nend_define\n\nbegin_comment\ncomment|/**  * If a node label \"lbl\" might have different addresses depending on  * its compatible \"compat\", you can use this macro to pick the right  * one.  *  * @param lbl lowercase-and-underscores devicetree node label to check  * @param compat lowercase-and-underscores compatible to check  * @param addr_if_match MDK address to return if \"lbl\" has compatible \"compat\"  * @param addr_if_no_match MDK address to return otherwise  */\nend_comment",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|BUILD_ASSERT(\t\t\t\t\t\t\t\\ \t\tUTIL_OR(UTIL_NOT(DT_NODE_EXISTS(DT_NODELABEL(lbl))),\t\\ \t\t\t(DT_REG_ADDR(DT_NODELABEL(lbl)) == (uint32_t)(mdk_addr))))\n+value|BUILD_ASSERT(\t\t\t\t\t\t\t\\ \t\tUTIL_OR(UTIL_NOT(DT_REG_HAS_IDX(DT_NODELABEL(lbl), 0)),\t\\ \t\t\t(DT_REG_ADDR(DT_NODELABEL(lbl)) == (uint32_t)(mdk_addr))))\nThe issue was with: soc: nordic: Fix validation of base addresses\n\nUse `DT_REG_HAS_IDX()` instead of `DT_NODE_EXISTS()` when checking\nif for a given nodelabel the base address of the associated node\nshould be validated, so that the validation is performed only if\nthe base address is available. This prevents build failures in cases\nlike the os_mgmt_datetime test where the `rtc` nodelabel is used for\nan emulated RTC."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: watchdog: wdt_nrfx.c Fix channel id check in wdt_feed()\n\nA Bug in the watchdog driver code allows an unconfigured\nWDT timer channel to be feed.\n\nThe first configured WDT timer channel has an id of zero.\nAt this point, data->m_allocated_channels is equal to one.\nThe condition of the if statement is invalid and allows\nchannel one to be feed.\n\nChange the test condition from greater to greater-or-equal.\nAdd check if channel id is less than zero. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|data\ndecl_stmt|;\nif|if\ncondition|(\nname|channel_id\noperator|>\nname|data\noperator|->\nname|m_allocated_channels\ncondition|)\nblock|{\nreturn|return\noperator|-\nname|EINVAL",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n-operator|>\n+operator|>=\n+operator|)\n+operator|||\n+operator|(\n+name|channel_id\n+operator|<\n+literal|0\n+operator|)\nThe issue was with: drivers: watchdog: wdt_nrfx.c Fix channel id check in wdt_feed()\n\nA Bug in the watchdog driver code allows an unconfigured\nWDT timer channel to be feed.\n\nThe first configured WDT timer channel has an id of zero.\nAt this point, data->m_allocated_channels is equal to one.\nThe condition of the if statement is invalid and allows\nchannel one to be feed.\n\nChange the test condition from greater to greater-or-equal.\nAdd check if channel id is less than zero."
},{
  "instruction": "There is an issue in the following code. It relates to boards: actinius: Move common folder\n\nMoves the common folder to the vendor directory Please fix this issue.",
  "input": "Faulty tokenized code:\nsimilarity index 100%\nrename from boards/common/actinius/CMakeLists.txt\nrename to boards/actinius/common/CMakeLists.txt\nsimilarity index 100%\nrename from boards/common/actinius/Kconfig\nrename to boards/actinius/common/Kconfig\nsimilarity index 100%\nrename from boards/common/actinius/actinius_board_common.c\nrename to boards/actinius/common/actinius_board_common.c\n#\n# Copyright (c) 2019-2022 Actinius\n#\n# SPDX-License-Identifier: Apache-2.0\n\nadd_subdirectory(${ZEPHYR_BASE}/boards/common/actinius actinius_common)\n# Copyright (c) 2019 Actinius\n# SPDX-License-Identifier: Apache-2.0\n\nif BOARD_ACTINIUS_ICARUS\n\nsource \"boards/common/actinius/Kconfig\"\n\n# For the secure version of the board the firmware is linked at the beginning\n# of the flash, or into the code-partition defined in DT if it is intended to\n# be loaded by MCUboot. If the secure firmware is to be combined with a non-\n# secure image (TRUSTED_EXECUTION_SECURE=y), the secure FW image shall always\n#\n# Copyright (c) 2021-2022 Actinius\n#\n# SPDX-License-Identifier: Apache-2.0\n\nadd_subdirectory(${ZEPHYR_BASE}/boards/common/actinius actinius_common)\n# Copyright (c) 2021 Actinius\n# SPDX-License-Identifier: Apache-2.0\n\nif BOARD_ACTINIUS_ICARUS_BEE\n\nsource \"boards/common/actinius/Kconfig\"\n\n# For the secure version of the board the firmware is linked at the beginning\n# of the flash, or into the code-partition defined in DT if it is intended to\n# be loaded by MCUboot. If the secure firmware is to be combined with a non-\n# secure image (TRUSTED_EXECUTION_SECURE=y), the secure FW image shall always\n#\n# Copyright (c) 2021-2022 Actinius\n#\n# SPDX-License-Identifier: Apache-2.0\n\nadd_subdirectory(${ZEPHYR_BASE}/boards/common/actinius actinius_common)\n# Copyright (c) 2021 Actinius\n# SPDX-License-Identifier: Apache-2.0\n\nif BOARD_ACTINIUS_ICARUS_SOM\n\nsource \"boards/common/actinius/Kconfig\"\n\n# For the secure version of the board the firmware is linked at the beginning\n# of the flash, or into the code-partition defined in DT if it is intended to\n# be loaded by MCUboot. If the secure firmware is to be combined with a non-\n# secure image (TRUSTED_EXECUTION_SECURE=y), the secure FW image shall always\n#\n# Copyright (c) 2022 Actinius\n#\n# SPDX-License-Identifier: Apache-2.0\n\nadd_subdirectory(${ZEPHYR_BASE}/boards/common/actinius actinius_common)\n# Copyright (c) 2022 Actinius\n# SPDX-License-Identifier: Apache-2.0\n\nif BOARD_ACTINIUS_ICARUS_SOM_DK\n\nsource \"boards/common/actinius/Kconfig\"\n\n# For the secure version of the board the firmware is linked at the beginning\n# of the flash, or into the code-partition defined in DT if it is intended to\n# be loaded by MCUboot. If the secure firmware is to be combined with a non-\n# secure image (TRUSTED_EXECUTION_SECURE=y), the secure FW image shall always",
  "result": "I corrected the issue in the code by changing the following tokens:\n-add_subdirectory(${ZEPHYR_BASE}/boards/common/actinius actinius_common)\n+add_subdirectory(${ZEPHYR_BASE}/boards/actinius/common actinius_common)\n-source \"boards/common/actinius/Kconfig\"\n+source \"boards/actinius/common/Kconfig\"\n-add_subdirectory(${ZEPHYR_BASE}/boards/common/actinius actinius_common)\n+add_subdirectory(${ZEPHYR_BASE}/boards/actinius/common actinius_common)\n-source \"boards/common/actinius/Kconfig\"\n+source \"boards/actinius/common/Kconfig\"\n-add_subdirectory(${ZEPHYR_BASE}/boards/common/actinius actinius_common)\n+add_subdirectory(${ZEPHYR_BASE}/boards/actinius/common actinius_common)\n-source \"boards/common/actinius/Kconfig\"\n+source \"boards/actinius/common/Kconfig\"\n-add_subdirectory(${ZEPHYR_BASE}/boards/common/actinius actinius_common)\n+add_subdirectory(${ZEPHYR_BASE}/boards/actinius/common actinius_common)\n-source \"boards/common/actinius/Kconfig\"\n+source \"boards/actinius/common/Kconfig\"\nThe issue was with: boards: actinius: Move common folder\n\nMoves the common folder to the vendor directory"
},{
  "instruction": "There is an issue in the following code. It relates to net: arp: Fix failed to add the arp table in stress test\n\nDuring stress test with WiFi connect, disconnect, ping and throughput\ntraffic, ARP table updating failed issue may occur.\nIn arp_prepare(), if packet allocate failed, should add the arp\nentry back to arp_free_entries, to avoid this entry is leak forever. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|req\nargument_list|)\nexpr_stmt|;\nblock|}\nname|k_mutex_unlock\nargument_list|(\noperator|&\nname|arp_mutex\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+operator|!\n+name|req\n+operator|&&\n+name|entry\n+condition|)\n+block|{\n+comment|/* Add the arp entry back to arp_free_entries, to avoid the \t\t\t * arp entry is leak due to ARP packet allocated failed. \t\t\t */\n+name|sys_slist_prepend\n+argument_list|(\n+operator|&\n+name|arp_free_entries\n+argument_list|,\n+operator|&\n+name|entry\n+operator|->\n+name|node\n+argument_list|)\n+expr_stmt|;\n+block|}\nThe issue was with: net: arp: Fix failed to add the arp table in stress test\n\nDuring stress test with WiFi connect, disconnect, ping and throughput\ntraffic, ARP table updating failed issue may occur.\nIn arp_prepare(), if packet allocate failed, should add the arp\nentry back to arp_free_entries, to avoid this entry is leak forever."
},{
  "instruction": "There is an issue in the following code. It relates to input: pat912x: fix build with default cpi setting\n\nFix up the BUILD_ASSERT so that it does not trigger if the resolution\ncpi is not specified in the devicetree and left to the default value.\nAlso use the correct spelling for \\\"cpi\\\". Please fix this issue.",
  "input": "Faulty tokenized code:\nname|PAT912X_INIT\nparameter_list|(\nname|n\nparameter_list|)\ndefine|\\\nvalue|BUILD_ASSERT(IN_RANGE(DT_INST_PROP(n, res_x_cpi), 0, RES_MAX),\t\t\\ \t\t     \"invalid res-x-cpy\");\t\t\t\t\t\\ \tBUILD_ASSERT(IN_RANGE(DT_INST_PROP(n, res_y_cpi), 0, RES_MAX),\t\t\\ \t\t     \"invalid res-y-cpy\");\t\t\t\t\t\\ \tBUILD_ASSERT(DT_INST_PROP(n, sleep1_enable) ||\t\t\t\t\\ \t\t     !DT_INST_PROP(n, sleep2_enable),\t\t\t\t\\ \t\t     \"invalid sleep configuration\");\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct pat912x_config pat912x_cfg_##n = {\t\t\t\\ \t\t.i2c = I2C_DT_SPEC_INST_GET(n),\t\t\t\t\t\\ \t\t.motion_gpio = GPIO_DT_SPEC_INST_GET(n, motion_gpios),\t\t\\ \t\t.axis_x = DT_INST_PROP_OR(n, zephyr_axis_x, -1),\t\t\\ \t\t.axis_y = DT_INST_PROP_OR(n, zephyr_axis_y, -1),\t\t\\ \t\t.res_x_cpi = DT_INST_PROP_OR(n, res_x_cpi, -1),\t\t\t\\ \t\t.res_y_cpi = DT_INST_PROP_OR(n, res_y_cpi, -1),\t\t\t\\ \t\t.invert_x = DT_INST_PROP(n, invert_x),\t\t\t\t\\ \t\t.invert_y = DT_INST_PROP(n, invert_y),\t\t\t\t\\ \t\t.sleep1_enable = DT_INST_PROP(n, sleep1_enable),\t\t\\ \t\t.sleep2_enable = DT_INST_PROP(n, sleep2_enable),\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic struct pat912x_data pat912x_data_##n;\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(n, pat912x_pm_action);\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n, pat912x_init, PM_DEVICE_DT_INST_GET(n),\t\\&pat912x_data_##n,&pat912x_cfg_##n,\t\t\\ \t\t\t      POST_KERNEL, CONFIG_INPUT_INIT_PRIORITY,\t\t\\ \t\t\t      NULL);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|BUILD_ASSERT(IN_RANGE(DT_INST_PROP(n, res_x_cpi), 0, RES_MAX),\t\t\\ \t\t     \"invalid res-x-cpy\");\t\t\t\t\t\\ \tBUILD_ASSERT(IN_RANGE(DT_INST_PROP(n, res_y_cpi), 0, RES_MAX),\t\t\\ \t\t     \"invalid res-y-cpy\");\t\t\t\t\t\\ \tBUILD_ASSERT(DT_INST_PROP(n, sleep1_enable) ||\t\t\t\t\\ \t\t     !DT_INST_PROP(n, sleep2_enable),\t\t\t\t\\ \t\t     \"invalid sleep configuration\");\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct pat912x_config pat912x_cfg_##n = {\t\t\t\\ \t\t.i2c = I2C_DT_SPEC_INST_GET(n),\t\t\t\t\t\\ \t\t.motion_gpio = GPIO_DT_SPEC_INST_GET(n, motion_gpios),\t\t\\ \t\t.axis_x = DT_INST_PROP_OR(n, zephyr_axis_x, -1),\t\t\\ \t\t.axis_y = DT_INST_PROP_OR(n, zephyr_axis_y, -1),\t\t\\ \t\t.res_x_cpi = DT_INST_PROP_OR(n, res_x_cpi, -1),\t\t\t\\ \t\t.res_y_cpi = DT_INST_PROP_OR(n, res_y_cpi, -1),\t\t\t\\ \t\t.invert_x = DT_INST_PROP(n, invert_x),\t\t\t\t\\ \t\t.invert_y = DT_INST_PROP(n, invert_y),\t\t\t\t\\ \t\t.sleep1_enable = DT_INST_PROP(n, sleep1_enable),\t\t\\ \t\t.sleep2_enable = DT_INST_PROP(n, sleep2_enable),\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic struct pat912x_data pat912x_data_##n;\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(n, pat912x_pm_action);\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n, pat912x_init, PM_DEVICE_DT_INST_GET(n),\t\\&pat912x_data_##n,&pat912x_cfg_##n,\t\t\\ \t\t\t      POST_KERNEL, CONFIG_INPUT_INIT_PRIORITY,\t\t\\ \t\t\t      NULL);\n+value|BUILD_ASSERT(IN_RANGE(DT_INST_PROP_OR(n, res_x_cpi, 0), 0, RES_MAX),\t\\ \t\t     \"invalid res-x-cpi\");\t\t\t\t\t\\ \tBUILD_ASSERT(IN_RANGE(DT_INST_PROP_OR(n, res_y_cpi, 0), 0, RES_MAX),\t\\ \t\t     \"invalid res-y-cpi\");\t\t\t\t\t\\ \tBUILD_ASSERT(DT_INST_PROP(n, sleep1_enable) ||\t\t\t\t\\ \t\t     !DT_INST_PROP(n, sleep2_enable),\t\t\t\t\\ \t\t     \"invalid sleep configuration\");\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct pat912x_config pat912x_cfg_##n = {\t\t\t\\ \t\t.i2c = I2C_DT_SPEC_INST_GET(n),\t\t\t\t\t\\ \t\t.motion_gpio = GPIO_DT_SPEC_INST_GET(n, motion_gpios),\t\t\\ \t\t.axis_x = DT_INST_PROP_OR(n, zephyr_axis_x, -1),\t\t\\ \t\t.axis_y = DT_INST_PROP_OR(n, zephyr_axis_y, -1),\t\t\\ \t\t.res_x_cpi = DT_INST_PROP_OR(n, res_x_cpi, -1),\t\t\t\\ \t\t.res_y_cpi = DT_INST_PROP_OR(n, res_y_cpi, -1),\t\t\t\\ \t\t.invert_x = DT_INST_PROP(n, invert_x),\t\t\t\t\\ \t\t.invert_y = DT_INST_PROP(n, invert_y),\t\t\t\t\\ \t\t.sleep1_enable = DT_INST_PROP(n, sleep1_enable),\t\t\\ \t\t.sleep2_enable = DT_INST_PROP(n, sleep2_enable),\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic struct pat912x_data pat912x_data_##n;\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(n, pat912x_pm_action);\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n, pat912x_init, PM_DEVICE_DT_INST_GET(n),\t\\&pat912x_data_##n,&pat912x_cfg_##n,\t\t\\ \t\t\t      POST_KERNEL, CONFIG_INPUT_INIT_PRIORITY,\t\t\\ \t\t\t      NULL);\nThe issue was with: input: pat912x: fix build with default cpi setting\n\nFix up the BUILD_ASSERT so that it does not trigger if the resolution\ncpi is not specified in the devicetree and left to the default value.\nAlso use the correct spelling for \\\"cpi\\\"."
},{
  "instruction": "There is an issue in the following code. It relates to Samples: Bluetooth: HF: Fix link key missing issue\n\nThe bonding info is not loaded after the Bluetooth\ninitialization again.\n\nCall settings_load after the Bluetooth initialized. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/bluetooth/classic/hfp_hf.h>\nend_include\n\nbegin_function\nDECL|function|connected (struct bt_conn * conn)\nspecifier|static\nname|void\nname|connected\nname|err\nargument_list|)\nexpr_stmt|;\nreturn|return;\nblock|}\nname|printk\nargument_list|(\nliteral|\"Bluetooth initialized\\n\"\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/settings/settings.h>\n+end_include\n+\n+if|if\n+condition|(\n+name|IS_ENABLED\n+argument_list|(\n+name|CONFIG_SETTINGS\n+argument_list|)\n+condition|)\n+block|{\n+name|settings_load\n+argument_list|()\n+expr_stmt|;\n+block|}\nThe issue was with: Samples: Bluetooth: HF: Fix link key missing issue\n\nThe bonding info is not loaded after the Bluetooth\ninitialization again.\n\nCall settings_load after the Bluetooth initialized."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: espi: npcx: fix warning when using ESPI_OOB_RX_ASYNC macro\n\nThis CL prevents unused warnings when CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC\nis used. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|HAL_INSTANCE\nargument_list|(\nname|dev\nargument_list|)\ndecl_stmt|;\nname|struct\nname|espi_npcx_data\nmodifier|*\nspecifier|const\nname|data\ninit|=\nname|dev\noperator|->\nname|data\ndecl_stmt|;\nname|uint8_t\nmodifier|*\nname|oob_buf\ninit|=\nname|pckt\ndecl_stmt|;\nname|int\nname|idx_rx_buf\ndecl_stmt|,\nname|sz_oob_rx\ndecl_stmt|,\nname|ret\ndecl_stmt|;\ncomment|/* Check eSPI bus status first */\nif|if\ncondition|(\nname|IS_BIT_SET\noperator|!\nname|defined\nargument_list|(\nname|CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC\nargument_list|)\ncomment|/* Wait until get oob package or timeout */\nname|ret\noperator|=\nname|k_sem_take\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|struct\n-name|espi_npcx_data\n-modifier|*\n-specifier|const\n-name|data\n-init|=\n-name|dev\n-operator|->\n-name|data\n-decl_stmt|;\n-decl_stmt|,\n-name|ret\n+name|struct\n+name|espi_npcx_data\n+modifier|*\n+specifier|const\n+name|data\n+init|=\n+name|dev\n+operator|->\n+name|data\n+decl_stmt|;\n+name|int\n+name|ret\n+decl_stmt|;\nThe issue was with: drivers: espi: npcx: fix warning when using ESPI_OOB_RX_ASYNC macro\n\nThis CL prevents unused warnings when CONFIG_ESPI_OOB_CHANNEL_RX_ASYNC\nis used."
},{
  "instruction": "There is an issue in the following code. It relates to ITE: drivers/i2c: Change GPIO output type to open-drain in recovery mode\n\nIf I2C recovery mode uses GPIO push-pull to drive(3.3v), it will result\nleakage in a pull-up voltage of 1.8V on the power rail, leading to\ndamage to 1.8V devices, including SoC, sensors.\nTherefore, the recovery mode should be changed to GPIO open-drain type\nto avoid this. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|bool\nname|target_attached\ndecl_stmt|;\nendif|#\ndirective|endif\nDECL|union|__anon28e26928010a\nunion|union\nblock|{\nifdef|#\ndirective|ifdef\nname|CONFIG_I2C_IT8XXX2_CQ_MODE\nname|config\noperator|->\nname|scl_gpios\nargument_list|,\nname|GPIO_OUTPUT\nargument_list|)\nexpr_stmt|;\ncomment|/* Set SDA of I2C as GPIO pin */\nname|gpio_pin_configure_dt\nargument_list|(\nname|config\noperator|->\nname|sda_gpios\nargument_list|,\nname|GPIO_OUTPUT\nargument_list|)\nexpr_stmt|;\ncomment|/* \t * In I2C recovery bus, 1ms sleep interval for bitbanging i2c \t * is mainly to ensure that gpio has enough time to go from \t * low to high or high to low. \t */\ncomment|/* Pull SCL and SDA pin to high */\nname|gpio_pin_set_dt\nname|config\noperator|->\nname|scl_gpios\nargument_list|,\nname|GPIO_OUTPUT\nargument_list|)\nexpr_stmt|;\ncomment|/* Set SDA of I2C as GPIO pin */\nname|gpio_pin_configure_dt\nargument_list|(\nname|config\noperator|->\nname|sda_gpios\nargument_list|,\nname|GPIO_OUTPUT\nargument_list|)\nexpr_stmt|;\ncomment|/* \t * In I2C recovery bus, 1ms sleep interval for bitbanging i2c \t * is mainly to ensure that gpio has enough time to go from \t * low to high or high to low. \t */\ncomment|/* Pull SCL and SDA pin to high */\nname|gpio_pin_set_dt",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon28e26928010a\n+DECL|union|__anon29bf7d4e010a\n+operator||\n+name|GPIO_OPEN_DRAIN\n+operator||\n+name|GPIO_OPEN_DRAIN\n+operator||\n+name|GPIO_OPEN_DRAIN\n+operator||\n+name|GPIO_OPEN_DRAIN\nThe issue was with: ITE: drivers/i2c: Change GPIO output type to open-drain in recovery mode\n\nIf I2C recovery mode uses GPIO push-pull to drive(3.3v), it will result\nleakage in a pull-up voltage of 1.8V on the power rail, leading to\ndamage to 1.8V devices, including SoC, sensors.\nTherefore, the recovery mode should be changed to GPIO open-drain type\nto avoid this."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: pinctrl: Add support for more ports\n\nMCX has more port modules which requires updating\nthe pinctrl driver Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright (c) 2022-2023 NXP  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_define\nDECL|macro|DT_DRV_COMPAT\ndefine|#\nargument_list|)\nargument_list|)\nblock|,\nendif|#\ndirective|endif\nblock|}\ndecl_stmt|;\nend_decl_stmt\n\nbegin_define",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/*  * Copyright (c) 2022-2023 NXP  *  * SPDX-License-Identifier: Apache-2.0  */\n+comment|/*  * Copyright 2022-2024 NXP  *  * SPDX-License-Identifier: Apache-2.0  */\n+if|#\n+directive|if\n+name|DT_NUM_INST_STATUS_OKAY\n+argument_list|(\n+name|DT_DRV_COMPAT\n+argument_list|)\n+operator|>\n+literal|5\n+operator|(\n+name|PORT_Type\n+operator|*\n+operator|)\n+name|DT_REG_ADDR\n+argument_list|(\n+name|DT_NODELABEL\n+argument_list|(\n+name|portf\n+argument_list|)\n+argument_list|)\n+block|,\n+endif|#\n+directive|endif\nThe issue was with: drivers: pinctrl: Add support for more ports\n\nMCX has more port modules which requires updating\nthe pinctrl driver"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: uart: Use the register define instead of enum define\n\nThe enum define is not implemented with the same name on all SoC's.\nUse the register define instead. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|config\noperator|->\nname|base\nargument_list|)\noperator|&\nname|kLPUART_TxDataRegEmptyFlag\noperator|)\ncondition|)\nblock|{\nblock|}\ncomment|/* Lock interrupts while we send data */\nname|config\noperator|->\nname|base\nargument_list|)\noperator|&\nname|kLPUART_TxDataRegEmptyFlag\noperator|)\ncondition|)\nblock|{\nname|LPUART_WriteByte\nargument_list|(\noperator|)\noperator|&&\noperator|(\nname|flags\noperator|&\nname|kLPUART_TxDataRegEmptyFlag\noperator|)\nreturn|;\nblock|}\nend_function\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|kLPUART_TxDataRegEmptyFlag\n+name|LPUART_STAT_TDRE_MASK\n-name|kLPUART_TxDataRegEmptyFlag\n+name|LPUART_STAT_TDRE_MASK\n-name|kLPUART_TxDataRegEmptyFlag\n+name|LPUART_STAT_TDRE_MASK\nThe issue was with: drivers: uart: Use the register define instead of enum define\n\nThe enum define is not implemented with the same name on all SoC's.\nUse the register define instead."
},{
  "instruction": "There is an issue in the following code. It relates to dts: nxp_lpuart: Interrupts is no longer a required property\n\nSome NXP SoC's have a FlexComm interface which manages\ninterrupts. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|MCUX_LPUART_IRQ_DEFINE\nparameter_list|(\nname|n\nparameter_list|)\ndefine|\\\nvalue|static void mcux_lpuart_config_func_##n(const struct device *dev)\t\\ \t{\t\t\t\t\t\t\t\t\t\\ \t\tMCUX_LPUART_IRQ_INSTALL(n, 0);\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \t\tIF_ENABLED(DT_INST_IRQ_HAS_IDX(n, 1),\t\t\t\\ \t\t\t   (MCUX_LPUART_IRQ_INSTALL(n, 1);))\t\t\\ \t}\nend_define\n\nbegin_else\nelse|#\ndirective|else\n\nproperties:\n  reg:\n    required: true\n\n interrupts:\n   required: true\n\n  nxp,loopback:\n    type: boolean\n    description: |\n      Enable loopback mode on LPUART peripheral. When present, RX pin is\n      disconnected, and transmitter output is internally connected to",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|static void mcux_lpuart_config_func_##n(const struct device *dev)\t\\ \t{\t\t\t\t\t\t\t\t\t\\ \t\tMCUX_LPUART_IRQ_INSTALL(n, 0);\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \t\tIF_ENABLED(DT_INST_IRQ_HAS_IDX(n, 1),\t\t\t\\ \t\t\t   (MCUX_LPUART_IRQ_INSTALL(n, 1);))\t\t\\ \t}\n+value|static void mcux_lpuart_config_func_##n(const struct device *dev)\t\\ \t{\t\t\t\t\t\t\t\t\t\\ \t\tIF_ENABLED(DT_INST_IRQ_HAS_IDX(n, 0),\t\t\t\\ \t\t\t   (MCUX_LPUART_IRQ_INSTALL(n, 0);))\t\t\\ \t\t\t\t\t\t\t\t\t\\ \t\tIF_ENABLED(DT_INST_IRQ_HAS_IDX(n, 1),\t\t\t\\ \t\t\t   (MCUX_LPUART_IRQ_INSTALL(n, 1);))\t\t\\ \t}\n-  interrupts:\n-    required: true\n-\nThe issue was with: dts: nxp_lpuart: Interrupts is no longer a required property\n\nSome NXP SoC's have a FlexComm interface which manages\ninterrupts."
},{
  "instruction": "There is an issue in the following code. It relates to modem: modem_cellular: increase imsi size\n\nFixes an issue introduced with `080d51bb` Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_define\nDECL|macro|MODEM_CELLULAR_DATA_IMSI_LEN\ndefine|#\ndirective|define\nname|MODEM_CELLULAR_DATA_IMSI_LEN\nvalue|(22)\nend_define\n\nbegin_define\nDECL|macro|MODEM_CELLULAR_DATA_ICCID_LEN\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|(22)\n+value|(23)\nThe issue was with: modem: modem_cellular: increase imsi size\n\nFixes an issue introduced with `080d51bb`"
},{
  "instruction": "There is an issue in the following code. It relates to modem: modem_cellular: increase imei size\n\nFixes an issue introduced with `b668296a` Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_define\nDECL|macro|MODEM_CELLULAR_DATA_IMEI_LEN\ndefine|#\ndirective|define\nname|MODEM_CELLULAR_DATA_IMEI_LEN\nvalue|(15)\nend_define\n\nbegin_define\nDECL|macro|MODEM_CELLULAR_DATA_MODEL_ID_LEN\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|(15)\n+value|(16)\nThe issue was with: modem: modem_cellular: increase imei size\n\nFixes an issue introduced with `b668296a`"
},{
  "instruction": "There is an issue in the following code. It relates to modem: modem_cellular: increase model_id size\n\nFixes an issue introduced with `08a51bae` Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_define\nDECL|macro|MODEM_CELLULAR_DATA_MODEL_ID_LEN\ndefine|#\ndirective|define\nname|MODEM_CELLULAR_DATA_MODEL_ID_LEN\nvalue|(64)\nend_define\n\nbegin_define\nDECL|macro|MODEM_CELLULAR_DATA_IMSI_LEN\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|(64)\n+value|(65)\nThe issue was with: modem: modem_cellular: increase model_id size\n\nFixes an issue introduced with `08a51bae`"
},{
  "instruction": "There is an issue in the following code. It relates to modem: modem_cellular: increase manufacturer size\n\nFixes an issue introduced with `ae951f5f` Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_define\nDECL|macro|MODEM_CELLULAR_DATA_MANUFACTURER_LEN\ndefine|#\ndirective|define\nname|MODEM_CELLULAR_DATA_MANUFACTURER_LEN\nvalue|(64)\nend_define\n\nbegin_define\nDECL|macro|MODEM_CELLULAR_DATA_FW_VERSION_LEN\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|(64)\n+value|(65)\nThe issue was with: modem: modem_cellular: increase manufacturer size\n\nFixes an issue introduced with `ae951f5f`"
},{
  "instruction": "There is an issue in the following code. It relates to modem: modem_cellular: increase fw_version size\n\nFixes an issue introduced with `adcdf64a` Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_define\nDECL|macro|MODEM_CELLULAR_DATA_FW_VERSION_LEN\ndefine|#\ndirective|define\nname|MODEM_CELLULAR_DATA_FW_VERSION_LEN\nvalue|(64)\nend_define\n\nbegin_comment\ncomment|/* Magic constants */\nend_comment",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|(64)\n+value|(65)\nThe issue was with: modem: modem_cellular: increase fw_version size\n\nFixes an issue introduced with `adcdf64a`"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Host: Add NULL check for callback_list\n\nIf no callbacks have been registered then callback_list\nis NULL, in which case we can skip searching.\n\nThis also fixes a NULL-pointer acces in the while loop\nas previous_callback would be NULL when it gets\ndereferenced as previous_callback->_next. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|;\nblock|}\nend_function\n\nbegin_enum\nDECL|enum|__anon29a33dc80103\nenum|enum\nblock|{\nDECL|enumerator|FRAG_START\nname|FRAG_START\nblock|,\nblock|}\nif|if\ncondition|(\nname|callback_list\noperator|==\nname|cb\ncondition|)\nblock|{\nname|callback_list\noperator|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon29a33dc80103\n+DECL|enum|__anon2c4eb9bc0103\n+name|NULL\n+condition|)\n+block|{\n+comment|/* No callsback registered */\n+return|return\n+operator|-\n+name|ENOENT\n+return|;\n+block|}\n+if|if\n+condition|(\n+name|callback_list\n+operator|==\nThe issue was with: Bluetooth: Host: Add NULL check for callback_list\n\nIf no callbacks have been registered then callback_list\nis NULL, in which case we can skip searching.\n\nThis also fixes a NULL-pointer acces in the while loop\nas previous_callback would be NULL when it gets\ndereferenced as previous_callback->_next."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: adc: stm32: dma fixes\n\nAdd a blank define for the case where DMA channels are defined in ADC node\nof the dts but STM32_ADC_DMA is not enabled. Otherwise compilation fails.\nAlso fix the way the DMA channel is configured by using a standard DT\nmacro, otherwise it doesn't work for dma-v2bis DMA types. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|src_dev\nparameter_list|,\nname|dest_dev\nparameter_list|)\ndefine|\\\nvalue|.dma = {\t\t\t\t\t\t\t\t\t\\ \t\t.dma_dev = DEVICE_DT_GET(DT_INST_DMAS_CTLR_BY_IDX(index, 0)),\t\t\\ \t\t.channel = STM32_DMA_SLOT_BY_IDX(index, 0, channel),\t\t\t\\ \t\t.dma_cfg = {\t\t\t\t\t\t\t\t\\ \t\t\t.dma_slot = STM32_DMA_SLOT_BY_IDX(index, 0, slot),\t\t\\ \t\t\t.channel_direction = STM32_DMA_CONFIG_DIRECTION(\t\t\\ \t\t\t\tSTM32_DMA_CHANNEL_CONFIG_BY_IDX(index, 0)),\t\t\\ \t\t\t.source_data_size = STM32_DMA_CONFIG_##src_dev##_DATA_SIZE(\t\\ \t\t\t\tSTM32_DMA_CHANNEL_CONFIG_BY_IDX(index, 0)),\t\t\\ \t\t\t.dest_data_size = STM32_DMA_CONFIG_##dest_dev##_DATA_SIZE(\t\\ \t\t\t\tSTM32_DMA_CHANNEL_CONFIG_BY_IDX(index, 0)),\t\t\\ \t\t\t.source_burst_length = 1,\ncomment|/* SINGLE transfer */\nvalue|\\ \t\t\t.dest_burst_length = 1,\ncomment|/* SINGLE transfer */\nvalue|\\ \t\t\t.channel_priority = STM32_DMA_CONFIG_PRIORITY(\t\t\t\\ \t\t\t\tSTM32_DMA_CHANNEL_CONFIG_BY_IDX(index, 0)),\t\t\\ \t\t\t.dma_callback = dma_callback,\t\t\t\t\t\\ \t\t\t.block_count = 2,\t\t\t\t\t\t\\ \t\t},\t\t\t\t\t\t\t\t\t\\ \t\t.src_addr_increment = STM32_DMA_CONFIG_##src_dev##_ADDR_INC(\t\t\\ \t\t\tSTM32_DMA_CHANNEL_CONFIG_BY_IDX(index, 0)),\t\t\t\\ \t\t.dst_addr_increment = STM32_DMA_CONFIG_##dest_dev##_ADDR_INC(\t\t\\ \t\t\tSTM32_DMA_CHANNEL_CONFIG_BY_IDX(index, 0)),\t\t\t\\ \t}\nDECL|macro|ADC_STM32_IRQ_FUNC (index)\nparameter_list|(\nname|index\nparameter_list|)\ndefine|\\\nvalue|.irq_cfg_func = COND_CODE_1(IS_EQ(index, FIRST_WITH_IRQN(index)),                          \\ \t\t\t\t    (UTIL_CAT(ISR_FUNC(index), _init)), (NULL)),\nendif|#\ndirective|endif\ncomment|/* CONFIG_ADC_STM32_DMA */\nDECL|macro|ADC_DMA_CHANNEL (id,src,dest)\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|.dma = {\t\t\t\t\t\t\t\t\t\\ \t\t.dma_dev = DEVICE_DT_GET(DT_INST_DMAS_CTLR_BY_IDX(index, 0)),\t\t\\ \t\t.channel = STM32_DMA_SLOT_BY_IDX(index, 0, channel),\t\t\t\\ \t\t.dma_cfg = {\t\t\t\t\t\t\t\t\\ \t\t\t.dma_slot = STM32_DMA_SLOT_BY_IDX(index, 0, slot),\t\t\\ \t\t\t.channel_direction = STM32_DMA_CONFIG_DIRECTION(\t\t\\ \t\t\t\tSTM32_DMA_CHANNEL_CONFIG_BY_IDX(index, 0)),\t\t\\ \t\t\t.source_data_size = STM32_DMA_CONFIG_##src_dev##_DATA_SIZE(\t\\ \t\t\t\tSTM32_DMA_CHANNEL_CONFIG_BY_IDX(index, 0)),\t\t\\ \t\t\t.dest_data_size = STM32_DMA_CONFIG_##dest_dev##_DATA_SIZE(\t\\ \t\t\t\tSTM32_DMA_CHANNEL_CONFIG_BY_IDX(index, 0)),\t\t\\ \t\t\t.source_burst_length = 1,\n+value|.dma = {\t\t\t\t\t\t\t\t\t\\ \t\t.dma_dev = DEVICE_DT_GET(DT_INST_DMAS_CTLR_BY_IDX(index, 0)),\t\t\\ \t\t.channel = DT_INST_DMAS_CELL_BY_IDX(index, 0, channel),\t\t\t\\ \t\t.dma_cfg = {\t\t\t\t\t\t\t\t\\ \t\t\t.dma_slot = STM32_DMA_SLOT_BY_IDX(index, 0, slot),\t\t\\ \t\t\t.channel_direction = STM32_DMA_CONFIG_DIRECTION(\t\t\\ \t\t\t\tSTM32_DMA_CHANNEL_CONFIG_BY_IDX(index, 0)),\t\t\\ \t\t\t.source_data_size = STM32_DMA_CONFIG_##src_dev##_DATA_SIZE(\t\\ \t\t\t\tSTM32_DMA_CHANNEL_CONFIG_BY_IDX(index, 0)),\t\t\\ \t\t\t.dest_data_size = STM32_DMA_CONFIG_##dest_dev##_DATA_SIZE(\t\\ \t\t\t\tSTM32_DMA_CHANNEL_CONFIG_BY_IDX(index, 0)),\t\t\\ \t\t\t.source_burst_length = 1,\n+DECL|macro|ADC_DMA_CHANNEL_INIT (index,src_dev,dest_dev)\n+define|#\n+directive|define\n+name|ADC_DMA_CHANNEL_INIT\n+parameter_list|(\n+name|index\n+parameter_list|,\n+name|src_dev\n+parameter_list|,\n+name|dest_dev\n+parameter_list|)\nThe issue was with: drivers: adc: stm32: dma fixes\n\nAdd a blank define for the case where DMA channels are defined in ADC node\nof the dts but STM32_ADC_DMA is not enabled. Otherwise compilation fails.\nAlso fix the way the DMA channel is configured by using a standard DT\nmacro, otherwise it doesn't work for dma-v2bis DMA types."
},{
  "instruction": "There is an issue in the following code. It relates to input: kbd_matrix: define PRIkbdrow coherently\n\nIt's not supposed to have the \\\"%\\\" in the macro, reuse the existin one\nfor the data type. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|++\ncontrol|)\nblock|{\nname|LOG_DBG\nargument_list|(\nliteral|\"c=%2d u=\"\nname|PRIkbdrow\nliteral|\" p=\"\nname|PRIkbdrow\nliteral|\" n=\"\nname|PRIkbdrow\nargument_list|,\nname|c\nargument_list|,\nname|cfg\nbegin_define\nDECL|macro|PRIkbdrow\ndefine|#\ndirective|define\nname|PRIkbdrow\nvalue|\"%04x\"\nend_define\n\nbegin_else\nelse|#\ndirective|else\nbegin_define\nDECL|macro|PRIkbdrow\ndefine|#\ndirective|define\nname|PRIkbdrow\nvalue|\"%02x\"\nend_define\n\nbegin_endif\nendif|#\ndirective|endif\nargument_list|(\nname|buf\nargument_list|,\nname|size\nargument_list|,\nname|PRIkbdrow\nliteral|\"%s\"\nargument_list|,\nname|data\nindex|[\nbegin_comment\ncomment|/* Mock data for every valid column. */\nend_comment\n\nbegin_struct\nDECL|struct|__anon2bec9e3d0108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|rows\nname|kbd_row_t\nargument|sizeof(state.rows)\nargument_list|)\nempty_stmt|;\nname|TC_PRINT\nargument_list|(\nliteral|\"set state [\"\nname|PRIkbdrow\nliteral|\" \"\nname|PRIkbdrow\nliteral|\" \"\nname|PRIkbdrow\nliteral|\"]\\n\"\nargument_list|,\nname|c0\nargument_list|,\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_struct\nDECL|struct|__anon2bec9e3d0208\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|row\nname|int",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"c=%2d u=\"\n+literal|\"c=%2d u=%\"\n-literal|\" p=\"\n+literal|\" p=%\"\n-literal|\" n=\"\n+literal|\" n=%\"\n-value|\"%04x\"\n+value|\"04\" PRIx16\n-value|\"%02x\"\n+value|\"02\" PRIx8\n+literal|\"%\"\n-DECL|struct|__anon2bec9e3d0108\n+DECL|struct|__anon2767c2c50108\n-literal|\"set state [\"\n+literal|\"set state [%\"\n-literal|\" \"\n+literal|\" %\"\n-literal|\" \"\n+literal|\" %\"\n-DECL|struct|__anon2bec9e3d0208\n+DECL|struct|__anon2767c2c50208\nThe issue was with: input: kbd_matrix: define PRIkbdrow coherently\n\nIt's not supposed to have the \\\"%\\\" in the macro, reuse the existin one\nfor the data type."
},{
  "instruction": "There is an issue in the following code. It relates to boards: lpcxpresso55s69: Fix misnomer\n\npinmux.c is inaptly named since it has nothing to do with pinmux.\nAlso, remove inclusion of iocon.h since this file does not use it,\nas this file has nothing to do with pinmux. Please fix this issue.",
  "input": "Faulty tokenized code:\n#\n# SPDX-License-Identifier: Apache-2.0\n#\n\nzephyr_library()\nzephyr_library_sources(pinmux.c)\nsimilarity index 94%\nrename from boards/nxp/lpcxpresso55s69/pinmux.c\nrename to boards/nxp/lpcxpresso55s69/board.c\ninclude|#\ndirective|include\nfile|<fsl_common.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<fsl_iocon.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<soc.h>\nend_include\n\nbegin_function\nDECL|function|lpcxpresso_55s69_pinmux_init (void)\nspecifier|static\nname|int\nname|lpcxpresso_55s69_pinmux_init\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nif|#\nend_function\n\nbegin_expr_stmt\nname|SYS_INIT\nargument_list|(\nname|lpcxpresso_55s69_pinmux_init\nargument_list|,\nname|PRE_KERNEL_1\nargument_list|,\nliteral|0\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-zephyr_library_sources(pinmux.c)\n+zephyr_library_sources(board.c)\n-begin_include\n-include|#\n-directive|include\n-file|<fsl_iocon.h>\n-end_include\n-\n-DECL|function|lpcxpresso_55s69_pinmux_init (void)\n+DECL|function|lpcxpresso_55s69_board_init (void)\n-name|lpcxpresso_55s69_pinmux_init\n+name|lpcxpresso_55s69_board_init\n-name|lpcxpresso_55s69_pinmux_init\n+name|lpcxpresso_55s69_board_init\nThe issue was with: boards: lpcxpresso55s69: Fix misnomer\n\npinmux.c is inaptly named since it has nothing to do with pinmux.\nAlso, remove inclusion of iocon.h since this file does not use it,\nas this file has nothing to do with pinmux."
},{
  "instruction": "There is an issue in the following code. It relates to net: dns: Fix timeout calculation with DNS retransmissions\n\nWith recently introduced DNS retransmission mechanism, a certain bug\ncould occur when calculating query timeout.\n\nIf the time until the final DNS timeout (as indicated by\nCONFIG_NET_SOCKETS_DNS_TIMEOUT) was less than 1 millisecond, the actual\nmillisecond timeout value was rounded down, resulting in 0 ms timeout.\nThis in order was interpreted as invalid argument by dns_get_addr_info()\nfunction, so in result, instead of reporting query timeout, the function\nreported invalid argument error.\n\nFix this by rounding the millisecond timeout up, instead of down, so\nthat in any case, if the final timeout is not due, we always provide\nnon-zero timeout to dns_get_addr_info(). Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nname|again\nlabel|:\nname|timeout_ms\noperator|=\nname|k_ticks_to_ms_floor32\nargument_list|(\nname|timeout\noperator|.\nname|ticks\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|k_ticks_to_ms_floor32\n+name|k_ticks_to_ms_ceil32\nThe issue was with: net: dns: Fix timeout calculation with DNS retransmissions\n\nWith recently introduced DNS retransmission mechanism, a certain bug\ncould occur when calculating query timeout.\n\nIf the time until the final DNS timeout (as indicated by\nCONFIG_NET_SOCKETS_DNS_TIMEOUT) was less than 1 millisecond, the actual\nmillisecond timeout value was rounded down, resulting in 0 ms timeout.\nThis in order was interpreted as invalid argument by dns_get_addr_info()\nfunction, so in result, instead of reporting query timeout, the function\nreported invalid argument error.\n\nFix this by rounding the millisecond timeout up, instead of down, so\nthat in any case, if the final timeout is not due, we always provide\nnon-zero timeout to dns_get_addr_info()."
},{
  "instruction": "There is an issue in the following code. It relates to intel_adsp/ace: power: Lock interruption when power gate fails\n\nIn case the core is not power gated, waiti will restore intlevel. In\nthis case we lock interruption after it.\n\nIn the bug scenario, the host starts streaming and via SOF APIs, keeps a\nlock to prevent Zephyr from entering PM_STATE_RUNTIME_IDLE. During the\ntest case, host removes this block and core0 is allowed to enter IDLE\nstate.\n\nWhen core0 enters power gated state, interrrupts are left enabled (so\nthe core can be woken up when something happens). This leaves a race\nwhere suitably timed interrupt will actually block entry to power gated\nstate and k_cpu_idle() in power_gate_entry() will return. This is rare,\nbut happens often enough that the relatively short test plan run on SOF\npull-requests will trigger this case.\n\nFixes #69807 Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nname|k_cpu_idle\nargument_list|()\nexpr_stmt|;\nname|z_xt_ints_off\nargument_list|(\nliteral|0xffffffff\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* It is unlikely we get in here, but when this happens \t * we need to lock interruptions again. \t * \t * @note Zephyr looks PS.INTLEVEL to check if interruptions are locked. \t */\n+operator|(\n+name|void\n+operator|)\n+name|arch_irq_lock\n+argument_list|()\n+expr_stmt|;\nThe issue was with: intel_adsp/ace: power: Lock interruption when power gate fails\n\nIn case the core is not power gated, waiti will restore intlevel. In\nthis case we lock interruption after it.\n\nIn the bug scenario, the host starts streaming and via SOF APIs, keeps a\nlock to prevent Zephyr from entering PM_STATE_RUNTIME_IDLE. During the\ntest case, host removes this block and core0 is allowed to enter IDLE\nstate.\n\nWhen core0 enters power gated state, interrrupts are left enabled (so\nthe core can be woken up when something happens). This leaves a race\nwhere suitably timed interrupt will actually block entry to power gated\nstate and k_cpu_idle() in power_gate_entry() will return. This is rare,\nbut happens often enough that the relatively short test plan run on SOF\npull-requests will trigger this case.\n\nFixes #69807"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: BAP: Shell: Fix issue with stopping broadcast sink\n\nWhen the broadcast sink is stopped, the sink was also\nset to NULL via\n\ndefault_broadcast_sink.bap_sink = NULL;\n\nHowever the lifetime of the broadcast sink does not\nfollow the state of the streams, and it still exists\nafterwards. The broadcast sink can only be terminated\n(deleted) via the term_broadcast_sink command. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|.\nname|syncable\noperator|=\nname|true\nexpr_stmt|;\nname|default_broadcast_sink\noperator|.\nname|bap_sink\noperator|=\nname|NULL\nexpr_stmt|;\nname|memset\nargument_list|(\noperator|&\nname|default_broadcast_sink\noperator|.",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|default_broadcast_sink\n-operator|.\n-name|bap_sink\n-operator|=\n-name|NULL\n-expr_stmt|;\nThe issue was with: Bluetooth: BAP: Shell: Fix issue with stopping broadcast sink\n\nWhen the broadcast sink is stopped, the sink was also\nset to NULL via\n\ndefault_broadcast_sink.bap_sink = NULL;\n\nHowever the lifetime of the broadcast sink does not\nfollow the state of the streams, and it still exists\nafterwards. The broadcast sink can only be terminated\n(deleted) via the term_broadcast_sink command."
},{
  "instruction": "There is an issue in the following code. It relates to tests/flash: Fix nrf52840dk configurations\n\nThe commit disables QSPI in SoC configurations, as QSPI got enabled\nby default and test never really run on SoC.\n\nIn QSPI configuration erase page size is set to 4096\nThere is not TC_PRINT showing name of device that the test will\nrun on, in test setup.\n\nThe nrf52840dk configuration files have been renamed to reflect\ndk name and SoC. Please fix this issue.",
  "input": "Faulty tokenized code:\nsimilarity index 67%\nrename from tests/drivers/flash/common/boards/nrf52840_flash_qspi.conf\nrename to tests/drivers/flash/common/boards/nrf52840dk_nrf52840_qspi_nor.conf\n# Minimal configuration for testing flash driver\n# on nrf52840dk/nrf52840 board\n\nCONFIG_NORDIC_QSPI_NOR=y\nsimilarity index 81%\nrename from tests/drivers/flash/common/boards/nrf52840_flash_soc.conf\nrename to tests/drivers/flash/common/boards/nrf52840dk_nrf52840_soc.conf\n# Minimal configuration for testing flash driver\n# on nrf52840dk/nrf52840 board\n\nCONFIG_MPU_ALLOW_FLASH_WRITE=y\nparameter_list|)\nblock|{\nname|int\nname|rc\ndecl_stmt|;\nname|zassert_true\nargument_list|(\nname|device_is_ready\nargument_list|(\nname|flash_dev\n    - drivers\n    - flash\ntests:\n  drivers.flash.common.nrf_qspi_nor:\n    platform_allow: nrf52840dk/nrf52840\n   extra_args: OVERLAY_CONFIG=boards/nrf52840_flash_qspi.conf\n    integration_platforms:\n      - nrf52840dk/nrf52840\n  drivers.flash.common.nrf_qspi_nor.size_in_bytes:\n    platform_allow: nrf52840dk/nrf52840\n    extra_args:\n     - OVERLAY_CONFIG=boards/nrf52840_flash_qspi.conf\n      - DTC_OVERLAY_FILE=boards/nrf52840_size_in_bytes.overlay\n    integration_platforms:\n      - nrf52840dk/nrf52840\n  drivers.flash.common.nrf_qspi_nor_4B_addr:\n    platform_allow: nrf52840dk/nrf52840\n    extra_args:\n     - OVERLAY_CONFIG=boards/nrf52840_flash_qspi.conf\n      - DTC_OVERLAY_FILE=boards/nrf52840dk_mx25l51245g.overlay\n    harness_config:\n      fixture: external_flash_mx25l51245g\n    integration_platforms:\n      - nrf52840dk/nrf52840\n  drivers.flash.common.soc_flash_nrf:\n    platform_allow: nrf52840dk/nrf52840\n   extra_args: OVERLAY_CONFIG=boards/nrf52840_flash_soc.conf\n    integration_platforms:\n      - nrf52840dk/nrf52840\n  drivers.flash.common.default:\n    filter: ((CONFIG_FLASH_HAS_DRIVER_ENABLED and not CONFIG_TRUSTED_EXECUTION_NONSECURE)\n      and dt_label_with_parent_compat_enabled(\"storage_partition\", \"fixed-partitions\"))",
  "result": "I corrected the issue in the code by changing the following tokens:\n+CONFIG_NORDIC_QSPI_NOR_FLASH_LAYOUT_PAGE_SIZE=4096\n+CONFIG_NORDIC_QSPI_NOR=n\n+name|TC_PRINT\n+argument_list|(\n+literal|\"Test will run on device %s\\n\"\n+argument_list|,\n+name|flash_dev\n+operator|->\n+name|name\n+argument_list|)\n+expr_stmt|;\n-    extra_args: OVERLAY_CONFIG=boards/nrf52840_flash_qspi.conf\n+    extra_args: OVERLAY_CONFIG=boards/nrf52840dk_nrf52840_qspi_nor.conf\n-      - OVERLAY_CONFIG=boards/nrf52840_flash_qspi.conf\n+      - OVERLAY_CONFIG=boards/nrf52840dk_nrf52840_qspi_nor.conf\n-      - OVERLAY_CONFIG=boards/nrf52840_flash_qspi.conf\n+      - OVERLAY_CONFIG=boards/nrf52840dk_nrf52840_qspi_nor.conf\n-    extra_args: OVERLAY_CONFIG=boards/nrf52840_flash_soc.conf\n+    extra_args: OVERLAY_CONFIG=boards/nrf52840dk_nrf52840_soc.conf\nThe issue was with: tests/flash: Fix nrf52840dk configurations\n\nThe commit disables QSPI in SoC configurations, as QSPI got enabled\nby default and test never really run on SoC.\n\nIn QSPI configuration erase page size is set to 4096\nThere is not TC_PRINT showing name of device that the test will\nrun on, in test setup.\n\nThe nrf52840dk configuration files have been renamed to reflect\ndk name and SoC."
},{
  "instruction": "There is an issue in the following code. It relates to soc: nordic: nrf54l: Remove redundant option\n\nThe option SOC_NRF54L_GLITCHDET_WORKAROUND is not\nneeded anymore becuase the glitch detector is already\ndisabled in the Nordic MDK in the hal_nordic repo.\n\nFile path in hal_nordic:\nnrfx/mdk/system_nrf54l.c Please fix this issue.",
  "input": "Faulty tokenized code:\n\t  To enable, an inductor must be connected to the DC/DC converter pin.\n\nconfig SOC_NRF54L_NORMAL_VOLTAGE_MODE\n\tbool \"NRF54L Normal Voltage Mode.\"\n\nconfig SOC_NRF54L_GLITCHDET_WORKAROUND\n\tbool \"Workaround that disables glitch detector\"\n\tdefault y\n\thelp\n\t  Temporary workaround - disabling glitch detector to limit power consumption.\n\nif NRF_GRTC_TIMER\n\nconfig ELV_GRTC_LFXO_ALLOWED\n\tbool\n\tdepends on NRF_GRTC_SLEEP_ALLOWED\nexpr_stmt|;\ncomment|/* Enable ICACHE */\nname|sys_cache_instr_enable\nargument_list|()\nexpr_stmt|;\nif|if\ncondition|(\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_SOC_NRF54L_GLITCHDET_WORKAROUND\nargument_list|)\ncondition|)\nblock|{\nname|nrf_glitchdet_enable_set\nargument_list|(\nname|NRF_GLITCHDET\nargument_list|,\nname|false\nargument_list|)\nexpr_stmt|;\nblock|}\nif|#\ndirective|if\nname|DT_ENUM_HAS_VALUE\nargument_list|(\nname|LFXO_NODE",
  "result": "I corrected the issue in the code by changing the following tokens:\n-config SOC_NRF54L_GLITCHDET_WORKAROUND\n-\tbool \"Workaround that disables glitch detector\"\n-\tdefault y\n-\thelp\n-\t  Temporary workaround - disabling glitch detector to limit power consumption.\n-\n-if|if\n-condition|(\n-name|IS_ENABLED\n-argument_list|(\n-name|CONFIG_SOC_NRF54L_GLITCHDET_WORKAROUND\n-argument_list|)\n-condition|)\n-block|{\n-name|nrf_glitchdet_enable_set\n-argument_list|(\n-name|NRF_GLITCHDET\n-argument_list|,\n-name|false\n-argument_list|)\n-expr_stmt|;\n-block|}\nThe issue was with: soc: nordic: nrf54l: Remove redundant option\n\nThe option SOC_NRF54L_GLITCHDET_WORKAROUND is not\nneeded anymore becuase the glitch detector is already\ndisabled in the Nordic MDK in the hal_nordic repo.\n\nFile path in hal_nordic:\nnrfx/mdk/system_nrf54l.c"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: ams_as5600: Fix calculation of fractional part\n\nThe original calculation has two bugs. One is the calculated value, and the\nother is that the value is not in one-millionth parts.\n\nWhat the original calculation does is compute a scaled position value by\nmultiplying the raw sensor value (`dev_data->position`) by\n`AS5600_FULL_ANGLE`, which represents a full rotation in degrees. It then\nsubtracts the product of the whole number of pulses (`val->val1`) and\n`AS5600_PULSES_PER_REV` from this scaled position value.\n\n    ((int32_t)dev_data->position * AS5600_FULL_ANGLE)\n    - (val->val1 * AS5600_PULSES_PER_REV);\n\nWhat you actually need is to extract the fractional part of the value by\ntaking the modulo of AS5600_PULSES_PER_REV from the scaled value of the\nposition.\n\n   (((int32_t)dev_data->position * AS5600_FULL_ANGLE)\n   % AS5600_PULSES_PER_REV)\n\nThen convert the value to one-millionth part.\n\n   * (AS5600_MILLION_UNIT / AS5600_PULSES_PER_REV); Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|AS5600_PULSES_PER_REV\nvalue|4096\nend_define\n\nbegin_struct\nDECL|struct|as5600_dev_cfg\nstruct|struct\nname|as5600_dev_cfg\nblock|{\noperator|->\nname|val2\noperator|=\noperator|(\noperator|(\nname|int32_t\noperator|)\nname|dev_data\noperator|->\nname|position\noperator|*\nname|AS5600_FULL_ANGLE\noperator|)\noperator|-\noperator|(\nname|val\noperator|->\nname|val1\noperator|*\nname|AS5600_PULSES_PER_REV\noperator|)\nexpr_stmt|;\nblock|}\nelse|else",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_define\n+DECL|macro|AS5600_MILLION_UNIT\n+define|#\n+directive|define\n+name|AS5600_MILLION_UNIT\n+value|1000000\n+end_define\n+\n+operator|(\n-operator|-\n-operator|(\n-name|val\n-operator|->\n-name|val1\n+operator|%\n+name|AS5600_PULSES_PER_REV\n+operator|)\n+operator|(\n+name|AS5600_MILLION_UNIT\n+operator|/\nThe issue was with: drivers: sensor: ams_as5600: Fix calculation of fractional part\n\nThe original calculation has two bugs. One is the calculated value, and the\nother is that the value is not in one-millionth parts.\n\nWhat the original calculation does is compute a scaled position value by\nmultiplying the raw sensor value (`dev_data->position`) by\n`AS5600_FULL_ANGLE`, which represents a full rotation in degrees. It then\nsubtracts the product of the whole number of pulses (`val->val1`) and\n`AS5600_PULSES_PER_REV` from this scaled position value.\n\n    ((int32_t)dev_data->position * AS5600_FULL_ANGLE)\n    - (val->val1 * AS5600_PULSES_PER_REV);\n\nWhat you actually need is to extract the fractional part of the value by\ntaking the modulo of AS5600_PULSES_PER_REV from the scaled value of the\nposition.\n\n   (((int32_t)dev_data->position * AS5600_FULL_ANGLE)\n   % AS5600_PULSES_PER_REV)\n\nThen convert the value to one-millionth part.\n\n   * (AS5600_MILLION_UNIT / AS5600_PULSES_PER_REV);"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: mbox: fix build failures when userspace enabled\n\nFix build failures due to using wrong arguments when\ncalling the implementation functions Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|z_impl_mbox_send\nargument_list|(\nname|channel\nargument_list|,\nname|msg\nargument_list|)\nreturn|;\nblock|}\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|z_impl_mbox_set_enabled\nargument_list|(\nname|channel_id\nargument_list|,\nname|enabled\nargument_list|)\nreturn|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|channel\n+name|dev\n+argument_list|,\n+name|channel_id\n+name|dev\n+argument_list|,\nThe issue was with: drivers: mbox: fix build failures when userspace enabled\n\nFix build failures due to using wrong arguments when\ncalling the implementation functions"
},{
  "instruction": "There is an issue in the following code. It relates to driver: uart: esp32: get port number from reg address\n\nESP32 uart driver requires uart port number to its low level calls.\n\nIn case uart0 is disabled and uart1 is enabled, driver will set\ndefault port num to 0 when it should be 1. This fixes this scenario\nby retrieving uart pot number based on periphral address.\n\nFixes #69973 Please fix this issue.",
  "input": "Faulty tokenized code:\ndecl_stmt|;\nDECL|member|rx_dma_channel\nname|uint8_t\nname|rx_dma_channel\ndecl_stmt|;\nDECL|member|uart_id\nname|bool\nname|uart_id\ndecl_stmt|;\nendif|#\ndirective|endif\nblock|}\nstruct|;\nend_struct\nargument_list|(\nname|data\noperator|->\nname|uhci_dev\nargument_list|,\nname|config\noperator|->\nname|uart_id\nargument_list|)\nexpr_stmt|;\nname|data\noperator|->\nname|uart_dev\nname|ESP_UART_DMA_INIT\nparameter_list|(\nname|n\nparameter_list|)\ndefine|\\\nvalue|.dma_dev = ESP32_DT_INST_DMA_CTLR(n, tx),                                                  \\ \t.tx_dma_channel = ESP32_DT_INST_DMA_CELL(n, tx, channel),                                  \\ \t.rx_dma_channel = ESP32_DT_INST_DMA_CELL(n, rx, channel),                                  \\ \t.uart_id = (DEVICE_DT_GET(DT_NODELABEL(uart0)) != DEVICE_DT_INST_GET(n)),\nend_define\n\nbegin_define\nDECL|macro|ESP_UART_UHCI_INIT (n)\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|member|uart_id\n-name|bool\n-name|uart_id\n-decl_stmt|;\n-name|config\n+name|uart_hal_get_port_num\n+argument_list|(\n+operator|&\n+name|data\n-name|uart_id\n+name|hal\n+argument_list|)\n-value|.dma_dev = ESP32_DT_INST_DMA_CTLR(n, tx),                                                  \\ \t.tx_dma_channel = ESP32_DT_INST_DMA_CELL(n, tx, channel),                                  \\ \t.rx_dma_channel = ESP32_DT_INST_DMA_CELL(n, rx, channel),                                  \\ \t.uart_id = (DEVICE_DT_GET(DT_NODELABEL(uart0)) != DEVICE_DT_INST_GET(n)),\n+value|.dma_dev = ESP32_DT_INST_DMA_CTLR(n, tx),                                                  \\ \t.tx_dma_channel = ESP32_DT_INST_DMA_CELL(n, tx, channel),                                  \\ \t.rx_dma_channel = ESP32_DT_INST_DMA_CELL(n, rx, channel)\nThe issue was with: driver: uart: esp32: get port number from reg address\n\nESP32 uart driver requires uart port number to its low level calls.\n\nIn case uart0 is disabled and uart1 is enabled, driver will set\ndefault port num to 0 when it should be 1. This fixes this scenario\nby retrieving uart pot number based on periphral address.\n\nFixes #69973"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: BAP: Shell: Add missing err check for bt_bap_ep_get_info\n\nTwo places we did not have an error check from calling\nbt_bap_ep_get_info before accessing the result. These\nhave simply been added (without an else), as they are\n(very) unlikely to fail.\n\nThis was caught by coverity and thus fixes those\ncoverity issues. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nname|struct\nname|bt_bap_ep_info\nname|ep_info\ndecl_stmt|;\nname|bt_bap_ep_get_info\nargument_list|(\nname|bap_stream\noperator|->\nname|ep\nname|ep_info\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|ep_info\noperator|.\nname|state\noperator|!=\nname|BT_BAP_EP_STATE_CODEC_CONFIGURED\nblock|{\nname|struct\nname|bt_bap_ep_info\nname|info\ndecl_stmt|;\nname|bt_bap_ep_get_info\nargument_list|(\nname|ep\nargument_list|,\noperator|&\nname|info\nargument_list|)\nexpr_stmt|;\nname|printk\nargument_list|(\nliteral|\"ASE info: id %u state %u dir %u\\n\"\nargument_list|,\nname|info\noperator|.\nname|dir\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|cmd_print_ase_info (const struct shell * sh,size_t argc,char * argv[])\nspecifier|static",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|int\n+name|err\n+decl_stmt|;\n+name|err\n+operator|=\n+name|err\n+operator|==\n+literal|0\n+operator|&&\n+name|int\n+name|err\n+decl_stmt|;\n+name|err\n+operator|=\n+if|if\n+condition|(\n+name|err\n+operator|==\n+literal|0\n+condition|)\n+block|{\n+block|}\nThe issue was with: Bluetooth: BAP: Shell: Add missing err check for bt_bap_ep_get_info\n\nTwo places we did not have an error check from calling\nbt_bap_ep_get_info before accessing the result. These\nhave simply been added (without an else), as they are\n(very) unlikely to fail.\n\nThis was caught by coverity and thus fixes those\ncoverity issues."
},{
  "instruction": "There is an issue in the following code. It relates to log: net: Depend on full featured libc instead of just newlibc\n\nFor time printout, depend on full featured libc like picolibc\ninstead of just newlibc. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_NEWLIB_LIBC\nargument_list|)\nname|char\nname|time_str\nindex|[\nsizeof|sizeof",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_NEWLIB_LIBC\n+name|CONFIG_REQUIRES_FULL_LIBC\nThe issue was with: log: net: Depend on full featured libc instead of just newlibc\n\nFor time printout, depend on full featured libc like picolibc\ninstead of just newlibc."
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: can: timing: report unsupported bitrates\n\nEnable testing of all bitrates for all drivers and report which bitrates\nare not supported by the CAN controller under test. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|can_timing_tests\nindex|[]\ninit|=\nblock|{\ncomment|/** Standard bitrates. */\nifndef|#\ndirective|ifndef\nname|CONFIG_CAN_ESP32_TWAI\ncomment|/* ESP32 TWAI does not support bitrates below 25kbit/s */\nblock|{\nliteral|20000\nblock|,\nliteral|875\nblock|,\nname|false\nblock|}\nblock|,\nendif|#\ndirective|endif\ncomment|/* CONFIG_CAN_ESP32_TWAI */\nblock|{\nliteral|50000\nblock|,\nliteral|875\nblock|,\nargument_list|(\nliteral|\"OK\\n\"\nargument_list|)\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\nname|zassert_true\nargument_list|(\nname|sp_err",
  "result": "I corrected the issue in the code by changing the following tokens:\n-ifndef|#\n-directive|ifndef\n-name|CONFIG_CAN_ESP32_TWAI\n-comment|/* ESP32 TWAI does not support bitrates below 25kbit/s */\n-endif|#\n-directive|endif\n-comment|/* CONFIG_CAN_ESP32_TWAI */\n+if|else if\n+condition|(\n+name|sp_err\n+operator|==\n+operator|-\n+name|ENOTSUP\n+condition|)\n+block|{\n+name|printk\n+argument_list|(\n+literal|\"bitrate not supported\\n\"\n+argument_list|)\n+expr_stmt|;\n+block|}\nThe issue was with: tests: drivers: can: timing: report unsupported bitrates\n\nEnable testing of all bitrates for all drivers and report which bitrates\nare not supported by the CAN controller under test."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: can: sja1000: allow front-ends to specify minimum bitrate\n\nAllow frontend drivers based on the SJA1000 backend to specify a minimum\nsupported bitrate.\n\nThe ESP32 TWAI supports bitrates from 25kbit/s to 1Mbit/s. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|CAN_ESP32_TWAI_INIT\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|PINCTRL_DT_INST_DEFINE(inst);                                                              \\                                                                                                    \\ \tstatic const struct can_esp32_twai_config can_esp32_twai_config_##inst = {                 \\ \t\t.base = DT_INST_REG_ADDR(inst),                                                    \\ \t\t.clock_dev = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(inst)),                             \\ \t\t.clock_subsys = (clock_control_subsys_t)DT_INST_CLOCKS_CELL(inst, offset),         \\ \t\t.pcfg = PINCTRL_DT_INST_DEV_CONFIG_GET(inst),                                      \\ \t\t.irq_source = DT_INST_IRQN(inst),                                                  \\ \t\tTWAI_CDR32_INIT(inst)                                                              \\ \t};                                                                                         \\ \tCAN_ESP32_TWAI_ASSERT_CLKOUT_DIVIDER(inst);                                                \\ \tstatic const struct can_sja1000_config can_sja1000_config_##inst =                         \\ \t\tCAN_SJA1000_DT_CONFIG_INST_GET(inst,&can_esp32_twai_config_##inst,                \\ \t\t\t\t\tcan_esp32_twai_read_reg, can_esp32_twai_write_reg,         \\ \t\t\t\t\tCAN_SJA1000_OCR_OCMODE_BIPHASE,                            \\ \t\t\t\t\tCOND_CODE_0(IS_ENABLED(CONFIG_SOC_SERIES_ESP32), (0),      \\ \t\t\t\t\t(CAN_ESP32_TWAI_DT_CDR_INST_GET(inst))));                  \\                                                                                                    \\ \tstatic struct can_sja1000_data can_sja1000_data_##inst =                                   \\ \t\tCAN_SJA1000_DATA_INITIALIZER(NULL);                                                \\                                                                                                    \\ \tCAN_DEVICE_DT_INST_DEFINE(inst, can_esp32_twai_init, NULL,&can_sja1000_data_##inst,       \\&can_sja1000_config_##inst, POST_KERNEL,                         \\ \t\t\t\t  CONFIG_CAN_INIT_PRIORITY,&can_esp32_twai_driver_api);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(\nname|CAN_KVASER_PCI_INIT\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|static void can_kvaser_pci_config_func_##inst(const struct device *dev);                   \\ \tDEVICE_PCIE_INST_DECLARE(inst);                                                            \\                                                                                                    \\ \tstatic const struct can_kvaser_pci_config can_kvaser_pci_config_##inst = {                 \\ \t\tDEVICE_PCIE_INST_INIT(inst, pcie),                                                 \\ \t\t.irq_config_func = can_kvaser_pci_config_func_##inst                               \\ \t};                                                                                         \\                                                                                                    \\ \tstatic const struct can_sja1000_config can_sja1000_config_##inst =                         \\ \t\tCAN_SJA1000_DT_CONFIG_INST_GET(inst,&can_kvaser_pci_config_##inst,                \\ \t\t\t\t\t       can_kvaser_pci_read_reg, can_kvaser_pci_write_reg,  \\ \t\t\t\t\t       CAN_KVASER_PCI_OCR, CAN_KVASER_PCI_CDR);            \\                                                                                                    \\ \tstatic struct can_kvaser_pci_data can_kvaser_pci_data_##inst;                              \\                                                                                                    \\ \tstatic struct can_sja1000_data can_sja1000_data_##inst =                                   \\ \t\tCAN_SJA1000_DATA_INITIALIZER(&can_kvaser_pci_data_##inst);                         \\                                                                                                    \\ \tCAN_DEVICE_DT_INST_DEFINE(inst, can_kvaser_pci_init, NULL,&can_sja1000_data_##inst,       \\&can_sja1000_config_##inst, POST_KERNEL,                         \\ \t\t\t\t  CONFIG_CAN_INIT_PRIORITY,&can_kvaser_pci_driver_api);           \\                                                                                                    \\ \tstatic void can_kvaser_pci_config_func_##inst(const struct device *dev)                    \\ \t{                                                                                          \\ \t\tIRQ_CONNECT(DT_INST_IRQN(inst), DT_INST_IRQ(inst, priority), can_sja1000_isr,      \\ \t\t\t    DEVICE_DT_INST_GET(inst), DT_INST_IRQ(inst, sense));                   \\ \t\tirq_enable(DT_INST_IRQN(inst));                                                    \\ \t}\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(\nblock|}\nstruct|;\nend_struct\n\nbegin_comment\ncomment|/**  * @brief Static initializer for @p can_sja1000_config struct  *  * @param node_id Devicetree node identifier  * @param _custom Pointer to custom driver frontend configuration structure  * @param _read_reg Driver frontend SJA100 register read function  * @param _write_reg Driver frontend SJA100 register write function  * @param _ocr Initial SJA1000 Output Control Register (OCR) value  * @param _cdr Initial SJA1000 Clock Divider Register (CDR) value  */\nend_comment\n\nbegin_define\nDECL|macro|CAN_SJA1000_DT_CONFIG_GET (node_id,_custom,_read_reg,_write_reg,_ocr,_cdr)\ndefine|#\ndirective|define\nname|CAN_SJA1000_DT_CONFIG_GET\nparameter_list|(\nname|node_id\nname|_write_reg\nparameter_list|,\nname|_ocr\nparameter_list|,\nname|_cdr\nparameter_list|)\ndefine|\\\nvalue|{                                                                                          \\ \t\t.common = CAN_DT_DRIVER_CONFIG_GET(node_id, 0, 1000000),                           \\ \t\t.read_reg = _read_reg,                                                             \\ \t\t.write_reg = _write_reg,                                                           \\ \t\t.ocr = _ocr,                                                                       \\ \t\t.cdr = _cdr,                                                                       \\ \t\t.custom = _custom,                                                                 \\ \t}\nend_define\n\nbegin_comment\ncomment|/**  * @brief Static initializer for @p can_sja1000_config struct from a DT_DRV_COMPAT instance  *  * @param inst DT_DRV_COMPAT instance number  * @param _custom Pointer to custom driver frontend configuration structure  * @param _read_reg Driver frontend SJA100 register read function  * @param _write_reg Driver frontend SJA100 register write function  * @param _ocr Initial SJA1000 Output Control Register (OCR) value  * @param _cdr Initial SJA1000 Clock Divider Register (CDR) value  * @see CAN_SJA1000_DT_CONFIG_GET()  */\nend_comment\n\nbegin_define\nDECL|macro|CAN_SJA1000_DT_CONFIG_INST_GET (inst,_custom,_read_reg,_write_reg,_ocr,_cdr)\ndefine|#\ndirective|define\nname|CAN_SJA1000_DT_CONFIG_INST_GET\nparameter_list|(\nname|inst\nname|_write_reg\nparameter_list|,\nname|_ocr\nparameter_list|,\nname|_cdr\nparameter_list|)\ndefine|\\\nvalue|CAN_SJA1000_DT_CONFIG_GET(DT_DRV_INST(inst), _custom, _read_reg, _write_reg, _ocr, _cdr)\nend_define\n\nbegin_comment\ncomment|/**  * @brief SJA1000 driver internal RX filter structure.  */\nend_comment",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|PINCTRL_DT_INST_DEFINE(inst);                                                              \\                                                                                                    \\ \tstatic const struct can_esp32_twai_config can_esp32_twai_config_##inst = {                 \\ \t\t.base = DT_INST_REG_ADDR(inst),                                                    \\ \t\t.clock_dev = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(inst)),                             \\ \t\t.clock_subsys = (clock_control_subsys_t)DT_INST_CLOCKS_CELL(inst, offset),         \\ \t\t.pcfg = PINCTRL_DT_INST_DEV_CONFIG_GET(inst),                                      \\ \t\t.irq_source = DT_INST_IRQN(inst),                                                  \\ \t\tTWAI_CDR32_INIT(inst)                                                              \\ \t};                                                                                         \\ \tCAN_ESP32_TWAI_ASSERT_CLKOUT_DIVIDER(inst);                                                \\ \tstatic const struct can_sja1000_config can_sja1000_config_##inst =                         \\ \t\tCAN_SJA1000_DT_CONFIG_INST_GET(inst,&can_esp32_twai_config_##inst,                \\ \t\t\t\t\tcan_esp32_twai_read_reg, can_esp32_twai_write_reg,         \\ \t\t\t\t\tCAN_SJA1000_OCR_OCMODE_BIPHASE,                            \\ \t\t\t\t\tCOND_CODE_0(IS_ENABLED(CONFIG_SOC_SERIES_ESP32), (0),      \\ \t\t\t\t\t(CAN_ESP32_TWAI_DT_CDR_INST_GET(inst))));                  \\                                                                                                    \\ \tstatic struct can_sja1000_data can_sja1000_data_##inst =                                   \\ \t\tCAN_SJA1000_DATA_INITIALIZER(NULL);                                                \\                                                                                                    \\ \tCAN_DEVICE_DT_INST_DEFINE(inst, can_esp32_twai_init, NULL,&can_sja1000_data_##inst,       \\&can_sja1000_config_##inst, POST_KERNEL,                         \\ \t\t\t\t  CONFIG_CAN_INIT_PRIORITY,&can_esp32_twai_driver_api);\n+value|PINCTRL_DT_INST_DEFINE(inst);                                                              \\                                                                                                    \\ \tstatic const struct can_esp32_twai_config can_esp32_twai_config_##inst = {                 \\ \t\t.base = DT_INST_REG_ADDR(inst),                                                    \\ \t\t.clock_dev = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(inst)),                             \\ \t\t.clock_subsys = (clock_control_subsys_t)DT_INST_CLOCKS_CELL(inst, offset),         \\ \t\t.pcfg = PINCTRL_DT_INST_DEV_CONFIG_GET(inst),                                      \\ \t\t.irq_source = DT_INST_IRQN(inst),                                                  \\ \t\tTWAI_CDR32_INIT(inst)                                                              \\ \t};                                                                                         \\ \tCAN_ESP32_TWAI_ASSERT_CLKOUT_DIVIDER(inst);                                                \\ \tstatic const struct can_sja1000_config can_sja1000_config_##inst =                         \\ \t\tCAN_SJA1000_DT_CONFIG_INST_GET(inst,&can_esp32_twai_config_##inst,                \\ \t\t\t\t\tcan_esp32_twai_read_reg, can_esp32_twai_write_reg,         \\ \t\t\t\t\tCAN_SJA1000_OCR_OCMODE_BIPHASE,                            \\ \t\t\t\t\tCOND_CODE_0(IS_ENABLED(CONFIG_SOC_SERIES_ESP32), (0),      \\ \t\t\t\t\t(CAN_ESP32_TWAI_DT_CDR_INST_GET(inst))), 25000);           \\                                                                                                    \\ \tstatic struct can_sja1000_data can_sja1000_data_##inst =                                   \\ \t\tCAN_SJA1000_DATA_INITIALIZER(NULL);                                                \\                                                                                                    \\ \tCAN_DEVICE_DT_INST_DEFINE(inst, can_esp32_twai_init, NULL,&can_sja1000_data_##inst,       \\&can_sja1000_config_##inst, POST_KERNEL,                         \\ \t\t\t\t  CONFIG_CAN_INIT_PRIORITY,&can_esp32_twai_driver_api);\n-value|static void can_kvaser_pci_config_func_##inst(const struct device *dev);                   \\ \tDEVICE_PCIE_INST_DECLARE(inst);                                                            \\                                                                                                    \\ \tstatic const struct can_kvaser_pci_config can_kvaser_pci_config_##inst = {                 \\ \t\tDEVICE_PCIE_INST_INIT(inst, pcie),                                                 \\ \t\t.irq_config_func = can_kvaser_pci_config_func_##inst                               \\ \t};                                                                                         \\                                                                                                    \\ \tstatic const struct can_sja1000_config can_sja1000_config_##inst =                         \\ \t\tCAN_SJA1000_DT_CONFIG_INST_GET(inst,&can_kvaser_pci_config_##inst,                \\ \t\t\t\t\t       can_kvaser_pci_read_reg, can_kvaser_pci_write_reg,  \\ \t\t\t\t\t       CAN_KVASER_PCI_OCR, CAN_KVASER_PCI_CDR);            \\                                                                                                    \\ \tstatic struct can_kvaser_pci_data can_kvaser_pci_data_##inst;                              \\                                                                                                    \\ \tstatic struct can_sja1000_data can_sja1000_data_##inst =                                   \\ \t\tCAN_SJA1000_DATA_INITIALIZER(&can_kvaser_pci_data_##inst);                         \\                                                                                                    \\ \tCAN_DEVICE_DT_INST_DEFINE(inst, can_kvaser_pci_init, NULL,&can_sja1000_data_##inst,       \\&can_sja1000_config_##inst, POST_KERNEL,                         \\ \t\t\t\t  CONFIG_CAN_INIT_PRIORITY,&can_kvaser_pci_driver_api);           \\                                                                                                    \\ \tstatic void can_kvaser_pci_config_func_##inst(const struct device *dev)                    \\ \t{                                                                                          \\ \t\tIRQ_CONNECT(DT_INST_IRQN(inst), DT_INST_IRQ(inst, priority), can_sja1000_isr,      \\ \t\t\t    DEVICE_DT_INST_GET(inst), DT_INST_IRQ(inst, sense));                   \\ \t\tirq_enable(DT_INST_IRQN(inst));                                                    \\ \t}\n+value|static void can_kvaser_pci_config_func_##inst(const struct device *dev);                   \\ \tDEVICE_PCIE_INST_DECLARE(inst);                                                            \\                                                                                                    \\ \tstatic const struct can_kvaser_pci_config can_kvaser_pci_config_##inst = {                 \\ \t\tDEVICE_PCIE_INST_INIT(inst, pcie),                                                 \\ \t\t.irq_config_func = can_kvaser_pci_config_func_##inst                               \\ \t};                                                                                         \\                                                                                                    \\ \tstatic const struct can_sja1000_config can_sja1000_config_##inst =                         \\ \t\tCAN_SJA1000_DT_CONFIG_INST_GET(inst,&can_kvaser_pci_config_##inst,                \\ \t\t\t\t\t       can_kvaser_pci_read_reg, can_kvaser_pci_write_reg,  \\ \t\t\t\t\t       CAN_KVASER_PCI_OCR, CAN_KVASER_PCI_CDR, 0);         \\                                                                                                    \\ \tstatic struct can_kvaser_pci_data can_kvaser_pci_data_##inst;                              \\                                                                                                    \\ \tstatic struct can_sja1000_data can_sja1000_data_##inst =                                   \\ \t\tCAN_SJA1000_DATA_INITIALIZER(&can_kvaser_pci_data_##inst);                         \\                                                                                                    \\ \tCAN_DEVICE_DT_INST_DEFINE(inst, can_kvaser_pci_init, NULL,&can_sja1000_data_##inst,       \\&can_sja1000_config_##inst, POST_KERNEL,                         \\ \t\t\t\t  CONFIG_CAN_INIT_PRIORITY,&can_kvaser_pci_driver_api);           \\                                                                                                    \\ \tstatic void can_kvaser_pci_config_func_##inst(const struct device *dev)                    \\ \t{                                                                                          \\ \t\tIRQ_CONNECT(DT_INST_IRQN(inst), DT_INST_IRQ(inst, priority), can_sja1000_isr,      \\ \t\t\t    DEVICE_DT_INST_GET(inst), DT_INST_IRQ(inst, sense));                   \\ \t\tirq_enable(DT_INST_IRQN(inst));                                                    \\ \t}\n-comment|/**  * @brief Static initializer for @p can_sja1000_config struct  *  * @param node_id Devicetree node identifier  * @param _custom Pointer to custom driver frontend configuration structure  * @param _read_reg Driver frontend SJA100 register read function  * @param _write_reg Driver frontend SJA100 register write function  * @param _ocr Initial SJA1000 Output Control Register (OCR) value  * @param _cdr Initial SJA1000 Clock Divider Register (CDR) value  */\n+comment|/**  * @brief Static initializer for @p can_sja1000_config struct  *  * @param node_id Devicetree node identifier  * @param _custom Pointer to custom driver frontend configuration structure  * @param _read_reg Driver frontend SJA100 register read function  * @param _write_reg Driver frontend SJA100 register write function  * @param _ocr Initial SJA1000 Output Control Register (OCR) value  * @param _cdr Initial SJA1000 Clock Divider Register (CDR) value  * @param _min_bitrate minimum bitrate supported by the CAN controller  */\n-DECL|macro|CAN_SJA1000_DT_CONFIG_GET (node_id,_custom,_read_reg,_write_reg,_ocr,_cdr)\n+DECL|macro|CAN_SJA1000_DT_CONFIG_GET (node_id,_custom,_read_reg,_write_reg,_ocr,_cdr,_min_bitrate)\n+parameter_list|,             \\\n+name|_min_bitrate\n-value|{                                                                                          \\ \t\t.common = CAN_DT_DRIVER_CONFIG_GET(node_id, 0, 1000000),                           \\ \t\t.read_reg = _read_reg,                                                             \\ \t\t.write_reg = _write_reg,                                                           \\ \t\t.ocr = _ocr,                                                                       \\ \t\t.cdr = _cdr,                                                                       \\ \t\t.custom = _custom,                                                                 \\ \t}\n+value|{                                                                                          \\ \t\t.common = CAN_DT_DRIVER_CONFIG_GET(node_id, _min_bitrate, 1000000),                \\ \t\t.read_reg = _read_reg,                                                             \\ \t\t.write_reg = _write_reg,                                                           \\ \t\t.ocr = _ocr,                                                                       \\ \t\t.cdr = _cdr,                                                                       \\ \t\t.custom = _custom,                                                                 \\ \t}\n-comment|/**  * @brief Static initializer for @p can_sja1000_config struct from a DT_DRV_COMPAT instance  *  * @param inst DT_DRV_COMPAT instance number  * @param _custom Pointer to custom driver frontend configuration structure  * @param _read_reg Driver frontend SJA100 register read function  * @param _write_reg Driver frontend SJA100 register write function  * @param _ocr Initial SJA1000 Output Control Register (OCR) value  * @param _cdr Initial SJA1000 Clock Divider Register (CDR) value  * @see CAN_SJA1000_DT_CONFIG_GET()  */\n+comment|/**  * @brief Static initializer for @p can_sja1000_config struct from a DT_DRV_COMPAT instance  *  * @param inst DT_DRV_COMPAT instance number  * @param _custom Pointer to custom driver frontend configuration structure  * @param _read_reg Driver frontend SJA100 register read function  * @param _write_reg Driver frontend SJA100 register write function  * @param _ocr Initial SJA1000 Output Control Register (OCR) value  * @param _cdr Initial SJA1000 Clock Divider Register (CDR) value  * @param _min_bitrate minimum bitrate supported by the CAN controller  * @see CAN_SJA1000_DT_CONFIG_GET()  */\n-DECL|macro|CAN_SJA1000_DT_CONFIG_INST_GET (inst,_custom,_read_reg,_write_reg,_ocr,_cdr)\n+DECL|macro|CAN_SJA1000_DT_CONFIG_INST_GET (inst,_custom,_read_reg,_write_reg,_ocr,_cdr,_min_bitrate)\n+parameter_list|,           \\\n+name|_min_bitrate\n-value|CAN_SJA1000_DT_CONFIG_GET(DT_DRV_INST(inst), _custom, _read_reg, _write_reg, _ocr, _cdr)\n+value|CAN_SJA1000_DT_CONFIG_GET(DT_DRV_INST(inst), _custom, _read_reg, _write_reg, _ocr, _cdr,   \\ \t\t\t\t  _min_bitrate)\nThe issue was with: drivers: can: sja1000: allow front-ends to specify minimum bitrate\n\nAllow frontend drivers based on the SJA1000 backend to specify a minimum\nsupported bitrate.\n\nThe ESP32 TWAI supports bitrates from 25kbit/s to 1Mbit/s."
},{
  "instruction": "There is an issue in the following code. It relates to net: telnet: Fix spelling in command defines\n\nRename command defines to make checkpatch happy. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nname|cmd\noperator|->\nname|op\noperator|=\nname|NVT_CMD_WONT\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\nname|cmd\ndefault|default:\nname|cmd\noperator|->\nname|op\noperator|=\nname|NVT_CMD_WONT\nexpr_stmt|;\nbreak|break;\nblock|}\nname|telnet_command_send_reply\nargument_list|(\nblock|{\nname|cmd\noperator|->\nname|op\noperator|=\nname|NVT_CMD_WONT\nexpr_stmt|;\nblock|}\nbreak|break;\nblock|}\ndefault|default:\nname|cmd\noperator|->\nname|op\noperator|=\nname|NVT_CMD_WONT\nexpr_stmt|;\nbreak|break;\nblock|}\nname|telnet_command_send_reply\nargument_list|(\nname|cmd\nargument_list|)\nexpr_stmt|;\nbreak|break;\ncase|case\nname|NVT_CMD_DONT\ncase|:\nname|telnet_reply_dont_command\nargument_list|(\nname|cmd\nargument_list|)\noperator|==\nname|NVT_CMD_WILL\noperator|||\nname|op\noperator|==\nname|NVT_CMD_WONT\noperator|||\nname|op\noperator|==\nname|NVT_CMD_DO\noperator|||\nname|op\noperator|==\nname|NVT_CMD_DONT\ncondition|)\nblock|{\nreturn|return\nname|TELNET_WILL_DO_COMMAND_LEN\nreturn|;\nname|NVT_CMD_WILL\nvalue|251\nend_define\n\nbegin_define\nDECL|macro|NVT_CMD_WONT\ndefine|#\ndirective|define\nname|NVT_CMD_WONT\nvalue|252\nend_define\n\nbegin_define\nDECL|macro|NVT_CMD_DO\nname|NVT_CMD_DO\nvalue|253\nend_define\n\nbegin_define\nDECL|macro|NVT_CMD_DONT\ndefine|#\ndirective|define\nname|NVT_CMD_DONT\nvalue|254\nend_define\n\nbegin_define\nDECL|macro|NVT_CMD_IAC",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|NVT_CMD_WONT\n+name|NVT_CMD_WILL_NOT\n-name|NVT_CMD_WONT\n+name|NVT_CMD_WILL_NOT\n-name|NVT_CMD_WONT\n+name|NVT_CMD_WILL_NOT\n-name|NVT_CMD_WONT\n+name|NVT_CMD_WILL_NOT\n-name|NVT_CMD_DONT\n+name|NVT_CMD_DO_NOT\n-name|NVT_CMD_WONT\n+name|NVT_CMD_WILL_NOT\n-name|NVT_CMD_DONT\n+name|NVT_CMD_DO_NOT\n-DECL|macro|NVT_CMD_WONT\n+DECL|macro|NVT_CMD_WILL_NOT\n-name|NVT_CMD_WONT\n+name|NVT_CMD_WILL_NOT\n-DECL|macro|NVT_CMD_DONT\n+DECL|macro|NVT_CMD_DO_NOT\n-name|NVT_CMD_DONT\n+name|NVT_CMD_DO_NOT\nThe issue was with: net: telnet: Fix spelling in command defines\n\nRename command defines to make checkpatch happy."
},{
  "instruction": "There is an issue in the following code. It relates to net: sockets: Stick to NET_SOCKETS_POLL_MAX limit in socket services\n\nSocket service pollfd count should not exceed the configured\nNET_SOCKETS_POLL_MAX limit, as poll() will not be able to monitor\nsockets beyond that limit anyway. Adding +1 there prevented the library\nfrom catching the configuration error. Please fix this issue.",
  "input": "Faulty tokenized code:\nDECL|struct|service\nspecifier|static\nstruct|struct\nname|service\nblock|{\ncomment|/* The +1 is for triggering events from register function */\nDECL|member|events\nname|struct\nname|zsock_pollfd\nname|events\nindex|[\nliteral|1\noperator|+\nname|CONFIG_NET_SOCKETS_POLL_MAX\nindex|]\ndecl_stmt|;\nDECL|member|count\nname|int",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* The +1 is for triggering events from register function */\n-literal|1\n-operator|+\nThe issue was with: net: sockets: Stick to NET_SOCKETS_POLL_MAX limit in socket services\n\nSocket service pollfd count should not exceed the configured\nNET_SOCKETS_POLL_MAX limit, as poll() will not be able to monitor\nsockets beyond that limit anyway. Adding +1 there prevented the library\nfrom catching the configuration error."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: counter: stm32: move reset_dt_spec from data to config\n\nMove 'reset' member, which is const, from driver data to driver config.\nThis allows to reduce flash usage by few bytes. Please fix this issue.",
  "input": "Faulty tokenized code:\ndecl_stmt|;\nDECL|member|freq\nname|uint32_t\nname|freq\ndecl_stmt|;\ncomment|/* Reset controller device configuration */\nDECL|member|reset\nspecifier|const\nname|struct\nname|reset_dt_spec\nname|reset\ndecl_stmt|;\nblock|}\nstruct|;\nend_struct\n\nbegin_struct\nfunction_decl|;\nDECL|member|irqn\nname|uint32_t\nname|irqn\ndecl_stmt|;\nname|LOG_INSTANCE_PTR_DECLARE\nargument_list|(\nname|log\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\noperator|!\nname|device_is_ready\nargument_list|(\nname|data\noperator|->\nname|reset\noperator|.\nname|dev\nargument_list|)\nname|void\noperator|)\nname|reset_line_toggle_dt\nargument_list|(\noperator|&\nname|data\noperator|->\nname|reset\nargument_list|)\nexpr_stmt|;\ncomment|/* config/enable IRQ */\nname|COUNTER_DEVICE_INIT\nparameter_list|(\nname|idx\nparameter_list|)\ndefine|\\\nvalue|BUILD_ASSERT(DT_PROP(TIMER(idx), st_prescaler)<= 0xFFFF,\t\t  \\ \t\t     \"TIMER prescaler out of range\");\t\t\t\t  \\ \tBUILD_ASSERT(NUM_CH(TIM(idx))<= TIMER_MAX_CH,\t\t\t\t  \\ \t\t     \"TIMER too many channels\");\t\t\t\t  \\ \t\t\t\t\t\t\t\t\t\t  \\ \tstatic struct counter_stm32_data counter##idx##_data = {\t\t  \\ \t\t.reset = RESET_DT_SPEC_GET(TIMER(idx)),\t\t\t\t  \\ \t};\t\t\t\t\t\t\t\t\t  \\ \tstatic struct counter_stm32_ch_data counter##idx##_ch_data[TIMER_MAX_CH]; \\ \t\t\t\t\t\t\t\t\t\t  \\ \tstatic void counter_##idx##_stm32_irq_config(const struct device *dev)\t  \\ \t{\t\t\t\t\t\t\t\t\t  \\ \t\tIRQ_CONNECT(DT_IRQN(TIMER(idx)),\t\t\t\t  \\ \t\t\t    DT_IRQ(TIMER(idx), priority),\t\t\t  \\ \t\t\t    counter_stm32_irq_handler,\t\t\t\t  \\ \t\t\t    DEVICE_DT_INST_GET(idx),\t\t\t\t  \\ \t\t\t    0);\t\t\t\t\t\t\t  \\ \t\tirq_enable(DT_IRQN(TIMER(idx)));\t\t\t\t  \\ \t}\t\t\t\t\t\t\t\t\t  \\ \t\t\t\t\t\t\t\t\t\t  \\ \tstatic const struct counter_stm32_config counter##idx##_config = {\t  \\ \t\t.info = {\t\t\t\t\t\t\t  \\ \t\t\t.max_top_value =\t\t\t\t\t  \\ \t\t\t\tIS_TIM_32B_COUNTER_INSTANCE(TIM(idx)) ?\t\t  \\ \t\t\t\t0xFFFFFFFF : 0x0000FFFF,\t\t\t  \\ \t\t\t.flags = COUNTER_CONFIG_INFO_COUNT_UP,\t\t\t  \\ \t\t\t.channels = NUM_CH(TIM(idx)),\t\t\t\t  \\ \t\t},\t\t\t\t\t\t\t\t  \\ \t\t.ch_data = counter##idx##_ch_data,\t\t\t\t  \\ \t\t.timer = TIM(idx),\t\t\t\t\t\t  \\ \t\t.prescaler = DT_PROP(TIMER(idx), st_prescaler),\t\t\t  \\ \t\t.pclken = {\t\t\t\t\t\t\t  \\ \t\t\t.bus = DT_CLOCKS_CELL(TIMER(idx), bus),\t\t\t  \\ \t\t\t.enr = DT_CLOCKS_CELL(TIMER(idx), bits)\t\t\t  \\ \t\t},\t\t\t\t\t\t\t\t  \\ \t\t.irq_config_func = counter_##idx##_stm32_irq_config,\t\t  \\ \t\t.irqn = DT_IRQN(TIMER(idx)),\t\t\t\t\t  \\ \t};\t\t\t\t\t\t\t\t\t  \\ \t\t\t\t\t\t\t\t\t\t  \\ \tDEVICE_DT_INST_DEFINE(idx,\t\t\t\t\t\t  \\ \t\t\t      counter_stm32_init_timer,\t\t\t\t  \\ \t\t\t      NULL,\t\t\t\t\t\t  \\&counter##idx##_data,\t\t\t\t  \\&counter##idx##_config,\t\t\t\t  \\ \t\t\t      PRE_KERNEL_1, CONFIG_COUNTER_INIT_PRIORITY,\t  \\&counter_stm32_driver_api);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* Reset controller device configuration */\n-DECL|member|reset\n-specifier|const\n-name|struct\n-name|reset_dt_spec\n-name|reset\n-decl_stmt|;\n+comment|/* Reset controller device configuration */\n+DECL|member|reset\n+specifier|const\n+name|struct\n+name|reset_dt_spec\n+name|reset\n+decl_stmt|;\n-name|data\n+name|cfg\n-name|data\n+name|cfg\n-value|BUILD_ASSERT(DT_PROP(TIMER(idx), st_prescaler)<= 0xFFFF,\t\t  \\ \t\t     \"TIMER prescaler out of range\");\t\t\t\t  \\ \tBUILD_ASSERT(NUM_CH(TIM(idx))<= TIMER_MAX_CH,\t\t\t\t  \\ \t\t     \"TIMER too many channels\");\t\t\t\t  \\ \t\t\t\t\t\t\t\t\t\t  \\ \tstatic struct counter_stm32_data counter##idx##_data = {\t\t  \\ \t\t.reset = RESET_DT_SPEC_GET(TIMER(idx)),\t\t\t\t  \\ \t};\t\t\t\t\t\t\t\t\t  \\ \tstatic struct counter_stm32_ch_data counter##idx##_ch_data[TIMER_MAX_CH]; \\ \t\t\t\t\t\t\t\t\t\t  \\ \tstatic void counter_##idx##_stm32_irq_config(const struct device *dev)\t  \\ \t{\t\t\t\t\t\t\t\t\t  \\ \t\tIRQ_CONNECT(DT_IRQN(TIMER(idx)),\t\t\t\t  \\ \t\t\t    DT_IRQ(TIMER(idx), priority),\t\t\t  \\ \t\t\t    counter_stm32_irq_handler,\t\t\t\t  \\ \t\t\t    DEVICE_DT_INST_GET(idx),\t\t\t\t  \\ \t\t\t    0);\t\t\t\t\t\t\t  \\ \t\tirq_enable(DT_IRQN(TIMER(idx)));\t\t\t\t  \\ \t}\t\t\t\t\t\t\t\t\t  \\ \t\t\t\t\t\t\t\t\t\t  \\ \tstatic const struct counter_stm32_config counter##idx##_config = {\t  \\ \t\t.info = {\t\t\t\t\t\t\t  \\ \t\t\t.max_top_value =\t\t\t\t\t  \\ \t\t\t\tIS_TIM_32B_COUNTER_INSTANCE(TIM(idx)) ?\t\t  \\ \t\t\t\t0xFFFFFFFF : 0x0000FFFF,\t\t\t  \\ \t\t\t.flags = COUNTER_CONFIG_INFO_COUNT_UP,\t\t\t  \\ \t\t\t.channels = NUM_CH(TIM(idx)),\t\t\t\t  \\ \t\t},\t\t\t\t\t\t\t\t  \\ \t\t.ch_data = counter##idx##_ch_data,\t\t\t\t  \\ \t\t.timer = TIM(idx),\t\t\t\t\t\t  \\ \t\t.prescaler = DT_PROP(TIMER(idx), st_prescaler),\t\t\t  \\ \t\t.pclken = {\t\t\t\t\t\t\t  \\ \t\t\t.bus = DT_CLOCKS_CELL(TIMER(idx), bus),\t\t\t  \\ \t\t\t.enr = DT_CLOCKS_CELL(TIMER(idx), bits)\t\t\t  \\ \t\t},\t\t\t\t\t\t\t\t  \\ \t\t.irq_config_func = counter_##idx##_stm32_irq_config,\t\t  \\ \t\t.irqn = DT_IRQN(TIMER(idx)),\t\t\t\t\t  \\ \t};\t\t\t\t\t\t\t\t\t  \\ \t\t\t\t\t\t\t\t\t\t  \\ \tDEVICE_DT_INST_DEFINE(idx,\t\t\t\t\t\t  \\ \t\t\t      counter_stm32_init_timer,\t\t\t\t  \\ \t\t\t      NULL,\t\t\t\t\t\t  \\&counter##idx##_data,\t\t\t\t  \\&counter##idx##_config,\t\t\t\t  \\ \t\t\t      PRE_KERNEL_1, CONFIG_COUNTER_INIT_PRIORITY,\t  \\&counter_stm32_driver_api);\n+value|BUILD_ASSERT(DT_PROP(TIMER(idx), st_prescaler)<= 0xFFFF,\t\t  \\ \t\t     \"TIMER prescaler out of range\");\t\t\t\t  \\ \tBUILD_ASSERT(NUM_CH(TIM(idx))<= TIMER_MAX_CH,\t\t\t\t  \\ \t\t     \"TIMER too many channels\");\t\t\t\t  \\ \t\t\t\t\t\t\t\t\t\t  \\ \tstatic struct counter_stm32_data counter##idx##_data;\t\t\t  \\ \tstatic struct counter_stm32_ch_data counter##idx##_ch_data[TIMER_MAX_CH]; \\ \t\t\t\t\t\t\t\t\t\t  \\ \tstatic void counter_##idx##_stm32_irq_config(const struct device *dev)\t  \\ \t{\t\t\t\t\t\t\t\t\t  \\ \t\tIRQ_CONNECT(DT_IRQN(TIMER(idx)),\t\t\t\t  \\ \t\t\t    DT_IRQ(TIMER(idx), priority),\t\t\t  \\ \t\t\t    counter_stm32_irq_handler,\t\t\t\t  \\ \t\t\t    DEVICE_DT_INST_GET(idx),\t\t\t\t  \\ \t\t\t    0);\t\t\t\t\t\t\t  \\ \t\tirq_enable(DT_IRQN(TIMER(idx)));\t\t\t\t  \\ \t}\t\t\t\t\t\t\t\t\t  \\ \t\t\t\t\t\t\t\t\t\t  \\ \tstatic const struct counter_stm32_config counter##idx##_config = {\t  \\ \t\t.info = {\t\t\t\t\t\t\t  \\ \t\t\t.max_top_value =\t\t\t\t\t  \\ \t\t\t\tIS_TIM_32B_COUNTER_INSTANCE(TIM(idx)) ?\t\t  \\ \t\t\t\t0xFFFFFFFF : 0x0000FFFF,\t\t\t  \\ \t\t\t.flags = COUNTER_CONFIG_INFO_COUNT_UP,\t\t\t  \\ \t\t\t.channels = NUM_CH(TIM(idx)),\t\t\t\t  \\ \t\t},\t\t\t\t\t\t\t\t  \\ \t\t.ch_data = counter##idx##_ch_data,\t\t\t\t  \\ \t\t.timer = TIM(idx),\t\t\t\t\t\t  \\ \t\t.prescaler = DT_PROP(TIMER(idx), st_prescaler),\t\t\t  \\ \t\t.pclken = {\t\t\t\t\t\t\t  \\ \t\t\t.bus = DT_CLOCKS_CELL(TIMER(idx), bus),\t\t\t  \\ \t\t\t.enr = DT_CLOCKS_CELL(TIMER(idx), bits)\t\t\t  \\ \t\t},\t\t\t\t\t\t\t\t  \\ \t\t.irq_config_func = counter_##idx##_stm32_irq_config,\t\t  \\ \t\t.irqn = DT_IRQN(TIMER(idx)),\t\t\t\t\t  \\ \t\t.reset = RESET_DT_SPEC_GET(TIMER(idx)),\t\t\t\t  \\ \t};\t\t\t\t\t\t\t\t\t  \\ \t\t\t\t\t\t\t\t\t\t  \\ \tDEVICE_DT_INST_DEFINE(idx,\t\t\t\t\t\t  \\ \t\t\t      counter_stm32_init_timer,\t\t\t\t  \\ \t\t\t      NULL,\t\t\t\t\t\t  \\&counter##idx##_data,\t\t\t\t  \\&counter##idx##_config,\t\t\t\t  \\ \t\t\t      PRE_KERNEL_1, CONFIG_COUNTER_INIT_PRIORITY,\t  \\&counter_stm32_driver_api);\nThe issue was with: drivers: counter: stm32: move reset_dt_spec from data to config\n\nMove 'reset' member, which is const, from driver data to driver config.\nThis allows to reduce flash usage by few bytes."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: adc: reset data ready signal for ADS114s0x\n\nReset the data ready signal for a new read operation\nwith a ADS114s0x. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|acquire_signal\nargument_list|,\nname|K_FOREVER\nargument_list|)\nexpr_stmt|;\nname|result\noperator|=\nname|ads114s0x_send_start_read\nargument_list|(\nname|dev",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|k_sem_reset\n+argument_list|(\n+operator|&\n+name|data\n+operator|->\n+name|data_ready_signal\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: adc: reset data ready signal for ADS114s0x\n\nReset the data ready signal for a new read operation\nwith a ADS114s0x."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: dacx0508: fix for multiple DACs of the same type\n\nPresently, this driver cannot handle multiple\nDACs of the same type without throwing a\ncompile error due to a missing line ending.\nThis PR fixes that issue by adding the missing\nline ending. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|n\nparameter_list|,\nname|res\nparameter_list|)\ndefine|\\\nvalue|static struct dacx0508_data dac##t##_data_##n; \\ \tstatic const struct dacx0508_config dac##t##_config_##n = { \\ \t\t.bus = SPI_DT_SPEC_GET(INST_DT_DACX0508(n, t), \\ \t\t\tSPI_OP_MODE_MASTER | SPI_TRANSFER_MSB | \\ \t\t\tSPI_WORD_SET(8) | SPI_MODE_CPHA, 0), \\ \t\t.resolution = res, \\ \t\t.reference = DT_PROP(INST_DT_DACX0508(n, t), \\ \t\t\t\t\t     voltage_reference), \\ \t\t.gain[0] = DT_PROP(INST_DT_DACX0508(n, t), channel0_gain), \\ \t\t.gain[1] = DT_PROP(INST_DT_DACX0508(n, t), channel1_gain), \\ \t\t.gain[2] = DT_PROP(INST_DT_DACX0508(n, t), channel2_gain), \\ \t\t.gain[3] = DT_PROP(INST_DT_DACX0508(n, t), channel3_gain), \\ \t\t.gain[4] = DT_PROP(INST_DT_DACX0508(n, t), channel4_gain), \\ \t\t.gain[5] = DT_PROP(INST_DT_DACX0508(n, t), channel5_gain), \\ \t\t.gain[6] = DT_PROP(INST_DT_DACX0508(n, t), channel6_gain), \\ \t\t.gain[7] = DT_PROP(INST_DT_DACX0508(n, t), channel7_gain), \\ \t}; \\ \tDEVICE_DT_DEFINE(INST_DT_DACX0508(n, t), \\&dacx0508_init, NULL, \\&dac##t##_data_##n, \\&dac##t##_config_##n, POST_KERNEL, \\ \t\t\t    CONFIG_DAC_DACX0508_INIT_PRIORITY, \\&dacx0508_driver_api)\nend_define\n\nbegin_comment\ncomment|/*  * DAC60508: 12-bit  */\nend_comment",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|static struct dacx0508_data dac##t##_data_##n; \\ \tstatic const struct dacx0508_config dac##t##_config_##n = { \\ \t\t.bus = SPI_DT_SPEC_GET(INST_DT_DACX0508(n, t), \\ \t\t\tSPI_OP_MODE_MASTER | SPI_TRANSFER_MSB | \\ \t\t\tSPI_WORD_SET(8) | SPI_MODE_CPHA, 0), \\ \t\t.resolution = res, \\ \t\t.reference = DT_PROP(INST_DT_DACX0508(n, t), \\ \t\t\t\t\t     voltage_reference), \\ \t\t.gain[0] = DT_PROP(INST_DT_DACX0508(n, t), channel0_gain), \\ \t\t.gain[1] = DT_PROP(INST_DT_DACX0508(n, t), channel1_gain), \\ \t\t.gain[2] = DT_PROP(INST_DT_DACX0508(n, t), channel2_gain), \\ \t\t.gain[3] = DT_PROP(INST_DT_DACX0508(n, t), channel3_gain), \\ \t\t.gain[4] = DT_PROP(INST_DT_DACX0508(n, t), channel4_gain), \\ \t\t.gain[5] = DT_PROP(INST_DT_DACX0508(n, t), channel5_gain), \\ \t\t.gain[6] = DT_PROP(INST_DT_DACX0508(n, t), channel6_gain), \\ \t\t.gain[7] = DT_PROP(INST_DT_DACX0508(n, t), channel7_gain), \\ \t}; \\ \tDEVICE_DT_DEFINE(INST_DT_DACX0508(n, t), \\&dacx0508_init, NULL, \\&dac##t##_data_##n, \\&dac##t##_config_##n, POST_KERNEL, \\ \t\t\t    CONFIG_DAC_DACX0508_INIT_PRIORITY, \\&dacx0508_driver_api)\n+value|static struct dacx0508_data dac##t##_data_##n; \\ \tstatic const struct dacx0508_config dac##t##_config_##n = { \\ \t\t.bus = SPI_DT_SPEC_GET(INST_DT_DACX0508(n, t), \\ \t\t\tSPI_OP_MODE_MASTER | SPI_TRANSFER_MSB | \\ \t\t\tSPI_WORD_SET(8) | SPI_MODE_CPHA, 0), \\ \t\t.resolution = res, \\ \t\t.reference = DT_PROP(INST_DT_DACX0508(n, t), \\ \t\t\t\t\t     voltage_reference), \\ \t\t.gain[0] = DT_PROP(INST_DT_DACX0508(n, t), channel0_gain), \\ \t\t.gain[1] = DT_PROP(INST_DT_DACX0508(n, t), channel1_gain), \\ \t\t.gain[2] = DT_PROP(INST_DT_DACX0508(n, t), channel2_gain), \\ \t\t.gain[3] = DT_PROP(INST_DT_DACX0508(n, t), channel3_gain), \\ \t\t.gain[4] = DT_PROP(INST_DT_DACX0508(n, t), channel4_gain), \\ \t\t.gain[5] = DT_PROP(INST_DT_DACX0508(n, t), channel5_gain), \\ \t\t.gain[6] = DT_PROP(INST_DT_DACX0508(n, t), channel6_gain), \\ \t\t.gain[7] = DT_PROP(INST_DT_DACX0508(n, t), channel7_gain), \\ \t}; \\ \tDEVICE_DT_DEFINE(INST_DT_DACX0508(n, t), \\&dacx0508_init, NULL, \\&dac##t##_data_##n, \\&dac##t##_config_##n, POST_KERNEL, \\ \t\t\t    CONFIG_DAC_DACX0508_INIT_PRIORITY, \\&dacx0508_driver_api);\nThe issue was with: drivers: dacx0508: fix for multiple DACs of the same type\n\nPresently, this driver cannot handle multiple\nDACs of the same type without throwing a\ncompile error due to a missing line ending.\nThis PR fixes that issue by adding the missing\nline ending."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: bluetooth: hci: Special handling of hci_reset only for ST SPI v1\n\nExclude devices based on ST SPI protocol v2 from special handling of\nhci_reset opcode as it is redundant. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|\"SPI TX\"\nargument_list|)\nexpr_stmt|;\nif|#\ndirective|if\noperator|(\nname|DT_HAS_COMPAT_STATUS_OKAY\nargument_list|(\nname|st_hci_spi_v1\nargument_list|)\noperator|||\nname|DT_HAS_COMPAT_STATUS_OKAY\nargument_list|(\nname|st_hci_spi_v2\nargument_list|)\noperator|)\ncomment|/* \t * Since a RESET has been requested, the chip will now restart. \t * Unfortunately the BlueNRG will reply with \"reset received\" but \t * since it does not send back a NOP, we have no way to tell when the \t * RESET has actually taken place.  Instead, we use the vendor command \t * EVT_BLUE_INITIALIZED as an indication that it is safe to proceed. \t */\nif|if\ncondition|(\nname|bt_spi_get_cmd\nargument_list|(\nargument_list|)\nexpr_stmt|;\nblock|}\nendif|#\ndirective|endif\ncomment|/* DT_HAS_COMPAT_STATUS_OKAY(st_hci_spi_v1) || DT_HAS_COMPAT_STATUS_OKAY(st_hci_spi_v2) */\nname|net_buf_unref\nargument_list|(\nname|buf\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|(\n-operator|||\n-name|DT_HAS_COMPAT_STATUS_OKAY\n-argument_list|(\n-name|st_hci_spi_v2\n-argument_list|)\n-operator|)\n-comment|/* DT_HAS_COMPAT_STATUS_OKAY(st_hci_spi_v1) || DT_HAS_COMPAT_STATUS_OKAY(st_hci_spi_v2) */\n+comment|/* DT_HAS_COMPAT_STATUS_OKAY(st_hci_spi_v1) */\nThe issue was with: drivers: bluetooth: hci: Special handling of hci_reset only for ST SPI v1\n\nExclude devices based on ST SPI protocol v2 from special handling of\nhci_reset opcode as it is redundant."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: i2s_nrfx: add support for divider setup on NRF54L15\n\nAdd support for NRF54L15 divider setting which is same as on NRF5340 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|i2s_config\nmodifier|*\nname|i2s_cfg\nparameter_list|)\nblock|{\nDECL|struct|__anon2b0bb8870108\nspecifier|static\nspecifier|const\nstruct|struct\nblock|{\nDECL|member|ratio_val\ncondition|(\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_SOC_SERIES_NRF53X\nargument_list|)\ncondition|)\nblock|{\nname|uint32_t\nname|requested_mck\ninit|=\nexpr_stmt|;\nblock|}\nblock|}\nelse|else\nblock|{\nDECL|struct|__anon2b0bb8870208\nspecifier|static\nspecifier|const\nstruct|struct\nblock|{\nDECL|member|divider_val",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2b0bb8870108\n+DECL|struct|__anon2b67a6aa0108\n+operator|||\n+name|IS_ENABLED\n+argument_list|(\n+name|CONFIG_SOC_SERIES_NRF54LX\n+argument_list|)\n-DECL|struct|__anon2b0bb8870208\n+DECL|struct|__anon2b67a6aa0208\nThe issue was with: drivers: i2s_nrfx: add support for divider setup on NRF54L15\n\nAdd support for NRF54L15 divider setting which is same as on NRF5340"
},{
  "instruction": "There is an issue in the following code. It relates to tests: net: ieee802154: Invalid number of params in debug print\n\nThe debug print did not had print modifier for errno which\ncauses compiler error. Please fix this issue.",
  "input": "Faulty tokenized code:\ndecl_stmt|;\nDECL|member|payload_length\nname|uint8_t\nname|payload_length\ndecl_stmt|;\nDECL|struct|__anon2af109e50108\nstruct|struct\nblock|{\nDECL|member|fc_seq\nname|struct\nname|ieee802154_fcf_seq\nargument_list|)\ncondition|)\nblock|{\nname|NET_ERR\nargument_list|(\nliteral|\"*** Received socket address does not compare\"\nargument_list|,\nname|errno\nargument_list|)\nexpr_stmt|;\ngoto|goto\nname|release_rx_pkt",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2af109e50108\n+DECL|struct|__anon29e61feb0108\n-literal|\"*** Received socket address does not compare\"\n+literal|\"*** Received socket address does not compare (%d)\"\n+operator|-\nThe issue was with: tests: net: ieee802154: Invalid number of params in debug print\n\nThe debug print did not had print modifier for errno which\ncauses compiler error."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: regulator: fix shell help typo\n\nFix typo with adget shell help Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nname|shell_error\nargument_list|(\nname|sh\nargument_list|,\nliteral|\"Could not set mode (%d)\"\nargument_list|,\nname|ret\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|adget\nargument_list|,\nname|NULL\nargument_list|,\nliteral|\"Get active discharge\\n\"\nliteral|\"Usage: adset<device>\"\nargument_list|,\nname|cmd_adget\nargument_list|,\nliteral|2\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"Could not set mode (%d)\"\n+literal|\"Could not set active discharge (%d)\"\n-literal|\"Usage: adset<device>\"\n+literal|\"Usage: adget<device>\"\nThe issue was with: drivers: regulator: fix shell help typo\n\nFix typo with adget shell help"
},{
  "instruction": "There is an issue in the following code. It relates to mcumgr/img_mgmt: Fix CONFIG_MCUBOOT_BOOTLOADER_NO_DOWNGRADE\n\nUsage of the Kconfig, in code, has been missing CONFIG_,\nso selected or not it did nothing. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nif|#\ndirective|if\nname|IS_ENABLED\nargument_list|(\nname|MCUBOOT_BOOTLOADER_NO_DOWNGRADE\nargument_list|)\nname|ok\noperator|=\nname|zcbor_tstr_put_lit\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|MCUBOOT_BOOTLOADER_NO_DOWNGRADE\n+name|CONFIG_MCUBOOT_BOOTLOADER_NO_DOWNGRADE\nThe issue was with: mcumgr/img_mgmt: Fix CONFIG_MCUBOOT_BOOTLOADER_NO_DOWNGRADE\n\nUsage of the Kconfig, in code, has been missing CONFIG_,\nso selected or not it did nothing."
},{
  "instruction": "There is an issue in the following code. It relates to tests/storage/stream_flash: Fix the test_stream_flash_erase_page\n\nFix for test that was failing due to incorrectly testing of\nstream_flash_erase_page.\nThe stream_flash_erase_page would never be able to erase a page\nit has been requested to erase. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|rc\ndecl_stmt|;\nname|init_target\nargument_list|()\nexpr_stmt|;\ncomment|/* Write out one buf */\nname|rc\noperator|=\nname|stream_flash_buffered_write\nargument_list|(\noperator|&\nname|ctx\nargument_list|,\nname|write_buf\nargument_list|,\nname|BUF_LEN\nargument_list|,\nname|false\nargument_list|)\nexpr_stmt|;\nname|zassert_equal\nargument_list|(\nname|rc\nliteral|\"expected success\"\nargument_list|)\nexpr_stmt|;\nname|VERIFY_ERASED\nargument_list|(\nname|FLASH_BASE\nargument_list|,\nname|page_size\nargument_list|)\nexpr_stmt|;\ncomment|/* \t * Test failure in erase does not change context. \t * The test is done by replacing erase function of device API with fake \t * one that returns with an error, invoking the erase procedure \t * and than comparing state of context prior to call to the one after. \t */",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* Write out one buf */\n+comment|/* Write something to make page dirty */\n-name|stream_flash_buffered_write\n+name|flash_write\n-operator|&\n+operator|.\n+name|fdev\n+argument_list|,\n+name|FLASH_BASE\n-argument_list|,\n-name|false\n-name|FLASH_BASE\n+literal|0\nThe issue was with: tests/storage/stream_flash: Fix the test_stream_flash_erase_page\n\nFix for test that was failing due to incorrectly testing of\nstream_flash_erase_page.\nThe stream_flash_erase_page would never be able to erase a page\nit has been requested to erase."
},{
  "instruction": "There is an issue in the following code. It relates to xtensa: make assembly-called functions static\n\nz_mp_entry() and power_gate_exit() are only called from assembly code\nin the same file, where they're defined. Make them \\\"static\\\" and add\nan attribute to let the compiler know, that they aren't unused. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nend_function\n\nbegin_function\nDECL|function|power_gate_exit (void)\nname|void\nname|power_gate_exit\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nblock|}\nend_function\n\nbegin_function\nDECL|function|power_gate_exit (void)\nname|void\nname|power_gate_exit\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nname|NOP4\nend_undef\n\nbegin_function\nDECL|function|z_mp_entry (void)\nname|__imr\nname|void\nname|z_mp_entry\nparameter_list|(\nname|void\nparameter_list|)\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n+specifier|static\n+name|__used\n+specifier|static\n+name|__used\n+specifier|static\n+name|__used\nThe issue was with: xtensa: make assembly-called functions static\n\nz_mp_entry() and power_gate_exit() are only called from assembly code\nin the same file, where they're defined. Make them \\\"static\\\" and add\nan attribute to let the compiler know, that they aren't unused."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: adc: stm32: disable ADC before writing oversampling bits for g0\n\nAdded the STM32G0X SOC series to the list of SOC that need to disable the\nADC while setting the oversampling bits to prevent writing over the\nCKMODE bits. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_STM32L0X\nargument_list|)\noperator|||\nexpr|\\\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_STM32WLX\nargument_list|)\ncomment|/* \t * setting OVS bits is conditioned to ADC state: ADC must be disabled \t * or enabled without conversion on going : disable it, it will stop \t */\nif|if\ncondition|(\nname|LL_ADC_GetOverSamplingScope\nargument_list|(\nname|adc",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|CONFIG_SOC_SERIES_STM32G0X\n+argument_list|)\n+operator|||\n+expr|\\\n+name|defined\n+argument_list|(\n-comment|/* \t * setting OVS bits is conditioned to ADC state: ADC must be disabled \t * or enabled without conversion on going : disable it, it will stop \t */\n+comment|/* \t * Setting OVS bits is conditioned to ADC state: ADC must be disabled \t * or enabled without conversion on going : disable it, it will stop. \t * For the G0 series, ADC must be disabled to prevent CKMODE bitfield \t * from getting reset, see errata ES0418 section 2.6.4. \t */\nThe issue was with: drivers: adc: stm32: disable ADC before writing oversampling bits for g0\n\nAdded the STM32G0X SOC series to the list of SOC that need to disable the\nADC while setting the oversampling bits to prevent writing over the\nCKMODE bits."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: can: shell: properly sort mode table entries\n\nProperly sort the entries in the can_mode_t translation table. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|can_shell_mode_mapping\nname|can_shell_mode_map\nindex|[]\ninit|=\nblock|{\ncomment|/* Array sorted alphabetically based on name */\nname|CAN_SHELL_MODE_MAPPING\nargument_list|(\nliteral|\"fd\"\nargument_list|,\nname|CAN_MODE_FD\nname|CAN_MODE_LOOPBACK\nargument_list|)\nblock|,\nname|CAN_SHELL_MODE_MAPPING\nargument_list|(\nliteral|\"normal\"\nargument_list|,\nname|CAN_MODE_NORMAL\nargument_list|)\nblock|,\nliteral|\"triple-sampling\"\nargument_list|,\nname|CAN_MODE_3_SAMPLES\nargument_list|)\nblock|,\nname|CAN_SHELL_MODE_MAPPING\nargument_list|(\nliteral|\"manual-recovery\"\nargument_list|,\nname|CAN_MODE_MANUAL_RECOVERY\nargument_list|)\nblock|, }\ndecl_stmt|;\nend_decl_stmt\n\nbegin_expr_stmt\nname|K_MSGQ_DEFINE",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* Array sorted alphabetically based on name */\n+comment|/* zephyr-keep-sorted-start */\n+literal|\"manual-recovery\"\n+argument_list|,\n+name|CAN_MODE_MANUAL_RECOVERY\n+argument_list|)\n+block|,\n+name|CAN_SHELL_MODE_MAPPING\n+argument_list|(\n-name|CAN_SHELL_MODE_MAPPING\n-argument_list|(\n-literal|\"manual-recovery\"\n-argument_list|,\n-name|CAN_MODE_MANUAL_RECOVERY\n-argument_list|)\n-block|, }\n+comment|/* zephyr-keep-sorted-stop */\n+block|}\nThe issue was with: drivers: can: shell: properly sort mode table entries\n\nProperly sort the entries in the can_mode_t translation table."
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: can: shell: skip dtiming test if CAN FD is not enabled\n\nSkip the \\\"test_can_dtiming\\\" test case if CONFIG_CAN_FD_MODE is not enabled,\nnot the \\\"test_can_timing_missing_value\\\" test case. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|()\ndecl_stmt|;\nname|int\nname|err\ndecl_stmt|;\nname|Z_TEST_SKIP_IFNDEF\nargument_list|(\nname|CONFIG_CAN_FD_MODE\nargument_list|)\nexpr_stmt|;\nname|err\noperator|=\nname|shell_execute_cmd\nargument_list|(\nname|sh\nblock|, \t}\ndecl_stmt|;\nname|int\nname|err\ndecl_stmt|;\nname|fake_can_set_timing_data_fake\noperator|.\nname|custom_fake\noperator|=\nname|can_shell_test_capture_timing",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|Z_TEST_SKIP_IFNDEF\n-argument_list|(\n-name|CONFIG_CAN_FD_MODE\n-argument_list|)\n-expr_stmt|;\n+name|Z_TEST_SKIP_IFNDEF\n+argument_list|(\n+name|CONFIG_CAN_FD_MODE\n+argument_list|)\n+expr_stmt|;\nThe issue was with: tests: drivers: can: shell: skip dtiming test if CAN FD is not enabled\n\nSkip the \\\"test_can_dtiming\\\" test case if CONFIG_CAN_FD_MODE is not enabled,\nnot the \\\"test_can_timing_missing_value\\\" test case."
},{
  "instruction": "There is an issue in the following code. It relates to arch: arm64: correct a comment on CONFIG_ARM64_STACK_PROTECTION\n\nThere is a #endif comment which was incorrectly marked with\nCONFIG_HW_STACK_PROTECTION instead of\nCONFIG_ARM64_STACK_PROTECTION, which is used at #if.\nSo update it. Please fix this issue.",
  "input": "Faulty tokenized code:\nendif|#\ndirective|endif\nend_endif\n\nbegin_comment\ncomment|/* defined(CONFIG_USERSPACE) || defined(CONFIG_HW_STACK_PROTECTION) */\nend_comment\n\nbegin_if\nif|#\ndirective|if",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* defined(CONFIG_USERSPACE) || defined(CONFIG_HW_STACK_PROTECTION) */\n+comment|/* defined(CONFIG_USERSPACE) || defined(CONFIG_ARM64_STACK_PROTECTION) */\nThe issue was with: arch: arm64: correct a comment on CONFIG_ARM64_STACK_PROTECTION\n\nThere is a #endif comment which was incorrectly marked with\nCONFIG_HW_STACK_PROTECTION instead of\nCONFIG_ARM64_STACK_PROTECTION, which is used at #if.\nSo update it."
},{
  "instruction": "There is an issue in the following code. It relates to posix: syslog: Fix uninitialized variable error\n\nSeen this in compiler\n\nlib/posix/options/syslog.c: In function 'setlogmask':\nlib/posix/options/syslog.c:66:16: error: 'oldpri' may be used uninitialized\n   66 |         return oldpri;\n      |                ^~~~~~\nlib/posix/options/syslog.c:59:13: note: 'oldpri' was declared here\n   59 |         int oldpri;\n      |             ^~~~~~\nlib/posix/options/syslog.c: In function 'vsyslog':\nlib/posix/options/syslog.c:83:33: error: 'mask' may be used uninitialized\n   83 |         if ((BIT(level) & mask) == 0) {\n      |             ~~~~~~~~~~~~~~~~~~~~^~~~\nlib/posix/options/syslog.c:71:17: note: 'mask' was declared here\n   71 |         uint8_t mask;\n      |                 ^~~~ Please fix this issue.",
  "input": "Faulty tokenized code:\nname|maskpri\nparameter_list|)\nblock|{\nname|int\nname|oldpri\ndecl_stmt|;\nname|K_SPINLOCK\nargument_list|(\nargument|&syslog_lock\nargument_list|)\nname|ap\nparameter_list|)\nblock|{\nname|uint8_t\nname|mask\ndecl_stmt|;\nname|int\nname|level\ninit|=\nname|syslog_priority_to_zephyr_log_level",
  "result": "I corrected the issue in the code by changing the following tokens:\n+init|=\n+operator|-\n+literal|1\n+init|=\n+literal|0\nThe issue was with: posix: syslog: Fix uninitialized variable error\n\nSeen this in compiler\n\nlib/posix/options/syslog.c: In function 'setlogmask':\nlib/posix/options/syslog.c:66:16: error: 'oldpri' may be used uninitialized\n   66 |         return oldpri;\n      |                ^~~~~~\nlib/posix/options/syslog.c:59:13: note: 'oldpri' was declared here\n   59 |         int oldpri;\n      |             ^~~~~~\nlib/posix/options/syslog.c: In function 'vsyslog':\nlib/posix/options/syslog.c:83:33: error: 'mask' may be used uninitialized\n   83 |         if ((BIT(level) & mask) == 0) {\n      |             ~~~~~~~~~~~~~~~~~~~~^~~~\nlib/posix/options/syslog.c:71:17: note: 'mask' was declared here\n   71 |         uint8_t mask;\n      |                 ^~~~"
},{
  "instruction": "There is an issue in the following code. It relates to drivers counter nrfx RTC: Fix ISR prototype\n\nThe ISR prototype is not matching the\nsignature for interrupt handlers, which results in\nbuild warnings.\nLet's fix it. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nblock|}\nend_function\n\nbegin_function\nDECL|function|irq_handler (const struct device * dev)\nspecifier|static\nname|void\nname|irq_handler\nparameter_list|(\nspecifier|const\nname|struct\nname|device\nmodifier|*\nname|dev\nparameter_list|)\nblock|{\nname|top_irq_handle\nargument_list|(\nname|dev\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|irq_handler (const struct device * dev)\n+DECL|function|irq_handler (const void * arg)\n+name|void\n+modifier|*\n+name|arg\n+parameter_list|)\n+block|{\n+specifier|const\n-parameter_list|)\n-block|{\n+init|=\n+name|arg\n+decl_stmt|;\nThe issue was with: drivers counter nrfx RTC: Fix ISR prototype\n\nThe ISR prototype is not matching the\nsignature for interrupt handlers, which results in\nbuild warnings.\nLet's fix it."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: ethernet: adin2111: fix real rx frame size\n\nFix issue related to \\\"generic SPI\\\" mode only, when a packet of\n1512 bytes is received, net_pkt_write() fails and thrwos the error:\n\n\\\"Still some length to go 2\\\".\n\nThis is due to net_pkt_rx_alloc_with_buffer() allocating a maximum\nmtu/size of 1514, and driver is not removing 4 bytes of crc32 from\nrx buffer, that comes to be 1516 (2 bytes over buffer limit).\n\nFix generic SPI rx frame size removing crc32 bytes. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\noperator|-\nname|fsize\noperator|)\nexpr_stmt|;\ncomment|/* actual frame length is FSIZE - FRAME HEADER */\nname|fsize_real\noperator|=\nname|fsize\noperator|-\nname|ADIN2111_FRAME_HEADER_SIZE\nexpr_stmt|;\ncomment|/* spi header */\noperator|*\noperator|(\nname|uint16_t",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* actual frame length is FSIZE - FRAME HEADER */\n+comment|/* actual frame length is FSIZE - FRAME HEADER - CRC32 */\n+operator|(\n+operator|+\n+sizeof|sizeof\n+argument_list|(\n+name|uint32_t\n+argument_list|)\n+operator|)\nThe issue was with: drivers: ethernet: adin2111: fix real rx frame size\n\nFix issue related to \\\"generic SPI\\\" mode only, when a packet of\n1512 bytes is received, net_pkt_write() fails and thrwos the error:\n\n\\\"Still some length to go 2\\\".\n\nThis is due to net_pkt_rx_alloc_with_buffer() allocating a maximum\nmtu/size of 1514, and driver is not removing 4 bytes of crc32 from\nrx buffer, that comes to be 1516 (2 bytes over buffer limit).\n\nFix generic SPI rx frame size removing crc32 bytes."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: ethernet: adin2111: remove unused header_len variable\n\nNon functional change, removing unused variable producing\ncompilation warning in \\\"Generic SPI without CRC8\\\" mode. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|struct\nname|net_pkt\nmodifier|*\nname|pkt\ndecl_stmt|;\nname|size_t\nname|header_len\ninit|=\nname|ADIN2111_READ_HEADER_SIZE\ndecl_stmt|;\nname|uint16_t\nname|fsize_reg\ninit|=\noperator|(\noperator|(\nliteral|3\nindex|]\noperator|=\nliteral|0U\nexpr_stmt|;\noperator|++\nname|header_len\nexpr_stmt|;\nelse|#\ndirective|else\ncomment|/* TA */\nname|cmd_buf\nindex|[",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|size_t\n-name|header_len\n-init|=\n-name|ADIN2111_READ_HEADER_SIZE\n-decl_stmt|;\n-operator|++\n-name|header_len\n-expr_stmt|;\nThe issue was with: drivers: ethernet: adin2111: remove unused header_len variable\n\nNon functional change, removing unused variable producing\ncompilation warning in \\\"Generic SPI without CRC8\\\" mode."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: ethernet: adin2111: fix generic spi withotut crc8 mode\n\nAfter some debugging related to non-working \\\"Generic SPI without CRC\\\"\nmode in eval_adin2111_ebz (CONFIG_ETH_ADIN2111_SPI_CFG0=n), noticed\nthat even after proper STATUS0 RESETC bit detection, registers,\nfor a certain period (some msecs) still reads as zero.\n\nThis patch fixes adin2111_await_device and with it the\n\\\"Generic SPI without CRC\\\" mode. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|=\nname|eth_adin2111_reg_read\nargument_list|(\nname|dev\nargument_list|,\nname|ADIN2111_STATUS0\nargument_list|,\noperator|&\nname|val\nargument_list|)\nexpr_stmt|;\nname|ret\noperator|>=\nliteral|0\ncondition|)\nblock|{\ncomment|/* if out of reset */\nif|if\ncondition|(\nname|val\noperator|&\nname|ADIN2111_STATUS0_RESETC\ncondition|)\nblock|{\ncomment|/* clear RESETC */\nname|ret\noperator|=\ndirective|define\nname|ADIN2111_TX_FIFO_BUFFER_MARGIN\nvalue|4U\nend_define\n\nbegin_enum\nDECL|enum|adin2111_chips_id\nenum|enum\nname|adin2111_chips_id\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|ADIN2111_STATUS0\n+name|ADIN2111_PHYID\n-comment|/* if out of reset */\n+comment|/* \t\t\t * Even after getting RESETC, for some milliseconds registers are \t\t\t * still not properly readable (they reads 0), \t\t\t * so checking OUI read-only value instead. \t\t\t */\n+operator|(\n-operator|&\n-name|ADIN2111_STATUS0_RESETC\n+operator|>>\n+literal|10\n+operator|)\n+operator|==\n+name|ADIN2111_PHYID_OUI\n+begin_comment\n+comment|/* Manufacturer unique ID */\n+end_comment\n+\n+begin_define\n+DECL|macro|ADIN2111_PHYID_OUI\n+define|#\n+directive|define\n+name|ADIN2111_PHYID_OUI\n+value|0xa0ef\n+end_define\n+\nThe issue was with: drivers: ethernet: adin2111: fix generic spi withotut crc8 mode\n\nAfter some debugging related to non-working \\\"Generic SPI without CRC\\\"\nmode in eval_adin2111_ebz (CONFIG_ETH_ADIN2111_SPI_CFG0=n), noticed\nthat even after proper STATUS0 RESETC bit detection, registers,\nfor a certain period (some msecs) still reads as zero.\n\nThis patch fixes adin2111_await_device and with it the\n\\\"Generic SPI without CRC\\\" mode."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: ethernet: adin2111: always append crc32 to the eth frame\n\nEnable appending of a crc32 at the end of the frame by the MAC,\nalways. This is always needed since the driver is not adding it.\n\nThis field has nothing to do with Generic SPI protocol-related\n8-bit CRC, so this patch removes the CONFIG_ETH_ADIN2111_SPI_CFG0\nchoice related to this setting.\n\nTesting without this flag set, packets are not forwareded in the\nnetwork, since the driver is not appending any crc32 header\nto the frame. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nreturn|return\nname|ret\nreturn|;\nblock|}\nif|#\ndirective|if\nname|CONFIG_ETH_ADIN2111_SPI_CFG0\nname|val\noperator||=\nname|ADIN2111_CONFIG2_CRC_APPEND\nexpr_stmt|;\nelse|#\ndirective|else\nname|val\noperator|&=\noperator|~\nname|ADIN2111_CONFIG2_CRC_APPEND\nexpr_stmt|;\nendif|#\ndirective|endif\ncomment|/* CONFIG_ETH_ADIN2111_SPI_CFG0 */\ncomment|/* configure forwarding of frames with unknown destination address */\ncomment|/* to the other port. This forwarding is done in hardware.         */\ncomment|/* The setting will take effect after the ports                    */\ncomment|/* are out of software powerdown.                                  */\nname|val",
  "result": "I corrected the issue in the code by changing the following tokens:\n-if|#\n-directive|if\n-name|CONFIG_ETH_ADIN2111_SPI_CFG0\n-else|#\n-directive|else\n-name|val\n-operator|&=\n-operator|~\n-name|ADIN2111_CONFIG2_CRC_APPEND\n-expr_stmt|;\n-endif|#\n-directive|endif\n-comment|/* CONFIG_ETH_ADIN2111_SPI_CFG0 */\nThe issue was with: drivers: ethernet: adin2111: always append crc32 to the eth frame\n\nEnable appending of a crc32 at the end of the frame by the MAC,\nalways. This is always needed since the driver is not adding it.\n\nThis field has nothing to do with Generic SPI protocol-related\n8-bit CRC, so this patch removes the CONFIG_ETH_ADIN2111_SPI_CFG0\nchoice related to this setting.\n\nTesting without this flag set, packets are not forwareded in the\nnetwork, since the driver is not appending any crc32 header\nto the frame."
},{
  "instruction": "There is an issue in the following code. It relates to net: sockets: packet: Ignore the packet type if LL address is not set\n\nIn case the LL address is not set on a packet for any reason, don't try\nto access address structure to determine packet type. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|lladdr\nparameter_list|)\nblock|{\nif|if\ncondition|(\nname|net_eth_is_addr_broadcast\nargument_list|(\noperator|(\nexpr|struct\nname|net_eth_addr",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|lladdr\n+operator|==\n+name|NULL\n+operator|||\n+name|lladdr\n+operator|->\n+name|addr\n+operator|==\n+name|NULL\n+condition|)\n+block|{\n+return|return;\n+block|}\n+if|if\n+condition|(\nThe issue was with: net: sockets: packet: Ignore the packet type if LL address is not set\n\nIn case the LL address is not set on a packet for any reason, don't try\nto access address structure to determine packet type."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: dai: sai: use \\\"dmas\\\" property for handshake encoding\n\nSince a DMA cell now allows specifying a channel and a MUX value\nthere's no need to fetch these values from the HAL. This, in turn,\nallows for more flexibility and reduces the coding effort for new\nplatforms that want to use the SAI driver. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|SAI_INIT\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\ \t\t\t\t\t\t\t\t\t\t\\\nvalue|BUILD_ASSERT(SAI_FIFO_DEPTH(inst)> 0&&\t\t\t\t\t\\ \t     SAI_FIFO_DEPTH(inst)<= _SAI_FIFO_DEPTH(inst),\t\t\t\\ \t     \"invalid FIFO depth\");\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(SAI_RX_FIFO_WATERMARK(inst)> 0&&\t\t\t\t\t\\ \t     SAI_RX_FIFO_WATERMARK(inst)<= _SAI_FIFO_DEPTH(inst),\t\t\\ \t     \"invalid RX FIFO watermark\");\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(SAI_TX_FIFO_WATERMARK(inst)> 0&&\t\t\t\t\t\\ \t     SAI_TX_FIFO_WATERMARK(inst)<= _SAI_FIFO_DEPTH(inst),\t\t\\ \t     \"invalid TX FIFO watermark\");\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(IS_ENABLED(CONFIG_SAI_HAS_MCLK_CONFIG_OPTION) ||\t\t\t\\ \t     !DT_INST_PROP(inst, mclk_is_output),\t\t\t\t\\ \t     \"SAI doesn't support MCLK config but mclk_is_output is specified\");\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(SAI_TX_SYNC_MODE(inst) != SAI_RX_SYNC_MODE(inst) ||\t\t\\ \t     SAI_TX_SYNC_MODE(inst) != kSAI_ModeSync,\t\t\t\t\\ \t     \"transmitter and receiver can't be both SYNC with each other\");\t\\ \t\t\t\t\t\t\t\t\t\t\\ static const struct dai_properties sai_tx_props_##inst = {\t\t\t\\ \t.fifo_address = SAI_TX_FIFO_BASE(inst),\t\t\t\t\t\\ \t.fifo_depth = SAI_FIFO_DEPTH(inst) * CONFIG_SAI_FIFO_WORD_SIZE,\t\t\\ \t.dma_hs_id = SAI_TX_DMA_MUX(inst),\t\t\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static const struct dai_properties sai_rx_props_##inst = {\t\t\t\\ \t.fifo_address = SAI_RX_FIFO_BASE(inst),\t\t\t\t\t\\ \t.fifo_depth = SAI_FIFO_DEPTH(inst) * CONFIG_SAI_FIFO_WORD_SIZE,\t\t\\ \t.dma_hs_id = SAI_RX_DMA_MUX(inst),\t\t\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ void irq_config_##inst(void)\t\t\t\t\t\t\t\\ {\t\t\t\t\t\t\t\t\t\t\\ \tIRQ_CONNECT(DT_INST_IRQN(inst),\t\t\t\t\t\t\\ \t\t    0,\t\t\t\t\t\t\t\t\\ \t\t    sai_isr,\t\t\t\t\t\t\t\\ \t\t    DEVICE_DT_INST_GET(inst),\t\t\t\t\t\\ \t\t    0);\t\t\t\t\t\t\t\t\\ \tirq_enable(DT_INST_IRQN(inst));\t\t\t\t\t\t\\ }\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static struct sai_config sai_config_##inst = {\t\t\t\t\t\\ \t.regmap_phys = DT_INST_REG_ADDR(inst),\t\t\t\t\t\\ \t.regmap_size = DT_INST_REG_SIZE(inst),\t\t\t\t\t\\ \t.clk_data = SAI_CLOCK_DATA_DECLARE(inst),\t\t\t\t\\ \t.rx_fifo_watermark = SAI_RX_FIFO_WATERMARK(inst),\t\t\t\\ \t.tx_fifo_watermark = SAI_TX_FIFO_WATERMARK(inst),\t\t\t\\ \t.mclk_is_output = DT_INST_PROP(inst, mclk_is_output),\t\t\t\\ \t.tx_props =&sai_tx_props_##inst,\t\t\t\t\t\\ \t.rx_props =&sai_rx_props_##inst,\t\t\t\t\t\\ \t.irq_config = irq_config_##inst,\t\t\t\t\t\\ \t.tx_sync_mode = SAI_TX_SYNC_MODE(inst),\t\t\t\t\t\\ \t.rx_sync_mode = SAI_RX_SYNC_MODE(inst),\t\t\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static struct sai_data sai_data_##inst = {\t\t\t\t\t\\ \t.cfg.type = DAI_IMX_SAI,\t\t\t\t\t\t\\ \t.cfg.dai_index = DT_INST_PROP_OR(inst, dai_index, 0),\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ DEVICE_DT_INST_DEFINE(inst,&sai_init, NULL,\t\t\t\t\t\\&sai_data_##inst,&sai_config_##inst,\t\t\t\\ \t\t      POST_KERNEL, CONFIG_DAI_INIT_PRIORITY,\t\t\t\\&sai_api);\t\t\t\t\t\t\\  DT_INST_FOREACH_STATUS_OKAY(SAI_INIT);\nend_define\n\nend_unit\n\nparameter_list|)\ndefine|\\\nvalue|DT_INST_PROP_OR(inst, rx_sync_mode, kSAI_ModeAsync)\nend_define\n\nbegin_comment\ncomment|/* utility macros */\nend_comment\n\nbegin_comment",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|BUILD_ASSERT(SAI_FIFO_DEPTH(inst)> 0&&\t\t\t\t\t\\ \t     SAI_FIFO_DEPTH(inst)<= _SAI_FIFO_DEPTH(inst),\t\t\t\\ \t     \"invalid FIFO depth\");\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(SAI_RX_FIFO_WATERMARK(inst)> 0&&\t\t\t\t\t\\ \t     SAI_RX_FIFO_WATERMARK(inst)<= _SAI_FIFO_DEPTH(inst),\t\t\\ \t     \"invalid RX FIFO watermark\");\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(SAI_TX_FIFO_WATERMARK(inst)> 0&&\t\t\t\t\t\\ \t     SAI_TX_FIFO_WATERMARK(inst)<= _SAI_FIFO_DEPTH(inst),\t\t\\ \t     \"invalid TX FIFO watermark\");\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(IS_ENABLED(CONFIG_SAI_HAS_MCLK_CONFIG_OPTION) ||\t\t\t\\ \t     !DT_INST_PROP(inst, mclk_is_output),\t\t\t\t\\ \t     \"SAI doesn't support MCLK config but mclk_is_output is specified\");\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(SAI_TX_SYNC_MODE(inst) != SAI_RX_SYNC_MODE(inst) ||\t\t\\ \t     SAI_TX_SYNC_MODE(inst) != kSAI_ModeSync,\t\t\t\t\\ \t     \"transmitter and receiver can't be both SYNC with each other\");\t\\ \t\t\t\t\t\t\t\t\t\t\\ static const struct dai_properties sai_tx_props_##inst = {\t\t\t\\ \t.fifo_address = SAI_TX_FIFO_BASE(inst),\t\t\t\t\t\\ \t.fifo_depth = SAI_FIFO_DEPTH(inst) * CONFIG_SAI_FIFO_WORD_SIZE,\t\t\\ \t.dma_hs_id = SAI_TX_DMA_MUX(inst),\t\t\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static const struct dai_properties sai_rx_props_##inst = {\t\t\t\\ \t.fifo_address = SAI_RX_FIFO_BASE(inst),\t\t\t\t\t\\ \t.fifo_depth = SAI_FIFO_DEPTH(inst) * CONFIG_SAI_FIFO_WORD_SIZE,\t\t\\ \t.dma_hs_id = SAI_RX_DMA_MUX(inst),\t\t\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ void irq_config_##inst(void)\t\t\t\t\t\t\t\\ {\t\t\t\t\t\t\t\t\t\t\\ \tIRQ_CONNECT(DT_INST_IRQN(inst),\t\t\t\t\t\t\\ \t\t    0,\t\t\t\t\t\t\t\t\\ \t\t    sai_isr,\t\t\t\t\t\t\t\\ \t\t    DEVICE_DT_INST_GET(inst),\t\t\t\t\t\\ \t\t    0);\t\t\t\t\t\t\t\t\\ \tirq_enable(DT_INST_IRQN(inst));\t\t\t\t\t\t\\ }\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static struct sai_config sai_config_##inst = {\t\t\t\t\t\\ \t.regmap_phys = DT_INST_REG_ADDR(inst),\t\t\t\t\t\\ \t.regmap_size = DT_INST_REG_SIZE(inst),\t\t\t\t\t\\ \t.clk_data = SAI_CLOCK_DATA_DECLARE(inst),\t\t\t\t\\ \t.rx_fifo_watermark = SAI_RX_FIFO_WATERMARK(inst),\t\t\t\\ \t.tx_fifo_watermark = SAI_TX_FIFO_WATERMARK(inst),\t\t\t\\ \t.mclk_is_output = DT_INST_PROP(inst, mclk_is_output),\t\t\t\\ \t.tx_props =&sai_tx_props_##inst,\t\t\t\t\t\\ \t.rx_props =&sai_rx_props_##inst,\t\t\t\t\t\\ \t.irq_config = irq_config_##inst,\t\t\t\t\t\\ \t.tx_sync_mode = SAI_TX_SYNC_MODE(inst),\t\t\t\t\t\\ \t.rx_sync_mode = SAI_RX_SYNC_MODE(inst),\t\t\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static struct sai_data sai_data_##inst = {\t\t\t\t\t\\ \t.cfg.type = DAI_IMX_SAI,\t\t\t\t\t\t\\ \t.cfg.dai_index = DT_INST_PROP_OR(inst, dai_index, 0),\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ DEVICE_DT_INST_DEFINE(inst,&sai_init, NULL,\t\t\t\t\t\\&sai_data_##inst,&sai_config_##inst,\t\t\t\\ \t\t      POST_KERNEL, CONFIG_DAI_INIT_PRIORITY,\t\t\t\\&sai_api);\t\t\t\t\t\t\\  DT_INST_FOREACH_STATUS_OKAY(SAI_INIT);\n+value|BUILD_ASSERT(SAI_FIFO_DEPTH(inst)> 0&&\t\t\t\t\t\\ \t     SAI_FIFO_DEPTH(inst)<= _SAI_FIFO_DEPTH(inst),\t\t\t\\ \t     \"invalid FIFO depth\");\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(SAI_RX_FIFO_WATERMARK(inst)> 0&&\t\t\t\t\t\\ \t     SAI_RX_FIFO_WATERMARK(inst)<= _SAI_FIFO_DEPTH(inst),\t\t\\ \t     \"invalid RX FIFO watermark\");\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(SAI_TX_FIFO_WATERMARK(inst)> 0&&\t\t\t\t\t\\ \t     SAI_TX_FIFO_WATERMARK(inst)<= _SAI_FIFO_DEPTH(inst),\t\t\\ \t     \"invalid TX FIFO watermark\");\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(IS_ENABLED(CONFIG_SAI_HAS_MCLK_CONFIG_OPTION) ||\t\t\t\\ \t     !DT_INST_PROP(inst, mclk_is_output),\t\t\t\t\\ \t     \"SAI doesn't support MCLK config but mclk_is_output is specified\");\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(SAI_TX_SYNC_MODE(inst) != SAI_RX_SYNC_MODE(inst) ||\t\t\\ \t     SAI_TX_SYNC_MODE(inst) != kSAI_ModeSync,\t\t\t\t\\ \t     \"transmitter and receiver can't be both SYNC with each other\");\t\\ \t\t\t\t\t\t\t\t\t\t\\ static const struct dai_properties sai_tx_props_##inst = {\t\t\t\\ \t.fifo_address = SAI_TX_FIFO_BASE(inst),\t\t\t\t\t\\ \t.fifo_depth = SAI_FIFO_DEPTH(inst) * CONFIG_SAI_FIFO_WORD_SIZE,\t\t\\ \t.dma_hs_id = SAI_TX_RX_DMA_HANDSHAKE(inst, tx),\t\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static const struct dai_properties sai_rx_props_##inst = {\t\t\t\\ \t.fifo_address = SAI_RX_FIFO_BASE(inst),\t\t\t\t\t\\ \t.fifo_depth = SAI_FIFO_DEPTH(inst) * CONFIG_SAI_FIFO_WORD_SIZE,\t\t\\ \t.dma_hs_id = SAI_TX_RX_DMA_HANDSHAKE(inst, rx),\t\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ void irq_config_##inst(void)\t\t\t\t\t\t\t\\ {\t\t\t\t\t\t\t\t\t\t\\ \tIRQ_CONNECT(DT_INST_IRQN(inst),\t\t\t\t\t\t\\ \t\t    0,\t\t\t\t\t\t\t\t\\ \t\t    sai_isr,\t\t\t\t\t\t\t\\ \t\t    DEVICE_DT_INST_GET(inst),\t\t\t\t\t\\ \t\t    0);\t\t\t\t\t\t\t\t\\ \tirq_enable(DT_INST_IRQN(inst));\t\t\t\t\t\t\\ }\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static struct sai_config sai_config_##inst = {\t\t\t\t\t\\ \t.regmap_phys = DT_INST_REG_ADDR(inst),\t\t\t\t\t\\ \t.regmap_size = DT_INST_REG_SIZE(inst),\t\t\t\t\t\\ \t.clk_data = SAI_CLOCK_DATA_DECLARE(inst),\t\t\t\t\\ \t.rx_fifo_watermark = SAI_RX_FIFO_WATERMARK(inst),\t\t\t\\ \t.tx_fifo_watermark = SAI_TX_FIFO_WATERMARK(inst),\t\t\t\\ \t.mclk_is_output = DT_INST_PROP(inst, mclk_is_output),\t\t\t\\ \t.tx_props =&sai_tx_props_##inst,\t\t\t\t\t\\ \t.rx_props =&sai_rx_props_##inst,\t\t\t\t\t\\ \t.irq_config = irq_config_##inst,\t\t\t\t\t\\ \t.tx_sync_mode = SAI_TX_SYNC_MODE(inst),\t\t\t\t\t\\ \t.rx_sync_mode = SAI_RX_SYNC_MODE(inst),\t\t\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static struct sai_data sai_data_##inst = {\t\t\t\t\t\\ \t.cfg.type = DAI_IMX_SAI,\t\t\t\t\t\t\\ \t.cfg.dai_index = DT_INST_PROP_OR(inst, dai_index, 0),\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ DEVICE_DT_INST_DEFINE(inst,&sai_init, NULL,\t\t\t\t\t\\&sai_data_##inst,&sai_config_##inst,\t\t\t\\ \t\t      POST_KERNEL, CONFIG_DAI_INIT_PRIORITY,\t\t\t\\&sai_api);\t\t\t\t\t\t\\  DT_INST_FOREACH_STATUS_OKAY(SAI_INIT);\n+begin_comment\n+comment|/* used to retrieve the handshake value for given direction. The handshake  * is computed as follows:  *\thandshake = CHANNEL_ID | (MUX_VALUE<< 8)  * The channel ID and MUX value are each encoded in 8 bits.  */\n+end_comment\n+\n+begin_define\n+DECL|macro|SAI_TX_RX_DMA_HANDSHAKE (inst,dir)\n+define|#\n+directive|define\n+name|SAI_TX_RX_DMA_HANDSHAKE\n+parameter_list|(\n+name|inst\n+parameter_list|,\n+name|dir\n+parameter_list|)\n+define|\\\n+value|((DT_INST_DMAS_CELL_BY_NAME(inst, dir, channel)& GENMASK(7, 0)) |\\ \t ((DT_INST_DMAS_CELL_BY_NAME(inst, dir, mux)<< 8)& GENMASK(15, 8)))\n+end_define\n+\nThe issue was with: drivers: dai: sai: use \\\"dmas\\\" property for handshake encoding\n\nSince a DMA cell now allows specifying a channel and a MUX value\nthere's no need to fetch these values from the HAL. This, in turn,\nallows for more flexibility and reduces the coding effort for new\nplatforms that want to use the SAI driver."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: ethernet: eth_adin2111: Fix build warning on 64bit\n\nAn overflow compiler warning is generated when building for native_sim_64,\nadd an explicit cast to fix -Werror builds. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ctx\noperator|->\nname|imask0\noperator|=\noperator|~\nname|ADIN2111_IMASK0_PHYINTM\nexpr_stmt|;\nname|ctx\noperator|->\nname|imask1\noperator|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+operator|(\n+name|uint32_t\n+operator|)\n+operator|)\nThe issue was with: drivers: ethernet: eth_adin2111: Fix build warning on 64bit\n\nAn overflow compiler warning is generated when building for native_sim_64,\nadd an explicit cast to fix -Werror builds."
},{
  "instruction": "There is an issue in the following code. It relates to net: mgmt: Handle loops in the linked list\n\nIn case the same callback handler is added to the list twice, this can\nresult in a loop.\n\nFixes: #69825. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|net_mgmt_callback_lock\nargument_list|,\nname|K_FOREVER\nargument_list|)\nexpr_stmt|;\nname|sys_slist_prepend\nargument_list|(\noperator|&\nname|event_callbacks\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Remove the callback if it already exists to avoid loop */\n+name|sys_slist_find_and_remove\n+argument_list|(\n+operator|&\n+name|event_callbacks\n+argument_list|,\n+operator|&\n+name|cb\n+operator|->\n+name|node\n+argument_list|)\n+expr_stmt|;\nThe issue was with: net: mgmt: Handle loops in the linked list\n\nIn case the same callback handler is added to the list twice, this can\nresult in a loop.\n\nFixes: #69825."
},{
  "instruction": "There is an issue in the following code. It relates to sched: finalize_cancel_locked can early return\n\nThe code `SYS_SLIST_FOR_EACH_CONTAINER_SAFE` just for remove work\nfrom `pending_cancels`.\nAfter removing work successfully, the function can return early.\nIt is unnecessary to iterate continuously. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|wc\noperator|->\nname|sem\nargument_list|)\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\nname|prev\noperator|=\noperator|&\nname|wc\noperator|->\nname|node\nexpr_stmt|;\nblock|}\nblock|}\nblock|}\nend_function\n\nbegin_function\nDECL|function|k_work_init (struct k_work * work,k_work_handler_t handler)\nname|void",
  "result": "I corrected the issue in the code by changing the following tokens:\n+break|break;\n-else|else\n-block|{\n-block|}\nThe issue was with: sched: finalize_cancel_locked can early return\n\nThe code `SYS_SLIST_FOR_EACH_CONTAINER_SAFE` just for remove work\nfrom `pending_cancels`.\nAfter removing work successfully, the function can return early.\nIt is unnecessary to iterate continuously."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: modem_cellular: allow leaving out the chat_filter parameter\n\nAllow not specifying the chat_filter parameter in a device\ndefinition, which is equivalent to setting it to \\\"\\\". Please fix this issue.",
  "input": "Faulty tokenized code:\nname|chat_filter\nblock|,\noperator|.\nname|filter_size\noperator|=\nname|strlen\nargument_list|(\nname|data\noperator|->\nname|chat_filter\nargument_list|)\nblock|,\noperator|.\nname|argv\noperator|=\nname|data",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|data\n+operator|->\n+name|chat_filter\n+operator|?\n+operator|:\n+literal|0\nThe issue was with: drivers: modem_cellular: allow leaving out the chat_filter parameter\n\nAllow not specifying the chat_filter parameter in a device\ndefinition, which is equivalent to setting it to \\\"\\\"."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: adc: set name for acquisition thread of MCP320x\n\nSet the name of the acquisition thread for the ADC MCP320x. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|return\noperator|-\nname|ENODEV\nreturn|;\nblock|}\nname|k_thread_create\nargument_list|(\noperator|&\nname|data\noperator|->\nargument_list|,\nliteral|0\nargument_list|,\nname|K_NO_WAIT\nargument_list|)\nexpr_stmt|;\nname|adc_context_unlock_unconditionally\nargument_list|(\noperator|&\nname|data",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|k_tid_t\n+name|tid\n+init|=\n+decl_stmt|;\n+name|k_thread_name_set\n+argument_list|(\n+name|tid\n+argument_list|,\n+name|dev\n+operator|->\n+name|name\n+argument_list|)\nThe issue was with: drivers: adc: set name for acquisition thread of MCP320x\n\nSet the name of the acquisition thread for the ADC MCP320x."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: input: Fix uninitialized closest_mv variable warning\n\nBuilding with GCC 9.4.0 gives the following warning/error:\n\n  error: closest_mv may be used uninitialized in this function\n\nThis commit fixes it. Please fix this issue.",
  "input": "Faulty tokenized code:\ndecl_stmt|;\nname|int32_t\nname|sample_mv\ndecl_stmt|,\nname|closest_mv\ndecl_stmt|;\nname|uint32_t\nname|diff\ndecl_stmt|,\nname|closest_diff",
  "result": "I corrected the issue in the code by changing the following tokens:\n+init|=\n+literal|0\nThe issue was with: drivers: input: Fix uninitialized closest_mv variable warning\n\nBuilding with GCC 9.4.0 gives the following warning/error:\n\n  error: closest_mv may be used uninitialized in this function\n\nThis commit fixes it."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: add missing initilization of sync_info member\n\nDuring manual testing with UBSAN enabled, it was found that\nbt_le_per_adv_sync_cb synced() callback in application\nsometimes gets unexpected different values in\n`sync_info.recv_enabled` field.\n\nThe UBSAN output contained the following warnings message:\nruntime error:\nload of value 65, which is not a valid value for type '_Bool'\n\nIt tunrned out that struct bt_le_per_adv_sync_synced_info sync_info\ninside bt_hci_le_past_received_common() contains uninitialized\nrecv_enabled member.\nSet it to true by default to avoid possible issues. Please fix this issue.",
  "input": "Faulty tokenized code:\ndecl_stmt|;\nDECL|member|sid\nname|uint8_t\nname|sid\ndecl_stmt|;\nDECL|enum|__anon2ae9f80d0103\nenum|enum\nblock|{\nDECL|enumerator|FRAG_ADV_INACTIVE\nname|FRAG_ADV_INACTIVE\nblock|,\nname|evt\noperator|->\nname|service_data\nargument_list|)\nexpr_stmt|;\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_BT_PER_ADV_SYNC_RSP",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon2ae9f80d0103\n+DECL|enum|__anon2c7072340103\n+name|sync_info\n+operator|.\n+name|recv_enabled\n+operator|=\n+name|true\n+expr_stmt|;\nThe issue was with: Bluetooth: add missing initilization of sync_info member\n\nDuring manual testing with UBSAN enabled, it was found that\nbt_le_per_adv_sync_cb synced() callback in application\nsometimes gets unexpected different values in\n`sync_info.recv_enabled` field.\n\nThe UBSAN output contained the following warnings message:\nruntime error:\nload of value 65, which is not a valid value for type '_Bool'\n\nIt tunrned out that struct bt_le_per_adv_sync_synced_info sync_info\ninside bt_hci_le_past_received_common() contains uninitialized\nrecv_enabled member.\nSet it to true by default to avoid possible issues."
},{
  "instruction": "There is an issue in the following code. It relates to ipc: ipc_service: backends: use MBOX_DT_INST_CHANNEL_GET\n\nInstead of MBOX_DT_CHANNEL_GET(DT_DRV_INST(i), ...). Please fix this issue.",
  "input": "Faulty tokenized code:\nname|DEFINE_BACKEND_DEVICE\nparameter_list|(\nname|i\nparameter_list|)\ndefine|\\\nvalue|SYS_BITARRAY_DEFINE_STATIC(tx_usage_bitmap_##i, DT_INST_PROP(i, tx_blocks));\t\\ \tSYS_BITARRAY_DEFINE_STATIC(rx_hold_bitmap_##i, DT_INST_PROP(i, rx_blocks));\t\\ \tPBUF_DEFINE(tx_icbmsg_pb_##i,\t\t\t\t\t\t\t\\ \t\t\tGET_MEM_ADDR_INST(i, tx),\t\t\t\t\t\\ \t\t\tGET_ICMSG_SIZE_INST(i, tx, rx),\t\t\t\t\t\\ \t\t\tGET_CACHE_ALIGNMENT(i));\t\t\t\t\t\\ \tPBUF_DEFINE(rx_icbmsg_pb_##i,\t\t\t\t\t\t\t\\ \t\t\tGET_MEM_ADDR_INST(i, rx),\t\t\t\t\t\\ \t\t\tGET_ICMSG_SIZE_INST(i, rx, tx),\t\t\t\t\t\\ \t\t\tGET_CACHE_ALIGNMENT(i));\t\t\t\t\t\\ \tstatic struct backend_data backend_data_##i = {\t\t\t\t\t\\ \t\t.control_data = {\t\t\t\t\t\t\t\\ \t\t\t.tx_pb =&tx_icbmsg_pb_##i,\t\t\t\t\t\\ \t\t\t.rx_pb =&rx_icbmsg_pb_##i,\t\t\t\t\t\\ \t\t}\t\t\t\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct icbmsg_config backend_config_##i =\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\t\t\\ \t\t.control_config = {\t\t\t\t\t\t\t\\ \t\t\t.mbox_tx = MBOX_DT_CHANNEL_GET(DT_DRV_INST(i), tx),\t\t\\ \t\t\t.mbox_rx = MBOX_DT_CHANNEL_GET(DT_DRV_INST(i), rx),\t\t\\ \t\t},\t\t\t\t\t\t\t\t\t\\ \t\t.tx = {\t\t\t\t\t\t\t\t\t\\ \t\t\t.blocks_ptr = (uint8_t *)GET_BLOCKS_ADDR_INST(i, tx, rx),\t\\ \t\t\t.block_count = DT_INST_PROP(i, tx_blocks),\t\t\t\\ \t\t\t.block_size = GET_BLOCK_SIZE_INST(i, tx, rx),\t\t\t\\ \t\t},\t\t\t\t\t\t\t\t\t\\ \t\t.rx = {\t\t\t\t\t\t\t\t\t\\ \t\t\t.blocks_ptr = (uint8_t *)GET_BLOCKS_ADDR_INST(i, rx, tx),\t\\ \t\t\t.block_count = DT_INST_PROP(i, rx_blocks),\t\t\t\\ \t\t\t.block_size = GET_BLOCK_SIZE_INST(i, rx, tx),\t\t\t\\ \t\t},\t\t\t\t\t\t\t\t\t\\ \t\t.tx_usage_bitmap =&tx_usage_bitmap_##i,\t\t\t\t\\ \t\t.rx_hold_bitmap =&rx_hold_bitmap_##i,\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \tBUILD_ASSERT(IS_POWER_OF_TWO(GET_CACHE_ALIGNMENT(i)),\t\t\t\t\\ \t\t     \"This module supports only power of two cache alignment\");\t\t\\ \tBUILD_ASSERT((GET_BLOCK_SIZE_INST(i, tx, rx)> GET_CACHE_ALIGNMENT(i))&&\t\\ \t\t     (GET_BLOCK_SIZE_INST(i, tx, rx)<\t\t\t\t\t\\ \t\t      GET_MEM_SIZE_INST(i, tx)),\t\t\t\t\t\\ \t\t     \"TX region is too small for provided number of blocks\");\t\t\\ \tBUILD_ASSERT((GET_BLOCK_SIZE_INST(i, rx, tx)> GET_CACHE_ALIGNMENT(i))&&\t\\ \t\t     (GET_BLOCK_SIZE_INST(i, rx, tx)<\t\t\t\t\t\\ \t\t      GET_MEM_SIZE_INST(i, rx)),\t\t\t\t\t\\ \t\t     \"RX region is too small for provided number of blocks\");\t\t\\ \tBUILD_ASSERT(DT_INST_PROP(i, rx_blocks)<= 256, \"Too many RX blocks\");\t\t\\ \tBUILD_ASSERT(DT_INST_PROP(i, tx_blocks)<= 256, \"Too many TX blocks\");\t\t\\ \tDEVICE_DT_INST_DEFINE(i,\t\t\t\t\t\t\t\\&backend_init,\t\t\t\t\t\t\\ \t\t\t      NULL,\t\t\t\t\t\t\t\\&backend_data_##i,\t\t\t\t\t\\&backend_config_##i,\t\t\t\t\t\\ \t\t\t      POST_KERNEL,\t\t\t\t\t\t\\ \t\t\t      CONFIG_IPC_SERVICE_REG_BACKEND_PRIORITY,\t\t\t\\&backend_ops);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(\nname|DEFINE_BACKEND_DEVICE\nparameter_list|(\nname|i\nparameter_list|)\ndefine|\\\nvalue|static const struct icmsg_config_t backend_config_##i = {\t\\ \t\t.mbox_tx = MBOX_DT_CHANNEL_GET(DT_DRV_INST(i), tx),\t\\ \t\t.mbox_rx = MBOX_DT_CHANNEL_GET(DT_DRV_INST(i), rx),\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tPBUF_DEFINE(tx_pb_##i,\t\t\t\t\t\t\\ \t\t\tDT_REG_ADDR(DT_INST_PHANDLE(i, tx_region)),\t\\ \t\t\tDT_REG_SIZE(DT_INST_PHANDLE(i, tx_region)),\t\\ \t\t\tDT_INST_PROP_OR(i, dcache_alignment, 0));\t\\ \tPBUF_DEFINE(rx_pb_##i,\t\t\t\t\t\t\\ \t\t\tDT_REG_ADDR(DT_INST_PHANDLE(i, rx_region)),\t\\ \t\t\tDT_REG_SIZE(DT_INST_PHANDLE(i, rx_region)),\t\\ \t\t\tDT_INST_PROP_OR(i, dcache_alignment, 0));\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic struct icmsg_data_t backend_data_##i = {\t\t\t\\ \t\t.tx_pb =&tx_pb_##i,\t\t\t\t\t\\ \t\t.rx_pb =&rx_pb_##i,\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(i,\t\t\t\t\t\\&backend_init,\t\t\t\t\t\\ \t\t\t NULL,\t\t\t\t\t\t\\&backend_data_##i,\t\t\t\t\\&backend_config_##i,\t\t\t\t\\ \t\t\t POST_KERNEL,\t\t\t\t\t\\ \t\t\t CONFIG_IPC_SERVICE_REG_BACKEND_PRIORITY,\t\\&backend_ops);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(\nname|DEFINE_BACKEND_DEVICE\nparameter_list|(\nname|i\nparameter_list|)\ndefine|\\\nvalue|static const struct icmsg_config_t backend_config_##i = {\t\t\\ \t\t.mbox_tx = MBOX_DT_CHANNEL_GET(DT_DRV_INST(i), tx),\t\t\\ \t\t.mbox_rx = MBOX_DT_CHANNEL_GET(DT_DRV_INST(i), rx),\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tPBUF_DEFINE(tx_pb_##i,\t\t\t\t\t\t\t\\ \t\t\tDT_REG_ADDR(DT_INST_PHANDLE(i, tx_region)),\t\t\\ \t\t\tDT_REG_SIZE(DT_INST_PHANDLE(i, tx_region)),\t\t\\ \t\t\tDT_INST_PROP_OR(i, dcache_alignment, 0));\t\t\\ \tPBUF_DEFINE(rx_pb_##i,\t\t\t\t\t\t\t\\ \t\t\tDT_REG_ADDR(DT_INST_PHANDLE(i, rx_region)),\t\t\\ \t\t\tDT_REG_SIZE(DT_INST_PHANDLE(i, rx_region)),\t\t\\ \t\t\tDT_INST_PROP_OR(i, dcache_alignment, 0));\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic struct backend_data_t backend_data_##i = {\t\t\t\\ \t\t.icmsg_me_data = {\t\t\t\t\t\t\\ \t\t\t.icmsg_data = {\t\t\t\t\t\t\\ \t\t\t\t.tx_pb =&tx_pb_##i,\t\t\t\t\\ \t\t\t\t.rx_pb =&rx_pb_##i,\t\t\t\t\\ \t\t\t}\t\t\t\t\t\t\t\\ \t\t}\t\t\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(i,\t\t\t\t\t\t\\&backend_init,\t\t\t\t\t\t\\ \t\t\t NULL,\t\t\t\t\t\t\t\\&backend_data_##i,\t\t\t\t\t\\&backend_config_##i,\t\t\t\t\t\\ \t\t\t POST_KERNEL,\t\t\t\t\t\t\\ \t\t\t CONFIG_IPC_SERVICE_REG_BACKEND_PRIORITY,\t\t\\&backend_ops);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(\nname|DEFINE_BACKEND_DEVICE\nparameter_list|(\nname|i\nparameter_list|)\ndefine|\\\nvalue|static const struct icmsg_config_t backend_config_##i = {\t\t\\ \t\t.mbox_tx = MBOX_DT_CHANNEL_GET(DT_DRV_INST(i), tx),\t\t\\ \t\t.mbox_rx = MBOX_DT_CHANNEL_GET(DT_DRV_INST(i), rx),\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tPBUF_DEFINE(tx_pb_##i,\t\t\t\t\t\t\t\\ \t\t\tDT_REG_ADDR(DT_INST_PHANDLE(i, tx_region)),\t\t\\ \t\t\tDT_REG_SIZE(DT_INST_PHANDLE(i, tx_region)),\t\t\\ \t\t\tDT_INST_PROP_OR(i, dcache_alignment, 0));\t\t\\ \tPBUF_DEFINE(rx_pb_##i,\t\t\t\t\t\t\t\\ \t\t\tDT_REG_ADDR(DT_INST_PHANDLE(i, rx_region)),\t\t\\ \t\t\tDT_REG_SIZE(DT_INST_PHANDLE(i, rx_region)),\t\t\\ \t\t\tDT_INST_PROP_OR(i, dcache_alignment, 0));\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic struct backend_data_t backend_data_##i = {\t\t\t\\ \t\t.icmsg_me_data = {\t\t\t\t\t\t\\ \t\t\t.icmsg_data = {\t\t\t\t\t\t\\ \t\t\t\t.tx_pb =&tx_pb_##i,\t\t\t\t\\ \t\t\t\t.rx_pb =&rx_pb_##i,\t\t\t\t\\ \t\t\t}\t\t\t\t\t\t\t\\ \t\t}\t\t\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(i,\t\t\t\t\t\t\\&backend_init,\t\t\t\t\t\t\\ \t\t\t NULL,\t\t\t\t\t\t\t\\&backend_data_##i,\t\t\t\t\t\\&backend_config_##i,\t\t\t\t\t\\ \t\t\t POST_KERNEL,\t\t\t\t\t\t\\ \t\t\t CONFIG_IPC_SERVICE_REG_BACKEND_PRIORITY,\t\t\\&backend_ops);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(\nname|DEFINE_BACKEND_DEVICE\nparameter_list|(\nname|i\nparameter_list|)\ndefine|\\\nvalue|BACKEND_PRE(i)\t\t\t\t\t\t\t\t\t\\ \tstatic struct backend_config_t backend_config_##i = {\t\t\t\t\\ \t\t.role = DT_ENUM_IDX_OR(DT_DRV_INST(i), role, ROLE_HOST),\t\t\\ \t\t.shm_size = DT_REG_SIZE(DT_INST_PHANDLE(i, memory_region)),\t\t\\ \t\t.shm_addr = BACKEND_SHM_ADDR(i),\t\t\t\t\t\\ \t\t.mbox_tx = MBOX_DT_CHANNEL_GET(DT_DRV_INST(i), tx),\t\t\t\\ \t\t.mbox_rx = MBOX_DT_CHANNEL_GET(DT_DRV_INST(i), rx),\t\t\t\\ \t\t.wq_prio = COND_CODE_1(DT_INST_NODE_HAS_PROP(i, zephyr_priority),\t\\ \t\t\t   (DT_INST_PROP_BY_IDX(i, zephyr_priority, 0)),\t\t\\ \t\t\t   (0)),\t\t\t\t\t\t\t\\ \t\t.wq_prio_type = COND_CODE_1(DT_INST_NODE_HAS_PROP(i, zephyr_priority),\t\\ \t\t\t   (DT_INST_PROP_BY_IDX(i, zephyr_priority, 1)),\t\t\\ \t\t\t   (PRIO_PREEMPT)),\t\t\t\t\t\t\\ \t\t.buffer_size = DT_INST_PROP_OR(i, zephyr_buffer_size,\t\t\t\\ \t\t\t\t\t       RPMSG_BUFFER_SIZE),\t\t\t\\ \t\t.id = i,\t\t\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct backend_data_t backend_data_##i;\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(i,\t\t\t\t\t\t\t\\&backend_init,\t\t\t\t\t\t\t\\ \t\t\t NULL,\t\t\t\t\t\t\t\t\\&backend_data_##i,\t\t\t\t\t\t\\&backend_config_##i,\t\t\t\t\t\t\\ \t\t\t POST_KERNEL,\t\t\t\t\t\t\t\\ \t\t\t CONFIG_IPC_SERVICE_REG_BACKEND_PRIORITY,\t\t\t\\&backend_ops);\nend_define\n\nbegin_macro\nDECL|function|DT_INST_FOREACH_STATUS_OKAY (DEFINE_BACKEND_DEVICE)\nname|DT_INST_FOREACH_STATUS_OKAY",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|SYS_BITARRAY_DEFINE_STATIC(tx_usage_bitmap_##i, DT_INST_PROP(i, tx_blocks));\t\\ \tSYS_BITARRAY_DEFINE_STATIC(rx_hold_bitmap_##i, DT_INST_PROP(i, rx_blocks));\t\\ \tPBUF_DEFINE(tx_icbmsg_pb_##i,\t\t\t\t\t\t\t\\ \t\t\tGET_MEM_ADDR_INST(i, tx),\t\t\t\t\t\\ \t\t\tGET_ICMSG_SIZE_INST(i, tx, rx),\t\t\t\t\t\\ \t\t\tGET_CACHE_ALIGNMENT(i));\t\t\t\t\t\\ \tPBUF_DEFINE(rx_icbmsg_pb_##i,\t\t\t\t\t\t\t\\ \t\t\tGET_MEM_ADDR_INST(i, rx),\t\t\t\t\t\\ \t\t\tGET_ICMSG_SIZE_INST(i, rx, tx),\t\t\t\t\t\\ \t\t\tGET_CACHE_ALIGNMENT(i));\t\t\t\t\t\\ \tstatic struct backend_data backend_data_##i = {\t\t\t\t\t\\ \t\t.control_data = {\t\t\t\t\t\t\t\\ \t\t\t.tx_pb =&tx_icbmsg_pb_##i,\t\t\t\t\t\\ \t\t\t.rx_pb =&rx_icbmsg_pb_##i,\t\t\t\t\t\\ \t\t}\t\t\t\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct icbmsg_config backend_config_##i =\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\t\t\\ \t\t.control_config = {\t\t\t\t\t\t\t\\ \t\t\t.mbox_tx = MBOX_DT_CHANNEL_GET(DT_DRV_INST(i), tx),\t\t\\ \t\t\t.mbox_rx = MBOX_DT_CHANNEL_GET(DT_DRV_INST(i), rx),\t\t\\ \t\t},\t\t\t\t\t\t\t\t\t\\ \t\t.tx = {\t\t\t\t\t\t\t\t\t\\ \t\t\t.blocks_ptr = (uint8_t *)GET_BLOCKS_ADDR_INST(i, tx, rx),\t\\ \t\t\t.block_count = DT_INST_PROP(i, tx_blocks),\t\t\t\\ \t\t\t.block_size = GET_BLOCK_SIZE_INST(i, tx, rx),\t\t\t\\ \t\t},\t\t\t\t\t\t\t\t\t\\ \t\t.rx = {\t\t\t\t\t\t\t\t\t\\ \t\t\t.blocks_ptr = (uint8_t *)GET_BLOCKS_ADDR_INST(i, rx, tx),\t\\ \t\t\t.block_count = DT_INST_PROP(i, rx_blocks),\t\t\t\\ \t\t\t.block_size = GET_BLOCK_SIZE_INST(i, rx, tx),\t\t\t\\ \t\t},\t\t\t\t\t\t\t\t\t\\ \t\t.tx_usage_bitmap =&tx_usage_bitmap_##i,\t\t\t\t\\ \t\t.rx_hold_bitmap =&rx_hold_bitmap_##i,\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \tBUILD_ASSERT(IS_POWER_OF_TWO(GET_CACHE_ALIGNMENT(i)),\t\t\t\t\\ \t\t     \"This module supports only power of two cache alignment\");\t\t\\ \tBUILD_ASSERT((GET_BLOCK_SIZE_INST(i, tx, rx)> GET_CACHE_ALIGNMENT(i))&&\t\\ \t\t     (GET_BLOCK_SIZE_INST(i, tx, rx)<\t\t\t\t\t\\ \t\t      GET_MEM_SIZE_INST(i, tx)),\t\t\t\t\t\\ \t\t     \"TX region is too small for provided number of blocks\");\t\t\\ \tBUILD_ASSERT((GET_BLOCK_SIZE_INST(i, rx, tx)> GET_CACHE_ALIGNMENT(i))&&\t\\ \t\t     (GET_BLOCK_SIZE_INST(i, rx, tx)<\t\t\t\t\t\\ \t\t      GET_MEM_SIZE_INST(i, rx)),\t\t\t\t\t\\ \t\t     \"RX region is too small for provided number of blocks\");\t\t\\ \tBUILD_ASSERT(DT_INST_PROP(i, rx_blocks)<= 256, \"Too many RX blocks\");\t\t\\ \tBUILD_ASSERT(DT_INST_PROP(i, tx_blocks)<= 256, \"Too many TX blocks\");\t\t\\ \tDEVICE_DT_INST_DEFINE(i,\t\t\t\t\t\t\t\\&backend_init,\t\t\t\t\t\t\\ \t\t\t      NULL,\t\t\t\t\t\t\t\\&backend_data_##i,\t\t\t\t\t\\&backend_config_##i,\t\t\t\t\t\\ \t\t\t      POST_KERNEL,\t\t\t\t\t\t\\ \t\t\t      CONFIG_IPC_SERVICE_REG_BACKEND_PRIORITY,\t\t\t\\&backend_ops);\n+value|SYS_BITARRAY_DEFINE_STATIC(tx_usage_bitmap_##i, DT_INST_PROP(i, tx_blocks));\t\\ \tSYS_BITARRAY_DEFINE_STATIC(rx_hold_bitmap_##i, DT_INST_PROP(i, rx_blocks));\t\\ \tPBUF_DEFINE(tx_icbmsg_pb_##i,\t\t\t\t\t\t\t\\ \t\t\tGET_MEM_ADDR_INST(i, tx),\t\t\t\t\t\\ \t\t\tGET_ICMSG_SIZE_INST(i, tx, rx),\t\t\t\t\t\\ \t\t\tGET_CACHE_ALIGNMENT(i));\t\t\t\t\t\\ \tPBUF_DEFINE(rx_icbmsg_pb_##i,\t\t\t\t\t\t\t\\ \t\t\tGET_MEM_ADDR_INST(i, rx),\t\t\t\t\t\\ \t\t\tGET_ICMSG_SIZE_INST(i, rx, tx),\t\t\t\t\t\\ \t\t\tGET_CACHE_ALIGNMENT(i));\t\t\t\t\t\\ \tstatic struct backend_data backend_data_##i = {\t\t\t\t\t\\ \t\t.control_data = {\t\t\t\t\t\t\t\\ \t\t\t.tx_pb =&tx_icbmsg_pb_##i,\t\t\t\t\t\\ \t\t\t.rx_pb =&rx_icbmsg_pb_##i,\t\t\t\t\t\\ \t\t}\t\t\t\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct icbmsg_config backend_config_##i =\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\t\t\\ \t\t.control_config = {\t\t\t\t\t\t\t\\ \t\t\t.mbox_tx = MBOX_DT_INST_CHANNEL_GET(i, tx),\t\t\t\\ \t\t\t.mbox_rx = MBOX_DT_INST_CHANNEL_GET(i, rx),\t\t\t\\ \t\t},\t\t\t\t\t\t\t\t\t\\ \t\t.tx = {\t\t\t\t\t\t\t\t\t\\ \t\t\t.blocks_ptr = (uint8_t *)GET_BLOCKS_ADDR_INST(i, tx, rx),\t\\ \t\t\t.block_count = DT_INST_PROP(i, tx_blocks),\t\t\t\\ \t\t\t.block_size = GET_BLOCK_SIZE_INST(i, tx, rx),\t\t\t\\ \t\t},\t\t\t\t\t\t\t\t\t\\ \t\t.rx = {\t\t\t\t\t\t\t\t\t\\ \t\t\t.blocks_ptr = (uint8_t *)GET_BLOCKS_ADDR_INST(i, rx, tx),\t\\ \t\t\t.block_count = DT_INST_PROP(i, rx_blocks),\t\t\t\\ \t\t\t.block_size = GET_BLOCK_SIZE_INST(i, rx, tx),\t\t\t\\ \t\t},\t\t\t\t\t\t\t\t\t\\ \t\t.tx_usage_bitmap =&tx_usage_bitmap_##i,\t\t\t\t\\ \t\t.rx_hold_bitmap =&rx_hold_bitmap_##i,\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \tBUILD_ASSERT(IS_POWER_OF_TWO(GET_CACHE_ALIGNMENT(i)),\t\t\t\t\\ \t\t     \"This module supports only power of two cache alignment\");\t\t\\ \tBUILD_ASSERT((GET_BLOCK_SIZE_INST(i, tx, rx)> GET_CACHE_ALIGNMENT(i))&&\t\\ \t\t     (GET_BLOCK_SIZE_INST(i, tx, rx)<\t\t\t\t\t\\ \t\t      GET_MEM_SIZE_INST(i, tx)),\t\t\t\t\t\\ \t\t     \"TX region is too small for provided number of blocks\");\t\t\\ \tBUILD_ASSERT((GET_BLOCK_SIZE_INST(i, rx, tx)> GET_CACHE_ALIGNMENT(i))&&\t\\ \t\t     (GET_BLOCK_SIZE_INST(i, rx, tx)<\t\t\t\t\t\\ \t\t      GET_MEM_SIZE_INST(i, rx)),\t\t\t\t\t\\ \t\t     \"RX region is too small for provided number of blocks\");\t\t\\ \tBUILD_ASSERT(DT_INST_PROP(i, rx_blocks)<= 256, \"Too many RX blocks\");\t\t\\ \tBUILD_ASSERT(DT_INST_PROP(i, tx_blocks)<= 256, \"Too many TX blocks\");\t\t\\ \tDEVICE_DT_INST_DEFINE(i,\t\t\t\t\t\t\t\\&backend_init,\t\t\t\t\t\t\\ \t\t\t      NULL,\t\t\t\t\t\t\t\\&backend_data_##i,\t\t\t\t\t\\&backend_config_##i,\t\t\t\t\t\\ \t\t\t      POST_KERNEL,\t\t\t\t\t\t\\ \t\t\t      CONFIG_IPC_SERVICE_REG_BACKEND_PRIORITY,\t\t\t\\&backend_ops);\n-value|static const struct icmsg_config_t backend_config_##i = {\t\\ \t\t.mbox_tx = MBOX_DT_CHANNEL_GET(DT_DRV_INST(i), tx),\t\\ \t\t.mbox_rx = MBOX_DT_CHANNEL_GET(DT_DRV_INST(i), rx),\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tPBUF_DEFINE(tx_pb_##i,\t\t\t\t\t\t\\ \t\t\tDT_REG_ADDR(DT_INST_PHANDLE(i, tx_region)),\t\\ \t\t\tDT_REG_SIZE(DT_INST_PHANDLE(i, tx_region)),\t\\ \t\t\tDT_INST_PROP_OR(i, dcache_alignment, 0));\t\\ \tPBUF_DEFINE(rx_pb_##i,\t\t\t\t\t\t\\ \t\t\tDT_REG_ADDR(DT_INST_PHANDLE(i, rx_region)),\t\\ \t\t\tDT_REG_SIZE(DT_INST_PHANDLE(i, rx_region)),\t\\ \t\t\tDT_INST_PROP_OR(i, dcache_alignment, 0));\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic struct icmsg_data_t backend_data_##i = {\t\t\t\\ \t\t.tx_pb =&tx_pb_##i,\t\t\t\t\t\\ \t\t.rx_pb =&rx_pb_##i,\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(i,\t\t\t\t\t\\&backend_init,\t\t\t\t\t\\ \t\t\t NULL,\t\t\t\t\t\t\\&backend_data_##i,\t\t\t\t\\&backend_config_##i,\t\t\t\t\\ \t\t\t POST_KERNEL,\t\t\t\t\t\\ \t\t\t CONFIG_IPC_SERVICE_REG_BACKEND_PRIORITY,\t\\&backend_ops);\n+value|static const struct icmsg_config_t backend_config_##i = {\t\\ \t\t.mbox_tx = MBOX_DT_INST_CHANNEL_GET(i, tx),\t\t\\ \t\t.mbox_rx = MBOX_DT_INST_CHANNEL_GET(i, rx),\t\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tPBUF_DEFINE(tx_pb_##i,\t\t\t\t\t\t\\ \t\t\tDT_REG_ADDR(DT_INST_PHANDLE(i, tx_region)),\t\\ \t\t\tDT_REG_SIZE(DT_INST_PHANDLE(i, tx_region)),\t\\ \t\t\tDT_INST_PROP_OR(i, dcache_alignment, 0));\t\\ \tPBUF_DEFINE(rx_pb_##i,\t\t\t\t\t\t\\ \t\t\tDT_REG_ADDR(DT_INST_PHANDLE(i, rx_region)),\t\\ \t\t\tDT_REG_SIZE(DT_INST_PHANDLE(i, rx_region)),\t\\ \t\t\tDT_INST_PROP_OR(i, dcache_alignment, 0));\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic struct icmsg_data_t backend_data_##i = {\t\t\t\\ \t\t.tx_pb =&tx_pb_##i,\t\t\t\t\t\\ \t\t.rx_pb =&rx_pb_##i,\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(i,\t\t\t\t\t\\&backend_init,\t\t\t\t\t\\ \t\t\t NULL,\t\t\t\t\t\t\\&backend_data_##i,\t\t\t\t\\&backend_config_##i,\t\t\t\t\\ \t\t\t POST_KERNEL,\t\t\t\t\t\\ \t\t\t CONFIG_IPC_SERVICE_REG_BACKEND_PRIORITY,\t\\&backend_ops);\n-value|static const struct icmsg_config_t backend_config_##i = {\t\t\\ \t\t.mbox_tx = MBOX_DT_CHANNEL_GET(DT_DRV_INST(i), tx),\t\t\\ \t\t.mbox_rx = MBOX_DT_CHANNEL_GET(DT_DRV_INST(i), rx),\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tPBUF_DEFINE(tx_pb_##i,\t\t\t\t\t\t\t\\ \t\t\tDT_REG_ADDR(DT_INST_PHANDLE(i, tx_region)),\t\t\\ \t\t\tDT_REG_SIZE(DT_INST_PHANDLE(i, tx_region)),\t\t\\ \t\t\tDT_INST_PROP_OR(i, dcache_alignment, 0));\t\t\\ \tPBUF_DEFINE(rx_pb_##i,\t\t\t\t\t\t\t\\ \t\t\tDT_REG_ADDR(DT_INST_PHANDLE(i, rx_region)),\t\t\\ \t\t\tDT_REG_SIZE(DT_INST_PHANDLE(i, rx_region)),\t\t\\ \t\t\tDT_INST_PROP_OR(i, dcache_alignment, 0));\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic struct backend_data_t backend_data_##i = {\t\t\t\\ \t\t.icmsg_me_data = {\t\t\t\t\t\t\\ \t\t\t.icmsg_data = {\t\t\t\t\t\t\\ \t\t\t\t.tx_pb =&tx_pb_##i,\t\t\t\t\\ \t\t\t\t.rx_pb =&rx_pb_##i,\t\t\t\t\\ \t\t\t}\t\t\t\t\t\t\t\\ \t\t}\t\t\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(i,\t\t\t\t\t\t\\&backend_init,\t\t\t\t\t\t\\ \t\t\t NULL,\t\t\t\t\t\t\t\\&backend_data_##i,\t\t\t\t\t\\&backend_config_##i,\t\t\t\t\t\\ \t\t\t POST_KERNEL,\t\t\t\t\t\t\\ \t\t\t CONFIG_IPC_SERVICE_REG_BACKEND_PRIORITY,\t\t\\&backend_ops);\n+value|static const struct icmsg_config_t backend_config_##i = {\t\t\\ \t\t.mbox_tx = MBOX_DT_INST_CHANNEL_GET(i, tx),\t\t\t\\ \t\t.mbox_rx = MBOX_DT_INST_CHANNEL_GET(i, rx),\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tPBUF_DEFINE(tx_pb_##i,\t\t\t\t\t\t\t\\ \t\t\tDT_REG_ADDR(DT_INST_PHANDLE(i, tx_region)),\t\t\\ \t\t\tDT_REG_SIZE(DT_INST_PHANDLE(i, tx_region)),\t\t\\ \t\t\tDT_INST_PROP_OR(i, dcache_alignment, 0));\t\t\\ \tPBUF_DEFINE(rx_pb_##i,\t\t\t\t\t\t\t\\ \t\t\tDT_REG_ADDR(DT_INST_PHANDLE(i, rx_region)),\t\t\\ \t\t\tDT_REG_SIZE(DT_INST_PHANDLE(i, rx_region)),\t\t\\ \t\t\tDT_INST_PROP_OR(i, dcache_alignment, 0));\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic struct backend_data_t backend_data_##i = {\t\t\t\\ \t\t.icmsg_me_data = {\t\t\t\t\t\t\\ \t\t\t.icmsg_data = {\t\t\t\t\t\t\\ \t\t\t\t.tx_pb =&tx_pb_##i,\t\t\t\t\\ \t\t\t\t.rx_pb =&rx_pb_##i,\t\t\t\t\\ \t\t\t}\t\t\t\t\t\t\t\\ \t\t}\t\t\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(i,\t\t\t\t\t\t\\&backend_init,\t\t\t\t\t\t\\ \t\t\t NULL,\t\t\t\t\t\t\t\\&backend_data_##i,\t\t\t\t\t\\&backend_config_##i,\t\t\t\t\t\\ \t\t\t POST_KERNEL,\t\t\t\t\t\t\\ \t\t\t CONFIG_IPC_SERVICE_REG_BACKEND_PRIORITY,\t\t\\&backend_ops);\n-value|static const struct icmsg_config_t backend_config_##i = {\t\t\\ \t\t.mbox_tx = MBOX_DT_CHANNEL_GET(DT_DRV_INST(i), tx),\t\t\\ \t\t.mbox_rx = MBOX_DT_CHANNEL_GET(DT_DRV_INST(i), rx),\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tPBUF_DEFINE(tx_pb_##i,\t\t\t\t\t\t\t\\ \t\t\tDT_REG_ADDR(DT_INST_PHANDLE(i, tx_region)),\t\t\\ \t\t\tDT_REG_SIZE(DT_INST_PHANDLE(i, tx_region)),\t\t\\ \t\t\tDT_INST_PROP_OR(i, dcache_alignment, 0));\t\t\\ \tPBUF_DEFINE(rx_pb_##i,\t\t\t\t\t\t\t\\ \t\t\tDT_REG_ADDR(DT_INST_PHANDLE(i, rx_region)),\t\t\\ \t\t\tDT_REG_SIZE(DT_INST_PHANDLE(i, rx_region)),\t\t\\ \t\t\tDT_INST_PROP_OR(i, dcache_alignment, 0));\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic struct backend_data_t backend_data_##i = {\t\t\t\\ \t\t.icmsg_me_data = {\t\t\t\t\t\t\\ \t\t\t.icmsg_data = {\t\t\t\t\t\t\\ \t\t\t\t.tx_pb =&tx_pb_##i,\t\t\t\t\\ \t\t\t\t.rx_pb =&rx_pb_##i,\t\t\t\t\\ \t\t\t}\t\t\t\t\t\t\t\\ \t\t}\t\t\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(i,\t\t\t\t\t\t\\&backend_init,\t\t\t\t\t\t\\ \t\t\t NULL,\t\t\t\t\t\t\t\\&backend_data_##i,\t\t\t\t\t\\&backend_config_##i,\t\t\t\t\t\\ \t\t\t POST_KERNEL,\t\t\t\t\t\t\\ \t\t\t CONFIG_IPC_SERVICE_REG_BACKEND_PRIORITY,\t\t\\&backend_ops);\n+value|static const struct icmsg_config_t backend_config_##i = {\t\t\\ \t\t.mbox_tx = MBOX_DT_INST_CHANNEL_GET(i, tx),\t\t\t\\ \t\t.mbox_rx = MBOX_DT_INST_CHANNEL_GET(i, rx),\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tPBUF_DEFINE(tx_pb_##i,\t\t\t\t\t\t\t\\ \t\t\tDT_REG_ADDR(DT_INST_PHANDLE(i, tx_region)),\t\t\\ \t\t\tDT_REG_SIZE(DT_INST_PHANDLE(i, tx_region)),\t\t\\ \t\t\tDT_INST_PROP_OR(i, dcache_alignment, 0));\t\t\\ \tPBUF_DEFINE(rx_pb_##i,\t\t\t\t\t\t\t\\ \t\t\tDT_REG_ADDR(DT_INST_PHANDLE(i, rx_region)),\t\t\\ \t\t\tDT_REG_SIZE(DT_INST_PHANDLE(i, rx_region)),\t\t\\ \t\t\tDT_INST_PROP_OR(i, dcache_alignment, 0));\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic struct backend_data_t backend_data_##i = {\t\t\t\\ \t\t.icmsg_me_data = {\t\t\t\t\t\t\\ \t\t\t.icmsg_data = {\t\t\t\t\t\t\\ \t\t\t\t.tx_pb =&tx_pb_##i,\t\t\t\t\\ \t\t\t\t.rx_pb =&rx_pb_##i,\t\t\t\t\\ \t\t\t}\t\t\t\t\t\t\t\\ \t\t}\t\t\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(i,\t\t\t\t\t\t\\&backend_init,\t\t\t\t\t\t\\ \t\t\t NULL,\t\t\t\t\t\t\t\\&backend_data_##i,\t\t\t\t\t\\&backend_config_##i,\t\t\t\t\t\\ \t\t\t POST_KERNEL,\t\t\t\t\t\t\\ \t\t\t CONFIG_IPC_SERVICE_REG_BACKEND_PRIORITY,\t\t\\&backend_ops);\n-value|BACKEND_PRE(i)\t\t\t\t\t\t\t\t\t\\ \tstatic struct backend_config_t backend_config_##i = {\t\t\t\t\\ \t\t.role = DT_ENUM_IDX_OR(DT_DRV_INST(i), role, ROLE_HOST),\t\t\\ \t\t.shm_size = DT_REG_SIZE(DT_INST_PHANDLE(i, memory_region)),\t\t\\ \t\t.shm_addr = BACKEND_SHM_ADDR(i),\t\t\t\t\t\\ \t\t.mbox_tx = MBOX_DT_CHANNEL_GET(DT_DRV_INST(i), tx),\t\t\t\\ \t\t.mbox_rx = MBOX_DT_CHANNEL_GET(DT_DRV_INST(i), rx),\t\t\t\\ \t\t.wq_prio = COND_CODE_1(DT_INST_NODE_HAS_PROP(i, zephyr_priority),\t\\ \t\t\t   (DT_INST_PROP_BY_IDX(i, zephyr_priority, 0)),\t\t\\ \t\t\t   (0)),\t\t\t\t\t\t\t\\ \t\t.wq_prio_type = COND_CODE_1(DT_INST_NODE_HAS_PROP(i, zephyr_priority),\t\\ \t\t\t   (DT_INST_PROP_BY_IDX(i, zephyr_priority, 1)),\t\t\\ \t\t\t   (PRIO_PREEMPT)),\t\t\t\t\t\t\\ \t\t.buffer_size = DT_INST_PROP_OR(i, zephyr_buffer_size,\t\t\t\\ \t\t\t\t\t       RPMSG_BUFFER_SIZE),\t\t\t\\ \t\t.id = i,\t\t\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct backend_data_t backend_data_##i;\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(i,\t\t\t\t\t\t\t\\&backend_init,\t\t\t\t\t\t\t\\ \t\t\t NULL,\t\t\t\t\t\t\t\t\\&backend_data_##i,\t\t\t\t\t\t\\&backend_config_##i,\t\t\t\t\t\t\\ \t\t\t POST_KERNEL,\t\t\t\t\t\t\t\\ \t\t\t CONFIG_IPC_SERVICE_REG_BACKEND_PRIORITY,\t\t\t\\&backend_ops);\n+value|BACKEND_PRE(i)\t\t\t\t\t\t\t\t\t\\ \tstatic struct backend_config_t backend_config_##i = {\t\t\t\t\\ \t\t.role = DT_ENUM_IDX_OR(DT_DRV_INST(i), role, ROLE_HOST),\t\t\\ \t\t.shm_size = DT_REG_SIZE(DT_INST_PHANDLE(i, memory_region)),\t\t\\ \t\t.shm_addr = BACKEND_SHM_ADDR(i),\t\t\t\t\t\\ \t\t.mbox_tx = MBOX_DT_INST_CHANNEL_GET(i, tx),\t\t\t\t\\ \t\t.mbox_rx = MBOX_DT_INST_CHANNEL_GET(i, rx),\t\t\t\t\\ \t\t.wq_prio = COND_CODE_1(DT_INST_NODE_HAS_PROP(i, zephyr_priority),\t\\ \t\t\t   (DT_INST_PROP_BY_IDX(i, zephyr_priority, 0)),\t\t\\ \t\t\t   (0)),\t\t\t\t\t\t\t\\ \t\t.wq_prio_type = COND_CODE_1(DT_INST_NODE_HAS_PROP(i, zephyr_priority),\t\\ \t\t\t   (DT_INST_PROP_BY_IDX(i, zephyr_priority, 1)),\t\t\\ \t\t\t   (PRIO_PREEMPT)),\t\t\t\t\t\t\\ \t\t.buffer_size = DT_INST_PROP_OR(i, zephyr_buffer_size,\t\t\t\\ \t\t\t\t\t       RPMSG_BUFFER_SIZE),\t\t\t\\ \t\t.id = i,\t\t\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct backend_data_t backend_data_##i;\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(i,\t\t\t\t\t\t\t\\&backend_init,\t\t\t\t\t\t\t\\ \t\t\t NULL,\t\t\t\t\t\t\t\t\\&backend_data_##i,\t\t\t\t\t\t\\&backend_config_##i,\t\t\t\t\t\t\\ \t\t\t POST_KERNEL,\t\t\t\t\t\t\t\\ \t\t\t CONFIG_IPC_SERVICE_REG_BACKEND_PRIORITY,\t\t\t\\&backend_ops);\nThe issue was with: ipc: ipc_service: backends: use MBOX_DT_INST_CHANNEL_GET\n\nInstead of MBOX_DT_CHANNEL_GET(DT_DRV_INST(i), ...)."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: mbox: nxp_mailbox: add missing include\n\nAdd irq.h for IRQ_CONNECT. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/drivers/mbox.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/sys/util_macro.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/irq.h>\n+end_include\n+\nThe issue was with: drivers: mbox: nxp_mailbox: add missing include\n\nAdd irq.h for IRQ_CONNECT."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: mbox: nxp_imx_mu: add missing include\n\nWas causing build failures with IRQ_CONNECT missing. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/drivers/mbox.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/sys/util_macro.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/irq.h>\n+end_include\n+\nThe issue was with: drivers: mbox: nxp_imx_mu: add missing include\n\nWas causing build failures with IRQ_CONNECT missing."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: mbox: andes_plic_sw: add missing include\n\nDriver used spinlocks without including the necessary headers. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/irq.h>\nend_include\n\nbegin_expr_stmt\nname|LOG_MODULE_REGISTER\nargument_list|(\nname|mbox_andes_plic_sw\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/spinlock.h>\n+end_include\n+\nThe issue was with: drivers: mbox: andes_plic_sw: add missing include\n\nDriver used spinlocks without including the necessary headers."
},{
  "instruction": "There is an issue in the following code. It relates to samples: drivers: crypto: Put keys in ROM\n\nThis change reduces the RAM consumption. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|endif\nend_endif\n\nbegin_decl_stmt\nDECL|variable|key\nspecifier|static\nname|uint8_t\nname|key\nindex|[\nliteral|16\nmodifier|*\nname|dev\nparameter_list|)\nblock|{\ncomment|/* from FIPS-197 test vectors */\nname|uint8_t\nname|ecb_key\nindex|[\nliteral|16\nindex|]\nliteral|0xEE\nblock|,\nliteral|0xFF\nblock|}\ndecl_stmt|;\nspecifier|const\nname|uint8_t\nname|ecb_ciphertext\nindex|[\nliteral|16\nindex|]\ncomment|/* RFC 3610 test vector #1 */\nend_comment\n\nbegin_decl_stmt\nDECL|variable|ccm_key\nspecifier|static\nname|uint8_t\nname|ccm_key\nindex|[\nliteral|16\ncomment|/*  MACsec GCM-AES test vector 2.4.1 */\nend_comment\n\nbegin_decl_stmt\nDECL|variable|gcm_key\nspecifier|static\nname|uint8_t\nname|gcm_key\nindex|[\nliteral|16",
  "result": "I corrected the issue in the code by changing the following tokens:\n+specifier|const\n+specifier|const\n-specifier|const\n+specifier|const\n+specifier|const\nThe issue was with: samples: drivers: crypto: Put keys in ROM\n\nThis change reduces the RAM consumption."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: crypto: stm32: Allow immutable key\n\nThe passed key does not have to be modifiable. Adapting the signature to\nreflect this.\n\nThis allows the following commit to change cipher_ctx::key::bit_stream\nto be pointing to an immutable key. Please fix this issue.",
  "input": "Faulty tokenized code:\nindex|]\ndecl_stmt|;\nend_decl_stmt\n\nbegin_function\nDECL|function|copy_reverse_words (uint8_t * dst_buf,int dst_len,uint8_t * src_buf,int src_len)\nspecifier|static\nname|int\nname|copy_reverse_words\nparameter_list|(\nname|uint8_t\nname|dst_buf\nparameter_list|,\nname|int\nname|dst_len\nparameter_list|,\nname|uint8_t\nmodifier|*\nname|src_buf\nparameter_list|,\nname|int",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|copy_reverse_words (uint8_t * dst_buf,int dst_len,uint8_t * src_buf,int src_len)\n+DECL|function|copy_reverse_words (uint8_t * dst_buf,int dst_len,const uint8_t * src_buf,int src_len)\n+specifier|const\nThe issue was with: drivers: crypto: stm32: Allow immutable key\n\nThe passed key does not have to be modifiable. Adapting the signature to\nreflect this.\n\nThis allows the following commit to change cipher_ctx::key::bit_stream\nto be pointing to an immutable key."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: audio: BAP: set the past_avail status\n\nWhile refactoring the handling of callbacks the setting of past_avail\nstatus got deleted (and it was in the wrong place). Adding it back at\nthe correct place. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|;\nblock|}\nblock|}\nelse|else\nblock|{\nname|bap_broadcast_assistant_recv_state_removed\nargument_list|(\nname|conn\nargument_list|,\nliteral|0",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|broadcast_assistant\n+operator|.\n+name|past_avail\n+index|[\n+name|index\n+index|]\n+operator|=\n+name|false\n+expr_stmt|;\nThe issue was with: Bluetooth: audio: BAP: set the past_avail status\n\nWhile refactoring the handling of callbacks the setting of past_avail\nstatus got deleted (and it was in the wrong place). Adding it back at\nthe correct place."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: display: elcdif: Run clang-format\n\nRun clang-format before making changes Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|MCUX_ELCDIF_PIXEL_BYTES\nparameter_list|(\nname|id\nparameter_list|)\ndefine|\\\nvalue|(DISPLAY_BITS_PER_PIXEL(DT_INST_PROP(id, pixel_format)) / 8)\nend_define\n\nbegin_define\nDECL|macro|MCUX_ELCDIF_DEVICE_INIT (id)\nname|MCUX_ELCDIF_DEVICE_INIT\nparameter_list|(\nname|id\nparameter_list|)\ndefine|\\\nvalue|PINCTRL_DT_INST_DEFINE(id);\t\t\t\t\t\t\\ \tstatic void mcux_elcdif_config_func_##id(const struct device *dev);\t\\ \tstatic uint8_t __aligned(64) frame_buffer_##id[CONFIG_MCUX_ELCDIF_FB_NUM\\ \t\t\t* DT_INST_PROP(id, width)\t\t\t\t\\ \t\t\t* DT_INST_PROP(id, height)\t\t\t\t\\ \t\t\t* MCUX_ELCDIF_PIXEL_BYTES(id)];\t\t\t\t\\ \tstatic const struct mcux_elcdif_config mcux_elcdif_config_##id = {\t\\ \t\t.base = (LCDIF_Type *) DT_INST_REG_ADDR(id),\t\t\t\\ \t\t.irq_config_func = mcux_elcdif_config_func_##id,\t\t\\ \t\t.rgb_mode = {\t\t\t\t\t\t\t\\ \t\t\t.panelWidth = DT_INST_PROP(id, width),\t\t\t\\ \t\t\t.panelHeight = DT_INST_PROP(id, height),\t\t\\ \t\t\t.hsw = DT_PROP(DT_INST_CHILD(id, display_timings),\t\\ \t\t\t\t\t\t\thsync_len),\t\t\\ \t\t\t.hfp = DT_PROP(DT_INST_CHILD(id, display_timings),\t\\ \t\t\t\t\t\t\thfront_porch),\t\t\\ \t\t\t.hbp = DT_PROP(DT_INST_CHILD(id, display_timings),\t\\ \t\t\t\t\t\t\thback_porch),\t\t\\ \t\t\t.vsw = DT_PROP(DT_INST_CHILD(id, display_timings),\t\\ \t\t\t\t\t\tvsync_len),\t\t\t\\ \t\t\t.vfp = DT_PROP(DT_INST_CHILD(id, display_timings),\t\\ \t\t\t\t\t\tvfront_porch),\t\t\t\\ \t\t\t.vbp = DT_PROP(DT_INST_CHILD(id, display_timings),\t\\ \t\t\t\t\t\tvback_porch),\t\t\t\\ \t\t\t.polarityFlags = (DT_PROP(DT_INST_CHILD(id,\t\t\\ \t\t\t\t\tdisplay_timings), hsync_active) ?\t\\ \t\t\t\t\tkELCDIF_HsyncActiveHigh :\t\t\\ \t\t\t\t\tkELCDIF_HsyncActiveLow) |\t\t\\ \t\t\t\t(DT_PROP(DT_INST_CHILD(id,\t\t\t\\ \t\t\t\t\tdisplay_timings), vsync_active) ?\t\\ \t\t\t\t\tkELCDIF_VsyncActiveHigh :\t\t\\ \t\t\t\t\tkELCDIF_VsyncActiveLow) |\t\t\\ \t\t\t\t(DT_PROP(DT_INST_CHILD(id,\t\t\t\\ \t\t\t\t\tdisplay_timings), de_active) ?\t\t\\ \t\t\t\t\tkELCDIF_DataEnableActiveHigh :\t\t\\ \t\t\t\t\tkELCDIF_DataEnableActiveLow) |\t\t\\ \t\t\t\t(DT_PROP(DT_INST_CHILD(id,\t\t\t\\ \t\t\t\t\tdisplay_timings), pixelclk_active) ?\t\\ \t\t\t\t\tkELCDIF_DriveDataOnRisingClkEdge :\t\\ \t\t\t\t\tkELCDIF_DriveDataOnFallingClkEdge),\t\\ \t\t\t.dataBus = LCDIF_CTRL_LCD_DATABUS_WIDTH(\t\t\\ \t\t\t\t\tDT_INST_ENUM_IDX(id, data_bus_width)),\t\\ \t\t},\t\t\t\t\t\t\t\t\\ \t\t.pixel_format = DT_INST_PROP(id, pixel_format),\t\t\t\\ \t\t.pixel_bytes = MCUX_ELCDIF_PIXEL_BYTES(id),\t\t\t\\ \t\t.fb_bytes = DT_INST_PROP(id, width) * DT_INST_PROP(id, height)\t\\ \t\t\t* MCUX_ELCDIF_PIXEL_BYTES(id),\t\t\t\t\\ \t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(id),\t\t\t\\ \t\t.backlight_gpio = GPIO_DT_SPEC_INST_GET(id, backlight_gpios),\t\\ \t\t.fb_ptr = frame_buffer_##id,\t\t\t\t\t\\ \t\tIF_ENABLED(CONFIG_MCUX_ELCDIF_PXP,\t\t\t\t\\ \t\t(.pxp = DEVICE_DT_GET(DT_INST_PHANDLE(id, nxp_pxp)),))\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \tstatic struct mcux_elcdif_data mcux_elcdif_data_##id = {\t\t\\ \t\t.next_idx = 0,\t\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(id,\t\t\t\t\t\t\\&mcux_elcdif_init,\t\t\t\t\t\\ \t\t\t    NULL,\t\t\t\t\t\t\\&mcux_elcdif_data_##id,\t\t\t\t\\&mcux_elcdif_config_##id,\t\t\t\t\\ \t\t\t    POST_KERNEL,\t\t\t\t\t\\ \t\t\t    CONFIG_DISPLAY_INIT_PRIORITY,\t\t\t\\&mcux_elcdif_api);\t\t\t\t\t\\ \tstatic void mcux_elcdif_config_func_##id(const struct device *dev)\t\\ \t{\t\t\t\t\t\t\t\t\t\\ \t\tIRQ_CONNECT(DT_INST_IRQN(id),\t\t\t\t\t\\ \t\t\t    DT_INST_IRQ(id, priority),\t\t\t\t\\ \t\t\t    mcux_elcdif_isr,\t\t\t\t\t\\ \t\t\t    DEVICE_DT_INST_GET(id),\t\t\t\t\\ \t\t\t    0);\t\t\t\t\t\t\t\\ \t\tirq_enable(DT_INST_IRQN(id));\t\t\t\t\t\\ \t}\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-define|\\\n-value|PINCTRL_DT_INST_DEFINE(id);\t\t\t\t\t\t\\ \tstatic void mcux_elcdif_config_func_##id(const struct device *dev);\t\\ \tstatic uint8_t __aligned(64) frame_buffer_##id[CONFIG_MCUX_ELCDIF_FB_NUM\\ \t\t\t* DT_INST_PROP(id, width)\t\t\t\t\\ \t\t\t* DT_INST_PROP(id, height)\t\t\t\t\\ \t\t\t* MCUX_ELCDIF_PIXEL_BYTES(id)];\t\t\t\t\\ \tstatic const struct mcux_elcdif_config mcux_elcdif_config_##id = {\t\\ \t\t.base = (LCDIF_Type *) DT_INST_REG_ADDR(id),\t\t\t\\ \t\t.irq_config_func = mcux_elcdif_config_func_##id,\t\t\\ \t\t.rgb_mode = {\t\t\t\t\t\t\t\\ \t\t\t.panelWidth = DT_INST_PROP(id, width),\t\t\t\\ \t\t\t.panelHeight = DT_INST_PROP(id, height),\t\t\\ \t\t\t.hsw = DT_PROP(DT_INST_CHILD(id, display_timings),\t\\ \t\t\t\t\t\t\thsync_len),\t\t\\ \t\t\t.hfp = DT_PROP(DT_INST_CHILD(id, display_timings),\t\\ \t\t\t\t\t\t\thfront_porch),\t\t\\ \t\t\t.hbp = DT_PROP(DT_INST_CHILD(id, display_timings),\t\\ \t\t\t\t\t\t\thback_porch),\t\t\\ \t\t\t.vsw = DT_PROP(DT_INST_CHILD(id, display_timings),\t\\ \t\t\t\t\t\tvsync_len),\t\t\t\\ \t\t\t.vfp = DT_PROP(DT_INST_CHILD(id, display_timings),\t\\ \t\t\t\t\t\tvfront_porch),\t\t\t\\ \t\t\t.vbp = DT_PROP(DT_INST_CHILD(id, display_timings),\t\\ \t\t\t\t\t\tvback_porch),\t\t\t\\ \t\t\t.polarityFlags = (DT_PROP(DT_INST_CHILD(id,\t\t\\ \t\t\t\t\tdisplay_timings), hsync_active) ?\t\\ \t\t\t\t\tkELCDIF_HsyncActiveHigh :\t\t\\ \t\t\t\t\tkELCDIF_HsyncActiveLow) |\t\t\\ \t\t\t\t(DT_PROP(DT_INST_CHILD(id,\t\t\t\\ \t\t\t\t\tdisplay_timings), vsync_active) ?\t\\ \t\t\t\t\tkELCDIF_VsyncActiveHigh :\t\t\\ \t\t\t\t\tkELCDIF_VsyncActiveLow) |\t\t\\ \t\t\t\t(DT_PROP(DT_INST_CHILD(id,\t\t\t\\ \t\t\t\t\tdisplay_timings), de_active) ?\t\t\\ \t\t\t\t\tkELCDIF_DataEnableActiveHigh :\t\t\\ \t\t\t\t\tkELCDIF_DataEnableActiveLow) |\t\t\\ \t\t\t\t(DT_PROP(DT_INST_CHILD(id,\t\t\t\\ \t\t\t\t\tdisplay_timings), pixelclk_active) ?\t\\ \t\t\t\t\tkELCDIF_DriveDataOnRisingClkEdge :\t\\ \t\t\t\t\tkELCDIF_DriveDataOnFallingClkEdge),\t\\ \t\t\t.dataBus = LCDIF_CTRL_LCD_DATABUS_WIDTH(\t\t\\ \t\t\t\t\tDT_INST_ENUM_IDX(id, data_bus_width)),\t\\ \t\t},\t\t\t\t\t\t\t\t\\ \t\t.pixel_format = DT_INST_PROP(id, pixel_format),\t\t\t\\ \t\t.pixel_bytes = MCUX_ELCDIF_PIXEL_BYTES(id),\t\t\t\\ \t\t.fb_bytes = DT_INST_PROP(id, width) * DT_INST_PROP(id, height)\t\\ \t\t\t* MCUX_ELCDIF_PIXEL_BYTES(id),\t\t\t\t\\ \t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(id),\t\t\t\\ \t\t.backlight_gpio = GPIO_DT_SPEC_INST_GET(id, backlight_gpios),\t\\ \t\t.fb_ptr = frame_buffer_##id,\t\t\t\t\t\\ \t\tIF_ENABLED(CONFIG_MCUX_ELCDIF_PXP,\t\t\t\t\\ \t\t(.pxp = DEVICE_DT_GET(DT_INST_PHANDLE(id, nxp_pxp)),))\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \tstatic struct mcux_elcdif_data mcux_elcdif_data_##id = {\t\t\\ \t\t.next_idx = 0,\t\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(id,\t\t\t\t\t\t\\&mcux_elcdif_init,\t\t\t\t\t\\ \t\t\t    NULL,\t\t\t\t\t\t\\&mcux_elcdif_data_##id,\t\t\t\t\\&mcux_elcdif_config_##id,\t\t\t\t\\ \t\t\t    POST_KERNEL,\t\t\t\t\t\\ \t\t\t    CONFIG_DISPLAY_INIT_PRIORITY,\t\t\t\\&mcux_elcdif_api);\t\t\t\t\t\\ \tstatic void mcux_elcdif_config_func_##id(const struct device *dev)\t\\ \t{\t\t\t\t\t\t\t\t\t\\ \t\tIRQ_CONNECT(DT_INST_IRQN(id),\t\t\t\t\t\\ \t\t\t    DT_INST_IRQ(id, priority),\t\t\t\t\\ \t\t\t    mcux_elcdif_isr,\t\t\t\t\t\\ \t\t\t    DEVICE_DT_INST_GET(id),\t\t\t\t\\ \t\t\t    0);\t\t\t\t\t\t\t\\ \t\tirq_enable(DT_INST_IRQN(id));\t\t\t\t\t\\ \t}\n+value|PINCTRL_DT_INST_DEFINE(id);                                                                \\ \tstatic void mcux_elcdif_config_func_##id(const struct device *dev);                        \\ \tstatic uint8_t __aligned(64)                                                               \\ \t\tframe_buffer_##id[CONFIG_MCUX_ELCDIF_FB_NUM * DT_INST_PROP(id, width) *            \\ \t\t\t\t  DT_INST_PROP(id, height) * MCUX_ELCDIF_PIXEL_BYTES(id)];         \\ \tstatic const struct mcux_elcdif_config mcux_elcdif_config_##id = {                         \\ \t\t.base = (LCDIF_Type *)DT_INST_REG_ADDR(id),                                        \\ \t\t.irq_config_func = mcux_elcdif_config_func_##id,                                   \\ \t\t.rgb_mode =                                                                        \\ \t\t\t{                                                                          \\ \t\t\t\t.panelWidth = DT_INST_PROP(id, width),                             \\ \t\t\t\t.panelHeight = DT_INST_PROP(id, height),                           \\ \t\t\t\t.hsw = DT_PROP(DT_INST_CHILD(id, display_timings), hsync_len),     \\ \t\t\t\t.hfp = DT_PROP(DT_INST_CHILD(id, display_timings), hfront_porch),  \\ \t\t\t\t.hbp = DT_PROP(DT_INST_CHILD(id, display_timings), hback_porch),   \\ \t\t\t\t.vsw = DT_PROP(DT_INST_CHILD(id, display_timings), vsync_len),     \\ \t\t\t\t.vfp = DT_PROP(DT_INST_CHILD(id, display_timings), vfront_porch),  \\ \t\t\t\t.vbp = DT_PROP(DT_INST_CHILD(id, display_timings), vback_porch),   \\ \t\t\t\t.polarityFlags =                                                   \\ \t\t\t\t\t(DT_PROP(DT_INST_CHILD(id, display_timings), hsync_active) \\ \t\t\t\t\t\t ? kELCDIF_HsyncActiveHigh                         \\ \t\t\t\t\t\t : kELCDIF_HsyncActiveLow) |                       \\ \t\t\t\t\t(DT_PROP(DT_INST_CHILD(id, display_timings), vsync_active) \\ \t\t\t\t\t\t ? kELCDIF_VsyncActiveHigh                         \\ \t\t\t\t\t\t : kELCDIF_VsyncActiveLow) |                       \\ \t\t\t\t\t(DT_PROP(DT_INST_CHILD(id, display_timings), de_active)    \\ \t\t\t\t\t\t ? kELCDIF_DataEnableActiveHigh                    \\ \t\t\t\t\t\t : kELCDIF_DataEnableActiveLow) |                  \\ \t\t\t\t\t(DT_PROP(DT_INST_CHILD(id, display_timings),               \\ \t\t\t\t\t\t pixelclk_active)                                  \\ \t\t\t\t\t\t ? kELCDIF_DriveDataOnRisingClkEdge                \\ \t\t\t\t\t\t : kELCDIF_DriveDataOnFallingClkEdge),             \\ \t\t\t\t.dataBus = LCDIF_CTRL_LCD_DATABUS_WIDTH(                           \\ \t\t\t\t\tDT_INST_ENUM_IDX(id, data_bus_width)),                     \\ \t\t\t},                                                                         \\ \t\t.pixel_format = DT_INST_PROP(id, pixel_format),                                    \\ \t\t.pixel_bytes = MCUX_ELCDIF_PIXEL_BYTES(id),                                        \\ \t\t.fb_bytes = DT_INST_PROP(id, width) * DT_INST_PROP(id, height) *                   \\ \t\t\t    MCUX_ELCDIF_PIXEL_BYTES(id),                                           \\ \t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(id),                                      \\ \t\t.backlight_gpio = GPIO_DT_SPEC_INST_GET(id, backlight_gpios),                      \\ \t\t.fb_ptr = frame_buffer_##id,                                                       \\ \t\tIF_ENABLED(CONFIG_MCUX_ELCDIF_PXP,                                                 \\ \t\t\t   (.pxp = DEVICE_DT_GET(DT_INST_PHANDLE(id, nxp_pxp)),))};               \\ \tstatic struct mcux_elcdif_data mcux_elcdif_data_##id = {                                   \\ \t\t.next_idx = 0,                                                                     \\ \t};                                                                                         \\ \tDEVICE_DT_INST_DEFINE(id,&mcux_elcdif_init, NULL,&mcux_elcdif_data_##id,                 \\&mcux_elcdif_config_##id, POST_KERNEL, CONFIG_DISPLAY_INIT_PRIORITY, \\&mcux_elcdif_api);                                                   \\ \tstatic void mcux_elcdif_config_func_##id(const struct device *dev)                         \\ \t{                                                                                          \\ \t\tIRQ_CONNECT(DT_INST_IRQN(id), DT_INST_IRQ(id, priority), mcux_elcdif_isr,          \\ \t\t\t    DEVICE_DT_INST_GET(id), 0);                                            \\ \t\tirq_enable(DT_INST_IRQN(id));                                                      \\ \t}\nThe issue was with: drivers: display: elcdif: Run clang-format\n\nRun clang-format before making changes"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: dma: pxp: Run clang-format\n\nRun clang-format before making changes Please fix this issue.",
  "input": "Faulty tokenized code:\nname|DMA_INIT\nparameter_list|(\nname|n\nparameter_list|)\ndefine|\\\nvalue|static void dma_pxp_config_func##n(const struct device *dev)   \\ \t{\t\t\t\t\t\t\t       \\ \t\tIF_ENABLED(DT_INST_IRQ_HAS_IDX(n, 0), (\t\t       \\ \t\t\t   IRQ_CONNECT(DT_INST_IRQN(n),\t\t       \\ \t\t\t\t       DT_INST_IRQ(n, priority),       \\ \t\t\t\t       dma_mcux_pxp_irq_handler,       \\ \t\t\t\t       DEVICE_DT_INST_GET(n), 0);      \\ \t\t\t   irq_enable(DT_INST_IRQ(n, irq));\t       \\ \t\t\t   ))\t\t\t\t\t       \\ \t}\t\t\t\t\t\t\t       \\ \t\t\t\t\t\t\t\t       \\ \tstatic const struct dma_mcux_pxp_config dma_config_##n = {     \\ \t\t.base = (PXP_Type *)DT_INST_REG_ADDR(n),\t       \\ \t\t.irq_config_func = dma_pxp_config_func##n,\t       \\ \t};\t\t\t\t\t\t\t       \\ \t\t\t\t\t\t\t\t       \\ \tstatic struct dma_mcux_pxp_data dma_data_##n;\t\t       \\ \t\t\t\t\t\t\t\t       \\ \tDEVICE_DT_INST_DEFINE(n,\t\t\t\t       \\&dma_mcux_pxp_init, NULL,\t\t       \\&dma_data_##n,&dma_config_##n,\t       \\ \t\t\t      PRE_KERNEL_1, CONFIG_DMA_INIT_PRIORITY,  \\&dma_mcux_pxp_api);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|static void dma_pxp_config_func##n(const struct device *dev)   \\ \t{\t\t\t\t\t\t\t       \\ \t\tIF_ENABLED(DT_INST_IRQ_HAS_IDX(n, 0), (\t\t       \\ \t\t\t   IRQ_CONNECT(DT_INST_IRQN(n),\t\t       \\ \t\t\t\t       DT_INST_IRQ(n, priority),       \\ \t\t\t\t       dma_mcux_pxp_irq_handler,       \\ \t\t\t\t       DEVICE_DT_INST_GET(n), 0);      \\ \t\t\t   irq_enable(DT_INST_IRQ(n, irq));\t       \\ \t\t\t   ))\t\t\t\t\t       \\ \t}\t\t\t\t\t\t\t       \\ \t\t\t\t\t\t\t\t       \\ \tstatic const struct dma_mcux_pxp_config dma_config_##n = {     \\ \t\t.base = (PXP_Type *)DT_INST_REG_ADDR(n),\t       \\ \t\t.irq_config_func = dma_pxp_config_func##n,\t       \\ \t};\t\t\t\t\t\t\t       \\ \t\t\t\t\t\t\t\t       \\ \tstatic struct dma_mcux_pxp_data dma_data_##n;\t\t       \\ \t\t\t\t\t\t\t\t       \\ \tDEVICE_DT_INST_DEFINE(n,\t\t\t\t       \\&dma_mcux_pxp_init, NULL,\t\t       \\&dma_data_##n,&dma_config_##n,\t       \\ \t\t\t      PRE_KERNEL_1, CONFIG_DMA_INIT_PRIORITY,  \\&dma_mcux_pxp_api);\n+value|static void dma_pxp_config_func##n(const struct device *dev)                               \\ \t{                                                                                          \\ \t\tIF_ENABLED(DT_INST_IRQ_HAS_IDX(n, 0),                                              \\ \t\t\t   (IRQ_CONNECT(DT_INST_IRQN(n), DT_INST_IRQ(n, priority),                 \\ \t\t\t\t\tdma_mcux_pxp_irq_handler, DEVICE_DT_INST_GET(n), 0);       \\ \t\t\t    irq_enable(DT_INST_IRQ(n, irq));))                                     \\ \t}                                                                                          \\                                                                                                    \\ \tstatic const struct dma_mcux_pxp_config dma_config_##n = {                                 \\ \t\t.base = (PXP_Type *)DT_INST_REG_ADDR(n),                                           \\ \t\t.irq_config_func = dma_pxp_config_func##n,                                         \\ \t};                                                                                         \\                                                                                                    \\ \tstatic struct dma_mcux_pxp_data dma_data_##n;                                              \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(n,&dma_mcux_pxp_init, NULL,&dma_data_##n,&dma_config_##n,         \\ \t\t\t      PRE_KERNEL_1, CONFIG_DMA_INIT_PRIORITY,&dma_mcux_pxp_api);\nThe issue was with: drivers: dma: pxp: Run clang-format\n\nRun clang-format before making changes"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: ATT: lock scheduler when sending from user thread\n\n`att_req_send_process` is not thread safe.\n\nIn the case where the current context is pre-emptible (e.g. when a user\nsends something over GATT from the main thread):\n\nThe iterator in `att_req_send_process` can get interrupted mid-processing,\nbreaking the logic and resulting in an assert/crash/data corruption.\n\nAdditionally, the connection state check in this fn is also not\nthread-safe, the RX thread could pre-empt us and disconnect right before\nwe attempt to send on an ATT bearer that is on it.\n\nThis is a hotfix until we have a generalized solution for the host API\nsurface. It seems a lot of our logic assumes cooperative priority. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_enum\nDECL|enum|__anon27906cb40103\nenum|enum\nblock|{\nDECL|enumerator|ATT_CONNECTED\nname|ATT_CONNECTED\nblock|,\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_BT_EATT\nargument_list|)\nDECL|struct|__anon27906cb40208\nstruct|struct\nblock|{\nDECL|member|connection_work\nname|struct\nname|k_work_delayable\nname|struct\nname|bt_att_find_info_rsp\nmodifier|*\nname|rsp\ndecl_stmt|;\nDECL|union|__anon27906cb4030a\nunion|union\nblock|{\nDECL|member|info16\nname|struct\nname|bt_att_info_16\ndecl_stmt|,\nname|end_handle\ndecl_stmt|,\nname|err_handle\ndecl_stmt|;\nDECL|union|__anon27906cb4040a\nunion|union\nblock|{\nDECL|member|uuid\nname|struct\nname|bt_uuid\ndecl_stmt|,\nname|end_handle\ndecl_stmt|,\nname|err_handle\ndecl_stmt|;\nDECL|union|__anon27906cb4050a\nunion|union\nblock|{\nDECL|member|uuid\nname|struct\nname|bt_uuid\nname|__ASSERT_NO_MSG\nargument_list|(\nname|req\nargument_list|)\nexpr_stmt|;\nname|att\noperator|=\nname|att_get\nargument_list|(\nname|conn\ncondition|(\noperator|!\nname|att\ncondition|)\nblock|{\nreturn|return\noperator|-\nname|ENOTCONN\nreturn|;\nblock|}\nname|att_req_send_process\nargument_list|(\nname|att\nargument_list|)\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon27906cb40103\n+DECL|enum|__anon279863340103\n-DECL|struct|__anon27906cb40208\n+DECL|struct|__anon279863340208\n-DECL|union|__anon27906cb4030a\n+DECL|union|__anon27986334030a\n-DECL|union|__anon27906cb4040a\n+DECL|union|__anon27986334040a\n-DECL|union|__anon27906cb4050a\n+DECL|union|__anon27986334050a\n+name|k_sched_lock\n+argument_list|()\n+expr_stmt|;\n+name|k_sched_unlock\n+argument_list|()\n+expr_stmt|;\n+name|k_sched_unlock\n+argument_list|()\n+expr_stmt|;\nThe issue was with: Bluetooth: ATT: lock scheduler when sending from user thread\n\n`att_req_send_process` is not thread safe.\n\nIn the case where the current context is pre-emptible (e.g. when a user\nsends something over GATT from the main thread):\n\nThe iterator in `att_req_send_process` can get interrupted mid-processing,\nbreaking the logic and resulting in an assert/crash/data corruption.\n\nAdditionally, the connection state check in this fn is also not\nthread-safe, the RX thread could pre-empt us and disconnect right before\nwe attempt to send on an ATT bearer that is on it.\n\nThis is a hotfix until we have a generalized solution for the host API\nsurface. It seems a lot of our logic assumes cooperative priority."
},{
  "instruction": "There is an issue in the following code. It relates to samples: pong: k_thread_foreach needs CONFIG_THREAD_MONITOR\n\nWhen debugging and dumping thread related info, CONFIG_THREAD_MONITOR is\nneeded. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|game_stack_dump (const struct k_thread * thread,void * user_data)\nspecifier|static\nname|void\nname|game_stack_dump\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|game_refresh (struct k_work * work)\nspecifier|static\nname|void\nname|game_refresh\nname|sound_set\nargument_list|(\nname|SOUND_IDLE\nargument_list|)\nexpr_stmt|;\nname|k_thread_foreach\nargument_list|(\nname|game_stack_dump\nargument_list|,\nname|NULL\nargument_list|)\nexpr_stmt|;\nblock|}\nif|if\ncondition|(\nname|pg_state\noperator|==",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_if\n+if|#\n+directive|if\n+name|CONFIG_THREAD_MONITOR\n+end_if\n+\n+begin_endif\n+endif|#\n+directive|endif\n+end_endif\n+\n+if|#\n+directive|if\n+name|CONFIG_THREAD_MONITOR\n+endif|#\n+directive|endif\nThe issue was with: samples: pong: k_thread_foreach needs CONFIG_THREAD_MONITOR\n\nWhen debugging and dumping thread related info, CONFIG_THREAD_MONITOR is\nneeded."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: sched: z_set_prio -> z_thread_prio_set\n\nRename private function to make it clear what priority we are setting\nand to be consistent across the code. Please fix this issue.",
  "input": "Faulty tokenized code:\nfunction_decl|;\nend_function_decl\n\nbegin_function_decl\nname|bool\nname|z_set_prio\nparameter_list|(\nname|struct\nname|k_thread\nmodifier|*\nname|thread\noperator|.\nname|prio\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|z_set_prio\nargument_list|(\nname|mutex\noperator|->\nname|owner\nargument_list|,\nbegin_comment\ncomment|/* Priority set utility that does no rescheduling, it just changes the  * run queue state, returning true if a reschedule is needed later.  */\nend_comment\n\nbegin_function\nDECL|function|z_set_prio (struct k_thread * thread,int prio)\nname|bool\nname|z_set_prio\nparameter_list|(\nname|struct\nname|k_thread\nmodifier|*\nname|thread\nargument_list|)\nexpr_stmt|;\nname|bool\nname|need_sched\ninit|=\nname|z_set_prio\nargument_list|(\noperator|(\nexpr|struct\nname|k_thread\noperator|*",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|z_set_prio\n+name|z_thread_prio_set\n-name|z_set_prio\n+name|z_thread_prio_set\n-DECL|function|z_set_prio (struct k_thread * thread,int prio)\n+DECL|function|z_thread_prio_set (struct k_thread * thread,int prio)\n-name|z_set_prio\n+name|z_thread_prio_set\n-name|z_set_prio\n+name|z_thread_prio_set\nThe issue was with: kernel: sched: z_set_prio -> z_thread_prio_set\n\nRename private function to make it clear what priority we are setting\nand to be consistent across the code."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: remove cmsis-rtos layering violation\n\nWe shouldn't be calling hooks from optional and upper layer subsystems\nin the kernel, instead, just call the hook to set thread status in the\nAPI where it is needed.\n\nThis now clears related bit in cmsis thread status bitarray when\nterminating a thread in the cmsis rtos v1 layer directly and not in the\nkenrel code. Please fix this issue.",
  "input": "Faulty tokenized code:\n\tbool \"Thread stack info\"\n\thelp\n\t  This option allows each thread to store the thread stack info into\n\t  the k_thread data structure.\n\nconfig THREAD_CUSTOM_DATA\n\tbool \"Thread custom data\"\n\thelp\n\t  This option allows each thread to store 32 bits of custom data,\n\t  which can be accessed using the k_thread_custom_data_xxx() APIs.\nend_function\n\nbegin_ifdef\nifdef|#\ndirective|ifdef\nname|CONFIG_CMSIS_RTOS_V1\nend_ifdef\n\nbegin_function_decl\nspecifier|extern\nname|void\nname|z_thread_cmsis_status_mask_clear\nparameter_list|(\nname|struct\nname|k_thread\nmodifier|*\nname|thread\nname|thread\nargument_list|)\nexpr_stmt|;\nifdef|#\ndirective|ifdef\nname|CONFIG_CMSIS_RTOS_V1\nname|z_thread_cmsis_status_mask_clear\nargument_list|(\nname|thread\nargument_list|)\nexpr_stmt|;\nendif|#\nconfig CMSIS_RTOS_V1\n\tbool \"CMSIS RTOS v1 API\"\n\tdepends on THREAD_CUSTOM_DATA\n\tdepends on POLL\n\tdepends on THREAD_STACK_INFO\n\thelp\n\t  This enables CMSIS RTOS v1 API support. This is an OS-integration\n\t  layer which allows applications using CMSIS RTOS APIs to build on\n\t  Zephyr.\n\nbegin_comment\ncomment|/* clear related bit in cmsis thread status bitarray  * when terminating a thread  */\nend_comment\n\nbegin_function\nDECL|function|z_thread_cmsis_status_mask_clear (struct k_thread * thread)\nname|void\nname|z_thread_cmsis_status_mask_clear\nparameter_list|(\nname|struct\nname|k_thread\nmodifier|*\nname|thread",
  "result": "I corrected the issue in the code by changing the following tokens:\n+config THREAD_ABORT_HOOK\n+\tbool\n+\thelp\n+\t  Used by portability layers to modify locally managed status mask.\n+\n-name|CONFIG_CMSIS_RTOS_V1\n+name|CONFIG_THREAD_ABORT_HOOK\n-name|z_thread_cmsis_status_mask_clear\n+name|thread_abort_hook\n-name|CONFIG_CMSIS_RTOS_V1\n-name|z_thread_cmsis_status_mask_clear\n+name|CONFIG_THREAD_ABORT_HOOK\n+name|thread_abort_hook\n+\tselect THREAD_ABORT_HOOK\n-DECL|function|z_thread_cmsis_status_mask_clear (struct k_thread * thread)\n+DECL|function|thread_abort_hook (struct k_thread * thread)\n-name|z_thread_cmsis_status_mask_clear\n+name|thread_abort_hook\nThe issue was with: kernel: remove cmsis-rtos layering violation\n\nWe shouldn't be calling hooks from optional and upper layer subsystems\nin the kernel, instead, just call the hook to set thread status in the\nAPI where it is needed.\n\nThis now clears related bit in cmsis thread status bitarray when\nterminating a thread in the cmsis rtos v1 layer directly and not in the\nkenrel code."
},{
  "instruction": "There is an issue in the following code. It relates to tests: kernel: thread_runtime_stats: Relax precision test for QEMU\n\nThis commit relaxes the idle event statistics test precision requirement\nfor emulated QEMU targets because the cycle counts may be inaccurate when\nthe host CPU is overloaded (e.g. when running tests with twister) and a\nhigh failure rate is observed for this test in the CI. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|IDLE_EVENT_STATS_PRECISION\nvalue|7\nend_define\n\nbegin_else\nelse|#\ndirective|else\nend_else\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_elif\n+elif|#\n+directive|elif\n+name|defined\n+argument_list|(\n+name|CONFIG_QEMU_TARGET\n+argument_list|)\n+end_elif\n+\n+begin_define\n+DECL|macro|IDLE_EVENT_STATS_PRECISION\n+define|#\n+directive|define\n+name|IDLE_EVENT_STATS_PRECISION\n+value|3\n+end_define\n+\nThe issue was with: tests: kernel: thread_runtime_stats: Relax precision test for QEMU\n\nThis commit relaxes the idle event statistics test precision requirement\nfor emulated QEMU targets because the cycle counts may be inaccurate when\nthe host CPU is overloaded (e.g. when running tests with twister) and a\nhigh failure rate is observed for this test in the CI."
},{
  "instruction": "There is an issue in the following code. It relates to net: lib: shell: iface: Fix when building ethernet without IP support\n\nThe count stack variable is also used when CONFIG_NET_L2_ETHERNET_MGMT is\nenabled. Make sure it is available. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_NET_IP\nargument_list|)\nname|int\nname|count\ndecl_stmt|;\nendif|#\ndirective|endif",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|||\n+name|defined\n+argument_list|(\n+name|CONFIG_NET_L2_ETHERNET_MGMT\n+argument_list|)\nThe issue was with: net: lib: shell: iface: Fix when building ethernet without IP support\n\nThe count stack variable is also used when CONFIG_NET_L2_ETHERNET_MGMT is\nenabled. Make sure it is available."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: can: respect minimum supported prescaler value\n\nRespect the minimum supported prescaler value when calculating CAN timing. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|total_tq\noperator|*\nname|bitrate\noperator|)\nargument_list|,\nliteral|1\nargument_list|)\ninit|;\nname|prescaler\noperator|<=\nname|max",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|1\n+name|min\n+operator|->\n+name|prescaler\nThe issue was with: drivers: can: respect minimum supported prescaler value\n\nRespect the minimum supported prescaler value when calculating CAN timing."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: led_strip: ws2812_gpio: Rename in-gpios property to gpios\n\nws2812-gpio's `in-gpios` property is not used as an input pin.\nRenaming it to `gpios` to reflect the actual situation. Please fix this issue.",
  "input": "Faulty tokenized code:\n=====\n\nInterrupt Controller\n====================\n\nSensors\n=======\n\nSerial\n======\nbegin_struct\nDECL|struct|ws2812_gpio_cfg\nstruct|struct\nname|ws2812_gpio_cfg\nblock|{\nDECL|member|in_gpio\nname|struct\nname|gpio_dt_spec\nname|in_gpio\ndecl_stmt|;\nDECL|member|num_colors\nname|uint8_t\nname|num_colors\ndecl_stmt|;\ninit|=\nname|BIT\nargument_list|(\nname|config\noperator|->\nname|in_gpio\noperator|.\nname|pin\nargument_list|)\ndecl_stmt|;\nname|struct\nname|WS2812_GPIO_DEVICE\nparameter_list|(\nname|idx\nparameter_list|)\ndefine|\\ \t\t\t\t\t\t\t\t\t\\\nvalue|static int ws2812_gpio_##idx##_init(const struct device *dev)\t\\ \t{\t\t\t\t\t\t\t\t\\ \t\tconst struct ws2812_gpio_cfg *cfg = dev->config;\t\\ \t\tuint8_t i;\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \t\tif (!gpio_is_ready_dt(&cfg->in_gpio)) {\t\t\\ \t\t\tLOG_ERR(\"GPIO device not ready\");\t\t\\ \t\t\treturn -ENODEV;\t\t\t\t\t\\ \t\t}\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \t\tfor (i = 0; i< cfg->num_colors; i++) {\t\t\t\\ \t\t\tswitch (cfg->color_mapping[i]) {\t\t\\ \t\t\tcase LED_COLOR_ID_WHITE:\t\t\t\\ \t\t\tcase LED_COLOR_ID_RED:\t\t\t\t\\ \t\t\tcase LED_COLOR_ID_GREEN:\t\t\t\\ \t\t\tcase LED_COLOR_ID_BLUE:\t\t\t\t\\ \t\t\t\tbreak;\t\t\t\t\t\\ \t\t\tdefault:\t\t\t\t\t\\ \t\t\t\tLOG_ERR(\"%s: invalid channel to color mapping.\" \\ \t\t\t\t\t\" Check the color-mapping DT property\",\t\\ \t\t\t\t\tdev->name);\t\t\t\\ \t\t\t\treturn -EINVAL;\t\t\t\t\\ \t\t\t}\t\t\t\t\t\t\\ \t\t}\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \t\treturn gpio_pin_configure_dt(&cfg->in_gpio, GPIO_OUTPUT); \\ \t}\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tWS2812_COLOR_MAPPING(idx);\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic const struct ws2812_gpio_cfg ws2812_gpio_##idx##_cfg = { \\ \t\t.in_gpio = GPIO_DT_SPEC_INST_GET(idx, in_gpios),\t\\ \t\t.num_colors = WS2812_NUM_COLORS(idx),\t\t\t\\ \t\t.color_mapping = ws2812_gpio_##idx##_color_mapping,\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(idx,\t\t\t\t\t\\ \t\t\t    ws2812_gpio_##idx##_init,\t\t\t\\ \t\t\t    NULL,\t\t\t\t\t\\ \t\t\t    NULL,\t\t\t\t\t\\&ws2812_gpio_##idx##_cfg, POST_KERNEL,\t\\ \t\t\t    CONFIG_LED_STRIP_INIT_PRIORITY,\t\t\\&ws2812_gpio_api);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(\ncompatible: \"worldsemi,ws2812-gpio\"\n\ninclude: [base.yaml, ws2812.yaml]\n\nproperties:\n in-gpios:\n    type: phandle-array\n    required: true\n    description: |\n      GPIO phandle and specifier for the pin connected to the daisy\n      chain's input pin. Exactly one pin should be given.\n\t\tchain-length = <16>; /* arbitrary; change at will */\n\t\tcolor-mapping = <LED_COLOR_ID_GREEN\n\t\t\t\t LED_COLOR_ID_RED\n\t\t\t\t LED_COLOR_ID_BLUE>;\n\t\t/* P0: */\n\t\tin-gpios = <&gpio0 3 0>;\n\t};\n\n\taliases {\n\t\tled-strip = &led_strip;\n\t};\n\t\t\t\t LED_COLOR_ID_BLUE>;\n\t\t/*\n\t\t * Arduino D11 / P0.25, which was chosen to match the pin\n\t\t * used in nrf52dk_nrf52832.overlay.\n\t\t */\n\t\tin-gpios = <&gpio0 25 0>;\n\t};\n\n\taliases {\n\t\tled-strip = &led_strip;\n\t};",
  "result": "I corrected the issue in the code by changing the following tokens:\n+LED Strip\n+=========\n+\n+* The property ``in-gpios`` defined in :dtcompatible:`worldsemi,ws2812-gpio` has been\n+  renamed to ``gpios``.\n+\n-DECL|member|in_gpio\n+DECL|member|gpio\n-name|in_gpio\n+name|gpio\n-name|in_gpio\n+name|gpio\n-value|static int ws2812_gpio_##idx##_init(const struct device *dev)\t\\ \t{\t\t\t\t\t\t\t\t\\ \t\tconst struct ws2812_gpio_cfg *cfg = dev->config;\t\\ \t\tuint8_t i;\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \t\tif (!gpio_is_ready_dt(&cfg->in_gpio)) {\t\t\\ \t\t\tLOG_ERR(\"GPIO device not ready\");\t\t\\ \t\t\treturn -ENODEV;\t\t\t\t\t\\ \t\t}\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \t\tfor (i = 0; i< cfg->num_colors; i++) {\t\t\t\\ \t\t\tswitch (cfg->color_mapping[i]) {\t\t\\ \t\t\tcase LED_COLOR_ID_WHITE:\t\t\t\\ \t\t\tcase LED_COLOR_ID_RED:\t\t\t\t\\ \t\t\tcase LED_COLOR_ID_GREEN:\t\t\t\\ \t\t\tcase LED_COLOR_ID_BLUE:\t\t\t\t\\ \t\t\t\tbreak;\t\t\t\t\t\\ \t\t\tdefault:\t\t\t\t\t\\ \t\t\t\tLOG_ERR(\"%s: invalid channel to color mapping.\" \\ \t\t\t\t\t\" Check the color-mapping DT property\",\t\\ \t\t\t\t\tdev->name);\t\t\t\\ \t\t\t\treturn -EINVAL;\t\t\t\t\\ \t\t\t}\t\t\t\t\t\t\\ \t\t}\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \t\treturn gpio_pin_configure_dt(&cfg->in_gpio, GPIO_OUTPUT); \\ \t}\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tWS2812_COLOR_MAPPING(idx);\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic const struct ws2812_gpio_cfg ws2812_gpio_##idx##_cfg = { \\ \t\t.in_gpio = GPIO_DT_SPEC_INST_GET(idx, in_gpios),\t\\ \t\t.num_colors = WS2812_NUM_COLORS(idx),\t\t\t\\ \t\t.color_mapping = ws2812_gpio_##idx##_color_mapping,\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(idx,\t\t\t\t\t\\ \t\t\t    ws2812_gpio_##idx##_init,\t\t\t\\ \t\t\t    NULL,\t\t\t\t\t\\ \t\t\t    NULL,\t\t\t\t\t\\&ws2812_gpio_##idx##_cfg, POST_KERNEL,\t\\ \t\t\t    CONFIG_LED_STRIP_INIT_PRIORITY,\t\t\\&ws2812_gpio_api);\n+value|static int ws2812_gpio_##idx##_init(const struct device *dev)\t\\ \t{\t\t\t\t\t\t\t\t\\ \t\tconst struct ws2812_gpio_cfg *cfg = dev->config;\t\\ \t\tuint8_t i;\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \t\tif (!gpio_is_ready_dt(&cfg->gpio)) {\t\t\t\\ \t\t\tLOG_ERR(\"GPIO device not ready\");\t\t\\ \t\t\treturn -ENODEV;\t\t\t\t\t\\ \t\t}\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \t\tfor (i = 0; i< cfg->num_colors; i++) {\t\t\t\\ \t\t\tswitch (cfg->color_mapping[i]) {\t\t\\ \t\t\tcase LED_COLOR_ID_WHITE:\t\t\t\\ \t\t\tcase LED_COLOR_ID_RED:\t\t\t\t\\ \t\t\tcase LED_COLOR_ID_GREEN:\t\t\t\\ \t\t\tcase LED_COLOR_ID_BLUE:\t\t\t\t\\ \t\t\t\tbreak;\t\t\t\t\t\\ \t\t\tdefault:\t\t\t\t\t\\ \t\t\t\tLOG_ERR(\"%s: invalid channel to color mapping.\" \\ \t\t\t\t\t\" Check the color-mapping DT property\",\t\\ \t\t\t\t\tdev->name);\t\t\t\\ \t\t\t\treturn -EINVAL;\t\t\t\t\\ \t\t\t}\t\t\t\t\t\t\\ \t\t}\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \t\treturn gpio_pin_configure_dt(&cfg->gpio, GPIO_OUTPUT);\t\\ \t}\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tWS2812_COLOR_MAPPING(idx);\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic const struct ws2812_gpio_cfg ws2812_gpio_##idx##_cfg = { \\ \t\t.gpio = GPIO_DT_SPEC_INST_GET(idx, gpios),\t\t\\ \t\t.num_colors = WS2812_NUM_COLORS(idx),\t\t\t\\ \t\t.color_mapping = ws2812_gpio_##idx##_color_mapping,\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(idx,\t\t\t\t\t\\ \t\t\t    ws2812_gpio_##idx##_init,\t\t\t\\ \t\t\t    NULL,\t\t\t\t\t\\ \t\t\t    NULL,\t\t\t\t\t\\&ws2812_gpio_##idx##_cfg, POST_KERNEL,\t\\ \t\t\t    CONFIG_LED_STRIP_INIT_PRIORITY,\t\t\\&ws2812_gpio_api);\n-  in-gpios:\n+  gpios:\n-\t\tin-gpios = <&gpio0 3 0>;\n+\t\tgpios = <&gpio0 3 0>;\n-\t\tin-gpios = <&gpio0 25 0>;\n+\t\tgpios = <&gpio0 25 0>;\nThe issue was with: drivers: led_strip: ws2812_gpio: Rename in-gpios property to gpios\n\nws2812-gpio's `in-gpios` property is not used as an input pin.\nRenaming it to `gpios` to reflect the actual situation."
},{
  "instruction": "There is an issue in the following code. It relates to lib/os/printk.c: use ARG_UNUSED() for char_out()\n\nUse ARG_UNUSED() within the function char_out()\nto handel unused param. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|void\nmodifier|*\nname|ctx_p\nparameter_list|)\nblock|{\noperator|(\nname|void\noperator|)\nname|ctx_p\nexpr_stmt|;\nreturn|return\nname|_char_out\nargument_list|(\nname|c",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|(\n-name|void\n-operator|)\n+name|ARG_UNUSED\n+argument_list|(\n+argument_list|)\nThe issue was with: lib/os/printk.c: use ARG_UNUSED() for char_out()\n\nUse ARG_UNUSED() within the function char_out()\nto handel unused param."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: regulator: axp192: Bugfix to control DCDC2 output\n\nFix wrong definition of DCDC2 register values. Please fix this issue.",
  "input": "Faulty tokenized code:\ninit|=\nblock|{\noperator|.\nname|enable_reg\noperator|=\nname|AXP192_REG_DCDC123_LDO23_CONTROL\nblock|,\noperator|.\nname|enable_mask\noperator|=\nliteral|0x10U\nblock|,\noperator|.\nname|enable_val\noperator|=\nliteral|0x10U\nblock|,\noperator|.\nname|vsel_reg\noperator|=\nname|AXP192_REG_DCDC2_VOLTAGE",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|AXP192_REG_DCDC123_LDO23_CONTROL\n+name|AXP192_REG_EXTEN_DCDC2_CONTROL\n-literal|0x10U\n+literal|0x01U\n-literal|0x10U\n+literal|0x01U\nThe issue was with: drivers: regulator: axp192: Bugfix to control DCDC2 output\n\nFix wrong definition of DCDC2 register values."
},{
  "instruction": "There is an issue in the following code. It relates to net: lib: Add debug for sockets total and owner\n\nThis helps in figuring out the need for the number of sockets. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument|net_socket_service_desc\nargument_list|,\nargument|svc\nargument_list|)\nblock|{\nname|get_idx\nargument_list|(\nname|svc\nargument_list|)\noperator|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|NET_DBG\n+argument_list|(\n+literal|\"Service %s has %d pollable sockets\"\n+argument_list|,\n+name|COND_CODE_1\n+argument_list|(\n+name|CONFIG_NET_SOCKETS_LOG_LEVEL_DBG\n+argument_list|,\n+operator|(\n+name|svc\n+operator|->\n+name|owner\n+operator|)\n+argument_list|,\n+operator|(\n+literal|\"\"\n+operator|)\n+argument_list|)\n+argument_list|,\n+name|svc\n+operator|->\n+name|pev_len\n+argument_list|)\n+expr_stmt|;\nThe issue was with: net: lib: Add debug for sockets total and owner\n\nThis helps in figuring out the need for the number of sockets."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: mipi_dsi: dsi_mcux: Remove DSI_DPHY_PLL_VCO definition\n\n - The DSI_DPHY_PLL_VCO_MAX and DSI_DPHY_PLL_VCO_MIN macro value is\n   different when changing to different SoC, so the definition is moved\n   to soc level driver header.\n - Remove the definition in this c file to fix the duplicate definition\n   issue. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|DSI_DPHY_PLL_CM_MAX\nvalue|255U\nend_define\n\nbegin_comment\ncomment|/* PLL VCO output frequency max value is 1.5GHz, VCO output is (ref_clk / CN ) * CM. */\nend_comment\n\nbegin_define\nDECL|macro|DSI_DPHY_PLL_VCO_MAX\ndefine|#\ndirective|define\nname|DSI_DPHY_PLL_VCO_MAX\nvalue|MHZ(1500)\nend_define\n\nbegin_define\nDECL|macro|DSI_DPHY_PLL_VCO_MIN\ndefine|#\ndirective|define\nname|DSI_DPHY_PLL_VCO_MIN\nvalue|(DSI_DPHY_PLL_REFCLK_CN_MIN * DSI_DPHY_PLL_CM_MIN)\nend_define\n\nbegin_define\nDECL|macro|DSI_DPHY_PLL_CO_MIN\ndefine|#\ndirective|define\nname|DSI_DPHY_PLL_CO_MIN",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_comment\n-comment|/* PLL VCO output frequency max value is 1.5GHz, VCO output is (ref_clk / CN ) * CM. */\n-end_comment\n-\n-begin_define\n-DECL|macro|DSI_DPHY_PLL_VCO_MAX\n-define|#\n-directive|define\n-name|DSI_DPHY_PLL_VCO_MAX\n-value|MHZ(1500)\n-end_define\n-\n-begin_define\n-DECL|macro|DSI_DPHY_PLL_VCO_MIN\n-define|#\n-directive|define\n-name|DSI_DPHY_PLL_VCO_MIN\n-value|(DSI_DPHY_PLL_REFCLK_CN_MIN * DSI_DPHY_PLL_CM_MIN)\n-end_define\n-\nThe issue was with: drivers: mipi_dsi: dsi_mcux: Remove DSI_DPHY_PLL_VCO definition\n\n - The DSI_DPHY_PLL_VCO_MAX and DSI_DPHY_PLL_VCO_MIN macro value is\n   different when changing to different SoC, so the definition is moved\n   to soc level driver header.\n - Remove the definition in this c file to fix the duplicate definition\n   issue."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: pinctrl: r8a779f0: move pfc file from soc to driver dir\n\nMove pfc_r8a779f0.c from the 'soc' directory to the 'drivers'\ndirectory to avoid code duplication for the ARM64 Spider board. Please fix this issue.",
  "input": "Faulty tokenized code:\nzephyr_library_sources_ifdef(CONFIG_PINCTRL_GD32_AFIO pinctrl_gd32_afio.c)\nzephyr_library_sources_ifdef(CONFIG_PINCTRL_ITE_IT8XXX2 pinctrl_ite_it8xxx2.c)\nzephyr_library_sources_ifdef(CONFIG_PINCTRL_NPCX pinctrl_npcx.c)\nzephyr_library_sources_ifdef(CONFIG_PINCTRL_NUMICRO pinctrl_numicro.c)\nzephyr_library_sources_ifdef(CONFIG_PINCTRL_NRF pinctrl_nrf.c)\nzephyr_library_sources_ifdef(CONFIG_PINCTRL_RCAR_PFC pfc_rcar.c)\nzephyr_library_sources_ifdef(CONFIG_PINCTRL_RPI_PICO pinctrl_rpi_pico.c)\nzephyr_library_sources_ifdef(CONFIG_PINCTRL_SAM pinctrl_sam.c)\nzephyr_library_sources_ifdef(CONFIG_PINCTRL_SAM0 pinctrl_sam0.c)\nzephyr_library_sources_ifdef(CONFIG_PINCTRL_STM32 pinctrl_stm32.c)\nsimilarity index 99%\nrename from soc/renesas/rcar/rcar_gen4/pfc_r8a779f0.c\nrename to drivers/pinctrl/pfc_r8a779f0.c\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|\"pinctrl_soc.h\"\nend_include\n\nbegin_include\ninclude|#\ndirective|include\n# Copyright (c) 2023 IoT.bzh\n# SPDX-License-Identifier: Apache-2.0\n\nzephyr_include_directories(.)\nzephyr_library_sources_ifdef(CONFIG_SOC_R8A779F0 pfc_r8a779f0.c)\nset(SOC_LINKER_SCRIPT ${ZEPHYR_BASE}/include/zephyr/arch/arm/cortex_a_r/scripts/linker.ld CACHE INTERNAL \"\")",
  "result": "I corrected the issue in the code by changing the following tokens:\n+zephyr_library_sources_ifdef(CONFIG_SOC_R8A779F0 pfc_r8a779f0.c)\n-file|\"pinctrl_soc.h\"\n+file|<pinctrl_soc.h>\n-zephyr_library_sources_ifdef(CONFIG_SOC_R8A779F0 pfc_r8a779f0.c)\nThe issue was with: drivers: pinctrl: r8a779f0: move pfc file from soc to driver dir\n\nMove pfc_r8a779f0.c from the 'soc' directory to the 'drivers'\ndirectory to avoid code duplication for the ARM64 Spider board."
},{
  "instruction": "There is an issue in the following code. It relates to net: ip: Fix for improper offset return by `net_pkt_find_offset()`\n\nThe original packet's link-layer destination and source address can be\nstored in separately allocated memory. This allocated memory can be\nplaced just after pkt data buffers.\nIn case when `net_pkt_find_offset()` uses condition:\n`if (buf->data <= ptr && ptr <= (buf->data + buf->len)) {`\nthe offset is set outside the packet's buffer and the function returns\nincorrect offset instead of error code.\nFinally the offset is used to set ll address in cloned packet, and\nthis can have unexpected behavior (e.g. crash when cursor will be set\nto empty memory). Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_struct\nDECL|struct|net_pkt_alloc\nstruct|struct\nname|net_pkt_alloc\nblock|{\nDECL|union|__anon297937a7010a\nunion|union\nblock|{\nDECL|member|pkt\nname|struct\nname|net_pkt\nname|data\noperator|<=\nname|ptr\noperator|&&\nname|ptr\noperator|<=\noperator|(\nname|buf\noperator|->\nname|data\noperator|+",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon297937a7010a\n+DECL|union|__anon29be6b9f010a\n-operator|<=\n+operator|<\nThe issue was with: net: ip: Fix for improper offset return by `net_pkt_find_offset()`\n\nThe original packet's link-layer destination and source address can be\nstored in separately allocated memory. This allocated memory can be\nplaced just after pkt data buffers.\nIn case when `net_pkt_find_offset()` uses condition:\n`if (buf->data <= ptr && ptr <= (buf->data + buf->len)) {`\nthe offset is set outside the packet's buffer and the function returns\nincorrect offset instead of error code.\nFinally the offset is used to set ll address in cloned packet, and\nthis can have unexpected behavior (e.g. crash when cursor will be set\nto empty memory)."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: charger: charger_max20335: fix argument name\n\nRename `current_uv` argument name to `voltage_uv` in function\nmax20335_get_constant_charge_voltage() to make the name aligned with\nits usage. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nstruct|;\nend_struct\n\nbegin_enum\nDECL|enum|__anon27a8d71c0103\nenum|enum\nblock|{\nDECL|enumerator|MAX20335_CHARGER_OFF\nname|MAX20335_CHARGER_OFF\nblock|,\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|max20335_get_constant_charge_voltage (const struct device * dev,uint32_t * current_uv)\nspecifier|static\nname|int\nname|max20335_get_constant_charge_voltage\nparameter_list|(\nspecifier|const\nmodifier|*\nname|dev\nparameter_list|,\nname|uint32_t\nmodifier|*\nname|current_uv\nparameter_list|)\nblock|{\nspecifier|const\nname|struct\nname|charger_max20335_config\noperator|&\nname|charger_uv_range\nargument_list|,\nname|val\nargument_list|,\nname|current_uv\nargument_list|)\nreturn|;\nblock|}\nend_function\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon27a8d71c0103\n+DECL|enum|__anon2acf0c670103\n-DECL|function|max20335_get_constant_charge_voltage (const struct device * dev,uint32_t * current_uv)\n+DECL|function|max20335_get_constant_charge_voltage (const struct device * dev,uint32_t * voltage_uv)\n-name|current_uv\n+name|voltage_uv\n-name|current_uv\n+name|voltage_uv\nThe issue was with: drivers: charger: charger_max20335: fix argument name\n\nRename `current_uv` argument name to `voltage_uv` in function\nmax20335_get_constant_charge_voltage() to make the name aligned with\nits usage."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: charger: charger_max20335: rename status get function\n\nCurrent driver handles charger status only but the charger chip\nprovides plenty of different statuses. Change name of\nmax20335_get_status() function to max20335_get_charger_status()\nto make further implementations easier. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nstruct|;\nend_struct\n\nbegin_enum\nDECL|enum|__anon27917cef0103\nenum|enum\nblock|{\nDECL|enumerator|MAX20335_CHARGER_OFF\nname|MAX20335_CHARGER_OFF\nblock|,\nargument_list|)\ndecl_stmt|;\nend_decl_stmt\n\nbegin_function\nDECL|function|max20335_get_status (const struct device * dev,enum charger_status * status)\nspecifier|static\nname|int\nname|max20335_get_status\nparameter_list|(\nspecifier|const\nname|struct\nname|device\nmodifier|*\nblock|{\ncase|case\nname|CHARGER_PROP_STATUS\ncase|:\nreturn|return\nname|max20335_get_status\nargument_list|(\nname|dev\nargument_list|,\noperator|&\nname|val",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon27917cef0103\n+DECL|enum|__anon27a8d71c0103\n-DECL|function|max20335_get_status (const struct device * dev,enum charger_status * status)\n+DECL|function|max20335_get_charger_status (const struct device * dev,enum charger_status * status)\n-name|max20335_get_status\n+name|max20335_get_charger_status\n-name|max20335_get_status\n+name|max20335_get_charger_status\nThe issue was with: drivers: charger: charger_max20335: rename status get function\n\nCurrent driver handles charger status only but the charger chip\nprovides plenty of different statuses. Change name of\nmax20335_get_status() function to max20335_get_charger_status()\nto make further implementations easier."
},{
  "instruction": "There is an issue in the following code. It relates to tests: net: dhcpv4: add comments to sample packets\n\nTo make the content of the sample packets more more\nunderstandable, comments describing it are added. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|,\nliteral|0x00\nblock|,\nliteral|0x00\nblock|,\nliteral|0x63\nblock|,\nliteral|0x82\nblock|,\nliteral|0x53\nblock|,\nliteral|0x63\nblock|,\nliteral|0x35\nblock|,\nliteral|0x01\nblock|,\nliteral|0x02\nblock|,\nliteral|0x01\nblock|,\nliteral|0x04\nblock|,\nliteral|0xff\nblock|,\nliteral|0xff\nblock|,\nliteral|0x00\nblock|,\nliteral|0x3a\nblock|,\nliteral|0x04\nblock|,\nliteral|0x00\nblock|,\nliteral|0x54\nblock|,\nliteral|0x60\nblock|,\nliteral|0x3b\nblock|,\nliteral|0x04\nblock|,\nliteral|0x00\nblock|,\nliteral|0x93\nblock|,\nliteral|0xa8\nblock|,\nliteral|0x33\nblock|,\nliteral|0x04\nblock|,\nliteral|0x00\nblock|,\nliteral|0xa8\nblock|,\nliteral|0xc0\nblock|,\nliteral|0x36\nblock|,\nliteral|0x04\nblock|,\nliteral|0x0a\nblock|,\nliteral|0x09\nblock|,\nliteral|0x01\nblock|,\nliteral|0x03\nblock|,\nliteral|0x04\nblock|,\nliteral|0x0a\nblock|,\nliteral|0x48\nblock|,\nliteral|0x01\nblock|,\nliteral|0x0f\nblock|,\nliteral|0x0d\nblock|,\nliteral|0x66\nblock|,\nliteral|0x6d\nblock|,\nliteral|0x00\nblock|,\nliteral|0x06\nblock|,\nliteral|0x0c\nblock|,\nliteral|0x0a\nblock|,\nliteral|0x09\nblock|,\nliteral|0x01\nblock|,\nliteral|0x77\nblock|,\nliteral|0x3d\nblock|,\nliteral|0x02\nblock|,\nliteral|0x00\nblock|,\nliteral|0x00\nblock|,\nliteral|0x63\nblock|,\nliteral|0x82\nblock|,\nliteral|0x53\nblock|,\nliteral|0x63\nblock|,\nliteral|0x35\nblock|,\nliteral|0x01\nblock|,\nliteral|0x05\nblock|,\nliteral|0x3a\nblock|,\nliteral|0x04\nblock|,\nliteral|0x00\nblock|,\nliteral|0x54\nblock|,\nliteral|0x60\nblock|,\nliteral|0x3b\nblock|,\nliteral|0x04\nblock|,\nliteral|0x00\nblock|,\nliteral|0x93\nblock|,\nliteral|0xa8\nblock|,\nliteral|0x33\nblock|,\nliteral|0x04\nblock|,\nliteral|0x00\nblock|,\nliteral|0xa8\nblock|,\nliteral|0xc0\nblock|,\nliteral|0x36\nblock|,\nliteral|0x04\nblock|,\nliteral|0x0a\nblock|,\nliteral|0x09\nblock|,\nliteral|0x01\nblock|,\nliteral|0x01\nblock|,\nliteral|0x04\nblock|,\nliteral|0xff\nblock|,\nliteral|0xff\nblock|,\nliteral|0x00\nblock|,\nliteral|0x03\nblock|,\nliteral|0x04\nblock|,\nliteral|0x0a\nblock|,\nliteral|0x48\nblock|,\nliteral|0x01\nblock|,\nliteral|0x0f\nblock|,\nliteral|0x0d\nblock|,\nliteral|0x66\nblock|,\nliteral|0x6d\nblock|,\nliteral|0x00\nblock|,\nliteral|0x06\nblock|,\nliteral|0x0c\nblock|,\nliteral|0x0a\nblock|,\nliteral|0x09\nblock|,\nliteral|0x01\nblock|,\nliteral|0x77\nblock|,\nliteral|0x3d\nblock|,\nliteral|0x02",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Magic cookie: DHCP */\n+comment|/* [53] DHCP Message Type: OFFER */\n+comment|/* [1] Subnet Mask: 255.255.255.0 */\n+comment|/* [58] Renewal Time Value: (21600s) 6 hours */\n+comment|/* [59] Rebinding Time Value: (37800s) 1 hour 30 min */\n+comment|/* [51] IP Address Lease Time: (43200s) 12 hours */\n+comment|/* [54] DHCP Server Identifier: 10.184.9.1 */\n+comment|/* [3] Router: 10.237.72.1 */\n+comment|/* [15] Domain Name: fi.intel.com */\n+comment|/* [6] Domain Name Server: 10.248.2.1 163.33.253.68 10.184.9.1 */\n+comment|/* [119] Domain Search Option: fi.intel.com ger.corp.intel.com corp.intel.com intel.com */\n+comment|/* Magic cookie: DHCP */\n+comment|/* [53] DHCP Message Type: ACK */\n+comment|/* [58] Renewal Time Value: (21600s) 6 hours */\n+comment|/* [59] Rebinding Time Value: (37800s) 1 hour 30 min */\n+comment|/* [51] IP Address Lease Time: (43200s) 12 hours */\n+comment|/* [54] DHCP Server Identifier: 10.184.9.1 */\n+comment|/* [1] Subnet Mask: 255.255.255.0 */\n+comment|/* [3] Router: 10.237.72.1 */\n+comment|/* [15] Domain Name: fi.intel.com */\n+comment|/* [6] Domain Name Server: 10.248.2.1 163.33.253.68 10.184.9.1 */\n+comment|/* [119] Domain Search Option: fi.intel.com ger.corp.intel.com corp.intel.com intel.com */\nThe issue was with: tests: net: dhcpv4: add comments to sample packets\n\nTo make the content of the sample packets more more\nunderstandable, comments describing it are added."
},{
  "instruction": "There is an issue in the following code. It relates to net: shell: keep event_mon_handler compatible to k_thread_entry_t\n\nNearly all other code places for k_thread_entry_t also keep\nunused params in place to stay compatible with k_thread_entry_t. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/* We use a separate thread in order not to do any shell printing from  * event handler callback (to avoid stack size issues).  */\nend_comment\n\nbegin_function\nDECL|function|event_mon_handler (const struct shell * sh)\nspecifier|static\nname|void\nname|event_mon_handler\nparameter_list|(\nspecifier|const\nname|struct\nname|shell\nmodifier|*\nname|sh\nparameter_list|)\nblock|{\nname|char\nname|extra_info\nindex|[\ndecl_stmt|;\nname|struct\nname|event_msg\nname|msg\ndecl_stmt|;\nname|net_mgmt_init_event_callback\nargument_list|(\noperator|&\nname|l2_cb\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|event_mon_handler (const struct shell * sh)\n+DECL|function|event_mon_handler (const struct shell * sh,void * p2,void * p3)\n+parameter_list|,\n+name|void\n+modifier|*\n+name|p2\n+parameter_list|,\n+name|void\n+modifier|*\n+name|p3\n+name|ARG_UNUSED\n+argument_list|(\n+name|p2\n+argument_list|)\n+expr_stmt|;\n+name|ARG_UNUSED\n+argument_list|(\n+name|p3\n+argument_list|)\n+expr_stmt|;\nThe issue was with: net: shell: keep event_mon_handler compatible to k_thread_entry_t\n\nNearly all other code places for k_thread_entry_t also keep\nunused params in place to stay compatible with k_thread_entry_t."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: ieee802154_nrf5: Use Radio IRQ number from DT\n\nUsed RADIO_IRQ number is based on information provided by DT rather\nthan direct use of RADIO_IRQn. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|CONFIG_IEEE802154_NRF5_EXT_IRQ_MGMT\nargument_list|)\nname|IRQ_CONNECT\nargument_list|(\nname|RADIO_IRQn\nargument_list|,\nname|NRF_802154_IRQ_PRIORITY\nargument_list|,\nname|nrf5_radio_irq\nargument_list|,\nliteral|0\nargument_list|)\nexpr_stmt|;\nname|irq_enable\nargument_list|(\nname|RADIO_IRQn\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|RADIO_IRQn\n+name|DT_IRQN\n+argument_list|(\n+name|DT_NODELABEL\n+argument_list|(\n+name|radio\n+argument_list|)\n+argument_list|)\n-name|RADIO_IRQn\n+name|DT_IRQN\n+argument_list|(\n+name|DT_NODELABEL\n+argument_list|(\n+name|radio\n+argument_list|)\n+argument_list|)\nThe issue was with: drivers: ieee802154_nrf5: Use Radio IRQ number from DT\n\nUsed RADIO_IRQ number is based on information provided by DT rather\nthan direct use of RADIO_IRQn."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: modem_cellular: fine tune nRF91's shutdown_time\n\nA shutdown lasting more than 5 seconds was experienced. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|MODEM_CELLULAR_DEVICE_NORDIC_NRF91_SLM\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 1500);               \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\\n\",                                                          \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tstatic struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {             \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.power_pulse_duration_ms = 100,                                                    \\ \t\t.reset_pulse_duration_ms = 100,                                                    \\ \t\t.startup_time_ms = 2000,                                                           \\ \t\t.shutdown_time_ms = 3000,                                                          \\ \t\t.init_chat_script =&nordic_nrf91_slm_init_chat_script,                            \\ \t\t.dial_chat_script =&nordic_nrf91_slm_dial_chat_script,                            \\ \t\t.periodic_chat_script =&nordic_nrf91_slm_periodic_chat_script,                    \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\nend_define\n\nbegin_define\nDECL|macro|DT_DRV_COMPAT\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 1500);               \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\\n\",                                                          \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tstatic struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {             \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.power_pulse_duration_ms = 100,                                                    \\ \t\t.reset_pulse_duration_ms = 100,                                                    \\ \t\t.startup_time_ms = 2000,                                                           \\ \t\t.shutdown_time_ms = 3000,                                                          \\ \t\t.init_chat_script =&nordic_nrf91_slm_init_chat_script,                            \\ \t\t.dial_chat_script =&nordic_nrf91_slm_dial_chat_script,                            \\ \t\t.periodic_chat_script =&nordic_nrf91_slm_periodic_chat_script,                    \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\n+value|MODEM_PPP_DEFINE(MODEM_CELLULAR_INST_NAME(ppp, inst), NULL, 98, 1500, 1500);               \\                                                                                                    \\ \tstatic struct modem_cellular_data MODEM_CELLULAR_INST_NAME(data, inst) = {                 \\ \t\t.chat_delimiter = \"\\r\\n\",                                                          \\ \t\t.ppp =&MODEM_CELLULAR_INST_NAME(ppp, inst),                                       \\ \t};                                                                                         \\                                                                                                    \\ \tstatic struct modem_cellular_config MODEM_CELLULAR_INST_NAME(config, inst) = {             \\ \t\t.uart = DEVICE_DT_GET(DT_INST_BUS(inst)),                                          \\ \t\t.power_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_power_gpios, {}),                 \\ \t\t.reset_gpio = GPIO_DT_SPEC_INST_GET_OR(inst, mdm_reset_gpios, {}),                 \\ \t\t.power_pulse_duration_ms = 100,                                                    \\ \t\t.reset_pulse_duration_ms = 100,                                                    \\ \t\t.startup_time_ms = 2000,                                                           \\ \t\t.shutdown_time_ms = 10000,                                                         \\ \t\t.init_chat_script =&nordic_nrf91_slm_init_chat_script,                            \\ \t\t.dial_chat_script =&nordic_nrf91_slm_dial_chat_script,                            \\ \t\t.periodic_chat_script =&nordic_nrf91_slm_periodic_chat_script,                    \\ \t};                                                                                         \\                                                                                                    \\ \tPM_DEVICE_DT_INST_DEFINE(inst, modem_cellular_pm_action);                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, modem_cellular_init, PM_DEVICE_DT_INST_GET(inst),              \\&MODEM_CELLULAR_INST_NAME(data, inst),                               \\&MODEM_CELLULAR_INST_NAME(config, inst), POST_KERNEL, 99,            \\&modem_cellular_api);\nThe issue was with: drivers: modem_cellular: fine tune nRF91's shutdown_time\n\nA shutdown lasting more than 5 seconds was experienced."
},{
  "instruction": "There is an issue in the following code. It relates to modem: backends: uart_async: log the number of bytes dropped\n\nWhen a receive buffer overrun happens. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|include\nfile|<string.h>\nend_include\n\nbegin_enum\nDECL|enum|__anon2b44e71b0103\nenum|enum\nblock|{\nDECL|enumerator|MODEM_BACKEND_UART_ASYNC_STATE_TRANSMITTING_BIT\nname|MODEM_BACKEND_UART_ASYNC_STATE_TRANSMITTING_BIT\nblock|,\nname|key\nargument_list|)\nexpr_stmt|;\nname|LOG_WRN\nargument_list|(\nliteral|\"Receive buffer overrun\"\nargument_list|)\nexpr_stmt|;\nbreak|break;\nblock|}\nname|k_spin_unlock",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon2b44e71b0103\n+DECL|enum|__anon2a8ea2950103\n-literal|\"Receive buffer overrun\"\n+literal|\"Receive buffer overrun (%u/%u dropped)\"\n+argument_list|,\n+name|evt\n+operator|->\n+name|data\n+operator|.\n+name|rx\n+operator|.\n+name|len\n+operator|-\n+name|received\n+argument_list|,\n+name|evt\n+operator|->\n+name|data\n+operator|.\n+name|rx\n+operator|.\n+name|len\nThe issue was with: modem: backends: uart_async: log the number of bytes dropped\n\nWhen a receive buffer overrun happens."
},{
  "instruction": "There is an issue in the following code. It relates to soc: nxp: Fix issues caught in CI from HWMv2 port\n\nDuring HWMv2 porting there was some build fails missed from\ntypos in the RT1064 and RT11XX series, fix these. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|kCLOCK_FlexspiMux\nargument_list|,\nliteral|3\nargument_list|)\nexpr_stmt|;\nif|#\ndirective|if\nname|DT_SAME_NODE\nargument_list|(\nname|DT_NODELABEL\nname|kCLOCK_FlexspiMux\nargument_list|,\nliteral|3\nargument_list|)\nexpr_stmt|;\nif|#\ndirective|if\nname|DT_SAME_NODE\nargument_list|(\nname|DT_NODELABEL\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|\"power_rt11xx.h\"\nend_include\n\nbegin_include\ninclude|#\ndirective|include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+endif|#\n+directive|endif\n+endif|#\n+directive|endif\n-file|\"power_rt11xx.h\"\n+file|\"power.h\"\nThe issue was with: soc: nxp: Fix issues caught in CI from HWMv2 port\n\nDuring HWMv2 porting there was some build fails missed from\ntypos in the RT1064 and RT11XX series, fix these."
},{
  "instruction": "There is an issue in the following code. It relates to input: kbd_matrix: skip column with empty mask\n\nThe active key mask can be used for supporting multiple keyboard layouts\nwith a single firmware. A possible use case is to support keyboard with\nor without a numpad, in which case an entire set of columns may be\nmissing. Add a check to detect this condition and skip scanning that\ncolumn entirely if no keys are defined in it. Please fix this issue.",
  "input": "Faulty tokenized code:\ncondition|;\nname|col\noperator|++\ncontrol|)\nblock|{\nname|input_kbd_matrix_drive_column\nargument_list|(\nname|dev\nargument_list|,\nname|col",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|cfg\n+operator|->\n+name|actual_key_mask\n+operator|!=\n+name|NULL\n+operator|&&\n+name|cfg\n+operator|->\n+name|actual_key_mask\n+index|[\n+name|col\n+index|]\n+operator|==\n+literal|0\n+condition|)\n+block|{\n+continue|continue;\n+block|}\nThe issue was with: input: kbd_matrix: skip column with empty mask\n\nThe active key mask can be used for supporting multiple keyboard layouts\nwith a single firmware. A possible use case is to support keyboard with\nor without a numpad, in which case an entire set of columns may be\nmissing. Add a check to detect this condition and skip scanning that\ncolumn entirely if no keys are defined in it."
},{
  "instruction": "There is an issue in the following code. It relates to shell: fix shell_stop command\n\nAdded missing condition to check if log backend is configured before\ncalling the function: z_shell_log_backend_disable. Without this, in some\nconfigurations, a compilation error appeared due to calling a\nnon-existent function.\n\nFixes: #69555 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|sh\nargument_list|,\nname|SHELL_STATE_INITIALIZED\nargument_list|)\nexpr_stmt|;\nname|z_shell_log_backend_disable\nargument_list|(\nname|sh\noperator|->\nname|log_backend\nargument_list|)\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|IS_ENABLED\n+argument_list|(\n+name|CONFIG_SHELL_LOG_BACKEND\n+argument_list|)\n+condition|)\n+block|{\n+block|}\nThe issue was with: shell: fix shell_stop command\n\nAdded missing condition to check if log backend is configured before\ncalling the function: z_shell_log_backend_disable. Without this, in some\nconfigurations, a compilation error appeared due to calling a\nnon-existent function.\n\nFixes: #69555"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: re-add missing hci_vendor.c reference\n\nMove the nordic and openisa vendor file under ll_sw and add them back to\nthe list when building for nRF platforms, this was inadvertently removed\nin\n\n385a9e882d [formerly 7bd2804c24] Bluetooth: Controller: Build vendor LLL as library\n\nand is currently causing a:\n\n<wrn> bt_id: No static addresses stored in controller\n\nand random address on nRF devices. Please fix this issue.",
  "input": "Faulty tokenized code:\n  )\n\nzephyr_library_include_directories_ifdef(\n  CONFIG_SOC_COMPATIBLE_NRF\n  ll_sw/nordic\n hci/nordic\n  )\n\nzephyr_library_include_directories_ifdef(\n  CONFIG_SOC_OPENISA_RV32M1\n  ll_sw/openisa\n hci/openisa\n  )\n\nadd_subdirectory_ifdef(\n  CONFIG_BT_CTLR_COEX_DRIVERS\n  coex\nzephyr_library_sources_ifdef(\n  CONFIG_BT_CTLR_ISO_VENDOR_DATA_PATH\n  ull/ull_iso_vendor.c\n  )\n\nzephyr_library_sources(\n  hal/nrf5/cntr.c\n  hal/nrf5/ecb.c\n  hal/nrf5/radio/radio.c\n  hal/nrf5/mayfly.c\nsimilarity index 100%\nrename from subsys/bluetooth/controller/hci/nordic/hci_vendor.c\nrename to subsys/bluetooth/controller/ll_sw/nordic/hci/hci_vendor.c\nsimilarity index 100%\nrename from subsys/bluetooth/controller/hci/nordic/hci_vendor.h\nrename to subsys/bluetooth/controller/ll_sw/nordic/hci/hci_vendor.h\nsimilarity index 100%\nrename from subsys/bluetooth/controller/hci/openisa/hci_vendor.h\nrename to subsys/bluetooth/controller/ll_sw/openisa/hci/hci_vendor.h",
  "result": "I corrected the issue in the code by changing the following tokens:\n-  hci/nordic\n+  ll_sw/nordic/hci\n-  hci/openisa\n+  ll_sw/openisa/hci\n+zephyr_library_sources_ifdef(\n+  CONFIG_SOC_FAMILY_NORDIC_NRF\n+  hci/hci_vendor.c\n+  )\n+\nThe issue was with: Bluetooth: Controller: re-add missing hci_vendor.c reference\n\nMove the nordic and openisa vendor file under ll_sw and add them back to\nthe list when building for nRF platforms, this was inadvertently removed\nin\n\n385a9e882d [formerly 7bd2804c24] Bluetooth: Controller: Build vendor LLL as library\n\nand is currently causing a:\n\n<wrn> bt_id: No static addresses stored in controller\n\nand random address on nRF devices."
},{
  "instruction": "There is an issue in the following code. It relates to modules: hal_nordic: remove weak nrf_802154_clock_hfclk_ready\n\nThe __WEAK-tagged function `nrf_802154_clock_hfclk_ready` is removed.\nThe implementation is provided by the nRF 802.15.4 Radio Driver.\nExistence of __WEAK-tagged version causes incorrect behavior when\nLink Time Optimization is used. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|lfclk_is_running\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|nrf_802154_clock_hfclk_ready (void)\nname|__WEAK\nname|void\nname|nrf_802154_clock_hfclk_ready\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\ncomment|/* Intentionally empty. */\nblock|}\nend_function\n\nbegin_function\nDECL|function|nrf_802154_clock_lfclk_ready (void)\nname|__WEAK\nname|void\nname|nrf_802154_clock_lfclk_ready",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_function\n-DECL|function|nrf_802154_clock_hfclk_ready (void)\n-name|__WEAK\n-name|void\n-name|nrf_802154_clock_hfclk_ready\n-parameter_list|(\n-name|void\n-parameter_list|)\n-block|{\n-comment|/* Intentionally empty. */\n-block|}\n-end_function\n-\nThe issue was with: modules: hal_nordic: remove weak nrf_802154_clock_hfclk_ready\n\nThe __WEAK-tagged function `nrf_802154_clock_hfclk_ready` is removed.\nThe implementation is provided by the nRF 802.15.4 Radio Driver.\nExistence of __WEAK-tagged version causes incorrect behavior when\nLink Time Optimization is used."
},{
  "instruction": "There is an issue in the following code. It relates to net: conn_mgr: set a thread name\n\nSet a thread name for net conn_mgr, so that e.g. thread listings\nwithin the shell are easier to look at. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|0\nargument_list|,\nname|K_NO_WAIT\nargument_list|)\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|k_thread_name_set\n+argument_list|(\n+operator|&\n+name|conn_mgr_mon_thread\n+argument_list|,\n+literal|\"conn_mgr_monitor\"\n+argument_list|)\n+expr_stmt|;\nThe issue was with: net: conn_mgr: set a thread name\n\nSet a thread name for net conn_mgr, so that e.g. thread listings\nwithin the shell are easier to look at."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: BAP: Broadcast Source: Remove unused variable\n\nRemove an unused variable in bt_bap_broadcast_source_reconfig\nthat causes compiler warnings. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument|stream\nargument_list|,\nargument|_node\nargument_list|)\nblock|{\nname|struct\nname|bt_iso_chan_io_qos\nmodifier|*\nname|iso_qos\ndecl_stmt|;\nname|iso_qos\noperator|=\nname|stream\noperator|->\nname|ep\noperator|->\nname|iso\noperator|->\nname|chan\noperator|.\nname|qos\noperator|->\nname|tx\nexpr_stmt|;\nname|bt_bap_stream_attach\nargument_list|(\nname|NULL\nargument_list|,\nname|stream",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|struct\n-name|bt_iso_chan_io_qos\n-modifier|*\n-name|iso_qos\n-decl_stmt|;\n-name|iso_qos\n-operator|=\n-name|stream\n-operator|->\n-name|ep\n-operator|->\n-name|iso\n-operator|->\n-name|chan\n-operator|.\n-name|qos\n-operator|->\n-name|tx\n-expr_stmt|;\nThe issue was with: Bluetooth: BAP: Broadcast Source: Remove unused variable\n\nRemove an unused variable in bt_bap_broadcast_source_reconfig\nthat causes compiler warnings."
},{
  "instruction": "There is an issue in the following code. It relates to net/if: Trivial comment fix about all-nodes\n\ns/net_ipv6_mcast_join/net_ipv6_mld_join Please fix this issue.",
  "input": "Faulty tokenized code:\nendif|#\ndirective|endif\nend_endif\n\nbegin_struct\nDECL|struct|__anon274ed0aa0108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|ipv6\nname|struct\nname|CONFIG_NET_NATIVE_IPV4\nargument_list|)\nend_if\n\nbegin_struct\nDECL|struct|__anon274ed0aa0208\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|ipv4\nname|struct\nname|NET_IF_IPV6_NO_ND\nargument_list|)\ncondition|)\nblock|{\ncomment|/* RFC 4862 5.4.2 \t\t\t * Before sending a Neighbor Solicitation, an interface \t\t\t * MUST join the all-nodes multicast address and the \t\t\t * solicited-node multicast address of the tentative \t\t\t * address. \t\t\t */\ncomment|/* The allnodes multicast group is only joined once as \t\t\t * net_ipv6_mcast_join() checks if we have already \t\t\t * joined. \t\t\t */\nname|join_mcast_nodes\nargument_list|(\nname|iface\nargument_list|,\noperator|&",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon274ed0aa0108\n+DECL|struct|__anon2a90716c0108\n-DECL|struct|__anon274ed0aa0208\n+DECL|struct|__anon2a90716c0208\n-comment|/* The allnodes multicast group is only joined once as \t\t\t * net_ipv6_mcast_join() checks if we have already \t\t\t * joined. \t\t\t */\n+comment|/* The allnodes multicast group is only joined once as \t\t\t * net_ipv6_mld_join() checks if we have already \t\t\t * joined. \t\t\t */\nThe issue was with: net/if: Trivial comment fix about all-nodes\n\ns/net_ipv6_mcast_join/net_ipv6_mld_join"
},{
  "instruction": "There is an issue in the following code. It relates to net/mgmt: Trivial debug output fix about layer\n\nNet MGMT uses layer identifiers that are meaningful only for itself, but\nfor users it requires a trivial operation to show the real layer value. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|cb\ndecl_stmt|,\nmodifier|*\nname|tmp\ndecl_stmt|;\nname|NET_DBG\nargument_list|(\nliteral|\"Event layer %u code %u cmd %u\"\nargument_list|,\nname|NET_MGMT_GET_LAYER\nargument_list|(\nname|mgmt_event\noperator|->\nname|event\nargument_list|)\nargument_list|,\nname|NET_MGMT_GET_LAYER_CODE\nargument_list|(\nname|mgmt_event\noperator|->\nargument_list|(\nname|mgmt_event\nargument_list|)\ncondition|)\nblock|{\nname|NET_DBG\nargument_list|(\nliteral|\"Notifying Event layer %u code %u type %u\"\nargument_list|,\nname|NET_MGMT_GET_LAYER\nargument_list|(\nname|mgmt_event\nargument_list|)\nargument_list|,\nname|NET_MGMT_GET_LAYER_CODE\nargument_list|(\nname|mgmt_event\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Readable layer code is starting from 1, thus the increment */\n+operator|+\n+literal|1\n+comment|/* Readable layer code is starting from 1, thus the increment */\n+operator|+\n+literal|1\nThe issue was with: net/mgmt: Trivial debug output fix about layer\n\nNet MGMT uses layer identifiers that are meaningful only for itself, but\nfor users it requires a trivial operation to show the real layer value."
},{
  "instruction": "There is an issue in the following code. It relates to net/shell: Fixing a trivial error code\n\nAs for adding an ipv6 address, removing one should return the same error\ncode when the network interface is not found. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|idx\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|ENOEXEC\nreturn|;\nblock|}\nif|if\ncondition|(\nname|net_addr_pton",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|ENOEXEC\n+name|ENOENT\nThe issue was with: net/shell: Fixing a trivial error code\n\nAs for adding an ipv6 address, removing one should return the same error\ncode when the network interface is not found."
},{
  "instruction": "There is an issue in the following code. It relates to tests: kernel/cache: Do not invd the whole cache\n\nThat is dangerous and a big no-no. Remove it. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|)\nargument_list|)\nexpr_stmt|;\nname|ret\noperator|=\nname|sys_cache_data_invd_all\nargument_list|()\nexpr_stmt|;\nname|zassert_true\nargument_list|(\noperator|(\nname|ret\noperator|==\nliteral|0\noperator|)\noperator|||\noperator|(\nname|ret\noperator|==\noperator|-\nname|ENOTSUP\noperator|)\nargument_list|)\nexpr_stmt|;\nname|ret\noperator|=\nname|sys_cache_data_flush_and_invd_all\nargument_list|()\nexpr_stmt|;\nname|zassert_true\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|sys_cache_data_invd_all\n-argument_list|()\n-expr_stmt|;\n-name|zassert_true\n-argument_list|(\n-operator|(\n-name|ret\n-operator|==\n-literal|0\n-operator|)\n-operator|||\n-operator|(\n-name|ret\n-operator|==\n-operator|-\n-name|ENOTSUP\n-operator|)\n-argument_list|)\n-expr_stmt|;\n-name|ret\n-operator|=\nThe issue was with: tests: kernel/cache: Do not invd the whole cache\n\nThat is dangerous and a big no-no. Remove it."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: adxl367: fix trigger support\n\nThe adxl367_trigger.c file was missing a DT_COMPAT definition,\nwhich resulted in the driver config structs being misaligned\nbetween the driver source files. This is fixed here. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright (c) 2023 Analog Devices Inc.  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/device.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_define\n+DECL|macro|DT_DRV_COMPAT\n+define|#\n+directive|define\n+name|DT_DRV_COMPAT\n+value|adi_adxl367\n+end_define\n+\nThe issue was with: drivers: sensor: adxl367: fix trigger support\n\nThe adxl367_trigger.c file was missing a DT_COMPAT definition,\nwhich resulted in the driver config structs being misaligned\nbetween the driver source files. This is fixed here."
},{
  "instruction": "There is an issue in the following code. It relates to ec_host_cmd: shi_ite: add missing include\n\nAdd a missing include with ITE registers definitions. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|\"ec_host_cmd_backend_shi.h\"\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/drivers/gpio.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<chip_chipregs.h>\n+end_include\n+\nThe issue was with: ec_host_cmd: shi_ite: add missing include\n\nAdd a missing include with ITE registers definitions."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: HS300x DF Command Update\n\nBy default, the sensor should be factory-programmed to operate\nin Sleep Mode. A Measurement Request (MR) command is required\nto exit the sensor from its sleep state. An MR command should\nconsist of the 7-bit address followed by an eighth bit set to\n0 (write). However, many I2C controllers cannot generate merely\nthe address byte with no data. To overcome this limitation the\nMR command should be followed by a dummy byte (zero value). Please fix this issue.",
  "input": "Faulty tokenized code:\nname|config\ndecl_stmt|;\nname|int\nname|rc\ndecl_stmt|;\nif|if\ncondition|(\nname|chan\noperator|!=\nname|SENSOR_CHAN_ALL\nreturn|return\noperator|-\nname|ENOTSUP\nreturn|;\nblock|}\ncomment|/* \t * Initiate a measurement simply by sending 7-bit address followed \t * by an eighth bit set to 0 (write) and NO data. \t */\nname|rc\noperator|=\nname|i2c_write_dt\nargument_list|(\noperator|&\nname|cfg\noperator|->\nname|bus\nargument_list|,\nname|NULL\nargument_list|,\nliteral|0\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|rc",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|uint8_t\n+name|df_dummy\n+init|=\n+literal|0x0\n+decl_stmt|;\n-comment|/* \t * Initiate a measurement simply by sending 7-bit address followed \t * by an eighth bit set to 0 (write) and NO data. \t */\n+comment|/* \t * By default, the sensor should be factory-programmed to operate in Sleep Mode. \t * A Measurement Request (MR) command is required to exit the sensor \t * from its sleep state. An MR command should consist of the 7-bit address followed \t * by an eighth bit set to 0 (write). However, many I2C controllers cannot generate \t * merely the address byte with no data. To overcome this limitation the MR command \t * should be followed by a dummy byte (zero value). \t */\n-name|NULL\n+operator|(\n+specifier|const\n+name|uint8_t\n+operator|*\n+operator|)\n+operator|&\n+name|df_dummy\n-literal|0\n+literal|1\nThe issue was with: drivers: sensor: HS300x DF Command Update\n\nBy default, the sensor should be factory-programmed to operate\nin Sleep Mode. A Measurement Request (MR) command is required\nto exit the sensor from its sleep state. An MR command should\nconsist of the 7-bit address followed by an eighth bit set to\n0 (write). However, many I2C controllers cannot generate merely\nthe address byte with no data. To overcome this limitation the\nMR command should be followed by a dummy byte (zero value)."
},{
  "instruction": "There is an issue in the following code. It relates to net: zperf: Fix TOS option not working in zperf\n\nWhen the zperf command is called with '-S' option which means IP_TOS\nfor IPv4 and IPV6_TCLASS for IPv6, an error is printed and the\nsetting does not work. The socket option handling was changed by\ncommit d30c2bfcf243 [formerly 77e522a5a243]('net: context: Refactor option setters'), but the\ncallers of option setters were not changed. This causes the IP_TOS\nor IPV6_TCLASS option failed to set. The fix is to use uint8_t to\nstore the value of the -S option. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|zperf_prepare_upload_sock (const struct sockaddr * peer_addr,int tos,int priority,int proto)\nname|int\nname|zperf_prepare_upload_sock\nparameter_list|(\nspecifier|const\nname|struct\nname|sockaddr\nmodifier|*\nname|peer_addr\nparameter_list|,\nname|int\nname|tos\nparameter_list|,\nname|int\nname|priority\nparameter_list|,\nname|struct\nname|sockaddr\nmodifier|*\nname|peer_addr\nparameter_list|,\nname|int\nname|tos\nparameter_list|,\nname|int\nname|priority\nparameter_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|zperf_prepare_upload_sock (const struct sockaddr * peer_addr,int tos,int priority,int proto)\n+DECL|function|zperf_prepare_upload_sock (const struct sockaddr * peer_addr,uint8_t tos,int priority,int proto)\n-name|int\n+name|uint8_t\n-name|int\n+name|uint8_t\nThe issue was with: net: zperf: Fix TOS option not working in zperf\n\nWhen the zperf command is called with '-S' option which means IP_TOS\nfor IPv4 and IPV6_TCLASS for IPv6, an error is printed and the\nsetting does not work. The socket option handling was changed by\ncommit d30c2bfcf243 [formerly 77e522a5a243]('net: context: Refactor option setters'), but the\ncallers of option setters were not changed. This causes the IP_TOS\nor IPV6_TCLASS option failed to set. The fix is to use uint8_t to\nstore the value of the -S option."
},{
  "instruction": "There is an issue in the following code. It relates to bbram: fix bbram dead code issue\n\nClear the whole 192 bytes of bbram, before writing the magic value to it.\ntest pass \\\"west twister -cviG -T tests/drivers/bbram/\\\".\n\nFixes #69119 Please fix this issue.",
  "input": "Faulty tokenized code:\ninit|=\nname|base_addr\noperator|+\nname|BRAM_IDX_VALID_FLAGS3\ndecl_stmt|;\nif|if\ncondition|(\noperator|(\noperator|*\nname|bram_valid_flag0\noperator|!=\nname|BRAM_VALID_MAGIC_FIELD3\noperator|)\ncondition|)\nblock|{\ncomment|/* \t\t * Magic does not match, so BRAM must be uninitialized. Clear \t\t * entire Bank0 BRAM, and set magic value. \t\t */\nfor|for\ncontrol|(\nname|int\nname|i\ninit|=\nliteral|0\ninit|;\nname|i\noperator|<\nname|BRAM_IDX_VALID_FLAGS0\ncondition|;\nname|i\noperator|++\ncontrol|)\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|int\n+name|size\n+init|=\n+name|config\n+operator|->\n+name|size\n+decl_stmt|;\n-comment|/* \t\t * Magic does not match, so BRAM must be uninitialized. Clear \t\t * entire Bank0 BRAM, and set magic value. \t\t */\n+comment|/* \t\t * Magic does not match, so BRAM must be uninitialized. Clear \t\t * entire Bank0 and Bank1 BRAM, and set magic value. \t\t */\n-name|BRAM_IDX_VALID_FLAGS0\n+name|size\nThe issue was with: bbram: fix bbram dead code issue\n\nClear the whole 192 bytes of bbram, before writing the magic value to it.\ntest pass \\\"west twister -cviG -T tests/drivers/bbram/\\\".\n\nFixes #69119"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Host: SDP: Fix endianness issue of tid\n\nThe transfer byte order of SDP is big-endian.\n\nThe transaction ID(tid) should be big-endian before\nsending.\n\nAnd tid needs to be converted to CPU byte order\nafter receiving. Please fix this issue.",
  "input": "Faulty tokenized code:\nindex|]\ndecl_stmt|;\nend_decl_stmt\n\nbegin_enum\nDECL|enum|__anon296928990103\nenum|enum\nblock|{\nDECL|enumerator|BT_SDP_ITER_STOP\nname|BT_SDP_ITER_STOP\nblock|,\nexpr_stmt|;\nname|hdr\noperator|->\nname|tid\noperator|=\nname|tid\nexpr_stmt|;\nname|hdr\noperator|->\nname|param_len\noperator|=\nname|uint32_t\nname|seq_size\ndecl_stmt|,\nname|size\ndecl_stmt|;\nDECL|union|__anon29692899020a\nunion|union\nblock|{\nDECL|member|uuid\nname|struct\nname|bt_uuid\nliteral|0U\ndecl_stmt|;\nname|bool\nname|found\ndecl_stmt|;\nDECL|union|__anon29692899030a\nunion|union\nblock|{\nDECL|member|uuid\nname|struct\nname|bt_uuid\nreturn|;\nblock|}\nend_function\n\nbegin_struct\nDECL|struct|__anon296928990408\nspecifier|static\nspecifier|const\nstruct|struct\nblock|{\nDECL|member|op_code\nargument_list|(\nname|sdp\nargument_list|,\nname|buf\nargument_list|,\nname|hdr\noperator|->\nname|tid\nargument_list|)\nexpr_stmt|;\nbreak|break;\nblock|}\nblock|}\nif|if\nargument_list|(\nname|chan\nargument_list|,\nname|err\nargument_list|,\nname|hdr\noperator|->\nname|tid\nargument_list|)\nexpr_stmt|;\nblock|}\nreturn|return\nliteral|0\nreturn|;\nbegin_struct\nDECL|struct|bt_sdp_uuid_desc\nstruct|struct\nname|bt_sdp_uuid_desc\nblock|{\nDECL|union|__anon29692899050a\nunion|union\nblock|{\nDECL|member|uuid\nname|struct\nname|bt_uuid",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon296928990103\n+DECL|enum|__anon2b9461410103\n+name|sys_cpu_to_be16\n+argument_list|(\n+argument_list|)\n-DECL|union|__anon29692899020a\n+DECL|union|__anon2b946141020a\n-DECL|union|__anon29692899030a\n+DECL|union|__anon2b946141030a\n-DECL|struct|__anon296928990408\n+DECL|struct|__anon2b9461410408\n+name|sys_be16_to_cpu\n+argument_list|(\n+argument_list|)\n+name|sys_be16_to_cpu\n+argument_list|(\n+argument_list|)\n-DECL|union|__anon29692899050a\n+DECL|union|__anon2b946141050a\nThe issue was with: Bluetooth: Host: SDP: Fix endianness issue of tid\n\nThe transfer byte order of SDP is big-endian.\n\nThe transaction ID(tid) should be big-endian before\nsending.\n\nAnd tid needs to be converted to CPU byte order\nafter receiving."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: video: sw_generator: Fix stream_start return value\n\nThe stream_start() callback needs to return 0 for success. However, to\nindicate work has been successfully scheduled, k_work_schedule() could\nreturn either 0 (already scheduled) or 1 (newly scheduled).\n\nDue to this issue, the sw_generator could not start streaming. Fix it. Please fix this issue.",
  "input": "Faulty tokenized code:\ninit|=\nname|dev\noperator|->\nname|data\ndecl_stmt|;\nreturn|return\nname|k_work_schedule\nargument_list|(\noperator|&\nname|data\noperator|->\nname|K_MSEC\nargument_list|(\nliteral|33\nargument_list|)\nargument_list|)\nreturn|;\nblock|}\nend_function\n\nbegin_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-return|return\n+expr_stmt|;\n+return|return\n+literal|0\nThe issue was with: drivers: video: sw_generator: Fix stream_start return value\n\nThe stream_start() callback needs to return 0 for success. However, to\nindicate work has been successfully scheduled, k_work_schedule() could\nreturn either 0 (already scheduled) or 1 (newly scheduled).\n\nDue to this issue, the sw_generator could not start streaming. Fix it."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: video: sw_generator: Run clang-format\n\nRun clang-format on the file to fix indentation before making any changes Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|,\noperator|.\nname|height_step\noperator|=\nliteral|1\nblock|, \t}\nblock|,\nblock|{\nliteral|0\nblock|}\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n-block|, \t}\n+block|, \t\t\t\t\t       }\nThe issue was with: drivers: video: sw_generator: Run clang-format\n\nRun clang-format on the file to fix indentation before making any changes"
},{
  "instruction": "There is an issue in the following code. It relates to bluetooth: hci: spi: 0xFF is a valid payload length\n\nA payload size of 0xFF is valid and should not be a reason to keep\nlooping for more headers. The complete reqiurement is now:\n```\nheader_slave[STATUS_HEADER_READY] == READY_NOW &&\nheader_slave[STATUS_HEADER_TOREAD] > 0\n```\nThis fixes events being dropped when the payload size is 255. Please fix this issue.",
  "input": "Faulty tokenized code:\nif|if\ncondition|(\nname|reading\ncondition|)\nblock|{\ncomment|/* When reading, keep looping if read buffer is not valid */\nname|loop_cond\noperator|=\noperator|(\noperator|(\nname|header_slave\nindex|[\nname|STATUS_HEADER_TOREAD\nindex|]\noperator|==\nliteral|0U\noperator|)\noperator|||\noperator|(\nname|header_slave\nindex|[\nname|STATUS_HEADER_TOREAD\nindex|]\noperator|==\nliteral|0xFF\noperator|)\noperator|)\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\ncomment|/* When writing, keep looping if all bytes are zero */",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* When reading, keep looping if read buffer is not valid */\n+comment|/* When reading, keep looping if there is not yet any data */\n-operator|(\n-operator|(\n-operator|)\n-operator|||\n-operator|(\n-name|header_slave\n-index|[\n-name|STATUS_HEADER_TOREAD\n-index|]\n-operator|==\n-literal|0xFF\n-operator|)\n-operator|)\nThe issue was with: bluetooth: hci: spi: 0xFF is a valid payload length\n\nA payload size of 0xFF is valid and should not be a reason to keep\nlooping for more headers. The complete reqiurement is now:\n```\nheader_slave[STATUS_HEADER_READY] == READY_NOW &&\nheader_slave[STATUS_HEADER_TOREAD] > 0\n```\nThis fixes events being dropped when the payload size is 255."
},{
  "instruction": "There is an issue in the following code. It relates to net: sockets: tls: Return an error on send() after session is closed\n\nIt was an overlook to return 0 on TLS send() call, after detecting that\nTLS session has been closed by peer, such a behavior is only valid for\nrecv(). Instead, an error should be returned. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|k_mutex\nmodifier|*\nname|lock\ndecl_stmt|;\ncomment|/** TLS specific option values. */\nDECL|struct|__anon27e071580108\nstruct|struct\nblock|{\ncomment|/** Select which credentials to use with TLS. */\nDECL|member|sec_tag_list\nname|struct\nname|ctx\noperator|->\nname|session_closed\ncondition|)\nblock|{\nreturn|return\nliteral|0\nreturn|;\nblock|}\nif|if\ncondition|(\noperator|!",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon27e071580108\n+DECL|struct|__anon2b0df8280108\n+name|errno\n+operator|=\n+name|ECONNABORTED\n+expr_stmt|;\n-literal|0\n+operator|-\n+literal|1\nThe issue was with: net: sockets: tls: Return an error on send() after session is closed\n\nIt was an overlook to return 0 on TLS send() call, after detecting that\nTLS session has been closed by peer, such a behavior is only valid for\nrecv(). Instead, an error should be returned."
},{
  "instruction": "There is an issue in the following code. It relates to modem: chat: fix init assert\n\nUse the proper variable. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|)\noperator|&&\noperator|(\nname|config\noperator|->\nname|filter\noperator|>\nliteral|0\noperator|)\noperator|)\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|filter\n+name|filter_size\nThe issue was with: modem: chat: fix init assert\n\nUse the proper variable."
},{
  "instruction": "There is an issue in the following code. It relates to modem: ppp: fix crash when attaching to a pipe\n\nmodem_pipe_attach() can send events before returning, which could\nprovoke a crash as ppp->pipe, still NULL at that time, could be\nused either in receiving (if the pipe had some data pending) or\nin sending (if the PPP module had already been attached and had\nsome data to send in its transmit buffer).\n\nppp->pipe is now set before modem_pipe_attach().\nAlso, the ATTACHED_BIT is now set only after having actually attached.\nAnd finally, the send_work is now scheduled on PIPE_EVENT_OPENED\nso that data is flushed when the (closed) attached pipe is opened. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|process_work\nargument_list|)\nexpr_stmt|;\nbreak|break;\ncase|case\nname|MODEM_PIPE_EVENT_TRANSMIT_IDLE\ncase|:\nname|k_work_submit\nargument_list|(\noperator|&\nname|pipe\nparameter_list|)\nblock|{\nif|if\ncondition|(\nname|atomic_test_and_set_bit\nargument_list|(\noperator|&\nname|ppp\noperator|->\nname|state\nblock|{\nreturn|return\nliteral|0\nreturn|;\nblock|}\nname|modem_pipe_attach\nargument_list|(\nname|pipe\nargument_list|,\nname|modem_ppp_pipe_callback\nargument_list|,\nname|ppp\nargument_list|)\nexpr_stmt|;\nname|ppp\noperator|->\nname|pipe\noperator|=\nname|pipe\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|MODEM_PIPE_EVENT_OPENED\n+case|:\n+case|case\n-name|atomic_test_and_set_bit\n+name|atomic_test_bit\n+name|ppp\n+operator|->\n+name|pipe\n+operator|=\n+name|pipe\n+expr_stmt|;\n+name|atomic_set_bit\n+argument_list|(\n+operator|&\n-name|pipe\n-operator|=\n-name|pipe\n+name|state\n+argument_list|,\n+name|MODEM_PPP_STATE_ATTACHED_BIT\n+argument_list|)\nThe issue was with: modem: ppp: fix crash when attaching to a pipe\n\nmodem_pipe_attach() can send events before returning, which could\nprovoke a crash as ppp->pipe, still NULL at that time, could be\nused either in receiving (if the pipe had some data pending) or\nin sending (if the PPP module had already been attached and had\nsome data to send in its transmit buffer).\n\nppp->pipe is now set before modem_pipe_attach().\nAlso, the ATTACHED_BIT is now set only after having actually attached.\nAnd finally, the send_work is now scheduled on PIPE_EVENT_OPENED\nso that data is flushed when the (closed) attached pipe is opened."
},{
  "instruction": "There is an issue in the following code. It relates to modem: backends: use CONFIG_MODEM_MODULES_LOG_LEVEL\n\nThis makes the modem backends use the log level\nset for the modem modules instead of the default one. Please fix this issue.",
  "input": "Faulty tokenized code:\n\nbegin_expr_stmt\nname|LOG_MODULE_REGISTER\nargument_list|(\nname|modem_backend_tty\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_include\n\nbegin_expr_stmt\nname|LOG_MODULE_REGISTER\nargument_list|(\nname|modem_backend_uart\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_include\n\nbegin_expr_stmt\nname|LOG_MODULE_DECLARE\nargument_list|(\nname|modem_backend_uart\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_include\n\nbegin_expr_stmt\nname|LOG_MODULE_DECLARE\nargument_list|(\nname|modem_backend_uart\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+argument_list|,\n+name|CONFIG_MODEM_MODULES_LOG_LEVEL\n+argument_list|,\n+name|CONFIG_MODEM_MODULES_LOG_LEVEL\n+argument_list|,\n+name|CONFIG_MODEM_MODULES_LOG_LEVEL\n+argument_list|,\n+name|CONFIG_MODEM_MODULES_LOG_LEVEL\nThe issue was with: modem: backends: use CONFIG_MODEM_MODULES_LOG_LEVEL\n\nThis makes the modem backends use the log level\nset for the modem modules instead of the default one."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: entropy: stm32: fix missing rng in function call\n\nReplace rng to dev_data->rng in call to LL_RNG_SetHealthConfig. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|,\nname|health_test_magic\nargument_list|)\nname|LL_RNG_SetHealthConfig\nargument_list|(\nname|rng\nargument_list|,\nname|DT_INST_PROP\nargument_list|(\nliteral|0",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|dev_data\n+operator|->\nThe issue was with: drivers: entropy: stm32: fix missing rng in function call\n\nReplace rng to dev_data->rng in call to LL_RNG_SetHealthConfig."
},{
  "instruction": "There is an issue in the following code. It relates to net: shell: Print mgmt socket information properly\n\nThe \\\"net sockets\\\" command did not print network management\nsocket information properly but claimed that the socket\nwas IPv4 one which it is not. Please fix this issue.",
  "input": "Faulty tokenized code:\nelse|:\noperator|(\nname|obj\noperator|->\nname|socket_family\ncondition|?\nliteral|'4'\nelse|:\nliteral|' '\noperator|)\nargument_list|,\nname|obj\noperator|->\nname|socket_type\noperator|==",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|==\n+name|AF_INET\n+operator|(\n+name|obj\n+operator|->\n+name|socket_family\n+operator|==\n+name|AF_NET_MGMT\n+condition|?\n+literal|'M'\n+else|:\n+operator|)\nThe issue was with: net: shell: Print mgmt socket information properly\n\nThe \\\"net sockets\\\" command did not print network management\nsocket information properly but claimed that the socket\nwas IPv4 one which it is not."
},{
  "instruction": "There is an issue in the following code. It relates to net: socket: mgmt: Return error for poll\n\nThe net_mgmt socket does not support poll() or fcntl(), so\nreturn EOPNOTSUPP error if user tries to use those functions\nfor AF_NET_MGMT type socket. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|,\nname|va_list\nname|args\nparameter_list|)\nblock|{\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function\n\nbegin_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|errno\n+operator|=\n+name|EOPNOTSUPP\n+expr_stmt|;\n-literal|0\n+operator|-\n+literal|1\nThe issue was with: net: socket: mgmt: Return error for poll\n\nThe net_mgmt socket does not support poll() or fcntl(), so\nreturn EOPNOTSUPP error if user tries to use those functions\nfor AF_NET_MGMT type socket."
},{
  "instruction": "There is an issue in the following code. It relates to stm32: flash: ospi: Make erase function less chatty\n\nChange LOG_INF to LOG_DBG in flash erase command Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nblock|}\nelse|else\nblock|{\ncomment|/* Sector or Block erase depending on the size */\nname|LOG_INF\nargument_list|(\nliteral|\"Sector/Block Erase\"\nargument_list|)\nexpr_stmt|;\nname|cmd_erase\noperator|=\nname|NULL\nexpr_stmt|;\nblock|}\nblock|}\nname|LOG_INF\nargument_list|(\nliteral|\"Sector/Block Erase addr 0x%x, asize 0x%x amode 0x%x  instr 0x%x\"\nargument_list|,\nname|cmd_erase\noperator|.\nname|uint8_t\nname|decl_nph\ninit|=\nliteral|2\ndecl_stmt|;\nDECL|union|__anon2b1c6cb8010a\nunion|union\nblock|{\ncomment|/* We only process BFP so use one parameter block */\nDECL|member|raw\nname|uint8_t\nname|id\noperator|==\nname|JESD216_SFDP_PARAM_ID_BFP\ncondition|)\nblock|{\nDECL|union|__anon2b1c6cb8020a\nunion|union\nblock|{\nDECL|member|dw\nname|uint32_t\nname|dw\noperator|==\nliteral|4U\ncondition|)\nblock|{\ncomment|/* \t\t\t\t * Check table 4 byte address instruction table to get supported \t\t\t\t * erase opcodes when running in 4 byte address mode \t\t\t\t */\nDECL|union|__anon2b1c6cb8030a\nunion|union\nblock|{\nDECL|member|dw\nname|uint32_t\nname|dw\nindex|[\nliteral|2\nindex|]\ndecl_stmt|;\nDECL|struct|__anon2b1c6cb80408\nstruct|struct\nblock|{\nDECL|member|dummy\nname|uint32_t\nname|dummy",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|LOG_INF\n+name|LOG_DBG\n-name|LOG_INF\n+name|LOG_DBG\n-DECL|union|__anon2b1c6cb8010a\n+DECL|union|__anon27b33e0e010a\n-DECL|union|__anon2b1c6cb8020a\n+DECL|union|__anon27b33e0e020a\n-DECL|union|__anon2b1c6cb8030a\n+DECL|union|__anon27b33e0e030a\n-DECL|struct|__anon2b1c6cb80408\n+DECL|struct|__anon27b33e0e0408\nThe issue was with: stm32: flash: ospi: Make erase function less chatty\n\nChange LOG_INF to LOG_DBG in flash erase command"
},{
  "instruction": "There is an issue in the following code. It relates to tests: watchdog: Do not fail on not permitted option\n\nSkip test on not permitted option provided. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|err\noperator|!=\nliteral|0\ncondition|)\nblock|{\nname|TC_PRINT",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|==\n+operator|-\n+name|EPERM\n+condition|)\n+block|{\n+name|TC_PRINT\n+argument_list|(\n+literal|\"Some of the options are not permitted, skip\\n\"\n+argument_list|)\n+expr_stmt|;\n+return|return\n+name|TC_SKIP\n+return|;\n+block|}\n+if|else if\n+condition|(\n+name|err\nThe issue was with: tests: watchdog: Do not fail on not permitted option\n\nSkip test on not permitted option provided."
},{
  "instruction": "There is an issue in the following code. It relates to net: dhcpv4: option callback check value explicitly\n\nCheck the value of net_dhcpv4_add_option_callback()\nand net_dhcpv4_remove_option_callback() explicitly. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|cb\nparameter_list|)\nblock|{\nif|if\ncondition|(\noperator|!\nname|cb\noperator|||\noperator|!\nname|cb\noperator|->\nname|handler\ncondition|)\nblock|{\nreturn|return\noperator|-\nname|EINVAL\ninit|=\nliteral|0\ndecl_stmt|;\nif|if\ncondition|(\noperator|!\nname|cb\noperator|||\noperator|!\nname|cb\noperator|->\nname|handler\ncondition|)\nblock|{\nreturn|return\noperator|-\nname|EINVAL",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|!\n+operator|==\n+name|NULL\n-operator|!\n+operator|==\n+name|NULL\n-operator|!\n+operator|==\n+name|NULL\n-operator|!\n+operator|==\n+name|NULL\nThe issue was with: net: dhcpv4: option callback check value explicitly\n\nCheck the value of net_dhcpv4_add_option_callback()\nand net_dhcpv4_remove_option_callback() explicitly."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: misc: nordic_vpr_launcher: fix address handling\n\nWhen CONFIG_XIP=y, execution address may come from a partition, so its\nabsolute address is needed. Fix code by using VPR_ADDR() macro in all\ncases: execution and source addresses. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|;\nblock|}\nend_function\n\nbegin_comment\ncomment|/* obtain VPR source address either from memory or partition */\nend_comment\n\nbegin_define\nDECL|macro|VPR_SRC_ADDR (node_id)\ndefine|#\ndirective|define\nname|VPR_SRC_ADDR\nparameter_list|(\nname|node_id\nparameter_list|)\ndefine|\\\nvalue|(DT_REG_ADDR(node_id) +                                                                    \\ \t COND_CODE_0(DT_FIXED_PARTITION_EXISTS(node_id), (0), (DT_REG_ADDR(DT_GPARENT(node_id)))))\nname|NORDIC_VPR_LAUNCHER_DEFINE\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|COND_CODE_1(DT_NODE_HAS_PROP(inst, source_memory),                                         \\ \t\t    (BUILD_ASSERT((DT_REG_SIZE(DT_INST_PHANDLE(inst, execution_memory)) ==         \\ \t\t\t\t   DT_REG_SIZE(DT_INST_PHANDLE(inst, source_memory))),             \\ \t\t\t\t  \"Source/execution memory sizes mismatch\");),                     \\ \t\t    ())                                                                            \\                                                                                                    \\ \tstatic const struct nordic_vpr_launcher_config config##inst = {                            \\ \t\t.vpr = (NRF_VPR_Type *)DT_INST_REG_ADDR(inst),                                     \\ \t\t.exec_addr = DT_REG_ADDR(DT_INST_PHANDLE(inst, execution_memory)),                 \\ \t\tCOND_CODE_1(DT_INST_NODE_HAS_PROP(inst, source_memory),                            \\ \t\t\t    (.src_addr = VPR_SRC_ADDR(DT_INST_PHANDLE(inst, source_memory)),       \\ \t\t\t     .src_size = DT_REG_SIZE(DT_INST_PHANDLE(inst, source_memory)),),      \\ \t\t\t    ())};                                                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, nordic_vpr_launcher_init, NULL, NULL,&config##inst,           \\ \t\t\t      POST_KERNEL, CONFIG_NORDIC_VPR_LAUNCHER_INIT_PRIORITY, NULL);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* obtain VPR source address either from memory or partition */\n+comment|/* obtain VPR address either from memory or partition */\n-DECL|macro|VPR_SRC_ADDR (node_id)\n+DECL|macro|VPR_ADDR (node_id)\n-name|VPR_SRC_ADDR\n+name|VPR_ADDR\n-value|COND_CODE_1(DT_NODE_HAS_PROP(inst, source_memory),                                         \\ \t\t    (BUILD_ASSERT((DT_REG_SIZE(DT_INST_PHANDLE(inst, execution_memory)) ==         \\ \t\t\t\t   DT_REG_SIZE(DT_INST_PHANDLE(inst, source_memory))),             \\ \t\t\t\t  \"Source/execution memory sizes mismatch\");),                     \\ \t\t    ())                                                                            \\                                                                                                    \\ \tstatic const struct nordic_vpr_launcher_config config##inst = {                            \\ \t\t.vpr = (NRF_VPR_Type *)DT_INST_REG_ADDR(inst),                                     \\ \t\t.exec_addr = DT_REG_ADDR(DT_INST_PHANDLE(inst, execution_memory)),                 \\ \t\tCOND_CODE_1(DT_INST_NODE_HAS_PROP(inst, source_memory),                            \\ \t\t\t    (.src_addr = VPR_SRC_ADDR(DT_INST_PHANDLE(inst, source_memory)),       \\ \t\t\t     .src_size = DT_REG_SIZE(DT_INST_PHANDLE(inst, source_memory)),),      \\ \t\t\t    ())};                                                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, nordic_vpr_launcher_init, NULL, NULL,&config##inst,           \\ \t\t\t      POST_KERNEL, CONFIG_NORDIC_VPR_LAUNCHER_INIT_PRIORITY, NULL);\n+value|COND_CODE_1(DT_NODE_HAS_PROP(inst, source_memory),                                         \\ \t\t    (BUILD_ASSERT((DT_REG_SIZE(DT_INST_PHANDLE(inst, execution_memory)) ==         \\ \t\t\t\t   DT_REG_SIZE(DT_INST_PHANDLE(inst, source_memory))),             \\ \t\t\t\t  \"Source/execution memory sizes mismatch\");),                     \\ \t\t    ())                                                                            \\                                                                                                    \\ \tstatic const struct nordic_vpr_launcher_config config##inst = {                            \\ \t\t.vpr = (NRF_VPR_Type *)DT_INST_REG_ADDR(inst),                                     \\ \t\t.exec_addr = VPR_ADDR(DT_INST_PHANDLE(inst, execution_memory)),                    \\ \t\tCOND_CODE_1(DT_INST_NODE_HAS_PROP(inst, source_memory),                            \\ \t\t\t    (.src_addr = VPR_ADDR(DT_INST_PHANDLE(inst, source_memory)),           \\ \t\t\t     .src_size = DT_REG_SIZE(DT_INST_PHANDLE(inst, source_memory)),),      \\ \t\t\t    ())};                                                                  \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, nordic_vpr_launcher_init, NULL, NULL,&config##inst,           \\ \t\t\t      POST_KERNEL, CONFIG_NORDIC_VPR_LAUNCHER_INIT_PRIORITY, NULL);\nThe issue was with: drivers: misc: nordic_vpr_launcher: fix address handling\n\nWhen CONFIG_XIP=y, execution address may come from a partition, so its\nabsolute address is needed. Fix code by using VPR_ADDR() macro in all\ncases: execution and source addresses."
},{
  "instruction": "There is an issue in the following code. It relates to net: l2: ppp: ipv6cp: add assert to check the link address length\n\nThis ensures that the configured link address is\nat least as big as the part of it that is used. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\nname|memcpy\nargument_list|(\nname|iid\nargument_list|,\nname|linkaddr",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|NET_ASSERT\n+argument_list|(\n+name|linkaddr\n+operator|->\n+name|len\n+operator|>=\n+literal|6\n+argument_list|)\n+expr_stmt|;\nThe issue was with: net: l2: ppp: ipv6cp: add assert to check the link address length\n\nThis ensures that the configured link address is\nat least as big as the part of it that is used."
},{
  "instruction": "There is an issue in the following code. It relates to tests: bsim: bluetooth: mesh: Add short delay before suspending stack\n\nThe stack manages to suspend the advertiser before it finishes\ntransmitting the Outbound PDU Report message to confirm the transmission\nof a Provisioning PDU. The test requires the server to become\nunresponsive when the Provisioning PDU is sent to the unprovisioned\ndevice to test timeout of the provisioning protocol. Please fix this issue.",
  "input": "Faulty tokenized code:\nmodifier|*\nname|buf\nparameter_list|)\nblock|{\ncomment|/* Device becomes unresponsive and doesn't communicate with other nodes anymore */\nname|bt_mesh_suspend\nargument_list|()\nexpr_stmt|;\nname|k_sem_give\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|k_sleep\n+argument_list|(\n+name|K_MSEC\n+argument_list|(\n+literal|10\n+argument_list|)\n+argument_list|)\n+expr_stmt|;\nThe issue was with: tests: bsim: bluetooth: mesh: Add short delay before suspending stack\n\nThe stack manages to suspend the advertiser before it finishes\ntransmitting the Outbound PDU Report message to confirm the transmission\nof a Provisioning PDU. The test requires the server to become\nunresponsive when the Provisioning PDU is sent to the unprovisioned\ndevice to test timeout of the provisioning protocol."
},{
  "instruction": "There is an issue in the following code. It relates to samples: Bluetooth: Only connect to devices with rssi below -50\n\nWhen the Bluetooth central samples in an open air environment\nit is very likely that there are multiple devices nearby with\na received signal strength stronger than -70 dBm.\n\nTo avoid connecting to the wrong device, make the check stricter.\n\nFor tests using those samples, the NtNcable attenuation is changed\nfrom the default 60 dBm to 40 dBm to satisfy the new requirement. Please fix this issue.",
  "input": "Faulty tokenized code:\nif|if\ncondition|(\nname|rssi\noperator|<\noperator|-\nliteral|70\ncondition|)\nblock|{\nreturn|return;\nblock|}\nif|if\nif|if\ncondition|(\nname|rssi\noperator|<\noperator|-\nliteral|70\ncondition|)\nblock|{\nreturn|return;\nblock|}\nname|err\nif|if\ncondition|(\nname|rssi\noperator|<\noperator|-\nliteral|70\ncondition|)\nblock|{\nreturn|return;\nblock|}\nif|if\nif|if\ncondition|(\nname|rssi\noperator|<\noperator|-\nliteral|70\ncondition|)\nblock|{\nreturn|return;\nblock|}\nif|if\nif|if\ncondition|(\nname|rssi\noperator|<\noperator|-\nliteral|70\ncondition|)\nblock|{\nreturn|return;\nblock|}\nif|if\nif|if\ncondition|(\nname|rssi\noperator|<\noperator|-\nliteral|70\ncondition|)\nblock|{\nreturn|return;\nblock|}\nname|bt_data_parse\nExecute ./bs_${BOARD}_tests_bsim_bluetooth_audio_samples_unicast_audio_client_prj_conf \\\n  -v=${verbosity_level} -s=${simulation_id} -d=1 -RealEncryption=1 \\\n  -testid=unicast_client\n\nExecute ./bs_2G4_phy_v1 -v=${verbosity_level} -s=${simulation_id} \\\n -D=2 -sim_length=20e6 $@\n\nwait_for_background_jobs #Wait for all programs in background and return != 0 if any fails\n\nExecute \"$peripheral_exe\" \\\n    -v=${verbosity_level} -s=${simulation_id} -d=1 -testid=peripheral -RealEncryption=1\n\nExecute ./bs_2G4_phy_v1 -v=${verbosity_level} -s=${simulation_id} \\\n   -D=2 -sim_length=60e6 $@\n\nwait_for_background_jobs\n\nExecute ./bs_${BOARD}_tests_bsim_bluetooth_ll_multiple_id_prj_conf\\\n  -v=${verbosity_level} -s=${simulation_id} -d=1 -testid=peripheral\n\nExecute ./bs_2G4_phy_v1 -v=${verbosity_level} -s=${simulation_id} \\\n -D=2 -sim_length=4500e6 $@\n\nwait_for_background_jobs\n\nExecute ./bs_${BOARD}_tests_bsim_bluetooth_ll_throughput_prj_conf\\\n  -v=${verbosity_level} -s=${simulation_id} -d=1 -testid=peripheral\n\nExecute ./bs_2G4_phy_v1 -v=${verbosity_level} -s=${simulation_id} \\\n -D=2 -sim_length=60e6 $@\n\nwait_for_background_jobs",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|70\n+literal|50\n-literal|70\n+literal|50\n-literal|70\n+literal|50\n-literal|70\n+literal|50\n-literal|70\n+literal|50\n-literal|70\n+literal|50\n-  -D=2 -sim_length=20e6 $@\n+  -D=2 -sim_length=20e6 $@ -argschannel -at=40\n-    -D=2 -sim_length=60e6 $@\n+    -D=2 -sim_length=60e6 $@ -argschannel -at=40\n-  -D=2 -sim_length=4500e6 $@\n+  -D=2 -sim_length=4500e6 $@ -argschannel -at=40\n-  -D=2 -sim_length=60e6 $@\n+  -D=2 -sim_length=60e6 $@ -argschannel -at=40\nThe issue was with: samples: Bluetooth: Only connect to devices with rssi below -50\n\nWhen the Bluetooth central samples in an open air environment\nit is very likely that there are multiple devices nearby with\na received signal strength stronger than -70 dBm.\n\nTo avoid connecting to the wrong device, make the check stricter.\n\nFor tests using those samples, the NtNcable attenuation is changed\nfrom the default 60 dBm to 40 dBm to satisfy the new requirement."
},{
  "instruction": "There is an issue in the following code. It relates to posix: mqmeue: do not return NULL after pthread_exit()\n\npthread_exit() does not return and therefore it does not make\nsense to return NULL after it in mq_notify_thread(), and that\nwould constitute dead code.\n\nRather than explicitly exiting the thread, simply return\ngracefully from the thread function, and allow the pthread to\nterminate in the usual way. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|remove_notification\nargument_list|(\nname|mqueue\nargument_list|)\nexpr_stmt|;\nname|pthread_exit\nargument_list|(\nname|NULL\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|NULL\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|pthread_exit\n-argument_list|(\n-name|NULL\n-argument_list|)\n-expr_stmt|;\nThe issue was with: posix: mqmeue: do not return NULL after pthread_exit()\n\npthread_exit() does not return and therefore it does not make\nsense to return NULL after it in mq_notify_thread(), and that\nwould constitute dead code.\n\nRather than explicitly exiting the thread, simply return\ngracefully from the thread function, and allow the pthread to\nterminate in the usual way."
},{
  "instruction": "There is an issue in the following code. It relates to wifi: shell: removed NULL check to net_mgmt callback\n\nSince PR, PR_SHELL, PR_ERROR, PR_INFO, and PR_WARNING already have\nan embedded `sh` NULL check, we can remove the change from PR #68809. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|MAX_BANDS_STR_LEN\nvalue|64\nend_define\n\nbegin_struct\nDECL|struct|__anon2a0d83fd0108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\ndecl_stmt|;\nDECL|member|scan_result\nname|uint32_t\nname|scan_result\ndecl_stmt|;\nDECL|union|__anon2a0d83fd020a\nunion|union\nblock|{\nDECL|struct|__anon2a0d83fd0308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\nname|net_if\nmodifier|*\nname|iface\nparameter_list|)\nblock|{\nif|if\ncondition|(\nname|context\noperator|.\nname|sh\noperator|==\nname|NULL\ncondition|)\nblock|{\nreturn|return;\nblock|}\nswitch|switch\ncondition|(\nname|mgmt_event\ncondition|)\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2a0d83fd0108\n+DECL|struct|__anon290907270108\n-DECL|union|__anon2a0d83fd020a\n+DECL|union|__anon29090727020a\n-DECL|struct|__anon2a0d83fd0308\n+DECL|struct|__anon290907270308\n-if|if\n-condition|(\n-name|context\n-operator|.\n-name|sh\n-operator|==\n-name|NULL\n-condition|)\n-block|{\n-return|return;\n-block|}\nThe issue was with: wifi: shell: removed NULL check to net_mgmt callback\n\nSince PR, PR_SHELL, PR_ERROR, PR_INFO, and PR_WARNING already have\nan embedded `sh` NULL check, we can remove the change from PR #68809."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: dma: dma_dw_common: Log start and stop in info level\n\nThe start and stop of the DMA channel provides useful information in\ndefault logs and they are not too frequent to cause bandwidth issues. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\ngoto|goto\nname|out\ngoto|;\nblock|}\nname|struct\nname|dw_lli\nmodifier|*\nname|lli\ninit|=\nname|int\nname|i\ndecl_stmt|;\nendif|#\ndirective|endif\nname|LOG_DBG\nargument_list|(\nliteral|\"%s: channel %d stop\"\nargument_list|,\nname|dev\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|LOG_INF\n+argument_list|(\n+literal|\"%s: channel %d start\"\n+argument_list|,\n+name|dev\n+operator|->\n+name|name\n+argument_list|,\n+name|channel\n+argument_list|)\n+expr_stmt|;\n-name|LOG_DBG\n+name|LOG_INF\nThe issue was with: drivers: dma: dma_dw_common: Log start and stop in info level\n\nThe start and stop of the DMA channel provides useful information in\ndefault logs and they are not too frequent to cause bandwidth issues."
},{
  "instruction": "There is an issue in the following code. It relates to ipc: rpmsg_service: Support IPM without data transfer\n\nRPMsg currently sends four dummy bytes over the IPM when sending a\nnotification/interrupt to another CPU. However, most IPM drivers\nsupport sending messages with no data transfer, and for some IPM\ndrivers, like the STM32 HSEM IPM driver, data transfer is not\npossible at all, thus breaking compatibility. To fix this, send an\nempty message with size 0 instead of a dummy message if the STM32\nHSEM IPM driver is active. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|0\nargument_list|,\nliteral|1\nargument_list|)\nexpr_stmt|;\nelse|#\ndirective|else\nname|uint32_t\nname|dummy_data\ninit|=\nliteral|0x55005500\ndecl_stmt|;\ncomment|/* Some data must be provided */\nname|status\noperator|=\nname|ipm_send\nargument_list|(\nname|ipm_handle",
  "result": "I corrected the issue in the code by changing the following tokens:\n+elif|#\n+directive|elif\n+name|defined\n+argument_list|(\n+name|CONFIG_IPM_STM32_HSEM\n+argument_list|)\n+comment|/* No data transfer, only doorbell. */\n+name|status\n+operator|=\n+name|ipm_send\n+argument_list|(\n+name|ipm_handle\n+argument_list|,\n+literal|0\n+argument_list|,\n+literal|0\n+argument_list|,\n+name|NULL\n+argument_list|,\n+literal|0\n+argument_list|)\n+expr_stmt|;\n+comment|/* The IPM interface is unclear on whether or not ipm_send \t * can be called with NULL as data, thus, drivers might cause \t * problems if you do. To avoid problems, we always send some \t * dummy data, unless the IPM driver cannot transfer data. \t * Ref: #68741 \t */\n-comment|/* Some data must be provided */\nThe issue was with: ipc: rpmsg_service: Support IPM without data transfer\n\nRPMsg currently sends four dummy bytes over the IPM when sending a\nnotification/interrupt to another CPU. However, most IPM drivers\nsupport sending messages with no data transfer, and for some IPM\ndrivers, like the STM32 HSEM IPM driver, data transfer is not\npossible at all, thus breaking compatibility. To fix this, send an\nempty message with size 0 instead of a dummy message if the STM32\nHSEM IPM driver is active."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: ipm: esp32: Allow doorbell without data transfer\n\nIPM drivers are commonly used to send notifications/cause interrupts\nwithout any transfer of data. To add this use case in the ESP32 IPM\ndriver, the guard statement is appended so that the pointer to the\ndata buffer is allowed to be zero only if the size of the data to be\ntransferred is zero. If size is given as 0 and data is equal to NULL,\nwe are thus only using the IPM as a doorbell, not to transfer data. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|data\ndecl_stmt|;\nif|if\ncondition|(\nname|data\noperator|==\nname|NULL\ncondition|)\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|size\n+operator|>\n+literal|0\n+operator|&&\nThe issue was with: drivers: ipm: esp32: Allow doorbell without data transfer\n\nIPM drivers are commonly used to send notifications/cause interrupts\nwithout any transfer of data. To add this use case in the ESP32 IPM\ndriver, the guard statement is appended so that the pointer to the\ndata buffer is allowed to be zero only if the size of the data to be\ntransferred is zero. If size is given as 0 and data is equal to NULL,\nwe are thus only using the IPM as a doorbell, not to transfer data."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: tests: Switch to default `BT_RECV_CONTEXT`\n\nThe tests `hci_prop_evt` and `host_long_adv_recv` used `bt_recv_prio`,\nand so relied on an extra config option `CONFIG_BT_RECV_BLOCKING`. This\npatch replaces the use of `bt_recv_prio` with `bt_recv` and restores the\nuse of the default option for `BT_RECV_CONTEXT`. Please fix this issue.",
  "input": "Faulty tokenized code:\nCONFIG_ZTEST=y\n\nCONFIG_BT=y\nCONFIG_BT_CTLR=n\nCONFIG_BT_NO_DRIVER=y\nCONFIG_BT_RECV_BLOCKING=y\n\nCONFIG_BT_HCI_VS_EVT_USER=y\n\nCONFIG_LOG=y\nCONFIG_BT_HCI_CORE_LOG_LEVEL_DBG=y\nif|if\ncondition|(\nname|evt\ncondition|)\nblock|{\nname|bt_recv_prio\nargument_list|(\nname|evt\nargument_list|)\nexpr_stmt|;\nblock|}\nCONFIG_BT_CTLR=n\nCONFIG_BT_HCI=n\nCONFIG_BT_HCI_RAW=n\nCONFIG_BT_OBSERVER=y\nCONFIG_BT_NO_DRIVER=y\nCONFIG_BT_RECV_BLOCKING=y\nCONFIG_BT_EXT_ADV=y\n\nCONFIG_LOG=y\nCONFIG_BT_HCI_CORE_LOG_LEVEL_DBG=n\nCONFIG_BT_HCI_DRIVER_LOG_LEVEL_DBG=n\nif|if\ncondition|(\nname|evt\ncondition|)\nblock|{\nname|bt_recv_prio\nargument_list|(\nname|evt\nargument_list|)\nexpr_stmt|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n-CONFIG_BT_RECV_BLOCKING=y\n-name|bt_recv_prio\n+name|bt_recv\n-CONFIG_BT_RECV_BLOCKING=y\n-name|bt_recv_prio\n+name|bt_recv\nThe issue was with: Bluetooth: tests: Switch to default `BT_RECV_CONTEXT`\n\nThe tests `hci_prop_evt` and `host_long_adv_recv` used `bt_recv_prio`,\nand so relied on an extra config option `CONFIG_BT_RECV_BLOCKING`. This\npatch replaces the use of `bt_recv_prio` with `bt_recv` and restores the\nuse of the default option for `BT_RECV_CONTEXT`."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Host: Set `conn->err` in prio\n\nThe goal is to not access `buf` in the non-prio `hci_disconn_complete`\nso that the buffer does not need to be retained.\n\nThis commit moves the copy of `conn->err` to the prio handler. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|handle\nargument_list|)\nexpr_stmt|;\nreturn|return;\nblock|}\nname|bt_conn_set_state\nargument_list|(\nname|conn\nargument_list|,\nname|BT_CONN_DISCONNECT_COMPLETE\nname|handle\nargument_list|)\nexpr_stmt|;\nreturn|return;\nblock|}\nname|conn\noperator|->\nname|err\noperator|=\nname|evt\noperator|->\nname|reason\nexpr_stmt|;\nname|bt_conn_set_state\nargument_list|(\nname|conn\nargument_list|,\nname|BT_CONN_DISCONNECTED\nname|hci_vs_init\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nDECL|union|__anon2aead6e6010a\nunion|union\nblock|{\nDECL|member|info\nname|struct\nname|bt_hci_rp_vs_read_version_info",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|conn\n+operator|->\n+name|err\n+operator|=\n+name|evt\n+operator|->\n+name|reason\n+expr_stmt|;\n-name|conn\n-operator|->\n-name|err\n-operator|=\n-name|evt\n-operator|->\n-name|reason\n-expr_stmt|;\n-DECL|union|__anon2aead6e6010a\n+DECL|union|__anon2902842d010a\nThe issue was with: Bluetooth: Host: Set `conn->err` in prio\n\nThe goal is to not access `buf` in the non-prio `hci_disconn_complete`\nso that the buffer does not need to be retained.\n\nThis commit moves the copy of `conn->err` to the prio handler."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: Fix BT_CTLR_TIFS_HW conditional compile\n\nFix CONFIG_BT_CTLR_TIFS_HW conditional compile by replacing\nDPPI_PRESENT with CONFIG_BT_CTLR_TIFS_HW.\n\nHAL_SW_SWITCH_TIMER_CLEAR_PPI can be same as\nHAL_RADIO_END_TIME_CAPTURE_PPI, and this is ok as same\nbit will be used to disable PPI/DPPI. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|HAL_RADIO_END_TIME_CAPTURE_PPI\nargument_list|)\noperator||\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|DPPI_PRESENT\nargument_list|)\nname|BIT\nargument_list|(\nname|HAL_SW_SWITCH_TIMER_CLEAR_PPI\nargument_list|)\noperator||\nendif|#\ndirective|endif\ncomment|/* DPPI_PRESENT */\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_BT_CTLR_PHY_CODED\nname|HAL_RADIO_END_TIME_CAPTURE_PPI\nargument_list|)\noperator||\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|DPPI_PRESENT\nargument_list|)\nname|BIT\nargument_list|(\nname|HAL_SW_SWITCH_TIMER_CLEAR_PPI\nargument_list|)\noperator||\nendif|#\ndirective|endif\ncomment|/* DPPI_PRESENT */\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_BT_CTLR_PHY_CODED\nname|HAL_RADIO_END_TIME_CAPTURE_PPI\nargument_list|)\noperator||\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|DPPI_PRESENT\nargument_list|)\nname|BIT\nargument_list|(\nname|HAL_SW_SWITCH_TIMER_CLEAR_PPI\nargument_list|)\noperator||\nendif|#\ndirective|endif\ncomment|/* DPPI_PRESENT */\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_BT_CTLR_PHY_CODED",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|!\n-name|DPPI_PRESENT\n+name|CONFIG_BT_CTLR_TIFS_HW\n-comment|/* DPPI_PRESENT */\n+comment|/* !CONFIG_BT_CTLR_TIFS_HW */\n+operator|!\n-name|DPPI_PRESENT\n+name|CONFIG_BT_CTLR_TIFS_HW\n-comment|/* DPPI_PRESENT */\n+comment|/* !CONFIG_BT_CTLR_TIFS_HW */\n+operator|!\n-name|DPPI_PRESENT\n+name|CONFIG_BT_CTLR_TIFS_HW\n-comment|/* DPPI_PRESENT */\n+comment|/* !CONFIG_BT_CTLR_TIFS_HW */\nThe issue was with: Bluetooth: Controller: Fix BT_CTLR_TIFS_HW conditional compile\n\nFix CONFIG_BT_CTLR_TIFS_HW conditional compile by replacing\nDPPI_PRESENT with CONFIG_BT_CTLR_TIFS_HW.\n\nHAL_SW_SWITCH_TIMER_CLEAR_PPI can be same as\nHAL_RADIO_END_TIME_CAPTURE_PPI, and this is ok as same\nbit will be used to disable PPI/DPPI."
},{
  "instruction": "There is an issue in the following code. It relates to samples: charger: Moves sample charger app under samples/drivers/\n\nMoves the charger API sample app from samples/charger/ to\nsamples/drivers/chargers/ as mentioned in issue #65032. Please fix this issue.",
  "input": "Faulty tokenized code:\nsimilarity index 100%\nrename from samples/charger/CMakeLists.txt\nrename to samples/drivers/charger/CMakeLists.txt\nsimilarity index 100%\nrename from samples/charger/prj.conf\nrename to samples/drivers/charger/prj.conf\nsimilarity index 100%\nrename from samples/charger/sample.yaml\nrename to samples/drivers/charger/sample.yaml\nsimilarity index 100%\nrename from samples/charger/src/main.c\nrename to samples/drivers/charger/src/main.c",
  "result": "I corrected the issue in the code by changing the following tokens:\n\nThe issue was with: samples: charger: Moves sample charger app under samples/drivers/\n\nMoves the charger API sample app from samples/charger/ to\nsamples/drivers/chargers/ as mentioned in issue #65032."
},{
  "instruction": "There is an issue in the following code. It relates to net: wifi_utils: fix typo and whitespace adjustment\n\nCorrected 'subsytem' to 'subsystem' and made minor whitespace formatting. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/*  * Copyright (c) 2023 Nordic Semiconductor ASA  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_comment\ncomment|/** @file  * @brief Utility functions to be used by the Wi-Fi subsytem.  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/** @file  * @brief Utility functions to be used by the Wi-Fi subsytem.  */\n+comment|/** @file  * @brief Utility functions to be used by the Wi-Fi subsystem.  */\nThe issue was with: net: wifi_utils: fix typo and whitespace adjustment\n\nCorrected 'subsytem' to 'subsystem' and made minor whitespace formatting."
},{
  "instruction": "There is an issue in the following code. It relates to net: wifi_utils: reduce `valid_5g_chans_20mhz` memory footprint\n\nThis change reduces the memory footprint by changing the data type of\n`valid_5g_chans_20mhz` from `uint16_t` to `uint8_t`.\n\nAdditionally, since the maximum channel number for 5GHz Wi-Fi is 177,\nit can fit within the `uint8_t` range. Please fix this issue.",
  "input": "Faulty tokenized code:\n\nbegin_decl_stmt\nDECL|variable|valid_5g_chans_20mhz\nspecifier|static\nspecifier|const\nname|uint16_t\nname|valid_5g_chans_20mhz\nindex|[]\ninit|=\nblock|{\nliteral|32",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|uint16_t\n+name|uint8_t\nThe issue was with: net: wifi_utils: reduce `valid_5g_chans_20mhz` memory footprint\n\nThis change reduces the memory footprint by changing the data type of\n`valid_5g_chans_20mhz` from `uint16_t` to `uint8_t`.\n\nAdditionally, since the maximum channel number for 5GHz Wi-Fi is 177,\nit can fit within the `uint8_t` range."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: dac: stm32: add dac value range check\n\nCompare value and DAC resolution in `dac_write_value` and return -EINVAL\nif the value is above supported resolution. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|EINVAL\nreturn|;\nblock|}\nif|if\ncondition|(\nname|data\noperator|->\nname|resolution\noperator|==\nliteral|8",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|value\n+operator|>=\n+name|BIT\n+argument_list|(\n+name|data\n+operator|->\n+name|resolution\n+argument_list|)\n+condition|)\n+block|{\n+name|LOG_ERR\n+argument_list|(\n+literal|\"Value %d is out of range\"\n+argument_list|,\n+name|value\n+argument_list|)\n+expr_stmt|;\n+return|return\n+operator|-\n+name|EINVAL\n+return|;\n+block|}\n+if|if\n+condition|(\nThe issue was with: drivers: dac: stm32: add dac value range check\n\nCompare value and DAC resolution in `dac_write_value` and return -EINVAL\nif the value is above supported resolution."
},{
  "instruction": "There is an issue in the following code. It relates to samples: Bluetooth: Fix UUID compare\n\nCheck for BASS and PACS, while scanning for\nBroadcast Audio Sinks was wrong in the\nBroadcast Audio Assistant sample. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|uuid\nargument_list|,\nname|BT_UUID_BASS\nargument_list|)\ncondition|)\nblock|{\nname|sr_info\noperator|->\nname|has_bass\nargument_list|(\nname|uuid\nargument_list|,\nname|BT_UUID_PACS\nargument_list|)\ncondition|)\nblock|{\nname|sr_info\noperator|->\nname|has_pacs",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|==\n+literal|0\n+operator|==\n+literal|0\nThe issue was with: samples: Bluetooth: Fix UUID compare\n\nCheck for BASS and PACS, while scanning for\nBroadcast Audio Sinks was wrong in the\nBroadcast Audio Assistant sample."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Host: Notify upper layer if the BR ACL is established\n\nIn current implementation, the upper is not notified when BR ACL\nconnection is established.\nL2CAP does not know that ACL connection has been established.\nAll fixed channels will not be notified. Then The SDP server\ncannot work properly. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|conn\nargument_list|,\nname|BT_CONN_CONNECTED\nargument_list|)\nexpr_stmt|;\nname|bt_conn_unref\nargument_list|(\nname|conn\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|bt_conn_connected\n+argument_list|(\n+name|conn\n+argument_list|)\n+expr_stmt|;\nThe issue was with: Bluetooth: Host: Notify upper layer if the BR ACL is established\n\nIn current implementation, the upper is not notified when BR ACL\nconnection is established.\nL2CAP does not know that ACL connection has been established.\nAll fixed channels will not be notified. Then The SDP server\ncannot work properly."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: timer: stm32 lptimer when sleeping for -1\n\nWhen CONFIG_SYSTEM_SLOPPY_IDLE is not set, then system\ncan sleep for -1 means waking Up at the max possible\ncounter value (INT_MAX)\nWhen CONFIG_SYSTEM_SLOPPY_IDLE is set sleeping K_TICKS_FOREVER\nmeans never wakingUp Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\ncondition|)\nblock|{\nreturn|return;\nblock|}\nif|if\ncondition|(\nname|ticks\noperator|==\nname|K_TICKS_FOREVER\nindex|]\nargument_list|)\nexpr_stmt|;\nreturn|return;\nblock|}\ncomment|/* if LPTIM clock was previously stopped, it must now be restored */\nname|err\noperator|=\nname|clock_control_on\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* \t * When CONFIG_SYSTEM_CLOCK_SLOPPY_IDLE = y, ticks equals to -1 \t * is treated as a lptim off ; never waking up ; lptim not clocked anymore \t */\n+comment|/* \t * When CONFIG_SYSTEM_CLOCK_SLOPPY_IDLE = n, ticks equals to INT_MAX \t * is treated as a maximum possible value LPTIM_MAX_TIMEBASE (16bit counter) \t */\nThe issue was with: drivers: timer: stm32 lptimer when sleeping for -1\n\nWhen CONFIG_SYSTEM_SLOPPY_IDLE is not set, then system\ncan sleep for -1 means waking Up at the max possible\ncounter value (INT_MAX)\nWhen CONFIG_SYSTEM_SLOPPY_IDLE is set sleeping K_TICKS_FOREVER\nmeans never wakingUp"
},{
  "instruction": "There is an issue in the following code. It relates to wifi: shell: Fix the case for acronym\n\nDFS is an acronym, so, should be capitalized. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|MAX_BANDS_STR_LEN\nvalue|64\nend_define\n\nbegin_struct\nDECL|struct|__anon2afc62200108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\ndecl_stmt|;\nDECL|member|scan_result\nname|uint32_t\nname|scan_result\ndecl_stmt|;\nDECL|union|__anon2afc6220020a\nunion|union\nblock|{\nDECL|struct|__anon2afc62200308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\nargument_list|)\nexpr_stmt|;\nname|PR\nargument_list|(\nliteral|\"<channel>\\t<center frequency>\\t<supported(y/n)>\\t\"\nliteral|\"<max power(dBm)>\\t<passive transmission only(y/n)>\\t<dfs supported(y/n)>\\n\"\nargument_list|)\nexpr_stmt|;\nfor|for\ncontrol|(\nname|chan_idx",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2afc62200108\n+DECL|struct|__anon2a0d83fd0108\n-DECL|union|__anon2afc6220020a\n+DECL|union|__anon2a0d83fd020a\n-DECL|struct|__anon2afc62200308\n+DECL|struct|__anon2a0d83fd0308\n-literal|\"<max power(dBm)>\\t<passive transmission only(y/n)>\\t<dfs supported(y/n)>\\n\"\n+literal|\"<max power(dBm)>\\t<passive transmission only(y/n)>\\t<DFS supported(y/n)>\\n\"\nThe issue was with: wifi: shell: Fix the case for acronym\n\nDFS is an acronym, so, should be capitalized."
},{
  "instruction": "There is an issue in the following code. It relates to wifi: shell: Fix the header for passive transmission only\n\nThis flag indicates that only passive transmissions are allowed in that\nchannel for that regulatory domain. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|MAX_BANDS_STR_LEN\nvalue|64\nend_define\n\nbegin_struct\nDECL|struct|__anon278263fc0108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\ndecl_stmt|;\nDECL|member|scan_result\nname|uint32_t\nname|scan_result\ndecl_stmt|;\nDECL|union|__anon278263fc020a\nunion|union\nblock|{\nDECL|struct|__anon278263fc0308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\nargument_list|)\nexpr_stmt|;\nname|PR\nargument_list|(\nliteral|\"<channel>\\t<center frequency>\\t<supported(y/n)>\\t\"\nliteral|\"<max power(dBm)>\\t<passive scan supported(y/n)>\\t<dfs supported(y/n)>\\n\"\nargument_list|)\nexpr_stmt|;\nfor|for\ncontrol|(\nname|chan_idx",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon278263fc0108\n+DECL|struct|__anon2afc62200108\n-DECL|union|__anon278263fc020a\n+DECL|union|__anon2afc6220020a\n-DECL|struct|__anon278263fc0308\n+DECL|struct|__anon2afc62200308\n-literal|\"<max power(dBm)>\\t<passive scan supported(y/n)>\\t<dfs supported(y/n)>\\n\"\n+literal|\"<max power(dBm)>\\t<passive transmission only(y/n)>\\t<dfs supported(y/n)>\\n\"\nThe issue was with: wifi: shell: Fix the header for passive transmission only\n\nThis flag indicates that only passive transmissions are allowed in that\nchannel for that regulatory domain."
},{
  "instruction": "There is an issue in the following code. It relates to net: if: Init must be called before setting the name\n\nAs the interface init function might configure the system\nsuch a way that would affect the naming of the network\ninterface, we need to call the init before setting the name.\nThis is mostly needed by Wifi where the Wifi driver needs\nto mark its network interface as Wifi interface as by default\nthe Wifi interface will look like Ethernet one. Please fix this issue.",
  "input": "Faulty tokenized code:\nendif|#\ndirective|endif\nend_endif\n\nbegin_struct\nDECL|struct|__anon29a4e7520108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|ipv6\nname|struct\nname|CONFIG_NET_NATIVE_IPV4\nargument_list|)\nend_if\n\nbegin_struct\nDECL|struct|__anon29a4e7520208\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|ipv4\nname|struct\nargument|net_if\nargument_list|,\nargument|iface\nargument_list|)\nblock|{\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_NET_INTERFACE_NAME\nname|iface\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\nname|init_iface\nargument_list|(\nname|iface\nargument_list|)\nexpr_stmt|;\nname|if_count\noperator|++\nexpr_stmt|;\nblock|}\nif|if",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon29a4e7520108\n+DECL|struct|__anon27c582610108\n-DECL|struct|__anon29a4e7520208\n+DECL|struct|__anon27c582610208\n+name|init_iface\n+argument_list|(\n+name|iface\n+argument_list|)\n+expr_stmt|;\n-name|init_iface\n-argument_list|(\n-name|iface\n-argument_list|)\n-expr_stmt|;\nThe issue was with: net: if: Init must be called before setting the name\n\nAs the interface init function might configure the system\nsuch a way that would affect the naming of the network\ninterface, we need to call the init before setting the name.\nThis is mostly needed by Wifi where the Wifi driver needs\nto mark its network interface as Wifi interface as by default\nthe Wifi interface will look like Ethernet one."
},{
  "instruction": "There is an issue in the following code. It relates to net: arp: Fix dead lock caused by arp_mutex\n\nFix the dead lock between rx_q and tx_q thread.\nWhen tx_q thread prepares to send ARP packet, it might get\nthe net_if_tx_lock in net_if_tx(), then in net_arp_prepare(),\nit will try to get the arp_mutex.\nAt the same time, if the rx_q thread receives an ARP reply\npacket, in arp_update(), it will get the arp_mutex first,\nand flush the packets in arp pending_queue and try to get\nthe net_if_tx_lock. Then the dead lock occurs, two threads\nstuck and all the packcets can't be freed.\nIn arp_update(), taking the net_if_tx_lock first then taking\nthe arp_mutex can fix this issue. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|src\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|k_mutex_lock\nargument_list|(\noperator|&\nname|arp_mutex\nargument_list|,\nargument_list|(\noperator|&\nname|arp_mutex\nargument_list|)\nexpr_stmt|;\nreturn|return;\nblock|}\nname|memcpy\nargument_list|(\noperator|&\noperator|->\nname|frags\nargument_list|)\nexpr_stmt|;\ncomment|/* We directly send the packet without first queueing it. \t\t * The pkt has already been queued for sending, once by \t\t * net_if and second time in the ARP queue. We must not \t\t * queue it twice in net_if so that the statistics of \t\t * the pkt are not counted twice and the packet filter \t\t * callbacks are only called once. \t\t */\nname|net_if_tx_lock\nargument_list|(\nname|iface\nargument_list|)\nexpr_stmt|;\nname|ret\noperator|=\nname|net_if_l2\nargument_list|(\nname|iface\nname|iface\nargument_list|,\nname|pkt\nargument_list|)\nexpr_stmt|;\nname|net_if_tx_unlock\nargument_list|(\nname|iface\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|ret\noperator|<\nliteral|0\nargument_list|(\noperator|&\nname|arp_mutex\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|arp_prepare_reply (struct net_if * iface,struct net_pkt * req,struct net_eth_hdr * eth_query,struct net_eth_addr * dst_addr)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|net_if_tx_lock\n+argument_list|(\n+name|iface\n+argument_list|)\n+expr_stmt|;\n+name|net_if_tx_unlock\n+argument_list|(\n+name|iface\n+argument_list|)\n+expr_stmt|;\n-name|net_if_tx_lock\n-argument_list|(\n-name|iface\n-argument_list|)\n-expr_stmt|;\n-name|net_if_tx_unlock\n-argument_list|(\n-name|iface\n-argument_list|)\n-expr_stmt|;\n+name|net_if_tx_unlock\n+argument_list|(\n+name|iface\n+argument_list|)\n+expr_stmt|;\nThe issue was with: net: arp: Fix dead lock caused by arp_mutex\n\nFix the dead lock between rx_q and tx_q thread.\nWhen tx_q thread prepares to send ARP packet, it might get\nthe net_if_tx_lock in net_if_tx(), then in net_arp_prepare(),\nit will try to get the arp_mutex.\nAt the same time, if the rx_q thread receives an ARP reply\npacket, in arp_update(), it will get the arp_mutex first,\nand flush the packets in arp pending_queue and try to get\nthe net_if_tx_lock. Then the dead lock occurs, two threads\nstuck and all the packcets can't be freed.\nIn arp_update(), taking the net_if_tx_lock first then taking\nthe arp_mutex can fix this issue."
},{
  "instruction": "There is an issue in the following code. It relates to native_simulator: constify 'buffer' argument in nsi_host_write()\n\n'buffer' argument is read only, so it can be 'const'. This makes it\ncompatible with POSIX specification of write(3) syscall. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|nsi_host_write\nparameter_list|(\nname|int\nname|fd\nparameter_list|,\nname|void\nmodifier|*\nname|buffer\nparameter_list|,\nname|unsigned\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|nsi_host_write (int fd,void * buffer,unsigned long size)\nname|long\nname|nsi_host_write\nparameter_list|(\nname|int\nname|fd\nparameter_list|,\nname|void\nmodifier|*\nname|buffer\nparameter_list|,\nname|unsigned",
  "result": "I corrected the issue in the code by changing the following tokens:\n+specifier|const\n-DECL|function|nsi_host_write (int fd,void * buffer,unsigned long size)\n+DECL|function|nsi_host_write (int fd,const void * buffer,unsigned long size)\n+specifier|const\nThe issue was with: native_simulator: constify 'buffer' argument in nsi_host_write()\n\n'buffer' argument is read only, so it can be 'const'. This makes it\ncompatible with POSIX specification of write(3) syscall."
},{
  "instruction": "There is an issue in the following code. It relates to drivers/flash: fix nRF RRAM write-length issue while MPSL in use\n\nWhen radio-synchronization was on\n(CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE=n) context of writing was shifted\nby 4 instead of write-length (this caused redundant, self-shortening\nwrites to the same block.)\n\nwrite-len was unset when requested write len was less than\nRRAM_MAX_WRITE_BUFFER. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|len\noperator|>\nliteral|0\ncondition|)\nblock|{\nif|if\ncondition|(\nname|RRAM_MAX_WRITE_BUFFER\noperator|<\nname|w_ctx\noperator|->\nname|len\ncondition|)\nblock|{\nname|len\noperator|=\noperator|(\nname|RRAM_MAX_WRITE_BUFFER\noperator|<\nelse|:\nname|w_ctx\noperator|->\nname|len\nexpr_stmt|;\nblock|}\nname|rram_write\nargument_list|(\nname|w_ctx\noperator|->\nname|flash_addr\nname|len\nargument_list|)\nexpr_stmt|;\nname|shift_write_context\nargument_list|(\nsizeof|sizeof\nargument_list|(\nname|uint32_t\nargument_list|)\nargument_list|,\nname|w_ctx\nargument_list|)\nexpr_stmt|;\nif|if",
  "result": "I corrected the issue in the code by changing the following tokens:\n-if|if\n-condition|(\n-name|RRAM_MAX_WRITE_BUFFER\n-operator|<\n-name|w_ctx\n-operator|->\n-name|len\n-condition|)\n-block|{\n-block|}\n-sizeof|sizeof\n-argument_list|(\n-name|uint32_t\n-argument_list|)\n+name|len\nThe issue was with: drivers/flash: fix nRF RRAM write-length issue while MPSL in use\n\nWhen radio-synchronization was on\n(CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE=n) context of writing was shifted\nby 4 instead of write-length (this caused redundant, self-shortening\nwrites to the same block.)\n\nwrite-len was unset when requested write len was less than\nRRAM_MAX_WRITE_BUFFER."
},{
  "instruction": "There is an issue in the following code. It relates to tests: posix: mqueue: increase sleep ms to reduce failures\n\nThe test_mqueue_notify_thread testcase had a relatively high\nfailure rate because sleeping only 10ms was in some cases not\nsufficiently long enough for the spawned thread to update\nnotification_executed.\n\nSleep 100 ms instead of 10 ms to reduce the failure rate. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nname|usleep\nargument_list|(\nname|USEC_PER_MSEC\noperator|*\nliteral|10U\nargument_list|)\nexpr_stmt|;\nname|zassert_true\nargument_list|(\nname|notification_executed",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|10U\n+literal|100U\nThe issue was with: tests: posix: mqueue: increase sleep ms to reduce failures\n\nThe test_mqueue_notify_thread testcase had a relatively high\nfailure rate because sleeping only 10ms was in some cases not\nsufficiently long enough for the spawned thread to update\nnotification_executed.\n\nSleep 100 ms instead of 10 ms to reduce the failure rate."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: fix spelling errors\n\nFix spelling errors found in comment of the kernel source code. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|idle\noperator|=\nname|z_get_next_timeout_expiry\nargument_list|()\nexpr_stmt|;\ncomment|/* \t\t * Call the suspend hook function of the soc interface \t\t * to allow entry into a low power state. The function \t\t * returns false if low power state was not entered, in \t\t * which case, kernel does normal idle processing. \t\t * \t\t * This function is entered with interrupts disabled. \t\t * If a low power state was entered, then the hook \t\t * function should enable inerrupts before exiting. \t\t * This is because the kernel does not do its own idle \t\t * processing in those cases i.e. skips k_cpu_idle(). \t\t * The kernel's idle processing re-enables interrupts \t\t * which is essential for the kernel's scheduling \t\t * logic. \t\t */\nif|if\ncondition|(\nname|k_is_pre_kernel\nargument_list|()\noperator|||\nname|k_thread\nmodifier|*\nname|thread\nparameter_list|)\nfunction_decl|;\ncomment|/**  * @brief Enable floating point context preservation  *  * The function is used to enable the preservation of floating  * point context information for a particular thread.  * This API depends on each architecture implimentation. If the architecture  * does not support enabling, this API will always be failed.  *  * The @a options parameter indicates which floating point register sets will  * be used by the specified thread. Currently it is used by x86 only.  *  * @param thread  ID of thread.  * @param options architecture dependent options  *  * @retval 0        On success.  * @retval -EINVAL  If the floating point enabling could not be performed.  * @retval -ENOTSUP If the operation is not supported  */\nname|int\nname|arch_float_enable\nparameter_list|(\nname|struct\nname|k_thread\nparameter_list|)\nfunction_decl|;\nend_function_decl\n\nbegin_comment\ncomment|/**  * @brief Walks the wait queue invoking the callback on each waiting thread  *  * This function walks the wait queue invoking the callback function on each  * waiting thread while holding sched_spinlock. This can be useful for routines  * that need to operate on multiple waiting threads.  *  * CAUTION! As a wait queue is of indeterminant length, the scheduler will be  * locked for an indeterminant amount of time. This may impact system  * performance. As such, care must be taken when using both this function and  * the specified callback.  *  * @param wait_q Identifies the wait queue to walk  * @param func   Callback to invoke on each waiting thread  * @param data   Custom data passed to the callback  *  * @retval non-zero if walk is terminated by the callback; otherwise 0  */\nend_comment\n\nbegin_function_decl\nname|int\nname|z_sched_waitq_walk\nargument_list|,\nname|obj_core\nargument_list|)\nargument_list|)\nexpr_stmt|;\ncomment|/* Initialize and link satically defined mailboxes */\nname|STRUCT_SECTION_FOREACH\nargument_list|(\nargument|k_mbox\nargument_list|,\nargument|mbox\nargument_list|,\nname|obj_core\nargument_list|)\nargument_list|)\nexpr_stmt|;\ncomment|/* Initialize and link statically defined mutexs */\nname|STRUCT_SECTION_FOREACH\nargument_list|(\nargument|k_mutex\nargument_list|,\nargument|mutex\ngoto|goto\nname|out\ngoto|;\nblock|}\nblock|}\ncomment|/* This object has no more references. Some objects may have \t * dynamically allocated resources, require cleanup, or need to be \t * marked as uninitailized when all references are gone. What \t * specifically needs to happen depends on the object type. \t */\nswitch|switch\ncondition|(\nname|ko\noperator|->\nname|type\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_comment\ncomment|/* Comeplete flushing of a work item.  *  * Invoked with work lock held.  *  * Invoked from a work queue thread.  *  * Reschedules.  *  * @param work the work structure that has completed flushing.  */\nend_comment\n\nbegin_function\nDECL|function|finalize_flush_locked (struct k_work * work)\nspecifier|static",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* \t\t * Call the suspend hook function of the soc interface \t\t * to allow entry into a low power state. The function \t\t * returns false if low power state was not entered, in \t\t * which case, kernel does normal idle processing. \t\t * \t\t * This function is entered with interrupts disabled. \t\t * If a low power state was entered, then the hook \t\t * function should enable inerrupts before exiting. \t\t * This is because the kernel does not do its own idle \t\t * processing in those cases i.e. skips k_cpu_idle(). \t\t * The kernel's idle processing re-enables interrupts \t\t * which is essential for the kernel's scheduling \t\t * logic. \t\t */\n+comment|/* \t\t * Call the suspend hook function of the soc interface \t\t * to allow entry into a low power state. The function \t\t * returns false if low power state was not entered, in \t\t * which case, kernel does normal idle processing. \t\t * \t\t * This function is entered with interrupts disabled. \t\t * If a low power state was entered, then the hook \t\t * function should enable interrupts before exiting. \t\t * This is because the kernel does not do its own idle \t\t * processing in those cases i.e. skips k_cpu_idle(). \t\t * The kernel's idle processing re-enables interrupts \t\t * which is essential for the kernel's scheduling \t\t * logic. \t\t */\n-comment|/**  * @brief Enable floating point context preservation  *  * The function is used to enable the preservation of floating  * point context information for a particular thread.  * This API depends on each architecture implimentation. If the architecture  * does not support enabling, this API will always be failed.  *  * The @a options parameter indicates which floating point register sets will  * be used by the specified thread. Currently it is used by x86 only.  *  * @param thread  ID of thread.  * @param options architecture dependent options  *  * @retval 0        On success.  * @retval -EINVAL  If the floating point enabling could not be performed.  * @retval -ENOTSUP If the operation is not supported  */\n+comment|/**  * @brief Enable floating point context preservation  *  * The function is used to enable the preservation of floating  * point context information for a particular thread.  * This API depends on each architecture implementation. If the architecture  * does not support enabling, this API will always be failed.  *  * The @a options parameter indicates which floating point register sets will  * be used by the specified thread. Currently it is used by x86 only.  *  * @param thread  ID of thread.  * @param options architecture dependent options  *  * @retval 0        On success.  * @retval -EINVAL  If the floating point enabling could not be performed.  * @retval -ENOTSUP If the operation is not supported  */\n-comment|/**  * @brief Walks the wait queue invoking the callback on each waiting thread  *  * This function walks the wait queue invoking the callback function on each  * waiting thread while holding sched_spinlock. This can be useful for routines  * that need to operate on multiple waiting threads.  *  * CAUTION! As a wait queue is of indeterminant length, the scheduler will be  * locked for an indeterminant amount of time. This may impact system  * performance. As such, care must be taken when using both this function and  * the specified callback.  *  * @param wait_q Identifies the wait queue to walk  * @param func   Callback to invoke on each waiting thread  * @param data   Custom data passed to the callback  *  * @retval non-zero if walk is terminated by the callback; otherwise 0  */\n+comment|/**  * @brief Walks the wait queue invoking the callback on each waiting thread  *  * This function walks the wait queue invoking the callback function on each  * waiting thread while holding sched_spinlock. This can be useful for routines  * that need to operate on multiple waiting threads.  *  * CAUTION! As a wait queue is of indeterminate length, the scheduler will be  * locked for an indeterminate amount of time. This may impact system  * performance. As such, care must be taken when using both this function and  * the specified callback.  *  * @param wait_q Identifies the wait queue to walk  * @param func   Callback to invoke on each waiting thread  * @param data   Custom data passed to the callback  *  * @retval non-zero if walk is terminated by the callback; otherwise 0  */\n-comment|/* Initialize and link satically defined mailboxes */\n+comment|/* Initialize and link statically defined mailboxes */\n-comment|/* Initialize and link statically defined mutexs */\n+comment|/* Initialize and link statically defined mutexes */\n-comment|/* This object has no more references. Some objects may have \t * dynamically allocated resources, require cleanup, or need to be \t * marked as uninitailized when all references are gone. What \t * specifically needs to happen depends on the object type. \t */\n+comment|/* This object has no more references. Some objects may have \t * dynamically allocated resources, require cleanup, or need to be \t * marked as uninitialized when all references are gone. What \t * specifically needs to happen depends on the object type. \t */\n-comment|/* Comeplete flushing of a work item.  *  * Invoked with work lock held.  *  * Invoked from a work queue thread.  *  * Reschedules.  *  * @param work the work structure that has completed flushing.  */\n+comment|/* Complete flushing of a work item.  *  * Invoked with work lock held.  *  * Invoked from a work queue thread.  *  * Reschedules.  *  * @param work the work structure that has completed flushing.  */\nThe issue was with: kernel: fix spelling errors\n\nFix spelling errors found in comment of the kernel source code."
},{
  "instruction": "There is an issue in the following code. It relates to net: sockets: Do not start service thread if too little resources\n\nIf the CONFIG_NET_SOCKETS_POLL_MAX is smaller than what is needed\nfor the socket service API to work properly, then we should not\nstart the service thread as the service API cannot work and might\ncause memory overwrite in ctx.events[] array.\n\nFixes #69233 Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|.\nname|events\nargument_list|)\ncondition|)\nblock|{\nname|NET_WARN\nargument_list|(\nliteral|\"You have %d services to monitor but \"\nliteral|\"%zd poll entries configured.\"\nargument_list|,\nname|count\noperator|.\nname|events\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|NET_WARN\nargument_list|(\nliteral|\"Consider increasing value of %s to %d\"\nargument_list|,\nliteral|\"CONFIG_NET_SOCKETS_POLL_MAX\"\nargument_list|,\nname|count\noperator|+\nliteral|1\nargument_list|)\nexpr_stmt|;\nblock|}\nname|NET_DBG\nargument_list|(\nliteral|\"Monitoring %d socket entries\"\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|NET_WARN\n+name|NET_ERR\n-name|NET_WARN\n+name|NET_ERR\n-literal|\"Consider increasing value of %s to %d\"\n+literal|\"Please increase value of %s to at least %d\"\n+goto|goto\n+name|fail\n+goto|;\nThe issue was with: net: sockets: Do not start service thread if too little resources\n\nIf the CONFIG_NET_SOCKETS_POLL_MAX is smaller than what is needed\nfor the socket service API to work properly, then we should not\nstart the service thread as the service API cannot work and might\ncause memory overwrite in ctx.events[] array.\n\nFixes #69233"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: dac: esp32: fix clock control subsys argument\n\nCurrent cfg->clock_subsys is passed as address and is\ncausing driver assertion.\n\nFixes #69198 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|clock_dev\nargument_list|,\noperator|(\nname|clock_control_subsys_t\noperator|)\noperator|&\nname|cfg\noperator|->\nname|clock_subsys\nargument_list|)\noperator|!=",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|&\nThe issue was with: drivers: dac: esp32: fix clock control subsys argument\n\nCurrent cfg->clock_subsys is passed as address and is\ncausing driver assertion.\n\nFixes #69198"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: tmag5273: cast value to int64_t\n\nCast val1 from sensor_value before multiplication in order to avoid\ninteger overflow, as indicated by Coverity CID 347136. Please fix this issue.",
  "input": "Faulty tokenized code:\ncomment|/* calc remaining part (first mT digit + fractal part) and scale according to Zephyr. \t * Ensure that always positive. \t */\nspecifier|const\nname|int64_t\nname|raw_dec_part\ninit|=\nname|b_field\noperator|->\nname|val1\noperator|*\noperator|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+name|int64_t\n+operator|)\nThe issue was with: drivers: sensor: tmag5273: cast value to int64_t\n\nCast val1 from sensor_value before multiplication in order to avoid\ninteger overflow, as indicated by Coverity CID 347136."
},{
  "instruction": "There is an issue in the following code. It relates to tests: subsys/fs/nvs: fix nvs-cache-gc test\n\nnvs-cache-gc test is running into infinite loop because of the wrong\nstop condition when filling a sector.\nFix this by keeping an empty ATE in the sector for delete operation as\ndefined in the NVS filesystem write operations. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|+\nsizeof|sizeof\nargument_list|(\nname|data\nargument_list|)\noperator|<=\nname|fixture\noperator|->\nname|fs\noperator|.",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|+\n+sizeof|sizeof\n+argument_list|(\n+expr|struct\n+name|nvs_ate\n+argument_list|)\nThe issue was with: tests: subsys/fs/nvs: fix nvs-cache-gc test\n\nnvs-cache-gc test is running into infinite loop because of the wrong\nstop condition when filling a sector.\nFix this by keeping an empty ATE in the sector for delete operation as\ndefined in the NVS filesystem write operations."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: can: add missing argument to LOG_ERR call\n\nPR #64399 introduced checks for out-of-bounds filter IDs\nin CAN drivers, along with logging of said IDs; however,\nthe call to LOG_ERR in the native POSIX/Linux driver is\nmissing the 'filter_id' argument.\n\nThis commit adds the missing argument to ensure proper\ndata is printed when the LOG_ERR call is performed. Please fix this issue.",
  "input": "Faulty tokenized code:\ncondition|)\nblock|{\nname|LOG_ERR\nargument_list|(\nliteral|\"filter ID %d out of bounds\"\nargument_list|)\nexpr_stmt|;\nreturn|return;\nblock|}\nname|k_mutex_lock",
  "result": "I corrected the issue in the code by changing the following tokens:\n+argument_list|,\n+name|filter_id\nThe issue was with: drivers: can: add missing argument to LOG_ERR call\n\nPR #64399 introduced checks for out-of-bounds filter IDs\nin CAN drivers, along with logging of said IDs; however,\nthe call to LOG_ERR in the native POSIX/Linux driver is\nmissing the 'filter_id' argument.\n\nThis commit adds the missing argument to ensure proper\ndata is printed when the LOG_ERR call is performed."
},{
  "instruction": "There is an issue in the following code. It relates to ITE: drivers/gpio: Fix untrusted loop bound\n\nThe pin in the loop start counting from 0, so the condition of the\nfor loop should not be equal to num_pins.\n\nFixes #69118 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|pin\noperator|=\nliteral|0\ninit|;\nname|pin\noperator|<=\nname|num_pins\ncondition|;\nname|pin\noperator|++\ncontrol|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|<=\n+operator|<\nThe issue was with: ITE: drivers/gpio: Fix untrusted loop bound\n\nThe pin in the loop start counting from 0, so the condition of the\nfor loop should not be equal to num_pins.\n\nFixes #69118"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: adc: ad5592: use K_KERNEL_STACK_SIZEOF()\n\nUse K_KERNEL_STACK_SIZEOF() for calculating thread stack size, as this\ntakes K_KERNEL_STACK_RESERVED into account.\n\nFixes: #69133 Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|data\noperator|->\nname|stack\nargument_list|,\nname|CONFIG_ADC_AD5592_ACQUISITION_THREAD_STACK_SIZE\nargument_list|,\noperator|(\nname|k_thread_entry_t\noperator|)\nname|adc_ad5592_acquisition_thread",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_ADC_AD5592_ACQUISITION_THREAD_STACK_SIZE\n+name|K_KERNEL_STACK_SIZEOF\n+argument_list|(\n+name|data\n+operator|->\n+name|stack\n+argument_list|)\nThe issue was with: drivers: adc: ad5592: use K_KERNEL_STACK_SIZEOF()\n\nUse K_KERNEL_STACK_SIZEOF() for calculating thread stack size, as this\ntakes K_KERNEL_STACK_RESERVED into account.\n\nFixes: #69133"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: adc: ads7052: use K_KERNEL_STACK_SIZEOF()\n\nUse K_KERNEL_STACK_SIZEOF() for calculating thread stack size, as this\ntakes K_KERNEL_STACK_RESERVED into account.\n\nFixes: #69132 Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|data\noperator|->\nname|stack\nargument_list|,\nname|CONFIG_ADC_ADS7052_ACQUISITION_THREAD_STACK_SIZE\nargument_list|,\nname|ads7052_acquisition_thread\nargument_list|,\nname|data\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_ADC_ADS7052_ACQUISITION_THREAD_STACK_SIZE\n+name|K_KERNEL_STACK_SIZEOF\n+argument_list|(\n+name|data\n+operator|->\n+name|stack\n+argument_list|)\nThe issue was with: drivers: adc: ads7052: use K_KERNEL_STACK_SIZEOF()\n\nUse K_KERNEL_STACK_SIZEOF() for calculating thread stack size, as this\ntakes K_KERNEL_STACK_RESERVED into account.\n\nFixes: #69132"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: adc: lmp90xxx: use K_KERNEL_STACK_SIZEOF()\n\nUse K_KERNEL_STACK_SIZEOF() for calculating thread stack size, as this\ntakes K_KERNEL_STACK_RESERVED into account.\n\nFixes: #69131 Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|data\noperator|->\nname|stack\nargument_list|,\nname|CONFIG_ADC_LMP90XXX_ACQUISITION_THREAD_STACK_SIZE\nargument_list|,\nname|lmp90xxx_acquisition_thread\nargument_list|,\nname|data\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_ADC_LMP90XXX_ACQUISITION_THREAD_STACK_SIZE\n+name|K_KERNEL_STACK_SIZEOF\n+argument_list|(\n+name|data\n+operator|->\n+name|stack\n+argument_list|)\nThe issue was with: drivers: adc: lmp90xxx: use K_KERNEL_STACK_SIZEOF()\n\nUse K_KERNEL_STACK_SIZEOF() for calculating thread stack size, as this\ntakes K_KERNEL_STACK_RESERVED into account.\n\nFixes: #69131"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: adc: mcp320x: use K_KERNEL_STACK_SIZEOF()\n\nUse K_KERNEL_STACK_SIZEOF() for calculating thread stack size, as this\ntakes K_KERNEL_STACK_RESERVED into account.\n\nFixes: #69130 Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|data\noperator|->\nname|stack\nargument_list|,\nname|CONFIG_ADC_MCP320X_ACQUISITION_THREAD_STACK_SIZE\nargument_list|,\nname|mcp320x_acquisition_thread\nargument_list|,\nname|data\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_ADC_MCP320X_ACQUISITION_THREAD_STACK_SIZE\n+name|K_KERNEL_STACK_SIZEOF\n+argument_list|(\n+name|data\n+operator|->\n+name|stack\n+argument_list|)\nThe issue was with: drivers: adc: mcp320x: use K_KERNEL_STACK_SIZEOF()\n\nUse K_KERNEL_STACK_SIZEOF() for calculating thread stack size, as this\ntakes K_KERNEL_STACK_RESERVED into account.\n\nFixes: #69130"
},{
  "instruction": "There is an issue in the following code. It relates to net: lib: coap: Add error check when waking server thread\n\nThere's not much to be done in case waking up the server thread with\nsocketpair send() fails, but at least we can log an error on such event\n(to please coverity). Please fix this issue.",
  "input": "Faulty tokenized code:\nname|coap_server_update_services\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nname|zsock_send\nargument_list|(\nargument|control_socks[\nliteral|1\nargument|]\nargument_list|,\nliteral|1\nargument_list|,\nliteral|0\nargument_list|)\nempty_stmt|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|coap_service_in_section (const struct coap_service * service)\ndecl_stmt|;\nname|struct\nname|sockaddr_storage\nname|addr_storage\ndecl_stmt|;\nDECL|union|__anon2a0acadb010a\nunion|union\nblock|{\nDECL|member|addr\nname|struct\nname|sockaddr",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n-empty_stmt|;\n+operator|<\n+literal|0\n+condition|)\n+block|{\n+name|LOG_ERR\n+argument_list|(\n+literal|\"Failed to notify server thread (%d)\"\n+argument_list|,\n+name|errno\n+argument_list|)\n+expr_stmt|;\n+block|}\n-DECL|union|__anon2a0acadb010a\n+DECL|union|__anon2acbb828010a\nThe issue was with: net: lib: coap: Add error check when waking server thread\n\nThere's not much to be done in case waking up the server thread with\nsocketpair send() fails, but at least we can log an error on such event\n(to please coverity)."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: charger: bq25180: fix return value check\n\nFix missing check of the return value of `bq25180_set_charge_current`\nfunction, resulting in logically dead code, as indicated by Coverity\nCID 347197. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|initial_current_microamp\noperator|>\nliteral|0\ncondition|)\nblock|{\nname|bq25180_set_charge_current\nargument_list|(\nname|dev\nargument_list|,\nname|cfg",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|ret\n+operator|=\nThe issue was with: drivers: charger: bq25180: fix return value check\n\nFix missing check of the return value of `bq25180_set_charge_current`\nfunction, resulting in logically dead code, as indicated by Coverity\nCID 347197."
},{
  "instruction": "There is an issue in the following code. It relates to arch: Fix bounds checking for dynamic shared interrupts\n\nFixes z_isr_install() and z_isr_uninstall() routines to check the isr\ntable index against the correct number of isr table entries. This\nprevents out-of-bounds isr table accesses when\nCONFIG_GEN_IRQ_START_VECTOR is greater than zero, such as on the ARC\narchitecture.\n\nCoverity-CID: 347187\nCoverity-CID: 347189\nCoverity-CID: 347097\nCoverity-CID: 347203\nCoverity-CID: 347210 Please fix this issue.",
  "input": "Faulty tokenized code:\ncomment|/* check for out of bounds table index */\nif|if\ncondition|(\nname|table_idx\noperator|>=\nname|CONFIG_NUM_IRQS\ncondition|)\nblock|{\nreturn|return;\nblock|}\nname|shared_entry\ncomment|/* check for out of bounds table index */\nif|if\ncondition|(\nname|table_idx\noperator|>=\nname|CONFIG_NUM_IRQS\ncondition|)\nblock|{\nreturn|return\noperator|-\nname|EINVAL",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_NUM_IRQS\n+name|IRQ_TABLE_SIZE\n-name|CONFIG_NUM_IRQS\n+name|IRQ_TABLE_SIZE\nThe issue was with: arch: Fix bounds checking for dynamic shared interrupts\n\nFixes z_isr_install() and z_isr_uninstall() routines to check the isr\ntable index against the correct number of isr table entries. This\nprevents out-of-bounds isr table accesses when\nCONFIG_GEN_IRQ_START_VECTOR is greater than zero, such as on the ARC\narchitecture.\n\nCoverity-CID: 347187\nCoverity-CID: 347189\nCoverity-CID: 347097\nCoverity-CID: 347203\nCoverity-CID: 347210"
},{
  "instruction": "There is an issue in the following code. It relates to ieee802154: ieee802154_cc13xx_cc26xx_subg: Fix 6lowpan for cc1352p7\n\n- Fix using custom setup function\n- Enable pRegOverrideTxStd and pRegOverrideTx20 in\n  ieee802154_cc13xx_subg_radio_div_setup struct Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|elif\nname|defined\nargument_list|(\nname|CONFIG_SOC_CC1352P\nargument_list|)\nend_elif\n\nbegin_decl_stmt\nspecifier|extern\nspecifier|volatile\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_SOC_CC1352P\nargument_list|)\noperator|.\nname|pRegOverrideTxStd\noperator|=\nname|rf_prop_overrides_tx_std\nblock|,\noperator|=\nname|rf_prop_overrides_tx_20\nblock|,\nendif|#\ndirective|endif\ncomment|/* CONFIG_SOC_CC1352P */\nblock|}\nblock|;\nendif|#\ndirective|endif\ncomment|/* CONFIG_IEEE802154_CC13XX_CC26XX_SUB_GHZ_CUSTOM_RADIO_SETUP */",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|||\n+name|defined\n+argument_list|(\n+name|CONFIG_SOC_CC1352P7\n+argument_list|)\n+operator|||\n+name|defined\n+argument_list|(\n+name|CONFIG_SOC_CC1352P7\n+argument_list|)\n-comment|/* CONFIG_SOC_CC1352P */\n+comment|/* CONFIG_SOC_CC1352P, CONFIG_SOC_CC1352P7 */\nThe issue was with: ieee802154: ieee802154_cc13xx_cc26xx_subg: Fix 6lowpan for cc1352p7\n\n- Fix using custom setup function\n- Enable pRegOverrideTxStd and pRegOverrideTx20 in\n  ieee802154_cc13xx_subg_radio_div_setup struct"
},{
  "instruction": "There is an issue in the following code. It relates to native_simulator: Get latest from upstream\n\nAlign with native_simulator's upstream main\nf02906708cf1668fe54ef2c2f1e159ed947573aa\n\nWhich includes:\n* f029067 CPU ctrl: Fix two malformed error/warning messages\n* 114f78b Host trampolines: Fix typos in comment Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright (c) 2023 Nordic Semiconductor ASA  *  * SPDX-License-Identifier: Apache-2.0  *  * The native simulator provides a set of trampolines to some of the simplest  * host C library symbols.  * These are intended to facilitate test embedded code interacting with the host.  *  * We should never include here symbols which require host headers be exposed  * to the embedded side, for example due to non-basic types being used in  * function calls, as that would break the include path isolation  *  * Naming convention: nsi_host_<fun>() where<func> is the name of the equivalent  * C library call we call thru.  */\nend_comment\n\nbegin_ifndef\nifndef|#\ndirective|ifndef\nname|CPU_N_RANGE_CHECK\nparameter_list|(\nname|cpu_n\nparameter_list|)\ndefine|\\\nvalue|if (cpu_n>= NSI_N_CPUS) { \\ \t\tnsi_print_error_and_exit(\"%s called with cpu_n(%i)>= NSI_N_CPUS (%i)\\n\", \\ \t\t\t\t\t cpu_n, NSI_N_CPUS); \\ \t}\nend_define\n\nbegin_function\nDECL|function|nsi_cpu_set_auto_start (int cpu_n,bool auto_start)\nname|void\nblock|{\nname|nsi_print_warning\nargument_list|(\nliteral|\"%s called with cpu_n(%i) which was already booted\\n\"\nargument_list|,\nname|cpu_n\nargument_list|)\nexpr_stmt|;\nblock|}\nname|cpu_booted",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/*  * Copyright (c) 2023 Nordic Semiconductor ASA  *  * SPDX-License-Identifier: Apache-2.0  *  * The native simulator provides a set of trampolines to some of the simplest  * host C library symbols.  * These are intended to facilitate test embedded code interacting with the host.  *  * We should never include here symbols which require host headers be exposed  * to the embedded side, for example due to non-basic types being used in  * function calls, as that would break the include path isolation  *  * Naming convention: nsi_host_<fun>() where<func> is the name of the equivalent  * C library call we call thru.  */\n+comment|/*  * Copyright (c) 2023 Nordic Semiconductor ASA  *  * SPDX-License-Identifier: Apache-2.0  *  * The native simulator provides a set of trampolines to some of the simplest  * host C library symbols.  * These are intended to facilitate test embedded code interacting with the host.  *  * We should never include here symbols which require host headers be exposed  * to the embedded side, for example due to non-basic types being used in  * function calls, as that would break the include path isolation  *  * Naming convention: nsi_host_<fun>() where<func> is the name of the equivalent  * C library function we call through  */\n-value|if (cpu_n>= NSI_N_CPUS) { \\ \t\tnsi_print_error_and_exit(\"%s called with cpu_n(%i)>= NSI_N_CPUS (%i)\\n\", \\ \t\t\t\t\t cpu_n, NSI_N_CPUS); \\ \t}\n+value|if (cpu_n>= NSI_N_CPUS) { \\ \t\tnsi_print_error_and_exit(\"%s called with cpu_n(%i)>= NSI_N_CPUS (%i)\\n\", \\ \t\t\t\t\t __func__, cpu_n, NSI_N_CPUS); \\ \t}\n+name|__func__\n+argument_list|,\nThe issue was with: native_simulator: Get latest from upstream\n\nAlign with native_simulator's upstream main\nf02906708cf1668fe54ef2c2f1e159ed947573aa\n\nWhich includes:\n* f029067 CPU ctrl: Fix two malformed error/warning messages\n* 114f78b Host trampolines: Fix typos in comment"
},{
  "instruction": "There is an issue in the following code. It relates to soc: arm: nxp_imx: fix flexspi frequency setting for iMXRT11xx SOC\n\nCommit 21a4ec30174 [formerly a10fee2d5e9] (drivers: clock_control: ccm_rev2: add support for\nreclocking FlexSPI) introduced the ability to set the FlexSPI\nclock frequency at runtime on RT11xx series SOCs. However, this\nimplementation resulted in the clock frequency being rounded up, not\ndown. This can result in flash clock frequency violations on some\nflash parts, causing the system to crash when running in XIP mode.\n\nFixes #69088 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|CLOCK_GetFreq\nargument_list|(\nname|root\nargument_list|)\nexpr_stmt|;\ncomment|/* Select a divider based on root frequency */\nname|divider\noperator|=\nname|MIN\nargument_list|(\noperator|(\nname|root_rate\noperator|/\nname|rate\noperator|)\nargument_list|,\nname|CCM_CLOCK_ROOT_CONTROL_DIV_MASK\nargument_list|)\nexpr_stmt|;\nwhile|while",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* Select a divider based on root frequency */\n+comment|/* Select a divider based on root clock frequency. We round the \t * divider up, so that the resulting clock frequency is lower than \t * requested when we can't output the exact requested frequency \t */\n-name|MIN\n-argument_list|(\n+operator|(\n+operator|+\n+operator|(\n+name|rate\n+operator|-\n+literal|1\n+operator|)\n+operator|)\n+expr_stmt|;\n+comment|/* Cap divider to max value */\n+name|divider\n+operator|=\n+name|MIN\n+argument_list|(\n+name|divider\nThe issue was with: soc: arm: nxp_imx: fix flexspi frequency setting for iMXRT11xx SOC\n\nCommit 21a4ec30174 [formerly a10fee2d5e9] (drivers: clock_control: ccm_rev2: add support for\nreclocking FlexSPI) introduced the ability to set the FlexSPI\nclock frequency at runtime on RT11xx series SOCs. However, this\nimplementation resulted in the clock frequency being rounded up, not\ndown. This can result in flash clock frequency violations on some\nflash parts, causing the system to crash when running in XIP mode.\n\nFixes #69088"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: BAP: UC: Fix call to bt_gatt_get_mtu in notify\n\nIn the unicast_client_ep_notify we would always call\nbt_gatt_get_mtu, regardless of whether data == NULL.\n\nWhen there is a disconnection, the notify callbacks are\ncalled with data == NULL to indicate a unsubscription.\nIn the case of the unicast client, this would also trigger\ncalls to bt_gatt_get_mtu when there is a disconnect, which\nin turn would trigger a warning that ATT is not connected.\n\nPostponing the call to bt_gatt_get_mtu fixes this. Please fix this issue.",
  "input": "Faulty tokenized code:\ndecl_stmt|;\nDECL|member|busy\nname|bool\nname|busy\ndecl_stmt|;\nDECL|union|__anon27c13430010a\nunion|union\nblock|{\nDECL|member|read_params\nname|struct\nname|bt_gatt_read_params\nname|att_ntf_header_size\ninit|=\nliteral|3\ndecl_stmt|;\ncomment|/* opcode (1) + handle (2) */\nspecifier|const\nname|uint16_t\nname|max_ntf_size\ninit|=\nname|bt_gatt_get_mtu\nargument_list|(\nname|conn\nargument_list|)\noperator|-\nname|att_ntf_header_size\ndecl_stmt|;\nname|struct\nname|bt_bap_ep\nmodifier|*\nname|ep\nexpr_stmt|;\nreturn|return\nname|BT_GATT_ITER_STOP\nreturn|;\nblock|}\nif|if\ncondition|(\nname|length\noperator|==\nname|max_ntf_size",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon27c13430010a\n+DECL|union|__anon2c5fb59c010a\n-specifier|const\n-init|=\n-name|bt_gatt_get_mtu\n-argument_list|(\n-name|conn\n-argument_list|)\n-operator|-\n-name|att_ntf_header_size\n+name|max_ntf_size\n+operator|=\n+name|bt_gatt_get_mtu\n+argument_list|(\n+name|conn\n+argument_list|)\n+operator|-\n+name|att_ntf_header_size\n+expr_stmt|;\nThe issue was with: Bluetooth: BAP: UC: Fix call to bt_gatt_get_mtu in notify\n\nIn the unicast_client_ep_notify we would always call\nbt_gatt_get_mtu, regardless of whether data == NULL.\n\nWhen there is a disconnection, the notify callbacks are\ncalled with data == NULL to indicate a unsubscription.\nIn the case of the unicast client, this would also trigger\ncalls to bt_gatt_get_mtu when there is a disconnect, which\nin turn would trigger a warning that ATT is not connected.\n\nPostponing the call to bt_gatt_get_mtu fixes this."
},{
  "instruction": "There is an issue in the following code. It relates to modem: hl7800: Fix null reference in hl7800_net_addr6_pton\n\nEnsure a potential null pointer is not incremented. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|src\nargument_list|,\nliteral|'.'\nargument_list|)\nexpr_stmt|;\nname|src\noperator|++\nexpr_stmt|;\nif|if\ncondition|(\noperator|!\nname|src\noperator|||\noperator|*\nname|src\noperator|==\nliteral|'\\0'\ncondition|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+operator|!\n+name|src\n+condition|)\n+block|{\n+return|return\n+operator|-\n+name|EINVAL\n+return|;\n+block|}\n-operator|!\n-name|src\n-operator|||\nThe issue was with: modem: hl7800: Fix null reference in hl7800_net_addr6_pton\n\nEnsure a potential null pointer is not incremented."
},{
  "instruction": "There is an issue in the following code. It relates to modem: cmux: Prevent NULL deref in connect_response_transmit\n\nPrevent potential NULL dereference identified by CID 338026 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|modem_cmux\nmodifier|*\nname|cmux\nparameter_list|)\nblock|{\nname|struct\nname|modem_cmux_frame\nname|frame\ninit|=\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|cmux\n+operator|==\n+name|NULL\n+condition|)\n+block|{\n+return|return;\n+block|}\nThe issue was with: modem: cmux: Prevent NULL deref in connect_response_transmit\n\nPrevent potential NULL dereference identified by CID 338026"
},{
  "instruction": "There is an issue in the following code. It relates to modules: openthread: platform: logging: catch up on log2_generic rename\n\nThe log2_generic() function was renamed to log_generic().\n\nFixes: 7f522fcb326a72a99f6e92bdd59ca2e6eaf35499 [formerly 2155a9e5f7771e05bd80b3505dd7804865ca1360] Please fix this issue.",
  "input": "Faulty tokenized code:\nname|param_list\nargument_list|,\nname|aFormat\nargument_list|)\nexpr_stmt|;\nname|log2_generic\nargument_list|(\nname|level\nargument_list|,\nname|aFormat\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|log2_generic\n+name|log_generic\nThe issue was with: modules: openthread: platform: logging: catch up on log2_generic rename\n\nThe log2_generic() function was renamed to log_generic().\n\nFixes: 7f522fcb326a72a99f6e92bdd59ca2e6eaf35499 [formerly 2155a9e5f7771e05bd80b3505dd7804865ca1360]"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: clock_control: ra: sub-clock oscillator select fix\n\nDue to a typo it is not possible to select the sub-clock oscillator\n(SOSC) as a clock source for an RA Microcontroller. This patch resolves\nthe issue. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_define\nDECL|macro|SYSCLK_SRC\ndefine|#\ndirective|define\nname|SYSCLK_SRC\nvalue|soco\nend_define\n\nbegin_elif\nelif|#\ndirective|elif\nname|z_clock_hw_cycles_per_sec\ndecl_stmt|;\nend_decl_stmt\n\nbegin_enum\nDECL|enum|__anon2ba921170103\nenum|enum\nblock|{\nDECL|enumerator|CLKSRC_hoco\nname|CLKSRC_hoco\ninit|=\nblock|, }\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon2ba921170203\nenum|enum\nblock|{\nDECL|enumerator|SCKDIV_1\nname|SCKDIV_1\ninit|=\nblock|}\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon2ba921170303\nenum|enum\nblock|{\nDECL|enumerator|SCKDIV_POS_pclkd\nname|SCKDIV_POS_pclkd\ninit|=\nblock|}\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon2ba921170403\nenum|enum\nblock|{\nDECL|enumerator|OSCSF_HOCOSF_POS\nname|OSCSF_HOCOSF_POS\ninit|=\nblock|, }\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon2ba921170503\nenum|enum\nblock|{\nDECL|enumerator|OPCCR_OPCMTSF_POS\nname|OPCCR_OPCMTSF_POS\ninit|=\nliteral|0x2U\ndecl_stmt|;\nend_decl_stmt\n\nbegin_enum\nDECL|enum|__anon2ba921170603\nenum|enum\nblock|{\nif|#\ndirective|if\nname|DT_INST_REG_SIZE_BY_NAME\nblock|, }\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon2ba921170703\nenum|enum\nblock|{\nDECL|enumerator|SCKDIVCR_OFFSET\nname|SCKDIVCR_OFFSET\ninit|=\nblock|, }\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon2ba921170803\nenum|enum\nblock|{\nDECL|enumerator|SCRSCK_hoco\nname|SCRSCK_hoco\nblock|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|soco\n+value|sosc\n-DECL|enum|__anon2ba921170103\n+DECL|enum|__anon27f7fc760103\n-DECL|enum|__anon2ba921170203\n+DECL|enum|__anon27f7fc760203\n-DECL|enum|__anon2ba921170303\n+DECL|enum|__anon27f7fc760303\n-DECL|enum|__anon2ba921170403\n+DECL|enum|__anon27f7fc760403\n-DECL|enum|__anon2ba921170503\n+DECL|enum|__anon27f7fc760503\n-DECL|enum|__anon2ba921170603\n+DECL|enum|__anon27f7fc760603\n-DECL|enum|__anon2ba921170703\n+DECL|enum|__anon27f7fc760703\n-DECL|enum|__anon2ba921170803\n+DECL|enum|__anon27f7fc760803\nThe issue was with: drivers: clock_control: ra: sub-clock oscillator select fix\n\nDue to a typo it is not possible to select the sub-clock oscillator\n(SOSC) as a clock source for an RA Microcontroller. This patch resolves\nthe issue."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: CAP: Shell: Fix argument issue for unicast_stop\n\nThe unicast_stop command takes either \\\"all\\\" or one or more\nstream pointers as argument, but the argument handler did\nnot allow this.\n\nThe documentation for the command was also out of date. Please fix this issue.",
  "input": "Faulty tokenized code:\n     discover        :Discover CAS\n     unicast_start   :Unicast Start [csip] [sinks <cnt> (default 1)] [sources <cnt>\n                      (default 1)] [conns (<cnt> | all) (default 1)]\n     unicast_list    :Unicast list streams\n     unicast_update  :Unicast Update <all | stream [stream [stream...]]>\n    unicast_stop    :Unicast stop all streams\n     unicast_cancel  :Unicast cancel current procedure\n\nBefore being able to perform any stream operation, the device must also perform the\n:code:`bap discover` operation to discover the ASEs and PAC records. The :code:`bap init`\ncommand also needs to be called.\nBoth of the above commands should be done for each device that you want to use in the set.\nTo use multiple devices, simply connect to more and then use :code:`bt select` the device to execute\nthe commands on.\n\nOnce all devices have been connected and the respective discovery commands have been called, the\n:code:`cap_initiator unicast-start` command can be used to put one or more streams into the\nstreaming state.\n\n.. code-block:: console\n\n  uart:~$ cap_initiator unicast-start sinks 1 sources 0 conns all\n   Setting up 1 sinks and 0 sources on each (2) conn\n   Starting 1 streams\n   Unicast start completed\n\nTo stop all the streams that has been started, the :code:`cap_initiator unicast-stop` command can be\nused.\n\n\n.. code-block:: console\n\n  uart:~$ cap_initiator unicast-stop\n  Unicast stopped for group 0x81e41c0 completed\n\nCAP Commander\n*************\n\nThe Commander will typically be a either co-located with a CAP Initiator or be on a separate\nblock|{\nname|shell_print\nargument_list|(\nname|ctx_shell\nargument_list|,\nliteral|\"Unicast stopped completed\"\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|default_unicast_group\nargument_list|(\nname|unicast_stop\nargument_list|,\nname|NULL\nargument_list|,\nliteral|\"Unicast stop all streams\"\nargument_list|,\nname|cmd_cap_initiator_unicast_stop\nargument_list|,\nliteral|1\nargument_list|,\nliteral|0\nargument_list|)\nargument_list|,\nname|SHELL_CMD_ARG\nargument_list|(\nname|unicast_cancel",
  "result": "I corrected the issue in the code by changing the following tokens:\n-     unicast_stop    :Unicast stop all streams\n+     unicast_stop    :Unicast stop streams <all | stream [stream [stream...]]>\n-:code:`cap_initiator unicast-start` command can be used to put one or more streams into the\n+:code:`cap_initiator unicast_start` command can be used to put one or more streams into the\n-   uart:~$ cap_initiator unicast-start sinks 1 sources 0 conns all\n+   uart:~$ cap_initiator unicast_start sinks 1 sources 0 conns all\n-To stop all the streams that has been started, the :code:`cap_initiator unicast-stop` command can be\n+To stop all the streams that has been started, the :code:`cap_initiator unicast_stop` command can be\n-   uart:~$ cap_initiator unicast-stop\n-   Unicast stopped for group 0x81e41c0 completed\n+   uart:~$ cap_initiator unicast_stop all\n+   Unicast stop completed\n-literal|\"Unicast stopped completed\"\n+literal|\"Unicast stop completed\"\n-literal|\"Unicast stop all streams\"\n+literal|\"Unicast stop streams<all | stream [stream [stream...]]>\"\n-literal|1\n+literal|2\n-literal|0\n+name|CAP_UNICAST_CLIENT_STREAM_COUNT\nThe issue was with: Bluetooth: CAP: Shell: Fix argument issue for unicast_stop\n\nThe unicast_stop command takes either \\\"all\\\" or one or more\nstream pointers as argument, but the argument handler did\nnot allow this.\n\nThe documentation for the command was also out of date."
},{
  "instruction": "There is an issue in the following code. It relates to modem: hl7800: fix parsing APN username\n\nEnsure a null reference cannot happen if there is an issue\nparsing the APN username. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|p\noperator|++\nexpr_stmt|;\nblock|}\nblock|}\nname|LOG_INF\nargument_list|(\nliteral|\"APN Username: %s\"\nargument_list|,\nname|iface_ctx\nname|password\nargument_list|)\nexpr_stmt|;\nblock|}\nblock|}\nname|net_buf_remove\nargument_list|(\nname|buf\nargument_list|,\nname|line_length",
  "result": "I corrected the issue in the code by changing the following tokens:\n+else|else\n+block|{\n+name|LOG_WRN\n+argument_list|(\n+literal|\"Issue parsing APN username\"\n+argument_list|)\n+expr_stmt|;\n+goto|goto\n+name|done\n+goto|;\n+block|}\n+name|done\n+label|:\nThe issue was with: modem: hl7800: fix parsing APN username\n\nEnsure a null reference cannot happen if there is an issue\nparsing the APN username."
},{
  "instruction": "There is an issue in the following code. It relates to tests: workq/user_work: change how resource pool is exhausted\n\nThe assumption of going through 100 iterations of allocating for\nwork queue is that the HEAP size is 1024 bytes. However, there\nare platforms where the HEAP size is inflated due to subsystems\nand/or drivers being included. So change the for loop into\na loop where it only stops until there is no memory to be\nallocated. Please fix this issue.",
  "input": "Faulty tokenized code:\nindex|]\nargument_list|)\nargument_list|)\nexpr_stmt|;\ncomment|/* use up the memory in resource pool */\nfor|for\ncontrol|(\nname|int\nname|i\ninit|=\nliteral|0\ninit|;\nname|i\noperator|<\nliteral|100\ncondition|;\nname|i\noperator|++\ncontrol|)\nblock|{\nname|ret\noperator|=\nname|k_queue_alloc_append\nargument_list|(\ncondition|)\nblock|{\nbreak|break;\nblock|}\nblock|}\nname|k_work_user_submit_to_queue\nargument_list|(\noperator|&\nname|user_workq\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-for|for\n-control|(\n-name|int\n-name|i\n-init|=\n-literal|0\n-init|;\n-name|i\n-operator|<\n-literal|100\n-condition|;\n-name|i\n-operator|++\n-control|)\n+do|do\n+do|while\n+condition|(\n+name|true\n+condition|)\n+do|;\nThe issue was with: tests: workq/user_work: change how resource pool is exhausted\n\nThe assumption of going through 100 iterations of allocating for\nwork queue is that the HEAP size is 1024 bytes. However, there\nare platforms where the HEAP size is inflated due to subsystems\nand/or drivers being included. So change the for loop into\na loop where it only stops until there is no memory to be\nallocated."
},{
  "instruction": "There is an issue in the following code. It relates to logging: rename log2_generic to log_generic\n\nThe log2 prefix was deprecated and changed to log some time ago,\nbut log2_generic() seems to have been inadvertantly left with\nthe old prefix.\n\nRename log2_generic() to log_generic() to follow suit. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ARG_UNUSED\nargument_list|(\nname|fmt\nargument_list|)\nblock|; }\ncomment|/**  * @brief Writes a generic log message to the logging v2.  *  * @note This function is intended to be used when porting other log systems.  *  * @param level          Log level..  * @param fmt            String to format.  * @param ap             Pointer to arguments list.  */\nDECL|function|log2_generic (uint8_t level,const char * fmt,va_list ap)\nspecifier|static\nspecifier|inline\nname|void\nname|log2_generic\nargument_list|(\nargument|uint8_t level\nargument_list|,\nargument|const char *fmt\nargument_list|,\nname|ap\nargument_list|,\nname|fmt\nargument_list|)\nexpr_stmt|;\nname|log2_generic\nargument_list|(\nname|log_level_lut\nindex|[\nname|level\nindex|]\nname|ap\nargument_list|,\nname|fmt\nargument_list|)\nexpr_stmt|;\nname|log2_generic\nargument_list|(\nname|LOG_LEVEL_INF\nargument_list|,\nname|fmt\nargument_list|,\nname|ap\nargument_list|,\nname|fmt\nargument_list|)\nexpr_stmt|;\nname|log2_generic\nargument_list|(\nname|LOG_LEVEL_INF\nargument_list|,\nname|fmt\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/**  * @brief Writes a generic log message to the logging v2.  *  * @note This function is intended to be used when porting other log systems.  *  * @param level          Log level..  * @param fmt            String to format.  * @param ap             Pointer to arguments list.  */\n-DECL|function|log2_generic (uint8_t level,const char * fmt,va_list ap)\n+comment|/**  * @brief Write a generic log message.  *  * @note This function is intended to be used when porting other log systems.  *  * @param level          Log level..  * @param fmt            String to format.  * @param ap             Pointer to arguments list.  */\n+DECL|function|log_generic (uint8_t level,const char * fmt,va_list ap)\n-name|log2_generic\n+name|log_generic\n-name|log2_generic\n+name|log_generic\n-name|log2_generic\n+name|log_generic\n-name|log2_generic\n+name|log_generic\nThe issue was with: logging: rename log2_generic to log_generic\n\nThe log2 prefix was deprecated and changed to log some time ago,\nbut log2_generic() seems to have been inadvertantly left with\nthe old prefix.\n\nRename log2_generic() to log_generic() to follow suit."
},{
  "instruction": "There is an issue in the following code. It relates to modem: hl7800: validate IPv4 DNS addr len for IPv6\n\nIf the IPv6 DNS address is not a valid address, DNS will fallback\nto the IPv4 DNS address.\nFix copying the IPv4 address to the IPv6 address by using\nthe IPv6 address destination length. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|iface_ctx\noperator|.\nname|dns_v4_string\nargument_list|,\nname|strlen\nargument_list|(\nname|iface_ctx\noperator|.\nname|dns_v4_string\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|valid_address\noperator|=\nname|net_ipaddr_parse",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|strlen\n+sizeof|sizeof\n-name|dns_v4_string\n+name|dns_v6_string\n+operator|-\n+literal|1\nThe issue was with: modem: hl7800: validate IPv4 DNS addr len for IPv6\n\nIf the IPv6 DNS address is not a valid address, DNS will fallback\nto the IPv4 DNS address.\nFix copying the IPv4 address to the IPv6 address by using\nthe IPv6 address destination length."
},{
  "instruction": "There is an issue in the following code. It relates to modem: modem_cellular: CID 338067\n\nincorrect size passed to strncpy() Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|data\noperator|->\nname|imsi\nargument_list|,\noperator|(\nname|char\noperator|*\noperator|)\nname|argv\nindex|[\nliteral|1\nindex|]\nargument_list|,\nargument_list|(\nname|data\noperator|->\nname|imsi\nargument_list|)\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|(\n-name|char\n-operator|*\n-operator|)\n+operator|-\n+literal|1\nThe issue was with: modem: modem_cellular: CID 338067\n\nincorrect size passed to strncpy()"
},{
  "instruction": "There is an issue in the following code. It relates to modem: modem_cellular: CID 338073\n\nincorrect size passed to strncpy() Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|data\noperator|->\nname|imei\nargument_list|)\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|-\n+literal|1\nThe issue was with: modem: modem_cellular: CID 338073\n\nincorrect size passed to strncpy()"
},{
  "instruction": "There is an issue in the following code. It relates to modem: modem_cellular: CID 338115\n\nincorrect size passed to strncpy() Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|data\noperator|->\nname|model_id\nargument_list|)\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|-\n+literal|1\nThe issue was with: modem: modem_cellular: CID 338115\n\nincorrect size passed to strncpy()"
},{
  "instruction": "There is an issue in the following code. It relates to modem: modem_cellular: CID 338140\n\nincorrect size passed to strncpy Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|data\noperator|->\nname|manufacturer\nargument_list|)\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|-\n+literal|1\nThe issue was with: modem: modem_cellular: CID 338140\n\nincorrect size passed to strncpy"
},{
  "instruction": "There is an issue in the following code. It relates to modem: modem_cellular: CID 338164\n\nstrncpy() passed incorrect size Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|data\noperator|->\nname|fw_version\nargument_list|)\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|-\n+literal|1\nThe issue was with: modem: modem_cellular: CID 338164\n\nstrncpy() passed incorrect size"
},{
  "instruction": "There is an issue in the following code. It relates to mgmt: mcumgr: img_mgmt_client: avoid using uninitialized variable\n\nMake sure temp_data is initialized before use.\n\nFixes: #68636 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|MCUMGR_UPLOAD_INIT_HEADER_BUF_SIZE\nindex|]\ndecl_stmt|;\nname|uint8_t\nname|temp_data\ndecl_stmt|;\ncomment|/* Calculation of message header with data length of 1 */\nname|zcbor_new_encode_state\nargument_list|(\nname|zse",
  "result": "I corrected the issue in the code by changing the following tokens:\n+init|=\n+literal|0U\nThe issue was with: mgmt: mcumgr: img_mgmt_client: avoid using uninitialized variable\n\nMake sure temp_data is initialized before use.\n\nFixes: #68636"
},{
  "instruction": "There is an issue in the following code. It relates to samples: Bluetooth: Broadcast Audio Source: Fix potential memory leak\n\nIn error cases, where send_data() returns early, the allocated net_buf\nis not free'd, causing a memory leak affecting the net_buf pool.\nFix this by freeing the allocated net_buf before returning early\nfrom send_data(). Please fix this issue.",
  "input": "Faulty tokenized code:\nname|printk\nargument_list|(\nliteral|\"LC3 encoder not setup, cannot encode data.\\n\"\nargument_list|)\nexpr_stmt|;\nreturn|return;\nblock|}\nif|#\ndirective|if\nname|defined\nliteral|\"LC3 encoder failed - wrong parameters?: %d\"\nargument_list|,\nname|ret\nargument_list|)\nexpr_stmt|;\nreturn|return;\nblock|}\nname|net_buf_add_mem\nargument_list|(\nname|buf",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|net_buf_unref\n+argument_list|(\n+name|buf\n+argument_list|)\n+expr_stmt|;\n+name|net_buf_unref\n+argument_list|(\n+name|buf\n+argument_list|)\n+expr_stmt|;\nThe issue was with: samples: Bluetooth: Broadcast Audio Source: Fix potential memory leak\n\nIn error cases, where send_data() returns early, the allocated net_buf\nis not free'd, causing a memory leak affecting the net_buf pool.\nFix this by freeing the allocated net_buf before returning early\nfrom send_data()."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: led_strip: tlc5971: fix brightness control bit shifting\n\nThe lower bits of the brightness control registers were erroneously\nshifted even though FIELD_PREP already does the shifting. In practice,\nthe effect is negliglible but of course should be fixed.\n\nAlso add missing parenthesis around shifting operations to satisy static\nanalysis. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator||\nname|FIELD_PREP\nargument_list|(\nname|TLC5971_BYTE26_GBC1_MASK\nargument_list|,\nname|gbc_color_1\noperator|>>\nliteral|2\nargument_list|)\nreturn|;\nblock|}\nend_function\n\nname|FIELD_PREP\nargument_list|(\nname|TLC5971_BYTE25_GBC1_MASK\nargument_list|,\nname|gbc_color_1\noperator|<<\nliteral|6\nargument_list|)\noperator||\nname|FIELD_PREP\nargument_list|(\nname|TLC5971_BYTE25_GBC2_MASK\nargument_list|,\nname|gbc_color_2\noperator|>>\nliteral|1\nargument_list|)\nreturn|;\nblock|}\nend_function\n\nname|FIELD_PREP\nargument_list|(\nname|TLC5971_BYTE24_GBC2_MASK\nargument_list|,\nname|gbc_color_2\noperator|<<\nliteral|7\nargument_list|)\noperator||\nname|FIELD_PREP\nargument_list|(\nname|TLC5971_BYTE24_GBC3_MASK",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+operator|)\n-operator|<<\n-literal|6\n+operator|(\n+operator|)\n-operator|<<\n-literal|7\nThe issue was with: drivers: led_strip: tlc5971: fix brightness control bit shifting\n\nThe lower bits of the brightness control registers were erroneously\nshifted even though FIELD_PREP already does the shifting. In practice,\nthe effect is negliglible but of course should be fixed.\n\nAlso add missing parenthesis around shifting operations to satisy static\nanalysis."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: i2c_mchp: Replace slave by target\n\nReplace slave_register with target_register and slave_unregister\nwith target_unregister. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|ifdef\nname|CONFIG_I2C_TARGET\nend_ifdef\n\nbegin_function\nDECL|function|i2c_xec_slave_register (const struct device * dev,struct i2c_target_config * config)\nspecifier|static\nname|int\nname|i2c_xec_slave_register\nparameter_list|(\nspecifier|const\nname|struct\nname|device\nmodifier|*\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|i2c_xec_slave_unregister (const struct device * dev,struct i2c_target_config * config)\nspecifier|static\nname|int\nname|i2c_xec_slave_unregister\nparameter_list|(\nspecifier|const\nname|struct\nname|device\nmodifier|*\nblock|,\nifdef|#\ndirective|ifdef\nname|CONFIG_I2C_TARGET\noperator|.\nname|slave_register\noperator|=\nname|i2c_xec_slave_register\nblock|,\noperator|.\nname|slave_unregister\noperator|=\nname|i2c_xec_slave_unregister\nblock|,\nendif|#\ndirective|endif\nblock|}\ndecl_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|i2c_xec_slave_register (const struct device * dev,struct i2c_target_config * config)\n+DECL|function|i2c_xec_target_register (const struct device * dev,struct i2c_target_config * config)\n-name|i2c_xec_slave_register\n+name|i2c_xec_target_register\n-DECL|function|i2c_xec_slave_unregister (const struct device * dev,struct i2c_target_config * config)\n+DECL|function|i2c_xec_target_unregister (const struct device * dev,struct i2c_target_config * config)\n-name|i2c_xec_slave_unregister\n+name|i2c_xec_target_unregister\n-name|slave_register\n+name|target_register\n-name|i2c_xec_slave_register\n+name|i2c_xec_target_register\n-name|slave_unregister\n+name|target_unregister\n-name|i2c_xec_slave_unregister\n+name|i2c_xec_target_unregister\nThe issue was with: drivers: i2c_mchp: Replace slave by target\n\nReplace slave_register with target_register and slave_unregister\nwith target_unregister."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: bbram: stm32: add include to fix compilation error\n\nDriver BBRAM for STM32 had a compilation error: \\\"unknown type name\n'RTC_TypeDef'\\\" due to missing include file. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/sys/util.h>\nend_include\n\nbegin_expr_stmt\nname|LOG_MODULE_REGISTER\nargument_list|(\nname|bbram\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<stm32_ll_rtc.h>\n+end_include\n+\nThe issue was with: drivers: bbram: stm32: add include to fix compilation error\n\nDriver BBRAM for STM32 had a compilation error: \\\"unknown type name\n'RTC_TypeDef'\\\" due to missing include file."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Host: Add ISO tx check for LOG_WRN in le_init_iso\n\nThe warning should only apply for configurations where the\ndevice may actually send ISO data (e.g. not the ISO sync receiver). Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|CONFIG_BT_CONN\nargument_list|)\ncondition|)\nblock|{\nname|LOG_WRN\nargument_list|(\nliteral|\"Read Buffer Size V2 command is not supported.\"\nliteral|\"No ISO buffers will be available\"\nargument_list|)\nexpr_stmt|;\ncomment|/* Read LE Buffer Size */\nname|err\noperator|=\nname|bt_hci_cmd_send_sync\nargument_list|(\nname|hci_vs_init\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nDECL|union|__anon29aad607010a\nunion|union\nblock|{\nDECL|member|info\nname|struct\nname|bt_hci_rp_vs_read_version_info",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|IS_ENABLED\n+argument_list|(\n+name|CONFIG_BT_ISO_UNICAST\n+argument_list|)\n+operator|||\n+name|IS_ENABLED\n+argument_list|(\n+name|CONFIG_BT_ISO_BROADCASTER\n+argument_list|)\n+condition|)\n+block|{\n-literal|\"Read Buffer Size V2 command is not supported.\"\n-literal|\"No ISO buffers will be available\"\n+literal|\"Read Buffer Size V2 command is not supported. \"\n+literal|\"No ISO TX buffers will be available\"\n+block|}\n-DECL|union|__anon29aad607010a\n+DECL|union|__anon2aead6e6010a\nThe issue was with: Bluetooth: Host: Add ISO tx check for LOG_WRN in le_init_iso\n\nThe warning should only apply for configurations where the\ndevice may actually send ISO data (e.g. not the ISO sync receiver)."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: ltrf216a: fix overflow in conversion\n\nThe conversion of the raw sensor value overflows because\nonly a 32 bit multiplication is executed.\nFix the issue by promoting the raw sensor value to uint64_t before\nexecuting the multiplication.\n\nAnalysis:\nThe current implementation overflows for all raw values grater\nthan 9544(14-bit).\nBut according to the datasheet the sensor has a maximum resolution of\n20-bit. So Multiplying that value with 450.000 would need at least 39\nbit to avoid an overflow, hence do it using 64-bit arithmetic.\n\nFixes CID 330657 Please fix this issue.",
  "input": "Faulty tokenized code:\ncomment|/* \t * 0.45 -> 45 / 100, multiplied by 1000000 for millilux \t * gain 3 (default), integration time 100ms=1 \t */\nname|uint64_t\nname|microlux\ninit|=\noperator|(\nname|greendata\noperator|*\nliteral|45000\noperator|*\nname|LTRF216A_WIN_FAC",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+name|uint64_t\n+operator|)\nThe issue was with: drivers: sensor: ltrf216a: fix overflow in conversion\n\nThe conversion of the raw sensor value overflows because\nonly a 32 bit multiplication is executed.\nFix the issue by promoting the raw sensor value to uint64_t before\nexecuting the multiplication.\n\nAnalysis:\nThe current implementation overflows for all raw values grater\nthan 9544(14-bit).\nBut according to the datasheet the sensor has a maximum resolution of\n20-bit. So Multiplying that value with 450.000 would need at least 39\nbit to avoid an overflow, hence do it using 64-bit arithmetic.\n\nFixes CID 330657"
},{
  "instruction": "There is an issue in the following code. It relates to net: trickle: Print the abs value using %u\n\nThe Imax_abs value should be printed using %u instead of %d\nas it can be large and should be printed as positive value. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|Imax_abs\nargument_list|)\nexpr_stmt|;\nname|NET_DBG\nargument_list|(\nliteral|\"Imin %d Imax %u k %u Imax_abs %d\"\nargument_list|,\nname|trickle\noperator|->\nname|Imin\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"Imin %d Imax %u k %u Imax_abs %d\"\n+literal|\"Imin %d Imax %u k %u Imax_abs %u\"\nThe issue was with: net: trickle: Print the abs value using %u\n\nThe Imax_abs value should be printed using %u instead of %d\nas it can be large and should be printed as positive value."
},{
  "instruction": "There is an issue in the following code. It relates to samples: Bluetooth: Add missing svc data for broadcast audio sink\n\nAdd missing service data for BASS for the broadcast audio sink\nsample.\n\nThis also required the controller to increase its maximum data\nlength. Increased more than minimum required so that the name\ncan be changed without needing to increase this again. Please fix this issue.",
  "input": "Faulty tokenized code:\nCONFIG_BT_CTLR_SCAN_DATA_LEN_MAX=191\n\n# Number of supported streams\nCONFIG_BT_CTLR_SYNC_ISO_STREAM_MAX=2\nCONFIG_BT_CTLR_ISOAL_SINKS=2\nname|BT_UUID_16_ENCODE\nargument_list|(\nname|BT_UUID_PACS_VAL\nargument_list|)\nargument_list|)\nblock|, \t}\ndecl_stmt|;\nname|int\nname|err\ndecl_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+CONFIG_BT_CTLR_ADV_DATA_LEN_MAX=50\n+block|,\n+name|BT_DATA_BYTES\n+argument_list|(\n+name|BT_DATA_SVC_DATA16\n+argument_list|,\n+name|BT_UUID_16_ENCODE\n+argument_list|(\n+name|BT_UUID_BASS_VAL\n+argument_list|)\n+argument_list|)\nThe issue was with: samples: Bluetooth: Add missing svc data for broadcast audio sink\n\nAdd missing service data for BASS for the broadcast audio sink\nsample.\n\nThis also required the controller to increase its maximum data\nlength. Increased more than minimum required so that the name\ncan be changed without needing to increase this again."
},{
  "instruction": "There is an issue in the following code. It relates to net: coap: add TOO_MANY_REQUESTS to return codes\n\nAdd COAP_RESPONSE_CODE_TOO_MANY_REQUESTS to coap_header_get_code(). CoAP\n4.29 response code for \\\"Too many requests\\\" is defined in coap.h but was\nmissing from the list of cases, resulting in a 0 being returned instead\nof the proper code. Please fix this issue.",
  "input": "Faulty tokenized code:\ncase|:\ncase|case\nname|COAP_RESPONSE_CODE_UNPROCESSABLE_ENTITY\ncase|:\ncase|case\nname|COAP_RESPONSE_CODE_INTERNAL_ERROR\ncase|:\ncase|case\nname|COAP_RESPONSE_CODE_NOT_IMPLEMENTED\ncase|:",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|COAP_RESPONSE_CODE_TOO_MANY_REQUESTS\n+case|:\n+case|case\nThe issue was with: net: coap: add TOO_MANY_REQUESTS to return codes\n\nAdd COAP_RESPONSE_CODE_TOO_MANY_REQUESTS to coap_header_get_code(). CoAP\n4.29 response code for \\\"Too many requests\\\" is defined in coap.h but was\nmissing from the list of cases, resulting in a 0 being returned instead\nof the proper code."
},{
  "instruction": "There is an issue in the following code. It relates to soc: xtensa: intel_adsp: restore bootctl with per-core state\n\nWhen exiting PM_STATE_SOFT_OFF, the primary core state is always\nused to restore bootctl register and the clock and power gating\nsettings.\n\nThis can lead to problems if non-primary core is powered up and down\nmany times before primary core 0 is powered down the first time.\nThe saved state in core_desc[0].bctl will be null, and as a result-\npower gating and clock gating is not disabled correctly for\nnon-primary cores.\n\nLink: https://github.com/thesofproject/sof/issues/8642 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|bctl\noperator||=\noperator|(\nname|core_desc\nindex|[\nliteral|0\nindex|]\noperator|.\nname|bctl\noperator|&\nname|DSPBR_BCTL_WAITIPCG",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|0\n+name|cpu\nThe issue was with: soc: xtensa: intel_adsp: restore bootctl with per-core state\n\nWhen exiting PM_STATE_SOFT_OFF, the primary core state is always\nused to restore bootctl register and the clock and power gating\nsettings.\n\nThis can lead to problems if non-primary core is powered up and down\nmany times before primary core 0 is powered down the first time.\nThe saved state in core_desc[0].bctl will be null, and as a result-\npower gating and clock gating is not disabled correctly for\nnon-primary cores.\n\nLink: https://github.com/thesofproject/sof/issues/8642"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: entropy: neorv32: add missing soc.h include\n\nAdd missing soc.h include for NEORV32_SYSINFO_FEATURES. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/drivers/entropy.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/pm/device.h>\nend_include\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/logging/log.h>\nend_include\n\nbegin_expr_stmt\nname|LOG_MODULE_REGISTER\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/logging/log.h>\n+end_include\n+\n-file|<zephyr/logging/log.h>\n+file|<soc.h>\nThe issue was with: drivers: entropy: neorv32: add missing soc.h include\n\nAdd missing soc.h include for NEORV32_SYSINFO_FEATURES."
},{
  "instruction": "There is an issue in the following code. It relates to modem: bg9x: ignore sem return value\n\nThe semaphore waits forever, ignore the return value. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|)\nname|buf_len\nargument_list|)\nexpr_stmt|;\ncomment|/* Setup the locks correctly. */\nname|k_sem_take\nargument_list|(\noperator|&\nname|mdata\noperator|.",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|(\n+name|void\n+operator|)\nThe issue was with: modem: bg9x: ignore sem return value\n\nThe semaphore waits forever, ignore the return value."
},{
  "instruction": "There is an issue in the following code. It relates to fix: lvgl: modules: keypad input log module\n\nCompilation error \\\"undefined reference to log_const_lvgl\\\"\nhappened in lvgl_keypad_input.c when trying to get logs with\nlvgl keypad module. Fixed by adding log level parameter\nin log module macro. Please fix this issue.",
  "input": "Faulty tokenized code:\n\nbegin_expr_stmt\nname|LOG_MODULE_DECLARE\nargument_list|(\nname|lvgl\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_struct",
  "result": "I corrected the issue in the code by changing the following tokens:\n+argument_list|,\n+name|CONFIG_LV_Z_LOG_LEVEL\nThe issue was with: fix: lvgl: modules: keypad input log module\n\nCompilation error \\\"undefined reference to log_const_lvgl\\\"\nhappened in lvgl_keypad_input.c when trying to get logs with\nlvgl keypad module. Fixed by adding log level parameter\nin log module macro."
},{
  "instruction": "There is an issue in the following code. It relates to boards native_posix: Detect attempt to configure not existing int\n\nPrevent overrunning the irq vector table.\nThis is not happening today in tree, but coverity thinks it\nmay. Checking for it to prevent it is not a bad idea\nanyhow, so let's do it. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|void\nmodifier|*\nname|isr_param_p\nparameter_list|)\nblock|{\nname|irq_vector_table\nindex|[\nname|irq_p\nindex|]\noperator|.",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|irq_p\n+operator|>=\n+name|N_IRQS\n+condition|)\n+block|{\n+name|posix_print_error_and_exit\n+argument_list|(\n+literal|\"Attempted to configure not existent interrupt %u\\n\"\n+argument_list|,\n+name|irq_p\n+argument_list|)\n+expr_stmt|;\n+return|return;\n+block|}\nThe issue was with: boards native_posix: Detect attempt to configure not existing int\n\nPrevent overrunning the irq vector table.\nThis is not happening today in tree, but coverity thinks it\nmay. Checking for it to prevent it is not a bad idea\nanyhow, so let's do it."
},{
  "instruction": "There is an issue in the following code. It relates to tests: mem_protect/obj_validation: fix check for heap size\n\nCommit fe34ffde7cdc9672e475548b83a483a8215216fa [formerly 3fbf12487c6c01c488210bc56b0f342f07098df9] introduced a way\nto add to CONFIG_HEAP_MEM_POOL_SIZE if, for example, subsystems\nneed more heap space. However, the size check in obj_validation\nwas still using the old kconfig, and was failing when extra\nspace was specified. So update the size check to use the updated\nsize. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|end_addr\ndecl_stmt|;\nname|size_t\nname|size_heap\ninit|=\nname|CONFIG_HEAP_MEM_POOL_SIZE\ndecl_stmt|;\ncomment|/* dynamically allocate kernel object semaphore */\nname|test_dyn_sem\noperator|=\nname|k_object_alloc",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_HEAP_MEM_POOL_SIZE\n+name|K_HEAP_MEM_POOL_SIZE\nThe issue was with: tests: mem_protect/obj_validation: fix check for heap size\n\nCommit fe34ffde7cdc9672e475548b83a483a8215216fa [formerly 3fbf12487c6c01c488210bc56b0f342f07098df9] introduced a way\nto add to CONFIG_HEAP_MEM_POOL_SIZE if, for example, subsystems\nneed more heap space. However, the size check in obj_validation\nwas still using the old kconfig, and was failing when extra\nspace was specified. So update the size check to use the updated\nsize."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: nrfx_uarte: Fix misbehavior due to preemption\n\nUART_RX_RDY event can be generated from UARTE interrupt or k_timer\nhandler. When ENDRX event occurs then k_timer is stopped (it can\nbe restarted if there is another buffer provided). However, if UARTE\ninterrupt priority is higher than k_timer priority (RTC is used\nunderneath) then k_timer handler may still be executed later.\nK_timer notifies new bytes based on RXDRDY HW event which is\ncounter by the TIMER (using PPI). It may happen that RXDRDY\nevent arrives due to byte received into RX FIFO but since there is\nnot buffer provided it stays in that FIFO. Given all this, it\nwas possible that RX_RDY event was reported from ENDRX UARTE event,\ntimer was stopped but because UARTE interrupt had higher priority\ntimer handler is executed after UARTE interrupt is handled. In\ntimer handler TIMER counter reports more bytes and calls\nUART_RX_RDY event with null buffer and non-zero amount of bytes.\n\nFixed by generating UART_RX_RDY event only if RX buffer is not\nnull. Please fix this issue.",
  "input": "Faulty tokenized code:\nDECL|member|rx_timeout_timer\nname|struct\nname|k_timer\nname|rx_timeout_timer\ndecl_stmt|;\nDECL|union|__anon27f11bfd010a\nunion|union\nblock|{\nDECL|member|ppi\nname|gppi_channel_t\nname|ppi\nname|rx_timeout_slab\noperator|)\ncondition|)\nblock|{\ncomment|/* rx_timeout us elapsed since last receiving */\nname|notify_uart_rx_rdy\nargument_list|(\nname|dev\nargument_list|,\nname|len\nname|rx_total_user_byte_cnt\noperator|+=\nname|len\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\nname|data\noperator|->\nname|async",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon27f11bfd010a\n+DECL|union|__anon2a0aae6f010a\n+if|if\n+condition|(\n+name|data\n+operator|->\n+name|async\n+operator|->\n+name|rx_buf\n+operator|!=\n+name|NULL\n+condition|)\n+block|{\n+block|}\nThe issue was with: drivers: serial: nrfx_uarte: Fix misbehavior due to preemption\n\nUART_RX_RDY event can be generated from UARTE interrupt or k_timer\nhandler. When ENDRX event occurs then k_timer is stopped (it can\nbe restarted if there is another buffer provided). However, if UARTE\ninterrupt priority is higher than k_timer priority (RTC is used\nunderneath) then k_timer handler may still be executed later.\nK_timer notifies new bytes based on RXDRDY HW event which is\ncounter by the TIMER (using PPI). It may happen that RXDRDY\nevent arrives due to byte received into RX FIFO but since there is\nnot buffer provided it stays in that FIFO. Given all this, it\nwas possible that RX_RDY event was reported from ENDRX UARTE event,\ntimer was stopped but because UARTE interrupt had higher priority\ntimer handler is executed after UARTE interrupt is handled. In\ntimer handler TIMER counter reports more bytes and calls\nUART_RX_RDY event with null buffer and non-zero amount of bytes.\n\nFixed by generating UART_RX_RDY event only if RX buffer is not\nnull."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: BAP: Fix BASE_SUBGROUP_MAX_COUNT value\n\nThe calculation for BASE_SUBGROUP_MAX_COUNT was off by one.\nThe macro did not consider the non-subgroup parameters of\nthe BASE that take up space. This effectively modifies\nBASE_SUBGROUP_MAX_COUNT to be 24 instead of 25. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_define\nDECL|macro|BASE_SUBGROUP_MAX_COUNT\ndefine|#\ndirective|define\nname|BASE_SUBGROUP_MAX_COUNT\nvalue|(BASE_MAX_SIZE / BASE_SUBGROUP_MIN_SIZE)\nend_define\n\nbegin_function\nDECL|function|base_pull_pd (struct net_buf_simple * net_buf)\nspecifier|static",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|(BASE_MAX_SIZE / BASE_SUBGROUP_MIN_SIZE)\n+define|\\\n+value|((BASE_MAX_SIZE - BASE_PD_SIZE - BASE_SUBGROUP_COUNT_SIZE) / BASE_SUBGROUP_MIN_SIZE)\nThe issue was with: Bluetooth: BAP: Fix BASE_SUBGROUP_MAX_COUNT value\n\nThe calculation for BASE_SUBGROUP_MAX_COUNT was off by one.\nThe macro did not consider the non-subgroup parameters of\nthe BASE that take up space. This effectively modifies\nBASE_SUBGROUP_MAX_COUNT to be 24 instead of 25."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: led: lp50xx: brightness: don't check uint >= 0\n\nNo need to check if an uint8_t is greater or equal 0 in\nlp50xx_set_brightness.\nFixes CID 322654 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|CONFIG_LED_LOG_LEVEL\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_define\nDECL|macro|LP50XX_MIN_BRIGHTNESS\ndefine|#\ndirective|define\nname|LP50XX_MIN_BRIGHTNESS\nvalue|0U\nend_define\n\nbegin_define\nDECL|macro|LP50XX_MAX_BRIGHTNESS\ndefine|#\ndirective|define\nname|LP50XX_MAX_BRIGHTNESS\nname|ENODEV\nreturn|;\nblock|}\nif|if\ncondition|(\noperator|!\nname|IN_RANGE\nargument_list|(\nname|value\nargument_list|,\nname|LP50XX_MIN_BRIGHTNESS\nargument_list|,\nname|LP50XX_MAX_BRIGHTNESS\nargument_list|)\ncondition|)\nblock|{\nname|LOG_ERR\nargument_list|(\nliteral|\"%s: brightness value out of bounds: \"\nliteral|\"val=%d, min=%d, max=%d\"\nargument_list|,\nname|dev\noperator|->\nname|name\nargument_list|,\nname|value\nargument_list|,\nname|LP50XX_MIN_BRIGHTNESS\nargument_list|,\nname|LP50XX_MAX_BRIGHTNESS\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_define\n-DECL|macro|LP50XX_MIN_BRIGHTNESS\n-define|#\n-directive|define\n-name|LP50XX_MIN_BRIGHTNESS\n-value|0U\n-end_define\n-\n-operator|!\n-name|IN_RANGE\n-argument_list|(\n-argument_list|,\n-name|LP50XX_MIN_BRIGHTNESS\n-argument_list|,\n+operator|>\n-argument_list|)\n-literal|\"%s: brightness value out of bounds: \"\n-literal|\"val=%d, min=%d, max=%d\"\n+literal|\"%s: brightness value out of bounds: val=%d, max=%d\"\n-name|LP50XX_MIN_BRIGHTNESS\n-argument_list|,\nThe issue was with: drivers: led: lp50xx: brightness: don't check uint >= 0\n\nNo need to check if an uint8_t is greater or equal 0 in\nlp50xx_set_brightness.\nFixes CID 322654"
},{
  "instruction": "There is an issue in the following code. It relates to wifi: shell: added NULL check to net_mgmt callback\n\nBy default variable context.sh is set to NULL. If any net_mgmt\nevent will be called when the variable has default value, there\nwill be a system exception. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|MAX_BANDS_STR_LEN\nvalue|64\nend_define\n\nbegin_struct\nDECL|struct|__anon2b16acb80108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\ndecl_stmt|;\nDECL|member|scan_result\nname|uint32_t\nname|scan_result\ndecl_stmt|;\nDECL|union|__anon2b16acb8020a\nunion|union\nblock|{\nDECL|struct|__anon2b16acb80308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\nname|net_if\nmodifier|*\nname|iface\nparameter_list|)\nblock|{\nswitch|switch\ncondition|(\nname|mgmt_event\ncondition|)\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2b16acb80108\n+DECL|struct|__anon278263fc0108\n-DECL|union|__anon2b16acb8020a\n+DECL|union|__anon278263fc020a\n-DECL|struct|__anon2b16acb80308\n+DECL|struct|__anon278263fc0308\n+if|if\n+condition|(\n+name|context\n+operator|.\n+name|sh\n+operator|==\n+name|NULL\n+condition|)\n+block|{\n+return|return;\n+block|}\nThe issue was with: wifi: shell: added NULL check to net_mgmt callback\n\nBy default variable context.sh is set to NULL. If any net_mgmt\nevent will be called when the variable has default value, there\nwill be a system exception."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Mesh: Disable randomization on Link Close in RPR server\n\nDisable randomization at the access layer in the Remote Provisioning\nserver when sending Link Stauts message as a responce on Link Close\nmessage and then sending Link Report message right after it. Because of\nthe randomization, the report message is sent before the status message\nwhich makes MESH/SR/RPR/PDU/BV-03-C test to fail.\n\nThis fixes MESH/SR/RPR/PDU/BV-03-C test. Please fix this issue.",
  "input": "Faulty tokenized code:\ndefine|\\\nvalue|{                                                                      \\ \t\t.net_idx = (_cli)->net_idx, .app_idx = BT_MESH_KEY_DEV_LOCAL,  \\ \t\t.addr = (_cli)->addr, .send_ttl = (_cli)->ttl,                 \\ \t\t.send_rel = (_send_rel)                                        \\ \t}\nend_define\n\nbegin_enum\nDECL|enum|__anon2bf5f4200103\nenum|enum\nblock|{\nDECL|enumerator|SCANNING\nname|SCANNING\nblock|,\nbegin_comment\ncomment|/** Remote provisioning server instance. */\nend_comment\n\nbegin_struct\nDECL|struct|__anon2bf5f4200208\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|mod\nspecifier|const\nname|flags\nargument_list|,\nname|RPR_SRV_NUM_FLAGS\nargument_list|)\nexpr_stmt|;\nDECL|struct|__anon2bf5f4200308\nstruct|struct\nblock|{\nname|struct\nname|bt_mesh_rpr_unprov\nDECL|member|devs\ndecl_stmt|;\nDECL|member|scan\nblock|}\nname|scan\nstruct|;\nDECL|struct|__anon2bf5f4200408\nstruct|struct\nblock|{\nDECL|member|report\nname|struct\nname|k_work\ndecl_stmt|;\nDECL|member|link\nblock|}\nname|link\nstruct|;\nDECL|struct|__anon2bf5f4200508\nstruct|struct\nblock|{\nDECL|member|cb\nspecifier|const\nname|struct\nDECL|member|cb_data\nname|void\nmodifier|*\nname|cb_data\ndecl_stmt|;\nDECL|struct|__anon2bf5f4200608\nstruct|struct\nblock|{\nDECL|member|cb\nname|prov_bearer_send_complete_t\nname|cb\nname|state\noperator|=\nname|BT_MESH_RPR_LINK_CLOSING\nexpr_stmt|;\ncomment|/* Note: The response status isn't the same as the link status state, \t * which will be used in the link report when the link is fully closed. \t */\nname|link_status_send\nargument_list|(\nname|ctx\nargument_list|,\nname|BT_MESH_RPR_SUCCESS",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon2bf5f4200103\n+DECL|enum|__anon2b3194320103\n-DECL|struct|__anon2bf5f4200208\n+DECL|struct|__anon2b3194320208\n-DECL|struct|__anon2bf5f4200308\n+DECL|struct|__anon2b3194320308\n-DECL|struct|__anon2bf5f4200408\n+DECL|struct|__anon2b3194320408\n-DECL|struct|__anon2bf5f4200508\n+DECL|struct|__anon2b3194320508\n-DECL|struct|__anon2bf5f4200608\n+DECL|struct|__anon2b3194320608\n+comment|/* Disable randomization for the Remote Provisioning Link Status message to avoid reordering \t * of it with the Remote Provisioning Link Report message that shall be sent in a sequence \t * when closing an active link (see section 4.4.5.5.3.3 of MshPRTv1.1). \t */\n+name|ctx\n+operator|->\n+name|rnd_delay\n+operator|=\n+name|false\n+expr_stmt|;\nThe issue was with: Bluetooth: Mesh: Disable randomization on Link Close in RPR server\n\nDisable randomization at the access layer in the Remote Provisioning\nserver when sending Link Stauts message as a responce on Link Close\nmessage and then sending Link Report message right after it. Because of\nthe randomization, the report message is sent before the status message\nwhich makes MESH/SR/RPR/PDU/BV-03-C test to fail.\n\nThis fixes MESH/SR/RPR/PDU/BV-03-C test."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Mesh: Disable randomization in DFD model for canceling update\n\nDisable randomization in the access layer when cancelling update in the\ndistribution server model. This is needed because the server sends 2\nmessages in a row and the gets reordered by the access layer\nrandomization feature making DFU/SR/FD/BV-43-C test to fail.\n\nThis fixes DFU/SR/FD/BV-43-C test. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|BT_MESH_DFD_ERR_INTERNAL\nreturn|;\nblock|}\nif|if\ncondition|(\nname|ctx\noperator|!=\nname|NULL\ncondition|)\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|prev_phase\n+operator|==\n+name|BT_MESH_DFD_PHASE_APPLYING_UPDATE\n+operator|&&\n+name|ctx\n+condition|)\n+block|{\n+comment|/* Disable randomization for the Firmware Distribution State message to avoid \t\t * reordering when Firmware Distribution Server sends 2 messages in a row when \t\t * cancelling the update (see section 6.2.3.10 of MshDFUv1.0). \t\t */\n+name|ctx\n+operator|->\n+name|rnd_delay\n+operator|=\n+name|false\n+expr_stmt|;\n+block|}\n+if|if\n+condition|(\nThe issue was with: Bluetooth: Mesh: Disable randomization in DFD model for canceling update\n\nDisable randomization in the access layer when cancelling update in the\ndistribution server model. This is needed because the server sends 2\nmessages in a row and the gets reordered by the access layer\nrandomization feature making DFU/SR/FD/BV-43-C test to fail.\n\nThis fixes DFU/SR/FD/BV-43-C test."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: conn: document obfuscated function: `send_buf()`\n\nIt is unclear from a cursory glance at the code what the caller of\n`send_buf(buf)` should do with `buf` based on the returned error codes.\n\nDocument when ownership is and isn't transferred to `send_buf()`. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|;\nblock|}\nend_function\n\nbegin_enum\nDECL|enum|__anon2a1a406d0103\nenum|enum\nblock|{\nDECL|enumerator|FRAG_START\nname|FRAG_START\nblock|,\nname|frag\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|send_buf (struct bt_conn * conn,struct net_buf * buf)\nspecifier|static\nname|int\nname|send_buf\nname|net_buf_unref\nargument_list|(\nname|buf\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|err\noperator|==\noperator|-",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon2a1a406d0103\n+DECL|enum|__anon2c507c650103\n+begin_comment\n+comment|/* Tentatively send a buffer to the HCI driver.  *  * This is designed to be async, as in most failures due to lack of resources  * are not fatal. The caller should call `send_buf()` again later.  *  * Return values:  *  * - 0: `buf` sent. `buf` ownership transferred to lower layers.  *  * - -EIO: buffer failed to send due to HCI error. `buf` ownership returned to  *    caller BUT `buf` is popped from the TX queue. The caller shall destroy  *    `buf` and its TX context.  *  * - Any other error: buffer failed to send. `buf` ownership returned to caller  *   and `buf` is still the head of the TX queue  *  */\n+end_comment\n+\n+comment|/* HCI driver error. `buf` may have been popped from `tx_queue` and \t * should be destroyed. \t * \t * TODO: In that case we might want to disable Bluetooth or at the very \t * least tear down the connection. \t */\nThe issue was with: Bluetooth: conn: document obfuscated function: `send_buf()`\n\nIt is unclear from a cursory glance at the code what the caller of\n`send_buf(buf)` should do with `buf` based on the returned error codes.\n\nDocument when ownership is and isn't transferred to `send_buf()`."
},{
  "instruction": "There is an issue in the following code. It relates to tests: dynamic_thread_stack: Fix problems in multicore\n\nWhen running it in a multicore and with incoherent cache environment it\nis possible that the thread allocating dynamic stacks is switched to a\ndifferent cpu. In this situation further access to that memory (like\nwhen releasing resources) will be invalid. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|MAX_HEAP_STACKS\nvalue|(POOL_SIZE / STACK_OBJ_SIZE)\nend_define\n\nbegin_expr_stmt\nname|Z_HEAP_DEFINE_IN_SECT\nargument_list|(\nname|stack_heap\nargument_list|,\nname|POOL_SIZE\nargument_list|,\nname|__incoherent\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_decl_stmt",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|Z_HEAP_DEFINE_IN_SECT\n+name|K_HEAP_DEFINE\n-argument_list|,\n-name|__incoherent\nThe issue was with: tests: dynamic_thread_stack: Fix problems in multicore\n\nWhen running it in a multicore and with incoherent cache environment it\nis possible that the thread allocating dynamic stacks is switched to a\ndifferent cpu. In this situation further access to that memory (like\nwhen releasing resources) will be invalid."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: thread: Allow stack in coherent memory\n\nWhen allowing dynamic thread stack allocation the stack may come from\nthe heap in coherent memory, trying to use cached memory is over\ncomplicated because of heap meta data and cache line sizes.\nAlso when userspace is enabled, stacks have to be page aligned and the\naddress of the stack is used to track kernel objects. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|base\noperator|.\nname|thread_state\ndecl_stmt|;\nDECL|struct|__anon28b95f2e0108\nspecifier|static\nspecifier|const\nstruct|struct\nblock|{\nDECL|member|str\nargument_list|(\nname|new_thread\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|__ASSERT_NO_MSG\nargument_list|(\noperator|!\nname|arch_mem_coherent\nargument_list|(\nargument_list|)\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\nname|arch_new_thread\nargument_list|(\nname|new_thread\nargument_list|,\nname|stack",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon28b95f2e0108\n+DECL|struct|__anon29b4f8330108\n+comment|/* When dynamic thread stack is available, the stack may come from \t * uncached area. \t */\n+ifndef|#\n+directive|ifndef\n+name|CONFIG_DYNAMIC_THREAD\n+comment|/* CONFIG_DYNAMIC_THREAD */\n+endif|#\n+directive|endif\nThe issue was with: kernel: thread: Allow stack in coherent memory\n\nWhen allowing dynamic thread stack allocation the stack may come from\nthe heap in coherent memory, trying to use cached memory is over\ncomplicated because of heap meta data and cache line sizes.\nAlso when userspace is enabled, stacks have to be page aligned and the\naddress of the stack is used to track kernel objects."
},{
  "instruction": "There is an issue in the following code. It relates to lib: acpi: Add asserts catching overflow\n\nAdd asserts catching sub-sctructure overflow. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_struct\nDECL|struct|__anon2b5410d90108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|child_dev\nname|struct\noperator|*\nname|subtable\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|func\nargument_list|(\nname|subtable\nargument_list|,\nname|arg\noperator|*\nname|devscope\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|func\nargument_list|(\nname|devscope\nargument_list|,\nname|arg",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2b5410d90108\n+DECL|struct|__anon2742c1ee0108\n+name|__ASSERT_NO_MSG\n+argument_list|(\n+name|subtable\n+operator|->\n+name|Length\n+operator|<=\n+name|length\n+operator|-\n+name|offset\n+argument_list|)\n+expr_stmt|;\n+name|__ASSERT_NO_MSG\n+argument_list|(\n+name|devscope\n+operator|->\n+name|Length\n+operator|<=\n+name|length\n+operator|-\n+name|offset\n+argument_list|)\n+expr_stmt|;\nThe issue was with: lib: acpi: Add asserts catching overflow\n\nAdd asserts catching sub-sctructure overflow."
},{
  "instruction": "There is an issue in the following code. It relates to lib: acpi: Add more ASSERT() in ACPI table parsing\n\nAdd more assert() to DMAR parsing functions. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_struct\nDECL|struct|__anon27c781960108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|child_dev\nname|struct\nsizeof|sizeof\nargument_list|(\nname|ACPI_TABLE_DMAR\nargument_list|)\ndecl_stmt|;\nwhile|while\ncondition|(\nname|offset\noperator|<\nname|length\nname|__ASSERT_NO_MSG\nargument_list|(\nname|subtable\noperator|->\nname|Length\noperator|>\nsizeof|sizeof\nargument_list|(\noperator|*\nname|subtable\nargument_list|)\nsizeof|sizeof\nargument_list|(\nname|ACPI_DMAR_HARDWARE_UNIT\nargument_list|)\ndecl_stmt|;\nwhile|while\ncondition|(\nname|offset\noperator|<\nname|length\nname|__ASSERT_NO_MSG\nargument_list|(\nname|devscope\noperator|->\nname|Length\noperator|>\nsizeof|sizeof\nargument_list|(\noperator|*\nname|devscope\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon27c781960108\n+DECL|struct|__anon2b5410d90108\n+name|__ASSERT_NO_MSG\n+argument_list|(\n+name|length\n+operator|>=\n+name|offset\n+argument_list|)\n+expr_stmt|;\n-operator|>\n+operator|>=\n+name|__ASSERT_NO_MSG\n+argument_list|(\n+name|length\n+operator|>=\n+name|offset\n+argument_list|)\n+expr_stmt|;\n-operator|>\n+operator|>=\nThe issue was with: lib: acpi: Add more ASSERT() in ACPI table parsing\n\nAdd more assert() to DMAR parsing functions."
},{
  "instruction": "There is an issue in the following code. It relates to usb: device_next: fix buffer count configuration in CDC ACM pool\n\nMultiple CDC ACM instances can block each other because there are only\nbuffers for a single instance. Fix this by configuring the number of\nbuffers in the pool based on the number of CDC ACM instances. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright (c) 2022 Nordic Semiconductor ASA  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/init.h>\nend_include\nname|CONFIG_USBD_CDC_ACM_LOG_LEVEL\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_comment\ncomment|/*  * FIXME: buffer count per device.  */\nend_comment\n\nbegin_expr_stmt\nname|NET_BUF_POOL_FIXED_DEFINE\nargument_list|(\nname|cdc_acm_ep_pool\nargument_list|,\nliteral|2\nargument_list|,\nliteral|512\nargument_list|,\nsizeof|sizeof\nvalue|static struct usbd_cdc_acm_desc cdc_acm_desc_##n = {\t\t\t\t\\ \t.iad_cdc = {\t\t\t\t\t\t\t\t\\ \t\t.bLength = sizeof(struct usb_association_descriptor),\t\t\\ \t\t.bDescriptorType = USB_DESC_INTERFACE_ASSOC,\t\t\t\\ \t\t.bFirstInterface = 0,\t\t\t\t\t\t\\ \t\t.bInterfaceCount = 0x02,\t\t\t\t\t\\ \t\t.bFunctionClass = USB_BCC_CDC_CONTROL,\t\t\t\t\\ \t\t.bFunctionSubClass = ACM_SUBCLASS,\t\t\t\t\\ \t\t.bFunctionProtocol = 0,\t\t\t\t\t\t\\ \t\t.iFunction = 0,\t\t\t\t\t\t\t\\ \t},\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \t.if0 = {\t\t\t\t\t\t\t\t\\ \t\t.bLength = sizeof(struct usb_if_descriptor),\t\t\t\\ \t\t.bDescriptorType = USB_DESC_INTERFACE,\t\t\t\t\\ \t\t.bInterfaceNumber = 0,\t\t\t\t\t\t\\ \t\t.bAlternateSetting = 0,\t\t\t\t\t\t\\ \t\t.bNumEndpoints = 1,\t\t\t\t\t\t\\ \t\t.bInterfaceClass = USB_BCC_CDC_CONTROL,\t\t\t\t\\ \t\t.bInterfaceSubClass = ACM_SUBCLASS,\t\t\t\t\\ \t\t.bInterfaceProtocol = 0,\t\t\t\t\t\\ \t\t.iInterface = 0,\t\t\t\t\t\t\\ \t},\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \t.if0_header = {\t\t\t\t\t\t\t\t\\ \t\t.bFunctionLength = sizeof(struct cdc_header_descriptor),\t\\ \t\t.bDescriptorType = USB_DESC_CS_INTERFACE,\t\t\t\\ \t\t.bDescriptorSubtype = HEADER_FUNC_DESC,\t\t\t\t\\ \t\t.bcdCDC = sys_cpu_to_le16(USB_SRN_1_1),\t\t\t\t\\ \t},\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \t.if0_cm = {\t\t\t\t\t\t\t\t\\ \t\t.bFunctionLength = sizeof(struct cdc_cm_descriptor),\t\t\\ \t\t.bDescriptorType = USB_DESC_CS_INTERFACE,\t\t\t\\ \t\t.bDescriptorSubtype = CALL_MANAGEMENT_FUNC_DESC,\t\t\\ \t\t.bmCapabilities = 0,\t\t\t\t\t\t\\ \t\t.bDataInterface = 1,\t\t\t\t\t\t\\ \t},\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \t.if0_acm = {\t\t\t\t\t\t\t\t\\ \t\t.bFunctionLength = sizeof(struct cdc_acm_descriptor),\t\t\\ \t\t.bDescriptorType = USB_DESC_CS_INTERFACE,\t\t\t\\ \t\t.bDescriptorSubtype = ACM_FUNC_DESC,\t\t\t\t\\\ncomment|/* See CDC PSTN Subclass Chapter 5.3.2 */\nvalue|\\ \t\t.bmCapabilities = BIT(1),\t\t\t\t\t\\ \t},\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \t.if0_union = {\t\t\t\t\t\t\t\t\\ \t\t.bFunctionLength = sizeof(struct cdc_union_descriptor),\t\t\\ \t\t.bDescriptorType = USB_DESC_CS_INTERFACE,\t\t\t\\ \t\t.bDescriptorSubtype = UNION_FUNC_DESC,\t\t\t\t\\ \t\t.bControlInterface = 0,\t\t\t\t\t\t\\ \t\t.bSubordinateInterface0 = 1,\t\t\t\t\t\\ \t},\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \t.if0_int_ep = {\t\t\t\t\t\t\t\t\\ \t\t.bLength = sizeof(struct usb_ep_descriptor),\t\t\t\\ \t\t.bDescriptorType = USB_DESC_ENDPOINT,\t\t\t\t\\ \t\t.bEndpointAddress = 0x81,\t\t\t\t\t\\ \t\t.bmAttributes = USB_EP_TYPE_INTERRUPT,\t\t\t\t\\ \t\t.wMaxPacketSize = sys_cpu_to_le16(CDC_ACM_DEFAULT_INT_EP_MPS),\t\\ \t\t.bInterval = CDC_ACM_DEFAULT_INT_INTERVAL,\t\t\t\\ \t},\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \t.if1 = {\t\t\t\t\t\t\t\t\\ \t\t.bLength = sizeof(struct usb_if_descriptor),\t\t\t\\ \t\t.bDescriptorType = USB_DESC_INTERFACE,\t\t\t\t\\ \t\t.bInterfaceNumber = 1,\t\t\t\t\t\t\\ \t\t.bAlternateSetting = 0,\t\t\t\t\t\t\\ \t\t.bNumEndpoints = 2,\t\t\t\t\t\t\\ \t\t.bInterfaceClass = USB_BCC_CDC_DATA,\t\t\t\t\\ \t\t.bInterfaceSubClass = 0,\t\t\t\t\t\\ \t\t.bInterfaceProtocol = 0,\t\t\t\t\t\\ \t\t.iInterface = 0,\t\t\t\t\t\t\\ \t},\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \t.if1_in_ep = {\t\t\t\t\t\t\t\t\\ \t\t.bLength = sizeof(struct usb_ep_descriptor),\t\t\t\\ \t\t.bDescriptorType = USB_DESC_ENDPOINT,\t\t\t\t\\ \t\t.bEndpointAddress = 0x82,\t\t\t\t\t\\ \t\t.bmAttributes = USB_EP_TYPE_BULK,\t\t\t\t\\ \t\t.wMaxPacketSize = sys_cpu_to_le16(CDC_ACM_DEFAULT_BULK_EP_MPS),\t\\ \t\t.bInterval = 0,\t\t\t\t\t\t\t\\ \t},\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \t.if1_out_ep = {\t\t\t\t\t\t\t\t\\ \t\t.bLength = sizeof(struct usb_ep_descriptor),\t\t\t\\ \t\t.bDescriptorType = USB_DESC_ENDPOINT,\t\t\t\t\\ \t\t.bEndpointAddress = 0x01,\t\t\t\t\t\\ \t\t.bmAttributes = USB_EP_TYPE_BULK,\t\t\t\t\\ \t\t.wMaxPacketSize = sys_cpu_to_le16(CDC_ACM_DEFAULT_BULK_EP_MPS),\t\\ \t\t.bInterval = 0,\t\t\t\t\t\t\t\\ \t},\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \t.nil_desc = {\t\t\t\t\t\t\t\t\\ \t\t.bLength = 0,\t\t\t\t\t\t\t\\ \t\t.bDescriptorType = 0,\t\t\t\t\t\t\\ \t},\t\t\t\t\t\t\t\t\t\\ }\nend_define\n\nbegin_define\nDECL|macro|DT_DRV_COMPAT\ndefine|#\ndirective|define\nname|DT_DRV_COMPAT\nvalue|zephyr_cdc_acm_uart\nend_define\n\nbegin_define\nDECL|macro|USBD_CDC_ACM_DT_DEVICE_DEFINE (n)\ndefine|#\ndirective|define\nname|USBD_CDC_ACM_DT_DEVICE_DEFINE",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_define\n+DECL|macro|DT_DRV_COMPAT\n+define|#\n+directive|define\n+name|DT_DRV_COMPAT\n+value|zephyr_cdc_acm_uart\n+end_define\n+\n-begin_comment\n-comment|/*  * FIXME: buffer count per device.  */\n-end_comment\n-\n+name|DT_NUM_INST_STATUS_OKAY\n+argument_list|(\n+name|DT_DRV_COMPAT\n+argument_list|)\n+operator|*\n-begin_define\n-DECL|macro|DT_DRV_COMPAT\n-define|#\n-directive|define\n-name|DT_DRV_COMPAT\n-value|zephyr_cdc_acm_uart\n-end_define\n-\nThe issue was with: usb: device_next: fix buffer count configuration in CDC ACM pool\n\nMultiple CDC ACM instances can block each other because there are only\nbuffers for a single instance. Fix this by configuring the number of\nbuffers in the pool based on the number of CDC ACM instances."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: Fix signs in max31865 temperature calculation\n\nThe reference document says that the formula for negative\ntemperatures has two minus signs missing.\n\nfixes #68710 Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|resistance\nargument_list|,\nliteral|2\nargument_list|)\noperator|+\nname|A\nindex|[\nliteral|3\nindex|]\noperator|*\nargument_list|(\nname|resistance\nargument_list|,\nliteral|3\nargument_list|)\noperator|+\nname|A\nindex|[\nliteral|4\nindex|]\noperator|*",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|+\n+operator|-\n-operator|+\n+operator|-\nThe issue was with: drivers: Fix signs in max31865 temperature calculation\n\nThe reference document says that the formula for negative\ntemperatures has two minus signs missing.\n\nfixes #68710"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: dma: dma_nxp_edma: query channel number from HAL config\n\nCurrently, the number of channels supported by the controlled\nis computed based on the size of the channel array. This\nworks well only if there's no gaps (i.e: \\\"dma-channels\\\" property\nis used or \\\"valid-channels\\\" property is used with contiguous\nchannels) but will break if there are any gaps. For instance,\nif the user wants to use channels 16 and 17 and specifies them\nthrough the \\\"valid-channels\\\" property, they won't be allowed\nto do so because dma_request_channels() will stop at channel 1.\nAs such, to fix this, simply use the number of channels from\nthe HAL configuration which is the maximum number of channels. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|&\nname|data\noperator|->\nname|channel_flags\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function\nname|EDMA_INIT\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\ \t\t\t\t\t\t\t\t\t\t\\\nvalue|BUILD_ASSERT(!DT_NODE_HAS_PROP(DT_INST(inst, DT_DRV_COMPAT), dma_channels) ||\t\\ \t     !DT_NODE_HAS_PROP(DT_INST(inst, DT_DRV_COMPAT), valid_channels),\t\\ \t     \"dma_channels and valid_channels are mutually exclusive\");\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(DT_INST_PROP_OR(inst, dma_channels, 0) ==\t\t\t\t\\ \t     DT_NUM_IRQS(DT_INST(inst, DT_DRV_COMPAT)) ||\t\t\t\\ \t     DT_INST_PROP_LEN_OR(inst, valid_channels, 0) ==\t\t\t\\ \t     DT_NUM_IRQS(DT_INST(inst, DT_DRV_COMPAT)),\t\t\t\t\\ \t     \"number of interrupts needs to match number of channels\");\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(DT_PROP_OR(DT_INST(inst, DT_DRV_COMPAT), hal_cfg_index, 0)<\t\\ \t     ARRAY_SIZE(s_edmaConfigs),\t\t\t\t\t\t\\ \t     \"HAL configuration index out of bounds\");\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static struct edma_channel channels_##inst[] = EDMA_CHANNEL_ARRAY_GET(inst);\t\\ \t\t\t\t\t\t\t\t\t\t\\ static void interrupt_config_function_##inst(void)\t\t\t\t\\ {\t\t\t\t\t\t\t\t\t\t\\ \tEDMA_CONNECT_INTERRUPTS(inst);\t\t\t\t\t\t\\ }\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static struct edma_config edma_config_##inst = {\t\t\t\t\\ \t.regmap_phys = DT_INST_REG_ADDR(inst),\t\t\t\t\t\\ \t.regmap_size = DT_INST_REG_SIZE(inst),\t\t\t\t\t\\ \t.irq_config = interrupt_config_function_##inst,\t\t\t\t\\ \t.contiguous_channels = EDMA_CHANS_ARE_CONTIGUOUS(inst),\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static struct edma_data edma_data_##inst = {\t\t\t\t\t\\ \t.channels = channels_##inst,\t\t\t\t\t\t\\ \t.ctx.dma_channels = ARRAY_SIZE(channels_##inst),\t\t\t\\ \t.ctx.magic = DMA_MAGIC,\t\t\t\t\t\t\t\\ \t.hal_cfg =&EDMA_HAL_CFG_GET(inst),\t\t\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ DEVICE_DT_INST_DEFINE(inst,&edma_init, NULL,\t\t\t\t\t\\&edma_data_##inst,&edma_config_##inst,\t\t\t\\ \t\t      PRE_KERNEL_1, CONFIG_DMA_INIT_PRIORITY,\t\t\t\\&edma_api);\t\t\t\t\t\t\\  DT_INST_FOREACH_STATUS_OKAY(EDMA_INIT);\nend_define\n\nend_unit\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|data\n+operator|->\n+name|ctx\n+operator|.\n+name|dma_channels\n+operator|=\n+name|data\n+operator|->\n+name|hal_cfg\n+operator|->\n+name|channels\n+expr_stmt|;\n-value|BUILD_ASSERT(!DT_NODE_HAS_PROP(DT_INST(inst, DT_DRV_COMPAT), dma_channels) ||\t\\ \t     !DT_NODE_HAS_PROP(DT_INST(inst, DT_DRV_COMPAT), valid_channels),\t\\ \t     \"dma_channels and valid_channels are mutually exclusive\");\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(DT_INST_PROP_OR(inst, dma_channels, 0) ==\t\t\t\t\\ \t     DT_NUM_IRQS(DT_INST(inst, DT_DRV_COMPAT)) ||\t\t\t\\ \t     DT_INST_PROP_LEN_OR(inst, valid_channels, 0) ==\t\t\t\\ \t     DT_NUM_IRQS(DT_INST(inst, DT_DRV_COMPAT)),\t\t\t\t\\ \t     \"number of interrupts needs to match number of channels\");\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(DT_PROP_OR(DT_INST(inst, DT_DRV_COMPAT), hal_cfg_index, 0)<\t\\ \t     ARRAY_SIZE(s_edmaConfigs),\t\t\t\t\t\t\\ \t     \"HAL configuration index out of bounds\");\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static struct edma_channel channels_##inst[] = EDMA_CHANNEL_ARRAY_GET(inst);\t\\ \t\t\t\t\t\t\t\t\t\t\\ static void interrupt_config_function_##inst(void)\t\t\t\t\\ {\t\t\t\t\t\t\t\t\t\t\\ \tEDMA_CONNECT_INTERRUPTS(inst);\t\t\t\t\t\t\\ }\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static struct edma_config edma_config_##inst = {\t\t\t\t\\ \t.regmap_phys = DT_INST_REG_ADDR(inst),\t\t\t\t\t\\ \t.regmap_size = DT_INST_REG_SIZE(inst),\t\t\t\t\t\\ \t.irq_config = interrupt_config_function_##inst,\t\t\t\t\\ \t.contiguous_channels = EDMA_CHANS_ARE_CONTIGUOUS(inst),\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static struct edma_data edma_data_##inst = {\t\t\t\t\t\\ \t.channels = channels_##inst,\t\t\t\t\t\t\\ \t.ctx.dma_channels = ARRAY_SIZE(channels_##inst),\t\t\t\\ \t.ctx.magic = DMA_MAGIC,\t\t\t\t\t\t\t\\ \t.hal_cfg =&EDMA_HAL_CFG_GET(inst),\t\t\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ DEVICE_DT_INST_DEFINE(inst,&edma_init, NULL,\t\t\t\t\t\\&edma_data_##inst,&edma_config_##inst,\t\t\t\\ \t\t      PRE_KERNEL_1, CONFIG_DMA_INIT_PRIORITY,\t\t\t\\&edma_api);\t\t\t\t\t\t\\  DT_INST_FOREACH_STATUS_OKAY(EDMA_INIT);\n+value|BUILD_ASSERT(!DT_NODE_HAS_PROP(DT_INST(inst, DT_DRV_COMPAT), dma_channels) ||\t\\ \t     !DT_NODE_HAS_PROP(DT_INST(inst, DT_DRV_COMPAT), valid_channels),\t\\ \t     \"dma_channels and valid_channels are mutually exclusive\");\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(DT_INST_PROP_OR(inst, dma_channels, 0) ==\t\t\t\t\\ \t     DT_NUM_IRQS(DT_INST(inst, DT_DRV_COMPAT)) ||\t\t\t\\ \t     DT_INST_PROP_LEN_OR(inst, valid_channels, 0) ==\t\t\t\\ \t     DT_NUM_IRQS(DT_INST(inst, DT_DRV_COMPAT)),\t\t\t\t\\ \t     \"number of interrupts needs to match number of channels\");\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(DT_PROP_OR(DT_INST(inst, DT_DRV_COMPAT), hal_cfg_index, 0)<\t\\ \t     ARRAY_SIZE(s_edmaConfigs),\t\t\t\t\t\t\\ \t     \"HAL configuration index out of bounds\");\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static struct edma_channel channels_##inst[] = EDMA_CHANNEL_ARRAY_GET(inst);\t\\ \t\t\t\t\t\t\t\t\t\t\\ static void interrupt_config_function_##inst(void)\t\t\t\t\\ {\t\t\t\t\t\t\t\t\t\t\\ \tEDMA_CONNECT_INTERRUPTS(inst);\t\t\t\t\t\t\\ }\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static struct edma_config edma_config_##inst = {\t\t\t\t\\ \t.regmap_phys = DT_INST_REG_ADDR(inst),\t\t\t\t\t\\ \t.regmap_size = DT_INST_REG_SIZE(inst),\t\t\t\t\t\\ \t.irq_config = interrupt_config_function_##inst,\t\t\t\t\\ \t.contiguous_channels = EDMA_CHANS_ARE_CONTIGUOUS(inst),\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static struct edma_data edma_data_##inst = {\t\t\t\t\t\\ \t.channels = channels_##inst,\t\t\t\t\t\t\\ \t.ctx.magic = DMA_MAGIC,\t\t\t\t\t\t\t\\ \t.hal_cfg =&EDMA_HAL_CFG_GET(inst),\t\t\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ DEVICE_DT_INST_DEFINE(inst,&edma_init, NULL,\t\t\t\t\t\\&edma_data_##inst,&edma_config_##inst,\t\t\t\\ \t\t      PRE_KERNEL_1, CONFIG_DMA_INIT_PRIORITY,\t\t\t\\&edma_api);\t\t\t\t\t\t\\  DT_INST_FOREACH_STATUS_OKAY(EDMA_INIT);\nThe issue was with: drivers: dma: dma_nxp_edma: query channel number from HAL config\n\nCurrently, the number of channels supported by the controlled\nis computed based on the size of the channel array. This\nworks well only if there's no gaps (i.e: \\\"dma-channels\\\" property\nis used or \\\"valid-channels\\\" property is used with contiguous\nchannels) but will break if there are any gaps. For instance,\nif the user wants to use channels 16 and 17 and specifies them\nthrough the \\\"valid-channels\\\" property, they won't be allowed\nto do so because dma_request_channels() will stop at channel 1.\nAs such, to fix this, simply use the number of channels from\nthe HAL configuration which is the maximum number of channels."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: mipi_dbi: mipi_dbi_spi: change reset pin polarity\n\nChange reset pin polarity for MIPI DBI SPI controller, so that the board\ndevicetree is responsible for setting the GPIO to active low, and the\ndriver always sets the pin to a logic 1 to reset the display.\n\nFixes #68562 Please fix this issue.",
  "input": "Faulty tokenized code:\n\t\tspi-flash0 = &mx25r64;\n\t};\n\n\tmipi_dbi {\n\t\tcompatible = \"zephyr,mipi-dbi-spi\";\n\t\treset-gpios = <&gpio0 6 GPIO_ACTIVE_HIGH>;\n\t\tdc-gpios = <&gpio0 12 GPIO_ACTIVE_HIGH>;\n\t\tspi-dev = <&spi2>;\n\t\twrite-only;\n\t\t#address-cells = <1>;\n\t\t#size-cells = <0>;\n\n\t/* LCD */\n\tmipi_dbi {\n\t\tcompatible = \"zephyr,mipi-dbi-spi\";\n\t\tdc-gpios = <&portc 6 GPIO_ACTIVE_HIGH>;\n\t\treset-gpios = <&portc 7 GPIO_ACTIVE_HIGH>;\n\t\t#address-cells = <1>;\n\t\t#size-cells = <0>;\n\t\tspi-dev = <&sercom7>;\n\t\twrite-only;\n\n\t};\n\n\tbuydisplay_2_8_tft_touch_arduino_mipi_dbi {\n\t\tcompatible = \"zephyr,mipi-dbi-spi\";\n\t\tdc-gpios = <&arduino_header 13 GPIO_ACTIVE_HIGH>; /* D7 */\n\t\treset-gpios = <&arduino_header 16 GPIO_ACTIVE_HIGH>; /* D10 */\n\t\tspi-dev = <&arduino_spi>;\n\t\twrite-only;\n\t\t#address-cells = <1>;\n\t\t#size-cells = <0>;\n\n\t};\n\n\tbuydisplay_3_5_tft_touch_arduino_mipi_dbi {\n\t\tcompatible = \"zephyr,mipi-dbi-spi\";\n\t\tdc-gpios = <&arduino_header 13 GPIO_ACTIVE_HIGH>; /* D7 */\n\t\treset-gpios = <&arduino_header 16 GPIO_ACTIVE_HIGH>; /* D10 */\n\t\tspi-dev = <&arduino_spi>;\n\t\twrite-only;\n\t\t#address-cells = <1>;\n\t\t#size-cells = <0>;\n\n\t};\n\n\tmipi_dbi {\n\t\tcompatible = \"zephyr,mipi-dbi-spi\";\n\t\tdc-gpios = <&gpio0 21 GPIO_ACTIVE_HIGH>;\n\t\treset-gpios = <&gpio0 18 GPIO_ACTIVE_HIGH>;\n\t\tspi-dev = <&spi3>;\n\t\twrite-only;\n\t\t#address-cells = <1>;\n\t\t#size-cells = <0>;\n\n\t};\n\n\tmipi_dbi {\n\t\tcompatible = \"zephyr,mipi-dbi-spi\";\n\t\tdc-gpios = <&gpio0 15 GPIO_ACTIVE_HIGH>;\n\t\treset-gpios = <&axp192_gpio 4 (GPIO_OPEN_DRAIN | GPIO_ACTIVE_HIGH)>;\n\t\tspi-dev = <&spi3>;\n\t\twrite-only;\n\t\t#address-cells = <1>;\n\t\t#size-cells = <0>;\n\noperator|&\nname|config\noperator|->\nname|reset\nargument_list|,\nliteral|0\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|ret\noperator|&\nname|config\noperator|->\nname|reset\nargument_list|,\nliteral|1\nargument_list|)\nreturn|;\nblock|}\nend_function\n\n      Set to low when sending a command, or high when sending data.\n\n  reset-gpios:\n    type: phandle-array\n    description: |\n     Reset GPIO pin. Used to reset the display during initialization.\n     Active low pin.\n\n  write-only:\n    type: boolean\n    description: |\n      Controller is not readable, IE only DOUT pin is connected on the SPI",
  "result": "I corrected the issue in the code by changing the following tokens:\n-\t\treset-gpios = <&gpio0 6 GPIO_ACTIVE_HIGH>;\n+\t\treset-gpios = <&gpio0 6 GPIO_ACTIVE_LOW>;\n-\t\treset-gpios = <&portc 7 GPIO_ACTIVE_HIGH>;\n+\t\treset-gpios = <&portc 7 GPIO_ACTIVE_LOW>;\n-\t\treset-gpios = <&arduino_header 16 GPIO_ACTIVE_HIGH>; /* D10 */\n+\t\treset-gpios = <&arduino_header 16 GPIO_ACTIVE_LOW>; /* D10 */\n-\t\treset-gpios = <&arduino_header 16 GPIO_ACTIVE_HIGH>; /* D10 */\n+\t\treset-gpios = <&arduino_header 16 GPIO_ACTIVE_LOW>; /* D10 */\n-\t\treset-gpios = <&gpio0 18 GPIO_ACTIVE_HIGH>;\n+\t\treset-gpios = <&gpio0 18 GPIO_ACTIVE_LOW>;\n-\t\treset-gpios = <&axp192_gpio 4 (GPIO_OPEN_DRAIN | GPIO_ACTIVE_HIGH)>;\n+\t\treset-gpios = <&axp192_gpio 4 (GPIO_OPEN_DRAIN | GPIO_ACTIVE_LOW)>;\n-literal|0\n+literal|1\n-literal|1\n+literal|0\n-      Reset GPIO pin. Used to reset the display during initialization.\n-      Active low pin.\n+      Reset GPIO pin. Set high to reset the display\nThe issue was with: drivers: mipi_dbi: mipi_dbi_spi: change reset pin polarity\n\nChange reset pin polarity for MIPI DBI SPI controller, so that the board\ndevicetree is responsible for setting the GPIO to active low, and the\ndriver always sets the pin to a logic 1 to reset the display.\n\nFixes #68562"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: dma: dma_dw_common: Disable channel even if draining times out\n\nIf the channel suspend with draining fails on stop because of reasons\noutside of the scope of the DMA driver (the peripheral is powered off\nbefore trying to drain for example) we must continue and disable the\nchannel.\n\nThe channel can be released by the client despite of it remained enabled.\nA new DMA channel request can pick the channel (as it is released) but\nre-configuration is going to be skipped and the use of the channel is going\nto fail. Then we will see the same drain timeout on channel stop again\nsince the channel retained the configuration which resulted the first\ntimeout.\n\nThe drain timeout was made fatal by an earlier commit which fixed the\nWAIT_FOR return value handling.\n\nFixes: 72fddd86b7d7 [formerly 6226f9e6e44f] (\\\"dma: dw: fix the return value check\\\") Please fix this issue.",
  "input": "Faulty tokenized code:\ncondition|(\noperator|!\nname|fifo_empty\ncondition|)\nblock|{\nname|LOG_ERR\nargument_list|(\nliteral|\"%s: dma %d channel drain time out\"\nargument_list|,\nname|__func__\nargument_list|,\nname|channel\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|ETIMEDOUT\nreturn|;\nblock|}\nendif|#\ndirective|endif\nname|dw_write\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|LOG_ERR\n+name|LOG_WRN\n-return|return\n-operator|-\n-name|ETIMEDOUT\n-return|;\n+comment|/* Continue even if draining timed out to make sure that the channel is going to be \t\t * disabled. \t\t * The same channel might be requested for other purpose (or for same) next time \t\t * which will fail if the channel has been left enabled. \t\t */\nThe issue was with: drivers: dma: dma_dw_common: Disable channel even if draining times out\n\nIf the channel suspend with draining fails on stop because of reasons\noutside of the scope of the DMA driver (the peripheral is powered off\nbefore trying to drain for example) we must continue and disable the\nchannel.\n\nThe channel can be released by the client despite of it remained enabled.\nA new DMA channel request can pick the channel (as it is released) but\nre-configuration is going to be skipped and the use of the channel is going\nto fail. Then we will see the same drain timeout on channel stop again\nsince the channel retained the configuration which resulted the first\ntimeout.\n\nThe drain timeout was made fatal by an earlier commit which fixed the\nWAIT_FOR return value handling.\n\nFixes: 72fddd86b7d7 [formerly 6226f9e6e44f] (\\\"dma: dw: fix the return value check\\\")"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: w1: fix return check in bit_read for w1-gpio\n\nThe driver masked the return value of a pin read operation before\nchecking the error.\nThus not detecting a potential error and leading to logically\ndead code, which was detected by coverity in CID 340853.\nAnther instance XORs 1 before returning, resulting in an unexpected\nreturn value; Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|=\nname|gpio_pin_get_dt\nargument_list|(\nname|spec\nargument_list|)\noperator|^\nliteral|0x01\nexpr_stmt|;\nif|if\ncondition|(\nname|ret\noperator|<\nblock|{\ngoto|goto\nname|out\ngoto|;\nblock|}\nname|W1_GPIO_WAIT_US\nargument_list|(\nname|timing\noperator|->\nname|j\noperator|=\nname|gpio_pin_get_dt\nargument_list|(\nname|spec\nargument_list|)\noperator|&\nliteral|0x01\nexpr_stmt|;\nif|if\ncondition|(\nname|ret\noperator|<\nblock|{\ngoto|goto\nname|out\ngoto|;\nblock|}\nname|W1_GPIO_WAIT_US\nargument_list|(\nname|timing\noperator|->\nname|f",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|^\n-literal|0x01\n+name|ret\n+operator|^=\n+literal|0x01\n+expr_stmt|;\n-operator|&\n-literal|0x01\n+name|ret\n+operator|&=\n+literal|0x01\n+expr_stmt|;\nThe issue was with: drivers: w1: fix return check in bit_read for w1-gpio\n\nThe driver masked the return value of a pin read operation before\nchecking the error.\nThus not detecting a potential error and leading to logically\ndead code, which was detected by coverity in CID 340853.\nAnther instance XORs 1 before returning, resulting in an unexpected\nreturn value;"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Host: Send status for terminated directed adv\n\n- Fix bug where status was only sent for legacy adv Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|BT_ADV_CONNECTABLE\nargument_list|)\ncondition|)\nblock|{\ncomment|/* Only set status for legacy advertising API. \t\t * This will call connected callback for high duty cycle \t\t * directed advertiser timeout. \t\t */\nname|le_adv_stop_free_conn\nargument_list|(\nname|adv\nargument_list|,\nname|adv\noperator|==\nname|bt_dev\noperator|.\nname|adv\ncondition|?\nname|evt\noperator|->\nname|status\nelse|:\nliteral|0\nargument_list|)\nexpr_stmt|;\nblock|}\nif|if\ncondition|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* Only set status for legacy advertising API. \t\t * This will call connected callback for high duty cycle \t\t * directed advertiser timeout. \t\t */\n+comment|/* This will call connected callback for high duty cycle \t\t * directed advertiser timeout. \t\t */\n-name|adv\n-operator|==\n-name|bt_dev\n-operator|.\n-name|adv\n-condition|?\n-else|:\n-literal|0\nThe issue was with: Bluetooth: Host: Send status for terminated directed adv\n\n- Fix bug where status was only sent for legacy adv"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Mesh: Warn if trying to send adv while suspended\n\nThis will warn if any of the mesh module will try to send anything while\nthe stack is suspended. Not clear what to do here as both advertisers\n(legacy and ext) behaves differently. The legacy advertiser has a\nthread which is stopped after the `bt_mesh_adv_disable` call and any\nsent advs after suspending the stack will stay in the pool until the\nadvertiser is resumed. The extended advertiser will schedule its work,\nbut then fail because `ext_adv->instance` value is NULL, but will call\n`bt_mesh_send_cb.start` with error `-ENODEV`. What to do with these 2\nbehaviors is unclear at the moment. Ideally none of the mesh stack\nmodules should call `bt_mesh_adv_send` after the stack was suspended, so\nif this warning appears, the faulty module wasn't stopped properly and\nthis should be fixed. If not to add the adv to the pool, then it kind\nof gets lost as the implementation probably expects one\nof `bt_mesh_send_cb` callbacks which will never be called. Leaving the\nwarning until clear customer request comes. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|.\nname|len\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|adv\noperator|->\nname|ctx\noperator|.\nname|cb",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|atomic_test_bit\n+argument_list|(\n+name|bt_mesh\n+operator|.\n+name|flags\n+argument_list|,\n+name|BT_MESH_SUSPENDED\n+argument_list|)\n+condition|)\n+block|{\n+name|LOG_WRN\n+argument_list|(\n+literal|\"Sending advertisement while suspended\"\n+argument_list|)\n+expr_stmt|;\n+block|}\nThe issue was with: Bluetooth: Mesh: Warn if trying to send adv while suspended\n\nThis will warn if any of the mesh module will try to send anything while\nthe stack is suspended. Not clear what to do here as both advertisers\n(legacy and ext) behaves differently. The legacy advertiser has a\nthread which is stopped after the `bt_mesh_adv_disable` call and any\nsent advs after suspending the stack will stay in the pool until the\nadvertiser is resumed. The extended advertiser will schedule its work,\nbut then fail because `ext_adv->instance` value is NULL, but will call\n`bt_mesh_send_cb.start` with error `-ENODEV`. What to do with these 2\nbehaviors is unclear at the moment. Ideally none of the mesh stack\nmodules should call `bt_mesh_adv_send` after the stack was suspended, so\nif this warning appears, the faulty module wasn't stopped properly and\nthis should be fixed. If not to add the adv to the pool, then it kind\nof gets lost as the implementation probably expects one\nof `bt_mesh_send_cb` callbacks which will never be called. Leaving the\nwarning until clear customer request comes."
},{
  "instruction": "There is an issue in the following code. It relates to tests: bsim: bluetooth: mesh: Change error code on timeout\n\nThis commit changes error code returned by `k_sem_take` when it times\nout from `-EAGAIN` to `-ETIMEDOUT` because `bt_le_scan_start` also\nreturns `-EAGAIN` if bt device is not ready, which may lead to invalid\ntest behavior. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nname|returned_value\noperator|=\noperator|-\nname|EAGAIN\nexpr_stmt|;\nblock|}\nif|else if\ncondition|(\nname|err\nname|err\noperator|&&\nname|err\noperator|!=\noperator|-\nname|EAGAIN\nargument_list|)\nexpr_stmt|;\ncomment|/* Wait for DUT to resume Mesh and notify Tester, then scan for gatt proxy beacons */\nname|ASSERT_OK\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|EAGAIN\n+name|ETIMEDOUT\n-name|EAGAIN\n+name|ETIMEDOUT\nThe issue was with: tests: bsim: bluetooth: mesh: Change error code on timeout\n\nThis commit changes error code returned by `k_sem_take` when it times\nout from `-EAGAIN` to `-ETIMEDOUT` because `bt_le_scan_start` also\nreturns `-EAGAIN` if bt device is not ready, which may lead to invalid\ntest behavior."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: fixing UBSAN warnings related to Codec Configuration\n\nDuring local testing with UBSAN enabled, warning was reported:\nbluetooth/host/iso.c:237:2: runtime error: null pointer passed\nas argument 2, which is declared to never be null\n\nIt turned out that when datapath doesn't contain\ncodec information, cc_len is 0 and cc is NULL\n\nIn order to avoid UB,\nnow we call memcpy only when cp->codec_config_len > 0 Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|=\nname|net_buf_add\nargument_list|(\nname|buf\nargument_list|,\nname|cp\noperator|->\nname|codec_config_len\nargument_list|)\nexpr_stmt|;\nname|memcpy\nargument_list|(\nname|cc\nargument_list|,\nname|path\noperator|->\nname|cc\nargument_list|,\nname|cp\noperator|->\nname|codec_config_len\nargument_list|)\nexpr_stmt|;\nname|err\noperator|=\nname|bt_hci_cmd_send_sync\nargument_list|(\nname|BT_HCI_OP_LE_SETUP_ISO_PATH",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|cp\n+name|path\n-name|codec_config_len\n+name|cc_len\n+if|if\n+condition|(\n+name|path\n+operator|->\n+name|cc_len\n+condition|)\n+block|{\n-name|cp\n+name|path\n-name|codec_config_len\n+name|cc_len\n+block|}\nThe issue was with: Bluetooth: fixing UBSAN warnings related to Codec Configuration\n\nDuring local testing with UBSAN enabled, warning was reported:\nbluetooth/host/iso.c:237:2: runtime error: null pointer passed\nas argument 2, which is declared to never be null\n\nIt turned out that when datapath doesn't contain\ncodec information, cc_len is 0 and cc is NULL\n\nIn order to avoid UB,\nnow we call memcpy only when cp->codec_config_len > 0"
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: spi: wait more when polling\n\nExtend timeout to perform coverage analysis when testing on HW.\nCoverage mode makes execution slower. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nliteral|1\nargument_list|,\nname|K_MSEC\nargument_list|(\nliteral|200\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|zassert_false\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|200\n+literal|2000\nThe issue was with: tests: drivers: spi: wait more when polling\n\nExtend timeout to perform coverage analysis when testing on HW.\nCoverage mode makes execution slower."
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: spi: allow to configure thread stack size\n\nUsed to perform coverage analysis when testing on HW.\nGathering coverage data require more stack,\nso its needs to configurable.\nThere is used CONFIG_TEST_EXTRA_STACK_SIZE for that.\n(with value depending on used HW). Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_define\nDECL|macro|STACK_SIZE\ndefine|#\ndirective|define\nname|STACK_SIZE\nvalue|512\nend_define\n\nbegin_define\nDECL|macro|BUF_SIZE\ndefine|#\nbegin_define\nDECL|macro|STACK_SIZE\ndefine|#\ndirective|define\nname|STACK_SIZE\nvalue|512\nend_define\n\nbegin_define\nDECL|macro|BUF_SIZE\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|512\n+value|(512 + CONFIG_TEST_EXTRA_STACK_SIZE)\n-value|512\n+value|(512 + CONFIG_TEST_EXTRA_STACK_SIZE)\nThe issue was with: tests: drivers: spi: allow to configure thread stack size\n\nUsed to perform coverage analysis when testing on HW.\nGathering coverage data require more stack,\nso its needs to configurable.\nThere is used CONFIG_TEST_EXTRA_STACK_SIZE for that.\n(with value depending on used HW)."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: modem: ublox-sara-r4: freeaddrinfo mark unused param\n\nThe res param in offload_freeaddrinfo is not used.\nMark it as unused, to avoid static analysis complaining about\nParse warning (PW.PARAM_SET_BUT_NOT_USED)\nFixes CID 316235 Please fix this issue.",
  "input": "Faulty tokenized code:\nmodifier|*\nname|res\nparameter_list|)\nblock|{\ncomment|/* using static result from offload_getaddrinfo() -- no need to free */\nname|res\noperator|=\nname|NULL\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_decl_stmt",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|ARG_UNUSED\n+argument_list|(\n-operator|=\n-name|NULL\n+argument_list|)\nThe issue was with: drivers: modem: ublox-sara-r4: freeaddrinfo mark unused param\n\nThe res param in offload_freeaddrinfo is not used.\nMark it as unused, to avoid static analysis complaining about\nParse warning (PW.PARAM_SET_BUT_NOT_USED)\nFixes CID 316235"
},{
  "instruction": "There is an issue in the following code. It relates to modem: hl7800: check sem take in event handler\n\nOnly execute event callbacks if the semaphore is successfully taken. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|struct\nname|mdm_hl7800_callback_agent\nmodifier|*\nname|agent\ndecl_stmt|;\nname|k_sem_take\nargument_list|(\noperator|&\nname|cb_lock\nargument_list|,\nname|K_FOREVER\nargument_list|)\nexpr_stmt|;\nname|SYS_SLIST_FOR_EACH_NODE\nargument_list|(\nargument|&hl7800_event_callback_list\nargument_list|,\nargument|node\noperator|&\nname|cb_lock\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|mdm_hl7800_get_signal_quality (int * rsrp,int * sinr)\nname|void",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|int\n+name|ret\n+decl_stmt|;\n+name|ret\n+operator|=\n+if|if\n+condition|(\n+name|ret\n+operator|==\n+literal|0\n+condition|)\n+block|{\n+block|}\nThe issue was with: modem: hl7800: check sem take in event handler\n\nOnly execute event callbacks if the semaphore is successfully taken."
},{
  "instruction": "There is an issue in the following code. It relates to modem: hl7800: sock_read len arg is not used\n\nThe static function sock_read does not need a length arg, remove it. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nblock|}\nend_function\n\nbegin_function\nDECL|function|sock_read (struct net_buf ** buf,uint16_t len)\nspecifier|static\nname|void\nname|sock_read\nparameter_list|(\nname|struct\nname|net_buf\nmodifier|*\nmodifier|*\nname|buf\nparameter_list|,\nname|uint16_t\nname|len\nparameter_list|)\nblock|{\nname|struct\nname|hl7800_socket\nmodifier|*\nblock|}\nname|frag\noperator|=\nname|NULL\nexpr_stmt|;\nname|len\noperator|=\nname|net_buf_findcrlf\nargument_list|(\noperator|*\nname|buf\nargument_list|,\nname|false\nexpr_stmt|;\nname|sock_read\nargument_list|(\nname|buf\nargument_list|,\nname|len\nargument_list|)\nexpr_stmt|;\nblock|}\nelse|else\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|sock_read (struct net_buf ** buf,uint16_t len)\n+DECL|function|sock_read (struct net_buf ** buf)\n-parameter_list|,\n-name|uint16_t\n-name|len\n-name|len\n-operator|=\n+operator|(\n+name|void\n+operator|)\n-argument_list|,\n-name|len\nThe issue was with: modem: hl7800: sock_read len arg is not used\n\nThe static function sock_read does not need a length arg, remove it."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: emul: Make fifo_read() respect size\n\nuart_emul_fifo_read() didn't regard the size arg, hence if the RX ring\nbuffer contained more data than the size of the input rx_data buffer\nsize, this could result in buffer overflow. This becomes more obvious\nwhen configuring device tree property latch-buffer-size > 1. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|rx_rb\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|ring_buf_get\nargument_list|(\nname|data\noperator|->\nname|rx_rb",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|bytes_to_read\n+operator|=\n+name|MIN\n+argument_list|(\n+name|bytes_to_read\n+argument_list|,\n+name|size\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: serial: emul: Make fifo_read() respect size\n\nuart_emul_fifo_read() didn't regard the size arg, hence if the RX ring\nbuffer contained more data than the size of the input rx_data buffer\nsize, this could result in buffer overflow. This becomes more obvious\nwhen configuring device tree property latch-buffer-size > 1."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Mesh: Reset solicitation settings before calling reset cb\n\nTrigger erasing solicitation settings before calling\n`bt_mesh_settings_store_pending` and `bt_mesh_prov.reset` callback.\nThe `bt_mesh_settings_store_pending` flushes every settings that is\npending to be erased. The `bt_mesh_prov.reset` callback must be called\nas the last step because a user is free to do anything from this\ncallback including rebooting or reprovisioning the device. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nif|if\ncondition|(\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_BT_SETTINGS\nargument_list|)\ncondition|)\nblock|{\nname|bt_mesh_settings_store_pending\nargument_list|()\nexpr_stmt|;\nblock|}\nif|if\ncondition|(\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_BT_MESH_PROV\nargument_list|)\ncondition|)\nblock|{\nname|bt_mesh_prov_reset\nargument_list|()\nexpr_stmt|;\nblock|}\nif|if\ncondition|(\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_BT_MESH_PROXY_SOLICITATION\nargument_list|)\ncondition|)\nblock|{\nname|bt_mesh_sol_reset\nargument_list|()\nexpr_stmt|;\nblock|}\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_BT_SETTINGS\n+name|CONFIG_BT_MESH_PROXY_SOLICITATION\n-name|bt_mesh_settings_store_pending\n+name|bt_mesh_sol_reset\n-name|CONFIG_BT_MESH_PROV\n+name|CONFIG_BT_SETTINGS\n-name|bt_mesh_prov_reset\n+name|bt_mesh_settings_store_pending\n-name|CONFIG_BT_MESH_PROXY_SOLICITATION\n+name|CONFIG_BT_MESH_PROV\n-name|bt_mesh_sol_reset\n+name|bt_mesh_prov_reset\nThe issue was with: Bluetooth: Mesh: Reset solicitation settings before calling reset cb\n\nTrigger erasing solicitation settings before calling\n`bt_mesh_settings_store_pending` and `bt_mesh_prov.reset` callback.\nThe `bt_mesh_settings_store_pending` flushes every settings that is\npending to be erased. The `bt_mesh_prov.reset` callback must be called\nas the last step because a user is free to do anything from this\ncallback including rebooting or reprovisioning the device."
},{
  "instruction": "There is an issue in the following code. It relates to libc: newlib: Grant access to dynamic locks from all threads\n\nFixes: zephyrproject-rtos#67504\n\nThe following error is produced  when using the following configuration\n```\nCONFIG_USERSPACE=y\nCONFIG_NEWLIB_LIBC=y\nCONFIG_NEWLIB_LIBC_NANO=n\nCONFIG_DYNAMIC_OBJECTS=y\nCONFIG_HEAP_MEM_POOL_SIZE=256\nCONFIG_THREAD_LOCAL_STORAGE=y\nCONFIG_MAIN_STACK_SIZE=2048\n```\n\n```\nos: thread 0x301a2950 (-1) does not have permission on k_mutex 0x301aaca4\nos: permission bitmap\n01 00 |..\nos: syscall z_vrfy_k_mutex_lock failed check: access denied\nos: r0/a1: 0x00000000 r1/a2: 0x00000000 r2/a3: 0x00000000\nos: r3/a4: 0x00000000 r12/ip: 0x00000000 r14/lr: 0x00000000\nos: xpsr: 0x00000000\nos: s[ 0]: 0x00000000 s[ 1]: 0x00000000 s[ 2]: 0x00000000 s[ 3]: 0x00000000\nos: s[ 4]: 0x00000000 s[ 5]: 0x00000000 s[ 6]: 0x00000000 s[ 7]: 0x00000000\nos: s[ 8]: 0x00000000 s[ 9]: 0x00000000 s[10]: 0x00000000 s[11]: 0x00000000\nos: s[12]: 0x00000000 s[13]: 0x00000000 s[14]: 0x00000000 s[15]: 0x00000000\nos: fpscr: 0x00000000\nos: Faulting instruction address (r15/pc): 0xee7fdb7d\nos: >>> ZEPHYR FATAL ERROR 3: Kernel oops on CPU 0\nos: Current thread: 0x301a2950\n```\n\nThis bug caused by a global mutex used by _vfprintf_r()\nwhich is initialized in __sinit() and located in z_malloc_partition\nnot being granted access to be used my multiple user threads\ndespite each user thread being granted read and write permission\nto the z_malloc_partition.\n\nHere is a sample main.c to reproduce the bug\n```\n\nextern struct k_mem_partition z_libc_partition;\nextern struct k_mem_partition z_malloc_partition;\n\nstatic k_tid_t tids[TEST_THDS];\nstatic struct k_thread tcbs[TEST_THDS];\nstatic struct k_mem_domain domains[TEST_THDS];\nstatic K_THREAD_STACK_ARRAY_DEFINE(thd_stacks, TEST_THDS, 2048);\n\nstatic int forbidden_global_data = 2;\n\nvoid thread_worker(void* a, void* b, void* c) {\n    (void)b;\n    (void)c;\n    printf(\\\"thd %d started\\n\\\", (int)(intptr_t)a);\n    k_sleep(K_MSEC(1000));\n    forbidden_global_data++; /* This should cause an MPU Fault */\n}\n\nint main(void) {\n    forbidden_global_data = 1;\n    struct k_mem_partition* share_parts[2] = {\n        &z_libc_partition,\n        &z_malloc_partition,\n    };\n\n    for (int i = 0l; i < TEST_THDS; i++) {\n        tids[i] = k_thread_create(\n\t\t\t&tcbs[i],\n\t\t\tthd_stacks[i],\n\t\t\tK_THREAD_STACK_SIZEOF(thd_stacks[i]),\n\t\t\tthread_worker,\n\t\t\t(void*)(intptr_t)i,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\t5,\n\t\t\tK_USER,\n\t\t\tK_FOREVER);\n        k_mem_domain_init(&domains[i], 2, share_parts);\n        k_mem_domain_add_thread(&domains[i], tids[i]);\n        k_thread_start(tids[i]);\n   }\n\n    for (int i = 0; i < TEST_THDS; i++) {\n        k_thread_join(tids[i], K_FOREVER);\n    }\n\n   return 0;\n}\n``` Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|1\nargument_list|,\nliteral|1\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_comment\ncomment|/* Create a new dynamic recursive lock */\noperator|)\noperator|*\nname|lock\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_comment\ncomment|/* Close dynamic non-recursive lock */",
  "result": "I corrected the issue in the code by changing the following tokens:\n+ifdef|#\n+directive|ifdef\n+name|CONFIG_USERSPACE\n+name|k_object_access_all_grant\n+argument_list|(\n+operator|*\n+name|lock\n+argument_list|)\n+expr_stmt|;\n+endif|#\n+directive|endif\n+comment|/* CONFIG_USERSPACE */\n+ifdef|#\n+directive|ifdef\n+name|CONFIG_USERSPACE\n+name|k_object_access_all_grant\n+argument_list|(\n+operator|*\n+name|lock\n+argument_list|)\n+expr_stmt|;\n+endif|#\n+directive|endif\n+comment|/* CONFIG_USERSPACE */\nThe issue was with: libc: newlib: Grant access to dynamic locks from all threads\n\nFixes: zephyrproject-rtos#67504\n\nThe following error is produced  when using the following configuration\n```\nCONFIG_USERSPACE=y\nCONFIG_NEWLIB_LIBC=y\nCONFIG_NEWLIB_LIBC_NANO=n\nCONFIG_DYNAMIC_OBJECTS=y\nCONFIG_HEAP_MEM_POOL_SIZE=256\nCONFIG_THREAD_LOCAL_STORAGE=y\nCONFIG_MAIN_STACK_SIZE=2048\n```\n\n```\nos: thread 0x301a2950 (-1) does not have permission on k_mutex 0x301aaca4\nos: permission bitmap\n01 00 |..\nos: syscall z_vrfy_k_mutex_lock failed check: access denied\nos: r0/a1: 0x00000000 r1/a2: 0x00000000 r2/a3: 0x00000000\nos: r3/a4: 0x00000000 r12/ip: 0x00000000 r14/lr: 0x00000000\nos: xpsr: 0x00000000\nos: s[ 0]: 0x00000000 s[ 1]: 0x00000000 s[ 2]: 0x00000000 s[ 3]: 0x00000000\nos: s[ 4]: 0x00000000 s[ 5]: 0x00000000 s[ 6]: 0x00000000 s[ 7]: 0x00000000\nos: s[ 8]: 0x00000000 s[ 9]: 0x00000000 s[10]: 0x00000000 s[11]: 0x00000000\nos: s[12]: 0x00000000 s[13]: 0x00000000 s[14]: 0x00000000 s[15]: 0x00000000\nos: fpscr: 0x00000000\nos: Faulting instruction address (r15/pc): 0xee7fdb7d\nos: >>> ZEPHYR FATAL ERROR 3: Kernel oops on CPU 0\nos: Current thread: 0x301a2950\n```\n\nThis bug caused by a global mutex used by _vfprintf_r()\nwhich is initialized in __sinit() and located in z_malloc_partition\nnot being granted access to be used my multiple user threads\ndespite each user thread being granted read and write permission\nto the z_malloc_partition.\n\nHere is a sample main.c to reproduce the bug\n```\n\nextern struct k_mem_partition z_libc_partition;\nextern struct k_mem_partition z_malloc_partition;\n\nstatic k_tid_t tids[TEST_THDS];\nstatic struct k_thread tcbs[TEST_THDS];\nstatic struct k_mem_domain domains[TEST_THDS];\nstatic K_THREAD_STACK_ARRAY_DEFINE(thd_stacks, TEST_THDS, 2048);\n\nstatic int forbidden_global_data = 2;\n\nvoid thread_worker(void* a, void* b, void* c) {\n    (void)b;\n    (void)c;\n    printf(\\\"thd %d started\\n\\\", (int)(intptr_t)a);\n    k_sleep(K_MSEC(1000));\n    forbidden_global_data++; /* This should cause an MPU Fault */\n}\n\nint main(void) {\n    forbidden_global_data = 1;\n    struct k_mem_partition* share_parts[2] = {\n        &z_libc_partition,\n        &z_malloc_partition,\n    };\n\n    for (int i = 0l; i < TEST_THDS; i++) {\n        tids[i] = k_thread_create(\n\t\t\t&tcbs[i],\n\t\t\tthd_stacks[i],\n\t\t\tK_THREAD_STACK_SIZEOF(thd_stacks[i]),\n\t\t\tthread_worker,\n\t\t\t(void*)(intptr_t)i,\n\t\t\tNULL,\n\t\t\tNULL,\n\t\t\t5,\n\t\t\tK_USER,\n\t\t\tK_FOREVER);\n        k_mem_domain_init(&domains[i], 2, share_parts);\n        k_mem_domain_add_thread(&domains[i], tids[i]);\n        k_thread_start(tids[i]);\n   }\n\n    for (int i = 0; i < TEST_THDS; i++) {\n        k_thread_join(tids[i], K_FOREVER);\n    }\n\n   return 0;\n}\n```"
},{
  "instruction": "There is an issue in the following code. It relates to fs: Clarify description of fs_open when no access bits given\n\nAdd warning that file opened without R/W flags will have no read/write\naccess.\nRemove suggestion for using fs_open to check if file exists.\nClarify -ENOENT return reason.\n\nFixes #64030 Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright (c) 2016 Intel Corporation.  * Copyright (c) 2020-2021 Nordic Semiconductor ASA  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_ifndef\nifndef|#\ndirective|ifndef\nDECL|enumerator|FS_DIR_ENTRY_DIR\nname|FS_DIR_ENTRY_DIR\nblock|}\nenum|;\ncomment|/** @brief Enumeration to uniquely identify file system types.  *  * Zephyr supports in-tree file systems and external ones.  Each  * requires a unique identifier used to register the file system  * implementation and to associate a mount point with the file system  * type.  This anonymous enum defines global identifiers for the  * in-tree file systems.  *  * External file systems should be registered using unique identifiers  * starting at @c FS_TYPE_EXTERNAL_BASE.  It is the responsibility of  * applications that use external file systems to ensure that these  * identifiers are unique if multiple file system implementations are  * used by the application.  */\nDECL|enum|__anon27dae75d0103\nenum|enum\nblock|{\ncomment|/** Identifier for in-tree FatFS file system. */\nDECL|enumerator|FS_FATFS\nname|FS_FATFS\nblock|{\nliteral|0\nblock|}\nexpr_stmt|;\nblock|}\ncomment|/**  * @brief Open or create file  *  * Opens or possibly creates a file and associates a stream with it.  *  * @details  * @p flags can be 0 or a binary combination of one or more of the following  * identifiers:  *   - @c FS_O_READ open for read  *   - @c FS_O_WRITE open for write  *   - @c FS_O_RDWR open for read/write (<tt>FS_O_READ | FS_O_WRITE</tt>)  *   - @c FS_O_CREATE create file if it does not exist  *   - @c FS_O_APPEND move to end of file before each write  *  * If @p flags are set to 0 the function will attempt to open an existing file  * with no read/write access; this may be used to e.g. check if the file exists.  *  * @param zfp Pointer to a file object  * @param file_name The name of a file to open  * @param flags The mode flags  *  * @retval 0 on success;  * @retval -EBUSY when zfp is already used;  * @retval -EINVAL when a bad file name is given;  * @retval -EROFS when opening read-only file for write, or attempting to  *\t   create a file on a system that has been mounted with the  *\t   FS_MOUNT_FLAG_READ_ONLY flag;  * @retval -ENOENT when the file path is not possible (bad mount point);  * @retval -ENOTSUP when not implemented by underlying file system driver;  * @retval<0 an other negative errno code, depending on a file system back-end.  */\nname|int\nname|fs_open\nparameter_list|(\nname|struct\nname|fs_file_t\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright (c) 2018 Intel Corporation.  * Copyright (c) 2020 Peter Bigot Consulting, LLC  * Copyright (c) 2020 Nordic Semiconductor ASA  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/*  * Copyright (c) 2016 Intel Corporation.  * Copyright (c) 2020-2021 Nordic Semiconductor ASA  *  * SPDX-License-Identifier: Apache-2.0  */\n+comment|/*  * Copyright (c) 2016 Intel Corporation.  * Copyright (c) 2020-2024 Nordic Semiconductor ASA  *  * SPDX-License-Identifier: Apache-2.0  */\n-DECL|enum|__anon27dae75d0103\n+DECL|enum|__anon27a648350103\n-comment|/**  * @brief Open or create file  *  * Opens or possibly creates a file and associates a stream with it.  *  * @details  * @p flags can be 0 or a binary combination of one or more of the following  * identifiers:  *   - @c FS_O_READ open for read  *   - @c FS_O_WRITE open for write  *   - @c FS_O_RDWR open for read/write (<tt>FS_O_READ | FS_O_WRITE</tt>)  *   - @c FS_O_CREATE create file if it does not exist  *   - @c FS_O_APPEND move to end of file before each write  *  * If @p flags are set to 0 the function will attempt to open an existing file  * with no read/write access; this may be used to e.g. check if the file exists.  *  * @param zfp Pointer to a file object  * @param file_name The name of a file to open  * @param flags The mode flags  *  * @retval 0 on success;  * @retval -EBUSY when zfp is already used;  * @retval -EINVAL when a bad file name is given;  * @retval -EROFS when opening read-only file for write, or attempting to  *\t   create a file on a system that has been mounted with the  *\t   FS_MOUNT_FLAG_READ_ONLY flag;  * @retval -ENOENT when the file path is not possible (bad mount point);  * @retval -ENOTSUP when not implemented by underlying file system driver;  * @retval<0 an other negative errno code, depending on a file system back-end.  */\n+comment|/**  * @brief Open or create file  *  * Opens or possibly creates a file and associates a stream with it.  * Successfully opened file, when no longer in use, should be closed  * with fs_close().  *  * @details  * @p flags can be 0 or a binary combination of one or more of the following  * identifiers:  *   - @c FS_O_READ open for read  *   - @c FS_O_WRITE open for write  *   - @c FS_O_RDWR open for read/write (<tt>FS_O_READ | FS_O_WRITE</tt>)  *   - @c FS_O_CREATE create file if it does not exist  *   - @c FS_O_APPEND move to end of file before each write  *  * @warning If @p flags are set to 0 the function will open file, if it exists  *          and is accessible, but you will have no read/write access to it.  *  * @param zfp Pointer to a file object  * @param file_name The name of a file to open  * @param flags The mode flags  *  * @retval 0 on success;  * @retval -EBUSY when zfp is already used;  * @retval -EINVAL when a bad file name is given;  * @retval -EROFS when opening read-only file for write, or attempting to  *\t   create a file on a system that has been mounted with the  *\t   FS_MOUNT_FLAG_READ_ONLY flag;  * @retval -ENOENT when the file does not exist at the path;  * @retval -ENOTSUP when not implemented by underlying file system driver;  * @retval<0 an other negative errno code, depending on a file system back-end.  */\n-comment|/*  * Copyright (c) 2018 Intel Corporation.  * Copyright (c) 2020 Peter Bigot Consulting, LLC  * Copyright (c) 2020 Nordic Semiconductor ASA  *  * SPDX-License-Identifier: Apache-2.0  */\n+comment|/*  * Copyright (c) 2018 Intel Corporation.  * Copyright (c) 2020 Peter Bigot Consulting, LLC  * Copyright (c) 2020-2024 Nordic Semiconductor ASA  *  * SPDX-License-Identifier: Apache-2.0  */\nThe issue was with: fs: Clarify description of fs_open when no access bits given\n\nAdd warning that file opened without R/W flags will have no read/write\naccess.\nRemove suggestion for using fs_open to check if file exists.\nClarify -ENOENT return reason.\n\nFixes #64030"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: espi: npcx: update for espi reset level\n\nThis CL updates the event data returned by espi_reset.\nReturn 0 for eSPI bus in reset, and 1 for eSPI bus out-of-reset. Please fix this issue.",
  "input": "Faulty tokenized code:\ndecl_stmt|;\nDECL|member|plt_rst_asserted\nname|uint8_t\nname|plt_rst_asserted\ndecl_stmt|;\nDECL|member|espi_rst_asserted\nname|uint8_t\nname|espi_rst_asserted\ndecl_stmt|;\nDECL|member|sx_state\nname|uint8_t\nname|sx_state\ndecl_stmt|;\nliteral|0\nblock|}\ndecl_stmt|;\nname|data\noperator|->\nname|espi_rst_asserted\noperator|=\noperator|!\nname|IS_BIT_SET\nargument_list|(\nname|inst\noperator|->\nname|ESPISTS\nname|NPCX_ESPISTS_ESPIRST_LVL\nargument_list|)\nexpr_stmt|;\nname|LOG_DBG\nargument_list|(\nliteral|\"eSPI RST asserted is %d!\"\nargument_list|,\nname|data\noperator|->\nname|espi_rst_asserted\nargument_list|)\nexpr_stmt|;\nname|evt\noperator|.\nname|evt_data\noperator|=\nname|data\noperator|->\nname|espi_rst_asserted\nexpr_stmt|;\nname|espi_send_callbacks\nargument_list|(\noperator|&\nname|data\nDECL|member|plt_rst_asserted\nname|uint8_t\nname|plt_rst_asserted\ndecl_stmt|;\ncomment|/* current PLT_RST# status */\nDECL|member|espi_rst_asserted\nname|uint8_t\nname|espi_rst_asserted\ndecl_stmt|;\ncomment|/* current ESPI_RST# status */\nDECL|member|host_bus_dev\nspecifier|const\nname|struct\nbegin_struct\nDECL|struct|npcx_dp80_buf\nstruct|struct\nname|npcx_dp80_buf\nblock|{\nDECL|union|__anon2c2ac771010a\nunion|union\nblock|{\nDECL|member|offset_code_16\nname|uint16_t\nname|offset_code_16",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|member|espi_rst_asserted\n+DECL|member|espi_rst_level\n-name|espi_rst_asserted\n+name|espi_rst_level\n-name|espi_rst_asserted\n+name|espi_rst_level\n-operator|!\n-literal|\"eSPI RST asserted is %d!\"\n+literal|\"eSPI RST level is %d!\"\n-name|espi_rst_asserted\n+name|espi_rst_level\n-name|espi_rst_asserted\n+name|espi_rst_level\n-DECL|member|espi_rst_asserted\n+DECL|member|espi_rst_level\n-name|espi_rst_asserted\n+name|espi_rst_level\n-DECL|union|__anon2c2ac771010a\n+DECL|union|__anon2c6b95f1010a\nThe issue was with: drivers: espi: npcx: update for espi reset level\n\nThis CL updates the event data returned by espi_reset.\nReturn 0 for eSPI bus in reset, and 1 for eSPI bus out-of-reset."
},{
  "instruction": "There is an issue in the following code. It relates to posix: semaphore: check return value of k_mutex_lock()\n\nThis fixes CID 340851.\n\nThis should never fail, but it's also something that can be\neasily verified. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|nsem_list_lock\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nname|k_mutex_lock\nargument_list|(\noperator|&\nname|nsem_mutex\nargument_list|,\nname|K_FOREVER\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|__unused\n+name|int\n+name|ret\n+init|=\n+decl_stmt|;\n+name|__ASSERT\n+argument_list|(\n+name|ret\n+operator|==\n+literal|0\n+argument_list|,\n+literal|\"nsem_list_lock() failed: %d\"\n+argument_list|,\n+name|ret\n+argument_list|)\nThe issue was with: posix: semaphore: check return value of k_mutex_lock()\n\nThis fixes CID 340851.\n\nThis should never fail, but it's also something that can be\neasily verified."
},{
  "instruction": "There is an issue in the following code. It relates to ipc: Drain pending work items before deregistering endpoint\n\nThe work item will attempt to dereference pointers that have been nulled\nby the backend.\n\nTo avoid that, wait until all items currently on the queue have been\nprocessed.\n\nThe symptom is a busfault on ARM, and is \\\"fixed\\\" by adding a\n`k_msleep(1)` right before `ipc_service_deregister_endpoint()`. This\nwill in effect do the same thing as this patch, and allow the scheduler\nto run the work item on the ipc workqueue. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|struct\nname|ipc_rpmsg_ept\nmodifier|*\nname|rpmsg_ept\ndecl_stmt|;\ncomment|/* Instance is not ready */\nif|if\ncondition|(\nname|atomic_get\nargument_list|(\nreturn|return\noperator|-\nname|ENOENT\nreturn|;\nblock|}\nname|rpmsg_destroy_ept\nargument_list|(\noperator|&\nname|rpmsg_ept\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n+specifier|static\n+name|struct\n+name|k_work_sync\n+name|sync\n+decl_stmt|;\n+comment|/* Drain pending work items before tearing down channel. \t * \t * Note: `k_work_flush` Faults on Cortex-M33 with \"illegal use of EPSR\" \t * if `sync` is not declared static. \t */\n+name|k_work_flush\n+argument_list|(\n+operator|&\n+name|data\n+operator|->\n+name|mbox_work\n+argument_list|,\n+operator|&\n+name|sync\n+argument_list|)\n+expr_stmt|;\nThe issue was with: ipc: Drain pending work items before deregistering endpoint\n\nThe work item will attempt to dereference pointers that have been nulled\nby the backend.\n\nTo avoid that, wait until all items currently on the queue have been\nprocessed.\n\nThe symptom is a busfault on ARM, and is \\\"fixed\\\" by adding a\n`k_msleep(1)` right before `ipc_service_deregister_endpoint()`. This\nwill in effect do the same thing as this patch, and allow the scheduler\nto run the work item on the ipc workqueue."
},{
  "instruction": "There is an issue in the following code. It relates to modem: change log level of events prints to debug\n\ninfo level is printed always to console and it's noisy.\nChange to debug level, which can be enabled with\nCONFIG_MODEM_MODULES_LOG_LEVEL_DBG Please fix this issue.",
  "input": "Faulty tokenized code:\nname|enum\nname|modem_cellular_state\nname|new_state\nparameter_list|)\nblock|{\nname|LOG_INF\nargument_list|(\nliteral|\"switch from %s to %s\"\nargument_list|,\nname|modem_cellular_state_str\nargument_list|(\nname|enum\nname|modem_cellular_event\nname|evt\nparameter_list|)\nblock|{\nname|LOG_INF\nargument_list|(\nliteral|\"event %s\"\nargument_list|,\nname|modem_cellular_event_str\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|LOG_INF\n+name|LOG_DBG\n-name|LOG_INF\n+name|LOG_DBG\nThe issue was with: modem: change log level of events prints to debug\n\ninfo level is printed always to console and it's noisy.\nChange to debug level, which can be enabled with\nCONFIG_MODEM_MODULES_LOG_LEVEL_DBG"
},{
  "instruction": "There is an issue in the following code. It relates to intel_adsp: ace: Remove dead code\n\nace/boot.c is ace specific file and RESET_MEMORY_HOLE symbol is never\ndefined for this target. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|=\nliteral|0\nexpr_stmt|;\nendif|#\ndirective|endif\nifdef|#\ndirective|ifdef\nname|RESET_MEMORY_HOLE\ncomment|/* reset memory hole */\nname|CAVS_SHIM\noperator|.\nname|l2mecs\noperator|=\nliteral|0\nexpr_stmt|;\nendif|#\ndirective|endif\nspecifier|extern\nname|void\nname|hp_sram_init\nargument_list|(\nname|uint32_t",
  "result": "I corrected the issue in the code by changing the following tokens:\n-ifdef|#\n-directive|ifdef\n-name|RESET_MEMORY_HOLE\n-comment|/* reset memory hole */\n-name|CAVS_SHIM\n-operator|.\n-name|l2mecs\n-operator|=\n-literal|0\n-expr_stmt|;\n-endif|#\n-directive|endif\nThe issue was with: intel_adsp: ace: Remove dead code\n\nace/boot.c is ace specific file and RESET_MEMORY_HOLE symbol is never\ndefined for this target."
},{
  "instruction": "There is an issue in the following code. It relates to test: net: net_pkt: use var buffer pool for testing\n\nFrom change 47eb592c28b9e7dfbdd25fedbf07a528ad240084 net_buf structures\nallocated from pools defined with NET_BUF_POOL_FIXED_DEFINE() will keep\ntheir `size` member set to the actual fixed size and not requested\nsize like before.\n\nFor this set of tests NET_BUF_POOL_FIXED_DEFINE() for several test\ncases. These tests check the several values based on a fact that the\nnetwork buffer's size was set to the requested size.\n\nThis commit changes definition of the buffer pool to\nNET_BUF_POOL_FIXED_DEFINE() in order to satisfy these expectations.\nThis change does not impact the tests themselves. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nblock|}\nend_block\n\nbegin_expr_stmt\nname|NET_BUF_POOL_FIXED_DEFINE\nargument_list|(\nname|test_net_pkt_headroom_copy_pool\nargument_list|,\nliteral|2\nargument_list|,\nliteral|4\nargument_list|,\nliteral|4\nargument_list|,\nname|NULL\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|NET_BUF_POOL_FIXED_DEFINE\n+name|NET_BUF_POOL_VAR_DEFINE\n-literal|4\n+literal|128\nThe issue was with: test: net: net_pkt: use var buffer pool for testing\n\nFrom change 47eb592c28b9e7dfbdd25fedbf07a528ad240084 net_buf structures\nallocated from pools defined with NET_BUF_POOL_FIXED_DEFINE() will keep\ntheir `size` member set to the actual fixed size and not requested\nsize like before.\n\nFor this set of tests NET_BUF_POOL_FIXED_DEFINE() for several test\ncases. These tests check the several values based on a fact that the\nnetwork buffer's size was set to the requested size.\n\nThis commit changes definition of the buffer pool to\nNET_BUF_POOL_FIXED_DEFINE() in order to satisfy these expectations.\nThis change does not impact the tests themselves."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: BAP: Broadcast source enabling state transition fix\n\nSince we may go from enabling to qos-configured state if the\ncall to bt_iso_big_create fails, that is a valid transition.\nIf bt_iso_big_create currently fails, then the source ends in a\nstate where it cannot be recovered. Please fix this issue.",
  "input": "Faulty tokenized code:\nif|if\ncondition|(\nname|state\noperator|!=\nname|BT_BAP_EP_STATE_STREAMING\ncondition|)\nblock|{\nname|LOG_DBG\nargument_list|(\nliteral|\"Invalid broadcast sync endpoint state transition\"",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|&&\n+name|state\n+operator|!=\n+name|BT_BAP_EP_STATE_QOS_CONFIGURED\nThe issue was with: Bluetooth: BAP: Broadcast source enabling state transition fix\n\nSince we may go from enabling to qos-configured state if the\ncall to bt_iso_big_create fails, that is a valid transition.\nIf bt_iso_big_create currently fails, then the source ends in a\nstate where it cannot be recovered."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: CAP: Fix uninitialized values in broadcast start\n\nWhen CONFIG_BT_ISO_TEST_PARAMS is enabled then the\nbt_bap_broadcast_source_param in\nbt_cap_initiator_broadcast_audio_create had uninitialized values.\n\nA general and future proof solution for this is to simply initialize\nthe entire struct to 0. Please fix this issue.",
  "input": "Faulty tokenized code:\nindex|]\ndecl_stmt|;\nname|struct\nname|bt_bap_broadcast_source_param\nname|bap_create_param\ndecl_stmt|;\nname|CHECKIF\nargument_list|(\nargument|param == NULL\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+init|=\n+block|{\n+literal|0\n+block|}\nThe issue was with: Bluetooth: CAP: Fix uninitialized values in broadcast start\n\nWhen CONFIG_BT_ISO_TEST_PARAMS is enabled then the\nbt_bap_broadcast_source_param in\nbt_cap_initiator_broadcast_audio_create had uninitialized values.\n\nA general and future proof solution for this is to simply initialize\nthe entire struct to 0."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: rpi_pico_pwm: Fix compilation warnings\n\nreturn value of pwm_rpi_get_clkdiv contains implicit conversions\nfrom 'float' to 'double', triggered by floating-point operations\ninvolving mixed data types. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|slice\nindex|]\noperator|.\nname|frac\noperator|/\nliteral|16.0\nreturn|;\nblock|}\nend_function\n\nbegin_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|16.0\n+literal|16.0f\nThe issue was with: drivers: rpi_pico_pwm: Fix compilation warnings\n\nreturn value of pwm_rpi_get_clkdiv contains implicit conversions\nfrom 'float' to 'double', triggered by floating-point operations\ninvolving mixed data types."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: ISO: Fix duplicate log statements for PDU check\n\nModifies two log statements so that it is clear whether it\nis failing to validate broadcast or unicast PDU sizes. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\ncondition|)\nblock|{\nname|LOG_DBG\nargument_list|(\nliteral|\"Invalid PDU %u\"\nargument_list|,\nname|io_qos\noperator|->\nname|max_pdu\nargument_list|)\nargument_list|)\ncondition|)\nblock|{\nname|LOG_DBG\nargument_list|(\nliteral|\"Invalid PDU %u\"\nargument_list|,\nname|io_qos\noperator|->\nname|max_pdu\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"Invalid PDU %u\"\n+literal|\"Invalid broadcast PDU %u\"\n-literal|\"Invalid PDU %u\"\n+literal|\"Invalid unicast PDU %u\"\nThe issue was with: Bluetooth: ISO: Fix duplicate log statements for PDU check\n\nModifies two log statements so that it is clear whether it\nis failing to validate broadcast or unicast PDU sizes."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: can: mcan: Fix off-by-one errors in asserts\n\nFix off-by-one errors in asserts. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|return;\nblock|}\nname|__ASSERT_NO_MSG\nargument_list|(\nname|tx_idx\noperator|<=\nname|cbs\noperator|->\nname|num_tx\nargument_list|)\nexpr_stmt|;\nargument_list|)\nexpr_stmt|;\nname|__ASSERT_NO_MSG\nargument_list|(\nname|filt_idx\noperator|<=\nname|cbs\noperator|->\nname|num_ext\nargument_list|)\nexpr_stmt|;\nargument_list|)\nexpr_stmt|;\nname|__ASSERT_NO_MSG\nargument_list|(\nname|filt_idx\noperator|<=\nname|cbs\noperator|->\nname|num_std\nargument_list|)\nexpr_stmt|;\nargument_list|)\nexpr_stmt|;\nname|__ASSERT_NO_MSG\nargument_list|(\nname|filter_id\noperator|<=\nname|cbs\noperator|->\nname|num_std\nargument_list|)\nexpr_stmt|;\nargument_list|)\nexpr_stmt|;\nname|__ASSERT_NO_MSG\nargument_list|(\nname|filter_id\noperator|<=\nname|cbs\noperator|->\nname|num_ext\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|<=\n+operator|<\n-operator|<=\n+operator|<\n-operator|<=\n+operator|<\n-operator|<=\n+operator|<\n-operator|<=\n+operator|<\nThe issue was with: drivers: can: mcan: Fix off-by-one errors in asserts\n\nFix off-by-one errors in asserts."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: dma: intel-adsp-hda: modify stop dma logic\n\nCommit b2eaa6448076 (\\\"drivers: dma: intel-adsp-hda: add delay to stop\nhost dma\\\") added a wait on GBUSY state to host DMA stop.\n\nThis is problematic as in some case (like SOF chain-DMA usage),\nthe host DMA side RUN bit is not cleared when intel_adsp_hda_dma_stop()\nis called. It is not possible to wait on GBUSY bit as there are\nvalid cases where it can remain set.\n\nAddress the original problem described in SOF bug #8686 and add a\npolling check for intel_adsp_hda_is_enabled(). As per the bug\ndescription, in some cases the GEN/FIFORDY bits are not cleared\nimmediately and if a new call to intel_adsp_hda_dma_stop() is made, the\nPM refcounting will go haywire.\n\nLink: https://github.com/thesofproject/sof/issues/8686 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|regblock_size\nargument_list|,\nname|channel\nargument_list|)\nexpr_stmt|;\ncomment|/* host dma needs some cycles to completely stop */\nif|if\ncondition|(\nname|cfg\noperator|->\nname|direction\noperator|==\nname|HOST_TO_MEMORY\noperator|||\nname|cfg\noperator|->\nname|direction\noperator|==\nname|MEMORY_TO_HOST\ncondition|)\nblock|{\nif|if\ncondition|(\noperator|!\nname|WAIT_FOR\nargument_list|(\noperator|!\noperator|(\noperator|*\nname|DGCS\nargument_list|(\nname|cfg\noperator|->\nname|base\nargument_list|,\noperator|->\nname|regblock_size\nargument_list|,\nname|channel\nargument_list|)\noperator|&\nname|DGCS_GBUSY\noperator|)\nargument_list|,\nliteral|1000\nargument_list|,\nname|k_busy_wait\nargument_list|(\nreturn|return\noperator|-\nname|EBUSY\nreturn|;\nblock|}\nblock|}\nreturn|return\nname|pm_device_runtime_put\nargument_list|(\nname|dev\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* host dma needs some cycles to completely stop */\n-if|if\n-condition|(\n-name|cfg\n-operator|->\n-name|direction\n-operator|==\n-name|HOST_TO_MEMORY\n-operator|||\n-name|cfg\n-operator|->\n-name|direction\n-operator|==\n-name|MEMORY_TO_HOST\n-condition|)\n-block|{\n-operator|(\n-operator|*\n-name|DGCS\n+name|intel_adsp_hda_is_enabled\n-operator|&\n-name|DGCS_GBUSY\n-operator|)\n-block|}\nThe issue was with: drivers: dma: intel-adsp-hda: modify stop dma logic\n\nCommit b2eaa6448076 (\\\"drivers: dma: intel-adsp-hda: add delay to stop\nhost dma\\\") added a wait on GBUSY state to host DMA stop.\n\nThis is problematic as in some case (like SOF chain-DMA usage),\nthe host DMA side RUN bit is not cleared when intel_adsp_hda_dma_stop()\nis called. It is not possible to wait on GBUSY bit as there are\nvalid cases where it can remain set.\n\nAddress the original problem described in SOF bug #8686 and add a\npolling check for intel_adsp_hda_is_enabled(). As per the bug\ndescription, in some cases the GEN/FIFORDY bits are not cleared\nimmediately and if a new call to intel_adsp_hda_dma_stop() is made, the\nPM refcounting will go haywire.\n\nLink: https://github.com/thesofproject/sof/issues/8686"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: input: cst816s: add alternative chip id\n\nThe CST816S chip ID have an alternative value. It seems that this\nfield represents in fact a version number of controller. Fix by adding\nthe new chip ID. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_define\nDECL|macro|CST816S_CHIP_ID\ndefine|#\ndirective|define\nname|CST816S_CHIP_ID\nvalue|0xB4\nend_define\n\nbegin_define\nDECL|macro|CST816S_REG_DATA\ndefine|#\ndirective|define\nname|CST816S_REG_DATA\nname|ret\nreturn|;\nblock|}\nif|if\ncondition|(\nname|chip_id\noperator|!=\nname|CST816S_CHIP_ID\ncondition|)\nblock|{\nname|LOG_ERR\nargument_list|(\nliteral|\"CST816S wrong chip id: returned 0x%x\"",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|macro|CST816S_CHIP_ID\n+DECL|macro|CST816S_CHIP_ID1\n-name|CST816S_CHIP_ID\n+name|CST816S_CHIP_ID1\n+begin_define\n+DECL|macro|CST816S_CHIP_ID2\n+define|#\n+directive|define\n+name|CST816S_CHIP_ID2\n+value|0xB5\n+end_define\n+\n+operator|(\n-name|CST816S_CHIP_ID\n+name|CST816S_CHIP_ID1\n+operator|)\n+operator|&&\n+operator|(\n+name|chip_id\n+operator|!=\n+name|CST816S_CHIP_ID2\n+operator|)\nThe issue was with: drivers: input: cst816s: add alternative chip id\n\nThe CST816S chip ID have an alternative value. It seems that this\nfield represents in fact a version number of controller. Fix by adding\nthe new chip ID."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: tmp108: fix coverity integer handling issue\n\nFix coverity integer handling issue (CWE-188).\nModifying a variable through a pointer of an incompatible type (other\nthan unsigned char) can lead to unpredictable results.\n\nFix: #67965\nCoverity-CID: 248434 Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|)\nblock|{\nname|int\nname|result\ndecl_stmt|;\nif|if\ncondition|(\nname|chan\noperator|!=\nname|SENSOR_CHAN_AMBIENT_TEMP\nargument_list|(\nname|dev\nargument_list|,\nname|TI_TMP108_REG_CONF\nargument_list|,\noperator|(\nname|uint16_t\noperator|*\noperator|)\noperator|&\noperator|(\nname|val\noperator|->\nname|val1\noperator|)\nargument_list|)\nexpr_stmt|;\nbreak|break;\ndefault|default:\nreturn|return\noperator|-",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|uint16_t\n+name|tmp_val\n+decl_stmt|;\n-operator|(\n-name|uint16_t\n-operator|*\n-operator|)\n-operator|(\n+name|tmp_val\n+argument_list|)\n+expr_stmt|;\n-operator|)\n-argument_list|)\n+operator|=\n+name|tmp_val\n+expr_stmt|;\n+name|val\n+operator|->\n+name|val2\n+operator|=\n+literal|0\nThe issue was with: drivers: sensor: tmp108: fix coverity integer handling issue\n\nFix coverity integer handling issue (CWE-188).\nModifying a variable through a pointer of an incompatible type (other\nthan unsigned char) can lead to unpredictable results.\n\nFix: #67965\nCoverity-CID: 248434"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: display: gc9x01x: fix bindings include\n\nThe GC9X01X driver relies on panel.h instead of gc9x01x.h (doesn't\nexist). Please fix this issue.",
  "input": "Faulty tokenized code:\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/dt-bindings/display/gc9x01x.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include",
  "result": "I corrected the issue in the code by changing the following tokens:\n-file|<zephyr/dt-bindings/display/gc9x01x.h>\n+file|<zephyr/dt-bindings/display/panel.h>\nThe issue was with: drivers: display: gc9x01x: fix bindings include\n\nThe GC9X01X driver relies on panel.h instead of gc9x01x.h (doesn't\nexist)."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: ra: reduce uart baud rate error\n\nUsing the 8 base clock cycles per bit period setting (instead of 16)\nreduces the uart baud rate error when using a 12MHz crystal (found on\nmany RA Microcontroller development kits boards). This setting also\nslightly reduces the error when using the internal 48MHz oscillator,\nused by the Arduino UNO R4 Minima board currently support by Zephyr. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_enum\nDECL|enum|__anon2bb1e4260103\nenum|enum\nblock|{\nDECL|enumerator|UART_RA_INT_RXI\nname|UART_RA_INT_RXI\nblock|,\nname|SEMR\nargument_list|)\nexpr_stmt|;\nname|reg_val\noperator||=\nname|REG_MASK\nargument_list|(\nname|SEMR_BGDM\nargument_list|)\nexpr_stmt|;\nname|reg_val\noperator|&=\noperator|~\noperator|(\noperator||\nname|REG_MASK\nargument_list|(\nname|SEMR_ABCSE\nargument_list|)\noperator||\nname|REG_MASK\nargument_list|(\nname|SEMR_ABCS\nargument_list|)\noperator|)\nexpr_stmt|;\nname|uart_ra_write_8\nargument_list|(\nname|dev\nname|data\noperator|->\nname|clk_rate\noperator|/\noperator|(\nliteral|16\noperator|*\nname|data\noperator|->\nname|current_config\noperator|.",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon2bb1e4260103\n+DECL|enum|__anon2c28d1c80103\n+operator|(\n+operator||\n+name|REG_MASK\n+argument_list|(\n+name|SEMR_ABCS\n+argument_list|)\n+operator|)\n-operator||\n-name|REG_MASK\n-argument_list|(\n-name|SEMR_ABCS\n-argument_list|)\n-literal|16\n+literal|8\nThe issue was with: drivers: serial: ra: reduce uart baud rate error\n\nUsing the 8 base clock cycles per bit period setting (instead of 16)\nreduces the uart baud rate error when using a 12MHz crystal (found on\nmany RA Microcontroller development kits boards). This setting also\nslightly reduces the error when using the internal 48MHz oscillator,\nused by the Arduino UNO R4 Minima board currently support by Zephyr."
},{
  "instruction": "There is an issue in the following code. It relates to kernel/thread: Detect in-kernel \\\"reserved\\\" stack overflow\n\nTraditionally, k_thread_create() has required that the application\nsize the stack correctly.  Zephyr doesn't detect or return errors and\ntreats stack overflow as an application bug (though obviously some\narchitectures have runtime features to trap on overflows).\n\nAt this one spot though, it's possible for the kernel to adjust the\nstack for K_THREAD_STACK_RESERVED in such a way that the arch layer's\nown stack initialization overflows.  That failure can be seen by\nstatic analysis, so we can't just sweep it under the rug as an\napplication failure.\n\nUnfortunately there aren't any good options for handling it here (no\nway to return failure, can't be a build assert as the size is a\nruntime argument).  A panic will have to do.\n\nFixes: #67106\nFixes: #65584 Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|base\noperator|.\nname|thread_state\ndecl_stmt|;\nDECL|struct|__anon2a2f781c0108\nspecifier|static\nspecifier|const\nstruct|struct\nblock|{\nDECL|member|str\noperator|=\nname|stack_obj_size\noperator|-\nname|K_KERNEL_STACK_RESERVED\nexpr_stmt|;\nblock|}\ncomment|/* Initial stack pointer at the high end of the stack object, may \t * be reduced later in this function by TLS or random offset \t */\nname|stack_ptr\noperator|=\noperator|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2a2f781c0108\n+DECL|struct|__anon28b95f2e0108\n+comment|/* Zephyr treats stack overflow as an app bug.  But \t\t * this particular overflow can be seen by static \t\t * analysis so needs to be handled somehow. \t\t */\n+if|if\n+condition|(\n+name|K_KERNEL_STACK_RESERVED\n+operator|>\n+name|stack_obj_size\n+condition|)\n+block|{\n+name|k_panic\n+argument_list|()\n+expr_stmt|;\n+block|}\nThe issue was with: kernel/thread: Detect in-kernel \\\"reserved\\\" stack overflow\n\nTraditionally, k_thread_create() has required that the application\nsize the stack correctly.  Zephyr doesn't detect or return errors and\ntreats stack overflow as an application bug (though obviously some\narchitectures have runtime features to trap on overflows).\n\nAt this one spot though, it's possible for the kernel to adjust the\nstack for K_THREAD_STACK_RESERVED in such a way that the arch layer's\nown stack initialization overflows.  That failure can be seen by\nstatic analysis, so we can't just sweep it under the rug as an\napplication failure.\n\nUnfortunately there aren't any good options for handling it here (no\nway to return failure, can't be a build assert as the size is a\nruntime argument).  A panic will have to do.\n\nFixes: #67106\nFixes: #65584"
},{
  "instruction": "There is an issue in the following code. It relates to soc: arm: xilinx_zynqmp: Add \\\"Execute Never\\\" MPU flag to non-code RAM\n\nExecuting from RAM sections other than rom/code should cause a fault.\nThis is tested as part of the kernel mem_protect tests. Please fix this issue.",
  "input": "Faulty tokenized code:\ndefine|\\\nvalue|{ \\ \t\t.rasr = (P_RO_U_RO_Msk \\ \t\t\t\t| (5<< MPU_RASR_TEX_Pos) \\ \t\t\t\t| MPU_RASR_B_Msk) \\ \t}\nend_define\n\nbegin_define\nDECL|macro|MPUTYPE_PRIV_WBWACACHE\ndefine|#\ndirective|define\nname|MPUTYPE_PRIV_WBWACACHE\ndefine|\\\nvalue|{ \\ \t\t.rasr = (P_RW_U_NA_Msk \\ \t\t\t\t| (5<< MPU_RASR_TEX_Pos) \\ \t\t\t\t| MPU_RASR_B_Msk) \\ \t}\nend_define\n\nbegin_define\nDECL|macro|MPUTYPE_PRIV_DEVICE\ndefine|#\nargument_list|,\nliteral|0x00000000\nargument_list|,\nname|REGION_2G\nargument_list|,\nname|MPUTYPE_PRIV_WBWACACHE\nargument_list|)\nblock|,\nname|MPU_REGION_ENTRY\nargument_list|(\nliteral|\"SRAM\"",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|macro|MPUTYPE_PRIV_WBWACACHE\n+DECL|macro|MPUTYPE_PRIV_WBWACACHE_XN\n-name|MPUTYPE_PRIV_WBWACACHE\n+name|MPUTYPE_PRIV_WBWACACHE_XN\n-value|{ \\ \t\t.rasr = (P_RW_U_NA_Msk \\ \t\t\t\t| (5<< MPU_RASR_TEX_Pos) \\ \t\t\t\t| MPU_RASR_B_Msk) \\ \t}\n+value|{ \\ \t\t.rasr = (P_RW_U_NA_Msk \\ \t\t\t\t| (5<< MPU_RASR_TEX_Pos) \\ \t\t\t\t| MPU_RASR_B_Msk \\ \t\t\t\t| MPU_RASR_XN_Msk) \\ \t}\n-name|MPUTYPE_PRIV_WBWACACHE\n+name|MPUTYPE_PRIV_WBWACACHE_XN\nThe issue was with: soc: arm: xilinx_zynqmp: Add \\\"Execute Never\\\" MPU flag to non-code RAM\n\nExecuting from RAM sections other than rom/code should cause a fault.\nThis is tested as part of the kernel mem_protect tests."
},{
  "instruction": "There is an issue in the following code. It relates to tests: kernel: mem_protect: Handle thumb instructions for Cortex-R\n\nCheck for COMPILER_ISA_THUMB2 rather than CPU_CORTEX_M when determining\nif special handling is required for thumb instructions.\n\nThis prevents false negative results on Cortex-R devices that may\ngenerate a fault (test pass) even if the MMU/MPU is not configured\ncorrectly. Please fix this issue.",
  "input": "Faulty tokenized code:\nend_function\n\nbegin_ifdef\nifdef|#\ndirective|ifdef\nname|CONFIG_CPU_CORTEX_M\nend_ifdef\n\nbegin_include\ninclude|#\ndirective|include\nfile|<cmsis_core.h>\nend_include\n\nbegin_comment\ncomment|/* Must clear LSB of function address to access as data. */\nend_comment\n\nbegin_define",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_CPU_CORTEX_M\n+name|CONFIG_COMPILER_ISA_THUMB2\n-begin_include\n-include|#\n-directive|include\n-file|<cmsis_core.h>\n-end_include\n-\nThe issue was with: tests: kernel: mem_protect: Handle thumb instructions for Cortex-R\n\nCheck for COMPILER_ISA_THUMB2 rather than CPU_CORTEX_M when determining\nif special handling is required for thumb instructions.\n\nThis prevents false negative results on Cortex-R devices that may\ngenerate a fault (test pass) even if the MMU/MPU is not configured\ncorrectly."
},{
  "instruction": "There is an issue in the following code. It relates to tests: net: ip-addr: Fix compiler warning\n\nBuilding with Zephyr SDK 0.16.5 revealed a minor bug with the buffer\nsize provided to snprintk():\n  specified bound 38 exceeds destination size 20 [-Wstringop-overflow=]\n\nAs we provide the buffer to snprintk() with an offset, the actual\nbuffer size should be reduced by that offset value. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|)\ndefine|\\\nvalue|do {\t\t\t\t\t\t\t\t\\ \t\tuint8_t ll[] = { a, b, c, d, e, f, g, h };\t\t\t\\ \t\tzassert_false(strcmp(net_sprint_ll_addr(ll, sizeof(ll)), \\ \t\t\t\t     expected),\t\t\t\t\\ \t\t\t      \"Test %s failed.\\n\", expected);\t\t\\ \t} while (0)\nend_define\n\nbegin_define\nDECL|macro|TEST_LL_6_TWO (a,b,c,d,e,f,expected)\ndefine|#\ndirective|define\nname|TEST_LL_6_TWO\nname|f\nparameter_list|,\nname|expected\nparameter_list|)\ndefine|\\\nvalue|do {\t\t\t\t\t\t\t\t\\ \t\tuint8_t ll1[] = { a, b, c, d, e, f };\t\t\t\\ \t\tuint8_t ll2[] = { f, e, d, c, b, a };\t\t\t\\ \t\tchar out[2 * sizeof(\"xx:xx:xx:xx:xx:xx\") + 1 + 1];\t\\ \t\tsnprintk(out, sizeof(out), \"%s \",\t\t\t\\ \t\t\t net_sprint_ll_addr(ll1, sizeof(ll1)));\t\t\\ \t\tsnprintk(out + sizeof(\"xx:xx:xx:xx:xx:xx\"),\t\t\\ \t\t\t sizeof(out), \"%s\",\t\t\t\t\\ \t\t\t net_sprint_ll_addr(ll2, sizeof(ll2)));\t\t\\ \t\tzassert_false(strcmp(out, expected),\t\t\t\\ \t\t\t      \"Test %s failed, got %s\\n\", expected,\t\\ \t\t\t      out);\t\t\t\t\t\\ \t} while (0)\nend_define\n\nbegin_define\nDECL|macro|TEST_IPV6 (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,expected)\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_define\n+DECL|macro|LL_ADDR_STR_SIZE\n+define|#\n+directive|define\n+name|LL_ADDR_STR_SIZE\n+value|sizeof(\"xx:xx:xx:xx:xx:xx\")\n+end_define\n+\n-value|do {\t\t\t\t\t\t\t\t\\ \t\tuint8_t ll1[] = { a, b, c, d, e, f };\t\t\t\\ \t\tuint8_t ll2[] = { f, e, d, c, b, a };\t\t\t\\ \t\tchar out[2 * sizeof(\"xx:xx:xx:xx:xx:xx\") + 1 + 1];\t\\ \t\tsnprintk(out, sizeof(out), \"%s \",\t\t\t\\ \t\t\t net_sprint_ll_addr(ll1, sizeof(ll1)));\t\t\\ \t\tsnprintk(out + sizeof(\"xx:xx:xx:xx:xx:xx\"),\t\t\\ \t\t\t sizeof(out), \"%s\",\t\t\t\t\\ \t\t\t net_sprint_ll_addr(ll2, sizeof(ll2)));\t\t\\ \t\tzassert_false(strcmp(out, expected),\t\t\t\\ \t\t\t      \"Test %s failed, got %s\\n\", expected,\t\\ \t\t\t      out);\t\t\t\t\t\\ \t} while (0)\n+value|do {\t\t\t\t\t\t\t\t\\ \t\tuint8_t ll1[] = { a, b, c, d, e, f };\t\t\t\\ \t\tuint8_t ll2[] = { f, e, d, c, b, a };\t\t\t\\ \t\tchar out[2 * LL_ADDR_STR_SIZE + 1 + 1];\t\\ \t\tsnprintk(out, sizeof(out), \"%s \",\t\t\t\\ \t\t\t net_sprint_ll_addr(ll1, sizeof(ll1)));\t\t\\ \t\tsnprintk(out + LL_ADDR_STR_SIZE,\t\t\t\\ \t\t\t sizeof(out) - LL_ADDR_STR_SIZE, \"%s\",\t\t\\ \t\t\t net_sprint_ll_addr(ll2, sizeof(ll2)));\t\t\\ \t\tzassert_false(strcmp(out, expected),\t\t\t\\ \t\t\t      \"Test %s failed, got %s\\n\", expected,\t\\ \t\t\t      out);\t\t\t\t\t\\ \t} while (0)\nThe issue was with: tests: net: ip-addr: Fix compiler warning\n\nBuilding with Zephyr SDK 0.16.5 revealed a minor bug with the buffer\nsize provided to snprintk():\n  specified bound 38 exceeds destination size 20 [-Wstringop-overflow=]\n\nAs we provide the buffer to snprintk() with an offset, the actual\nbuffer size should be reduced by that offset value."
},{
  "instruction": "There is an issue in the following code. It relates to tests/c_lib: Remove define of _POSIX_C_SOURCE for newlib\n\nThis test does not use any APIs beyond those provided in the Zephyr\nstandard set, so it should not define _POSIX_C_SOURCE. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_if\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_NEWLIB_LIBC\nargument_list|)\noperator|||\nname|defined\nargument_list|(\nname|CONFIG_NATIVE_LIBC\nargument_list|)\nend_if\n\nbegin_undef",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_NEWLIB_LIBC\n-argument_list|)\n-operator|||\n-name|defined\n-argument_list|(\nThe issue was with: tests/c_lib: Remove define of _POSIX_C_SOURCE for newlib\n\nThis test does not use any APIs beyond those provided in the Zephyr\nstandard set, so it should not define _POSIX_C_SOURCE."
},{
  "instruction": "There is an issue in the following code. It relates to arch: isr_tables: Add __used attribute to int_list_header\n\nThis commit adds missing __used attribute it int_list_header,\npreventing it from being optimized out. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nend_macro\n\nbegin_decl_stmt\nDECL|variable|_iheader\nname|struct\nname|int_list_header\nname|_iheader\ninit|=\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|__used\nThe issue was with: arch: isr_tables: Add __used attribute to int_list_header\n\nThis commit adds missing __used attribute it int_list_header,\npreventing it from being optimized out."
},{
  "instruction": "There is an issue in the following code. It relates to llext: Remove automatic include\n\nclangd like to automatically add include directives, this one slipped by\nand made its way in the tree. Remove it. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright (c) 2023 Intel Corporation  *  * SPDX-License-Identifier: Apache-2.0  *  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nfile|\"zephyr/sys/__assert.h\"\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/sys/util.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_include\n-include|#\n-directive|include\n-file|\"zephyr/sys/__assert.h\"\n-end_include\n-\nThe issue was with: llext: Remove automatic include\n\nclangd like to automatically add include directives, this one slipped by\nand made its way in the tree. Remove it."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: display: ili9xxx: do not delay for reset unless supported\n\nCheck the return code of mipi_dbi_reset, and do not delay for the reset\nwait time unless the mipi controller has issued a hardware reset to the\ndisplay. Please fix this issue.",
  "input": "Faulty tokenized code:\ninit|=\nname|dev\noperator|->\nname|config\ndecl_stmt|;\nname|mipi_dbi_reset\nargument_list|(\nname|config\noperator|->\nname|mipi_dev\nargument_list|,\nname|ILI9XXX_RESET_PULSE_TIME\nargument_list|)\nexpr_stmt|;\nname|k_sleep\nargument_list|(\nname|K_MSEC\nargument_list|(\nname|ILI9XXX_RESET_WAIT_TIME",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n-expr_stmt|;\n+operator|<\n+literal|0\n+condition|)\n+block|{\n+return|return;\n+block|}\n+empty_stmt|;\nThe issue was with: drivers: display: ili9xxx: do not delay for reset unless supported\n\nCheck the return code of mipi_dbi_reset, and do not delay for the reset\nwait time unless the mipi controller has issued a hardware reset to the\ndisplay."
},{
  "instruction": "There is an issue in the following code. It relates to drvers: display: ili9xxx: fix usage of MIPI buffer descriptor\n\nFix usage of MIPI buffer descriptor in ili9xxx driver. Previously, the\nbuffer descriptor size was being set to display buffer size. For cases\nwhere the write height/width  was not equal to the size of the buffer, this\nresulted in additional data being written that was not needed. To\nresolve this, calculate the mipi descriptor buffer size in the driver\n\nAlso, remove the unconditional setting of mipi_desc.height, as this\nwould override the previous (correct) setting. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|.\nname|buf_size\noperator|=\nname|desc\noperator|->\nname|buf_size\nexpr_stmt|;\nname|nbr_of_writes\noperator|=\nliteral|1U\nexpr_stmt|;\noperator|=\nname|desc\noperator|->\nname|width\nexpr_stmt|;\nname|mipi_desc\noperator|.\nname|height\noperator|=\nname|desc\noperator|->\nname|height\nexpr_stmt|;\ncomment|/* Per MIPI API, pitch must always match width */\nname|mipi_desc\noperator|.\nname|pitch\noperator|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|buf_size\n+name|width\n+operator|*\n+name|data\n+operator|->\n+name|bytes_per_pixel\n+operator|*\n+name|write_h\n-name|mipi_desc\n-operator|.\n-name|height\n-operator|=\n-name|desc\n-operator|->\n-name|height\n-expr_stmt|;\nThe issue was with: drvers: display: ili9xxx: fix usage of MIPI buffer descriptor\n\nFix usage of MIPI buffer descriptor in ili9xxx driver. Previously, the\nbuffer descriptor size was being set to display buffer size. For cases\nwhere the write height/width  was not equal to the size of the buffer, this\nresulted in additional data being written that was not needed. To\nresolve this, calculate the mipi descriptor buffer size in the driver\n\nAlso, remove the unconditional setting of mipi_desc.height, as this\nwould override the previous (correct) setting."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: nrfx_uarte2: drop soc.h\n\nAs it is not required (e.g. RISC-V nRF54H port does not provide soc.h) Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/logging/log.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<soc.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<nrfx_uarte.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_include\n-include|#\n-directive|include\n-file|<soc.h>\n-end_include\n-\nThe issue was with: drivers: serial: nrfx_uarte2: drop soc.h\n\nAs it is not required (e.g. RISC-V nRF54H port does not provide soc.h)"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: timer: nrf_grtc_timer: Add dependency on nRF clock control\n\n... in the related parts, so that the driver can be used on nRF54H20\nwhere the clock control is not present yet. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/irq.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/drivers/clock_control/nrf_clock_control.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/drivers/timer/system_timer.h>\nend_include\nargument_list|(\nname|CYC_PER_TICK\nargument_list|)\nexpr_stmt|;\nblock|}\nspecifier|static\nspecifier|const\nname|enum\nname|nrf_lfclk_start_mode\nname|mode\nname|z_nrf_clock_control_lf_on\nargument_list|(\nname|mode\nargument_list|)\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_if\n+if|#\n+directive|if\n+name|defined\n+argument_list|(\n+name|CONFIG_CLOCK_CONTROL_NRF\n+argument_list|)\n+end_if\n+\n+begin_endif\n+endif|#\n+directive|endif\n+end_endif\n+\n+if|#\n+directive|if\n+name|defined\n+argument_list|(\n+name|CONFIG_CLOCK_CONTROL_NRF\n+argument_list|)\n+endif|#\n+directive|endif\nThe issue was with: drivers: timer: nrf_grtc_timer: Add dependency on nRF clock control\n\n... in the related parts, so that the driver can be used on nRF54H20\nwhere the clock control is not present yet."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: Fix handling of CTEInfo in le_ext_adv_report()\n\nHandling of CTEInfo being present was missing; Fixes test failure of\nLL/DDI/SCN/BV-89-C Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nif|if\ncondition|(\nname|h\noperator|->\nname|adi\ncondition|)\nblock|{\nname|adi_curr\noperator|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|cte_info\n+condition|)\n+block|{\n+comment|/* CTEInfo is RFU */\n+name|ptr\n+operator|+=\n+literal|1\n+expr_stmt|;\n+block|}\n+if|if\n+condition|(\n+name|h\n+operator|->\nThe issue was with: Bluetooth: Controller: Fix handling of CTEInfo in le_ext_adv_report()\n\nHandling of CTEInfo being present was missing; Fixes test failure of\nLL/DDI/SCN/BV-89-C"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Host: Set user data size for hfp tx pool\n\nThe user data size of hfp tx pool is zero.\n\nThere is not enough space to put tx_mate.\n\nUse CONFIG_BT_CONN_TX_USER_DATA_SIZE to\nset data size of hfp tx pool. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|BT_RFCOMM_BUF_SIZE\nargument_list|(\nname|BT_HF_CLIENT_MAX_PDU\nargument_list|)\nargument_list|,\nliteral|0\nargument_list|,\nname|NULL\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\nbegin_comment\ncomment|/* The order should follow the enum hfp_hf_ag_indicators */\nend_comment\n\nbegin_struct\nDECL|struct|__anon2af9dc4d0108\nspecifier|static\nspecifier|const\nstruct|struct\nblock|{\nDECL|member|name",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|0\n+name|CONFIG_BT_CONN_TX_USER_DATA_SIZE\n-DECL|struct|__anon2af9dc4d0108\n+DECL|struct|__anon27b38d9b0108\nThe issue was with: Bluetooth: Host: Set user data size for hfp tx pool\n\nThe user data size of hfp tx pool is zero.\n\nThere is not enough space to put tx_mate.\n\nUse CONFIG_BT_CONN_TX_USER_DATA_SIZE to\nset data size of hfp tx pool."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: Fix PA sync-ed ACL supervision timeout\n\nFix Periodic Advertising Synchronization leading to\nPeripheral ACL connection supervision timeout, due to\ndirection finding related radio hardware registers being\nupdated in the implementation that is not built for\ndirection finding feature support. Please fix this issue.",
  "input": "Faulty tokenized code:\ncomment|/* CONFIG_BT_CTLR_DF_SCAN_CTE_RX */\nif|if\ncondition|(\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_BT_CTLR_DF_SUPPORT\nargument_list|)\ncondition|)\nblock|{\ncomment|/* Disable CTE reception and sampling in Radio */\nname|radio_df_cte_inline_set_enabled",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_BT_CTLR_DF_SUPPORT\n+name|CONFIG_BT_CTLR_DF\nThe issue was with: Bluetooth: Controller: Fix PA sync-ed ACL supervision timeout\n\nFix Periodic Advertising Synchronization leading to\nPeripheral ACL connection supervision timeout, due to\ndirection finding related radio hardware registers being\nupdated in the implementation that is not built for\ndirection finding feature support."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: Fix coverity issue 340844\n\nFix coverity issue 340844, Uninitialized pointer read. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/* Memory pool to store IQ reports data */\nend_comment\n\nbegin_struct\nDECL|struct|__anon2c0c65ce0108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|free\nname|void\nname|lll\noperator|.\nname|sync\nexpr_stmt|;\ncomment|/* NOTE: ULL_ADV_PDU_EXTRA_DATA_ALLOC_NEVER is just information that extra_data \t * should be removed in case of this call ull_adv_sync_pdu_alloc. \t */\nname|err\noperator|=\nname|ull_adv_sync_pdu_alloc\nargument_list|(\nname|adv\nname|err\nreturn|;\nblock|}\nif|if\ncondition|(\nname|extra_data\ncondition|)\nblock|{\nname|ull_adv_sync_extra_data_set_clear\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2c0c65ce0108\n+DECL|struct|__anon28cbeffd0108\n+name|extra_data_prev\n+operator|=\n+name|NULL\n+expr_stmt|;\n+name|extra_data\n+operator|=\n+name|NULL\n+expr_stmt|;\n+name|extra_data_prev\n+operator|&&\nThe issue was with: Bluetooth: Controller: Fix coverity issue 340844\n\nFix coverity issue 340844, Uninitialized pointer read."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: Fix coverity issue 340845\n\nFix coverity issue 340845, Uninitialized pointer read. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/* Memory pool to store IQ reports data */\nend_comment\n\nbegin_struct\nDECL|struct|__anon2b8b203a0108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|free\nname|void\nname|rfu\noperator|=\nliteral|0U\nexpr_stmt|;\ncomment|/* Note: ULL_ADV_PDU_EXTRA_DATA_ALLOC_ALWAYS is just information that extra_data \t * is required in case of this ull_adv_sync_pdu_alloc. \t */\nname|err\noperator|=\nname|ull_adv_sync_pdu_alloc\nargument_list|(\nname|adv\nblock|{\nreturn|return\nname|err\nreturn|;\nblock|}\nname|ull_adv_sync_extra_data_set_clear\nargument_list|(\nname|NULL\nargument_list|,\nname|extra_data\nliteral|0\nargument_list|,\nname|df_cfg\nargument_list|)\nexpr_stmt|;\nif|#\ndirective|if\noperator|(\nname|CONFIG_BT_CTLR_DF_PER_ADV_CTE_NUM_MAX\noperator|>",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2b8b203a0108\n+DECL|struct|__anon2c0c65ce0108\n+name|extra_data\n+operator|=\n+name|NULL\n+expr_stmt|;\n+if|if\n+condition|(\n+name|extra_data\n+condition|)\n+block|{\n+block|}\nThe issue was with: Bluetooth: Controller: Fix coverity issue 340845\n\nFix coverity issue 340845, Uninitialized pointer read."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: Fix coverity issue 330027\n\nFix coverity issue 330027, Structurally dead code. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/* Setup cache for CIG commit transaction */\nend_comment\n\nbegin_struct\nDECL|struct|__anon27c5df460108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|group\nname|struct\ndecl_stmt|;\nname|uint8_t\nname|err\ndecl_stmt|;\ncomment|/* Intermediate subevent data */\nDECL|struct|__anon27c5df460208\nstruct|struct\nblock|{\nDECL|member|length\nname|uint32_t\nname|length\nblock|}\nreturn|return\noperator|-\nname|EBUSY\nreturn|;\nendif|#\ndirective|endif\ncomment|/* CONFIG_BT_CTLR_CENTRAL_SPACING  != 0 */\noperator|*\nname|cis_offset_min\noperator|=\nname|HAL_TICKER_TICKS_TO_US\nargument_list|(\nname|sync_delay\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function\n\nbegin_if\nif|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon27c5df460108\n+DECL|struct|__anon29fbbfa80108\n-DECL|struct|__anon27c5df460208\n+DECL|struct|__anon29fbbfa80208\n-endif|#\n-directive|endif\n-comment|/* CONFIG_BT_CTLR_CENTRAL_SPACING  != 0 */\n+else|#\n+directive|else\n+comment|/* CONFIG_BT_CTLR_CENTRAL_SPACING != 0 */\n+endif|#\n+directive|endif\n+comment|/* CONFIG_BT_CTLR_CENTRAL_SPACING != 0 */\nThe issue was with: Bluetooth: Controller: Fix coverity issue 330027\n\nFix coverity issue 330027, Structurally dead code."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: Fix coverity issue 330043\n\nFix coverity issue 330043, Unsigned compared against 0. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ticks_slot_overhead\nexpr_stmt|;\ncomment|/* Calculate total overheads due to extended and periodic advertising */\nif|if\ncondition|(\nname|CONFIG_BT_CTLR_ADV_AUX_SYNC_OFFSET\noperator|>\nliteral|0U\ncondition|)\nblock|{\nname|ticks_slot_aux\nargument_list|,\nname|ticks_slot_sync\nargument_list|)\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\nname|ticks_slot_overhead\noperator|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|false\n+condition|)\n+block|{\n+if|#\n+directive|if\n+name|defined\n+argument_list|(\n+name|CONFIG_BT_CTLR_ADV_AUX_SYNC_OFFSET\n+argument_list|)\n+block|}\n+if|else if\n+condition|(\n+endif|#\n+directive|endif\n+comment|/* CONFIG_BT_CTLR_ADV_AUX_SYNC_OFFSET */\nThe issue was with: Bluetooth: Controller: Fix coverity issue 330043\n\nFix coverity issue 330043, Unsigned compared against 0."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: counter: mcux_rtc: enable oscillator if supported\n\nSome devices like S32K1xx don't feature an internal 32.768 KHz\noscillator. Also, updated the code to use the existing HAL API\nfor this purpose. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright (c) 2018 blik GmbH  * Copyright (c) 2018, NXP  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_define\nDECL|macro|DT_DRV_COMPAT\ndefine|#\nargument_list|,\noperator|&\nname|rtc_config\nargument_list|)\nexpr_stmt|;\ncomment|/* Enable 32kHz oscillator and wait for 1ms to settle */\nname|config\noperator|->\nname|base\noperator|->\nname|CR\noperator||=\nliteral|0x100\nexpr_stmt|;\nname|k_busy_wait\nargument_list|(\nname|USEC_PER_MSEC\nargument_list|)\nexpr_stmt|;\nname|config\noperator|->\nname|irq_config_func\nargument_list|(\nname|dev",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/*  * Copyright (c) 2018 blik GmbH  * Copyright (c) 2018, NXP  *  * SPDX-License-Identifier: Apache-2.0  */\n+comment|/*  * Copyright (c) 2018 blik GmbH  * Copyright (c) 2018,2024 NXP  *  * SPDX-License-Identifier: Apache-2.0  */\n+if|#\n+directive|if\n+operator|!\n+operator|(\n+name|defined\n+argument_list|(\n+name|FSL_FEATURE_RTC_HAS_NO_CR_OSCE\n+argument_list|)\n+operator|&&\n+name|FSL_FEATURE_RTC_HAS_NO_CR_OSCE\n+operator|)\n+name|RTC_SetClockSource\n+argument_list|(\n-operator|->\n-name|CR\n-operator||=\n-literal|0x100\n+argument_list|)\n+endif|#\n+directive|endif\n+comment|/* !FSL_FEATURE_RTC_HAS_NO_CR_OSCE */\nThe issue was with: drivers: counter: mcux_rtc: enable oscillator if supported\n\nSome devices like S32K1xx don't feature an internal 32.768 KHz\noscillator. Also, updated the code to use the existing HAL API\nfor this purpose."
},{
  "instruction": "There is an issue in the following code. It relates to net: lib: coap: Reduce CoAP server stack usage\n\nDeclare the CoAP server receiving buffer as static to lower the\nstack usage. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|(\nname|int\nname|sock_fd\nparameter_list|)\nblock|{\nname|uint8_t\nname|buf\nindex|[\nname|CONFIG_COAP_SERVER_MESSAGE_SIZE\nindex|]\ndecl_stmt|;\nname|struct\nname|sockaddr_storage\nname|addr_storage\ndecl_stmt|;\nDECL|union|__anon29ab7374010a\nunion|union\nblock|{\nDECL|member|addr\nname|struct\nname|sockaddr",
  "result": "I corrected the issue in the code by changing the following tokens:\n+specifier|static\n-DECL|union|__anon29ab7374010a\n+DECL|union|__anon2a0acadb010a\nThe issue was with: net: lib: coap: Reduce CoAP server stack usage\n\nDeclare the CoAP server receiving buffer as static to lower the\nstack usage."
},{
  "instruction": "There is an issue in the following code. It relates to tests: CAN: change duplicate test name: get_capabilities\n\nIn twister, we do not include the ZTEST testsuite as part of the\nidentifier, something we should start doing especially for tests with\nmultiple suites. The issue happens with same testcase name in different\nsuites, where results get messed up.\nWork around this for now by making the testcase names unqiue until we\nhave a better solution twister. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/**  * @brief Test getting the CAN controller capabilities.  */\nend_comment\n\nbegin_macro\nDECL|function|ZTEST (canfd,test_get_capabilities)\nname|ZTEST\nargument_list|(\nargument|canfd\nargument_list|,\nargument|test_get_capabilities\nargument_list|)\nend_macro\n\nbegin_block\nblock|{\nbegin_comment\ncomment|/**  * @brief Test getting the CAN controller capabilities.  */\nend_comment\n\nbegin_macro\nDECL|function|ZTEST_USER (can_classic,test_get_capabilities)\nname|ZTEST_USER\nargument_list|(\nargument|can_classic\nargument_list|,\nargument|test_get_capabilities\nargument_list|)\nend_macro\n\nbegin_block\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|ZTEST (canfd,test_get_capabilities)\n+DECL|function|ZTEST (canfd,test_canfd_get_capabilities)\n-argument|test_get_capabilities\n+argument|test_canfd_get_capabilities\n-DECL|function|ZTEST_USER (can_classic,test_get_capabilities)\n+DECL|function|ZTEST_USER (can_classic,test_classic_get_capabilities)\n-argument|test_get_capabilities\n+argument|test_classic_get_capabilities\nThe issue was with: tests: CAN: change duplicate test name: get_capabilities\n\nIn twister, we do not include the ZTEST testsuite as part of the\nidentifier, something we should start doing especially for tests with\nmultiple suites. The issue happens with same testcase name in different\nsuites, where results get messed up.\nWork around this for now by making the testcase names unqiue until we\nhave a better solution twister."
},{
  "instruction": "There is an issue in the following code. It relates to dai: nxp: sai: Disable data line on pause trigger\n\nCurrently, whenever performing TRIGGER_PAUSE operation, the\ndata line is not disabled. This works well if TX and RX don't\noperate at the same time or they operate in ASYNC-ASYNC mode. This\nis because sai_tx_rx_disable() will disable transmitter/receiver\nall the time since there's no dependencies to take into consideration.\nHowever, in the ASYNC-SYNC mode, sai_tx_rx_disable() may not disable\nthe current asynchronous side if the synchronous side is still enabled.\nAs a consequence, the asynchronous side will remain enabled, thus\nleading to an underrun/overrun.\n\nTo fix this issue, sai_trigger_pause() should disable the data line\neach time it's called. This way, even if sai_tx_rx_disable() doesn't\ndisable the current direction, the data line will be disabled, thus\nstopping the consumption/production of frames. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nreturn|return\nname|ret\nreturn|;\nblock|}\ncomment|/* update the software state of TX/RX */\nname|sai_tx_rx_sw_enable_disable\nargument_list|(\nname|dir\nargument_list|,\nname|DAI_STATE_PAUSED\ncondition|)\nblock|{\ncomment|/* if SAI was previously paused then all that's \t\t * left to do is disable the DMA requests and \t\t * the data line. \t\t */\ngoto|goto\nname|out_dline_disable\ngoto|;\nblock|}\nname|ret\noperator|=\nname|sai_tx_rx_disable\nname|data\nargument_list|,\nname|false\nargument_list|)\nexpr_stmt|;\nname|out_dline_disable\nlabel|:\ncomment|/* disable TX/RX data line */\nname|sai_tx_rx_set_dline_mask\nargument_list|(\nname|dir\nargument_list|,\nname|regmap\nargument_list|,\nliteral|0x0\nargument_list|)\nexpr_stmt|;\ncomment|/* disable DMA requests */\nname|SAI_TX_RX_DMA_ENABLE_DISABLE\nargument_list|(\nname|dir\nargument_list|,\nname|DAI_STATE_PAUSED\ncondition|)\nblock|{\ncomment|/* if the SAI has been paused then there's no \t\t * point in issuing a software reset. As such, \t\t * skip this part and go directly to the TX/RX \t\t * enablement. \t\t */\ngoto|goto\nname|out_enable_tx_rx\ngoto|;\nblock|}\nname|LOG_DBG\nargument_list|(\nliteral|\"start on direction %d\"\nname|regmap\nargument_list|,\nname|true\nargument_list|)\nexpr_stmt|;\ncomment|/* enable TX/RX data line. This translates to TX_DLINE0/RX_DLINE0 \t * being enabled. \t * \t * TODO: for now we only support 1 data line per direction. \t */\nname|sai_tx_rx_set_dline_mask\nargument_list|(\nname|dir\nargument_list|,\nname|regmap\nargument_list|,\nliteral|0x1\nargument_list|)\nexpr_stmt|;\nname|out_enable_tx_rx\nlabel|:\ncomment|/* this will also enable the async side */\nname|SAI_TX_RX_ENABLE_DISABLE\nargument_list|(\nname|dir\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* disable TX/RX data line */\n+name|sai_tx_rx_set_dline_mask\n+argument_list|(\n+name|dir\n+argument_list|,\n+name|data\n+operator|->\n+name|regmap\n+argument_list|,\n+literal|0x0\n+argument_list|)\n+expr_stmt|;\n-name|out_dline_disable\n+name|out_dmareq_disable\n-name|out_dline_disable\n-label|:\n+name|out_dmareq_disable\n+label|:\n-name|out_enable_tx_rx\n+name|out_enable_dline\n+name|out_enable_dline\n+label|:\n-name|out_enable_tx_rx\n-label|:\nThe issue was with: dai: nxp: sai: Disable data line on pause trigger\n\nCurrently, whenever performing TRIGGER_PAUSE operation, the\ndata line is not disabled. This works well if TX and RX don't\noperate at the same time or they operate in ASYNC-ASYNC mode. This\nis because sai_tx_rx_disable() will disable transmitter/receiver\nall the time since there's no dependencies to take into consideration.\nHowever, in the ASYNC-SYNC mode, sai_tx_rx_disable() may not disable\nthe current asynchronous side if the synchronous side is still enabled.\nAs a consequence, the asynchronous side will remain enabled, thus\nleading to an underrun/overrun.\n\nTo fix this issue, sai_trigger_pause() should disable the data line\neach time it's called. This way, even if sai_tx_rx_disable() doesn't\ndisable the current direction, the data line will be disabled, thus\nstopping the consumption/production of frames."
},{
  "instruction": "There is an issue in the following code. It relates to xtensa: remove ARG_UNUSED from arch_syscall_oops\n\nssf is being passed to xtensa_arch_kernel_oops() so there is\nno need to mark ssf with ARG_UNUSED. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|void\nmodifier|*\nname|ssf\nparameter_list|)\nblock|{\nname|ARG_UNUSED\nargument_list|(\nname|ssf\nargument_list|)\nexpr_stmt|;\nname|xtensa_arch_kernel_oops\nargument_list|(\nname|K_ERR_KERNEL_OOPS\nargument_list|,\nname|ssf",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|ARG_UNUSED\n-argument_list|(\n-name|ssf\n-argument_list|)\n-expr_stmt|;\nThe issue was with: xtensa: remove ARG_UNUSED from arch_syscall_oops\n\nssf is being passed to xtensa_arch_kernel_oops() so there is\nno need to mark ssf with ARG_UNUSED."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: spi: stm32h7: Ignore spurious interrupts\n\nSupurious interrupts can be generated when the SPI device\nis disabled. Ignore them within the SPI IRQ handler.\n\nCo-authored-by: Georgij Cernysiov <geo.cgv@gmail.com> Please fix this issue.",
  "input": "Faulty tokenized code:\nname|spi\ndecl_stmt|;\nname|int\nname|err\ndecl_stmt|;\nname|err\noperator|=\nname|spi_stm32_get_err\nargument_list|(\nname|spi",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Some spurious interrupts are triggered when SPI is not enabled; ignore them. \t * Do it only when fifo is enabled to leave non-fifo functionality untouched for now \t */\n+if|if\n+condition|(\n+name|cfg\n+operator|->\n+name|fifo_enabled\n+condition|)\n+block|{\n+if|if\n+condition|(\n+operator|!\n+name|LL_SPI_IsEnabled\n+argument_list|(\n+name|spi\n+argument_list|)\n+condition|)\n+block|{\n+return|return;\n+block|}\n+block|}\nThe issue was with: drivers: spi: stm32h7: Ignore spurious interrupts\n\nSupurious interrupts can be generated when the SPI device\nis disabled. Ignore them within the SPI IRQ handler.\n\nCo-authored-by: Georgij Cernysiov <geo.cgv@gmail.com>"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: audio: fix bug in scan delegator sync\n\nIn the scan delegator when modifying the source we only want to\nsend a sync request to the upper layers if we are not yet synced,\nand not also on a state change\n\nNote that without this change the babblesim test for long writes\nwill fail\n\n\nScan del bugfix Please fix this issue.",
  "input": "Faulty tokenized code:\ncondition|(\nname|pa_sync\noperator|!=\nname|BT_BAP_BASS_PA_REQ_NO_SYNC\noperator|&&\noperator|(\nname|state_changed\noperator|||\nname|state\noperator|->\nname|pa_sync_state\noperator|!=\nname|BT_BAP_PA_STATE_SYNCED\noperator|)\ncondition|)\nblock|{\nspecifier|const\nname|int\nname|err",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|(\n-name|state_changed\n-operator|||\n-operator|)\nThe issue was with: Bluetooth: audio: fix bug in scan delegator sync\n\nIn the scan delegator when modifying the source we only want to\nsend a sync request to the upper layers if we are not yet synced,\nand not also on a state change\n\nNote that without this change the babblesim test for long writes\nwill fail\n\n\nScan del bugfix"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: audio: bap: long write\n\nIncrease the buffer size to allow for long writes Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/bluetooth/gatt.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/bluetooth/buf.h>\nend_include\nliteral|0\nargument_list|)\ndecl_stmt|;\nend_decl_stmt\n\nbegin_expr_stmt\nname|NET_BUF_SIMPLE_DEFINE_STATIC\nargument_list|(\nname|cp_buf\nargument_list|,\nname|CONFIG_BT_L2CAP_TX_MTU\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_function\nname|recv_state_handles\nindex|[\nname|idx\nindex|]\nexpr_stmt|;\nname|err\noperator|=\nname|bt_gatt_read\nargument_list|(\nname|conn",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/bluetooth/att.h>\n+end_include\n+\n+begin_define\n+DECL|macro|CP_BUF_SIZE\n+define|#\n+directive|define\n+name|CP_BUF_SIZE\n+value|MAX(CONFIG_BT_L2CAP_TX_MTU, BT_ATT_MAX_ATTRIBUTE_LEN)\n+end_define\n+\n-name|CONFIG_BT_L2CAP_TX_MTU\n+name|CP_BUF_SIZE\n+comment|/* we do not need a semaphore for the read_params long read I think */\nThe issue was with: Bluetooth: audio: bap: long write\n\nIncrease the buffer size to allow for long writes"
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: can: shell: verify can_get_core_clock() call count\n\nVerify the call count of can_get_core_clock() after executing \\\"can show\\\"\nshell subcommand. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|1\nargument_list|,\nliteral|\"get_state function not called\"\nargument_list|)\nexpr_stmt|;\nblock|}\nend_block\n\nbegin_macro\nDECL|function|ZTEST (can_shell,test_can_bitrate_missing_value)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|zassert_equal\n+argument_list|(\n+name|fake_can_get_core_clock_fake\n+operator|.\n+name|call_count\n+argument_list|,\n+literal|1\n+argument_list|,\n+literal|\"get_core_clock function not called\"\n+argument_list|)\n+expr_stmt|;\nThe issue was with: tests: drivers: can: shell: verify can_get_core_clock() call count\n\nVerify the call count of can_get_core_clock() after executing \\\"can show\\\"\nshell subcommand."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: eth_stm32_hal: Fix compilation warnings\n\nPromote clk_ratio_adj to double for internal calculations related to ratio\nto avoid compilation warnings related to implicit conversion from float\nto double. Please fix this issue.",
  "input": "Faulty tokenized code:\ncomment|/* No change needed */\nif|if\ncondition|(\nname|ratio\noperator|==\nliteral|1.0f\ncondition|)\nblock|{\nreturn|return\nliteral|0\nreturn|;\nname|irq_lock\nargument_list|()\nexpr_stmt|;\nname|ratio\noperator|*=\nname|eth_dev_data\noperator|->\nname|clk_ratio_adj\nexpr_stmt|;\ncomment|/* Limit possible ratio */\ncomment|/* Update addend register */\nname|addend_val\noperator|=\nname|UINT32_MAX\noperator|*\nname|eth_dev_data\noperator|->\nname|clk_ratio\noperator|*\nname|ratio",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|1.0f\n+literal|1.0L\n+operator|(\n+name|double\n+operator|)\n+operator|(\n+name|double\n+operator|)\nThe issue was with: drivers: eth_stm32_hal: Fix compilation warnings\n\nPromote clk_ratio_adj to double for internal calculations related to ratio\nto avoid compilation warnings related to implicit conversion from float\nto double."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: modem/simcom: Unused variable\n\nMake coverity happy and mark a variable as unused.\n\nFixes CID-248325\nFixes #58572 Please fix this issue.",
  "input": "Faulty tokenized code:\nmodifier|*\nname|res\nparameter_list|)\nblock|{\ncomment|/* No need to free static memory. */\nname|res\noperator|=\nname|NULL\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_comment",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|ARG_UNUSED\n+argument_list|(\n-operator|=\n-name|NULL\n+argument_list|)\nThe issue was with: drivers: modem/simcom: Unused variable\n\nMake coverity happy and mark a variable as unused.\n\nFixes CID-248325\nFixes #58572"
},{
  "instruction": "There is an issue in the following code. It relates to usb: host: use uint16_t for Language ID\n\nusbh_req_desc() truncates the descriptor id. This problem is most\nvisible with string descriptor requests, as only then can wIndex be\ngreater than 0xFF. In particular, this affects commonly used language\nIDs such as English (United States), which is 0x0409. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|usbh_req_desc (struct usb_device * const udev,const uint8_t type,const uint8_t index,const uint8_t id,const uint16_t len,struct net_buf * const buf)\nname|int\nname|usbh_req_desc\nparameter_list|(\nname|struct\nname|usb_device\nspecifier|const\nname|uint8_t\nname|index\nparameter_list|,\nspecifier|const\nname|uint8_t\nname|id\nparameter_list|,\nspecifier|const\nname|uint16_t\nname|len\nspecifier|const\nname|uint8_t\nname|index\nparameter_list|,\nspecifier|const\nname|uint8_t\nname|id\nparameter_list|,\nspecifier|const\nname|uint16_t\nname|len",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|usbh_req_desc (struct usb_device * const udev,const uint8_t type,const uint8_t index,const uint8_t id,const uint16_t len,struct net_buf * const buf)\n+DECL|function|usbh_req_desc (struct usb_device * const udev,const uint8_t type,const uint8_t index,const uint16_t id,const uint16_t len,struct net_buf * const buf)\n-name|uint8_t\n+name|uint16_t\n-name|uint8_t\n+name|uint16_t\nThe issue was with: usb: host: use uint16_t for Language ID\n\nusbh_req_desc() truncates the descriptor id. This problem is most\nvisible with string descriptor requests, as only then can wIndex be\ngreater than 0xFF. In particular, this affects commonly used language\nIDs such as English (United States), which is 0x0409."
},{
  "instruction": "There is an issue in the following code. It relates to tests: bluetooth: mesh: blob test bugfix\n\nAdded missing end marker to test instance Please fix this issue.",
  "input": "Faulty tokenized code:\nname|is_pull_mode\ndecl_stmt|;\nend_decl_stmt\n\nbegin_enum\nDECL|enum|__anon28a5ac4b0103\nspecifier|static\nenum|enum\nblock|{\nDECL|enumerator|BLOCK_GET_FAIL\nname|BLOCK_GET_FAIL\nname|prov\ndecl_stmt|;\nend_decl_stmt\n\nbegin_struct\nDECL|struct|__anon28a5ac4b0208\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|inputs\nname|struct\nargument_list|,\nname|stop\nargument_list|,\nliteral|\"Server stopping after reaching configured xfer phase\"\nargument_list|)\nblock|, }\ndecl_stmt|;\nend_decl_stmt\n\nbegin_function\nDECL|function|test_blob_pst_install (struct bst_test_list * tests)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon28a5ac4b0103\n+DECL|enum|__anon2912427a0103\n-DECL|struct|__anon28a5ac4b0208\n+DECL|struct|__anon2912427a0208\n-block|, }\n+block|,\n+name|BSTEST_END_MARKER\n+block|}\nThe issue was with: tests: bluetooth: mesh: blob test bugfix\n\nAdded missing end marker to test instance"
},{
  "instruction": "There is an issue in the following code. It relates to samples: posix: philosophers: fix off-by-one error\n\nThe number of forks should match the number of philophers, and\nthat is encoded via NUM_PHIL.\n\nChange the build assert to match. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|BUILD_ASSERT\nargument_list|(\nname|CONFIG_MAX_PTHREAD_COUNT\noperator|==\nname|CONFIG_MAX_PTHREAD_MUTEX_COUNT\noperator|-\nliteral|1\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_expr_stmt",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|-\n-literal|1\nThe issue was with: samples: posix: philosophers: fix off-by-one error\n\nThe number of forks should match the number of philophers, and\nthat is encoded via NUM_PHIL.\n\nChange the build assert to match."
},{
  "instruction": "There is an issue in the following code. It relates to samples: drivers: jesd216: support NXP FlexSPI NOR driver\n\nSupport NXP FlexSPI nor driver with jesd216 sample. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|FLASH_NODE\nvalue|DT_COMPAT_GET_ANY_STATUS_OKAY(nxp_s32_qspi_nor)\nend_define\n\nbegin_else\nelse|#\ndirective|else\nend_else\n\nname|uint8_t\nname|decl_nph\ninit|=\nliteral|5\ndecl_stmt|;\nDECL|union|__anon28ae91f9010a\nunion|union\nblock|{\nDECL|member|raw\nname|uint8_t\nname|raw",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_elif\n+elif|#\n+directive|elif\n+name|DT_HAS_COMPAT_STATUS_OKAY\n+argument_list|(\n+name|nxp_imx_flexspi_nor\n+argument_list|)\n+end_elif\n+\n+begin_define\n+DECL|macro|FLASH_NODE\n+define|#\n+directive|define\n+name|FLASH_NODE\n+value|DT_COMPAT_GET_ANY_STATUS_OKAY(nxp_imx_flexspi_nor)\n+end_define\n+\n-DECL|union|__anon28ae91f9010a\n+DECL|union|__anon27c87e04010a\nThe issue was with: samples: drivers: jesd216: support NXP FlexSPI NOR driver\n\nSupport NXP FlexSPI nor driver with jesd216 sample."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: dma: atcdmac300: Update driver for bug 68129\n\n1. Remove redundant include, <soc.h> is not needed.\n2. Fix some wrong MACRO defined Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_define\nDECL|macro|DMA_CH_CTRL_SBSIZE_MASK\ndefine|#\ndirective|define\nname|DMA_CH_CTRL_SBSIZE_MASK\nvalue|BIT(24)\nend_define\n\nbegin_define\nDECL|macro|DMA_CH_CTRL_SBSIZE (n)\ndefine|#\nbegin_define\nDECL|macro|DMA_CH_CTRL_DMODE_HANDSHAKE\ndefine|#\ndirective|define\nname|DMA_CH_CTRL_DMODE_HANDSHAKE\nvalue|BIT(17)\nend_define\n\nbegin_define\nDECL|macro|DMA_CH_CTRL_SRCADDRCTRL_MASK\ndefine|#\nbegin_define\nDECL|macro|DMA_CH_CTRL_SRCADDR_INC\ndefine|#\ndirective|define\nname|DMA_CH_CTRL_SRCADDR_INC\nvalue|FIELD_PREP(DMA_CH_CTRL_DWIDTH_MASK, (0))\nend_define\n\nbegin_define\nDECL|macro|DMA_CH_CTRL_SRCADDR_DEC\ndefine|#\ndirective|define\nname|DMA_CH_CTRL_SRCADDR_DEC\nvalue|FIELD_PREP(DMA_CH_CTRL_DWIDTH_MASK, (1))\nend_define\n\nbegin_define\nDECL|macro|DMA_CH_CTRL_SRCADDR_FIX\ndefine|#\ndirective|define\nname|DMA_CH_CTRL_SRCADDR_FIX\nvalue|FIELD_PREP(DMA_CH_CTRL_DWIDTH_MASK, (2))\nend_define\n\nbegin_define\nDECL|macro|DMA_CH_CTRL_DSTADDRCTRL_MASK\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|BIT(24)\n+value|GENMASK(27, 24)\n-value|BIT(17)\n+value|BIT(16)\n-value|FIELD_PREP(DMA_CH_CTRL_DWIDTH_MASK, (0))\n+value|FIELD_PREP(DMA_CH_CTRL_SRCADDRCTRL_MASK, (0))\n-value|FIELD_PREP(DMA_CH_CTRL_DWIDTH_MASK, (1))\n+value|FIELD_PREP(DMA_CH_CTRL_SRCADDRCTRL_MASK, (1))\n-value|FIELD_PREP(DMA_CH_CTRL_DWIDTH_MASK, (2))\n+value|FIELD_PREP(DMA_CH_CTRL_SRCADDRCTRL_MASK, (2))\nThe issue was with: drivers: dma: atcdmac300: Update driver for bug 68129\n\n1. Remove redundant include, <soc.h> is not needed.\n2. Fix some wrong MACRO defined"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: BAP: Update log for unicast iso recv without endpoint\n\nSince we always set up the ISO data path for endpoints in both\ndirections (due to limitations in the ISO API), we can actually\nreceive valid (empty) SDUs on a CIS in a direction that has not\nbeen configured.\n\nThis is not the ideal solution, but prevents unncessary LOG_ERR.\nThe ideal solution is to modify the ISO API to provide the\nflexibility that BAP needs w.r.t. ISO data paths, but that is\na larger change for later. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|)\noperator|!=\nliteral|0\ncondition|)\nblock|{\nname|LOG_ERR\nargument_list|(\nliteral|\"iso %p not bound with ep\"\nargument_list|,\nname|chan\nargument_list|)\nexpr_stmt|;\nblock|}\ndecl_stmt|;\nDECL|member|busy\nname|bool\nname|busy\ndecl_stmt|;\nDECL|union|__anon2b5dc1a6010a\nunion|union\nblock|{\nDECL|member|read_params\nname|struct\nname|bt_gatt_read_params\noperator|)\noperator|!=\nliteral|0\ncondition|)\nblock|{\nname|LOG_ERR\nargument_list|(\nliteral|\"iso %p not bound with ep\"\nargument_list|,\nname|chan\nargument_list|)\nexpr_stmt|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|LOG_ERR\n+name|LOG_DBG\n-literal|\"iso %p not bound with ep\"\n+literal|\"Valid ISO packet of len %zu received for iso %p not bound with ep\"\n+argument_list|,\n+name|net_buf_frags_len\n+argument_list|(\n+name|buf\n+argument_list|)\n-DECL|union|__anon2b5dc1a6010a\n+DECL|union|__anon2c304327010a\n-name|LOG_ERR\n+name|LOG_DBG\n-literal|\"iso %p not bound with ep\"\n+literal|\"Valid ISO packet of len %zu received for iso %p not bound with ep\"\n+argument_list|,\n+name|net_buf_frags_len\n+argument_list|(\n+name|buf\n+argument_list|)\nThe issue was with: Bluetooth: BAP: Update log for unicast iso recv without endpoint\n\nSince we always set up the ISO data path for endpoints in both\ndirections (due to limitations in the ISO API), we can actually\nreceive valid (empty) SDUs on a CIS in a direction that has not\nbeen configured.\n\nThis is not the ideal solution, but prevents unncessary LOG_ERR.\nThe ideal solution is to modify the ISO API to provide the\nflexibility that BAP needs w.r.t. ISO data paths, but that is\na larger change for later."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: interrupt_controller: changes in shared irq\n\nUpdated the shared IRQ handler function in the shared interrupt controller\ndrivers to include support for the 'irq_number' parameter. When a single\ndriver manages multiple shared IRQs, it becomes challenging to determine\nwhich IRQ line is invoking the handler. Therefore, I've introduced an\noption to share the IRQ number to address this issue. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright (c) 2015 Intel Corporation.  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_define\nDECL|macro|DT_DRV_COMPAT\ndefine|#\nindex|[\nname|i\nindex|]\noperator|.\nname|isr_dev\nargument_list|)\nexpr_stmt|;\nblock|}\nblock|}\nblock|}\nbegin_comment\ncomment|/* shared_irq - Shared interrupt driver */\nend_comment\n\nbegin_comment\ncomment|/*  * Copyright (c) 2015 Intel corporation  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_ifndef\nifndef|#\ndirective|ifndef\nspecifier|const\nname|struct\nname|device\nmodifier|*\nname|dev\nparameter_list|)\nfunction_decl|;\ncomment|/* driver API definition */\nDECL|typedef|shared_irq_register_t\ntypedef|typedef",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/*  * Copyright (c) 2015 Intel Corporation.  *  * SPDX-License-Identifier: Apache-2.0  */\n+comment|/*  * Copyright (c) 2015 - 2023 Intel Corporation.  *  * SPDX-License-Identifier: Apache-2.0  */\n+argument_list|,\n+name|config\n+operator|->\n+name|irq_num\n-comment|/*  * Copyright (c) 2015 Intel corporation  *  * SPDX-License-Identifier: Apache-2.0  */\n+comment|/*  * Copyright (c) 2015 - 2023 Intel corporation  *  * SPDX-License-Identifier: Apache-2.0  */\n+parameter_list|,\n+name|unsigned\n+name|int\n+name|irq_number\nThe issue was with: drivers: interrupt_controller: changes in shared irq\n\nUpdated the shared IRQ handler function in the shared interrupt controller\ndrivers to include support for the 'irq_number' parameter. When a single\ndriver manages multiple shared IRQs, it becomes challenging to determine\nwhich IRQ line is invoking the handler. Therefore, I've introduced an\noption to share the IRQ number to address this issue."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: dma: andes: remove soc.h inclusion\n\nNot needed or present soc.h Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/drivers/dma.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<soc.h>\nend_include\n\nbegin_define\nDECL|macro|DT_DRV_COMPAT\ndefine|#\ndirective|define\nname|DT_DRV_COMPAT",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_include\n-include|#\n-directive|include\n-file|<soc.h>\n-end_include\n-\nThe issue was with: drivers: dma: andes: remove soc.h inclusion\n\nNot needed or present soc.h"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: Fix coverity issue 340852\n\nFix coverity issue 340852, Uninitialized scalar variable. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/* Memory pool to store IQ reports data */\nend_comment\n\nbegin_struct\nDECL|struct|__anon29aa49a80108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|free\nname|void\noperator|=\nname|df_cfg\noperator|->\nname|cte_length\nexpr_stmt|;\ncomment|/* Note: ULL_ADV_PDU_EXTRA_DATA_ALLOC_ALWAYS is just information that extra_data \t * is required in case of this ull_adv_sync_pdu_alloc. \t */\nname|err\noperator|=\nname|ull_adv_sync_pdu_alloc\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon29aa49a80108\n+DECL|struct|__anon2b8b203a0108\n+name|cte_info\n+operator|.\n+name|rfu\n+operator|=\n+literal|0U\n+expr_stmt|;\nThe issue was with: Bluetooth: Controller: Fix coverity issue 340852\n\nFix coverity issue 340852, Uninitialized scalar variable."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Mesh: fix SRPL always accepting sol pdus with sseq 0\n\nUpdated logic in srpl_entry_save. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|entry\noperator|->\nname|sseq\noperator|>=\nname|sseq\noperator|&&\nname|sseq\noperator|!=\nliteral|0\ncondition|)\nblock|{\nname|LOG_WRN\nargument_list|(\nliteral|\"Higher or equal SSEQ already saved for this SSRC\"",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|&&\n-name|sseq\n-operator|!=\n-literal|0\nThe issue was with: Bluetooth: Mesh: fix SRPL always accepting sol pdus with sseq 0\n\nUpdated logic in srpl_entry_save."
},{
  "instruction": "There is an issue in the following code. It relates to net: gptp: Fix double converted byte order of BMCA info steps_removed\n\nFixes #68320 Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|gm_priority\noperator|.\nname|steps_removed\noperator|=\nname|htons\nargument_list|(\nname|ntohs\nargument_list|(\nname|best_vector\noperator|->\nname|steps_removed\nargument_list|)\noperator|+\nliteral|1\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\noperator|&\nname|global_ds",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|htons\n-argument_list|(\n-argument_list|)\nThe issue was with: net: gptp: Fix double converted byte order of BMCA info steps_removed\n\nFixes #68320"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: Fix RXFIFO_DEFINE to reduce FLASH usage\n\nFix RXFIFO_DEFINE to reduce FLASH usage by moving the pool\noutside the struct that is static initialized. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|_count\nparameter_list|,\nname|_extra_links\nparameter_list|)\ndefine|\\\nvalue|MFIFO_DEFINE(_name, sizeof(void *), _count); \\ \t\\ \tstatic struct { \\ \t\tvoid *free; \\ \t\tuint16_t size; \\ \t\tuint8_t count; \\ \t\tuint8_t extra_links; \\ \t\tuint8_t pool[MROUND(_size) * (_count)]; \\ \t} mem_##_name = { .size = MROUND(_size), .count = _count, \\ \t\t\t  .extra_links = _extra_links }; \\ \t\\ \tstatic struct { \\ \t\tvoid *free; \\ \t\tuint8_t pool[sizeof(memq_link_t) * \\ \t\t     (_count + _extra_links)]; \\ \t} mem_link_##_name\nend_define\n\nbegin_comment\ncomment|/**  * @brief   Initializes MFIFO and pools  * @details This makes the MFIFO empty and will subsequently need  *          RXFIFO_ALLOC. Memory pools are initialized.  */\nend_comment\nname|RXFIFO_INIT\nparameter_list|(\nname|_name\nparameter_list|)\ndefine|\\\nvalue|MFIFO_INIT(_name); \\ \tmem_init(mem_##_name.pool, mem_##_name.size, \\ \t\t mem_##_name.count,&mem_##_name.free); \\ \t\\ \tmem_init(mem_link_##_name.pool, sizeof(memq_link_t), mem_##_name.count + \\ \t\t mem_##_name.extra_links,&mem_link_##_name.free)\nend_define\n\nbegin_comment\ncomment|/**  * @brief   Allocate FIFO elements with backing  * @details This function allocates up to<_count> number of MFIFO elements by  *          enqueuing pointers to memory elements with associated memq links.  */\nend_comment\nname|_name\nparameter_list|,\nname|_count\nparameter_list|)\ndefine|\\\nvalue|ull_rxfifo_alloc(mfifo_##_name.s, mfifo_##_name.n, mfifo_##_name.f, \\&mfifo_##_name.l, mfifo_##_name.m,&mem_##_name.free, \\&mem_link_##_name.free, _count)\nend_define\n\nbegin_comment\ncomment|/**  * @brief Initialize and allocate MFIFO and pools  */\nend_comment\nname|ISO_TEST_TX_BUFFER_SIZE\nvalue|32U\nend_define\n\nbegin_struct\nDECL|struct|__anon288ca37f0108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|free\nname|void\nname|mem_iso_tx\nstruct|;\nend_struct\n\nbegin_struct\nDECL|struct|__anon288ca37f0208\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|free\nname|void\nname|mem_release\nargument_list|(\nname|rx\nargument_list|,\noperator|&\nname|mem_iso_rx\noperator|.\nname|free\nargument_list|)\nexpr_stmt|;\nname|RXFIFO_ALLOC\nname|mem_release\nargument_list|(\nname|rx_free\nargument_list|,\noperator|&\nname|mem_iso_rx\noperator|.\nname|free\nargument_list|)\nexpr_stmt|;\nbreak|break;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|MFIFO_DEFINE(_name, sizeof(void *), _count); \\ \t\\ \tstatic struct { \\ \t\tvoid *free; \\ \t\tuint16_t size; \\ \t\tuint8_t count; \\ \t\tuint8_t extra_links; \\ \t\tuint8_t pool[MROUND(_size) * (_count)]; \\ \t} mem_##_name = { .size = MROUND(_size), .count = _count, \\ \t\t\t  .extra_links = _extra_links }; \\ \t\\ \tstatic struct { \\ \t\tvoid *free; \\ \t\tuint8_t pool[sizeof(memq_link_t) * \\ \t\t     (_count + _extra_links)]; \\ \t} mem_link_##_name\n+value|MFIFO_DEFINE(_name, sizeof(void *), _count); \\ \t\\ \tstatic const struct { \\ \t\tuint16_t size; \\ \t\tuint8_t count; \\ \t\tuint8_t extra_links; \\ \t} mem_##_name = { .size = MROUND(_size), .count = _count, \\ \t\t\t  .extra_links = _extra_links }; \\ \t\\ \tstatic struct { \\ \t\tvoid *free; \\ \t\tuint8_t pool[MROUND(_size) * (_count)]; \\ \t} mem_pool_##_name; \\ \t\\ \tstatic struct { \\ \t\tvoid *free; \\ \t\tuint8_t pool[sizeof(memq_link_t) * (_count + _extra_links)]; \\ \t} mem_link_##_name\n-value|MFIFO_INIT(_name); \\ \tmem_init(mem_##_name.pool, mem_##_name.size, \\ \t\t mem_##_name.count,&mem_##_name.free); \\ \t\\ \tmem_init(mem_link_##_name.pool, sizeof(memq_link_t), mem_##_name.count + \\ \t\t mem_##_name.extra_links,&mem_link_##_name.free)\n+value|MFIFO_INIT(_name); \\ \tmem_init(mem_pool_##_name.pool, mem_##_name.size, \\ \t\t mem_##_name.count,&mem_pool_##_name.free); \\ \t\\ \tmem_init(mem_link_##_name.pool, sizeof(memq_link_t), mem_##_name.count + \\ \t\t mem_##_name.extra_links,&mem_link_##_name.free)\n-value|ull_rxfifo_alloc(mfifo_##_name.s, mfifo_##_name.n, mfifo_##_name.f, \\&mfifo_##_name.l, mfifo_##_name.m,&mem_##_name.free, \\&mem_link_##_name.free, _count)\n+value|ull_rxfifo_alloc(mfifo_##_name.s, mfifo_##_name.n, mfifo_##_name.f, \\&mfifo_##_name.l, mfifo_##_name.m, \\&mem_pool_##_name.free,&mem_link_##_name.free, \\ \t\t\t _count)\n-DECL|struct|__anon288ca37f0108\n+DECL|struct|__anon27b8ed0c0108\n-DECL|struct|__anon288ca37f0208\n+DECL|struct|__anon27b8ed0c0208\n-name|mem_iso_rx\n+name|mem_pool_iso_rx\n-name|mem_iso_rx\n+name|mem_pool_iso_rx\nThe issue was with: Bluetooth: Controller: Fix RXFIFO_DEFINE to reduce FLASH usage\n\nFix RXFIFO_DEFINE to reduce FLASH usage by moving the pool\noutside the struct that is static initialized."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: BAP: client: Add support for source ASEs disconnects\n\nWhen the CIS of a source ASE disconnects, the server shall put\nit into the QoS Configured state, which is not really part of the\nstate machine for source ASEs, but more like a hidden bonus state\nchange.\n\nThe state machine handler in the unicast client has been updated\nto support this state change. Please fix this issue.",
  "input": "Faulty tokenized code:\ndecl_stmt|;\nDECL|member|busy\nname|bool\nname|busy\ndecl_stmt|;\nDECL|union|__anon28eb9378010a\nunion|union\nblock|{\nDECL|member|read_params\nname|struct\nname|bt_gatt_read_params\ncase|:\ncomment|/* or 0x02 (QoS Configured) */\ncase|case\nname|BT_BAP_EP_STATE_QOS_CONFIGURED\ncase|:\ncomment|/* or 0x05 (Disabling) */\ncase|case\nname|BT_BAP_EP_STATE_DISABLING\ncase|:\nbreak|break;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon28eb9378010a\n+DECL|union|__anon2998412b010a\n+comment|/* or 0x04 (Streaming) if there is a disconnect */\n+case|case\n+name|BT_BAP_EP_STATE_STREAMING\n+case|:\nThe issue was with: Bluetooth: BAP: client: Add support for source ASEs disconnects\n\nWhen the CIS of a source ASE disconnects, the server shall put\nit into the QoS Configured state, which is not really part of the\nstate machine for source ASEs, but more like a hidden bonus state\nchange.\n\nThe state machine handler in the unicast client has been updated\nto support this state change."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: add missed binding for xen dom0 consoleio driver\n\nAdd missed binding and appropriate changes for Xen Dom0/Dom0less\nUART driver. Please fix this issue.",
  "input": "Faulty tokenized code:\n\t  for Zephyr as unprivileged domain.\n\nconfig UART_XEN_HVC_CONSOLEIO\n\tbool \"Xen hypervisor consoleio UART driver\"\n\tselect SERIAL_HAS_DRIVER\n\tdepends on XEN_DOM0 || XEN_DOM0LESS\n\tdefault y\n\thelp\n\t  Enable Xen hypervisor console driver. Used for Zephyr as\n\t  privileged domain (Dom0) or for Zephyr DomU in Dom0less\n\t  configuration. Dom0less configuration does not have\ninclude|#\ndirective|include\nfile|<zephyr/kernel.h>\nend_include\n\nbegin_function\nDECL|function|xen_consoleio_poll_in (const struct device * dev,unsigned char * c)\nspecifier|static\nname|int\nname|xen_consoleio_poll_in\ndecl_stmt|;\nend_decl_stmt\n\nbegin_function\nDECL|function|xen_consoleio_init (const struct device * dev)\nname|int\nname|xen_consoleio_init\nparameter_list|(\nspecifier|const\nname|struct\nreturn|;\nblock|}\nend_function\n\nbegin_expr_stmt\nname|DEVICE_DT_DEFINE\nargument_list|(\nname|DT_NODELABEL\nargument_list|(\nname|xen_consoleio_hvc\nargument_list|)\nargument_list|,\nname|xen_consoleio_init\nargument_list|,\nname|NULL\nargument_list|,\nnew file mode 100644\n\tpsci {\n\t\tmethod = \"hvc\";\n\t};\n\n\txen_consoleio_hvc: hvc {\n\t\tcompatible = \"xen,uart_hvc\";\n\t\tstatus = \"okay\";\n\t};\n};",
  "result": "I corrected the issue in the code by changing the following tokens:\n-\tdepends on XEN_DOM0 || XEN_DOM0LESS\n+\tdepends on DT_HAS_XEN_HVC_CONSOLEIO_ENABLED && (XEN_DOM0 || XEN_DOM0LESS)\n+begin_define\n+DECL|macro|DT_DRV_COMPAT\n+define|#\n+directive|define\n+name|DT_DRV_COMPAT\n+value|xen_hvc_consoleio\n+end_define\n+\n+specifier|static\n-name|DEVICE_DT_DEFINE\n-argument_list|(\n-name|DT_NODELABEL\n+name|DEVICE_DT_INST_DEFINE\n-name|xen_consoleio_hvc\n-argument_list|)\n+literal|0\n+description: Xen Dom0/Dom0less Platform HVC ConsoleIO\n+\n+compatible: \"xen,hvc-consoleio\"\n+\n+include: uart-controller.yaml\n-\t\tcompatible = \"xen,uart_hvc\";\n+\t\tcompatible = \"xen,hvc-consoleio\";\nThe issue was with: drivers: serial: add missed binding for xen dom0 consoleio driver\n\nAdd missed binding and appropriate changes for Xen Dom0/Dom0less\nUART driver."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: clock_control: stm32wba: remove disabling of backup access\n\nDisabling Backup access prevents Suspend to RAM to work. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|LL_RCC_LSE_IsPropagationReady\nargument_list|()\ncondition|)\nblock|{\nblock|}\nname|LL_PWR_DisableBkUpAccess\nargument_list|()\nexpr_stmt|;\nblock|}\nblock|}\nend_function\n\nbegin_comment",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|LL_PWR_DisableBkUpAccess\n-argument_list|()\n-expr_stmt|;\nThe issue was with: drivers: clock_control: stm32wba: remove disabling of backup access\n\nDisabling Backup access prevents Suspend to RAM to work."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: spi: ifx_cat1: drop non-existing DT properties\n\nIt looks like driver references quite a few non-existing properties in\ndevicetree (see dts/bindings/spi/infineon,cat1-spi.yml). This mistake\nwas hidden because of DT_INST_PROP_OR(), which expands to the default if\nthe property is not present. However, after\n62e4a6a86a8576a6ef28cb73811450589fd2a744 [formerly 260fc89643fd64b74f9983065867d8b368f81a0d], the issue became visible\nbecause sme DT_INST_PROP_OR() were changed to DT_INST_PROP().\n\nNote that only fields not initialized to 0 (or false) have been kept. Please fix this issue.",
  "input": "Faulty tokenized code:\ncomment|/* overwrite by cfg  */\nvalue|\\ \t\t\t .txDataWidth = 8,\ncomment|/* overwrite by cfg  */\nvalue|\\ \t\t\t .enableMsbFirst = true,\ncomment|/* overwrite by cfg  */\nvalue|\\ \t\t\t .subMode = DT_INST_PROP_OR(n, sub_mode, CY_SCB_SPI_MOTOROLA),             \\ \t\t\t .oversample =                                                             \\ \t\t\t\t DT_INST_PROP_OR(n, oversample, IFX_CAT1_SPI_DEFAULT_OVERSAMPLE),  \\ \t\t\t .enableFreeRunSclk = DT_INST_PROP(n, enable_free_run_sclk),               \\ \t\t\t .enableInputFilter = DT_INST_PROP(n, enable_input_filter),                \\ \t\t\t .enableMisoLateSample =                                                   \\ \t\t\t\t DT_INST_PROP_OR(n, enable_miso_late_sample, true),                \\ \t\t\t .enableTransferSeperation =                                               \\ \t\t\t\t DT_INST_PROP(n, enable_transfer_seperation),                      \\ \t\t\t .enableWakeFromSleep = DT_INST_PROP(n, enableWakeFromSleep),              \\ \t\t\t .ssPolarity = DT_INST_PROP_OR(n, ss_polarity, CY_SCB_SPI_ACTIVE_LOW),     \\ \t\t\t .rxFifoTriggerLevel = DT_INST_PROP_OR(n, rx_fifo_trigger_level, 0),       \\ \t\t\t .rxFifoIntEnableMask = DT_INST_PROP_OR(n, rx_fifo_int_enable_mask, 0),    \\ \t\t\t .txFifoTriggerLevel = DT_INST_PROP_OR(n, tx_fifo_trigger_level, 0),       \\ \t\t\t .txFifoIntEnableMask = DT_INST_PROP_OR(n, tx_fifo_int_enable_mask, 0),    \\ \t\t\t .masterSlaveIntEnableMask =                                               \\ \t\t\t\t DT_INST_PROP_OR(n, master_slave_int_enable_mask, 0)},             \\                                                                                                    \\ \t\t.irq_priority = DT_INST_IRQ(n, priority),                                          \\ \t};                                                                                         \\ \tDEVICE_DT_INST_DEFINE(n,&ifx_cat1_spi_init, NULL,&spi_cat1_data_##n,                     \\&spi_cat1_config_##n, POST_KERNEL,                                   \\ \t\t\t      CONFIG_KERNEL_INIT_PRIORITY_DEVICE,&ifx_cat1_spi_api);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|\\ \t\t\t .subMode = DT_INST_PROP_OR(n, sub_mode, CY_SCB_SPI_MOTOROLA),             \\ \t\t\t .oversample =                                                             \\ \t\t\t\t DT_INST_PROP_OR(n, oversample, IFX_CAT1_SPI_DEFAULT_OVERSAMPLE),  \\ \t\t\t .enableFreeRunSclk = DT_INST_PROP(n, enable_free_run_sclk),               \\ \t\t\t .enableInputFilter = DT_INST_PROP(n, enable_input_filter),                \\ \t\t\t .enableMisoLateSample =                                                   \\ \t\t\t\t DT_INST_PROP_OR(n, enable_miso_late_sample, true),                \\ \t\t\t .enableTransferSeperation =                                               \\ \t\t\t\t DT_INST_PROP(n, enable_transfer_seperation),                      \\ \t\t\t .enableWakeFromSleep = DT_INST_PROP(n, enableWakeFromSleep),              \\ \t\t\t .ssPolarity = DT_INST_PROP_OR(n, ss_polarity, CY_SCB_SPI_ACTIVE_LOW),     \\ \t\t\t .rxFifoTriggerLevel = DT_INST_PROP_OR(n, rx_fifo_trigger_level, 0),       \\ \t\t\t .rxFifoIntEnableMask = DT_INST_PROP_OR(n, rx_fifo_int_enable_mask, 0),    \\ \t\t\t .txFifoTriggerLevel = DT_INST_PROP_OR(n, tx_fifo_trigger_level, 0),       \\ \t\t\t .txFifoIntEnableMask = DT_INST_PROP_OR(n, tx_fifo_int_enable_mask, 0),    \\ \t\t\t .masterSlaveIntEnableMask =                                               \\ \t\t\t\t DT_INST_PROP_OR(n, master_slave_int_enable_mask, 0)},             \\                                                                                                    \\ \t\t.irq_priority = DT_INST_IRQ(n, priority),                                          \\ \t};                                                                                         \\ \tDEVICE_DT_INST_DEFINE(n,&ifx_cat1_spi_init, NULL,&spi_cat1_data_##n,                     \\&spi_cat1_config_##n, POST_KERNEL,                                   \\ \t\t\t      CONFIG_KERNEL_INIT_PRIORITY_DEVICE,&ifx_cat1_spi_api);\n+value|\\ \t\t\t .subMode = CY_SCB_SPI_MOTOROLA,                                           \\ \t\t\t .oversample = IFX_CAT1_SPI_DEFAULT_OVERSAMPLE,                            \\ \t\t\t .enableMisoLateSample = true,                                             \\ \t\t\t .ssPolarity = CY_SCB_SPI_ACTIVE_LOW,                                      \\ \t\t},                                                                                 \\ \t\t.irq_priority = DT_INST_IRQ(n, priority),                                          \\ \t};                                                                                         \\ \tDEVICE_DT_INST_DEFINE(n,&ifx_cat1_spi_init, NULL,&spi_cat1_data_##n,                     \\&spi_cat1_config_##n, POST_KERNEL,                                   \\ \t\t\t      CONFIG_KERNEL_INIT_PRIORITY_DEVICE,&ifx_cat1_spi_api);\nThe issue was with: drivers: spi: ifx_cat1: drop non-existing DT properties\n\nIt looks like driver references quite a few non-existing properties in\ndevicetree (see dts/bindings/spi/infineon,cat1-spi.yml). This mistake\nwas hidden because of DT_INST_PROP_OR(), which expands to the default if\nthe property is not present. However, after\n62e4a6a86a8576a6ef28cb73811450589fd2a744 [formerly 260fc89643fd64b74f9983065867d8b368f81a0d], the issue became visible\nbecause sme DT_INST_PROP_OR() were changed to DT_INST_PROP().\n\nNote that only fields not initialized to 0 (or false) have been kept."
},{
  "instruction": "There is an issue in the following code. It relates to intel_adsp/cavs: power: Fix INTLEVEL value\n\nIn pm_state_set we can't just call k_cpu_idle() because\nthis will clear out PS.INTLEVEL. Use k_cpu_atomic_idle instead\nsince Zephyr's expect interruptions to be locked after pm_state_set. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\nname|k_cpu_idle\nargument_list|()\nexpr_stmt|;\nblock|}\nblock|}\nelse|else\nblock|{\nargument_list|,\nliteral|\"invalid argument - unsupported power state\"\nargument_list|)\nexpr_stmt|;\nblock|}\nblock|}\nend_function\n\nbegin_endif\nendif|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|k_cpu_idle\n+name|k_cpu_atomic_idle\n+argument_list|(\n+name|arch_irq_lock\n+argument_list|)\n+comment|/** \t * We don't have the key used to lock interruptions here. \t * Just set PS.INTLEVEL to 0. \t */\n+asm|__asm__\n+specifier|volatile\n+asm|(\"rsil a2, 0\");\nThe issue was with: intel_adsp/cavs: power: Fix INTLEVEL value\n\nIn pm_state_set we can't just call k_cpu_idle() because\nthis will clear out PS.INTLEVEL. Use k_cpu_atomic_idle instead\nsince Zephyr's expect interruptions to be locked after pm_state_set."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: adc: stm32: do not disable adc after measurement\n\nDo not disable the ADC after the end of the measurement to avoid systematic\nenabling which is time-consuming in case the configuration is unchanged. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ARG_UNUSED\nargument_list|(\nname|status\nargument_list|)\nexpr_stmt|;\nname|adc_stm32_disable\nargument_list|(\nname|adc\nargument_list|)\nexpr_stmt|;\ncomment|/* Reset acquisition time used for the sequence */\nname|data\noperator|->\nname|acq_time_index\nindex|[\nname|adc\nargument_list|,\nliteral|0\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\ncomment|/* CONFIG_SOC_SERIES_STM32H7X || CONFIG_SOC_SERIES_STM32U5X */\nblock|}\nDECL|function|adc_stm32_read (const struct device * dev,const struct adc_sequence * sequence)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|adc_stm32_disable\n-argument_list|(\n-name|adc\n-argument_list|)\n-expr_stmt|;\n+else|#\n+directive|else\n+name|ARG_UNUSED\n+argument_list|(\n+name|adc\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: adc: stm32: do not disable adc after measurement\n\nDo not disable the ADC after the end of the measurement to avoid systematic\nenabling which is time-consuming in case the configuration is unchanged."
},{
  "instruction": "There is an issue in the following code. It relates to flash: correct userspace flash_handlers\n\nfixes #68248 Please fix this issue.",
  "input": "Faulty tokenized code:\nend_function\n\nbegin_include\ninclude|#\ndirective|include\nfile|<syscalls/flash_sfdp_read.c>\nend_include\n\nbegin_function\nDECL|function|z_vrfy_flash_read_jedec_id (const struct device * dev,uint8_t * id)\nspecifier|static\nend_function\n\nbegin_include\ninclude|#\ndirective|include\nfile|<syscalls/flash_sfdp_jedec_id.c>\nend_include\n\nbegin_endif\nendif|#\ndirective|endif",
  "result": "I corrected the issue in the code by changing the following tokens:\n-file|<syscalls/flash_sfdp_read.c>\n+file|<syscalls/flash_sfdp_read_mrsh.c>\n-file|<syscalls/flash_sfdp_jedec_id.c>\n+file|<syscalls/flash_read_jedec_id_mrsh.c>\nThe issue was with: flash: correct userspace flash_handlers\n\nfixes #68248"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Audio: Change samples and shell to use sinf\n\nChange the samples and shell to use sinf instead of sin,\nas that return the expect float data type, instead of\na double. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nspecifier|const\nname|float\nname|sample\ninit|=\nname|sin\nargument_list|(\nname|i\noperator|*\nname|step\nargument_list|)\nblock|{\nspecifier|const\nname|float\nname|sample\ninit|=\nname|sin\nargument_list|(\nname|i\noperator|*\nname|step\nargument_list|)\nblock|{\nspecifier|const\nname|float\nname|sample\ninit|=\nname|sin\nargument_list|(\nname|i\noperator|*\nname|step\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|sin\n+name|sinf\n-name|sin\n+name|sinf\n-name|sin\n+name|sinf\nThe issue was with: Bluetooth: Audio: Change samples and shell to use sinf\n\nChange the samples and shell to use sinf instead of sin,\nas that return the expect float data type, instead of\na double."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: mcp23xxx: explain more common causes for spurious interrupts\n\nInterrupt handling in this chip is broken beyond repair, anyone unfortunate\nenough to have to use it will probably come across this error and wonder\nwhat's up. Please fix this issue.",
  "input": "Faulty tokenized code:\ncondition|(\noperator|!\nname|intf\ncondition|)\nblock|{\ncomment|/* Probable cause: REG_GPIO was read from somewhere else before the interrupt \t\t * handler had a chance to run \t\t */\nname|LOG_ERR\nargument_list|(\nliteral|\"Spurious interrupt\"\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* Probable cause: REG_GPIO was read from somewhere else before the interrupt \t\t * handler had a chance to run \t\t */\n+comment|/* Probable causes: \t\t * - REG_GPIO was read from somewhere else before the interrupt handler had a chance \t\t *   to run \t\t * - Even though the datasheet says differently, reading INTCAP while a level \t\t *   interrupt is active briefly (~2ns) causes the interrupt line to go high and \t\t *   low again. This causes a second ISR to be scheduled, which then won't \t\t *   find any active interrupts if the callback has disabled the level interrupt. \t\t */\nThe issue was with: drivers: mcp23xxx: explain more common causes for spurious interrupts\n\nInterrupt handling in this chip is broken beyond repair, anyone unfortunate\nenough to have to use it will probably come across this error and wonder\nwhat's up."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: use DT_INST_PROP over DT_INST_PROP_OR if possible\n\nIt might happens that DT(_INST)_PROP_OR is used with boolean properties.\nFor instance:\n\n\t.single_wire = DT_INST_PROP_OR(index, single_wire, false),\t\\\n\t.tx_rx_swap = DT_INST_PROP_OR(index, tx_rx_swap, false),\t\\\n\nThis is not required as boolean properties are generated with false\nvalue when not present, so the _OR macro extension is superflous\nand the above code can be replaced by:\n\n\t.single_wire = DT_INST_PROP(index, single_wire),\t\t\\\n\t.tx_rx_swap = DT_INST_PROP(index, tx_rx_swap),\t\t\t\\ Please fix this issue.",
  "input": "Faulty tokenized code:\nname|SAI_INIT\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\ \t\t\t\t\t\t\t\t\t\t\\\nvalue|BUILD_ASSERT(SAI_FIFO_DEPTH(inst)> 0&&\t\t\t\t\t\\ \t     SAI_FIFO_DEPTH(inst)<= _SAI_FIFO_DEPTH(inst),\t\t\t\\ \t     \"invalid FIFO depth\");\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(SAI_RX_FIFO_WATERMARK(inst)> 0&&\t\t\t\t\t\\ \t     SAI_RX_FIFO_WATERMARK(inst)<= _SAI_FIFO_DEPTH(inst),\t\t\\ \t     \"invalid RX FIFO watermark\");\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(SAI_TX_FIFO_WATERMARK(inst)> 0&&\t\t\t\t\t\\ \t     SAI_TX_FIFO_WATERMARK(inst)<= _SAI_FIFO_DEPTH(inst),\t\t\\ \t     \"invalid TX FIFO watermark\");\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(IS_ENABLED(CONFIG_SAI_HAS_MCLK_CONFIG_OPTION) ||\t\t\t\\ \t     !DT_INST_PROP(inst, mclk_is_output),\t\t\t\t\\ \t     \"SAI doesn't support MCLK config but mclk_is_output is specified\");\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(SAI_TX_SYNC_MODE(inst) != SAI_RX_SYNC_MODE(inst) ||\t\t\\ \t     SAI_TX_SYNC_MODE(inst) != kSAI_ModeSync,\t\t\t\t\\ \t     \"transmitter and receiver can't be both SYNC with each other\");\t\\ \t\t\t\t\t\t\t\t\t\t\\ static const struct dai_properties sai_tx_props_##inst = {\t\t\t\\ \t.fifo_address = SAI_TX_FIFO_BASE(inst),\t\t\t\t\t\\ \t.fifo_depth = SAI_FIFO_DEPTH(inst) * CONFIG_SAI_FIFO_WORD_SIZE,\t\t\\ \t.dma_hs_id = SAI_TX_DMA_MUX(inst),\t\t\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static const struct dai_properties sai_rx_props_##inst = {\t\t\t\\ \t.fifo_address = SAI_RX_FIFO_BASE(inst),\t\t\t\t\t\\ \t.fifo_depth = SAI_FIFO_DEPTH(inst) * CONFIG_SAI_FIFO_WORD_SIZE,\t\t\\ \t.dma_hs_id = SAI_RX_DMA_MUX(inst),\t\t\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ void irq_config_##inst(void)\t\t\t\t\t\t\t\\ {\t\t\t\t\t\t\t\t\t\t\\ \tIRQ_CONNECT(DT_INST_IRQN(inst),\t\t\t\t\t\t\\ \t\t    0,\t\t\t\t\t\t\t\t\\ \t\t    sai_isr,\t\t\t\t\t\t\t\\ \t\t    DEVICE_DT_INST_GET(inst),\t\t\t\t\t\\ \t\t    0);\t\t\t\t\t\t\t\t\\ \tirq_enable(DT_INST_IRQN(inst));\t\t\t\t\t\t\\ }\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static struct sai_config sai_config_##inst = {\t\t\t\t\t\\ \t.regmap_phys = DT_INST_REG_ADDR(inst),\t\t\t\t\t\\ \t.regmap_size = DT_INST_REG_SIZE(inst),\t\t\t\t\t\\ \t.clk_data = SAI_CLOCK_DATA_DECLARE(inst),\t\t\t\t\\ \t.rx_fifo_watermark = SAI_RX_FIFO_WATERMARK(inst),\t\t\t\\ \t.tx_fifo_watermark = SAI_TX_FIFO_WATERMARK(inst),\t\t\t\\ \t.mclk_is_output = DT_INST_PROP_OR(inst, mclk_is_output, false),\t\t\\ \t.tx_props =&sai_tx_props_##inst,\t\t\t\t\t\\ \t.rx_props =&sai_rx_props_##inst,\t\t\t\t\t\\ \t.irq_config = irq_config_##inst,\t\t\t\t\t\\ \t.tx_sync_mode = SAI_TX_SYNC_MODE(inst),\t\t\t\t\t\\ \t.rx_sync_mode = SAI_RX_SYNC_MODE(inst),\t\t\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static struct sai_data sai_data_##inst = {\t\t\t\t\t\\ \t.cfg.type = DAI_IMX_SAI,\t\t\t\t\t\t\\ \t.cfg.dai_index = DT_INST_PROP_OR(inst, dai_index, 0),\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ DEVICE_DT_INST_DEFINE(inst,&sai_init, NULL,\t\t\t\t\t\\&sai_data_##inst,&sai_config_##inst,\t\t\t\\ \t\t      POST_KERNEL, CONFIG_DAI_INIT_PRIORITY,\t\t\t\\&sai_api);\t\t\t\t\t\t\\  DT_INST_FOREACH_STATUS_OKAY(SAI_INIT);\nend_define\n\nend_unit\n\nname|SBS_GAUGE_CONFIG_DEFINE\nparameter_list|(\nname|index\nparameter_list|)\ndefine|\\\nvalue|COND_CODE_1(DT_INST_PROP_OR(index, battery_cutoff_support, false),                         \\ \t\t    (_SBS_GAUGE_CONFIG_DEFINE(index)), (;))\nend_define\n\nbegin_comment\ncomment|/* Conditionally get the battery config variable name or NULL based on battery cutoff support */\nend_comment\nname|SBS_GAUGE_GET_BATTERY_CONFIG_NAME\nparameter_list|(\nname|index\nparameter_list|)\ndefine|\\\nvalue|COND_CODE_1(DT_INST_PROP_OR(index, battery_cutoff_support, false),                         \\ \t\t    (&_SBS_GAUGE_BATT_CUTOFF_CFG_VAR_NAME(index)), (NULL))\nend_define\n\nbegin_define\nDECL|macro|SBS_GAUGE_INIT (index)\ndefine|#\nDECL|member|ibi_lock\nname|struct\nname|k_sem\nname|ibi_lock\ndecl_stmt|;\nDECL|struct|__anon274e0edf0108\nstruct|struct\nblock|{\ncomment|/** \t\t * Clock divider for use when generating clock for \t\t * I3C Push-pull mode. \t\t */\nDECL|member|clk_div_pp\nname|uint8_t\nname|clocks\nstruct|;\nifdef|#\ndirective|ifdef\nname|CONFIG_I3C_USE_IBI\nDECL|struct|__anon274e0edf0208\nstruct|struct\nblock|{\ncomment|/** List of addresses used in the MIBIRULES register. */\nDECL|member|addr\nname|uint8_t\nname|I3C_MCUX_DEVICE\nparameter_list|(\nname|id\nparameter_list|)\ndefine|\\\nvalue|PINCTRL_DT_INST_DEFINE(id);\t\t\t\t\t\t\\ \tstatic void mcux_i3c_config_func_##id(const struct device *dev);\t\\ \tstatic struct i3c_device_desc mcux_i3c_device_array_##id[] =\t\t\t\\ \t\tI3C_DEVICE_ARRAY_DT_INST(id);\t\t\t\t\t\\ \tstatic struct i3c_i2c_device_desc mcux_i3c_i2c_device_array_##id[] =\t\t\\ \t\tI3C_I2C_DEVICE_ARRAY_DT_INST(id);\t\t\t\t\\ \tstatic const struct mcux_i3c_config mcux_i3c_config_##id = {\t\t\\ \t\t.base = (I3C_Type *) DT_INST_REG_ADDR(id),\t\t\t\\ \t\t.clock_dev = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(id)),\t\t\\ \t\t.clock_subsys =\t\t\t\t\t\t\t\\ \t\t\t(clock_control_subsys_t)DT_INST_CLOCKS_CELL(id, name),\t\\ \t\t.irq_config_func = mcux_i3c_config_func_##id,\t\t\t\\ \t\t.common.dev_list.i3c = mcux_i3c_device_array_##id,\t\t\t\\ \t\t.common.dev_list.num_i3c = ARRAY_SIZE(mcux_i3c_device_array_##id),\t\\ \t\t.common.dev_list.i2c = mcux_i3c_i2c_device_array_##id,\t\t\t\\ \t\t.common.dev_list.num_i2c = ARRAY_SIZE(mcux_i3c_i2c_device_array_##id),\t\\ \t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(id),\t\t\t\\ \t\t.disable_open_drain_high_pp =\t\t\t\t\t\\ \t\t\tDT_INST_PROP_OR(id, disable_open_drain_high_pp, false), \\ \t};\t\t\t\t\t\t\t\t\t\\ \tstatic struct mcux_i3c_data mcux_i3c_data_##id = {\t\t\t\\ \t\t.clocks.i3c_od_scl_hz = DT_INST_PROP_OR(id, i3c_od_scl_hz, 0),\t\\ \t\t.common.ctrl_config.scl.i3c = DT_INST_PROP_OR(id, i3c_scl_hz, 0),\t\\ \t\t.common.ctrl_config.scl.i2c = DT_INST_PROP_OR(id, i2c_scl_hz, 0),\t\\ \t\t.clocks.clk_div_pp = DT_INST_PROP(id, clk_divider),\t\t\\ \t\t.clocks.clk_div_od = DT_INST_PROP(id, clk_divider_slow),\t\\ \t\t.clocks.clk_div_tc = DT_INST_PROP(id, clk_divider_tc),\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(id,\t\t\t\t\t\t\\ \t\t\t      mcux_i3c_init,\t\t\t\t\t\\ \t\t\t      NULL,\t\t\t\t\t\t\\&mcux_i3c_data_##id,\t\t\t\t\\&mcux_i3c_config_##id,\t\t\t\t\\ \t\t\t      POST_KERNEL,\t\t\t\t\t\\ \t\t\t      CONFIG_I3C_CONTROLLER_INIT_PRIORITY,\t\t\\&mcux_i3c_driver_api);\t\t\t\t\\ \tstatic void mcux_i3c_config_func_##id(const struct device *dev)\t\t\\ \t{\t\t\t\t\t\t\t\t\t\\ \t\tIRQ_CONNECT(DT_INST_IRQN(id),\t\t\t\t\t\\ \t\t\t    DT_INST_IRQ(id, priority),\t\t\t\t\\ \t\t\t    mcux_i3c_isr,\t\t\t\t\t\\ \t\t\t    DEVICE_DT_INST_GET(id),\t\t\t\t\\ \t\t\t    0);\t\t\t\t\t\t\t\\ \t\tirq_enable(DT_INST_IRQN(id));\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\  DT_INST_FOREACH_STATUS_OKAY(I3C_MCUX_DEVICE)\nend_define\n\nend_unit\n\nname|UART_SAM0_SERCOM_COLLISION_DETECT\nparameter_list|(\nname|n\nparameter_list|)\ndefine|\\\nvalue|(DT_INST_PROP_OR(n, collision_detection, false))\nend_define\n\nbegin_ifdef\nifdef|#\ndirective|ifdef\nname|STM32_UART_INIT\nparameter_list|(\nname|index\nparameter_list|)\ndefine|\\\nvalue|STM32_UART_IRQ_HANDLER_DECL(index)\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ PINCTRL_DT_INST_DEFINE(index);\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ static const struct stm32_pclken pclken_##index[] =\t\t\t\\ \t\t\t\t\t    STM32_DT_INST_CLOCKS(index);\\ \t\t\t\t\t\t\t\t\t\\ static struct uart_config uart_cfg_##index = {\t\t\t\t\\ \t.baudrate  = DT_INST_PROP_OR(index, current_speed,\t\t\\ \t\t\t\t     STM32_UART_DEFAULT_BAUDRATE),\t\\ \t.parity    = DT_INST_ENUM_IDX_OR(index, parity,\t\t\t\\ \t\t\t\t\t STM32_UART_DEFAULT_PARITY),\t\\ \t.stop_bits = DT_INST_ENUM_IDX_OR(index, stop_bits,\t\t\\ \t\t\t\t\t STM32_UART_DEFAULT_STOP_BITS),\t\\ \t.data_bits = DT_INST_ENUM_IDX_OR(index, data_bits,\t\t\\ \t\t\t\t\t STM32_UART_DEFAULT_DATA_BITS),\t\\ \t.flow_ctrl = DT_INST_PROP(index, hw_flow_control)\t\t\\ \t\t\t\t\t? UART_CFG_FLOW_CTRL_RTS_CTS\t\\ \t\t\t\t\t: UART_CFG_FLOW_CTRL_NONE,\t\\ };\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ static const struct uart_stm32_config uart_stm32_cfg_##index = {\t\\ \t.usart = (USART_TypeDef *)DT_INST_REG_ADDR(index),\t\t\\ \t.reset = RESET_DT_SPEC_GET(DT_DRV_INST(index)),\t\t\t\\ \t.pclken = pclken_##index,\t\t\t\t\t\\ \t.pclk_len = DT_INST_NUM_CLOCKS(index),\t\t\t\t\\ \t.pcfg = PINCTRL_DT_INST_DEV_CONFIG_GET(index),\t\t\t\\ \t.single_wire = DT_INST_PROP_OR(index, single_wire, false),\t\\ \t.tx_rx_swap = DT_INST_PROP_OR(index, tx_rx_swap, false),\t\\ \t.rx_invert = DT_INST_PROP(index, rx_invert),\t\t\t\\ \t.tx_invert = DT_INST_PROP(index, tx_invert),\t\t\t\\ \t.de_enable = DT_INST_PROP(index, de_enable),\t\t\t\\ \t.de_assert_time = DT_INST_PROP(index, de_assert_time),\t\t\\ \t.de_deassert_time = DT_INST_PROP(index, de_deassert_time),\t\\ \t.de_invert = DT_INST_PROP(index, de_invert),\t\t\t\\ \t.fifo_enable = DT_INST_PROP(index, fifo_enable),\t\t\\ \tSTM32_UART_IRQ_HANDLER_FUNC(index)\t\t\t\t\\ \tSTM32_UART_PM_WAKEUP(index)\t\t\t\t\t\\ };\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ static struct uart_stm32_data uart_stm32_data_##index = {\t\t\\ \t.uart_cfg =&uart_cfg_##index,\t\t\t\t\t\\ \tUART_DMA_CHANNEL(index, rx, RX, PERIPHERAL, MEMORY)\t\t\\ \tUART_DMA_CHANNEL(index, tx, TX, MEMORY, PERIPHERAL)\t\t\\ };\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ PM_DEVICE_DT_INST_DEFINE(index, uart_stm32_pm_action);\t\t        \\ \t\t\t\t\t\t\t\t\t\\ DEVICE_DT_INST_DEFINE(index,\t\t\t\t\t\t\\&uart_stm32_init,\t\t\t\t\t\\ \t\t    PM_DEVICE_DT_INST_GET(index),\t\t\t\\&uart_stm32_data_##index,&uart_stm32_cfg_##index,\t\\ \t\t    PRE_KERNEL_1, CONFIG_SERIAL_INIT_PRIORITY,\t\t\\&uart_stm32_driver_api);\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ STM32_UART_IRQ_HANDLER(index)\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ STM32_UART_CHECK_DT_PARITY(index)\t\t\t\t\t\\ STM32_UART_CHECK_DT_DATA_BITS(index)\t\t\t\t\t\\ STM32_UART_CHECK_DT_STOP_BITS_0_5(index)\t\t\t\t\\ STM32_UART_CHECK_DT_STOP_BITS_1_5(index)\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(\ncomment|/* overwrite by cfg  */\nvalue|\\ \t\t\t .txDataWidth = 8,\ncomment|/* overwrite by cfg  */\nvalue|\\ \t\t\t .enableMsbFirst = true,\ncomment|/* overwrite by cfg  */\nvalue|\\ \t\t\t .subMode = DT_INST_PROP_OR(n, sub_mode, CY_SCB_SPI_MOTOROLA),             \\ \t\t\t .oversample =                                                             \\ \t\t\t\t DT_INST_PROP_OR(n, oversample, IFX_CAT1_SPI_DEFAULT_OVERSAMPLE),  \\ \t\t\t .enableFreeRunSclk = DT_INST_PROP_OR(n, enable_free_run_sclk, false),     \\ \t\t\t .enableInputFilter = DT_INST_PROP_OR(n, enable_input_filter, false),      \\ \t\t\t .enableMisoLateSample =                                                   \\ \t\t\t\t DT_INST_PROP_OR(n, enable_miso_late_sample, true),                \\ \t\t\t .enableTransferSeperation =                                               \\ \t\t\t\t DT_INST_PROP_OR(n, enable_transfer_seperation, false),            \\ \t\t\t .enableWakeFromSleep = DT_INST_PROP_OR(n, enableWakeFromSleep, false),    \\ \t\t\t .ssPolarity = DT_INST_PROP_OR(n, ss_polarity, CY_SCB_SPI_ACTIVE_LOW),     \\ \t\t\t .rxFifoTriggerLevel = DT_INST_PROP_OR(n, rx_fifo_trigger_level, 0),       \\ \t\t\t .rxFifoIntEnableMask = DT_INST_PROP_OR(n, rx_fifo_int_enable_mask, 0),    \\ \t\t\t .txFifoTriggerLevel = DT_INST_PROP_OR(n, tx_fifo_trigger_level, 0),       \\ \t\t\t .txFifoIntEnableMask = DT_INST_PROP_OR(n, tx_fifo_int_enable_mask, 0),    \\ \t\t\t .masterSlaveIntEnableMask =                                               \\ \t\t\t\t DT_INST_PROP_OR(n, master_slave_int_enable_mask, 0)},             \\                                                                                                    \\ \t\t.irq_priority = DT_INST_IRQ(n, priority),                                          \\ \t};                                                                                         \\ \tDEVICE_DT_INST_DEFINE(n,&ifx_cat1_spi_init, NULL,&spi_cat1_data_##n,                     \\&spi_cat1_config_##n, POST_KERNEL,                                   \\ \t\t\t      CONFIG_KERNEL_INIT_PRIORITY_DEVICE,&ifx_cat1_spi_api);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(\nname|CDC_ACM_CFG_AND_DATA_DEFINE\nparameter_list|(\nname|x\nparameter_list|)\ndefine|\\\nvalue|USBD_CLASS_DESCR_DEFINE(primary, x)\t\t\t\t\\ \tstruct usb_cdc_acm_config cdc_acm_cfg_##x = {\t\t\t\\ \t\tINITIALIZER_IAD\t\t\t\t\t\t\\ \t\t.if0 = INITIALIZER_IF(0, 1,\t\t\t\t\\ \t\t\t\tUSB_BCC_CDC_CONTROL,\t\t\t\\ \t\t\t\tACM_SUBCLASS),\t\t\t\t\\ \t\t.if0_header = INITIALIZER_IF_HDR,\t\t\t\\ \t\t.if0_cm = INITIALIZER_IF_CM,\t\t\t\t\\ \t\t.if0_acm = INITIALIZER_IF_ACM,\t\t\t\t\\ \t\t.if0_union = INITIALIZER_IF_UNION,\t\t\t\\ \t\t.if0_int_ep = INITIALIZER_IF_EP(AUTO_EP_IN,\t\t\\ \t\t\t\tUSB_DC_EP_INTERRUPT,\t\t\t\\ \t\t\t\tCONFIG_CDC_ACM_INTERRUPT_EP_MPS,\t\\ \t\t\t\t0x0A),\t\t\t\t\t\\ \t\t.if1 = INITIALIZER_IF(1, 2,\t\t\t\t\\ \t\t\t\tUSB_BCC_CDC_DATA,\t\t\t\\ \t\t\t\t0),\t\t\t\t\t\\ \t\t.if1_in_ep = INITIALIZER_IF_EP(AUTO_EP_IN,\t\t\\ \t\t\t\tUSB_DC_EP_BULK,\t\t\t\t\\ \t\t\t\tCONFIG_CDC_ACM_BULK_EP_MPS,\t\t\\ \t\t\t\t0x00),\t\t\t\t\t\\ \t\t.if1_out_ep = INITIALIZER_IF_EP(AUTO_EP_OUT,\t\t\\ \t\t\t\tUSB_DC_EP_BULK,\t\t\t\t\\ \t\t\t\tCONFIG_CDC_ACM_BULK_EP_MPS,\t\t\\ \t\t\t\t0x00),\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic struct usb_ep_cfg_data cdc_acm_ep_data_##x[] = {\t\t\\ \t\t{\t\t\t\t\t\t\t\\ \t\t\t.ep_cb = cdc_acm_int_in,\t\t\t\\ \t\t\t.ep_addr = AUTO_EP_IN,\t\t\t\t\\ \t\t},\t\t\t\t\t\t\t\\ \t\t{\t\t\t\t\t\t\t\\ \t\t\t.ep_cb = usb_transfer_ep_callback,\t\t\\ \t\t\t.ep_addr = AUTO_EP_OUT,\t\t\t\t\\ \t\t},\t\t\t\t\t\t\t\\ \t\t{\t\t\t\t\t\t\t\\ \t\t\t.ep_cb = usb_transfer_ep_callback,\t\t\\ \t\t\t.ep_addr = AUTO_EP_IN,\t\t\t\t\\ \t\t},\t\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tUSBD_DEFINE_CFG_DATA(cdc_acm_config_##x) = {\t\t\t\\ \t\t.usb_device_description = NULL,\t\t\t\t\\ \t\t.interface_config = cdc_interface_config,\t\t\\ \t\t.interface_descriptor =&cdc_acm_cfg_##x.if0,\t\t\\ \t\t.cb_usb_status = cdc_acm_dev_status_cb,\t\t\t\\ \t\t.interface = {\t\t\t\t\t\t\\ \t\t\t.class_handler = cdc_acm_class_handle_req,\t\\ \t\t\t.custom_handler = NULL,\t\t\t\t\\ \t\t},\t\t\t\t\t\t\t\\ \t\t.num_endpoints = ARRAY_SIZE(cdc_acm_ep_data_##x),\t\\ \t\t.endpoint = cdc_acm_ep_data_##x,\t\t\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tRING_BUF_DECLARE(cdc_acm_rx_rb_##x,\t\t\t\t\\ \t\t\t CONFIG_USB_CDC_ACM_RINGBUF_SIZE);\t\t\\ \tRING_BUF_DECLARE(cdc_acm_tx_rb_##x,\t\t\t\t\\ \t\t\t CONFIG_USB_CDC_ACM_RINGBUF_SIZE);\t\t\\ \tstatic struct cdc_acm_dev_data_t cdc_acm_dev_data_##x = {\t\\ \t\t.line_coding = CDC_ACM_DEFAULT_BAUDRATE,\t\t\\ \t\t.rx_ringbuf =&cdc_acm_rx_rb_##x,\t\t\t\\ \t\t.tx_ringbuf =&cdc_acm_tx_rb_##x,\t\t\t\\ \t\t.flow_ctrl = DT_INST_PROP_OR(x, hw_flow_control, false),\\ \t};\nend_define\n\nbegin_define\nDECL|macro|DT_DRV_COMPAT\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|BUILD_ASSERT(SAI_FIFO_DEPTH(inst)> 0&&\t\t\t\t\t\\ \t     SAI_FIFO_DEPTH(inst)<= _SAI_FIFO_DEPTH(inst),\t\t\t\\ \t     \"invalid FIFO depth\");\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(SAI_RX_FIFO_WATERMARK(inst)> 0&&\t\t\t\t\t\\ \t     SAI_RX_FIFO_WATERMARK(inst)<= _SAI_FIFO_DEPTH(inst),\t\t\\ \t     \"invalid RX FIFO watermark\");\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(SAI_TX_FIFO_WATERMARK(inst)> 0&&\t\t\t\t\t\\ \t     SAI_TX_FIFO_WATERMARK(inst)<= _SAI_FIFO_DEPTH(inst),\t\t\\ \t     \"invalid TX FIFO watermark\");\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(IS_ENABLED(CONFIG_SAI_HAS_MCLK_CONFIG_OPTION) ||\t\t\t\\ \t     !DT_INST_PROP(inst, mclk_is_output),\t\t\t\t\\ \t     \"SAI doesn't support MCLK config but mclk_is_output is specified\");\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(SAI_TX_SYNC_MODE(inst) != SAI_RX_SYNC_MODE(inst) ||\t\t\\ \t     SAI_TX_SYNC_MODE(inst) != kSAI_ModeSync,\t\t\t\t\\ \t     \"transmitter and receiver can't be both SYNC with each other\");\t\\ \t\t\t\t\t\t\t\t\t\t\\ static const struct dai_properties sai_tx_props_##inst = {\t\t\t\\ \t.fifo_address = SAI_TX_FIFO_BASE(inst),\t\t\t\t\t\\ \t.fifo_depth = SAI_FIFO_DEPTH(inst) * CONFIG_SAI_FIFO_WORD_SIZE,\t\t\\ \t.dma_hs_id = SAI_TX_DMA_MUX(inst),\t\t\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static const struct dai_properties sai_rx_props_##inst = {\t\t\t\\ \t.fifo_address = SAI_RX_FIFO_BASE(inst),\t\t\t\t\t\\ \t.fifo_depth = SAI_FIFO_DEPTH(inst) * CONFIG_SAI_FIFO_WORD_SIZE,\t\t\\ \t.dma_hs_id = SAI_RX_DMA_MUX(inst),\t\t\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ void irq_config_##inst(void)\t\t\t\t\t\t\t\\ {\t\t\t\t\t\t\t\t\t\t\\ \tIRQ_CONNECT(DT_INST_IRQN(inst),\t\t\t\t\t\t\\ \t\t    0,\t\t\t\t\t\t\t\t\\ \t\t    sai_isr,\t\t\t\t\t\t\t\\ \t\t    DEVICE_DT_INST_GET(inst),\t\t\t\t\t\\ \t\t    0);\t\t\t\t\t\t\t\t\\ \tirq_enable(DT_INST_IRQN(inst));\t\t\t\t\t\t\\ }\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static struct sai_config sai_config_##inst = {\t\t\t\t\t\\ \t.regmap_phys = DT_INST_REG_ADDR(inst),\t\t\t\t\t\\ \t.regmap_size = DT_INST_REG_SIZE(inst),\t\t\t\t\t\\ \t.clk_data = SAI_CLOCK_DATA_DECLARE(inst),\t\t\t\t\\ \t.rx_fifo_watermark = SAI_RX_FIFO_WATERMARK(inst),\t\t\t\\ \t.tx_fifo_watermark = SAI_TX_FIFO_WATERMARK(inst),\t\t\t\\ \t.mclk_is_output = DT_INST_PROP_OR(inst, mclk_is_output, false),\t\t\\ \t.tx_props =&sai_tx_props_##inst,\t\t\t\t\t\\ \t.rx_props =&sai_rx_props_##inst,\t\t\t\t\t\\ \t.irq_config = irq_config_##inst,\t\t\t\t\t\\ \t.tx_sync_mode = SAI_TX_SYNC_MODE(inst),\t\t\t\t\t\\ \t.rx_sync_mode = SAI_RX_SYNC_MODE(inst),\t\t\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static struct sai_data sai_data_##inst = {\t\t\t\t\t\\ \t.cfg.type = DAI_IMX_SAI,\t\t\t\t\t\t\\ \t.cfg.dai_index = DT_INST_PROP_OR(inst, dai_index, 0),\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ DEVICE_DT_INST_DEFINE(inst,&sai_init, NULL,\t\t\t\t\t\\&sai_data_##inst,&sai_config_##inst,\t\t\t\\ \t\t      POST_KERNEL, CONFIG_DAI_INIT_PRIORITY,\t\t\t\\&sai_api);\t\t\t\t\t\t\\  DT_INST_FOREACH_STATUS_OKAY(SAI_INIT);\n+value|BUILD_ASSERT(SAI_FIFO_DEPTH(inst)> 0&&\t\t\t\t\t\\ \t     SAI_FIFO_DEPTH(inst)<= _SAI_FIFO_DEPTH(inst),\t\t\t\\ \t     \"invalid FIFO depth\");\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(SAI_RX_FIFO_WATERMARK(inst)> 0&&\t\t\t\t\t\\ \t     SAI_RX_FIFO_WATERMARK(inst)<= _SAI_FIFO_DEPTH(inst),\t\t\\ \t     \"invalid RX FIFO watermark\");\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(SAI_TX_FIFO_WATERMARK(inst)> 0&&\t\t\t\t\t\\ \t     SAI_TX_FIFO_WATERMARK(inst)<= _SAI_FIFO_DEPTH(inst),\t\t\\ \t     \"invalid TX FIFO watermark\");\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(IS_ENABLED(CONFIG_SAI_HAS_MCLK_CONFIG_OPTION) ||\t\t\t\\ \t     !DT_INST_PROP(inst, mclk_is_output),\t\t\t\t\\ \t     \"SAI doesn't support MCLK config but mclk_is_output is specified\");\\ \t\t\t\t\t\t\t\t\t\t\\ BUILD_ASSERT(SAI_TX_SYNC_MODE(inst) != SAI_RX_SYNC_MODE(inst) ||\t\t\\ \t     SAI_TX_SYNC_MODE(inst) != kSAI_ModeSync,\t\t\t\t\\ \t     \"transmitter and receiver can't be both SYNC with each other\");\t\\ \t\t\t\t\t\t\t\t\t\t\\ static const struct dai_properties sai_tx_props_##inst = {\t\t\t\\ \t.fifo_address = SAI_TX_FIFO_BASE(inst),\t\t\t\t\t\\ \t.fifo_depth = SAI_FIFO_DEPTH(inst) * CONFIG_SAI_FIFO_WORD_SIZE,\t\t\\ \t.dma_hs_id = SAI_TX_DMA_MUX(inst),\t\t\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static const struct dai_properties sai_rx_props_##inst = {\t\t\t\\ \t.fifo_address = SAI_RX_FIFO_BASE(inst),\t\t\t\t\t\\ \t.fifo_depth = SAI_FIFO_DEPTH(inst) * CONFIG_SAI_FIFO_WORD_SIZE,\t\t\\ \t.dma_hs_id = SAI_RX_DMA_MUX(inst),\t\t\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ void irq_config_##inst(void)\t\t\t\t\t\t\t\\ {\t\t\t\t\t\t\t\t\t\t\\ \tIRQ_CONNECT(DT_INST_IRQN(inst),\t\t\t\t\t\t\\ \t\t    0,\t\t\t\t\t\t\t\t\\ \t\t    sai_isr,\t\t\t\t\t\t\t\\ \t\t    DEVICE_DT_INST_GET(inst),\t\t\t\t\t\\ \t\t    0);\t\t\t\t\t\t\t\t\\ \tirq_enable(DT_INST_IRQN(inst));\t\t\t\t\t\t\\ }\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static struct sai_config sai_config_##inst = {\t\t\t\t\t\\ \t.regmap_phys = DT_INST_REG_ADDR(inst),\t\t\t\t\t\\ \t.regmap_size = DT_INST_REG_SIZE(inst),\t\t\t\t\t\\ \t.clk_data = SAI_CLOCK_DATA_DECLARE(inst),\t\t\t\t\\ \t.rx_fifo_watermark = SAI_RX_FIFO_WATERMARK(inst),\t\t\t\\ \t.tx_fifo_watermark = SAI_TX_FIFO_WATERMARK(inst),\t\t\t\\ \t.mclk_is_output = DT_INST_PROP(inst, mclk_is_output),\t\t\t\\ \t.tx_props =&sai_tx_props_##inst,\t\t\t\t\t\\ \t.rx_props =&sai_rx_props_##inst,\t\t\t\t\t\\ \t.irq_config = irq_config_##inst,\t\t\t\t\t\\ \t.tx_sync_mode = SAI_TX_SYNC_MODE(inst),\t\t\t\t\t\\ \t.rx_sync_mode = SAI_RX_SYNC_MODE(inst),\t\t\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ static struct sai_data sai_data_##inst = {\t\t\t\t\t\\ \t.cfg.type = DAI_IMX_SAI,\t\t\t\t\t\t\\ \t.cfg.dai_index = DT_INST_PROP_OR(inst, dai_index, 0),\t\t\t\\ };\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ DEVICE_DT_INST_DEFINE(inst,&sai_init, NULL,\t\t\t\t\t\\&sai_data_##inst,&sai_config_##inst,\t\t\t\\ \t\t      POST_KERNEL, CONFIG_DAI_INIT_PRIORITY,\t\t\t\\&sai_api);\t\t\t\t\t\t\\  DT_INST_FOREACH_STATUS_OKAY(SAI_INIT);\n-value|COND_CODE_1(DT_INST_PROP_OR(index, battery_cutoff_support, false),                         \\ \t\t    (_SBS_GAUGE_CONFIG_DEFINE(index)), (;))\n+value|COND_CODE_1(DT_INST_PROP(index, battery_cutoff_support),                                   \\ \t\t    (_SBS_GAUGE_CONFIG_DEFINE(index)), (;))\n-value|COND_CODE_1(DT_INST_PROP_OR(index, battery_cutoff_support, false),                         \\ \t\t    (&_SBS_GAUGE_BATT_CUTOFF_CFG_VAR_NAME(index)), (NULL))\n+value|COND_CODE_1(DT_INST_PROP(index, battery_cutoff_support),                                   \\ \t\t    (&_SBS_GAUGE_BATT_CUTOFF_CFG_VAR_NAME(index)), (NULL))\n-DECL|struct|__anon274e0edf0108\n+DECL|struct|__anon2b7857c10108\n-DECL|struct|__anon274e0edf0208\n+DECL|struct|__anon2b7857c10208\n-value|PINCTRL_DT_INST_DEFINE(id);\t\t\t\t\t\t\\ \tstatic void mcux_i3c_config_func_##id(const struct device *dev);\t\\ \tstatic struct i3c_device_desc mcux_i3c_device_array_##id[] =\t\t\t\\ \t\tI3C_DEVICE_ARRAY_DT_INST(id);\t\t\t\t\t\\ \tstatic struct i3c_i2c_device_desc mcux_i3c_i2c_device_array_##id[] =\t\t\\ \t\tI3C_I2C_DEVICE_ARRAY_DT_INST(id);\t\t\t\t\\ \tstatic const struct mcux_i3c_config mcux_i3c_config_##id = {\t\t\\ \t\t.base = (I3C_Type *) DT_INST_REG_ADDR(id),\t\t\t\\ \t\t.clock_dev = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(id)),\t\t\\ \t\t.clock_subsys =\t\t\t\t\t\t\t\\ \t\t\t(clock_control_subsys_t)DT_INST_CLOCKS_CELL(id, name),\t\\ \t\t.irq_config_func = mcux_i3c_config_func_##id,\t\t\t\\ \t\t.common.dev_list.i3c = mcux_i3c_device_array_##id,\t\t\t\\ \t\t.common.dev_list.num_i3c = ARRAY_SIZE(mcux_i3c_device_array_##id),\t\\ \t\t.common.dev_list.i2c = mcux_i3c_i2c_device_array_##id,\t\t\t\\ \t\t.common.dev_list.num_i2c = ARRAY_SIZE(mcux_i3c_i2c_device_array_##id),\t\\ \t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(id),\t\t\t\\ \t\t.disable_open_drain_high_pp =\t\t\t\t\t\\ \t\t\tDT_INST_PROP_OR(id, disable_open_drain_high_pp, false), \\ \t};\t\t\t\t\t\t\t\t\t\\ \tstatic struct mcux_i3c_data mcux_i3c_data_##id = {\t\t\t\\ \t\t.clocks.i3c_od_scl_hz = DT_INST_PROP_OR(id, i3c_od_scl_hz, 0),\t\\ \t\t.common.ctrl_config.scl.i3c = DT_INST_PROP_OR(id, i3c_scl_hz, 0),\t\\ \t\t.common.ctrl_config.scl.i2c = DT_INST_PROP_OR(id, i2c_scl_hz, 0),\t\\ \t\t.clocks.clk_div_pp = DT_INST_PROP(id, clk_divider),\t\t\\ \t\t.clocks.clk_div_od = DT_INST_PROP(id, clk_divider_slow),\t\\ \t\t.clocks.clk_div_tc = DT_INST_PROP(id, clk_divider_tc),\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(id,\t\t\t\t\t\t\\ \t\t\t      mcux_i3c_init,\t\t\t\t\t\\ \t\t\t      NULL,\t\t\t\t\t\t\\&mcux_i3c_data_##id,\t\t\t\t\\&mcux_i3c_config_##id,\t\t\t\t\\ \t\t\t      POST_KERNEL,\t\t\t\t\t\\ \t\t\t      CONFIG_I3C_CONTROLLER_INIT_PRIORITY,\t\t\\&mcux_i3c_driver_api);\t\t\t\t\\ \tstatic void mcux_i3c_config_func_##id(const struct device *dev)\t\t\\ \t{\t\t\t\t\t\t\t\t\t\\ \t\tIRQ_CONNECT(DT_INST_IRQN(id),\t\t\t\t\t\\ \t\t\t    DT_INST_IRQ(id, priority),\t\t\t\t\\ \t\t\t    mcux_i3c_isr,\t\t\t\t\t\\ \t\t\t    DEVICE_DT_INST_GET(id),\t\t\t\t\\ \t\t\t    0);\t\t\t\t\t\t\t\\ \t\tirq_enable(DT_INST_IRQN(id));\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\  DT_INST_FOREACH_STATUS_OKAY(I3C_MCUX_DEVICE)\n+value|PINCTRL_DT_INST_DEFINE(id);\t\t\t\t\t\t\\ \tstatic void mcux_i3c_config_func_##id(const struct device *dev);\t\\ \tstatic struct i3c_device_desc mcux_i3c_device_array_##id[] =\t\t\\ \t\tI3C_DEVICE_ARRAY_DT_INST(id);\t\t\t\t\t\\ \tstatic struct i3c_i2c_device_desc mcux_i3c_i2c_device_array_##id[] =\t\\ \t\tI3C_I2C_DEVICE_ARRAY_DT_INST(id);\t\t\t\t\\ \tstatic const struct mcux_i3c_config mcux_i3c_config_##id = {\t\t\\ \t\t.base = (I3C_Type *) DT_INST_REG_ADDR(id),\t\t\t\\ \t\t.clock_dev = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(id)),\t\t\\ \t\t.clock_subsys =\t\t\t\t\t\t\t\\ \t\t\t(clock_control_subsys_t)DT_INST_CLOCKS_CELL(id, name),\t\\ \t\t.irq_config_func = mcux_i3c_config_func_##id,\t\t\t\\ \t\t.common.dev_list.i3c = mcux_i3c_device_array_##id,\t\t\t\\ \t\t.common.dev_list.num_i3c = ARRAY_SIZE(mcux_i3c_device_array_##id),\t\\ \t\t.common.dev_list.i2c = mcux_i3c_i2c_device_array_##id,\t\t\t\\ \t\t.common.dev_list.num_i2c = ARRAY_SIZE(mcux_i3c_i2c_device_array_##id),\t\\ \t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(id),\t\t\t\\ \t\t.disable_open_drain_high_pp =\t\t\t\t\t\\ \t\t\tDT_INST_PROP(id, disable_open_drain_high_pp),\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \tstatic struct mcux_i3c_data mcux_i3c_data_##id = {\t\t\t\\ \t\t.clocks.i3c_od_scl_hz = DT_INST_PROP_OR(id, i3c_od_scl_hz, 0),\t\\ \t\t.common.ctrl_config.scl.i3c = DT_INST_PROP_OR(id, i3c_scl_hz, 0),\t\\ \t\t.common.ctrl_config.scl.i2c = DT_INST_PROP_OR(id, i2c_scl_hz, 0),\t\\ \t\t.clocks.clk_div_pp = DT_INST_PROP(id, clk_divider),\t\t\\ \t\t.clocks.clk_div_od = DT_INST_PROP(id, clk_divider_slow),\t\\ \t\t.clocks.clk_div_tc = DT_INST_PROP(id, clk_divider_tc),\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(id,\t\t\t\t\t\t\\ \t\t\t      mcux_i3c_init,\t\t\t\t\t\\ \t\t\t      NULL,\t\t\t\t\t\t\\&mcux_i3c_data_##id,\t\t\t\t\\&mcux_i3c_config_##id,\t\t\t\t\\ \t\t\t      POST_KERNEL,\t\t\t\t\t\\ \t\t\t      CONFIG_I3C_CONTROLLER_INIT_PRIORITY,\t\t\\&mcux_i3c_driver_api);\t\t\t\t\\ \tstatic void mcux_i3c_config_func_##id(const struct device *dev)\t\t\\ \t{\t\t\t\t\t\t\t\t\t\\ \t\tIRQ_CONNECT(DT_INST_IRQN(id),\t\t\t\t\t\\ \t\t\t    DT_INST_IRQ(id, priority),\t\t\t\t\\ \t\t\t    mcux_i3c_isr,\t\t\t\t\t\\ \t\t\t    DEVICE_DT_INST_GET(id),\t\t\t\t\\ \t\t\t    0);\t\t\t\t\t\t\t\\ \t\tirq_enable(DT_INST_IRQN(id));\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\  DT_INST_FOREACH_STATUS_OKAY(I3C_MCUX_DEVICE)\n-value|(DT_INST_PROP_OR(n, collision_detection, false))\n+value|(DT_INST_PROP(n, collision_detection))\n-value|STM32_UART_IRQ_HANDLER_DECL(index)\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ PINCTRL_DT_INST_DEFINE(index);\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ static const struct stm32_pclken pclken_##index[] =\t\t\t\\ \t\t\t\t\t    STM32_DT_INST_CLOCKS(index);\\ \t\t\t\t\t\t\t\t\t\\ static struct uart_config uart_cfg_##index = {\t\t\t\t\\ \t.baudrate  = DT_INST_PROP_OR(index, current_speed,\t\t\\ \t\t\t\t     STM32_UART_DEFAULT_BAUDRATE),\t\\ \t.parity    = DT_INST_ENUM_IDX_OR(index, parity,\t\t\t\\ \t\t\t\t\t STM32_UART_DEFAULT_PARITY),\t\\ \t.stop_bits = DT_INST_ENUM_IDX_OR(index, stop_bits,\t\t\\ \t\t\t\t\t STM32_UART_DEFAULT_STOP_BITS),\t\\ \t.data_bits = DT_INST_ENUM_IDX_OR(index, data_bits,\t\t\\ \t\t\t\t\t STM32_UART_DEFAULT_DATA_BITS),\t\\ \t.flow_ctrl = DT_INST_PROP(index, hw_flow_control)\t\t\\ \t\t\t\t\t? UART_CFG_FLOW_CTRL_RTS_CTS\t\\ \t\t\t\t\t: UART_CFG_FLOW_CTRL_NONE,\t\\ };\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ static const struct uart_stm32_config uart_stm32_cfg_##index = {\t\\ \t.usart = (USART_TypeDef *)DT_INST_REG_ADDR(index),\t\t\\ \t.reset = RESET_DT_SPEC_GET(DT_DRV_INST(index)),\t\t\t\\ \t.pclken = pclken_##index,\t\t\t\t\t\\ \t.pclk_len = DT_INST_NUM_CLOCKS(index),\t\t\t\t\\ \t.pcfg = PINCTRL_DT_INST_DEV_CONFIG_GET(index),\t\t\t\\ \t.single_wire = DT_INST_PROP_OR(index, single_wire, false),\t\\ \t.tx_rx_swap = DT_INST_PROP_OR(index, tx_rx_swap, false),\t\\ \t.rx_invert = DT_INST_PROP(index, rx_invert),\t\t\t\\ \t.tx_invert = DT_INST_PROP(index, tx_invert),\t\t\t\\ \t.de_enable = DT_INST_PROP(index, de_enable),\t\t\t\\ \t.de_assert_time = DT_INST_PROP(index, de_assert_time),\t\t\\ \t.de_deassert_time = DT_INST_PROP(index, de_deassert_time),\t\\ \t.de_invert = DT_INST_PROP(index, de_invert),\t\t\t\\ \t.fifo_enable = DT_INST_PROP(index, fifo_enable),\t\t\\ \tSTM32_UART_IRQ_HANDLER_FUNC(index)\t\t\t\t\\ \tSTM32_UART_PM_WAKEUP(index)\t\t\t\t\t\\ };\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ static struct uart_stm32_data uart_stm32_data_##index = {\t\t\\ \t.uart_cfg =&uart_cfg_##index,\t\t\t\t\t\\ \tUART_DMA_CHANNEL(index, rx, RX, PERIPHERAL, MEMORY)\t\t\\ \tUART_DMA_CHANNEL(index, tx, TX, MEMORY, PERIPHERAL)\t\t\\ };\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ PM_DEVICE_DT_INST_DEFINE(index, uart_stm32_pm_action);\t\t        \\ \t\t\t\t\t\t\t\t\t\\ DEVICE_DT_INST_DEFINE(index,\t\t\t\t\t\t\\&uart_stm32_init,\t\t\t\t\t\\ \t\t    PM_DEVICE_DT_INST_GET(index),\t\t\t\\&uart_stm32_data_##index,&uart_stm32_cfg_##index,\t\\ \t\t    PRE_KERNEL_1, CONFIG_SERIAL_INIT_PRIORITY,\t\t\\&uart_stm32_driver_api);\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ STM32_UART_IRQ_HANDLER(index)\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ STM32_UART_CHECK_DT_PARITY(index)\t\t\t\t\t\\ STM32_UART_CHECK_DT_DATA_BITS(index)\t\t\t\t\t\\ STM32_UART_CHECK_DT_STOP_BITS_0_5(index)\t\t\t\t\\ STM32_UART_CHECK_DT_STOP_BITS_1_5(index)\n+value|STM32_UART_IRQ_HANDLER_DECL(index)\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ PINCTRL_DT_INST_DEFINE(index);\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ static const struct stm32_pclken pclken_##index[] =\t\t\t\\ \t\t\t\t\t    STM32_DT_INST_CLOCKS(index);\\ \t\t\t\t\t\t\t\t\t\\ static struct uart_config uart_cfg_##index = {\t\t\t\t\\ \t.baudrate  = DT_INST_PROP_OR(index, current_speed,\t\t\\ \t\t\t\t     STM32_UART_DEFAULT_BAUDRATE),\t\\ \t.parity    = DT_INST_ENUM_IDX_OR(index, parity,\t\t\t\\ \t\t\t\t\t STM32_UART_DEFAULT_PARITY),\t\\ \t.stop_bits = DT_INST_ENUM_IDX_OR(index, stop_bits,\t\t\\ \t\t\t\t\t STM32_UART_DEFAULT_STOP_BITS),\t\\ \t.data_bits = DT_INST_ENUM_IDX_OR(index, data_bits,\t\t\\ \t\t\t\t\t STM32_UART_DEFAULT_DATA_BITS),\t\\ \t.flow_ctrl = DT_INST_PROP(index, hw_flow_control)\t\t\\ \t\t\t\t\t? UART_CFG_FLOW_CTRL_RTS_CTS\t\\ \t\t\t\t\t: UART_CFG_FLOW_CTRL_NONE,\t\\ };\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ static const struct uart_stm32_config uart_stm32_cfg_##index = {\t\\ \t.usart = (USART_TypeDef *)DT_INST_REG_ADDR(index),\t\t\\ \t.reset = RESET_DT_SPEC_GET(DT_DRV_INST(index)),\t\t\t\\ \t.pclken = pclken_##index,\t\t\t\t\t\\ \t.pclk_len = DT_INST_NUM_CLOCKS(index),\t\t\t\t\\ \t.pcfg = PINCTRL_DT_INST_DEV_CONFIG_GET(index),\t\t\t\\ \t.single_wire = DT_INST_PROP(index, single_wire),\t\t\\ \t.tx_rx_swap = DT_INST_PROP(index, tx_rx_swap),\t\t\t\\ \t.rx_invert = DT_INST_PROP(index, rx_invert),\t\t\t\\ \t.tx_invert = DT_INST_PROP(index, tx_invert),\t\t\t\\ \t.de_enable = DT_INST_PROP(index, de_enable),\t\t\t\\ \t.de_assert_time = DT_INST_PROP(index, de_assert_time),\t\t\\ \t.de_deassert_time = DT_INST_PROP(index, de_deassert_time),\t\\ \t.de_invert = DT_INST_PROP(index, de_invert),\t\t\t\\ \t.fifo_enable = DT_INST_PROP(index, fifo_enable),\t\t\\ \tSTM32_UART_IRQ_HANDLER_FUNC(index)\t\t\t\t\\ \tSTM32_UART_PM_WAKEUP(index)\t\t\t\t\t\\ };\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ static struct uart_stm32_data uart_stm32_data_##index = {\t\t\\ \t.uart_cfg =&uart_cfg_##index,\t\t\t\t\t\\ \tUART_DMA_CHANNEL(index, rx, RX, PERIPHERAL, MEMORY)\t\t\\ \tUART_DMA_CHANNEL(index, tx, TX, MEMORY, PERIPHERAL)\t\t\\ };\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ PM_DEVICE_DT_INST_DEFINE(index, uart_stm32_pm_action);\t\t        \\ \t\t\t\t\t\t\t\t\t\\ DEVICE_DT_INST_DEFINE(index,\t\t\t\t\t\t\\&uart_stm32_init,\t\t\t\t\t\\ \t\t    PM_DEVICE_DT_INST_GET(index),\t\t\t\\&uart_stm32_data_##index,&uart_stm32_cfg_##index,\t\\ \t\t    PRE_KERNEL_1, CONFIG_SERIAL_INIT_PRIORITY,\t\t\\&uart_stm32_driver_api);\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ STM32_UART_IRQ_HANDLER(index)\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ STM32_UART_CHECK_DT_PARITY(index)\t\t\t\t\t\\ STM32_UART_CHECK_DT_DATA_BITS(index)\t\t\t\t\t\\ STM32_UART_CHECK_DT_STOP_BITS_0_5(index)\t\t\t\t\\ STM32_UART_CHECK_DT_STOP_BITS_1_5(index)\n-value|\\ \t\t\t .subMode = DT_INST_PROP_OR(n, sub_mode, CY_SCB_SPI_MOTOROLA),             \\ \t\t\t .oversample =                                                             \\ \t\t\t\t DT_INST_PROP_OR(n, oversample, IFX_CAT1_SPI_DEFAULT_OVERSAMPLE),  \\ \t\t\t .enableFreeRunSclk = DT_INST_PROP_OR(n, enable_free_run_sclk, false),     \\ \t\t\t .enableInputFilter = DT_INST_PROP_OR(n, enable_input_filter, false),      \\ \t\t\t .enableMisoLateSample =                                                   \\ \t\t\t\t DT_INST_PROP_OR(n, enable_miso_late_sample, true),                \\ \t\t\t .enableTransferSeperation =                                               \\ \t\t\t\t DT_INST_PROP_OR(n, enable_transfer_seperation, false),            \\ \t\t\t .enableWakeFromSleep = DT_INST_PROP_OR(n, enableWakeFromSleep, false),    \\ \t\t\t .ssPolarity = DT_INST_PROP_OR(n, ss_polarity, CY_SCB_SPI_ACTIVE_LOW),     \\ \t\t\t .rxFifoTriggerLevel = DT_INST_PROP_OR(n, rx_fifo_trigger_level, 0),       \\ \t\t\t .rxFifoIntEnableMask = DT_INST_PROP_OR(n, rx_fifo_int_enable_mask, 0),    \\ \t\t\t .txFifoTriggerLevel = DT_INST_PROP_OR(n, tx_fifo_trigger_level, 0),       \\ \t\t\t .txFifoIntEnableMask = DT_INST_PROP_OR(n, tx_fifo_int_enable_mask, 0),    \\ \t\t\t .masterSlaveIntEnableMask =                                               \\ \t\t\t\t DT_INST_PROP_OR(n, master_slave_int_enable_mask, 0)},             \\                                                                                                    \\ \t\t.irq_priority = DT_INST_IRQ(n, priority),                                          \\ \t};                                                                                         \\ \tDEVICE_DT_INST_DEFINE(n,&ifx_cat1_spi_init, NULL,&spi_cat1_data_##n,                     \\&spi_cat1_config_##n, POST_KERNEL,                                   \\ \t\t\t      CONFIG_KERNEL_INIT_PRIORITY_DEVICE,&ifx_cat1_spi_api);\n+value|\\ \t\t\t .subMode = DT_INST_PROP_OR(n, sub_mode, CY_SCB_SPI_MOTOROLA),             \\ \t\t\t .oversample =                                                             \\ \t\t\t\t DT_INST_PROP_OR(n, oversample, IFX_CAT1_SPI_DEFAULT_OVERSAMPLE),  \\ \t\t\t .enableFreeRunSclk = DT_INST_PROP(n, enable_free_run_sclk),               \\ \t\t\t .enableInputFilter = DT_INST_PROP(n, enable_input_filter),                \\ \t\t\t .enableMisoLateSample =                                                   \\ \t\t\t\t DT_INST_PROP_OR(n, enable_miso_late_sample, true),                \\ \t\t\t .enableTransferSeperation =                                               \\ \t\t\t\t DT_INST_PROP(n, enable_transfer_seperation),                      \\ \t\t\t .enableWakeFromSleep = DT_INST_PROP(n, enableWakeFromSleep),              \\ \t\t\t .ssPolarity = DT_INST_PROP_OR(n, ss_polarity, CY_SCB_SPI_ACTIVE_LOW),     \\ \t\t\t .rxFifoTriggerLevel = DT_INST_PROP_OR(n, rx_fifo_trigger_level, 0),       \\ \t\t\t .rxFifoIntEnableMask = DT_INST_PROP_OR(n, rx_fifo_int_enable_mask, 0),    \\ \t\t\t .txFifoTriggerLevel = DT_INST_PROP_OR(n, tx_fifo_trigger_level, 0),       \\ \t\t\t .txFifoIntEnableMask = DT_INST_PROP_OR(n, tx_fifo_int_enable_mask, 0),    \\ \t\t\t .masterSlaveIntEnableMask =                                               \\ \t\t\t\t DT_INST_PROP_OR(n, master_slave_int_enable_mask, 0)},             \\                                                                                                    \\ \t\t.irq_priority = DT_INST_IRQ(n, priority),                                          \\ \t};                                                                                         \\ \tDEVICE_DT_INST_DEFINE(n,&ifx_cat1_spi_init, NULL,&spi_cat1_data_##n,                     \\&spi_cat1_config_##n, POST_KERNEL,                                   \\ \t\t\t      CONFIG_KERNEL_INIT_PRIORITY_DEVICE,&ifx_cat1_spi_api);\n-value|USBD_CLASS_DESCR_DEFINE(primary, x)\t\t\t\t\\ \tstruct usb_cdc_acm_config cdc_acm_cfg_##x = {\t\t\t\\ \t\tINITIALIZER_IAD\t\t\t\t\t\t\\ \t\t.if0 = INITIALIZER_IF(0, 1,\t\t\t\t\\ \t\t\t\tUSB_BCC_CDC_CONTROL,\t\t\t\\ \t\t\t\tACM_SUBCLASS),\t\t\t\t\\ \t\t.if0_header = INITIALIZER_IF_HDR,\t\t\t\\ \t\t.if0_cm = INITIALIZER_IF_CM,\t\t\t\t\\ \t\t.if0_acm = INITIALIZER_IF_ACM,\t\t\t\t\\ \t\t.if0_union = INITIALIZER_IF_UNION,\t\t\t\\ \t\t.if0_int_ep = INITIALIZER_IF_EP(AUTO_EP_IN,\t\t\\ \t\t\t\tUSB_DC_EP_INTERRUPT,\t\t\t\\ \t\t\t\tCONFIG_CDC_ACM_INTERRUPT_EP_MPS,\t\\ \t\t\t\t0x0A),\t\t\t\t\t\\ \t\t.if1 = INITIALIZER_IF(1, 2,\t\t\t\t\\ \t\t\t\tUSB_BCC_CDC_DATA,\t\t\t\\ \t\t\t\t0),\t\t\t\t\t\\ \t\t.if1_in_ep = INITIALIZER_IF_EP(AUTO_EP_IN,\t\t\\ \t\t\t\tUSB_DC_EP_BULK,\t\t\t\t\\ \t\t\t\tCONFIG_CDC_ACM_BULK_EP_MPS,\t\t\\ \t\t\t\t0x00),\t\t\t\t\t\\ \t\t.if1_out_ep = INITIALIZER_IF_EP(AUTO_EP_OUT,\t\t\\ \t\t\t\tUSB_DC_EP_BULK,\t\t\t\t\\ \t\t\t\tCONFIG_CDC_ACM_BULK_EP_MPS,\t\t\\ \t\t\t\t0x00),\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic struct usb_ep_cfg_data cdc_acm_ep_data_##x[] = {\t\t\\ \t\t{\t\t\t\t\t\t\t\\ \t\t\t.ep_cb = cdc_acm_int_in,\t\t\t\\ \t\t\t.ep_addr = AUTO_EP_IN,\t\t\t\t\\ \t\t},\t\t\t\t\t\t\t\\ \t\t{\t\t\t\t\t\t\t\\ \t\t\t.ep_cb = usb_transfer_ep_callback,\t\t\\ \t\t\t.ep_addr = AUTO_EP_OUT,\t\t\t\t\\ \t\t},\t\t\t\t\t\t\t\\ \t\t{\t\t\t\t\t\t\t\\ \t\t\t.ep_cb = usb_transfer_ep_callback,\t\t\\ \t\t\t.ep_addr = AUTO_EP_IN,\t\t\t\t\\ \t\t},\t\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tUSBD_DEFINE_CFG_DATA(cdc_acm_config_##x) = {\t\t\t\\ \t\t.usb_device_description = NULL,\t\t\t\t\\ \t\t.interface_config = cdc_interface_config,\t\t\\ \t\t.interface_descriptor =&cdc_acm_cfg_##x.if0,\t\t\\ \t\t.cb_usb_status = cdc_acm_dev_status_cb,\t\t\t\\ \t\t.interface = {\t\t\t\t\t\t\\ \t\t\t.class_handler = cdc_acm_class_handle_req,\t\\ \t\t\t.custom_handler = NULL,\t\t\t\t\\ \t\t},\t\t\t\t\t\t\t\\ \t\t.num_endpoints = ARRAY_SIZE(cdc_acm_ep_data_##x),\t\\ \t\t.endpoint = cdc_acm_ep_data_##x,\t\t\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tRING_BUF_DECLARE(cdc_acm_rx_rb_##x,\t\t\t\t\\ \t\t\t CONFIG_USB_CDC_ACM_RINGBUF_SIZE);\t\t\\ \tRING_BUF_DECLARE(cdc_acm_tx_rb_##x,\t\t\t\t\\ \t\t\t CONFIG_USB_CDC_ACM_RINGBUF_SIZE);\t\t\\ \tstatic struct cdc_acm_dev_data_t cdc_acm_dev_data_##x = {\t\\ \t\t.line_coding = CDC_ACM_DEFAULT_BAUDRATE,\t\t\\ \t\t.rx_ringbuf =&cdc_acm_rx_rb_##x,\t\t\t\\ \t\t.tx_ringbuf =&cdc_acm_tx_rb_##x,\t\t\t\\ \t\t.flow_ctrl = DT_INST_PROP_OR(x, hw_flow_control, false),\\ \t};\n+value|USBD_CLASS_DESCR_DEFINE(primary, x)\t\t\t\t\\ \tstruct usb_cdc_acm_config cdc_acm_cfg_##x = {\t\t\t\\ \t\tINITIALIZER_IAD\t\t\t\t\t\t\\ \t\t.if0 = INITIALIZER_IF(0, 1,\t\t\t\t\\ \t\t\t\tUSB_BCC_CDC_CONTROL,\t\t\t\\ \t\t\t\tACM_SUBCLASS),\t\t\t\t\\ \t\t.if0_header = INITIALIZER_IF_HDR,\t\t\t\\ \t\t.if0_cm = INITIALIZER_IF_CM,\t\t\t\t\\ \t\t.if0_acm = INITIALIZER_IF_ACM,\t\t\t\t\\ \t\t.if0_union = INITIALIZER_IF_UNION,\t\t\t\\ \t\t.if0_int_ep = INITIALIZER_IF_EP(AUTO_EP_IN,\t\t\\ \t\t\t\tUSB_DC_EP_INTERRUPT,\t\t\t\\ \t\t\t\tCONFIG_CDC_ACM_INTERRUPT_EP_MPS,\t\\ \t\t\t\t0x0A),\t\t\t\t\t\\ \t\t.if1 = INITIALIZER_IF(1, 2,\t\t\t\t\\ \t\t\t\tUSB_BCC_CDC_DATA,\t\t\t\\ \t\t\t\t0),\t\t\t\t\t\\ \t\t.if1_in_ep = INITIALIZER_IF_EP(AUTO_EP_IN,\t\t\\ \t\t\t\tUSB_DC_EP_BULK,\t\t\t\t\\ \t\t\t\tCONFIG_CDC_ACM_BULK_EP_MPS,\t\t\\ \t\t\t\t0x00),\t\t\t\t\t\\ \t\t.if1_out_ep = INITIALIZER_IF_EP(AUTO_EP_OUT,\t\t\\ \t\t\t\tUSB_DC_EP_BULK,\t\t\t\t\\ \t\t\t\tCONFIG_CDC_ACM_BULK_EP_MPS,\t\t\\ \t\t\t\t0x00),\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic struct usb_ep_cfg_data cdc_acm_ep_data_##x[] = {\t\t\\ \t\t{\t\t\t\t\t\t\t\\ \t\t\t.ep_cb = cdc_acm_int_in,\t\t\t\\ \t\t\t.ep_addr = AUTO_EP_IN,\t\t\t\t\\ \t\t},\t\t\t\t\t\t\t\\ \t\t{\t\t\t\t\t\t\t\\ \t\t\t.ep_cb = usb_transfer_ep_callback,\t\t\\ \t\t\t.ep_addr = AUTO_EP_OUT,\t\t\t\t\\ \t\t},\t\t\t\t\t\t\t\\ \t\t{\t\t\t\t\t\t\t\\ \t\t\t.ep_cb = usb_transfer_ep_callback,\t\t\\ \t\t\t.ep_addr = AUTO_EP_IN,\t\t\t\t\\ \t\t},\t\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tUSBD_DEFINE_CFG_DATA(cdc_acm_config_##x) = {\t\t\t\\ \t\t.usb_device_description = NULL,\t\t\t\t\\ \t\t.interface_config = cdc_interface_config,\t\t\\ \t\t.interface_descriptor =&cdc_acm_cfg_##x.if0,\t\t\\ \t\t.cb_usb_status = cdc_acm_dev_status_cb,\t\t\t\\ \t\t.interface = {\t\t\t\t\t\t\\ \t\t\t.class_handler = cdc_acm_class_handle_req,\t\\ \t\t\t.custom_handler = NULL,\t\t\t\t\\ \t\t},\t\t\t\t\t\t\t\\ \t\t.num_endpoints = ARRAY_SIZE(cdc_acm_ep_data_##x),\t\\ \t\t.endpoint = cdc_acm_ep_data_##x,\t\t\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tRING_BUF_DECLARE(cdc_acm_rx_rb_##x,\t\t\t\t\\ \t\t\t CONFIG_USB_CDC_ACM_RINGBUF_SIZE);\t\t\\ \tRING_BUF_DECLARE(cdc_acm_tx_rb_##x,\t\t\t\t\\ \t\t\t CONFIG_USB_CDC_ACM_RINGBUF_SIZE);\t\t\\ \tstatic struct cdc_acm_dev_data_t cdc_acm_dev_data_##x = {\t\\ \t\t.line_coding = CDC_ACM_DEFAULT_BAUDRATE,\t\t\\ \t\t.rx_ringbuf =&cdc_acm_rx_rb_##x,\t\t\t\\ \t\t.tx_ringbuf =&cdc_acm_tx_rb_##x,\t\t\t\\ \t\t.flow_ctrl = DT_INST_PROP(x, hw_flow_control),\t\t\\ \t};\nThe issue was with: drivers: use DT_INST_PROP over DT_INST_PROP_OR if possible\n\nIt might happens that DT(_INST)_PROP_OR is used with boolean properties.\nFor instance:\n\n\t.single_wire = DT_INST_PROP_OR(index, single_wire, false),\t\\\n\t.tx_rx_swap = DT_INST_PROP_OR(index, tx_rx_swap, false),\t\\\n\nThis is not required as boolean properties are generated with false\nvalue when not present, so the _OR macro extension is superflous\nand the above code can be replaced by:\n\n\t.single_wire = DT_INST_PROP(index, single_wire),\t\t\\\n\t.tx_rx_swap = DT_INST_PROP(index, tx_rx_swap),\t\t\t\\"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sensor: qdec_s32k: fix double promotion warning\n\nFixing this \\\"revealed\\\" bug which got introduced when\na PR added the -Wdouble-promotion flag to GCC builds Please fix this issue.",
  "input": "Faulty tokenized code:\nDECL|member|abs_counter\nname|int32_t\nname|abs_counter\ndecl_stmt|;\nDECL|member|micro_ticks_per_rev\nname|float\nname|micro_ticks_per_rev\ndecl_stmt|;\nDECL|member|ticks_per_sec\nname|uint32_t\nname|ticks_per_sec\nname|QDEC_NXP_S32_INIT\nparameter_list|(\nname|n\nparameter_list|)\ndefine|\\ \t\t\t\t\t\t\t\t\t\t\t\t\\\nvalue|static struct qdec_s32_data qdec_s32_##n##_data = {\t\t\t\t\t\\ \t\t.micro_ticks_per_rev = (float)(DT_INST_PROP(n, micro_ticks_per_rev) / 1000000),\t\\ \t\t.counter_CW = 1,\t\t\t\t\t\t\t\t\\ \t\t.counter_CCW = 1,\t\t\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tPINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t\t\t\t\\ \tTRGMUX_IP_INIT_CONFIG(n)\t\t\t\t\t\t\t\t\\ \tLCU_IP_INIT_CONFIG(n)\t\t\t\t\t\t\t\t\t\\ \tEMIOS_NXP_S32_MCB_OVERFLOW_CALLBACK(n)\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct qdec_s32_config qdec_s32_##n##_config = {\t\t\t\t\\ \t\t.emios_inst = EMIOS_NXP_S32_GET_INSTANCE(DT_INST_PHANDLE(n, emios)),\t\t\\ \t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\t\t\t\\ \t\t.trgmux_config =&Trgmux_Ip_Init_##n##_Config,\t\t\t\t\t\\ \t\t.lcu_config =&Lcu_Ip_Init_Config##n,\t\t\t\t\t\t\\ \t\t.emios_channels = {DT_INST_PROP_BY_IDX(n, emios_channels, EMIOS_CW_CH_IDX),\t\\ \t\t\t\t   DT_INST_PROP_BY_IDX(n, emios_channels, EMIOS_CCW_CH_IDX)},\t\\ \t\t.emios_cw_overflow_cb =&qdec##n##_emios_overflow_count_cw_callback,\t\t\\ \t\t.emios_ccw_overflow_cb =&qdec##n##_emios_overflow_count_ccw_callback,\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tSENSOR_DEVICE_DT_INST_DEFINE(n, qdec_s32_initialize, NULL,&qdec_s32_##n##_data,\t\\&qdec_s32_##n##_config, POST_KERNEL,\t\t\t\\ \t\t\t\t     CONFIG_SENSOR_INIT_PRIORITY,&qdec_s32_api);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|float\n+name|double\n-value|static struct qdec_s32_data qdec_s32_##n##_data = {\t\t\t\t\t\\ \t\t.micro_ticks_per_rev = (float)(DT_INST_PROP(n, micro_ticks_per_rev) / 1000000),\t\\ \t\t.counter_CW = 1,\t\t\t\t\t\t\t\t\\ \t\t.counter_CCW = 1,\t\t\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tPINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t\t\t\t\\ \tTRGMUX_IP_INIT_CONFIG(n)\t\t\t\t\t\t\t\t\\ \tLCU_IP_INIT_CONFIG(n)\t\t\t\t\t\t\t\t\t\\ \tEMIOS_NXP_S32_MCB_OVERFLOW_CALLBACK(n)\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct qdec_s32_config qdec_s32_##n##_config = {\t\t\t\t\\ \t\t.emios_inst = EMIOS_NXP_S32_GET_INSTANCE(DT_INST_PHANDLE(n, emios)),\t\t\\ \t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\t\t\t\\ \t\t.trgmux_config =&Trgmux_Ip_Init_##n##_Config,\t\t\t\t\t\\ \t\t.lcu_config =&Lcu_Ip_Init_Config##n,\t\t\t\t\t\t\\ \t\t.emios_channels = {DT_INST_PROP_BY_IDX(n, emios_channels, EMIOS_CW_CH_IDX),\t\\ \t\t\t\t   DT_INST_PROP_BY_IDX(n, emios_channels, EMIOS_CCW_CH_IDX)},\t\\ \t\t.emios_cw_overflow_cb =&qdec##n##_emios_overflow_count_cw_callback,\t\t\\ \t\t.emios_ccw_overflow_cb =&qdec##n##_emios_overflow_count_ccw_callback,\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tSENSOR_DEVICE_DT_INST_DEFINE(n, qdec_s32_initialize, NULL,&qdec_s32_##n##_data,\t\\&qdec_s32_##n##_config, POST_KERNEL,\t\t\t\\ \t\t\t\t     CONFIG_SENSOR_INIT_PRIORITY,&qdec_s32_api);\n+value|static struct qdec_s32_data qdec_s32_##n##_data = {\t\t\t\t\t\\ \t\t.micro_ticks_per_rev = (double)(DT_INST_PROP(n, micro_ticks_per_rev) / 1000000),\\ \t\t.counter_CW = 1,\t\t\t\t\t\t\t\t\\ \t\t.counter_CCW = 1,\t\t\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tPINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t\t\t\t\\ \tTRGMUX_IP_INIT_CONFIG(n)\t\t\t\t\t\t\t\t\\ \tLCU_IP_INIT_CONFIG(n)\t\t\t\t\t\t\t\t\t\\ \tEMIOS_NXP_S32_MCB_OVERFLOW_CALLBACK(n)\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct qdec_s32_config qdec_s32_##n##_config = {\t\t\t\t\\ \t\t.emios_inst = EMIOS_NXP_S32_GET_INSTANCE(DT_INST_PHANDLE(n, emios)),\t\t\\ \t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\t\t\t\\ \t\t.trgmux_config =&Trgmux_Ip_Init_##n##_Config,\t\t\t\t\t\\ \t\t.lcu_config =&Lcu_Ip_Init_Config##n,\t\t\t\t\t\t\\ \t\t.emios_channels = {DT_INST_PROP_BY_IDX(n, emios_channels, EMIOS_CW_CH_IDX),\t\\ \t\t\t\t   DT_INST_PROP_BY_IDX(n, emios_channels, EMIOS_CCW_CH_IDX)},\t\\ \t\t.emios_cw_overflow_cb =&qdec##n##_emios_overflow_count_cw_callback,\t\t\\ \t\t.emios_ccw_overflow_cb =&qdec##n##_emios_overflow_count_ccw_callback,\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tSENSOR_DEVICE_DT_INST_DEFINE(n, qdec_s32_initialize, NULL,&qdec_s32_##n##_data,\t\\&qdec_s32_##n##_config, POST_KERNEL,\t\t\t\\ \t\t\t\t     CONFIG_SENSOR_INIT_PRIORITY,&qdec_s32_api);\nThe issue was with: drivers: sensor: qdec_s32k: fix double promotion warning\n\nFixing this \\\"revealed\\\" bug which got introduced when\na PR added the -Wdouble-promotion flag to GCC builds"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: gpio: fix build of BD8LB600FS on intel_adl_crb\n\nFix the build of the gpio driver BD8LB600FS on the\nboard intel_adl_crb.\nFixes #68219. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nblock|}\nblock|}\nname|LOG_DBG\nargument_list|(\nliteral|\"%s: configuration for instance %i: %04X (position %i)\"\nargument_list|,\nname|dev\noperator|->\nname|name\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"%s: configuration for instance %i: %04X (position %i)\"\n+literal|\"%s: configuration for instance %zu: %04X (position %i)\"\nThe issue was with: drivers: gpio: fix build of BD8LB600FS on intel_adl_crb\n\nFix the build of the gpio driver BD8LB600FS on the\nboard intel_adl_crb.\nFixes #68219."
},{
  "instruction": "There is an issue in the following code. It relates to net: icmp: Don't report error on ICMP messages w/o handler\n\nICMPv4/6 modules print error when ICMP message handling fails, which\nincludes no message handler registered. This is a bit problematic, as\nthere are many ICMP messages that Zephyr does not process, and every\ntime such a message is received, an error log is printed (which wasn't\nthe case before ICMP rework).\n\nRestore the old behavior (no log on unrecognized ICMP message) by\nexplicitly filtering out ENOENT error code from printing error. That\nway, log will only be printed if an error occured within the actual\nmessage handler. Please fix this issue.",
  "input": "Faulty tokenized code:\nif|if\ncondition|(\nname|ret\noperator|<\nliteral|0\ncondition|)\nblock|{\nname|NET_ERR\nargument_list|(\nliteral|\"ICMPv4 handling failure (%d)\"\nif|if\ncondition|(\nname|ret\noperator|<\nliteral|0\ncondition|)\nblock|{\nname|NET_ERR\nargument_list|(\nliteral|\"ICMPv6 handling failure (%d)\"",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|&&\n+name|ret\n+operator|!=\n+operator|-\n+name|ENOENT\n+operator|&&\n+name|ret\n+operator|!=\n+operator|-\n+name|ENOENT\nThe issue was with: net: icmp: Don't report error on ICMP messages w/o handler\n\nICMPv4/6 modules print error when ICMP message handling fails, which\nincludes no message handler registered. This is a bit problematic, as\nthere are many ICMP messages that Zephyr does not process, and every\ntime such a message is received, an error log is printed (which wasn't\nthe case before ICMP rework).\n\nRestore the old behavior (no log on unrecognized ICMP message) by\nexplicitly filtering out ENOENT error code from printing error. That\nway, log will only be printed if an error occured within the actual\nmessage handler."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: i2s_nrfx: Generate master clock if pin is connected\n\nThe driver uses pinctrl to configure pins instead of nrfx I2S API.\nCheck whether MCK pin was actually connected by pinctrl instead of\ncomparing nrfx_cfg.mck_pin that is always NRF_I2S_PIN_NOT_CONNECTED.\n\nThis makes it possible for nRF I2S to provide master clock even when\noperating in I2S Slave mode. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|i2s_config\nmodifier|*\nname|i2s_cfg\nparameter_list|)\nblock|{\nDECL|struct|__anon27a1d07c0108\nspecifier|static\nspecifier|const\nstruct|struct\nblock|{\nDECL|member|ratio_val\nexpr_stmt|;\nblock|}\nblock|}\nelse|else\nblock|{\nDECL|struct|__anon27a1d07c0208\nspecifier|static\nspecifier|const\nstruct|struct\nblock|{\nDECL|member|divider_val\noperator|.\nname|mode\noperator|==\nname|NRF_I2S_MODE_MASTER\noperator|||\nname|nrfx_cfg\noperator|.\nname|mck_pin\noperator|!=\nname|NRF_I2S_PIN_NOT_CONNECTED\ncondition|)\nblock|{\nname|find_suitable_clock\nargument_list|(\nname|drv_cfg",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon27a1d07c0108\n+DECL|struct|__anon2b0bb8870108\n-DECL|struct|__anon27a1d07c0208\n+DECL|struct|__anon2b0bb8870208\n-name|nrfx_cfg\n+operator|(\n+name|nrf_i2s_mck_pin_get\n+argument_list|(\n+name|drv_cfg\n+operator|->\n+name|i2s\n-name|mck_pin\n-operator|!=\n-name|NRF_I2S_PIN_NOT_CONNECTED\n+name|p_reg\n+argument_list|)\n+operator|&\n+name|I2S_PSEL_MCK_CONNECT_Msk\n+operator|)\n+operator|==\n+name|I2S_PSEL_MCK_CONNECT_Connected\n+operator|<<\n+name|I2S_PSEL_MCK_CONNECT_Pos\nThe issue was with: drivers: i2s_nrfx: Generate master clock if pin is connected\n\nThe driver uses pinctrl to configure pins instead of nrfx I2S API.\nCheck whether MCK pin was actually connected by pinctrl instead of\ncomparing nrfx_cfg.mck_pin that is always NRF_I2S_PIN_NOT_CONNECTED.\n\nThis makes it possible for nRF I2S to provide master clock even when\noperating in I2S Slave mode."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: usb_dc_stm32: Fix OUT transfer issue\n\nThe driver cannot handle OUT transactions for an endpoint with an\nMPS smaller than 64 bytes. To solve the issue, we will not use one\nfixed value, EP_MPS, but instead use the actual MPS of an endpoint,\nep_state->ep_mps. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|ep\nargument_list|)\nindex|]\nargument_list|,\nname|EP_MPS\nargument_list|)\nreturn|;\nblock|}\nreturn|return\nliteral|0\nargument_list|(\nname|ep\nargument_list|)\nindex|]\nargument_list|,\nname|EP_MPS\nargument_list|)\nexpr_stmt|;\nblock|}\nreturn|return\nliteral|0",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|EP_MPS\n+name|ep_state\n+operator|->\n+name|ep_mps\n-name|EP_MPS\n+name|ep_state\n+operator|->\n+name|ep_mps\nThe issue was with: drivers: usb_dc_stm32: Fix OUT transfer issue\n\nThe driver cannot handle OUT transactions for an endpoint with an\nMPS smaller than 64 bytes. To solve the issue, we will not use one\nfixed value, EP_MPS, but instead use the actual MPS of an endpoint,\nep_state->ep_mps."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: gnss: lcx7g: Close pipe on suspend\n\nThe pipe should be closed when suspended, both to save ressources\nand to flush it. Without flushing the pipe, the driver may fail\nto either resume or suspend the GNSS as the chat module starts\nprocessing old data, which can contain acks to commands, breaking\nthe scripts. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|struct\nname|modem_chat_script\nname|dynamic_script\ndecl_stmt|;\ncomment|/* Allocation for responses from GNSS modem */\nDECL|union|__anon28e2f9af010a\nunion|union\nblock|{\nDECL|member|fix_rate_response\nname|uint16_t\nname|fix_rate_response\nname|LOG_ERR\nargument_list|(\nliteral|\"Failed to suspend GNSS\"\nargument_list|)\nexpr_stmt|;\nname|modem_pipe_close\nargument_list|(\nname|data\noperator|->\nname|uart_pipe\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|ret\nreturn|;\nblock|}\nname|LOG_INF\nargument_list|(\nliteral|\"Suspended\"\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|ret\nreturn|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon28e2f9af010a\n+DECL|union|__anon29fe55b1010a\n-name|modem_pipe_close\n+block|}\n+else|else\n+block|{\n+name|LOG_INF\n-name|data\n-operator|->\n-name|uart_pipe\n+literal|\"Suspended\"\n-return|return\n-name|ret\n-return|;\n-name|LOG_INF\n+name|modem_pipe_close\n-literal|\"Suspended\"\n+name|data\n+operator|->\n+name|uart_pipe\nThe issue was with: drivers: gnss: lcx7g: Close pipe on suspend\n\nThe pipe should be closed when suspended, both to save ressources\nand to flush it. Without flushing the pipe, the driver may fail\nto either resume or suspend the GNSS as the chat module starts\nprocessing old data, which can contain acks to commands, breaking\nthe scripts."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: gnss: lcx6g: Remove left over from testing\n\nThe k_msleep() removed with this has no utility. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|struct\nname|modem_chat_script\nname|dynamic_script\ndecl_stmt|;\ncomment|/* Allocation for responses from GNSS modem */\nDECL|union|__anon2b71d563010a\nunion|union\nblock|{\nDECL|member|fix_rate_response\nname|uint16_t\nname|fix_rate_response\nexpr_stmt|;\nreturn|return\nname|ret\nreturn|;\nblock|}\nname|k_msleep\nargument_list|(\nliteral|1000\nargument_list|)\nexpr_stmt|;\nname|ret\noperator|=\nname|quectel_lcx6g_configure_pps\nargument_list|(\nname|dev",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon2b71d563010a\n+DECL|union|__anon2c826eed010a\n-name|k_msleep\n-argument_list|(\n-literal|1000\n-argument_list|)\n-expr_stmt|;\nThe issue was with: drivers: gnss: lcx6g: Remove left over from testing\n\nThe k_msleep() removed with this has no utility."
},{
  "instruction": "There is an issue in the following code. It relates to net: shell: Clarify the name of the virtual interface\n\nThe net-shell printed virtual interface name so that it got\nthe impression it was the network interface name which is not\ncorrect. Now the name is printed as \\\"Virtual name\\\" which is\nunambiguous. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|\"<unknown>\"\nexpr_stmt|;\nblock|}\nname|PR\nargument_list|(\nliteral|\"Name      : %s\\n\"\nargument_list|,\nname|name\nargument_list|)\nexpr_stmt|;\nname|orig_iface",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"Name      : %s\\n\"\n+literal|\"Virtual name : %s\\n\"\nThe issue was with: net: shell: Clarify the name of the virtual interface\n\nThe net-shell printed virtual interface name so that it got\nthe impression it was the network interface name which is not\ncorrect. Now the name is printed as \\\"Virtual name\\\" which is\nunambiguous."
},{
  "instruction": "There is an issue in the following code. It relates to net: if: Do not join multicast address if IPv6 is not enabled\n\nIf IPv6 is not enabled for the interface, then do not try to\njoin the IPv6 solicited multicast address. Please fix this issue.",
  "input": "Faulty tokenized code:\nendif|#\ndirective|endif\nend_endif\n\nbegin_struct\nDECL|struct|__anon2a56fb810108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|ipv6\nname|struct\nname|CONFIG_NET_NATIVE_IPV4\nargument_list|)\nend_if\n\nbegin_struct\nDECL|struct|__anon2a56fb810208\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|ipv4\nname|struct\nblock|{\nname|struct\nname|net_if_ipv6\nmodifier|*\nname|ipv6\nname|__unused\ninit|=\nname|iface\noperator|->\nname|config\noperator|.\nname|ip\noperator|.\nname|ipv6\ndecl_stmt|;\nname|join_mcast_nodes\nargument_list|(\nname|iface\nargument_list|,\noperator|&\noperator|.\nname|in6_addr\nargument_list|)\nexpr_stmt|;\nblock|}\nname|net_if_start_rs\nargument_list|(\nname|iface\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2a56fb810108\n+DECL|struct|__anon29a4e7520108\n-DECL|struct|__anon2a56fb810208\n+DECL|struct|__anon29a4e7520208\n-name|__unused\n+if|if\n+condition|(\n+name|ipv6\n+operator|!=\n+name|NULL\n+condition|)\n+block|{\n+block|}\nThe issue was with: net: if: Do not join multicast address if IPv6 is not enabled\n\nIf IPv6 is not enabled for the interface, then do not try to\njoin the IPv6 solicited multicast address."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: Rename renesas ra driver\n\nNeed this rename to be able to target this driver\nin the \\\"Renesas RA\\\" maintainer area. Please fix this issue.",
  "input": "Faulty tokenized code:\nzephyr_library_sources_ifdef(CONFIG_UART_NUMAKER uart_numaker.c)\nzephyr_library_sources_ifdef(CONFIG_UART_EFINIX_SAPPIHIRE uart_efinix_sapphire.c)\nzephyr_library_sources_ifdef(CONFIG_UART_SEDI uart_sedi.c)\nzephyr_library_sources_ifdef(CONFIG_UART_BCM2711_MU uart_bcm2711.c)\nzephyr_library_sources_ifdef(CONFIG_UART_INTEL_LW uart_intel_lw.c)\nzephyr_library_sources_ifdef(CONFIG_UART_RA uart_ra.c)\nzephyr_library_sources_ifdef(CONFIG_UART_RZT2M uart_rzt2m.c)\n\nzephyr_library_sources_ifdef(CONFIG_USERSPACE   uart_handlers.c)\n\nif(CONFIG_UART_NATIVE_POSIX)\n\nsource \"drivers/serial/Kconfig.bcm2711\"\n\nsource \"drivers/serial/Kconfig.intel_lw\"\n\nsource \"drivers/serial/Kconfig.ra\"\n\nsource \"drivers/serial/Kconfig.rzt2m\"\n\nendif # SERIAL\nsimilarity index 93%\nrename from drivers/serial/Kconfig.ra\nrename to drivers/serial/Kconfig.renesas_ra\n# Copyright (c) 2023 TOKITA Hiroshi <tokita.hiroshi@fujitsu.com>\n# SPDX-License-Identifier: Apache-2.0\n\nconfig UART_RA\n\tbool \"Renesas RA Series UART Driver\"\n\tdefault y\n\tdepends on DT_HAS_RENESAS_RA_UART_SCI_ENABLED\n\tselect SERIAL_HAS_DRIVER\n\tselect SERIAL_SUPPORT_INTERRUPT\nsimilarity index 100%\nrename from drivers/serial/uart_ra.c\nrename to drivers/serial/uart_renesas_ra.c",
  "result": "I corrected the issue in the code by changing the following tokens:\n-zephyr_library_sources_ifdef(CONFIG_UART_RA uart_ra.c)\n+zephyr_library_sources_ifdef(CONFIG_UART_RENESAS_RA uart_renesas_ra.c)\n-source \"drivers/serial/Kconfig.ra\"\n+source \"drivers/serial/Kconfig.renesas_ra\"\n-config UART_RA\n+config UART_RENESAS_RA\nThe issue was with: drivers: serial: Rename renesas ra driver\n\nNeed this rename to be able to target this driver\nin the \\\"Renesas RA\\\" maintainer area."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: pinctrl: Rename renesas ra driver\n\nNeed this rename to be able to target this driver\nin the \\\"Renesas RA\\\" maintainer area. Please fix this issue.",
  "input": "Faulty tokenized code:\nzephyr_library_sources_ifdef(CONFIG_PINCTRL_TI_K3 pinctrl_ti_k3.c)\nzephyr_library_sources_ifdef(CONFIG_PINCTRL_EMSDP pinctrl_emsdp.c)\nzephyr_library_sources_ifdef(CONFIG_PINCTRL_TI_CC32XX pinctrl_ti_cc32xx.c)\nzephyr_library_sources_ifdef(CONFIG_PINCTRL_NUMAKER pinctrl_numaker.c)\nzephyr_library_sources_ifdef(CONFIG_PINCTRL_QUICKLOGIC_EOS_S3 pinctrl_eos_s3.c)\nzephyr_library_sources_ifdef(CONFIG_PINCTRL_RA pinctrl_ra.c)\nzephyr_library_sources_ifdef(CONFIG_PINCTRL_IMX_SCU pinctrl_imx_scu.c)\nzephyr_library_sources_ifdef(CONFIG_PINCTRL_RZT2M pinctrl_rzt2m.c)\nsource \"drivers/pinctrl/Kconfig.ti_k3\"\nsource \"drivers/pinctrl/Kconfig.emsdp\"\nsource \"drivers/pinctrl/Kconfig.ti_cc32xx\"\nsource \"drivers/pinctrl/Kconfig.numaker\"\nsource \"drivers/pinctrl/Kconfig.eos_s3\"\nsource \"drivers/pinctrl/Kconfig.ra\"\nsource \"drivers/pinctrl/Kconfig.rzt2m\"\nsource \"drivers/pinctrl/Kconfig.zynqmp\"\n\nendif # PINCTRL\nsimilarity index 91%\nrename from drivers/pinctrl/Kconfig.ra\nrename to drivers/pinctrl/Kconfig.renesas_ra\n# Copyright (c) 2023 TOKITA Hiroshi <tokita.hiroshi@fujitsu.com>\n# SPDX-License-Identifier: Apache-2.0\n\nconfig PINCTRL_RA\n\tbool \"Renesas RA series pin controller driver\"\n\tdefault y\n\tdepends on DT_HAS_RENESAS_RA_PINCTRL_ENABLED\n\thelp\n\t  Enable Renesas RA series pin controller driver.\nsimilarity index 100%\nrename from drivers/pinctrl/pinctrl_ra.c\nrename to drivers/pinctrl/pinctrl_renesas_ra.c",
  "result": "I corrected the issue in the code by changing the following tokens:\n-zephyr_library_sources_ifdef(CONFIG_PINCTRL_RA pinctrl_ra.c)\n+zephyr_library_sources_ifdef(CONFIG_PINCTRL_RENESAS_RA pinctrl_renesas_ra.c)\n-source \"drivers/pinctrl/Kconfig.ra\"\n+source \"drivers/pinctrl/Kconfig.renesas_ra\"\n-config PINCTRL_RA\n+config PINCTRL_RENESAS_RA\nThe issue was with: drivers: pinctrl: Rename renesas ra driver\n\nNeed this rename to be able to target this driver\nin the \\\"Renesas RA\\\" maintainer area."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: intc: Rename renesas ra driver\n\nNeed this rename to be able to target this driver\nin the \\\"Renesas RA\\\" maintainer area. Please fix this issue.",
  "input": "Faulty tokenized code:\nzephyr_library_sources_ifdef(CONFIG_NUCLEI_ECLIC            intc_nuclei_eclic.S)\nzephyr_library_sources_ifdef(CONFIG_NXP_S32_EIRQ            intc_eirq_nxp_s32.c)\nzephyr_library_sources_ifdef(CONFIG_NXP_S32_WKPU            intc_wkpu_nxp_s32.c)\nzephyr_library_sources_ifdef(CONFIG_XMC4XXX_INTC            intc_xmc4xxx.c)\nzephyr_library_sources_ifdef(CONFIG_NXP_PINT                intc_nxp_pint.c)\nzephyr_library_sources_ifdef(CONFIG_RENESAS_RA_ICU          intc_ra_icu.c)\nzephyr_library_sources_ifdef(CONFIG_NXP_IRQSTEER            intc_nxp_irqsteer.c)\n\nif(CONFIG_INTEL_VTD_ICTL)\n  zephyr_library_include_directories(${ZEPHYR_BASE}/arch/x86/include)\nendif()\n\nsource \"drivers/interrupt_controller/Kconfig.nxp_pint\"\n\nsource \"drivers/interrupt_controller/Kconfig.vim\"\n\nsource \"drivers/interrupt_controller/Kconfig.ra\"\n\nsource \"drivers/interrupt_controller/Kconfig.nxp_irqsteer\"\n\nendmenu\nsimilarity index 100%\nrename from drivers/interrupt_controller/Kconfig.ra\nrename to drivers/interrupt_controller/Kconfig.renesas_ra\nsimilarity index 100%\nrename from drivers/interrupt_controller/intc_ra_icu.c\nrename to drivers/interrupt_controller/intc_renesas_ra_icu.c",
  "result": "I corrected the issue in the code by changing the following tokens:\n-zephyr_library_sources_ifdef(CONFIG_RENESAS_RA_ICU          intc_ra_icu.c)\n+zephyr_library_sources_ifdef(CONFIG_RENESAS_RA_ICU          intc_renesas_ra_icu.c)\n-source \"drivers/interrupt_controller/Kconfig.ra\"\n+source \"drivers/interrupt_controller/Kconfig.renesas_ra\"\nThe issue was with: drivers: intc: Rename renesas ra driver\n\nNeed this rename to be able to target this driver\nin the \\\"Renesas RA\\\" maintainer area."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: gpio: Rename renesas ra driver\n\nNeed this rename to be able to target this driver\nin the \\\"Renesas RA\\\" maintainer area. Please fix this issue.",
  "input": "Faulty tokenized code:\nzephyr_library_sources_ifdef(CONFIG_GPIO_DAVINCI    gpio_davinci.c)\nzephyr_library_sources_ifdef(CONFIG_GPIO_SEDI    gpio_sedi.c)\nzephyr_library_sources_ifdef(CONFIG_GPIO_TLE9104    gpio_tle9104.c)\nzephyr_library_sources_ifdef(CONFIG_GPIO_ALTERA_PIO gpio_altera_pio.c)\nzephyr_library_sources_ifdef(CONFIG_GPIO_BCM2711    gpio_bcm2711.c)\nzephyr_library_sources_ifdef(CONFIG_GPIO_RA         gpio_ra.c)\nzephyr_library_sources_ifdef(CONFIG_GPIO_RZT2M    gpio_rzt2m.c)\nzephyr_library_sources_ifdef(CONFIG_GPIO_AMBIQ      gpio_ambiq.c)\n\nif (CONFIG_GPIO_EMUL_SDL)\n  zephyr_library_sources(gpio_emul_sdl.c)\n\nsource \"drivers/gpio/Kconfig.altera\"\n\nsource \"drivers/gpio/Kconfig.bcm2711\"\n\nsource \"drivers/gpio/Kconfig.ra\"\n\nsource \"drivers/gpio/Kconfig.rzt2m\"\n\nsource \"drivers/gpio/Kconfig.ambiq\"\n\nsimilarity index 92%\nrename from drivers/gpio/Kconfig.ra\nrename to drivers/gpio/Kconfig.renesas_ra\n# Copyright (c) 2023 TOKITA Hiroshi <tokita.hiroshi@fujitsu.com>\n# SPDX-License-Identifier: Apache-2.0\n\nconfig GPIO_RA\n\tbool \"Renesas RA Series GPIO driver\"\n\tdefault y\n\tselect GPIO_GET_CONFIG\n\tdepends on DT_HAS_RENESAS_RA_GPIO_ENABLED\n\thelp\nsimilarity index 100%\nrename from drivers/gpio/gpio_ra.c\nrename to drivers/gpio/gpio_renesas_ra.c",
  "result": "I corrected the issue in the code by changing the following tokens:\n-zephyr_library_sources_ifdef(CONFIG_GPIO_RA         gpio_ra.c)\n+zephyr_library_sources_ifdef(CONFIG_GPIO_RENESAS_RA gpio_renesas_ra.c)\n-source \"drivers/gpio/Kconfig.ra\"\n+source \"drivers/gpio/Kconfig.renesas_ra\"\n-config GPIO_RA\n+config GPIO_RENESAS_RA\nThe issue was with: drivers: gpio: Rename renesas ra driver\n\nNeed this rename to be able to target this driver\nin the \\\"Renesas RA\\\" maintainer area."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: clock: Rename renesas ra driver\n\nNeed this rename to be able to target this driver\nin the \\\"Renesas RA\\\" maintainer area. Please fix this issue.",
  "input": "Faulty tokenized code:\nzephyr_library_sources_ifdef(CONFIG_CLOCK_CONTROL_INFINEON_CAT1       clock_control_ifx_cat1.c)\nzephyr_library_sources_ifdef(CONFIG_CLOCK_CONTROL_SAM                 clock_control_sam_pmc.c)\nzephyr_library_sources_ifdef(CONFIG_CLOCK_CONTROL_SMARTBOND           clock_control_smartbond.c)\nzephyr_library_sources_ifdef(CONFIG_CLOCK_CONTROL_NUMAKER_SCC         clock_control_numaker_scc.c)\nzephyr_library_sources_ifdef(CONFIG_CLOCK_CONTROL_NXP_S32             clock_control_nxp_s32.c)\nzephyr_library_sources_ifdef(CONFIG_CLOCK_CONTROL_RA                  clock_control_ra.c)\nzephyr_library_sources_ifdef(CONFIG_CLOCK_CONTROL_AMBIQ               clock_control_ambiq.c)\nzephyr_library_sources_ifdef(CONFIG_CLOCK_CONTROL_PWM                 clock_control_pwm.c)\nzephyr_library_sources_ifdef(CONFIG_CLOCK_CONTROL_RPI_PICO            clock_control_rpi_pico.c)\n\n\n\nsource \"drivers/clock_control/Kconfig.nxp_s32\"\n\nsource \"drivers/clock_control/Kconfig.agilex5\"\n\nsource \"drivers/clock_control/Kconfig.ra\"\n\nsource \"drivers/clock_control/Kconfig.ambiq\"\n\nsource \"drivers/clock_control/Kconfig.pwm\"\n\nsimilarity index 90%\nrename from drivers/clock_control/Kconfig.ra\nrename to drivers/clock_control/Kconfig.renesas_ra\n# Copyright (c) 2023 TOKITA Hiroshi <tokita.hiroshi@fujitsu.com>\n# SPDX-License-Identifier: Apache-2.0\n\nconfig CLOCK_CONTROL_RA\n\tbool \"Renesas RA series clock generation circuit driver\"\n\tdefault y\n\tdepends on DT_HAS_RENESAS_RA_CLOCK_GENERATION_CIRCUIT_ENABLED\n\thelp\n\t  Enable Renesas RA series clock generation circuit driver.\nsimilarity index 100%\nrename from drivers/clock_control/clock_control_ra.c\nrename to drivers/clock_control/clock_control_renesas_ra.c",
  "result": "I corrected the issue in the code by changing the following tokens:\n-zephyr_library_sources_ifdef(CONFIG_CLOCK_CONTROL_RA                  clock_control_ra.c)\n+zephyr_library_sources_ifdef(CONFIG_CLOCK_CONTROL_RENESAS_RA          clock_control_renesas_ra.c)\n-source \"drivers/clock_control/Kconfig.ra\"\n+source \"drivers/clock_control/Kconfig.renesas_ra\"\n-config CLOCK_CONTROL_RA\n+config CLOCK_CONTROL_RENESAS_RA\nThe issue was with: drivers: clock: Rename renesas ra driver\n\nNeed this rename to be able to target this driver\nin the \\\"Renesas RA\\\" maintainer area."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: L2CAP: initialize `servers` slist\n\nSomehow it slipped through the cracks and didn't crash before. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_decl_stmt\nDECL|variable|servers\nspecifier|static\nname|sys_slist_t\nname|servers\ndecl_stmt|;\nend_decl_stmt\n\nbegin_function\nDECL|function|l2cap_tx_buf_destroy (struct bt_conn * conn,struct net_buf * buf,int err)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+init|=\n+name|SYS_SLIST_STATIC_INIT\n+argument_list|(\n+operator|&\n+name|servers\n+argument_list|)\nThe issue was with: Bluetooth: L2CAP: initialize `servers` slist\n\nSomehow it slipped through the cracks and didn't crash before."
},{
  "instruction": "There is an issue in the following code. It relates to arm64: smp: Fix cache operations in the SMP\n\nThe arm64_cpu_boot_params will be read on other cores\n\ncall sys_cache_data_flush_range flush the data from the cache to RAM.\n\nThis ensures that other cores can access the correct data. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|.\nname|mpid\noperator|=\nname|cpu_mpid\nexpr_stmt|;\nname|sys_cache_data_invd_range\nargument_list|(\noperator|(\nname|void\noperator|*\noperator|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|sys_cache_data_invd_range\n+name|sys_cache_data_flush_range\nThe issue was with: arm64: smp: Fix cache operations in the SMP\n\nThe arm64_cpu_boot_params will be read on other cores\n\ncall sys_cache_data_flush_range flush the data from the cache to RAM.\n\nThis ensures that other cores can access the correct data."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: i2s: i2s_mcux_flexcomm: Guard use of I2S_EnableSecondaryChannel\n\nGuard use of I2S_EnableSecondaryChannel behind the SDK feature macro\nthat determines if this support is available, since when this macro is\nnot defined the SDK function is not implemented.\n\nFixes #68136 Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|!=\nname|I2S_FMT_DATA_FORMAT_I2S\ncondition|)\nblock|{\ncomment|/* \t\t * More than 2 channels are enabled, so we need to enable \t\t * secondary channel pairs. \t\t */\nfor|for\ncontrol|(\nname|uint32_t\nname|slot\ninit|=\noperator|*\nname|slot\nargument_list|)\nexpr_stmt|;\nblock|}\nblock|}\ncomment|/* \t * I2S API definition specifies that a \"16 bit word will occupy 2 bytes, \t * a 24 or 32 bit word will occupy 4 bytes\". Therefore, we will assume \t * that \"odd\" word sizes will be aligned to 16 or 32 bit boundaries. \t * \t * FIFO depth is controlled by the number of bits per word (DATALEN). \t * Per the RM: \t * If the data length is 4-16, the FIFO should be filled \t * with two 16 bit values (one for left, one for right channel) \t * \t * If the data length is 17-24, the FIFO should be filled with 2 24 bit \t * values (one for left, one for right channel). We can just transfer \t * 4 bytes, since the I2S API specifies 24 bit values would be aligned \t * to a 32 bit boundary. \t * \t * If the data length is 25-32, the FIFO should be filled \t * with one 32 bit value. First value is left channel, second is right. \t * \t * All this is to say that we can always use 4 byte transfer widths \t * with the DMA engine, regardless of the data length. \t */\nname|stream\noperator|->\nname|dma_cfg",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|#\n+directive|if\n+operator|(\n+name|defined\n+argument_list|(\n+name|FSL_FEATURE_I2S_SUPPORT_SECONDARY_CHANNEL\n+argument_list|)\n+operator|&&\n+expr|\\\n+name|FSL_FEATURE_I2S_SUPPORT_SECONDARY_CHANNEL\n+operator|)\n+else|#\n+directive|else\n+comment|/* No support */\n+return|return\n+operator|-\n+name|ENOTSUP\n+return|;\n+endif|#\n+directive|endif\nThe issue was with: drivers: i2s: i2s_mcux_flexcomm: Guard use of I2S_EnableSecondaryChannel\n\nGuard use of I2S_EnableSecondaryChannel behind the SDK feature macro\nthat determines if this support is available, since when this macro is\nnot defined the SDK function is not implemented.\n\nFixes #68136"
},{
  "instruction": "There is an issue in the following code. It relates to net: wifi: Make sure scan band string is null terminated\n\nMake sure that scan band string is properly terminated when\nparsing user supplied string.\n\nFixes: #67944\nCoverity-CID: 342930 Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nsizeof|sizeof\nargument_list|(\nname|parse_str\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|band_str\noperator|=\nname|strtok_r\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|-\n+literal|1\n+argument_list|)\n+expr_stmt|;\n+name|parse_str\n+index|[\n+sizeof|sizeof\n+argument_list|(\n+name|parse_str\n+operator|-\n+literal|1\n+index|]\n+operator|=\n+literal|'\\0'\nThe issue was with: net: wifi: Make sure scan band string is null terminated\n\nMake sure that scan band string is properly terminated when\nparsing user supplied string.\n\nFixes: #67944\nCoverity-CID: 342930"
},{
  "instruction": "There is an issue in the following code. It relates to net: lwm2m: Use CID_SUPPORTED instead of CID_ENABLED\n\nWhen ENABLED flag is used, we generate 32 byte DTLS\nConnection Identifier and include that in our\nDTLS Client HELO. This has no benefit as client only\nhas one connection toward the server, it does not need\nany identification.\n\nWhen SUPPORTED flag is used, we just include\nzero length Connection Identifier in the handshake,\nwhich tell server that we support Connection Identifier\nand server can generate one for it.\nWe then use the CID in the packets that we send towards\nserver, but response packets don't contain any CID.\nThis gives all the benefit of CID as server is able to\nidentify us even when NAT mapping have changed. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\ncomment|/* Enable CID */\nname|int\nname|cid\ninit|=\nname|TLS_DTLS_CID_ENABLED\ndecl_stmt|;\nname|ret\noperator|=\nname|zsock_setsockopt\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|TLS_DTLS_CID_ENABLED\n+name|TLS_DTLS_CID_SUPPORTED\nThe issue was with: net: lwm2m: Use CID_SUPPORTED instead of CID_ENABLED\n\nWhen ENABLED flag is used, we generate 32 byte DTLS\nConnection Identifier and include that in our\nDTLS Client HELO. This has no benefit as client only\nhas one connection toward the server, it does not need\nany identification.\n\nWhen SUPPORTED flag is used, we just include\nzero length Connection Identifier in the handshake,\nwhich tell server that we support Connection Identifier\nand server can generate one for it.\nWe then use the CID in the packets that we send towards\nserver, but response packets don't contain any CID.\nThis gives all the benefit of CID as server is able to\nidentify us even when NAT mapping have changed."
},{
  "instruction": "There is an issue in the following code. It relates to tests: net: dhcpv4: Move DHCPv4 client tests to subdirectory\n\nMove DHCPv4 client tests to subdirectory, to make room for DHCPv4 server\ntests.\n\nRename test project to dhcpv4_client to better reflect its purpose. Please fix this issue.",
  "input": "Faulty tokenized code:\nsimilarity index 92%\nrename from tests/net/dhcpv4/CMakeLists.txt\nrename to tests/net/dhcpv4/client/CMakeLists.txt\n# SPDX-License-Identifier: Apache-2.0\n\ncmake_minimum_required(VERSION 3.20.0)\nfind_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})\nproject(dhcpv4)\n\ntarget_include_directories(app PRIVATE ${ZEPHYR_BASE}/subsys/net/ip)\nFILE(GLOB app_sources src/*.c)\ntarget_sources(app PRIVATE ${app_sources})\nsimilarity index 100%\nrename from tests/net/dhcpv4/prj.conf\nrename to tests/net/dhcpv4/client/prj.conf\nsimilarity index 100%\nrename from tests/net/dhcpv4/src/main.c\nrename to tests/net/dhcpv4/client/src/main.c\nsimilarity index 75%\nrename from tests/net/dhcpv4/testcase.yaml\nrename to tests/net/dhcpv4/client/testcase.yaml\n  depends_on: netif\n  tags:\n    - net\n    - dhcpv4\ntests:\n net.dhcp:\n    extra_configs:\n      - CONFIG_NET_TC_THREAD_COOPERATIVE=y\n net.dhcp.preempt:\n    extra_configs:\n      - CONFIG_NET_TC_THREAD_PREEMPTIVE=y\n net.dhcp.optioncbs:\n    extra_configs:\n      - CONFIG_NET_DHCPV4_OPTION_CALLBACKS=y",
  "result": "I corrected the issue in the code by changing the following tokens:\n-project(dhcpv4)\n+project(dhcpv4_client)\n-  net.dhcp:\n+  net.dhcpv4_client:\n-  net.dhcp.preempt:\n+  net.dhcpv4_client.preempt:\n-  net.dhcp.optioncbs:\n+  net.dhcpv4_client.optioncbs:\nThe issue was with: tests: net: dhcpv4: Move DHCPv4 client tests to subdirectory\n\nMove DHCPv4 client tests to subdirectory, to make room for DHCPv4 server\ntests.\n\nRename test project to dhcpv4_client to better reflect its purpose."
},{
  "instruction": "There is an issue in the following code. It relates to hostap: Change the name of the control api struct\n\nZephyr requires that the name of the variable is not the\nsame as the struct as seen by this warning:\n\nmodules/hostap/src/supp_api.c:64:WARNING:\n  Violation to rule 5.7 (Tag name should be unique)\n  tag: wpa_supp_api_ctrl Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nstruct|;\nend_struct\n\nbegin_decl_stmt\nDECL|variable|wpa_supp_api_ctrl\nspecifier|static\nname|struct\nname|wpa_supp_api_ctrl\nname|wpa_supp_api_ctrl\ndecl_stmt|;\nend_decl_stmt\n\nbegin_function_decl\nspecifier|static\nname|wpa_supp_api_ctrl\nmodifier|*\nname|ctrl\ninit|=\noperator|&\nname|wpa_supp_api_ctrl\ndecl_stmt|;\nname|k_mutex_lock\nargument_list|(\noperator|&\nname|wpa_supplicant_mutex\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\ncomment|/* Terminate synchronously */\nname|wpa_supp_api_ctrl\noperator|.\nname|terminate\noperator|=\nliteral|1\nexpr_stmt|;\nargument_list|(\noperator|&\nname|wpa_supp_status_work\nargument_list|,\noperator|&\nname|wpa_supp_api_ctrl\noperator|.\nname|sync\nargument_list|)\nexpr_stmt|;\nname|wpa_supp_api_ctrl\noperator|.\nname|terminate\noperator|=\nliteral|0\nexpr_stmt|;\nname|resp\noperator|.\nname|network_id\nargument_list|)\nexpr_stmt|;\nname|wpa_supp_api_ctrl\noperator|.\nname|dev\noperator|=\nname|dev\nexpr_stmt|;\nname|wpa_supp_api_ctrl\noperator|.\nname|requested_op\noperator|=\nname|CONNECT\nexpr_stmt|;\nname|wpa_supp_api_ctrl\noperator|.\nname|connection_timeout\noperator|=\nname|params\noperator|->\nexpr_stmt|;\ngoto|goto\nname|out\ngoto|;\nblock|}\nname|wpa_supp_api_ctrl\noperator|.\nname|dev\noperator|=\nname|dev\nexpr_stmt|;\nname|wpa_supp_api_ctrl\noperator|.\nname|requested_op\noperator|=\nname|DISCONNECT\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|variable|wpa_supp_api_ctrl\n+DECL|variable|wpas_api_ctrl\n-name|wpa_supp_api_ctrl\n+name|wpas_api_ctrl\n-name|wpa_supp_api_ctrl\n+name|wpas_api_ctrl\n-name|wpa_supp_api_ctrl\n+name|wpas_api_ctrl\n-name|wpa_supp_api_ctrl\n+name|wpas_api_ctrl\n-name|wpa_supp_api_ctrl\n+name|wpas_api_ctrl\n-name|wpa_supp_api_ctrl\n+name|wpas_api_ctrl\n-name|wpa_supp_api_ctrl\n+name|wpas_api_ctrl\n-name|wpa_supp_api_ctrl\n+name|wpas_api_ctrl\n-name|wpa_supp_api_ctrl\n+name|wpas_api_ctrl\n-name|wpa_supp_api_ctrl\n+name|wpas_api_ctrl\nThe issue was with: hostap: Change the name of the control api struct\n\nZephyr requires that the name of the variable is not the\nsame as the struct as seen by this warning:\n\nmodules/hostap/src/supp_api.c:64:WARNING:\n  Violation to rule 5.7 (Tag name should be unique)\n  tag: wpa_supp_api_ctrl"
},{
  "instruction": "There is an issue in the following code. It relates to hostap: Align to Zephyr coding style\n\nTweaked the code to be more readable and align to\nZephyr coding style. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|)\nblock|{\ncomment|/* We use global channel list here and also use the widest \t * op_class for 5GHz channels as there is no user input \t * for these (yet). \t */\nname|int\nname|freq\ninit|=\nname|ieee80211_chan_to_freq\nargument_list|(\nname|NULL\nargument_list|,\nliteral|81\nargument_list|,\nname|chan\nargument_list|)\ndecl_stmt|;\nif|if\ncondition|(\nname|freq\noperator|<=\nliteral|0\ncondition|(\nname|_res\noperator|<\nliteral|0\ncondition|)\nname|ssid_len\noperator|=\nliteral|0\nexpr_stmt|;\nelse|else\nname|ssid_len\noperator|=\nname|cli_status\noperator|.\nname|ssid_len\nexpr_stmt|;\nname|_ssid\noperator|=\nname|cli_status\noperator|.\nname|ssid",
  "result": "I corrected the issue in the code by changing the following tokens:\n-init|=\n+decl_stmt|;\n+name|freq\n+operator|=\n-decl_stmt|;\n+expr_stmt|;\n+block|{\n+block|}\n+block|{\n+block|}\nThe issue was with: hostap: Align to Zephyr coding style\n\nTweaked the code to be more readable and align to\nZephyr coding style."
},{
  "instruction": "There is an issue in the following code. It relates to posix: pthread: initialize t and c pointers to NULL\n\n* initialize posix_thread and __pthread_cleanup ptrs to NULL\n* check ret is zero before finalizing a thread in pthread_cancel() Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nname|struct\nname|posix_thread\nmodifier|*\nname|t\ndecl_stmt|;\nname|struct\nname|__pthread_cleanup\nmodifier|*\nspecifier|const\ndecl_stmt|;\nname|struct\nname|__pthread_cleanup\nmodifier|*\nname|c\ndecl_stmt|;\nname|struct\nname|posix_thread\nmodifier|*\nname|t\ndecl_stmt|;\nname|K_SPINLOCK\nargument_list|(\nargument|&pthread_pool_lock\nargument_list|)\ndecl_stmt|;\nname|struct\nname|posix_thread\nmodifier|*\nname|t\ndecl_stmt|;\nname|K_SPINLOCK\nargument_list|(\nargument|&pthread_pool_lock\nargument_list|)\nname|canceltype\nexpr_stmt|;\nblock|}\nif|if\ncondition|(\nname|cancel_state\noperator|==\nname|PTHREAD_CANCEL_ENABLE\noperator|&&\nname|cancel_type\ninit|=\nliteral|0\ndecl_stmt|;\nname|int\nname|new_prio\ndecl_stmt|;\nname|struct\nname|posix_thread\nmodifier|*\nname|t\ndecl_stmt|;\nif|if\ncondition|(\nname|param\noperator|==\ndecl_stmt|;\nname|struct\nname|posix_thread\nmodifier|*\nname|t\ndecl_stmt|;\nif|if\ncondition|(\nname|pthread\noperator|==",
  "result": "I corrected the issue in the code by changing the following tokens:\n+init|=\n+name|NULL\n+init|=\n+name|NULL\n+init|=\n+name|NULL\n+init|=\n+name|NULL\n+name|ret\n+operator|==\n+literal|0\n+operator|&&\n+init|=\n+name|K_LOWEST_APPLICATION_THREAD_PRIO\n+init|=\n+name|NULL\n+init|=\n+name|NULL\nThe issue was with: posix: pthread: initialize t and c pointers to NULL\n\n* initialize posix_thread and __pthread_cleanup ptrs to NULL\n* check ret is zero before finalizing a thread in pthread_cancel()"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: can: stm32: bxcan: store current operation mode\n\nStore the current operation mode in the can_driver_data structure.\n\nFixes: be9e58409aa53a54cf7eb257d7e07690fd17ba60 [formerly 9051824fa3f1b2d22163e27abef8061c6242464e] Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|&=\noperator|~\nname|CAN_MCR_NART\nexpr_stmt|;\nblock|}\nname|k_mutex_unlock\nargument_list|(\noperator|&\nname|data\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|data\n+operator|->\n+name|common\n+operator|.\n+name|mode\n+operator|=\n+name|mode\n+expr_stmt|;\nThe issue was with: drivers: can: stm32: bxcan: store current operation mode\n\nStore the current operation mode in the can_driver_data structure.\n\nFixes: be9e58409aa53a54cf7eb257d7e07690fd17ba60 [formerly 9051824fa3f1b2d22163e27abef8061c6242464e]"
},{
  "instruction": "There is an issue in the following code. It relates to drivers/entropy/native: Define required SOURCE macro\n\nThe srandom function is not available\nunless _XOPEN_SOURCE is set > 500 or an equivalent\ndeclaration is done.\nLet's set it. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright (c) 2024 Nordic Semiconductor ASA  *  * SPDX-License-Identifier: Apache-2.0  *  * Bottom/Linux side of the pseudo-random entropy generator for  * ARCH_POSIX architecture  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nfile|<stdbool.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_undef\n+undef|#\n+directive|undef\n+name|_XOPEN_SOURCE\n+end_undef\n+\n+begin_define\n+DECL|macro|_XOPEN_SOURCE\n+define|#\n+directive|define\n+name|_XOPEN_SOURCE\n+value|700\n+end_define\n+\nThe issue was with: drivers/entropy/native: Define required SOURCE macro\n\nThe srandom function is not available\nunless _XOPEN_SOURCE is set > 500 or an equivalent\ndeclaration is done.\nLet's set it."
},{
  "instruction": "There is an issue in the following code. It relates to subsys/net/lib/lwm2m: Define required source standard macros\n\nInstead of relaying on those macros having been defined\nsomewhere else let's define them for this file. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|LOG_LEVEL\nvalue|CONFIG_LWM2M_LOG_LEVEL\nend_define\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/logging/log.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_undef\n+undef|#\n+directive|undef\n+name|_POSIX_C_SOURCE\n+end_undef\n+\n+begin_define\n+DECL|macro|_POSIX_C_SOURCE\n+define|#\n+directive|define\n+name|_POSIX_C_SOURCE\n+value|200809L\n+end_define\n+\n+begin_comment\n+DECL|macro|_POSIX_C_SOURCE\n+comment|/* Required for gmtime_r */\n+end_comment\n+\nThe issue was with: subsys/net/lib/lwm2m: Define required source standard macros\n\nInstead of relaying on those macros having been defined\nsomewhere else let's define them for this file."
},{
  "instruction": "There is an issue in the following code. It relates to tests/bluetooth/uuid: Define required source standard macros\n\nstrnlen is not a C standard API, but an extension.\nInstead of relaying that the SOURCE macro was set somewhere else\nof that the C library provides a prototype anyhow\nlet's explicitly define it for this library. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/* Copyright (c) 2022 Nordic Semiconductor ASA  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nfile|<stdbool.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_undef\n+undef|#\n+directive|undef\n+name|_POSIX_C_SOURCE\n+end_undef\n+\n+begin_define\n+DECL|macro|_POSIX_C_SOURCE\n+define|#\n+directive|define\n+name|_POSIX_C_SOURCE\n+value|200809L\n+end_define\n+\nThe issue was with: tests/bluetooth/uuid: Define required source standard macros\n\nstrnlen is not a C standard API, but an extension.\nInstead of relaying that the SOURCE macro was set somewhere else\nof that the C library provides a prototype anyhow\nlet's explicitly define it for this library."
},{
  "instruction": "There is an issue in the following code. It relates to tests/benchmarks/footprints: Define required source standard macros\n\nstrnlen is not a C standard API, but an extension.\nInstead of relaying that the SOURCE macro was set somewhere else\nof that the C library provides a prototype anyhow\nlet's explicitly define it for this library. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright (c) 2020 Intel Corporation.  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/kernel.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_undef\n+undef|#\n+directive|undef\n+name|_POSIX_C_SOURCE\n+end_undef\n+\n+begin_define\n+DECL|macro|_POSIX_C_SOURCE\n+define|#\n+directive|define\n+name|_POSIX_C_SOURCE\n+value|200809L\n+end_define\n+\nThe issue was with: tests/benchmarks/footprints: Define required source standard macros\n\nstrnlen is not a C standard API, but an extension.\nInstead of relaying that the SOURCE macro was set somewhere else\nof that the C library provides a prototype anyhow\nlet's explicitly define it for this library."
},{
  "instruction": "There is an issue in the following code. It relates to drivers rtc: Do not treat the host libC differently\n\nThis code was using strptime from the C library in some cases,\nbut this function is an extension which many embedded libCs do\nnot provide, and which is not provided by default unless\n_XOPEN_SOURCE or a similar macro is defined before the system headers\nare included.\n\nWe could define _XOPEN_SOURCE for the libraries that provide it,\nbut instead of treating the host C library differently than\nembedded libraries, let's just build the provided version always,\nas that should provide better coverage of this code.\n\nNote: It seems picolibc's strptime is broken,\nuntil this very recent patch:\nhttps://github.com/picolibc/picolibc/pull/657\nso we should not select it when building for this library\nfor a while either. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\nDECL|variable|format_date\ncomment|/* yyyy-mm-dd */\nend_comment\n\nbegin_if\nif|#\ndirective|if\noperator|!\nname|defined\nname|CONFIG_BOARD_NATIVE_POSIX\nend_if\n\nbegin_function\nDECL|function|consume_chars (const char * s,char * dest,unsigned int cnt)\nspecifier|static\nspecifier|const\nname|char\nreturn|;\nblock|}\nblock|}\nend_function\n\nbegin_endif\nendif|#\ndirective|endif\nend_endif\n\nbegin_function\nDECL|function|cmd_set (const struct shell * sh,size_t argc,char ** argv)\nspecifier|static\nname|int\nname|cmd_set",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_if\n-if|#\n-directive|if\n-operator|!\n-name|defined\n-name|CONFIG_BOARD_NATIVE_POSIX\n-end_if\n-\n-begin_endif\n-endif|#\n-directive|endif\n-end_endif\n-\nThe issue was with: drivers rtc: Do not treat the host libC differently\n\nThis code was using strptime from the C library in some cases,\nbut this function is an extension which many embedded libCs do\nnot provide, and which is not provided by default unless\n_XOPEN_SOURCE or a similar macro is defined before the system headers\nare included.\n\nWe could define _XOPEN_SOURCE for the libraries that provide it,\nbut instead of treating the host C library differently than\nembedded libraries, let's just build the provided version always,\nas that should provide better coverage of this code.\n\nNote: It seems picolibc's strptime is broken,\nuntil this very recent patch:\nhttps://github.com/picolibc/picolibc/pull/657\nso we should not select it when building for this library\nfor a while either."
},{
  "instruction": "There is an issue in the following code. It relates to posix: Use _POSIX_C_SOURCE=200809L instead of 200809\n\nThis constant is supposed to be defined as a long instead of an int,\npresumably to support systems where int isn't large enough. Please fix this issue.",
  "input": "Faulty tokenized code:\n  zephyr_link_libraries($<TARGET_PROPERTY:linker,gprof>)\n\n  target_link_options(native_simulator INTERFACE \"-pg\")\nendif()\n\nzephyr_compile_definitions(_POSIX_C_SOURCE=200809 _XOPEN_SOURCE=600 _XOPEN_SOURCE_EXTENDED)\n\nif (CONFIG_NATIVE_APPLICATION)\n  zephyr_ld_options(\n    -ldl\n    -pthread\nname|hw_counter_timer\ndecl_stmt|;\nend_decl_stmt\n\nbegin_enum\nDECL|enum|__anon293619e50103\nspecifier|static\nenum|enum\nblock|{\nDECL|enumerator|HWTIMER\nname|HWTIMER\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_comment\ncomment|/**  * Set the handler for SIGTERM and SIGINT which will cause the  * program to exit gracefully when they are received the 1st time  *  * Note that our handler only sets a variable indicating the signal was  * received, and in each iteration of the hw main loop this variable is  * evaluated.  * If for some reason (the program is stuck) we never evaluate it, the program  * would never exit.  * Therefore we set SA_RESETHAND: This way, the 2nd time the signal is received  * the default handler would be called to terminate the program no matter what.  *  * Note that SA_RESETHAND requires either _POSIX_C_SOURCE>=200809 or  * _XOPEN_SOURCE>=500  */\nend_comment\n\nbegin_function\nDECL|function|hwm_set_sig_handler (void)\nname|void\n#  Build optimization level (by default disabled to ease debugging)\nNSI_OPT?=-O0\n#  Warnings switches (for the runner itself)\nNSI_WARNINGS?=-Wall -Wpedantic\n#  Preprocessor flags\nNSI_CPPFLAGS?=-D_POSIX_C_SOURCE=200809 -D_XOPEN_SOURCE=600 -D_XOPEN_SOURCE_EXTENDED\n\nNO_PIE_CO:=-fno-pie -fno-pic\nDEPENDFLAGS:=-MMD -MP\nCFLAGS:=${NSI_DEBUG} ${NSI_WARNINGS} ${NSI_OPT} ${NO_PIE_CO} -DNSI_N_CPUS=${NSI_N_CPUS} \\\n  -ffunction-sections -fdata-sections ${DEPENDFLAGS} -std=c11 ${NSI_BUILD_OPTIONS}\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_comment\ncomment|/**  * Set the handler for SIGTERM and SIGINT which will cause the  * program to exit gracefully when they are received the 1st time  *  * Note that our handler only sets a variable indicating the signal was  * received, and in each iteration of the hw main loop this variable is  * evaluated.  * If for some reason (the program is stuck) we never evaluate it, the program  * would never exit.  * Therefore we set SA_RESETHAND: This way, the 2nd time the signal is received  * the default handler would be called to terminate the program no matter what.  *  * Note that SA_RESETHAND requires either _POSIX_C_SOURCE>=200809 or  * _XOPEN_SOURCE>=500  */\nend_comment\n\nbegin_function\nDECL|function|nsi_hws_set_sig_handler (void)\nspecifier|static\nbegin_define\nDECL|macro|_POSIX_C_SOURCE\ndefine|#\ndirective|define\nname|_POSIX_C_SOURCE\nvalue|200809\nend_define\n\nbegin_endif\nendif|#\ndirective|endif",
  "result": "I corrected the issue in the code by changing the following tokens:\n-zephyr_compile_definitions(_POSIX_C_SOURCE=200809 _XOPEN_SOURCE=600 _XOPEN_SOURCE_EXTENDED)\n+zephyr_compile_definitions(_POSIX_C_SOURCE=200809L _XOPEN_SOURCE=600 _XOPEN_SOURCE_EXTENDED)\n-DECL|enum|__anon293619e50103\n+DECL|enum|__anon28f64d1b0103\n-comment|/**  * Set the handler for SIGTERM and SIGINT which will cause the  * program to exit gracefully when they are received the 1st time  *  * Note that our handler only sets a variable indicating the signal was  * received, and in each iteration of the hw main loop this variable is  * evaluated.  * If for some reason (the program is stuck) we never evaluate it, the program  * would never exit.  * Therefore we set SA_RESETHAND: This way, the 2nd time the signal is received  * the default handler would be called to terminate the program no matter what.  *  * Note that SA_RESETHAND requires either _POSIX_C_SOURCE>=200809 or  * _XOPEN_SOURCE>=500  */\n+comment|/**  * Set the handler for SIGTERM and SIGINT which will cause the  * program to exit gracefully when they are received the 1st time  *  * Note that our handler only sets a variable indicating the signal was  * received, and in each iteration of the hw main loop this variable is  * evaluated.  * If for some reason (the program is stuck) we never evaluate it, the program  * would never exit.  * Therefore we set SA_RESETHAND: This way, the 2nd time the signal is received  * the default handler would be called to terminate the program no matter what.  *  * Note that SA_RESETHAND requires either _POSIX_C_SOURCE>=200809L or  * _XOPEN_SOURCE>=500  */\n-NSI_CPPFLAGS?=-D_POSIX_C_SOURCE=200809 -D_XOPEN_SOURCE=600 -D_XOPEN_SOURCE_EXTENDED\n+NSI_CPPFLAGS?=-D_POSIX_C_SOURCE=200809L -D_XOPEN_SOURCE=600 -D_XOPEN_SOURCE_EXTENDED\n-comment|/**  * Set the handler for SIGTERM and SIGINT which will cause the  * program to exit gracefully when they are received the 1st time  *  * Note that our handler only sets a variable indicating the signal was  * received, and in each iteration of the hw main loop this variable is  * evaluated.  * If for some reason (the program is stuck) we never evaluate it, the program  * would never exit.  * Therefore we set SA_RESETHAND: This way, the 2nd time the signal is received  * the default handler would be called to terminate the program no matter what.  *  * Note that SA_RESETHAND requires either _POSIX_C_SOURCE>=200809 or  * _XOPEN_SOURCE>=500  */\n+comment|/**  * Set the handler for SIGTERM and SIGINT which will cause the  * program to exit gracefully when they are received the 1st time  *  * Note that our handler only sets a variable indicating the signal was  * received, and in each iteration of the hw main loop this variable is  * evaluated.  * If for some reason (the program is stuck) we never evaluate it, the program  * would never exit.  * Therefore we set SA_RESETHAND: This way, the 2nd time the signal is received  * the default handler would be called to terminate the program no matter what.  *  * Note that SA_RESETHAND requires either _POSIX_C_SOURCE>=200809L or  * _XOPEN_SOURCE>=500  */\n-value|200809\n+value|200809L\nThe issue was with: posix: Use _POSIX_C_SOURCE=200809L instead of 200809\n\nThis constant is supposed to be defined as a long instead of an int,\npresumably to support systems where int isn't large enough."
},{
  "instruction": "There is an issue in the following code. It relates to drivers uart_native_ptty: Set standard source macro appropriately\n\nThis file uses several functions which are extensions to the the\nstd C library. Let's explicity select one of the extensions\nwhich includes it instead of relaying on somebody having\nset it for this file somewhere else. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright (c) 2018, Oticon A/S  * Copyright (c) 2023, Nordic Semiconductor ASA  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nfile|<stdbool.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_undef\n+undef|#\n+directive|undef\n+name|_XOPEN_SOURCE\n+end_undef\n+\n+begin_comment\n+comment|/* Note: This is used only for interaction with the host C library, and is therefore exempt of  * coding guidelines rule A.4&5 which applies to the embedded code using embedded libraries  */\n+end_comment\n+\n+begin_define\n+DECL|macro|_XOPEN_SOURCE\n+define|#\n+directive|define\n+name|_XOPEN_SOURCE\n+value|600\n+end_define\n+\nThe issue was with: drivers uart_native_ptty: Set standard source macro appropriately\n\nThis file uses several functions which are extensions to the the\nstd C library. Let's explicity select one of the extensions\nwhich includes it instead of relaying on somebody having\nset it for this file somewhere else."
},{
  "instruction": "There is an issue in the following code. It relates to drivers flash_simulator: Set standard source macro appropriately\n\nThis file uses several functions which are extensions to the the\nstd C library. Let's explicity select one of the extensions\nwhich includes it instead of relaying on somebody having\nset it for this file somewhere else. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright (c) 2023 Nordic Semiconductor ASA  *  * SPDX-License-Identifier: Apache-2.0  *  * Part of flash simulator which interacts with the host OS  *  * When building for the native simulator, this file is built in the  * native simulator runner/host context, and not in Zephyr/embedded context.  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nfile|<unistd.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_undef\n+undef|#\n+directive|undef\n+name|_POSIX_C_SOURCE\n+end_undef\n+\n+begin_comment\n+comment|/* Note: This is used only for interaction with the host C library, and is therefore exempt of  * coding guidelines rule A.4&5 which applies to the embedded code using embedded libraries  */\n+end_comment\n+\n+begin_define\n+DECL|macro|_POSIX_C_SOURCE\n+define|#\n+directive|define\n+name|_POSIX_C_SOURCE\n+value|200809L\n+end_define\n+\nThe issue was with: drivers flash_simulator: Set standard source macro appropriately\n\nThis file uses several functions which are extensions to the the\nstd C library. Let's explicity select one of the extensions\nwhich includes it instead of relaying on somebody having\nset it for this file somewhere else."
},{
  "instruction": "There is an issue in the following code. It relates to ztest native extensions: Set standard source macro appropriately\n\nThis file uses strtok_r which is an extension to the the\nstd C library. Let's explicity select one of the extensions\nwhich includes it instead of relaying on somebody having\nset it for this file somewhere else. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_unit|revision:1.0.0;language:C;cregit-version:0.0.1\nbegin_comment\ncomment|/*  * Copyright (c) 2022 Google LLC  *  * SPDX-License-Identifier: Apache-2.0  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nfile|<stdio.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_undef\n+undef|#\n+directive|undef\n+name|_POSIX_C_SOURCE\n+end_undef\n+\n+begin_define\n+DECL|macro|_POSIX_C_SOURCE\n+define|#\n+directive|define\n+name|_POSIX_C_SOURCE\n+value|200809L\n+end_define\n+\nThe issue was with: ztest native extensions: Set standard source macro appropriately\n\nThis file uses strtok_r which is an extension to the the\nstd C library. Let's explicity select one of the extensions\nwhich includes it instead of relaying on somebody having\nset it for this file somewhere else."
},{
  "instruction": "There is an issue in the following code. It relates to drivers/wifi/esp32: Remove _POSIX_C_SOURCE define as unneeded\n\nThis driver doesn't use any APIs outside of the Zephyr C library list, so\nit doesn't need this _POSIX_C_SOURCE define. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|DT_DRV_COMPAT\nvalue|espressif_esp32_wifi\nend_define\n\nbegin_define\nDECL|macro|_POSIX_C_SOURCE\ndefine|#\ndirective|define\nname|_POSIX_C_SOURCE\nvalue|200809\nend_define\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/logging/log.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_define\n-DECL|macro|_POSIX_C_SOURCE\n-define|#\n-directive|define\n-name|_POSIX_C_SOURCE\n-value|200809\n-end_define\n-\nThe issue was with: drivers/wifi/esp32: Remove _POSIX_C_SOURCE define as unneeded\n\nThis driver doesn't use any APIs outside of the Zephyr C library list, so\nit doesn't need this _POSIX_C_SOURCE define."
},{
  "instruction": "There is an issue in the following code. It relates to tests: posix: pthread: identify thread ids of detached threads\n\nPreviously, the number 2 seemed to be somewhat magical. This\nremoves some of the mystery by labeling it.\n\nSo threads >= DETACH_THR_ID will be detached (we should not\nattempt to join detached threads). Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/ztest.h>\nend_include\n\nbegin_define\nDECL|macro|N_THR_E\ndefine|#\ndirective|define\nname|N_THR_E\nblock|}\nif|if\ncondition|(\nname|id\noperator|>=\nliteral|2\ncondition|)\nblock|{\nname|zassert_ok\nargument_list|(\nname|pthread_detach\ncondition|;\nname|i\noperator|++\ncontrol|)\nblock|{\nname|pthread_join\nargument_list|(\nname|newthread\nindex|[\nname|i\nindex|]\nargument_list|,\noperator|&\nname|retval\nargument_list|)\nexpr_stmt|;\nblock|}\ncomment|/* TESTPOINT: Test for deadlock */\nname|ret\noperator|=\nname|pthread_join\nargument_list|(\noperator|=\nname|pthread_cancel\nargument_list|(\nname|newthread\nindex|[\nname|N_THR_T\noperator|/\nliteral|2\nindex|]\nargument_list|)\nexpr_stmt|;\nname|zassert_equal\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_define\n+DECL|macro|DETACH_THR_ID\n+define|#\n+directive|define\n+name|DETACH_THR_ID\n+value|2\n+end_define\n+\n-literal|2\n+name|DETACH_THR_ID\n+if|if\n+condition|(\n+name|i\n+operator|<\n+name|DETACH_THR_ID\n+condition|)\n+block|{\n+name|zassert_ok\n+argument_list|(\n+argument_list|)\n+block|}\n-name|N_THR_T\n-operator|/\n-literal|2\n+literal|0\nThe issue was with: tests: posix: pthread: identify thread ids of detached threads\n\nPreviously, the number 2 seemed to be somewhat magical. This\nremoves some of the mystery by labeling it.\n\nSo threads >= DETACH_THR_ID will be detached (we should not\nattempt to join detached threads)."
},{
  "instruction": "There is an issue in the following code. It relates to posix: pthread: check canceltype before async cancel\n\nThe default pthread cancellation type is deferred.\n\nCheck that the canceltype is asynchronous (with\nrespect to cancellation points) before cancelling\na thread. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|)\nblock|{\nname|int\nname|cancel_state\ndecl_stmt|;\nname|k_spinlock_key_t\nname|key\ndecl_stmt|;\nname|struct\nname|posix_thread\noperator|=\nname|t\noperator|->\nname|cancel_state\nexpr_stmt|;\nname|k_spin_unlock\nargument_list|(\noperator|&\nname|pthread_pool_lock\nargument_list|,\nif|if\ncondition|(\nname|cancel_state\noperator|==\nname|PTHREAD_CANCEL_ENABLE\ncondition|)\nblock|{\nname|posix_thread_finalize\nargument_list|(\nname|t",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|int\n+name|cancel_type\n+decl_stmt|;\n+name|cancel_type\n+operator|=\n+name|t\n+operator|->\n+name|cancel_type\n+expr_stmt|;\n+operator|&&\n+name|cancel_type\n+operator|==\n+name|PTHREAD_CANCEL_ASYNCHRONOUS\nThe issue was with: posix: pthread: check canceltype before async cancel\n\nThe default pthread cancellation type is deferred.\n\nCheck that the canceltype is asynchronous (with\nrespect to cancellation points) before cancelling\na thread."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: dynamic: reduce verbosity in degenerate case\n\nk_thread_stack_free() is designed to be called with any pointer\nvalue. We return -EINVAL when an attempt is made to free an\ninvalid stack pointer.\n\nThis change reduces the verbosity in the degenerate case, when\nthe pointer is not obtained via k_thread_stack_alloc(), but\notherwise does not affect functionality.\n\nIf debug log verbosity is not enabled, we save a few bytes in\n.text / .rodata / .strtab. Please fix this issue.",
  "input": "Faulty tokenized code:\nendif|#\ndirective|endif\nblock|}\nelse|else\nblock|{\nname|LOG_ERR\nargument_list|(\nliteral|\"Invalid stack %p\"\nargument_list|,\nname|stack\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|LOG_ERR\n+name|LOG_DBG\nThe issue was with: kernel: dynamic: reduce verbosity in degenerate case\n\nk_thread_stack_free() is designed to be called with any pointer\nvalue. We return -EINVAL when an attempt is made to free an\ninvalid stack pointer.\n\nThis change reduces the verbosity in the degenerate case, when\nthe pointer is not obtained via k_thread_stack_alloc(), but\notherwise does not affect functionality.\n\nIf debug log verbosity is not enabled, we save a few bytes in\n.text / .rodata / .strtab."
},{
  "instruction": "There is an issue in the following code. It relates to tests: posix: pthread_attr: skip when large stack allocation fails\n\nRather than fail when attempting to set an extraordinarily large\npthread stack size (much larger than most Zephyr platforms have)\nconsider the test non-fatal and skip it. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|BIT\nargument_list|(\nname|CONFIG_POSIX_PTHREAD_ATTR_STACKSIZE_BITS\nargument_list|)\ndecl_stmt|;\nname|zassert_ok\nargument_list|(\nname|pthread_attr_setstacksize\nargument_list|(\noperator|&\nname|attr\nargument_list|,\nname|expect_size\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|zassert_ok\nargument_list|(\nname|pthread_attr_getstacksize\nargument_list|(\noperator|&",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|zassert_ok\n-argument_list|(\n+if|if\n+condition|(\n+operator|!=\n+literal|0\n+condition|)\n+block|{\n+name|TC_PRINT\n+argument_list|(\n+literal|\"Unable to allocate large stack of size %zu (skipping)\\n\"\n+argument_list|,\n+name|expect_size\n+name|ztest_test_skip\n+argument_list|()\n+expr_stmt|;\n+return|return;\n+block|}\nThe issue was with: tests: posix: pthread_attr: skip when large stack allocation fails\n\nRather than fail when attempting to set an extraordinarily large\npthread stack size (much larger than most Zephyr platforms have)\nconsider the test non-fatal and skip it."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: watchdog: andes atcwdt200 remove soc.h\n\nsoc\\riscv\\andes_v5\\ae350\\soc.h was empty and deleted,so revise\n wdt_andes_atcwdt200.c to resolve\n 'fatal error: soc.h: No such file or directory'. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/kernel.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<soc.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/drivers/watchdog.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_include\n-include|#\n-directive|include\n-file|<soc.h>\n-end_include\n-\nThe issue was with: drivers: watchdog: andes atcwdt200 remove soc.h\n\nsoc\\riscv\\andes_v5\\ae350\\soc.h was empty and deleted,so revise\n wdt_andes_atcwdt200.c to resolve\n 'fatal error: soc.h: No such file or directory'."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: display: uc81xx: fix 16-bit 'tres'\n\nUse 'struct uc81xx_tres16' for 16-bit 'tres' setup, instead of 'struct\nuc81xx_tres8'. This fixes a regression when support for 'uc8175' was added\nand 'struct uc81xx_tres' was replaced with 'struct uc81xx_tres16'.\n\nFixes: fef513a2ae27 [formerly 7c46b0b8984e] (\\\"drivers: display: uc81xx: add support for uc8175\\\") Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|config\ndecl_stmt|;\nspecifier|const\nname|struct\nname|uc81xx_tres8\nname|tres\ninit|=\nblock|{\noperator|.\nname|hres",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|uc81xx_tres8\n+name|uc81xx_tres16\nThe issue was with: drivers: display: uc81xx: fix 16-bit 'tres'\n\nUse 'struct uc81xx_tres16' for 16-bit 'tres' setup, instead of 'struct\nuc81xx_tres8'. This fixes a regression when support for 'uc8175' was added\nand 'struct uc81xx_tres' was replaced with 'struct uc81xx_tres16'.\n\nFixes: fef513a2ae27 [formerly 7c46b0b8984e] (\\\"drivers: display: uc81xx: add support for uc8175\\\")"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: adc: ad5592: add missing static keyword\n\nAdd the missing static keyword for driver data structure. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ADC_AD5592_DEFINE\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|static const struct adc_ad5592_config adc_ad5592_config##inst = {\t\\ \t\t.mfd_dev = DEVICE_DT_GET(DT_INST_PARENT(inst)),\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstruct adc_ad5592_data adc_ad5592_data##inst;\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst, adc_ad5592_init, NULL,\t\t\t\\&adc_ad5592_data##inst,&adc_ad5592_config##inst, \\ \t\t\t      POST_KERNEL, CONFIG_MFD_INIT_PRIORITY,\t\t\\&adc_ad5592_api);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|static const struct adc_ad5592_config adc_ad5592_config##inst = {\t\\ \t\t.mfd_dev = DEVICE_DT_GET(DT_INST_PARENT(inst)),\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstruct adc_ad5592_data adc_ad5592_data##inst;\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst, adc_ad5592_init, NULL,\t\t\t\\&adc_ad5592_data##inst,&adc_ad5592_config##inst, \\ \t\t\t      POST_KERNEL, CONFIG_MFD_INIT_PRIORITY,\t\t\\&adc_ad5592_api);\n+value|static const struct adc_ad5592_config adc_ad5592_config##inst = {\t\\ \t\t.mfd_dev = DEVICE_DT_GET(DT_INST_PARENT(inst)),\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic struct adc_ad5592_data adc_ad5592_data##inst;\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst, adc_ad5592_init, NULL,\t\t\t\\&adc_ad5592_data##inst,&adc_ad5592_config##inst, \\ \t\t\t      POST_KERNEL, CONFIG_MFD_INIT_PRIORITY,\t\t\\&adc_ad5592_api);\nThe issue was with: drivers: adc: ad5592: add missing static keyword\n\nAdd the missing static keyword for driver data structure."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: Fix ISO Sync Receiver sequential BIS PDU drop\n\nFix ISO Synchronized Receiver sequential packing BIS PDU\nbeing dropped in the first repetation just after previous\nBIS subevents where skipped. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|)\noperator|)\noperator|+\nliteral|1U\nexpr_stmt|;\ncomment|/* Find the missing (bn_curr)th Rx PDU \t\t\t\t\t * of bis_curr \t\t\t\t\t */\ngoto|goto\nname|isr_rx_find_subevent\ngoto|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* BIS index */\n+name|bis_idx\n+operator|=\n+name|lll\n+operator|->\n+name|bis_curr\n+operator|-\n+literal|1U\n+expr_stmt|;\nThe issue was with: Bluetooth: Controller: Fix ISO Sync Receiver sequential BIS PDU drop\n\nFix ISO Synchronized Receiver sequential packing BIS PDU\nbeing dropped in the first repetation just after previous\nBIS subevents where skipped."
},{
  "instruction": "There is an issue in the following code. It relates to sd: update comment to reference 'SD host controller specification'\n\nIn the code comments referring to section 3.6.1, changed the reference\nfrom 'SD specification' to 'SD host controller specification'\nfor a clearer and more accurate context. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|;\nblock|}\nend_function\n\nbegin_comment\ncomment|/*  * Implements signal voltage switch procedure described in section 3.6.1 of  * SD specification.  */\nend_comment\n\nbegin_function\nDECL|function|sdmmc_switch_voltage (struct sd_card * card)\nname|int\ndirective|define\nname|ZEPHYR_SUBSYS_SD_SD_OPS_H_\nend_define\n\nbegin_comment\ncomment|/*  * Switches voltage of SD card to 1.8V, as described by  * \"Signal voltage switch procedure\" in section 3.6.1 of SD specification.  */\nend_comment\n\nbegin_function_decl\nname|int\nname|sdmmc_switch_voltage",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/*  * Implements signal voltage switch procedure described in section 3.6.1 of  * SD specification.  */\n+comment|/*  * Implements signal voltage switch procedure described in section 3.6.1 of  * SD host controller specification.  */\n-comment|/*  * Switches voltage of SD card to 1.8V, as described by  * \"Signal voltage switch procedure\" in section 3.6.1 of SD specification.  */\n+comment|/*  * Switches voltage of SD card to 1.8V, as described by  * \"Signal voltage switch procedure\" in section 3.6.1 of SD host controller specification.  */\nThe issue was with: sd: update comment to reference 'SD host controller specification'\n\nIn the code comments referring to section 3.6.1, changed the reference\nfrom 'SD specification' to 'SD host controller specification'\nfor a clearer and more accurate context."
},{
  "instruction": "There is an issue in the following code. It relates to sd: omit zero-initialization for csd[4] and cid[4]\n\nAfter a review of the usage of csd[4] and cid[4],\nit has been determined that zero-initialization can be omitted.\n\nIt can be expected from successful operations that data will be\nappropriately written back from the underlying layer. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|uint32_t\nname|csd\nindex|[\nliteral|4\nindex|]\ninit|=\nblock|{\nliteral|0\nblock|}\ndecl_stmt|;\ncomment|/* Keep CSD on stack for reduced RAM usage */\nname|struct\nname|sd_csd\nname|card_csd\nname|uint32_t\nname|cid\nindex|[\nliteral|4\nindex|]\ninit|=\nblock|{\nliteral|0\nblock|}\ndecl_stmt|;\nname|int\nname|ret\ndecl_stmt|;\nif|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-init|=\n-block|{\n-literal|0\n-block|}\n-init|=\n-block|{\n-literal|0\n-block|}\nThe issue was with: sd: omit zero-initialization for csd[4] and cid[4]\n\nAfter a review of the usage of csd[4] and cid[4],\nit has been determined that zero-initialization can be omitted.\n\nIt can be expected from successful operations that data will be\nappropriately written back from the underlying layer."
},{
  "instruction": "There is an issue in the following code. It relates to soc: intel_adsp/ace: fix assert for uncached pointer\n\nOnly when CONFIG_MP_MAX_NUM_CPUS > 1, then .bss is put in\nuncached region. Otherwise, .bss is in cached region.\nSo the assertion that g_key_read_holder must be in uncached\nregion must take into account how many CPUs are enabled on\nbuild. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|true\nexpr_stmt|;\nif|#\ndirective|if\nname|CONFIG_SOC_INTEL_ACE15_MTPM\nname|__ASSERT\nargument_list|(\noperator|!\nname|arch_xtensa_is_ptr_cached\nargument_list|(\nargument_list|)\nargument_list|,\nliteral|\"g_key_read_holder must be uncached\"\nargument_list|)\nexpr_stmt|;\nname|g_key_read_holder\noperator|=\nname|INTEL_ADSP_ACE15_MAGIC_KEY\nexpr_stmt|;\nendif|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|#\n+directive|if\n+name|defined\n+argument_list|(\n+name|CONFIG_SMP\n+argument_list|)\n+operator|&&\n+operator|(\n+name|CONFIG_MP_MAX_NUM_CPUS\n+operator|>\n+literal|1\n+operator|)\n+comment|/* \t * Only when more than 1 CPUs is enabled, then this is in uncached area. \t * Otherwise, this is in cached area and will fail this test. \t */\n+endif|#\n+directive|endif\n+comment|/* defined(CONFIG_SMP)&& (CONFIG_MP_MAX_NUM_CPUS> 1) */\nThe issue was with: soc: intel_adsp/ace: fix assert for uncached pointer\n\nOnly when CONFIG_MP_MAX_NUM_CPUS > 1, then .bss is put in\nuncached region. Otherwise, .bss is in cached region.\nSo the assertion that g_key_read_holder must be in uncached\nregion must take into account how many CPUs are enabled on\nbuild."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: audio: tas6422dac: fix codec_mute_output function\n\nMute GPIO mutes both channel 1 and channel 2.\nSo, only control it when all channels have to be muted. Please fix this issue.",
  "input": "Faulty tokenized code:\ninit|=\nname|dev\noperator|->\nname|config\ndecl_stmt|;\nname|gpio_pin_configure_dt\nargument_list|(\noperator|&\nname|dev_cfg\noperator|->\nname|mute_gpio\nargument_list|,\nname|GPIO_OUTPUT_ACTIVE\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\nname|codec_read_reg\nargument_list|(\nname|dev",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|channel\n+operator|==\n+name|TAS6422DAC_CHANNEL_ALL\n+condition|)\n+block|{\n+block|}\nThe issue was with: drivers: audio: tas6422dac: fix codec_mute_output function\n\nMute GPIO mutes both channel 1 and channel 2.\nSo, only control it when all channels have to be muted."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: gpio: make reset of TLE9104 optional\n\nIn some hardware designs it might happen that the reset signal\nfor the TLE9104 is not used only for this purpose, but instead for\ninstance to reset other devices at the same time. For such a hardware\ndesign it is then necessary to make the reset GPIO optional. The reset\nwill have to be triggered earlier on. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|return\nname|result\nreturn|;\nblock|}\nblock|}\nname|result\noperator|=\nname|gpio_pin_configure_dt\nargument_list|(\noperator|&\nname|TLE9104_RESET_DURATION_WAIT_TIME_US\noperator|+\nname|TLE9104_RESET_DURATION_WAIT_TIME_SAFETY_MARGIN_US\nargument_list|)\nexpr_stmt|;\ncomment|/* \t * The first read value should be the ICVID, this acts also as the setup of the \t * global status register address. \t */\nname|result\noperator|=\nname|tle9104_transceive_frame\nargument_list|(\nname|TLE9104_INIT\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|static const struct tle9104_config tle9104_##inst##_config = {                             \\ \t\t.common = {                                                                        \\ \t\t\t\t.port_pin_mask = GPIO_PORT_PIN_MASK_FROM_DT_INST(inst),            \\ \t\t},                                                                                 \\ \t\t.bus = SPI_DT_SPEC_INST_GET(                                                       \\ \t\t\tinst, SPI_OP_MODE_MASTER | SPI_MODE_CPHA | SPI_WORD_SET(8), 0),            \\ \t\t.gpio_enable = TLE9104_INIT_GPIO_FIELDS(inst, en_gpios),                           \\ \t\t.gpio_reset = GPIO_DT_SPEC_GET_BY_IDX(DT_DRV_INST(inst), resn_gpios, 0),           \\ \t\t.gpio_control = {                                                                  \\ \t\t\t\tTLE9104_INIT_GPIO_FIELDS(inst, in1_gpios),                         \\ \t\t\t\tTLE9104_INIT_GPIO_FIELDS(inst, in2_gpios),                         \\ \t\t\t\tTLE9104_INIT_GPIO_FIELDS(inst, in3_gpios),                         \\ \t\t\t\tTLE9104_INIT_GPIO_FIELDS(inst, in4_gpios),                         \\ \t\t},                                                                                 \\ \t};                                                                                         \\                                                                                                    \\ \tstatic struct tle9104_data tle9104_##inst##_drvdata;                                       \\                                                                                                    \\\ncomment|/* This has to be initialized after the SPI peripheral. */\nvalue|\\ \tDEVICE_DT_INST_DEFINE(inst, tle9104_init, NULL,&tle9104_##inst##_drvdata,                 \\&tle9104_##inst##_config, POST_KERNEL,                               \\ \t\t\t      CONFIG_GPIO_TLE9104_INIT_PRIORITY,&api_table);\nend_define\n\nbegin_macro\n    type: phandle-array\n    description: \"GPIO for enable\"\n\n  resn-gpios:\n    type: phandle-array\n   required: true\n    description: \"GPIO for reset\"\n\n  in1-gpios:\n    type: phandle-array\n    description: \"GPIO for controlling OUT1\"",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|config\n+operator|->\n+name|gpio_reset\n+operator|.\n+name|port\n+operator|!=\n+name|NULL\n+condition|)\n+block|{\n+block|}\n-value|static const struct tle9104_config tle9104_##inst##_config = {                             \\ \t\t.common = {                                                                        \\ \t\t\t\t.port_pin_mask = GPIO_PORT_PIN_MASK_FROM_DT_INST(inst),            \\ \t\t},                                                                                 \\ \t\t.bus = SPI_DT_SPEC_INST_GET(                                                       \\ \t\t\tinst, SPI_OP_MODE_MASTER | SPI_MODE_CPHA | SPI_WORD_SET(8), 0),            \\ \t\t.gpio_enable = TLE9104_INIT_GPIO_FIELDS(inst, en_gpios),                           \\ \t\t.gpio_reset = GPIO_DT_SPEC_GET_BY_IDX(DT_DRV_INST(inst), resn_gpios, 0),           \\ \t\t.gpio_control = {                                                                  \\ \t\t\t\tTLE9104_INIT_GPIO_FIELDS(inst, in1_gpios),                         \\ \t\t\t\tTLE9104_INIT_GPIO_FIELDS(inst, in2_gpios),                         \\ \t\t\t\tTLE9104_INIT_GPIO_FIELDS(inst, in3_gpios),                         \\ \t\t\t\tTLE9104_INIT_GPIO_FIELDS(inst, in4_gpios),                         \\ \t\t},                                                                                 \\ \t};                                                                                         \\                                                                                                    \\ \tstatic struct tle9104_data tle9104_##inst##_drvdata;                                       \\                                                                                                    \\\n+value|static const struct tle9104_config tle9104_##inst##_config = {                             \\ \t\t.common = {                                                                        \\ \t\t\t\t.port_pin_mask = GPIO_PORT_PIN_MASK_FROM_DT_INST(inst),            \\ \t\t},                                                                                 \\ \t\t.bus = SPI_DT_SPEC_INST_GET(                                                       \\ \t\t\tinst, SPI_OP_MODE_MASTER | SPI_MODE_CPHA | SPI_WORD_SET(8), 0),            \\ \t\t.gpio_enable = TLE9104_INIT_GPIO_FIELDS(inst, en_gpios),                           \\ \t\t.gpio_reset = TLE9104_INIT_GPIO_FIELDS(inst, resn_gpios),                          \\ \t\t.gpio_control = {                                                                  \\ \t\t\t\tTLE9104_INIT_GPIO_FIELDS(inst, in1_gpios),                         \\ \t\t\t\tTLE9104_INIT_GPIO_FIELDS(inst, in2_gpios),                         \\ \t\t\t\tTLE9104_INIT_GPIO_FIELDS(inst, in3_gpios),                         \\ \t\t\t\tTLE9104_INIT_GPIO_FIELDS(inst, in4_gpios),                         \\ \t\t},                                                                                 \\ \t};                                                                                         \\                                                                                                    \\ \tstatic struct tle9104_data tle9104_##inst##_drvdata;                                       \\                                                                                                    \\\n-    required: true\nThe issue was with: drivers: gpio: make reset of TLE9104 optional\n\nIn some hardware designs it might happen that the reset signal\nfor the TLE9104 is not used only for this purpose, but instead for\ninstance to reset other devices at the same time. For such a hardware\ndesign it is then necessary to make the reset GPIO optional. The reset\nwill have to be triggered earlier on."
},{
  "instruction": "There is an issue in the following code. It relates to input: keymap: use the non `_OR_NULL` DEVICE_DT_GET variant\n\nThis driver really needs a device associated with it for the\nsyncronization bit to make sense, and since the argument is DT_PARENT it\nwill get it all the time, so no changes in practice, but this should\nhave been using the normal macro anyway. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|INPUT_KEYMAP_DEFINE\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|static void keymap_cb_##inst(struct input_event *evt)\t\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\t\t\t\\ \t\tkeymap_cb(DEVICE_DT_INST_GET(inst), evt);\t\t\t\t\t\\ \t}\t\t\t\t\t\t\t\t\t\t\t\\ \tINPUT_CALLBACK_DEFINE(DEVICE_DT_GET_OR_NULL(DT_INST_PARENT(inst)), keymap_cb_##inst);\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tDT_INST_FOREACH_PROP_ELEM(inst, keymap, KEYMAP_ENTRY_VALIDATE)\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic const uint16_t keymap_codes_##inst[] = {\t\t\t\t\t\t\\ \t\tDT_INST_FOREACH_PROP_ELEM(inst, keymap, CODES_INIT)\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct keymap_config keymap_config_##inst = {\t\t\t\t\\ \t\t.input_dev = DEVICE_DT_GET(DT_INST_PARENT(inst)),\t\t\t\t\\ \t\t.codes = keymap_codes_##inst,\t\t\t\t\t\t\t\\ \t\t.num_codes = ARRAY_SIZE(keymap_codes_##inst),\t\t\t\t\t\\ \t\t.row_size = DT_INST_PROP(inst, row_size),\t\t\t\t\t\\ \t\t.col_size = DT_INST_PROP(inst, col_size),\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct keymap_data keymap_data_##inst;\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst, keymap_init, NULL,\t\t\t\t\t\t\\&keymap_data_##inst,&keymap_config_##inst,\t\t\t\\ \t\t\t      POST_KERNEL, CONFIG_INPUT_INIT_PRIORITY, NULL);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|static void keymap_cb_##inst(struct input_event *evt)\t\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\t\t\t\\ \t\tkeymap_cb(DEVICE_DT_INST_GET(inst), evt);\t\t\t\t\t\\ \t}\t\t\t\t\t\t\t\t\t\t\t\\ \tINPUT_CALLBACK_DEFINE(DEVICE_DT_GET_OR_NULL(DT_INST_PARENT(inst)), keymap_cb_##inst);\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tDT_INST_FOREACH_PROP_ELEM(inst, keymap, KEYMAP_ENTRY_VALIDATE)\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic const uint16_t keymap_codes_##inst[] = {\t\t\t\t\t\t\\ \t\tDT_INST_FOREACH_PROP_ELEM(inst, keymap, CODES_INIT)\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct keymap_config keymap_config_##inst = {\t\t\t\t\\ \t\t.input_dev = DEVICE_DT_GET(DT_INST_PARENT(inst)),\t\t\t\t\\ \t\t.codes = keymap_codes_##inst,\t\t\t\t\t\t\t\\ \t\t.num_codes = ARRAY_SIZE(keymap_codes_##inst),\t\t\t\t\t\\ \t\t.row_size = DT_INST_PROP(inst, row_size),\t\t\t\t\t\\ \t\t.col_size = DT_INST_PROP(inst, col_size),\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct keymap_data keymap_data_##inst;\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst, keymap_init, NULL,\t\t\t\t\t\t\\&keymap_data_##inst,&keymap_config_##inst,\t\t\t\\ \t\t\t      POST_KERNEL, CONFIG_INPUT_INIT_PRIORITY, NULL);\n+value|static void keymap_cb_##inst(struct input_event *evt)\t\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\t\t\t\\ \t\tkeymap_cb(DEVICE_DT_INST_GET(inst), evt);\t\t\t\t\t\\ \t}\t\t\t\t\t\t\t\t\t\t\t\\ \tINPUT_CALLBACK_DEFINE(DEVICE_DT_GET(DT_INST_PARENT(inst)), keymap_cb_##inst);\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tDT_INST_FOREACH_PROP_ELEM(inst, keymap, KEYMAP_ENTRY_VALIDATE)\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic const uint16_t keymap_codes_##inst[] = {\t\t\t\t\t\t\\ \t\tDT_INST_FOREACH_PROP_ELEM(inst, keymap, CODES_INIT)\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct keymap_config keymap_config_##inst = {\t\t\t\t\\ \t\t.input_dev = DEVICE_DT_GET(DT_INST_PARENT(inst)),\t\t\t\t\\ \t\t.codes = keymap_codes_##inst,\t\t\t\t\t\t\t\\ \t\t.num_codes = ARRAY_SIZE(keymap_codes_##inst),\t\t\t\t\t\\ \t\t.row_size = DT_INST_PROP(inst, row_size),\t\t\t\t\t\\ \t\t.col_size = DT_INST_PROP(inst, col_size),\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct keymap_data keymap_data_##inst;\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst, keymap_init, NULL,\t\t\t\t\t\t\\&keymap_data_##inst,&keymap_config_##inst,\t\t\t\\ \t\t\t      POST_KERNEL, CONFIG_INPUT_INIT_PRIORITY, NULL);\nThe issue was with: input: keymap: use the non `_OR_NULL` DEVICE_DT_GET variant\n\nThis driver really needs a device associated with it for the\nsyncronization bit to make sense, and since the argument is DT_PARENT it\nwill get it all the time, so no changes in practice, but this should\nhave been using the normal macro anyway."
},{
  "instruction": "There is an issue in the following code. It relates to modbus: Remove mode reset in modbus_disable function\n\nRemove reset mode in modbus_disable. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|=\nliteral|0\nexpr_stmt|;\nname|ctx\noperator|->\nname|mode\noperator|=\nname|MODBUS_MODE_RTU\nexpr_stmt|;\nname|ctx\noperator|->\nname|mbs_user_cb\noperator|=\nname|NULL\nexpr_stmt|;\nname|atomic_clear_bit",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|mode\n-operator|=\n-name|MODBUS_MODE_RTU\n-expr_stmt|;\n-name|ctx\n-operator|->\nThe issue was with: modbus: Remove mode reset in modbus_disable function\n\nRemove reset mode in modbus_disable."
},{
  "instruction": "There is an issue in the following code. It relates to subsys/net/lib/lwm2m: Change how we seed the random generator\n\nInstead of seeding the random generator from the test\nitself calling into a host API, let's use the\nentropy generator option to be seeded from /dev/urandom\n\nThis avoids trouble with the srandom() and time() calls\nnot existing depending on the chosen C library. Please fix this issue.",
  "input": "Faulty tokenized code:\nCONFIG_LWM2M_DNS_SUPPORT=y\nCONFIG_NET_CONFIG_MY_IPV4_GW=\"192.0.2.2\"\nCONFIG_NATIVE_SIM_SLOWDOWN_TO_REAL_TIME=y\nCONFIG_NATIVE_UART_0_ON_STDINOUT=y\nCONFIG_ASAN=y\nparameter_list|)\nblock|{\nname|int\nname|ret\ndecl_stmt|;\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_BOARD_NATIVE_POSIX\nargument_list|)\nname|srandom\nargument_list|(\nname|time\nargument_list|(\nname|NULL\nargument_list|)\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\nname|ret\noperator|=\nname|lwm2m_setup\nargument_list|()\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+CONFIG_NATIVE_EXTRA_CMDLINE_ARGS=\"--seed-random\"\n-if|#\n-directive|if\n-name|defined\n-argument_list|(\n-name|CONFIG_BOARD_NATIVE_POSIX\n-argument_list|)\n-name|srandom\n-argument_list|(\n-name|time\n-argument_list|(\n-name|NULL\n-argument_list|)\n-argument_list|)\n-expr_stmt|;\n-endif|#\n-directive|endif\nThe issue was with: subsys/net/lib/lwm2m: Change how we seed the random generator\n\nInstead of seeding the random generator from the test\nitself calling into a host API, let's use the\nentropy generator option to be seeded from /dev/urandom\n\nThis avoids trouble with the srandom() and time() calls\nnot existing depending on the chosen C library."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: stm32: add reinit after standby\n\nWhen resuming from low power mode, if UART is disabled, this means that\nwe come from a mode that reset the registers, so we redo a full init of\nthe driver. Please fix this issue.",
  "input": "Faulty tokenized code:\ncondition|)\nblock|{\ncase|case\nname|PM_DEVICE_ACTION_RESUME\ncase|:\ncomment|/* Set pins to active state */\nname|err\noperator|=\nname|pinctrl_apply_state\nargument_list|(\nexpr_stmt|;\nreturn|return\nname|err\nreturn|;\nblock|}\nbreak|break;\ncase|case\nname|PM_DEVICE_ACTION_SUSPEND\ncase|:\nname|uart_stm32_suspend_setup",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* When exiting low power mode, check whether UART is enabled. \t\t * If not, it means we are exiting Suspend to RAM mode (STM32 \t\t * Standby), and the driver need to be reinitialized \t\t */\n+if|if\n+condition|(\n+name|LL_USART_IsEnabled\n+argument_list|(\n+name|config\n+operator|->\n+name|usart\n+argument_list|)\n+condition|)\n+block|{\n+block|}\n+else|else\n+block|{\n+name|uart_stm32_init\n+argument_list|(\n+name|dev\n+argument_list|)\n+expr_stmt|;\n+block|}\nThe issue was with: drivers: serial: stm32: add reinit after standby\n\nWhen resuming from low power mode, if UART is disabled, this means that\nwe come from a mode that reset the registers, so we redo a full init of\nthe driver."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: gpio: stm32: do not resume device when flag is DISCONNECTED\n\nFix a bug where after a standby, it was impossible to reenable a GPIO\nclock.\n\nA counter is incremented each time pm_device_runtime_get is called, and\ndecremented each time pm_device_runtime_put is called. The\nclock is only enabled if this counter equals 1.\nWhen configuring a GPIO (as input or output), the timer is incremented, and\nwhen disconnecting it, it is both incremented and decremented. Thus the\nnext time we try to configuring it, the clock is not enabled (since the\ncounter will now be equal to 2).\n\nThis causes a problem when using low power standby mode: after wakeup all\nclocks are disabled and the GPIO clock can not be reenabled.\n\nThis commit fixes this bug by not incrementing the counter when disconnect\nis asked (or in other words incrementing it only when configuring either\nan input or an output). Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|return\nname|err\nreturn|;\nblock|}\ncomment|/* Enable device clock before configuration (requires bank writes) */\nname|err\noperator|=\nname|pm_device_runtime_get\nargument_list|(\nname|dev\nblock|{\nreturn|return\nname|err\nreturn|;\nblock|}\nif|if\ncondition|(\noperator|(\nname|flags\noperator|&",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+operator|(\n+operator|(\n+name|flags\n+operator|&\n+name|GPIO_OUTPUT\n+operator|)\n+operator|!=\n+literal|0\n+operator|)\n+operator|||\n+operator|(\n+operator|(\n+name|flags\n+operator|&\n+name|GPIO_INPUT\n+operator|)\n+operator|!=\n+literal|0\n+operator|)\n+condition|)\n+block|{\n+block|}\nThe issue was with: drivers: gpio: stm32: do not resume device when flag is DISCONNECTED\n\nFix a bug where after a standby, it was impossible to reenable a GPIO\nclock.\n\nA counter is incremented each time pm_device_runtime_get is called, and\ndecremented each time pm_device_runtime_put is called. The\nclock is only enabled if this counter equals 1.\nWhen configuring a GPIO (as input or output), the timer is incremented, and\nwhen disconnecting it, it is both incremented and decremented. Thus the\nnext time we try to configuring it, the clock is not enabled (since the\ncounter will now be equal to 2).\n\nThis causes a problem when using low power standby mode: after wakeup all\nclocks are disabled and the GPIO clock can not be reenabled.\n\nThis commit fixes this bug by not incrementing the counter when disconnect\nis asked (or in other words incrementing it only when configuring either\nan input or an output)."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: timer: stm32: lptim: remove init to 0 of static\n\nRemove initialization of static variable to 0 to prevent resetting the\nvalue when reinitializing the driver after resume from standby.\nThis has no impact since static variables are initialized to 0 by default. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|LL_LPTIM_ClearFlag_ARROK\nargument_list|(\nname|LPTIM\nargument_list|)\nexpr_stmt|;\nname|accumulated_lptim_cnt\noperator|=\nliteral|0\nexpr_stmt|;\nif|#\ndirective|if\noperator|!\nname|defined\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|accumulated_lptim_cnt\n-operator|=\n-literal|0\n-expr_stmt|;\nThe issue was with: drivers: timer: stm32: lptim: remove init to 0 of static\n\nRemove initialization of static variable to 0 to prevent resetting the\nvalue when reinitializing the driver after resume from standby.\nThis has no impact since static variables are initialized to 0 by default."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: power_domain/intel_adsp: Init priority option\n\nAdd a Kconfig option to customize initialization priority of\nIntel ADSP power domain. Please fix this issue.",
  "input": "Faulty tokenized code:\n\tdepends on DT_HAS_INTEL_ADSP_POWER_DOMAIN_ENABLED\n\tselect DEVICE_DEPS\n\thelp\n\t  Include Intel ADSP power domain control mechanisms\n\nconfig POWER_DOMAIN_GPIO_MONITOR\n\tbool \"GPIO monitor for sensing power on rail\"\n\tdefault y\n\tdepends on DT_HAS_POWER_DOMAIN_GPIO_MONITOR_ENABLED\n\tdepends on GPIO\nname|POWER_DOMAIN_DEVICE\nparameter_list|(\nname|id\nparameter_list|)\ndefine|\\\nvalue|static struct pg_bits pd_pg_reg##id = {\t\t\t\t\t\t\\ \t\t.SPA_bit = DT_INST_PROP(id, bit_position),\t\t\t\t\\ \t\t.CPA_bit = DT_INST_PROP(id, bit_position),\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(id, pd_intel_adsp_pm_action);\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(id, pd_intel_adsp_init, PM_DEVICE_DT_INST_GET(id),\t\\&pd_pg_reg##id, NULL, POST_KERNEL,\t\t\t\\ \t\t\t      CONFIG_KERNEL_INIT_PRIORITY_DEFAULT, NULL);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if POWER_DOMAIN_INTEL_ADSP\n+\n+config POWER_DOMAIN_INTEL_ADSP_INIT_PRIORITY\n+\tint \"Intel ADSP power domain init priority\"\n+\tdefault KERNEL_INIT_PRIORITY_DEFAULT\n+\thelp\n+\t  Intel ADSP power domain initialization priority.\n+\n+endif #POWER_DOMAIN_INTEL_ADSP\n+\n-value|static struct pg_bits pd_pg_reg##id = {\t\t\t\t\t\t\\ \t\t.SPA_bit = DT_INST_PROP(id, bit_position),\t\t\t\t\\ \t\t.CPA_bit = DT_INST_PROP(id, bit_position),\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(id, pd_intel_adsp_pm_action);\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(id, pd_intel_adsp_init, PM_DEVICE_DT_INST_GET(id),\t\\&pd_pg_reg##id, NULL, POST_KERNEL,\t\t\t\\ \t\t\t      CONFIG_KERNEL_INIT_PRIORITY_DEFAULT, NULL);\n+value|static struct pg_bits pd_pg_reg##id = {\t\t\t\t\t\t\\ \t\t.SPA_bit = DT_INST_PROP(id, bit_position),\t\t\t\t\\ \t\t.CPA_bit = DT_INST_PROP(id, bit_position),\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(id, pd_intel_adsp_pm_action);\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(id, pd_intel_adsp_init, PM_DEVICE_DT_INST_GET(id),\t\\&pd_pg_reg##id, NULL, POST_KERNEL,\t\t\t\\ \t\t\t      CONFIG_POWER_DOMAIN_INTEL_ADSP_INIT_PRIORITY, NULL);\nThe issue was with: drivers: power_domain/intel_adsp: Init priority option\n\nAdd a Kconfig option to customize initialization priority of\nIntel ADSP power domain."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: power_domain/gpio: Init priority option\n\nAdd a Kconfig option to customize initialization priority of\ngpio power domain. Please fix this issue.",
  "input": "Faulty tokenized code:\n\tdepends on DT_HAS_POWER_DOMAIN_GPIO_ENABLED\n\tdepends on GPIO\n\tdepends on TIMEOUT_64BIT\n\tselect DEVICE_DEPS\n\nconfig POWER_DOMAIN_INTEL_ADSP\n\tbool \"Use Intel ADSP power gating mechanisms\"\n\tdefault y\n\tdepends on DT_HAS_INTEL_ADSP_POWER_DOMAIN_ENABLED\n\tselect DEVICE_DEPS\nname|POWER_DOMAIN_DEVICE\nparameter_list|(\nname|id\nparameter_list|)\ndefine|\\\nvalue|static const struct pd_gpio_config pd_gpio_##id##_cfg = {\t\t\\ \t\t.enable = GPIO_DT_SPEC_INST_GET(id, enable_gpios),\t\t\\ \t\t.startup_delay_us = DT_INST_PROP(id, startup_delay_us),\t\t\\ \t\t.off_on_delay_us = DT_INST_PROP(id, off_on_delay_us),\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \tstatic struct pd_gpio_data pd_gpio_##id##_data;\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(id, pd_gpio_pm_action);\t\t\t\\ \tDEVICE_DT_INST_DEFINE(id, pd_gpio_init, PM_DEVICE_DT_INST_GET(id),\t\\&pd_gpio_##id##_data,&pd_gpio_##id##_cfg,\t\\ \t\t\t      POST_KERNEL, CONFIG_POWER_DOMAIN_INIT_PRIORITY,\t\\ \t\t\t      NULL);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if POWER_DOMAIN_GPIO\n+\n+config POWER_DOMAIN_GPIO_INIT_PRIORITY\n+\tint \"GPIO power domain init priority\"\n+\tdefault POWER_DOMAIN_INIT_PRIORITY\n+\thelp\n+\t  GPIO power domain initialization priority.\n+\n+endif #POWER_DOMAIN_GPIO_MONITOR\n+\n-value|static const struct pd_gpio_config pd_gpio_##id##_cfg = {\t\t\\ \t\t.enable = GPIO_DT_SPEC_INST_GET(id, enable_gpios),\t\t\\ \t\t.startup_delay_us = DT_INST_PROP(id, startup_delay_us),\t\t\\ \t\t.off_on_delay_us = DT_INST_PROP(id, off_on_delay_us),\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \tstatic struct pd_gpio_data pd_gpio_##id##_data;\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(id, pd_gpio_pm_action);\t\t\t\\ \tDEVICE_DT_INST_DEFINE(id, pd_gpio_init, PM_DEVICE_DT_INST_GET(id),\t\\&pd_gpio_##id##_data,&pd_gpio_##id##_cfg,\t\\ \t\t\t      POST_KERNEL, CONFIG_POWER_DOMAIN_INIT_PRIORITY,\t\\ \t\t\t      NULL);\n+value|static const struct pd_gpio_config pd_gpio_##id##_cfg = {\t\t\\ \t\t.enable = GPIO_DT_SPEC_INST_GET(id, enable_gpios),\t\t\\ \t\t.startup_delay_us = DT_INST_PROP(id, startup_delay_us),\t\t\\ \t\t.off_on_delay_us = DT_INST_PROP(id, off_on_delay_us),\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \tstatic struct pd_gpio_data pd_gpio_##id##_data;\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(id, pd_gpio_pm_action);\t\t\t\\ \tDEVICE_DT_INST_DEFINE(id, pd_gpio_init, PM_DEVICE_DT_INST_GET(id),\t\\&pd_gpio_##id##_data,&pd_gpio_##id##_cfg,\t\\ \t\t\t      POST_KERNEL, CONFIG_POWER_DOMAIN_GPIO_INIT_PRIORITY,\t\\ \t\t\t      NULL);\nThe issue was with: drivers: power_domain/gpio: Init priority option\n\nAdd a Kconfig option to customize initialization priority of\ngpio power domain."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: power_domain/gpio_monitor: Init priority option\n\nAdd a Kconfig option to customize initialization priority of\ngpio monitor power domain. Please fix this issue.",
  "input": "Faulty tokenized code:\n\tdefault y\n\tdepends on DT_HAS_POWER_DOMAIN_GPIO_MONITOR_ENABLED\n\tdepends on GPIO\n\tselect DEVICE_DEPS\n\nendif\nname|POWER_DOMAIN_DEVICE\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|static const struct pd_gpio_monitor_config pd_gpio_monitor_config_##inst = {\t\t\\ \t\t.power_good_gpio = GPIO_DT_SPEC_INST_GET(inst, gpios),\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct pd_gpio_monitor_data pd_gpio_monitor_data_##inst;\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(inst, pd_gpio_monitor_pm_action);\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst, pd_gpio_monitor_init,\t\t\t\t\t\\ \t\t\t\tPM_DEVICE_DT_INST_GET(inst),&pd_gpio_monitor_data_##inst,\t\\&pd_gpio_monitor_config_##inst, POST_KERNEL,\t\t\t\\ \t\t\t\tCONFIG_POWER_DOMAIN_INIT_PRIORITY, NULL);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if POWER_DOMAIN_GPIO_MONITOR\n+\n+config POWER_DOMAIN_GPIO_MONITOR_INIT_PRIORITY\n+\tint \"GPIO monitor power domain init priority\"\n+\tdefault POWER_DOMAIN_INIT_PRIORITY\n+\thelp\n+\t  GPIO monitor power domain initialization priority.\n+\n+endif #POWER_DOMAIN_GPIO_MONITOR\n+\n-value|static const struct pd_gpio_monitor_config pd_gpio_monitor_config_##inst = {\t\t\\ \t\t.power_good_gpio = GPIO_DT_SPEC_INST_GET(inst, gpios),\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct pd_gpio_monitor_data pd_gpio_monitor_data_##inst;\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(inst, pd_gpio_monitor_pm_action);\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst, pd_gpio_monitor_init,\t\t\t\t\t\\ \t\t\t\tPM_DEVICE_DT_INST_GET(inst),&pd_gpio_monitor_data_##inst,\t\\&pd_gpio_monitor_config_##inst, POST_KERNEL,\t\t\t\\ \t\t\t\tCONFIG_POWER_DOMAIN_INIT_PRIORITY, NULL);\n+value|static const struct pd_gpio_monitor_config pd_gpio_monitor_config_##inst = {\t\t\\ \t\t.power_good_gpio = GPIO_DT_SPEC_INST_GET(inst, gpios),\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct pd_gpio_monitor_data pd_gpio_monitor_data_##inst;\t\t\t\t\\ \tPM_DEVICE_DT_INST_DEFINE(inst, pd_gpio_monitor_pm_action);\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(inst, pd_gpio_monitor_init,\t\t\t\t\t\\ \t\t\t\tPM_DEVICE_DT_INST_GET(inst),&pd_gpio_monitor_data_##inst,\t\\&pd_gpio_monitor_config_##inst, POST_KERNEL,\t\t\t\\ \t\t\t\tCONFIG_POWER_DOMAIN_GPIO_MONITOR_INIT_PRIORITY, NULL);\nThe issue was with: drivers: power_domain/gpio_monitor: Init priority option\n\nAdd a Kconfig option to customize initialization priority of\ngpio monitor power domain."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: sdhc: set 'sdhc_driver_api' as 'static const'\n\nThis change marks each instance of the 'api' as 'static const'.\nThe rationale is that 'api' is used for declaring internal\nmodule interfaces and is not intended to be modified at runtime.\nBy using 'static const', we ensure immutability, leading to usage of only\n.rodata and a reduction in the .data area. Please fix this issue.",
  "input": "Faulty tokenized code:\nend_function\n\nbegin_decl_stmt\nDECL|variable|sdhc_spi_api\nspecifier|static\nname|struct\nname|sdhc_driver_api\nname|sdhc_spi_api\ninit|=\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n+specifier|const\nThe issue was with: drivers: sdhc: set 'sdhc_driver_api' as 'static const'\n\nThis change marks each instance of the 'api' as 'static const'.\nThe rationale is that 'api' is used for declaring internal\nmodule interfaces and is not intended to be modified at runtime.\nBy using 'static const', we ensure immutability, leading to usage of only\n.rodata and a reduction in the .data area."
},{
  "instruction": "There is an issue in the following code. It relates to tests: bsim: Bluetooth: Mesh: Adjust timeout for Adv Extensions use\n\nAdjust mesh test timing and timeout value for Advertising\nExtensions use/fix in Zephyr Controller. The scanning in\nZephyr Controller is delayed when using extended scanning. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\ndecl_stmt|;\nend_decl_stmt\n\nbegin_struct\nDECL|struct|__anon29266d600108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|primary\nname|uint8_t\nname|observer_sem\ndecl_stmt|;\nend_decl_stmt\n\nbegin_struct\nDECL|struct|__anon29266d600208\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|flags\nname|uint8_t\nargument_list|,\nname|status\nargument_list|)\nexpr_stmt|;\nblock|}\nDECL|struct|__anon29266d600308\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|phase\nname|uint8_t\nargument_list|(\nname|K_SECONDS\nargument_list|(\nname|BEACON_INTERVAL\noperator|+\nliteral|5\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|toggle_priv_beacon\nargument_list|(\ndecl_stmt|;\nDECL|member|rx_timestamp\nname|int64_t\nname|rx_timestamp\ndecl_stmt|;\nDECL|union|__anon29266d60040a\nunion|union\nblock|{\nDECL|member|net_id\nname|uint64_t\nname|net_id\ndecl_stmt|;\nDECL|struct|__anon29266d600508\nstruct|struct\nblock|{\nDECL|member|hash\nname|uint64_t\nname|hash\ndecl_stmt|;\nDECL|member|evt_cnt\nname|uint16_t\nname|evt_cnt\ndecl_stmt|;\nDECL|struct|__anon29266d600608\nstruct|struct\nblock|{\nDECL|member|after\nname|int64_t\nname|after\nname|uint8_t\nname|old_idx\ninit|=\nliteral|0xff\ndecl_stmt|;\nDECL|struct|__anon29266d600708\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|net\nname|struct\noperator|&\nname|srv\nargument_list|,\nname|uuid\nargument_list|,\nliteral|5\nargument_list|,\nliteral|1\nargument_list|,\noperator|&\nname|scan_status\nname|max_devs\nargument_list|)\nexpr_stmt|;\nname|ASSERT_EQUAL\nargument_list|(\nliteral|5\nargument_list|,\nname|scan_status\noperator|.\nname|timeout\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon29266d600108\n+DECL|struct|__anon2c535a1d0108\n-DECL|struct|__anon29266d600208\n+DECL|struct|__anon2c535a1d0208\n-DECL|struct|__anon29266d600308\n+DECL|struct|__anon2c535a1d0308\n-literal|5\n+literal|7\n-DECL|union|__anon29266d60040a\n+DECL|union|__anon2c535a1d040a\n-DECL|struct|__anon29266d600508\n+DECL|struct|__anon2c535a1d0508\n-DECL|struct|__anon29266d600608\n+DECL|struct|__anon2c535a1d0608\n-DECL|struct|__anon29266d600708\n+DECL|struct|__anon2c535a1d0708\n-literal|5\n+literal|15\n-literal|5\n+literal|15\nThe issue was with: tests: bsim: Bluetooth: Mesh: Adjust timeout for Adv Extensions use\n\nAdjust mesh test timing and timeout value for Advertising\nExtensions use/fix in Zephyr Controller. The scanning in\nZephyr Controller is delayed when using extended scanning."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: Fix extended scanning assertion\n\nFix extended scanning assertion after long duration. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_BT_CENTRAL\nargument_list|)\nname|bool\nname|is_sched_advanced\ninit|=\nname|IS_ENABLED\nargument_list|(\nname|conn_win_offset_us\ndecl_stmt|;\nname|uint32_t\nname|ticks_anchor_prev\ndecl_stmt|;\nname|uint32_t\nname|ticks_at_start\ndecl_stmt|;\nif|if\ncondition|(\nname|is_sched_advanced\ncondition|)\nblock|{\nname|ticks_anchor_prev\noperator|=\nliteral|0U\nexpr_stmt|;\nblock|}\nname|ticks_at_start\noperator|=\nname|ticker_ticks_now_get\nargument_list|()\noperator|+\nname|ticks_at_start\nargument_list|)\nexpr_stmt|;\nelse|#\ndirective|else\ncomment|/* !CONFIG_BT_CENTRAL */\nname|remainder_us\noperator|=\nname|radio_tmr_start_now\nargument_list|(\nliteral|0\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\ncomment|/* !CONFIG_BT_CENTRAL */\ncomment|/* capture end of Rx-ed PDU, for initiator to calculate first \t * central event. \t */\nname|radio_tmr_end_capture\nargument_list|()\nexpr_stmt|;\nif|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|||\n+name|defined\n+argument_list|(\n+name|CONFIG_BT_CTLR_ADV_EXT\n+argument_list|)\n+if|#\n+directive|if\n+name|defined\n+argument_list|(\n+name|CONFIG_BT_CENTRAL\n+argument_list|)\n-name|uint32_t\n-name|ticks_at_start\n-decl_stmt|;\n+endif|#\n+directive|endif\n+comment|/* CONFIG_BT_CENTRAL */\n+name|uint32_t\n+name|ticks_at_start\n+decl_stmt|;\n-comment|/* !CONFIG_BT_CENTRAL */\n+comment|/* !CONFIG_BT_CENTRAL&& !CONFIG_BT_CTLR_ADV_EXT */\n-comment|/* !CONFIG_BT_CENTRAL */\n+comment|/* !CONFIG_BT_CENTRAL&& !CONFIG_BT_CTLR_ADV_EXT */\nThe issue was with: Bluetooth: Controller: Fix extended scanning assertion\n\nFix extended scanning assertion after long duration."
},{
  "instruction": "There is an issue in the following code. It relates to sensing: Code formatting fixups\n\nFixes a few small code formatting issues in sensor_mgmt.c adding\nbrackets where needed for an if and droping a line continuation slash\nthat failed one of the CI lints. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|state\noperator|!=\nname|SENSING_SENSOR_STATE_READY\ncondition|)\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\ncomment|/* create connection from sensor to application(client = NULL) */\nname|tmp_conn\noperator|=\nname|malloc\nargument_list|(\nargument_list|,\noperator|&\nname|sensing_ctx\nargument_list|,\nname|NULL\nargument_list|,\t\t\\\nname|POST_KERNEL\nargument_list|,\nname|CONFIG_SENSOR_INIT_PRIORITY\nargument_list|,\nname|NULL",
  "result": "I corrected the issue in the code by changing the following tokens:\n+block|{\n+block|}\n-argument_list|,\t\t\\\n+argument_list|,\nThe issue was with: sensing: Code formatting fixups\n\nFixes a few small code formatting issues in sensor_mgmt.c adding\nbrackets where needed for an if and droping a line continuation slash\nthat failed one of the CI lints."
},{
  "instruction": "There is an issue in the following code. It relates to fs: Add Kconfig key for init priority\n\nNon-configurable init priority POST_KERNEL/99 might\nbe too late for certain uses cases (e.g. fetching data from\nthe file system in driver initialization). Chabge it to\nbe configurable so that applications can mount the\nfile systems earlies if they want. Please fix this issue.",
  "input": "Faulty tokenized code:\n\t  default may be inappropriate when registering an out-of-tree\n\t  file system.  Selecting a value less than the actual length\n\t  supported by a file system may result in memory access\n\t  violations.\n\nconfig FILE_SYSTEM_SHELL\n\tbool \"File system shell\"\n\tdepends on SHELL\n\tdepends on HEAP_MEM_POOL_SIZE > 0\n\thelp\nargument_list|(\nname|fatfs_init\nargument_list|,\nname|POST_KERNEL\nargument_list|,\nliteral|99\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nend_unit\nargument_list|(\nname|littlefs_init\nargument_list|,\nname|POST_KERNEL\nargument_list|,\nliteral|99\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nend_unit",
  "result": "I corrected the issue in the code by changing the following tokens:\n+config FILE_SYSTEM_INIT_PRIORITY\n+\tint \"File system initialization priority\"\n+\tdefault 99\n+\thelp\n+\t  Specify the initialization priority for file systems. In case\n+\t  automount is enabled, the initialization should be done after\n+\t  the underlying storage device is initialized.\n+\n-literal|99\n+name|CONFIG_FILE_SYSTEM_INIT_PRIORITY\n-literal|99\n+name|CONFIG_FILE_SYSTEM_INIT_PRIORITY\nThe issue was with: fs: Add Kconfig key for init priority\n\nNon-configurable init priority POST_KERNEL/99 might\nbe too late for certain uses cases (e.g. fetching data from\nthe file system in driver initialization). Chabge it to\nbe configurable so that applications can mount the\nfile systems earlies if they want."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: eth_sam_gmac: Use CONFIG_PTP_CLOCK_INIT_PRIORITY to init ptp\n\nUse dedicated Kconfig symbol to set init priority. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|NULL\nargument_list|,\nname|POST_KERNEL\nargument_list|,\nname|CONFIG_APPLICATION_INIT_PRIORITY\nargument_list|,\noperator|&\nname|ptp_api\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_APPLICATION_INIT_PRIORITY\n+name|CONFIG_PTP_CLOCK_INIT_PRIORITY\nThe issue was with: drivers: eth_sam_gmac: Use CONFIG_PTP_CLOCK_INIT_PRIORITY to init ptp\n\nUse dedicated Kconfig symbol to set init priority."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: i2c: rv32m1: Fix build error\n\nThis fixes following build error when rv32m1_vega_zero_riscy\nboard gets compiled:\n\n    implicit declaration of function 'INST_DT_CLOCK_IP_NAME'\n\nFixes #68012 Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/logging/log.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/drivers/pinctrl.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<soc.h>\n+end_include\n+\nThe issue was with: drivers: i2c: rv32m1: Fix build error\n\nThis fixes following build error when rv32m1_vega_zero_riscy\nboard gets compiled:\n\n    implicit declaration of function 'INST_DT_CLOCK_IP_NAME'\n\nFixes #68012"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: spi: fix unreliable SPI busy flag for some STM32 devices\n\nExtend the workaround for the unreliable SPI busy flag\nto all F7 and L4 devices, which are affected by the same\nerratum.\n\nFixes  #67739 Please fix this issue.",
  "input": "Faulty tokenized code:\n\tbool \"STM32 Hardware Slave Select support\"\n\tdefault y\n\thelp\n\t  Use Slave Select pin instead of software Slave Select.\n\nconfig SPI_STM32F7_ERRATA_BUSY\n\tbool\n\tdefault y\n\tdepends on SOC_STM32F745XX || SOC_STM32F746XX || \\\n\t\t   SOC_STM32F750XX || SOC_STM32F756XX\n\thelp\n\t  Handles erratum \"BSY bit may stay high at the end of a data\n\t  transfer in Slave mode\".\n\t  Seen in Errata Sheet 0290 §2.11.2\n\nif SPI_STM32F7_ERRATA_BUSY\n\nconfig SPI_STM32_BUSY_FLAG_TIMEOUT\n\tint \"timeout in us for the STM32 busy flag workaround\"\n\tdefault 10000\n\nendif # SPI_STM32F7_ERRATA_BUSY\n\nendif # SPI_STM32\nblock|}\nendif|#\ndirective|endif\nifdef|#\ndirective|ifdef\nname|CONFIG_SPI_STM32F7_ERRATA_BUSY\nname|WAIT_FOR\nargument_list|(\nname|ll_func_spi_dma_busy\nargument_list|(\nname|spi",
  "result": "I corrected the issue in the code by changing the following tokens:\n-config SPI_STM32F7_ERRATA_BUSY\n+config SPI_STM32_ERRATA_BUSY\n-\tdepends on SOC_STM32F745XX || SOC_STM32F746XX || \\\n-\t\t   SOC_STM32F750XX || SOC_STM32F756XX\n+\tdepends on SOC_SERIES_STM32F7X || SOC_SERIES_STM32L4X\n-\t  transfer in Slave mode\".\n-\t  Seen in Errata Sheet 0290 §2.11.2\n+\t  transfer in slave mode\".\n+\t  Seen for instance in Errata Sheet 0290 §2.11.2\n-if SPI_STM32F7_ERRATA_BUSY\n+if SPI_STM32_ERRATA_BUSY\n-endif # SPI_STM32F7_ERRATA_BUSY\n+endif # SPI_STM32_ERRATA_BUSY\n-name|CONFIG_SPI_STM32F7_ERRATA_BUSY\n+name|CONFIG_SPI_STM32_ERRATA_BUSY\nThe issue was with: drivers: spi: fix unreliable SPI busy flag for some STM32 devices\n\nExtend the workaround for the unreliable SPI busy flag\nto all F7 and L4 devices, which are affected by the same\nerratum.\n\nFixes  #67739"
},{
  "instruction": "There is an issue in the following code. It relates to input: gpio_qdec: rename gpio to ab_gpio\n\nRename gpio to ab_gpio, this is in preparation for adding another gpio\npointer. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_struct\nDECL|struct|gpio_qdec_config\nstruct|struct\nname|gpio_qdec_config\nblock|{\nDECL|member|gpio\nname|struct\nname|gpio_dt_spec\nname|gpio\nindex|[\nname|GPIO_QDEC_GPIO_NUM\nindex|]\ndecl_stmt|;\nDECL|member|sample_time_us\nname|gpio_pin_get_dt\nargument_list|(\noperator|&\nname|cfg\noperator|->\nname|gpio\nindex|[\nliteral|0\nindex|]\nargument_list|)\ncondition|)\nname|gpio_pin_get_dt\nargument_list|(\noperator|&\nname|cfg\noperator|->\nname|gpio\nindex|[\nliteral|1\nindex|]\nargument_list|)\ncondition|)\nname|gpio\ninit|=\noperator|&\nname|cfg\noperator|->\nname|gpio\nindex|[\nname|i\nindex|]\ndecl_stmt|;\nname|ret\nargument_list|,\nname|BIT\nargument_list|(\nname|cfg\noperator|->\nname|gpio\nindex|[\nliteral|0\nindex|]\noperator|.\nname|pin\noperator||\nname|BIT\nargument_list|(\nname|cfg\noperator|->\nname|gpio\nindex|[\nliteral|1\nindex|]\noperator|.\nname|pin\nname|gpio\ninit|=\noperator|&\nname|cfg\noperator|->\nname|gpio\nindex|[\nname|i\nindex|]\ndecl_stmt|;\nif|if\nname|QDEC_GPIO_INIT\nparameter_list|(\nname|n\nparameter_list|)\ndefine|\\\nvalue|BUILD_ASSERT(DT_INST_PROP_LEN(n, gpios) == GPIO_QDEC_GPIO_NUM,\t\t\\ \t\t     \"input_gpio_qdec: gpios must have exactly two entries\");\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct gpio_qdec_config gpio_qdec_cfg_##n = {\t\t\\ \t\t.gpio = {GPIO_DT_SPEC_INST_GET_BY_IDX(n, gpios, 0),\t\t\\ \t\t\t GPIO_DT_SPEC_INST_GET_BY_IDX(n, gpios, 1)},\t\t\\ \t\t.sample_time_us = DT_INST_PROP(n, sample_time_us),\t\t\\ \t\t.idle_timeout_ms = DT_INST_PROP(n, idle_timeout_ms),\t\t\\ \t\t.steps_per_period = DT_INST_PROP(n, steps_per_period),\t\t\\ \t\t.axis = DT_INST_PROP(n, zephyr_axis),\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic struct gpio_qdec_data gpio_qdec_data_##n;\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n, gpio_qdec_init, NULL,\t\t\t\t\\&gpio_qdec_data_##n,\t\t\t\t\\&gpio_qdec_cfg_##n,\t\t\t\t\\ \t\t\t      POST_KERNEL, CONFIG_INPUT_INIT_PRIORITY,\t\t\\ \t\t\t      NULL);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|member|gpio\n+DECL|member|ab_gpio\n-name|gpio\n+name|ab_gpio\n-name|gpio\n+name|ab_gpio\n-name|gpio\n+name|ab_gpio\n-name|gpio\n+name|ab_gpio\n-name|gpio\n+name|ab_gpio\n-name|gpio\n+name|ab_gpio\n-name|gpio\n+name|ab_gpio\n-value|BUILD_ASSERT(DT_INST_PROP_LEN(n, gpios) == GPIO_QDEC_GPIO_NUM,\t\t\\ \t\t     \"input_gpio_qdec: gpios must have exactly two entries\");\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct gpio_qdec_config gpio_qdec_cfg_##n = {\t\t\\ \t\t.gpio = {GPIO_DT_SPEC_INST_GET_BY_IDX(n, gpios, 0),\t\t\\ \t\t\t GPIO_DT_SPEC_INST_GET_BY_IDX(n, gpios, 1)},\t\t\\ \t\t.sample_time_us = DT_INST_PROP(n, sample_time_us),\t\t\\ \t\t.idle_timeout_ms = DT_INST_PROP(n, idle_timeout_ms),\t\t\\ \t\t.steps_per_period = DT_INST_PROP(n, steps_per_period),\t\t\\ \t\t.axis = DT_INST_PROP(n, zephyr_axis),\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic struct gpio_qdec_data gpio_qdec_data_##n;\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n, gpio_qdec_init, NULL,\t\t\t\t\\&gpio_qdec_data_##n,\t\t\t\t\\&gpio_qdec_cfg_##n,\t\t\t\t\\ \t\t\t      POST_KERNEL, CONFIG_INPUT_INIT_PRIORITY,\t\t\\ \t\t\t      NULL);\n+value|BUILD_ASSERT(DT_INST_PROP_LEN(n, gpios) == GPIO_QDEC_GPIO_NUM,\t\t\\ \t\t     \"input_gpio_qdec: gpios must have exactly two entries\");\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct gpio_qdec_config gpio_qdec_cfg_##n = {\t\t\\ \t\t.ab_gpio = {\t\t\t\t\t\t\t\\ \t\t\tGPIO_DT_SPEC_INST_GET_BY_IDX(n, gpios, 0),\t\t\\ \t\t\tGPIO_DT_SPEC_INST_GET_BY_IDX(n, gpios, 1),\t\t\\ \t\t},\t\t\t\t\t\t\t\t\\ \t\t.sample_time_us = DT_INST_PROP(n, sample_time_us),\t\t\\ \t\t.idle_timeout_ms = DT_INST_PROP(n, idle_timeout_ms),\t\t\\ \t\t.steps_per_period = DT_INST_PROP(n, steps_per_period),\t\t\\ \t\t.axis = DT_INST_PROP(n, zephyr_axis),\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic struct gpio_qdec_data gpio_qdec_data_##n;\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n, gpio_qdec_init, NULL,\t\t\t\t\\&gpio_qdec_data_##n,\t\t\t\t\\&gpio_qdec_cfg_##n,\t\t\t\t\\ \t\t\t      POST_KERNEL, CONFIG_INPUT_INIT_PRIORITY,\t\t\\ \t\t\t      NULL);\nThe issue was with: input: gpio_qdec: rename gpio to ab_gpio\n\nRename gpio to ab_gpio, this is in preparation for adding another gpio\npointer."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: Fix ISO Sync Receiver subevent Rx window\n\nFix ISO Synchronized Receiver subevent Rx window timing and\nPDU address receive timeout to consider the +/- 2us active\nclock jitter. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|(\nname|EVENT_CLOCK_JITTER_US\noperator|<<\nliteral|1\noperator|)\nexpr_stmt|;\nname|start_us\noperator|=\nname|hcto\nexpr_stmt|;\nname|start_us\nargument_list|)\nexpr_stmt|;\ncomment|/* FIXME: Assertion check disabled until investigation as to \t\t *        why there is high ISR latency causing assertion here. \t\t */\ncomment|/* LL_ASSERT(hcto == (start_us + 1U)); */\ncomment|/* Add 4 us + 4 us + (4 us * subevents so far), as radio \t\t * was setup to listen 4 us early and subevents could have \t\t * a 4 us drift each until the current subevent we are \t\t * listening. \t\t */\nname|hcto\noperator|+=\noperator|(\noperator|(\nname|EVENT_CLOCK_JITTER_US\noperator|<<\nliteral|1\noperator|)\noperator|*\noperator|(\nliteral|2U\noperator|+\nname|nse\noperator|)\noperator|)\noperator|+\nname|RANGE_DELAY_US\noperator|+\nname|HCTO_START_DELAY_US",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|*\n+name|nse\n-comment|/* Add 4 us + 4 us + (4 us * subevents so far), as radio \t\t * was setup to listen 4 us early and subevents could have \t\t * a 4 us drift each until the current subevent we are \t\t * listening. \t\t */\n+comment|/* Add 8 us * subevents so far, as radio was setup to listen \t\t * 4 us early and subevents could have a 4 us drift each until \t\t * the current subevent we are listening. \t\t */\n+operator|(\n-operator|(\n-literal|2U\n-operator|+\n+operator|<<\n+literal|1\nThe issue was with: Bluetooth: Controller: Fix ISO Sync Receiver subevent Rx window\n\nFix ISO Synchronized Receiver subevent Rx window timing and\nPDU address receive timeout to consider the +/- 2us active\nclock jitter."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: Fix ISO Sync Receiver sequential subevent skip\n\nFix ISO Synchronized Receiver sequential packing subevent\nskip to next BIS subevent, so that radio channel is\ncorrectly calculated. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|=\noperator|(\nname|bis_idx_new\noperator|-\nname|bis_idx\noperator|-\nliteral|1U\noperator|)\noperator|*\noperator|(\noperator|(\nname|lll\noperator|(\noperator|(\nname|bis_idx_new\noperator|-\nname|bis_idx\noperator|-\nliteral|1U\noperator|)\noperator|*\noperator|(\noperator|(\nname|lll\noperator|-=\noperator|(\nname|bis_idx_new\noperator|-\nname|bis_idx\noperator|-\nliteral|1U\noperator|)\noperator|*\noperator|(\noperator|(\nname|lll",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|-\n-literal|1U\n-operator|-\n-literal|1U\n-operator|-\n-literal|1U\nThe issue was with: Bluetooth: Controller: Fix ISO Sync Receiver sequential subevent skip\n\nFix ISO Synchronized Receiver sequential packing subevent\nskip to next BIS subevent, so that radio channel is\ncorrectly calculated."
},{
  "instruction": "There is an issue in the following code. It relates to tests: devicetree: api: align `DT_IRQN` test\n\nNot sure why the `DT_IRQN` tests are tabbed, fix that. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nend_macro\n\nbegin_block\nblock|{\nDECL|enum|__anon2af8492b0103\nenum|enum\nblock|{\nDECL|enumerator|MY_ENUM_zero\nname|MY_ENUM_zero\ninit|=\nparameter_list|(\nname|pc_idx\nparameter_list|)\ndefine|\\\nvalue|_CONCAT(NODE_ID_ENUM_,\t\t\t\t\t\t\\ \t\tDT_PINCTRL_IDX_TO_NAME_UPPER_TOKEN(TEST_TEMP, pc_idx))\nDECL|enum|__anon2af8492b0203\nenum|enum\nblock|{\nDECL|enumerator|MAKE_TOKEN\nname|MAKE_TOKEN\nargument_list|(\nparameter_list|(\nname|pc_idx\nparameter_list|)\ndefine|\\\nvalue|_CONCAT(INST_ENUM_,\t\t\t\t\t\t\\ \t\t\tDT_INST_PINCTRL_IDX_TO_NAME_UPPER_TOKEN(0, pc_idx))\nDECL|enum|__anon2af8492b0303\nenum|enum\nblock|{\nDECL|enumerator|MAKE_TOKEN\nname|MAKE_TOKEN\nargument_list|(\nDECL|macro|DT_DRV_COMPAT\ndefine|#\ndirective|define\nname|DT_DRV_COMPAT\nvalue|vnd_string_token\nDECL|enum|__anon2af8492b0403\nenum|enum\nblock|{\nDECL|enumerator|token_zero\nname|token_zero\nblock|,\nblock|,\nDECL|enumerator|token_no_inst\nname|token_no_inst\nblock|, \t}\nenum|;\nDECL|enum|__anon2af8492b0503\nenum|enum\nblock|{\nDECL|enumerator|TOKEN_ZERO\nname|TOKEN_ZERO\ninit|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon2af8492b0103\n+DECL|enum|__anon27bb8d860103\n-DECL|enum|__anon2af8492b0203\n+DECL|enum|__anon27bb8d860203\n-DECL|enum|__anon2af8492b0303\n+DECL|enum|__anon27bb8d860303\n-DECL|enum|__anon2af8492b0403\n+DECL|enum|__anon27bb8d860403\n-DECL|enum|__anon2af8492b0503\n+DECL|enum|__anon27bb8d860503\nThe issue was with: tests: devicetree: api: align `DT_IRQN` test\n\nNot sure why the `DT_IRQN` tests are tabbed, fix that."
},{
  "instruction": "There is an issue in the following code. It relates to samples: bluetooth: iso_receive: Allow syncing any subevent number\n\nWhen using softdevice controller on iso_broadcast sample, the BIG\ncreated uses more than 1 subevent. This means that when you try to\nuse the iso_receive sample to sync it does not work.\n\nSo update the sample to use mse=0 and allow any number of subevents,\nmaking the sample more flexible and work with SDC without any changes. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|)\nblock|,\noperator|.\nname|mse\noperator|=\nliteral|1\nblock|,\noperator|.\nname|sync_timeout\noperator|=\nliteral|100\nblock|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|1\n+name|BT_ISO_SYNC_MSE_ANY\n+comment|/* any number of subevents */\nThe issue was with: samples: bluetooth: iso_receive: Allow syncing any subevent number\n\nWhen using softdevice controller on iso_broadcast sample, the BIG\ncreated uses more than 1 subevent. This means that when you try to\nuse the iso_receive sample to sync it does not work.\n\nSo update the sample to use mse=0 and allow any number of subevents,\nmaking the sample more flexible and work with SDC without any changes."
},{
  "instruction": "There is an issue in the following code. It relates to intel_adsp: ace: do not use external kconfigs in code\n\nuse CONFIG_SOC_INTEL_ACE15_MTPM instead of CONFIG_ACE_VERSION_1_5.\n\nCONFIG_ACE_VERSION_1_5 leaked from SOF. Please fix this issue.",
  "input": "Faulty tokenized code:\nend_include\n\nbegin_if\nif|#\ndirective|if\nname|CONFIG_ACE_VERSION_1_5\nend_if\n\nbegin_include\ninclude|#\ndirective|include\nendif|#\ndirective|endif\nend_endif\n\nbegin_comment\ncomment|/* CONFIG_ACE_VERSION_1_5 */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nblock|}\nelse|else\nblock|{\nif|#\ndirective|if\nname|CONFIG_ACE_VERSION_1_5\nspecifier|extern\nname|uint32_t\nname|g_key_read_holder\ndecl_stmt|;\nif|if\nend_define\n\nbegin_if\nif|#\ndirective|if\nname|CONFIG_ACE_VERSION_1_5\nend_if\n\nbegin_comment\ncomment|/* .bss is uncached, we further check it below */\nend_comment\nendif|#\ndirective|endif\nend_endif\n\nbegin_comment\ncomment|/* CONFIG_ACE_VERSION_1_5 */\nend_comment\n\nbegin_function\nDECL|function|ipc_isr (void * arg)\nspecifier|static\noperator|=\nname|true\nexpr_stmt|;\nif|#\ndirective|if\nname|CONFIG_ACE_VERSION_1_5\nname|__ASSERT\nargument_list|(\noperator|!\nname|arch_xtensa_is_ptr_cached\nargument_list|(\noperator|=\nname|INTEL_ADSP_ACE15_MAGIC_KEY\nexpr_stmt|;\nendif|#\ndirective|endif\ncomment|/* CONFIG_ACE_VERSION_1_5 */\nblock|}\nend_function\n\nbegin_function\nDECL|function|host_runtime_get (void)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_ACE_VERSION_1_5\n+name|CONFIG_SOC_INTEL_ACE15_MTPM\n-comment|/* CONFIG_ACE_VERSION_1_5 */\n+comment|/* CONFIG_SOC_INTEL_ACE15_MTPM */\n-name|CONFIG_ACE_VERSION_1_5\n+name|CONFIG_SOC_INTEL_ACE15_MTPM\n-name|CONFIG_ACE_VERSION_1_5\n+name|CONFIG_SOC_INTEL_ACE15_MTPM\n-comment|/* CONFIG_ACE_VERSION_1_5 */\n+comment|/* CONFIG_SOC_INTEL_ACE15_MTPM */\n-name|CONFIG_ACE_VERSION_1_5\n+name|CONFIG_SOC_INTEL_ACE15_MTPM\n-comment|/* CONFIG_ACE_VERSION_1_5 */\n+comment|/* CONFIG_SOC_INTEL_ACE15_MTPM */\nThe issue was with: intel_adsp: ace: do not use external kconfigs in code\n\nuse CONFIG_SOC_INTEL_ACE15_MTPM instead of CONFIG_ACE_VERSION_1_5.\n\nCONFIG_ACE_VERSION_1_5 leaked from SOF."
},{
  "instruction": "There is an issue in the following code. It relates to net: lwm2m: Fix segfault on failed bootstrap\n\nIf bootstrap fails, RD client will call lwm2m_engine_stop()\nwhich will close the context.\nThe socket loop, however still contains a call to\nhint_socket_state(context, NULL) which has a null pointer now.\n\nFix the segfault by allowing nullpointer on hint_socket_state(). Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nif|if\ncondition|(\noperator|!\nname|ctx\noperator|->\nname|set_socket_state\ncondition|)\nblock|{\nreturn|return;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|||\n+operator|!\n+name|ctx\nThe issue was with: net: lwm2m: Fix segfault on failed bootstrap\n\nIf bootstrap fails, RD client will call lwm2m_engine_stop()\nwhich will close the context.\nThe socket loop, however still contains a call to\nhint_socket_state(context, NULL) which has a null pointer now.\n\nFix the segfault by allowing nullpointer on hint_socket_state()."
},{
  "instruction": "There is an issue in the following code. It relates to tests: lwm2m: Rename engine to observation\n\n\\\"engine\\\" directory contained tests for observation\nso rename it.\nThere is separate \\\"lwm2m_engine\\\" directory that contains\ntests for the engine itself. Please fix this issue.",
  "input": "Faulty tokenized code:\nsimilarity index 100%\nrename from tests/net/lib/lwm2m/engine/CMakeLists.txt\nrename to tests/net/lib/lwm2m/observation/CMakeLists.txt\nsimilarity index 100%\nrename from tests/net/lib/lwm2m/engine/prj.conf\nrename to tests/net/lib/lwm2m/observation/prj.conf\nsimilarity index 100%\nrename from tests/net/lib/lwm2m/engine/src/lwm2m_observation.c\nrename to tests/net/lib/lwm2m/observation/src/lwm2m_observation.c\nsimilarity index 83%\nrename from tests/net/lib/lwm2m/engine/testcase.yaml\nrename to tests/net/lib/lwm2m/observation/testcase.yaml\ntests:\n net.lwm2m.engine:\n    platform_key:\n      - simulation\n    tags:\n      - lwm2m\n      - net",
  "result": "I corrected the issue in the code by changing the following tokens:\n-  net.lwm2m.engine:\n+  net.lwm2m.observation:\nThe issue was with: tests: lwm2m: Rename engine to observation\n\n\\\"engine\\\" directory contained tests for observation\nso rename it.\nThere is separate \\\"lwm2m_engine\\\" directory that contains\ntests for the engine itself."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Controller: Fix extended scanning data length assertion\n\nFix assertion due to LLL scheduling of auxiliary PDU\nreception was not considered in the ULL when checking for\naccumulated data length exceeding the supported maximum scan\ndata length. This caused the auxiliary context to be release\nwhile LLL was still active with scheduled PDU reception. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|data_len\noperator|+=\nname|data_len\nexpr_stmt|;\nif|if\ncondition|(\nname|aux\noperator|->\nname|data_len\noperator|>=\nname|CONFIG_BT_CTLR_SCAN_DATA_LEN_MAX\ncondition|)\nblock|{\ngoto|goto\nname|ull_scan_aux_rx_flush\ngoto|;\nblock|}\nblock|}\ncomment|/* In sync context we can dispatch rx immediately, in scan context we \t * enqueue rx in aux context and will flush them after scan is complete. \t */\nif|if\ncondition|(\nname|IS_ENABLED\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Flush auxiliary PDU receptions and stop any more ULL \t\t * scheduling if accumulated data length exceeds configured \t\t * maximum supported. \t\t */\n+comment|/* If LLL has already scheduled, then let it proceed. \t\t\t * \t\t\t * TODO: LLL to check accumulated data length and \t\t\t *       stop further reception. \t\t\t *       Currently LLL will schedule as long as there \t\t\t *       are free node rx available. \t\t\t */\n+if|if\n+condition|(\n+operator|!\n+name|ftr\n+operator|->\n+name|aux_lll_sched\n+condition|)\n+block|{\n+block|}\nThe issue was with: Bluetooth: Controller: Fix extended scanning data length assertion\n\nFix assertion due to LLL scheduling of auxiliary PDU\nreception was not considered in the ULL when checking for\naccumulated data length exceeding the supported maximum scan\ndata length. This caused the auxiliary context to be release\nwhile LLL was still active with scheduled PDU reception."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: gnss: quectel_lcx6g: fix compilation error when CONFIG_PM_DEVICE=y\n\nFixes a compilation error in quectel_lcx6g driver when CONFIG_PM_DEVICE=y.\nCorrects the function call in quectel_lcx6g_suspend from\n'modem_chat_run_script_run' to 'modem_chat_run_script'. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|struct\nname|modem_chat_script\nname|dynamic_script\ndecl_stmt|;\ncomment|/* Allocation for responses from GNSS modem */\nDECL|union|__anon29749d7a010a\nunion|union\nblock|{\nDECL|member|fix_rate_response\nname|uint16_t\nname|fix_rate_response\nname|int\nname|ret\ndecl_stmt|;\nname|ret\noperator|=\nname|modem_chat_run_script_run\nargument_list|(\noperator|&\nname|data\noperator|->\nname|chat",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon29749d7a010a\n+DECL|union|__anon27a83edf010a\n-name|modem_chat_run_script_run\n+name|modem_chat_run_script\nThe issue was with: drivers: gnss: quectel_lcx6g: fix compilation error when CONFIG_PM_DEVICE=y\n\nFixes a compilation error in quectel_lcx6g driver when CONFIG_PM_DEVICE=y.\nCorrects the function call in quectel_lcx6g_suspend from\n'modem_chat_run_script_run' to 'modem_chat_run_script'."
},{
  "instruction": "There is an issue in the following code. It relates to tests: drivers: can: api: fix uninitialized variable warning.\n\nFix a warning about unitialized variable. The test will be skipped in this\ncode path. Please fix this issue.",
  "input": "Faulty tokenized code:\n\nbegin_block\nblock|{\nname|uint32_t\nname|max\ndecl_stmt|;\nname|int\nname|err\ndecl_stmt|;\nname|err",
  "result": "I corrected the issue in the code by changing the following tokens:\n+init|=\n+literal|0U\nThe issue was with: tests: drivers: can: api: fix uninitialized variable warning.\n\nFix a warning about unitialized variable. The test will be skipped in this\ncode path."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: can: loopback: add common configuration structure\n\nAdd the common configuration structure to the CAN loopback driver. Please fix this issue.",
  "input": "Faulty tokenized code:\ndecl_stmt|;\nblock|}\nstruct|;\nend_struct\n\nbegin_struct\nDECL|struct|can_loopback_data\nstruct|struct\nname|can_loopback_data\nblock|{\nname|CAN_LOOPBACK_INIT\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|static struct can_loopback_data can_loopback_dev_data_##inst;\t\\ \t\t\t\t\t\t\t\t\t\\ \tCAN_DEVICE_DT_INST_DEFINE(inst, can_loopback_init, NULL,\t\\&can_loopback_dev_data_##inst, NULL,\t\\ \t\t\t\t  POST_KERNEL, CONFIG_CAN_INIT_PRIORITY,\\&can_loopback_driver_api);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_struct\n+DECL|struct|can_loopback_config\n+struct|struct\n+name|can_loopback_config\n+block|{\n+DECL|member|common\n+specifier|const\n+name|struct\n+name|can_driver_config\n+name|common\n+decl_stmt|;\n+block|}\n+struct|;\n+end_struct\n+\n-value|static struct can_loopback_data can_loopback_dev_data_##inst;\t\\ \t\t\t\t\t\t\t\t\t\\ \tCAN_DEVICE_DT_INST_DEFINE(inst, can_loopback_init, NULL,\t\\&can_loopback_dev_data_##inst, NULL,\t\\ \t\t\t\t  POST_KERNEL, CONFIG_CAN_INIT_PRIORITY,\\&can_loopback_driver_api);\n+value|static const struct can_loopback_config can_loopback_config_##inst = {\t\\ \t\t.common = CAN_DT_DRIVER_CONFIG_INST_GET(inst, 0U),\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic struct can_loopback_data can_loopback_data_##inst;\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tCAN_DEVICE_DT_INST_DEFINE(inst, can_loopback_init, NULL,\t\t\\&can_loopback_data_##inst,\t\t\t\\&can_loopback_config_##inst,\t\t\t\\ \t\t\t\t  POST_KERNEL, CONFIG_CAN_INIT_PRIORITY,\t\\&can_loopback_driver_api);\nThe issue was with: drivers: can: loopback: add common configuration structure\n\nAdd the common configuration structure to the CAN loopback driver."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: ISO: Fix CIS peripheral disconnection during setup\n\nWhen the central aborts the CIS setup during the CIS Creation\nprocedure after it has accepted the CIS request, the peripheral\nwill receive the HCI LE CIS Established event with an error code.\nIt does not receive a disconnection event.\nSee the message sequence chart in Core_v5.4, Vol 6, Part D,\nSection 6.23.\n\nThis commit ensures that the perirpheral disconnected callback gets\ncalled for this particular scenario. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nreturn|return;\nblock|}\nif|else if\ncondition|(\nname|evt\noperator|->\nname|status\noperator|!=\nname|BT_HCI_ERR_OP_CANCELLED_BY_HOST",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|iso\n+operator|->\n+name|role\n+operator|==\n+name|BT_HCI_ROLE_PERIPHERAL\n+operator|||\nThe issue was with: Bluetooth: ISO: Fix CIS peripheral disconnection during setup\n\nWhen the central aborts the CIS setup during the CIS Creation\nprocedure after it has accepted the CIS request, the peripheral\nwill receive the HCI LE CIS Established event with an error code.\nIt does not receive a disconnection event.\nSee the message sequence chart in Core_v5.4, Vol 6, Part D,\nSection 6.23.\n\nThis commit ensures that the perirpheral disconnected callback gets\ncalled for this particular scenario."
},{
  "instruction": "There is an issue in the following code. It relates to input: utils: fix kbd_matrix_state_log types\n\nChange row and col static types to unsigned, this should prevent really\nbad things from happening if a negative number ends up there for\nwhatever reasons without having to explicitly check for < 0. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|input_kbd_matrix_common_config\nmodifier|*\nname|cfg\ndecl_stmt|;\nspecifier|static\nname|int\nname|row\ndecl_stmt|,\nname|col\ndecl_stmt|,\nname|val\ndecl_stmt|;\nif|if\ncondition|(\nname|kbd_matrix_state_dev",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|int\n+name|uint32_t\n-decl_stmt|,\n+decl_stmt|;\n+specifier|static\n+name|bool\nThe issue was with: input: utils: fix kbd_matrix_state_log types\n\nChange row and col static types to unsigned, this should prevent really\nbad things from happening if a negative number ends up there for\nwhatever reasons without having to explicitly check for < 0."
},{
  "instruction": "There is an issue in the following code. It relates to tests: bsim: bluetooth: host: gatt: general: improve conn ref handling\n\nImproved the connection reference handling in the BabbleSim test\nproject in the Bluetooth Host category. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|\"Connected to %s\\n\"\nargument_list|,\nname|addr\nargument_list|)\nexpr_stmt|;\nname|g_conn\noperator|=\nname|conn\nexpr_stmt|;\nname|SET_FLAG\nargument_list|(\nname|flag_is_connected\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|__ASSERT_NO_MSG\n+argument_list|(\n-operator|=\n+operator|==\n+argument_list|)\nThe issue was with: tests: bsim: bluetooth: host: gatt: general: improve conn ref handling\n\nImproved the connection reference handling in the BabbleSim test\nproject in the Bluetooth Host category."
},{
  "instruction": "There is an issue in the following code. It relates to tests: posix: semaphore: speed up named semaphore test\n\nReduce N_LOOPS from 999 to 32 by default and use a Kconfig\nto encode it as CONFIG_TEST_SEM_N_LOOPS.\n\nRunning TESTSUITE semaphore\n===============================================================\nSTART - test_named_semaphore\n PASS - test_named_semaphore in 5.685 seconds\n===============================================================\nSTART - test_semaphore\n PASS - test_semaphore in 5.010 seconds\n===============================================================\nTESTSUITE semaphore succeeded Please fix this issue.",
  "input": "Faulty tokenized code:\n\trange 10 500\n\tdefault 10\n\thelp\n\t  This option is specific to posix_apis.test_realtime in clock.c\n\nsource \"Kconfig.zephyr\"\nname|void\nparameter_list|)\nfunction_decl|;\nend_function_decl\n\nbegin_define\nDECL|macro|N_LOOPS\ndefine|#\ndirective|define\nname|N_LOOPS\nvalue|999\nend_define\n\nbegin_function\nDECL|function|nsem_open_func (void * p)\nspecifier|static\nname|void\nmodifier|*\ninit|=\nliteral|0\ninit|;\nname|i\noperator|<\nname|N_LOOPS\ncondition|;\nname|i\noperator|++\ncontrol|)\nblock|{\nname|p\ndecl_stmt|;\ncomment|/* Make sure that we have enough ref_count's initially */\nname|k_msleep\nargument_list|(\nname|N_LOOPS\noperator|>>\nliteral|1\nargument_list|)\nexpr_stmt|;\nfor|for\ninit|=\nliteral|0\ninit|;\nname|i\noperator|<\nname|N_LOOPS\ncondition|;\nname|i\noperator|++\ncontrol|)\nblock|{\ninit|=\nliteral|1\ninit|;\nname|i\noperator|<=\nname|N_LOOPS\ncondition|;\nname|i\noperator|++\ncontrol|)\nblock|{\nfor|for\ncontrol|(\nname|size_t\nname|i\ninit|=\nname|N_LOOPS\ninit|;\ncomment|/* close until one left, required by the test later */\nname|i\noperator|>=\nliteral|1",
  "result": "I corrected the issue in the code by changing the following tokens:\n+config TEST_SEM_N_LOOPS\n+\tint \"Number of loops in semaphore test\"\n+\trange 16 1024\n+\tdefault 32\n+\thelp\n+\t  This option is specific to semaphore.test_named_semaphore in semaphore.c\n+\n-begin_define\n-DECL|macro|N_LOOPS\n-define|#\n-directive|define\n-name|N_LOOPS\n-value|999\n-end_define\n-\n-name|N_LOOPS\n+name|CONFIG_TEST_SEM_N_LOOPS\n-name|N_LOOPS\n+name|CONFIG_TEST_SEM_N_LOOPS\n-name|N_LOOPS\n+name|CONFIG_TEST_SEM_N_LOOPS\n-name|N_LOOPS\n+name|CONFIG_TEST_SEM_N_LOOPS\n-name|N_LOOPS\n+name|CONFIG_TEST_SEM_N_LOOPS\nThe issue was with: tests: posix: semaphore: speed up named semaphore test\n\nReduce N_LOOPS from 999 to 32 by default and use a Kconfig\nto encode it as CONFIG_TEST_SEM_N_LOOPS.\n\nRunning TESTSUITE semaphore\n===============================================================\nSTART - test_named_semaphore\n PASS - test_named_semaphore in 5.685 seconds\n===============================================================\nSTART - test_semaphore\n PASS - test_semaphore in 5.010 seconds\n===============================================================\nTESTSUITE semaphore succeeded"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: clock_control: clock_control_ra.c: protect register fix\n\nProtection for clock control and power mode registers was not being\nre-enabled. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|z_clock_hw_cycles_per_sec\ndecl_stmt|;\nend_decl_stmt\n\nbegin_enum\nDECL|enum|__anon2af55e730103\nenum|enum\nblock|{\nDECL|enumerator|CLKSRC_hoco\nname|CLKSRC_hoco\ninit|=\nblock|, }\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon2af55e730203\nenum|enum\nblock|{\nDECL|enumerator|SCKDIV_1\nname|SCKDIV_1\ninit|=\nblock|}\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon2af55e730303\nenum|enum\nblock|{\nDECL|enumerator|SCKDIV_POS_pclkd\nname|SCKDIV_POS_pclkd\ninit|=\nblock|}\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon2af55e730403\nenum|enum\nblock|{\nDECL|enumerator|OSCSF_HOCOSF_POS\nname|OSCSF_HOCOSF_POS\ninit|=\nblock|, }\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon2af55e730503\nenum|enum\nblock|{\nDECL|enumerator|OPCCR_OPCMTSF_POS\nname|OPCCR_OPCMTSF_POS\ninit|=\nliteral|0x2U\ndecl_stmt|;\nend_decl_stmt\n\nbegin_enum\nDECL|enum|__anon2af55e730603\nenum|enum\nblock|{\nif|#\ndirective|if\nname|DT_INST_REG_SIZE_BY_NAME\nblock|, }\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon2af55e730703\nenum|enum\nblock|{\nDECL|enumerator|SCKDIVCR_OFFSET\nname|SCKDIVCR_OFFSET\ninit|=\nblock|, }\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon2af55e730803\nenum|enum\nblock|{\nDECL|enumerator|SCRSCK_hoco\nname|SCRSCK_hoco\nblock|,\nname|SYSTEM_write16\nargument_list|(\nname|PRCR_OFFSET\nargument_list|,\nname|PRCR_KEY\noperator||\nname|PRCR_CLOCKS\noperator||\nname|PRCR_LOW_POWER\nargument_list|)\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon2af55e730103\n+DECL|enum|__anon2ba921170103\n-DECL|enum|__anon2af55e730203\n+DECL|enum|__anon2ba921170203\n-DECL|enum|__anon2af55e730303\n+DECL|enum|__anon2ba921170303\n-DECL|enum|__anon2af55e730403\n+DECL|enum|__anon2ba921170403\n-DECL|enum|__anon2af55e730503\n+DECL|enum|__anon2ba921170503\n-DECL|enum|__anon2af55e730603\n+DECL|enum|__anon2ba921170603\n-DECL|enum|__anon2af55e730703\n+DECL|enum|__anon2ba921170703\n-DECL|enum|__anon2af55e730803\n+DECL|enum|__anon2ba921170803\n-operator||\n-name|PRCR_CLOCKS\n-operator||\n-name|PRCR_LOW_POWER\nThe issue was with: drivers: clock_control: clock_control_ra.c: protect register fix\n\nProtection for clock control and power mode registers was not being\nre-enabled."
},{
  "instruction": "There is an issue in the following code. It relates to posix: Adds test to check getpid() is not NULL\n\nAdds test to check getpid() function is not NULL Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\ncomment|/* zassert_not_null(getpgid); */\ncomment|/* not implemented */\ncomment|/* zassert_not_null(getpgrp); */\ncomment|/* not implemented */\ncomment|/* zassert_not_null(getpid); */\ncomment|/* not implemented */\ncomment|/* zassert_not_null(getppid); */\ncomment|/* not implemented */\ncomment|/* zassert_not_null(getsid); */\ncomment|/* not implemented */\ncomment|/* zassert_not_null(getuid); */",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* zassert_not_null(getpid); */\n-comment|/* not implemented */\n+name|zassert_not_null\n+argument_list|(\n+name|getpid\n+argument_list|)\n+expr_stmt|;\nThe issue was with: posix: Adds test to check getpid() is not NULL\n\nAdds test to check getpid() function is not NULL"
},{
  "instruction": "There is an issue in the following code. It relates to posix: Adds test for clock_getcpuclockid()\n\nAdds test for clock_getcpuclockid() to\nmake sure clock_id is equal to CLOCK_PROCESS_CPUTIME_ID\nafter a successful call\n\nFixes #59954 Please fix this issue.",
  "input": "Faulty tokenized code:\ninit|=\nliteral|0\ndecl_stmt|;\nname|clockid_t\nname|clock_id\ndecl_stmt|;\nname|ret\noperator|=\nname|clock_getcpuclockid\nargument_list|(\nliteral|0\nargument_list|,\nliteral|\"POSIX clock_getcpuclock id failed\"\nargument_list|)\nexpr_stmt|;\nname|ret\noperator|=\nname|clock_getcpuclockid\nargument_list|(\noperator|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+init|=\n+name|CLOCK_INVALID\n+name|zassert_equal\n+argument_list|(\n+name|clock_id\n+argument_list|,\n+name|CLOCK_PROCESS_CPUTIME_ID\n+argument_list|,\n+literal|\"POSIX clock_getcpuclock id failed\"\n+argument_list|)\n+expr_stmt|;\nThe issue was with: posix: Adds test for clock_getcpuclockid()\n\nAdds test for clock_getcpuclockid() to\nmake sure clock_id is equal to CLOCK_PROCESS_CPUTIME_ID\nafter a successful call\n\nFixes #59954"
},{
  "instruction": "There is an issue in the following code. It relates to tests: smp_suspend: Tweak duration and timeouts\n\nReduces the number of seconds that the test runs to 15 seconds\n(down from 30 seconds). This should still be sufficient time\nto determine if there is anything amiss with the synchonous\nthread suspend/resume. Furthermore, the test itself has been\ntagged as being slow and its timeout increased to 10 minutes\n(600 seconds) as some simulators are rather slow. Please fix this issue.",
  "input": "Faulty tokenized code:\ninit|=\nliteral|0\ninit|;\nname|iteration\noperator|<\nliteral|30\ncondition|;\nname|iteration\noperator|++\ncontrol|)\nblock|{\ntests:\n  kernel.smp_suspend:\n    tags:\n      - kernel\n      - smp\n    filter: (CONFIG_MP_MAX_NUM_CPUS > 1)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|30\n+literal|15\n+    timeout: 600\nThe issue was with: tests: smp_suspend: Tweak duration and timeouts\n\nReduces the number of seconds that the test runs to 15 seconds\n(down from 30 seconds). This should still be sufficient time\nto determine if there is anything amiss with the synchonous\nthread suspend/resume. Furthermore, the test itself has been\ntagged as being slow and its timeout increased to 10 minutes\n(600 seconds) as some simulators are rather slow."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: modem: gsm fix rssi range\n\nrssi 31 will be -51dBm or greater, where -51 is valid. Fix the\nrange by allowing until -51. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|gsm\noperator|->\nname|minfo\noperator|.\nname|mdm_rssi\noperator|<\nname|GSM_RSSI_MAXVAL\noperator|)\noperator|)\ncondition|)\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|<\n+operator|<=\nThe issue was with: drivers: modem: gsm fix rssi range\n\nrssi 31 will be -51dBm or greater, where -51 is valid. Fix the\nrange by allowing until -51."
},{
  "instruction": "There is an issue in the following code. It relates to soc: riscv: virt: reduce the scope of SIFIVE_SYSCON_TEST\n\nIt was used nowhere else, there's no need to expose it publicly. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/sys/util.h>\nend_include\n\nbegin_comment\ncomment|/*  * Exit QEMU and tell error number.  *   Higher 16bits: indicates error number.  *   Lower 16bits : set FINISHER_FAIL  */\nend_comment\n\nbegin_define\ndefine|#\ndirective|define\nname|__RISCV_VIRT_SOC_H_\nend_define\n\nbegin_define\nDECL|macro|SIFIVE_SYSCON_TEST\ndefine|#\ndirective|define\nname|SIFIVE_SYSCON_TEST\nvalue|0x00100000\nend_define\n\nbegin_endif\nendif|#\ndirective|endif\nend_endif\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_define\n+DECL|macro|SIFIVE_SYSCON_TEST\n+define|#\n+directive|define\n+name|SIFIVE_SYSCON_TEST\n+value|0x00100000\n+end_define\n+\n-begin_define\n-DECL|macro|SIFIVE_SYSCON_TEST\n-define|#\n-directive|define\n-name|SIFIVE_SYSCON_TEST\n-value|0x00100000\n-end_define\n-\nThe issue was with: soc: riscv: virt: reduce the scope of SIFIVE_SYSCON_TEST\n\nIt was used nowhere else, there's no need to expose it publicly."
},{
  "instruction": "There is an issue in the following code. It relates to soc: riscv: openisa_rv32m1: add missing includes\n\n<soc.h> is needed to pull some APIs defined in soc.h.\n<fsl_device_registers.h> is needed to access EVENT0/1 addresses. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_endif\nendif|#\ndirective|endif\nend_endif\n\nbegin_define\nDECL|macro|LOG_LEVEL\ndefine|#\ndirective|define\nname|LOG_LEVEL\ndefine|#\ndirective|define\nname|SOC_RISCV32_OPENISA_RV32M1_SOC_OFFSETS_H_\nend_define\n\nbegin_ifdef\nifdef|#\ndirective|ifdef\nname|CONFIG_SOC_OPENISA_RV32M1_RI5CY\nend_ifdef",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<soc.h>\n+end_include\n+\n+begin_include\n+include|#\n+directive|include\n+file|<fsl_device_registers.h>\n+end_include\n+\nThe issue was with: soc: riscv: openisa_rv32m1: add missing includes\n\n<soc.h> is needed to pull some APIs defined in soc.h.\n<fsl_device_registers.h> is needed to access EVENT0/1 addresses."
},{
  "instruction": "There is an issue in the following code. It relates to soc: riscv: microchip_miv: miv: move MIV_UART_0_LINECFG to driver\n\nInstead of soc.h, since it's not used by anything else. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|BAUDVALUE_SHIFT\nvalue|((uint8_t)(5))\nend_define\n\nbegin_ifdef\nifdef|#\ndirective|ifdef\nname|CONFIG_UART_INTERRUPT_DRIVEN\nend_ifdef\ndefine|#\ndirective|define\nname|__RISCV32_MIV_SOC_H_\nend_define\n\nbegin_comment\ncomment|/* UART Configuration */\nend_comment\n\nbegin_define\nDECL|macro|MIV_UART_0_LINECFG\ndefine|#\ndirective|define\nname|MIV_UART_0_LINECFG\nvalue|0x1\nend_define\n\nbegin_endif\nendif|#\ndirective|endif\nend_endif\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_define\n+DECL|macro|MIV_UART_0_LINECFG\n+define|#\n+directive|define\n+name|MIV_UART_0_LINECFG\n+value|0x1\n+end_define\n+\n-begin_comment\n-comment|/* UART Configuration */\n-end_comment\n-\n-begin_define\n-DECL|macro|MIV_UART_0_LINECFG\n-define|#\n-directive|define\n-name|MIV_UART_0_LINECFG\n-value|0x1\n-end_define\n-\nThe issue was with: soc: riscv: microchip_miv: miv: move MIV_UART_0_LINECFG to driver\n\nInstead of soc.h, since it's not used by anything else."
},{
  "instruction": "There is an issue in the following code. It relates to soc: riscv: ite_ec: add missing soc_common.h include\n\nFile uses some API declared in soc_common.h. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/irq.h>\nend_include\n\nbegin_function\nDECL|function|arch_irq_enable (unsigned int irq)\nname|void\nname|arch_irq_enable\nparameter_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<soc_common.h>\n+end_include\n+\nThe issue was with: soc: riscv: ite_ec: add missing soc_common.h include\n\nFile uses some API declared in soc_common.h."
},{
  "instruction": "There is an issue in the following code. It relates to soc: riscv: andes_v5: include soc_v5.h\n\nInstead of catch-all soc.h (which was now just being a proxy for\nsoc_v5.h). Please fix this issue.",
  "input": "Faulty tokenized code:\n\nbegin_comment\ncomment|/**  * @brief Andes V5 L2 Cache Controller driver  */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/init.h>\nend_include\ndefine|#\ndirective|define\nname|__RISCV_ANDES_AE350_SOC_H_\nend_define\n\nbegin_comment\ncomment|/* Include CSRs available for Andes V5 SoCs */\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nfile|\"soc_v5.h\"\nend_include\n\nbegin_endif\nendif|#\ndirective|endif\nend_endif\n\n * Copyright (c) 2021 Andes Technology Corporation\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#include <offsets.h>\n#include <zephyr/toolchain.h>\n\n#include <soc.h>\n\n#ifdef CONFIG_RISCV_SOC_CONTEXT_SAVE\n\n/* Exports */\nGTEXT(__soc_save_context)\nGTEXT(__soc_restore_context)\n * Copyright (c) 2021 Andes Technology Corporation\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#include <zephyr/toolchain.h>\n#include <soc.h>\n\n/* exports */\nGTEXT(entry)\n\nSECTION_FUNC(init, entry)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|\"soc_v5.h\"\n+end_include\n+\n-begin_comment\n-comment|/* Include CSRs available for Andes V5 SoCs */\n-end_comment\n-\n-begin_include\n-include|#\n-directive|include\n-file|\"soc_v5.h\"\n-end_include\n-\n+#include \"soc_v5.h\"\n+\n-#include <soc.h>\n-\n+#include \"soc_v5.h\"\n+\n-#include <soc.h>\nThe issue was with: soc: riscv: andes_v5: include soc_v5.h\n\nInstead of catch-all soc.h (which was now just being a proxy for\nsoc_v5.h)."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: timer: litex: add missing include\n\n<soc.h> is needed to access IO R/W functions like litex_read8. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/drivers/timer/system_timer.h>\nend_include\n\nbegin_define\nDECL|macro|TIMER_LOAD_ADDR\ndefine|#\ndirective|define\nname|TIMER_LOAD_ADDR",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<soc.h>\n+end_include\n+\nThe issue was with: drivers: timer: litex: add missing include\n\n<soc.h> is needed to access IO R/W functions like litex_read8."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: spi: rv32m1_lpspi: add missing include\n\nAdd <soc.h>, for INST_DT_CLOCK_IP_NAME. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|spi_rv32m1_lpspi\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_include\ninclude|#\ndirective|include\nfile|\"spi_context.h\"\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<soc.h>\n+end_include\n+\nThe issue was with: drivers: spi: rv32m1_lpspi: add missing include\n\nAdd <soc.h>, for INST_DT_CLOCK_IP_NAME."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: opentitan: remove redundant include\n\n<soc.h> is not needed. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/drivers/uart.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<soc.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/irq.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_include\n-include|#\n-directive|include\n-file|<soc.h>\n-end_include\n-\nThe issue was with: drivers: serial: opentitan: remove redundant include\n\n<soc.h> is not needed."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: liteuart: add missing include\n\nsoc.h was missing to access custom IO read/write functions, e.g.\nlitex_read8. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/types.h>\nend_include\n\nbegin_define\nDECL|macro|UART_RXTX_ADDR\ndefine|#\ndirective|define\nname|UART_RXTX_ADDR",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<soc.h>\n+end_include\n+\nThe issue was with: drivers: serial: liteuart: add missing include\n\nsoc.h was missing to access custom IO read/write functions, e.g.\nlitex_read8."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: neorv32: add missing include\n\n<soc.h> is needed for some NEORV32_SYSINFO_* definition. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/irq.h>\nend_include\n\nbegin_expr_stmt\nname|LOG_MODULE_REGISTER\nargument_list|(\nname|uart_neorv32\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<soc.h>\n+end_include\n+\nThe issue was with: drivers: serial: neorv32: add missing include\n\n<soc.h> is needed for some NEORV32_SYSINFO_* definition."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: intc: plic: remove redundant include\n\n<soc.h> is not needed. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/shell/shell.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<soc.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/sw_isr_table.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_include\n-include|#\n-directive|include\n-file|<soc.h>\n-end_include\n-\nThe issue was with: drivers: intc: plic: remove redundant include\n\n<soc.h> is not needed."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: intc: nuclei_eclic: remove unnecessary include\n\nsoc.h is empty for this platform. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/irq_multilevel.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<soc.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/sw_isr_table.h>\nend_include\nbegin_union\nDECL|union|CLICCFG\nunion|union\nname|CLICCFG\nblock|{\nDECL|struct|__anon27b6437c0108\nstruct|struct\nblock|{\nDECL|member|_reserved0\nname|uint8_t\nname|_reserved0\nbegin_union\nDECL|union|CLICINFO\nunion|union\nname|CLICINFO\nblock|{\nDECL|struct|__anon27b6437c0208\nstruct|struct\nblock|{\ncomment|/** number of max supported interrupts */\nDECL|member|numint\nname|uint32_t\nbegin_union\nDECL|union|CLICINTIP\nunion|union\nname|CLICINTIP\nblock|{\nDECL|struct|__anon27b6437c0308\nstruct|struct\nblock|{\ncomment|/** Interrupt Pending */\nDECL|member|IP\nname|uint8_t\nbegin_union\nDECL|union|CLICINTIE\nunion|union\nname|CLICINTIE\nblock|{\nDECL|struct|__anon27b6437c0408\nstruct|struct\nblock|{\ncomment|/** Interrupt Enabled */\nDECL|member|IE\nname|uint8_t\nbegin_union\nDECL|union|CLICINTATTR\nunion|union\nname|CLICINTATTR\nblock|{\nDECL|struct|__anon27b6437c0508\nstruct|struct\nblock|{\ncomment|/** 0: non-vectored 1:vectored */\nDECL|member|shv\nname|uint8_t",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_include\n-include|#\n-directive|include\n-file|<soc.h>\n-end_include\n-\n-DECL|struct|__anon27b6437c0108\n+DECL|struct|__anon2973db950108\n-DECL|struct|__anon27b6437c0208\n+DECL|struct|__anon2973db950208\n-DECL|struct|__anon27b6437c0308\n+DECL|struct|__anon2973db950308\n-DECL|struct|__anon27b6437c0408\n+DECL|struct|__anon2973db950408\n-DECL|struct|__anon27b6437c0508\n+DECL|struct|__anon2973db950508\nThe issue was with: drivers: intc: nuclei_eclic: remove unnecessary include\n\nsoc.h is empty for this platform."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: i2c: mchp_mss: remove redundant include\n\n<soc.h> is not needed. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/device.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<soc.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/drivers/i2c.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_include\n-include|#\n-directive|include\n-file|<soc.h>\n-end_include\n-\nThe issue was with: drivers: i2c: mchp_mss: remove redundant include\n\n<soc.h> is not needed."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: i2c: litex: add missing include\n\nsoc.h was missing for some IO r/w functions, e.g. litex_write8. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|\"i2c_bitbang.h\"\nend_include\n\nbegin_define\nDECL|macro|SCL_BIT_POS\ndefine|#\ndirective|define\nname|SCL_BIT_POS",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<soc.h>\n+end_include\n+\nThe issue was with: drivers: i2c: litex: add missing include\n\nsoc.h was missing for some IO r/w functions, e.g. litex_write8."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: gpio: sifive: remove unnecessary check\n\nThe API already asserts for invalid pin based on DT `ngpios` property. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|DEV_GPIO\nargument_list|(\nname|dev\nargument_list|)\ndecl_stmt|;\nif|if\ncondition|(\nname|pin\noperator|>=\nname|SIFIVE_PINMUX_PINS\ncondition|)\nblock|{\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}\ncomment|/* We cannot support open-source open-drain configuration */\nif|if\ncondition|(\noperator|(\nname|flags",
  "result": "I corrected the issue in the code by changing the following tokens:\n-if|if\n-condition|(\n-name|pin\n-operator|>=\n-name|SIFIVE_PINMUX_PINS\n-condition|)\n-block|{\n-return|return\n-operator|-\n-name|EINVAL\n-return|;\n-block|}\nThe issue was with: drivers: gpio: sifive: remove unnecessary check\n\nThe API already asserts for invalid pin based on DT `ngpios` property."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: gpio: mchp_mss: remove redundant include\n\n<soc.h> is not needed. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/device.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<soc.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/drivers/gpio.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_include\n-include|#\n-directive|include\n-file|<soc.h>\n-end_include\n-\nThe issue was with: drivers: gpio: mchp_mss: remove redundant include\n\n<soc.h> is not needed."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: gpio: atcgpio100: remove redundant include\n\n<soc.h> is not needed. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/device.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<soc.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/drivers/gpio.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_include\n-include|#\n-directive|include\n-file|<soc.h>\n-end_include\n-\nThe issue was with: drivers: gpio: atcgpio100: remove redundant include\n\n<soc.h> is not needed."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: clock_control: litex: add missing include\n\nDrivers uses custom IO read/write API defined in soc.h. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/kernel.h>\nend_include\n\nbegin_expr_stmt\nname|LOG_MODULE_REGISTER\nargument_list|(\nname|CLK_CTRL_LITEX\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<soc.h>\n+end_include\n+\nThe issue was with: drivers: clock_control: litex: add missing include\n\nDrivers uses custom IO read/write API defined in soc.h."
},{
  "instruction": "There is an issue in the following code. It relates to bluetooth: controller: ll_sw: RV32M1: add missing include\n\ncntr.c accesses some registers defined in fsl_device_registers.h. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|\"ll_irqs.h\"\nend_include\n\nbegin_define\nDECL|macro|PCS_SOURCE_RTC\ndefine|#\ndirective|define\nname|PCS_SOURCE_RTC",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<fsl_device_registers.h>\n+end_include\n+\nThe issue was with: bluetooth: controller: ll_sw: RV32M1: add missing include\n\ncntr.c accesses some registers defined in fsl_device_registers.h."
},{
  "instruction": "There is an issue in the following code. It relates to arch: riscv: offsets: fix header race condition\n\nIt looks like some soc_offsets.h files need to be included before\nkernel_offsets, otherwise there are some header race conditions due to\nthe infamous soc.h. This problem is exposed if all soc.h are removed\nfrom RISC-V arch header files (see the upcoming commits). It can be\nreproduced by building rv32m1_vega_ri5cy board after applying all the\npatches in this series (excluding this one, of course). Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<gen_offset.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<kernel_offsets.h>\nend_include\n\nbegin_ifdef\nifdef|#\ndirective|ifdef\nname|CONFIG_RISCV_SOC_CONTEXT_SAVE\nend_ifdef\nbegin_endif\nendif|#\ndirective|endif\nend_endif\n\nbegin_comment\ncomment|/* struct _callee_saved member offsets */\nend_comment\n\nbegin_expr_stmt",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_include\n-include|#\n-directive|include\n-file|<kernel_offsets.h>\n-end_include\n-\n+begin_include\n+include|#\n+directive|include\n+file|<kernel_offsets.h>\n+end_include\n+\nThe issue was with: arch: riscv: offsets: fix header race condition\n\nIt looks like some soc_offsets.h files need to be included before\nkernel_offsets, otherwise there are some header race conditions due to\nthe infamous soc.h. This problem is exposed if all soc.h are removed\nfrom RISC-V arch header files (see the upcoming commits). It can be\nreproduced by building rv32m1_vega_ri5cy board after applying all the\npatches in this series (excluding this one, of course)."
},{
  "instruction": "There is an issue in the following code. It relates to boards native_sim: Detect attemtp to configure not existing int\n\nPrevent overrunning the irq vector table.\nThis is not happening today in tree, but coverity thinks it\nmay. Checking for it to prevent it is not a bad idea\nanyhow, so let's do it. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|void\nmodifier|*\nname|isr_param_p\nparameter_list|)\nblock|{\nname|irq_vector_table\nindex|[\nname|irq_p\nindex|]\noperator|.",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|irq_p\n+operator|>=\n+name|N_IRQS\n+condition|)\n+block|{\n+name|posix_print_error_and_exit\n+argument_list|(\n+literal|\"Attempted to configure not existent interrupt %u\\n\"\n+argument_list|,\n+name|irq_p\n+argument_list|)\n+expr_stmt|;\n+return|return;\n+block|}\nThe issue was with: boards native_sim: Detect attemtp to configure not existing int\n\nPrevent overrunning the irq vector table.\nThis is not happening today in tree, but coverity thinks it\nmay. Checking for it to prevent it is not a bad idea\nanyhow, so let's do it."
},{
  "instruction": "There is an issue in the following code. It relates to boards nrf*_bsim: Detect attemtp to configure not existing int\n\nPrevent overrunning the irq vector table.\nThis is not happening today in tree, but coverity thinks it\ndoes. Checking for it to prevent it is not a bad idea\nanyhow, so let's do it. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|void\nmodifier|*\nname|isr_param_p\nparameter_list|)\nblock|{\nname|irq_vector_table\nindex|[\nname|irq_p\nindex|]\noperator|.",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|irq_p\n+operator|>=\n+name|NHW_INTCTRL_MAX_INTLINES\n+condition|)\n+block|{\n+name|bs_trace_error_time_line\n+argument_list|(\n+literal|\"Attempted to configure not existent interrupt %u\\n\"\n+argument_list|,\n+name|irq_p\n+argument_list|)\n+expr_stmt|;\n+return|return;\n+block|}\nThe issue was with: boards nrf*_bsim: Detect attemtp to configure not existing int\n\nPrevent overrunning the irq vector table.\nThis is not happening today in tree, but coverity thinks it\ndoes. Checking for it to prevent it is not a bad idea\nanyhow, so let's do it."
},{
  "instruction": "There is an issue in the following code. It relates to pm: Remove CURRENT_CPU macro\n\nJust use _current_cpu that works with/without multicore. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|CONFIG_PM_LOG_LEVEL\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_define\nDECL|macro|CURRENT_CPU\ndefine|#\ndirective|define\nname|CURRENT_CPU\ndefine|\\\nvalue|(COND_CODE_1(CONFIG_SMP, (arch_curr_cpu()->id), (_current_cpu->id)))\nend_define\n\nbegin_expr_stmt\nspecifier|static\nname|ATOMIC_DEFINE\nargument_list|(\nname|z_post_ops_required\nparameter_list|)\nblock|{\nname|uint8_t\nname|id\ninit|=\nname|CURRENT_CPU\ndecl_stmt|;\ncomment|/* \t * This notification is called from the ISR of the event \t * that caused exit from kernel idling after PM operations. \t * \t * Some CPU low power states require enabling of interrupts \t * atomically when entering those states. The wake up from \t * such a state first executes code in the ISR of the interrupt \t * that caused the wake. This hook will be called from the ISR. \t * For such CPU LPS states, do post operations and restores here. \t * The kernel scheduler will get control after the ISR finishes \t * and it may schedule another thread. \t */\nif|if\ncondition|(\nname|atomic_test_and_clear_bit\nparameter_list|)\nblock|{\nname|uint8_t\nname|id\ninit|=\nname|CURRENT_CPU\ndecl_stmt|;\nname|k_spinlock_key_t\nname|key\ndecl_stmt|;\nname|SYS_PORT_TRACING_FUNC_ENTER",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_define\n-DECL|macro|CURRENT_CPU\n-define|#\n-directive|define\n-name|CURRENT_CPU\n-define|\\\n-value|(COND_CODE_1(CONFIG_SMP, (arch_curr_cpu()->id), (_current_cpu->id)))\n-end_define\n-\n-name|CURRENT_CPU\n+name|_current_cpu\n+operator|->\n+name|id\n-name|CURRENT_CPU\n+name|_current_cpu\n+operator|->\n+name|id\nThe issue was with: pm: Remove CURRENT_CPU macro\n\nJust use _current_cpu that works with/without multicore."
},{
  "instruction": "There is an issue in the following code. It relates to tests: lwm2m: Update lwm2m_engine tests\n\nFix lwm2m_message initialization. Pending struct was NULL. Please fix this issue.",
  "input": "Faulty tokenized code:\ndecl_stmt|;\nname|struct\nname|lwm2m_message\nname|msg\ndecl_stmt|;\noperator|(\nname|void\noperator|)\nname|memset\nargument_list|(\nname|ctx\noperator|=\noperator|&\nname|ctx\nexpr_stmt|;\nname|sys_slist_append\nargument_list|(\noperator|&\nname|ctx\noperator|.\ndecl_stmt|;\nname|struct\nname|lwm2m_message\nname|msg\ndecl_stmt|;\noperator|(\nname|void\noperator|)\nname|memset\nargument_list|(\noperator|&\nname|ctx\nexpr_stmt|;\nname|msg\noperator|.\nname|type\noperator|=\nname|COAP_TYPE_CON\nexpr_stmt|;\nname|sys_slist_append",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|struct\n+name|coap_pending\n+name|pending\n+decl_stmt|;\n+name|msg\n+operator|.\n+name|pending\n+operator|=\n+operator|&\n+name|pending\n+expr_stmt|;\n+name|struct\n+name|coap_pending\n+name|pending\n+decl_stmt|;\n+name|pending\n+operator|=\n+operator|&\n+name|pending\n+expr_stmt|;\n+name|msg\n+operator|.\nThe issue was with: tests: lwm2m: Update lwm2m_engine tests\n\nFix lwm2m_message initialization. Pending struct was NULL."
},{
  "instruction": "There is an issue in the following code. It relates to net: openthread: remove unneded call to `otLinkMetricsInit`\n\nPlatforms calculate Link Metrics values internally after using\n`otPlatRadioConfigureEnhAckProbing`. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\noperator|&\nname|cfg\nargument_list|)\nexpr_stmt|;\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_OPENTHREAD_LINK_METRICS_SUBJECT\nargument_list|)\nname|otLinkMetricsInit\nargument_list|(\nname|DEFAULT_SENSITIVITY\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\nblock|}\nend_function\n\nbegin_function\nDECL|function|transmit_message (struct k_work * tx_job)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-if|#\n-directive|if\n-name|defined\n-argument_list|(\n-name|CONFIG_OPENTHREAD_LINK_METRICS_SUBJECT\n-argument_list|)\n-name|otLinkMetricsInit\n-argument_list|(\n-name|DEFAULT_SENSITIVITY\n-argument_list|)\n-expr_stmt|;\n-endif|#\n-directive|endif\nThe issue was with: net: openthread: remove unneded call to `otLinkMetricsInit`\n\nPlatforms calculate Link Metrics values internally after using\n`otPlatRadioConfigureEnhAckProbing`."
},{
  "instruction": "There is an issue in the following code. It relates to net: wifi_shell: Add help for maximum channels in scan\n\nAdd a line for scan's -c parameter which specify\nto take care of maximum channels. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|MAX_BANDS_STR_LEN\nvalue|64\nend_define\n\nbegin_struct\nDECL|struct|__anon2a31a5870108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\nname|struct\nname|shell\nmodifier|*\nname|sh\ndecl_stmt|;\nDECL|union|__anon2a31a587020a\nunion|union\nblock|{\nDECL|struct|__anon2a31a5870308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\nliteral|\"[-b, --bands<Comma separated list of band values (2/5/6)>] : Bands to be scanned where 2: 2.4 GHz, 5: 5 GHz, 6: 6 GHz\\n\"\nliteral|\"[-a, --dwell_time_active<val_in_ms>] : Active scan dwell time (in ms) on a channel. Range 5 ms to 1000 ms\\n\"\nliteral|\"[-p, --dwell_time_passive<val_in_ms>] : Passive scan dwell time (in ms) on a channel. Range 10 ms to 1000 ms\\n\"\nliteral|\"[-s, --ssid] : SSID to scan for. Can be provided multiple times\\n\"\nliteral|\"[-m, --max_bss<val>] : Maximum BSSes to scan for. Range 1 - 65535\\n\"\nliteral|\"[-c, --chans<Comma separated list of channel ranges>] : Channels to be scanned. The channels must be specified in the form band1:chan1,chan2_band2:chan3,..etc. band1, band2 must be valid band values and chan1, chan2, chan3 must be specified as a list of comma separated values where each value is either a single channel or a channel range specified as chan_start-chan_end. Each band channel set has to be separated by a _. For example, a valid channel specification can be 2:1,6_5:36 or 2:1,6-11,14_5:36,163-177,52\\n\"\nliteral|\"[-h, --help] : Print out the help for the scan command.\\n\"\nargument_list|,\nname|cmd_wifi_scan\nargument_list|,\nliteral|1",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2a31a5870108\n+DECL|struct|__anon2afa87680108\n-DECL|union|__anon2a31a587020a\n+DECL|union|__anon2afa8768020a\n-DECL|struct|__anon2a31a5870308\n+DECL|struct|__anon2afa87680308\n-literal|\"[-c, --chans<Comma separated list of channel ranges>] : Channels to be scanned. The channels must be specified in the form band1:chan1,chan2_band2:chan3,..etc. band1, band2 must be valid band values and chan1, chan2, chan3 must be specified as a list of comma separated values where each value is either a single channel or a channel range specified as chan_start-chan_end. Each band channel set has to be separated by a _. For example, a valid channel specification can be 2:1,6_5:36 or 2:1,6-11,14_5:36,163-177,52\\n\"\n+literal|\"[-c, --chans<Comma separated list of channel ranges>] : Channels to be scanned. The channels must be specified in the form band1:chan1,chan2_band2:chan3,..etc. band1, band2 must be valid band values and chan1, chan2, chan3 must be specified as a list of comma separated values where each value is either a single channel or a channel range specified as chan_start-chan_end. Each band channel set has to be separated by a _. For example, a valid channel specification can be 2:1,6_5:36 or 2:1,6-11,14_5:36,163-177,52. Care should be taken to ensure that configured channels don't exceed CONFIG_WIFI_MGMT_SCAN_CHAN_MAX_MANUAL\\n\"\nThe issue was with: net: wifi_shell: Add help for maximum channels in scan\n\nAdd a line for scan's -c parameter which specify\nto take care of maximum channels."
},{
  "instruction": "There is an issue in the following code. It relates to net: socket: Change the printf modifier to print size_t correctly\n\nThe argument is size_t, so change the printf modifier to %zd\nto avoid warning prints. Please fix this issue.",
  "input": "Faulty tokenized code:\ncondition|)\nblock|{\nname|NET_WARN\nargument_list|(\nliteral|\"You have %d services to monitor but \"\nliteral|\"%d poll entries configured.\"\nargument_list|,\nname|count\noperator|+\nliteral|1\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"%d poll entries configured.\"\n+literal|\"%zd poll entries configured.\"\nThe issue was with: net: socket: Change the printf modifier to print size_t correctly\n\nThe argument is size_t, so change the printf modifier to %zd\nto avoid warning prints."
},{
  "instruction": "There is an issue in the following code. It relates to net: shell: Make the thread name longer for sockets command\n\nThe thread name output field was a bit too short in \\\"net sockets\\\"\ncommand, so make it 25 char long. Please fix this issue.",
  "input": "Faulty tokenized code:\nelse|#\ndirective|else\ndefine|#\ndirective|define\nname|THREAD_NAME_LEN\nvalue|16\nendif|#\ndirective|endif\nname|struct\nname|sock_obj_type_raw_stats\nname|stats\noperator|++\nexpr_stmt|;\nblock|}\nname|PR\nargument_list|(\nliteral|\"%16s  %-12s  %c%c%c\\t%-5s%-13d   %-10\"\nname|PRId64\nliteral|\"%-10\"\nname|PRId64\nliteral|\"\\n\"\nargument_list|,\noperator|&\nname|count\nexpr_stmt|;\nname|PR\nargument_list|(\nliteral|\"%16s  %-12s  %-5s\\t%-5s%-14s  %-10s%-10s\\n\"\nargument_list|,\nliteral|\"Creator\"\nargument_list|,\nliteral|\"Name\"\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|16\n+value|23\n-literal|\"%16s  %-12s  %c%c%c\\t%-5s%-13d   %-10\"\n+literal|\"%25s  %-12s  %c%c%c\\t%-5s%-13d   %-10\"\n-literal|\"%16s  %-12s  %-5s\\t%-5s%-14s  %-10s%-10s\\n\"\n+literal|\"%25s  %-12s  %-5s\\t%-5s%-14s  %-10s%-10s\\n\"\nThe issue was with: net: shell: Make the thread name longer for sockets command\n\nThe thread name output field was a bit too short in \\\"net sockets\\\"\ncommand, so make it 25 char long."
},{
  "instruction": "There is an issue in the following code. It relates to net: shell: Do not crash if no sockets are found\n\nThe \\\"net sockets\\\" command was not checking if there is any\nsockets in the system before trying to access them. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|k_obj_type_find\nargument_list|(\nname|K_OBJ_TYPE_SOCK\nargument_list|)\nexpr_stmt|;\nname|k_obj_type_walk_unlocked\nargument_list|(\nname|obj_type\nargument_list|,\nname|walk_sockets\noperator|)\noperator|&\nname|user_data\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|count\noperator|.\nname|opened",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|obj_type\n+operator|!=\n+name|NULL\n+condition|)\n+block|{\n+block|}\nThe issue was with: net: shell: Do not crash if no sockets are found\n\nThe \\\"net sockets\\\" command was not checking if there is any\nsockets in the system before trying to access them."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: clock_control: clock_control_ra.c: clock divider fix\n\nThe clock divider value is not being applied as the address of the\nregister to which it is being written is incorrect. A check of all RA MCU\ndatasheets confirms that, in all cases, the SCKDIVCR register is at an\noffset of 0x20 (and not 0x21). Please fix this issue.",
  "input": "Faulty tokenized code:\nname|z_clock_hw_cycles_per_sec\ndecl_stmt|;\nend_decl_stmt\n\nbegin_enum\nDECL|enum|__anon2adfa0200103\nenum|enum\nblock|{\nDECL|enumerator|CLKSRC_hoco\nname|CLKSRC_hoco\ninit|=\nblock|, }\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon2adfa0200203\nenum|enum\nblock|{\nDECL|enumerator|SCKDIV_1\nname|SCKDIV_1\ninit|=\nblock|}\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon2adfa0200303\nenum|enum\nblock|{\nDECL|enumerator|SCKDIV_POS_pclkd\nname|SCKDIV_POS_pclkd\ninit|=\nblock|}\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon2adfa0200403\nenum|enum\nblock|{\nDECL|enumerator|OSCSF_HOCOSF_POS\nname|OSCSF_HOCOSF_POS\ninit|=\nblock|, }\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon2adfa0200503\nenum|enum\nblock|{\nDECL|enumerator|OPCCR_OPCMTSF_POS\nname|OPCCR_OPCMTSF_POS\ninit|=\nliteral|0x2U\ndecl_stmt|;\nend_decl_stmt\n\nbegin_enum\nDECL|enum|__anon2adfa0200603\nenum|enum\nblock|{\nif|#\ndirective|if\nname|DT_INST_REG_SIZE_BY_NAME\nblock|, }\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon2adfa0200703\nenum|enum\nblock|{\nDECL|enumerator|SCKDIVCR_OFFSET\nname|SCKDIVCR_OFFSET\ninit|=\nliteral|0x021\nblock|,\nDECL|enumerator|SCKSCR_OFFSET\nname|SCKSCR_OFFSET\ninit|=\nliteral|0x026\nblock|, }\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon2adfa0200803\nenum|enum\nblock|{\nDECL|enumerator|SCRSCK_hoco\nname|SCRSCK_hoco\nblock|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon2adfa0200103\n+DECL|enum|__anon2af55e730103\n-DECL|enum|__anon2adfa0200203\n+DECL|enum|__anon2af55e730203\n-DECL|enum|__anon2adfa0200303\n+DECL|enum|__anon2af55e730303\n-DECL|enum|__anon2adfa0200403\n+DECL|enum|__anon2af55e730403\n-DECL|enum|__anon2adfa0200503\n+DECL|enum|__anon2af55e730503\n-DECL|enum|__anon2adfa0200603\n+DECL|enum|__anon2af55e730603\n-DECL|enum|__anon2adfa0200703\n+DECL|enum|__anon2af55e730703\n-literal|0x021\n+literal|0x020\n-DECL|enum|__anon2adfa0200803\n+DECL|enum|__anon2af55e730803\nThe issue was with: drivers: clock_control: clock_control_ra.c: clock divider fix\n\nThe clock divider value is not being applied as the address of the\nregister to which it is being written is incorrect. A check of all RA MCU\ndatasheets confirms that, in all cases, the SCKDIVCR register is at an\noffset of 0x20 (and not 0x21)."
},{
  "instruction": "There is an issue in the following code. It relates to usbc: fix shadowed declaration build error\n\nFixes:\n\n/__w/zephyr/zephyr/subsys/usb/usb_c/usbc_tc_src_states.c:260:21: error:\ndeclaration of 'ret' shadows a previous local [-Werror=shadow] Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ppc\noperator|!=\nname|NULL\ncondition|)\nblock|{\nname|int\nname|ret\ndecl_stmt|;\nname|ret\noperator|=\nname|ppc_set_src_ctrl\nargument_list|(\nname|data\nname|ppc\noperator|!=\nname|NULL\ncondition|)\nblock|{\nname|int\nname|ret\ndecl_stmt|;\nname|ret\noperator|=\nname|ppc_set_src_ctrl\nargument_list|(\nname|data",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|int\n-name|ret\n-decl_stmt|;\n-name|int\n-name|ret\n-decl_stmt|;\nThe issue was with: usbc: fix shadowed declaration build error\n\nFixes:\n\n/__w/zephyr/zephyr/subsys/usb/usb_c/usbc_tc_src_states.c:260:21: error:\ndeclaration of 'ret' shadows a previous local [-Werror=shadow]"
},{
  "instruction": "There is an issue in the following code. It relates to wifi: shell: Fix the channel extraction\n\nThe channel extraction from string directly uses the end variable with\nlimited data type, this causes issue if an invalid channel that exceeds\nthe data is given as an input e.g., 300, which would end up as a valid\nchannel 44.\n\nUse an intermediate variable with type that can hold all possible\ncombinations (valid and invalid) and only after validation assign that\nto the end type. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/* CONFIG_WIFI_MGMT_RAW_SCAN_RESULTS_ONLY */\nend_comment\n\nbegin_struct\nDECL|struct|__anon2bcda64e0108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\nname|struct\nname|shell\nmodifier|*\nname|sh\ndecl_stmt|;\nDECL|union|__anon2bcda64e020a\nunion|union\nblock|{\nDECL|struct|__anon2bcda64e0308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\noperator|<=\nliteral|3\noperator|)\ncondition|)\nblock|{\nname|params\noperator|->\nname|channel\noperator|=\nname|strtol\nargument_list|(\nname|argv\nindex|[\nname|idx\noperator|&\nname|endptr\nargument_list|,\nliteral|10\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\noperator|*\nname|endptr\noperator|!=\ncondition|(\nname|iface_mode\noperator|==\nname|WIFI_MODE_INFRA\noperator|&&\nname|params\noperator|->\nname|channel\noperator|==\nliteral|0\ncondition|)\nblock|{\nname|bands\nindex|[\nname|band\nindex|]\nargument_list|,\nname|params\noperator|->\nname|channel\nargument_list|)\ncondition|)\nblock|{\nname|found\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}\nblock|}\nname|idx\noperator|++\nexpr_stmt|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2bcda64e0108\n+DECL|struct|__anon2b64e2c40108\n-DECL|union|__anon2bcda64e020a\n+DECL|union|__anon2b64e2c4020a\n-DECL|struct|__anon2bcda64e0308\n+DECL|struct|__anon2b64e2c40308\n-name|params\n-operator|->\n+name|long\n-operator|=\n+init|=\n-expr_stmt|;\n+decl_stmt|;\n-name|params\n-operator|->\n-name|params\n-operator|->\n+name|params\n+operator|->\n+name|channel\n+operator|=\n+name|channel\n+expr_stmt|;\nThe issue was with: wifi: shell: Fix the channel extraction\n\nThe channel extraction from string directly uses the end variable with\nlimited data type, this causes issue if an invalid channel that exceeds\nthe data is given as an input e.g., 300, which would end up as a valid\nchannel 44.\n\nUse an intermediate variable with type that can hold all possible\ncombinations (valid and invalid) and only after validation assign that\nto the end type."
},{
  "instruction": "There is an issue in the following code. It relates to wifi: shell: Add a sanity check for MFP\n\nFor none and WPA-PSK MFP isn't applicable, it was only introduced in\nWPA2-PSK (RSN) and later. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/* CONFIG_WIFI_MGMT_RAW_SCAN_RESULTS_ONLY */\nend_comment\n\nbegin_struct\nDECL|struct|__anon29f8f8270108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\nname|struct\nname|shell\nmodifier|*\nname|sh\ndecl_stmt|;\nDECL|union|__anon29f8f827020a\nunion|union\nblock|{\nDECL|struct|__anon29f8f8270308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\nliteral|10\nargument_list|)\ndecl_stmt|;\nif|if\ncondition|(\nname|mfp\noperator|<=\nname|WIFI_MFP_REQUIRED\ncondition|)\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon29f8f8270108\n+DECL|struct|__anon276cc91b0108\n-DECL|union|__anon29f8f827020a\n+DECL|union|__anon276cc91b020a\n-DECL|struct|__anon29f8f8270308\n+DECL|struct|__anon276cc91b0308\n+name|security\n+operator|==\n+name|WIFI_SECURITY_TYPE_NONE\n+operator|||\n+name|security\n+operator|==\n+name|WIFI_SECURITY_TYPE_WPA_PSK\n+condition|)\n+block|{\n+return|return\n+operator|-\n+name|EINVAL\n+return|;\n+block|}\n+if|if\n+condition|(\nThe issue was with: wifi: shell: Add a sanity check for MFP\n\nFor none and WPA-PSK MFP isn't applicable, it was only introduced in\nWPA2-PSK (RSN) and later."
},{
  "instruction": "There is an issue in the following code. It relates to wifi: shell: Make channel mandatory for AP\n\nFor starting an AP mode, channel is mandatory, so, fix the arguments and\nthe help text. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/* CONFIG_WIFI_MGMT_RAW_SCAN_RESULTS_ONLY */\nend_comment\n\nbegin_struct\nDECL|struct|__anon2b5cb0b30108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\nname|struct\nname|shell\nmodifier|*\nname|sh\ndecl_stmt|;\nDECL|union|__anon2b5cb0b3020a\nunion|union\nblock|{\nDECL|struct|__anon2b5cb0b30308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}\ncomment|/* Channel (optional) */\nif|if\ncondition|(\noperator|(\nname|idx\noperator|<\nname|enable\nargument_list|,\nname|NULL\nargument_list|,\nliteral|\"\\\"<SSID>\\\"\\n\"\nliteral|\"[channel number: 0 means all]\\n\"\nliteral|\"[PSK: valid only for secure SSIDs]\\n\"\nliteral|\"[Security type: valid only for secure SSIDs]\\n\"\nliteral|\"0:None, 1:WPA2-PSK, 2:WPA2-PSK-256, 3:SAE, 4:WAPI, 5:EAP, 6:WEP, 7: WPA-PSK\\n\"\nliteral|\"[MFP (optional: needs security type to be specified)]\\n\"\nliteral|\": 0:Disable, 1:Optional, 2:Required.\\n\"\nargument_list|,\nname|cmd_wifi_ap_enable\nargument_list|,\nliteral|2\nargument_list|,\nliteral|4\nargument_list|)\nargument_list|,\nname|SHELL_CMD_ARG\nargument_list|(\nname|stations",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2b5cb0b30108\n+DECL|struct|__anon29f8f8270108\n-DECL|union|__anon2b5cb0b3020a\n+DECL|union|__anon29f8f827020a\n-DECL|struct|__anon2b5cb0b30308\n+DECL|struct|__anon29f8f8270308\n-comment|/* Channel (optional) */\n+comment|/* Channel (optional: STA, mandatory: AP) */\n-literal|\"[channel number: 0 means all]\\n\"\n+literal|\"<channel number>\\n\"\n-literal|2\n+literal|3\n-literal|4\n+literal|3\nThe issue was with: wifi: shell: Make channel mandatory for AP\n\nFor starting an AP mode, channel is mandatory, so, fix the arguments and\nthe help text."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Mesh: Fix processing SegAcks to wrong destination\n\nDo not process SegAcks which were not targeted to the node.\n\nThey were rejected in the next if statement always, but generated\nthe annyoing warning \\\"No matching TX context for ack\\\". Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}\nname|ack\noperator|=\nname|net_buf_simple_pull_be32\nargument_list|(\nname|buf\nargument_list|,\nname|buf\nargument_list|)\nreturn|;\nblock|}\ncomment|/* Only acks and heartbeats may need processing without local_match */\nif|if\ncondition|(\noperator|!\nname|rx\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|else if\n+condition|(\n+operator|!\n+name|rx\n+operator|->\n+name|local_match\n+condition|)\n+block|{\n+return|return\n+literal|0\n+return|;\n+block|}\n-comment|/* Only acks and heartbeats may need processing without local_match */\n+comment|/* Only acks for friendship and heartbeats may need processing without local_match */\nThe issue was with: Bluetooth: Mesh: Fix processing SegAcks to wrong destination\n\nDo not process SegAcks which were not targeted to the node.\n\nThey were rejected in the next if statement always, but generated\nthe annyoing warning \\\"No matching TX context for ack\\\"."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: gpio_mcux_lpc: Fix xt-clang error\n\nRemove gpio_clock_names and gpio_mcux_lpc_config->clock_ip_name from\ndrivers/gpio/gpio_mcux_lpc.c.\n\nThe drivers/gpio/gpio_mcux_lpc.c file did not compile with xt-clang\nRI-2021.8-win32, as the gpio_clock_names was initialised with a\nreference to a static const array. The clock_ip_name member was\ninitialised from this variable, but it isn't used anywhere else. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|endif\nDECL|member|port_no\nname|uint32_t\nname|port_no\ndecl_stmt|;\nDECL|member|clock_ip_name\nname|clock_ip_name_t\nname|clock_ip_name\ndecl_stmt|;\nblock|}\nstruct|;\nend_struct\n\nbegin_struct\nname|gpio_mcux_lpc_manage_cb\nblock|, }\ndecl_stmt|;\nend_decl_stmt\n\nbegin_decl_stmt\nDECL|variable|gpio_clock_names\nspecifier|static\nspecifier|const\nname|clock_ip_name_t\nname|gpio_clock_names\nindex|[]\ninit|=\nname|GPIO_CLOCKS\ndecl_stmt|;\nend_decl_stmt\n\nbegin_ifdef\nifdef|#\ndirective|ifdef\nname|IOPCTL\nend_ifdef\nname|GPIO_MCUX_LPC\nparameter_list|(\nname|n\nparameter_list|)\ndefine|\\\nvalue|static int lpc_gpio_init_##n(const struct device *dev);\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct gpio_mcux_lpc_config gpio_mcux_lpc_config_##n = {\t\t\\ \t\t.common = {\t\t\t\t\t\t\t\t\\ \t\t\t.port_pin_mask = GPIO_PORT_PIN_MASK_FROM_DT_INST(n),\t\t\\ \t\t},\t\t\t\t\t\t\t\t\t\\ \t\t.gpio_base = GPIO,\t\t\t\t\t\t\t\\ \t\t.pinmux_base = PINMUX_BASE,\t\t\t\t\t\t\\ \t\t.int_source = DT_INST_ENUM_IDX(n, int_source),\t\t\t\t\\ \t\t.port_no = DT_INST_PROP(n, port),\t\t\t\t\t\\ \t\t.clock_ip_name = gpio_clock_names[DT_INST_PROP(n, port)],\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct gpio_mcux_lpc_data gpio_mcux_lpc_data_##n;\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n, lpc_gpio_init_##n, NULL,\t\t\t\t\\&gpio_mcux_lpc_data_##n,\t\t\t\t\t\t\\&gpio_mcux_lpc_config_##n, PRE_KERNEL_1,\t\t\t\t\\ \t\t    CONFIG_GPIO_INIT_PRIORITY,\t\t\t\t\t\t\\&gpio_mcux_lpc_driver_api);\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tstatic int lpc_gpio_init_##n(const struct device *dev)\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\t\t\\ \t\tgpio_mcux_lpc_init(dev);\t\t\t\t\t\t\\ \t\tGPIO_MCUX_LPC_MODULE_IRQ(n);\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\treturn 0;\t\t\t\t\t\t\t\t\\ \t}\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|member|clock_ip_name\n-name|clock_ip_name_t\n-name|clock_ip_name\n-decl_stmt|;\n-begin_decl_stmt\n-DECL|variable|gpio_clock_names\n-specifier|static\n-specifier|const\n-name|clock_ip_name_t\n-name|gpio_clock_names\n-index|[]\n-init|=\n-name|GPIO_CLOCKS\n-decl_stmt|;\n-end_decl_stmt\n-\n-value|static int lpc_gpio_init_##n(const struct device *dev);\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct gpio_mcux_lpc_config gpio_mcux_lpc_config_##n = {\t\t\\ \t\t.common = {\t\t\t\t\t\t\t\t\\ \t\t\t.port_pin_mask = GPIO_PORT_PIN_MASK_FROM_DT_INST(n),\t\t\\ \t\t},\t\t\t\t\t\t\t\t\t\\ \t\t.gpio_base = GPIO,\t\t\t\t\t\t\t\\ \t\t.pinmux_base = PINMUX_BASE,\t\t\t\t\t\t\\ \t\t.int_source = DT_INST_ENUM_IDX(n, int_source),\t\t\t\t\\ \t\t.port_no = DT_INST_PROP(n, port),\t\t\t\t\t\\ \t\t.clock_ip_name = gpio_clock_names[DT_INST_PROP(n, port)],\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct gpio_mcux_lpc_data gpio_mcux_lpc_data_##n;\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n, lpc_gpio_init_##n, NULL,\t\t\t\t\\&gpio_mcux_lpc_data_##n,\t\t\t\t\t\t\\&gpio_mcux_lpc_config_##n, PRE_KERNEL_1,\t\t\t\t\\ \t\t    CONFIG_GPIO_INIT_PRIORITY,\t\t\t\t\t\t\\&gpio_mcux_lpc_driver_api);\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tstatic int lpc_gpio_init_##n(const struct device *dev)\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\t\t\\ \t\tgpio_mcux_lpc_init(dev);\t\t\t\t\t\t\\ \t\tGPIO_MCUX_LPC_MODULE_IRQ(n);\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\treturn 0;\t\t\t\t\t\t\t\t\\ \t}\n+value|static int lpc_gpio_init_##n(const struct device *dev);\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tstatic const struct gpio_mcux_lpc_config gpio_mcux_lpc_config_##n = {\t\t\\ \t\t.common = {\t\t\t\t\t\t\t\t\\ \t\t\t.port_pin_mask = GPIO_PORT_PIN_MASK_FROM_DT_INST(n),\t\t\\ \t\t},\t\t\t\t\t\t\t\t\t\\ \t\t.gpio_base = GPIO,\t\t\t\t\t\t\t\\ \t\t.pinmux_base = PINMUX_BASE,\t\t\t\t\t\t\\ \t\t.int_source = DT_INST_ENUM_IDX(n, int_source),\t\t\t\t\\ \t\t.port_no = DT_INST_PROP(n, port)\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct gpio_mcux_lpc_data gpio_mcux_lpc_data_##n;\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n, lpc_gpio_init_##n, NULL,\t\t\t\t\\&gpio_mcux_lpc_data_##n,\t\t\t\t\t\t\\&gpio_mcux_lpc_config_##n, PRE_KERNEL_1,\t\t\t\t\\ \t\t    CONFIG_GPIO_INIT_PRIORITY,\t\t\t\t\t\t\\&gpio_mcux_lpc_driver_api);\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \tstatic int lpc_gpio_init_##n(const struct device *dev)\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\t\t\\ \t\tgpio_mcux_lpc_init(dev);\t\t\t\t\t\t\\ \t\tGPIO_MCUX_LPC_MODULE_IRQ(n);\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\treturn 0;\t\t\t\t\t\t\t\t\\ \t}\nThe issue was with: drivers: gpio_mcux_lpc: Fix xt-clang error\n\nRemove gpio_clock_names and gpio_mcux_lpc_config->clock_ip_name from\ndrivers/gpio/gpio_mcux_lpc.c.\n\nThe drivers/gpio/gpio_mcux_lpc.c file did not compile with xt-clang\nRI-2021.8-win32, as the gpio_clock_names was initialised with a\nreference to a static const array. The clock_ip_name member was\ninitialised from this variable, but it isn't used anywhere else."
},{
  "instruction": "There is an issue in the following code. It relates to posix: pthread: priority should be of `int` type\n\nChanged the variable type of the priority in the args and the\nreturn type of the conversion functions to `int`, as both\nZephyr's priority & POSIX's `sched_priority` has type `int`. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|zephyr_to_posix_priority (int32_t z_prio,int * policy)\nspecifier|static\nname|uint32_t\nname|zephyr_to_posix_priority\nparameter_list|(\nname|int32_t\nname|z_prio\nparameter_list|,\nname|int\nmodifier|*\nname|policy\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|posix_to_zephyr_priority (uint32_t priority,int policy)\nspecifier|static\nname|int32_t\nname|posix_to_zephyr_priority\nparameter_list|(\nname|uint32_t\nname|priority\nparameter_list|,\nname|int\nname|policy\nparameter_list|)\nname|sched_param\nmodifier|*\nname|param\nparameter_list|)\nblock|{\nname|uint32_t\nname|priority\ndecl_stmt|;\nname|struct\nname|posix_thread\nmodifier|*",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|zephyr_to_posix_priority (int32_t z_prio,int * policy)\n+DECL|function|zephyr_to_posix_priority (int z_prio,int * policy)\n-name|uint32_t\n+name|int\n-name|int32_t\n+name|int\n-DECL|function|posix_to_zephyr_priority (uint32_t priority,int policy)\n+DECL|function|posix_to_zephyr_priority (int priority,int policy)\n-name|int32_t\n+name|int\n-name|uint32_t\n+name|int\n-name|uint32_t\n+name|int\nThe issue was with: posix: pthread: priority should be of `int` type\n\nChanged the variable type of the priority in the args and the\nreturn type of the conversion functions to `int`, as both\nZephyr's priority & POSIX's `sched_priority` has type `int`."
},{
  "instruction": "There is an issue in the following code. It relates to posix: pthread: fix typos\n\n- 'piority' should be 'priority'\n- COOP should start from `-CONFIG_NUM_COOP_PRIORITIES` Please fix this issue.",
  "input": "Faulty tokenized code:\nname|true\nreturn|;\nblock|}\nname|LOG_ERR\nargument_list|(\nliteral|\"Invalid piority %d and / or policy %d\"\nargument_list|,\nname|priority\nargument_list|,\nname|policy\nargument_list|)\nname|policy\noperator|==\nname|SCHED_FIFO\ncondition|)\nblock|{\ncomment|/* COOP: highest [CONFIG_NUM_COOP_PRIORITIES, -1] lowest */\nname|__ASSERT_NO_MSG\nargument_list|(\nname|priority\noperator|<\nname|CONFIG_NUM_COOP_PRIORITIES",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"Invalid piority %d and / or policy %d\"\n+literal|\"Invalid priority %d and / or policy %d\"\n-comment|/* COOP: highest [CONFIG_NUM_COOP_PRIORITIES, -1] lowest */\n+comment|/* COOP: highest [-CONFIG_NUM_COOP_PRIORITIES, -1] lowest */\nThe issue was with: posix: pthread: fix typos\n\n- 'piority' should be 'priority'\n- COOP should start from `-CONFIG_NUM_COOP_PRIORITIES`"
},{
  "instruction": "There is an issue in the following code. It relates to posix: pthread: fix `zephyr_to_posix_priority` assert test\n\nIf `z_prio` is negative and we want to make sure that it is\nwithin `[-CONFIG_NUM_COOP_PRIORITIES, -1]`, we should invert\nits sign and make sure that it is `<=`\n`CONFIG_NUM_COOP_PRIORITIES` instead of `<`. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|0\ncondition|)\nblock|{\nname|__ASSERT_NO_MSG\nargument_list|(\nname|z_prio\noperator|<\nname|CONFIG_NUM_COOP_PRIORITIES\nargument_list|)\nexpr_stmt|;\nblock|}\nelse|else",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|-\n-operator|<\n+operator|<=\nThe issue was with: posix: pthread: fix `zephyr_to_posix_priority` assert test\n\nIf `z_prio` is negative and we want to make sure that it is\nwithin `[-CONFIG_NUM_COOP_PRIORITIES, -1]`, we should invert\nits sign and make sure that it is `<=`\n`CONFIG_NUM_COOP_PRIORITIES` instead of `<`."
},{
  "instruction": "There is an issue in the following code. It relates to posix: uname: shell: update help message with more information\n\nPopulate the help message with more information when an error\noccurs. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|UNAME_ALL\ndefine|\\\nvalue|(UNAME_KERNEL | UNAME_NODE | UNAME_RELEASE | UNAME_VERSION | UNAME_MACHINE | UNAME_PLATFORM)\nend_define\n\nbegin_function\nDECL|function|uname_print_usage (const struct shell * sh)\nspecifier|static\nname|void\nname|uname_print_usage\nblock|{\nname|shell_print\nargument_list|(\nname|sh\nargument_list|,\nliteral|\"usage: uname [-asonrvmpi]\"\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nblock|{\nname|shell_error\nargument_list|(\nname|sh\nargument_list|,\nliteral|\"extra operand %s\"\nargument_list|,\nname|argv\nindex|[\nname|optind\nindex|]",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_define\n+DECL|macro|HELP_USAGE\n+define|#\n+directive|define\n+name|HELP_USAGE\n+define|\\\n+value|\"Usage: uname [OPTION]\\n\"                                                                  \\ \t\"Print system information\\n\"                                                               \\ \t\"\\n\"                                                                                       \\ \t\"    -a,  all informationn\\n\"                                                              \\ \t\"    -s,  kernel name\\n\"                                                                   \\ \t\"    -o,  operating system\\n\"                                                              \\ \t\"    -n,  network node hostname\\n\"                                                         \\ \t\"    -r,  kernel release\\n\"                                                                \\ \t\"    -v,  kernel version\\n\"                                                                \\ \t\"    -m,  machine hardware name\\n\"                                                         \\ \t\"    -p,  processor type\\n\"                                                                \\ \t\"    -i,  hardware platform\\n\"\n+end_define\n+\n-literal|\"usage: uname [-asonrvmpi]\"\n+name|HELP_USAGE\n-literal|\"extra operand %s\"\n+literal|\"uname: extra operand %s\"\nThe issue was with: posix: uname: shell: update help message with more information\n\nPopulate the help message with more information when an error\noccurs."
},{
  "instruction": "There is an issue in the following code. It relates to samples: posix: uname: convert to use `printf`\n\nConvert to `printf` from `printk` to be more POSIX-y. Please fix this issue.",
  "input": "Faulty tokenized code:\nend_comment\n\nbegin_include\ninclude|#\ndirective|include\nfile|<unistd.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<sys/utsname.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/kernel.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nargument_list|(\noperator|&\nname|info\nargument_list|)\nexpr_stmt|;\nname|printk\nargument_list|(\nliteral|\"\\nPrinting everything in utsname...\\n\"\nargument_list|)\nexpr_stmt|;\nname|printk\nargument_list|(\nliteral|\"sysname[%zu]: %s\\n\"\nargument_list|,\nsizeof|sizeof\nargument_list|(\nname|info\noperator|.\nname|sysname\nargument_list|)\nexpr_stmt|;\nname|printk\nargument_list|(\nliteral|\"nodename[%zu]: %s\\n\"\nargument_list|,\nsizeof|sizeof\nargument_list|(\nname|info\noperator|.\nname|nodename\nargument_list|)\nexpr_stmt|;\nname|printk\nargument_list|(\nliteral|\"release[%zu]: %s\\n\"\nargument_list|,\nsizeof|sizeof\nargument_list|(\nname|info\noperator|.\nname|release\nargument_list|)\nexpr_stmt|;\nname|printk\nargument_list|(\nliteral|\"version[%zu]: %s\\n\"\nargument_list|,\nsizeof|sizeof\nargument_list|(\nname|info\noperator|.\nname|version\nargument_list|)\nexpr_stmt|;\nname|printk\nargument_list|(\nliteral|\"machine[%zu]: %s\\n\"\nargument_list|,\nsizeof|sizeof\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-file|<unistd.h>\n+file|<stdio.h>\n-file|<sys/utsname.h>\n+file|<unistd.h>\n-file|<zephyr/kernel.h>\n+file|<sys/utsname.h>\n-name|printk\n+name|printf\n-name|printk\n+name|printf\n-name|printk\n+name|printf\n-name|printk\n+name|printf\n-name|printk\n+name|printf\n-name|printk\n+name|printf\nThe issue was with: samples: posix: uname: convert to use `printf`\n\nConvert to `printf` from `printk` to be more POSIX-y."
},{
  "instruction": "There is an issue in the following code. It relates to driver: I2C: npcx: re-enable interrupts after bus error\n\nWhen the I2C is in the target mode and encounters the bus error, the\ndriver has to reset the bus to recover the I2C hardware. However, when\nthe hardware is disabled, the interrupt enable bits are also cleared\nautomatically by design. As a result, we need to enable the interrupts\nafter resetting the I2C hardware. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|BIT\nargument_list|(\nname|NPCX_SMBCTL2_ENABLE\nargument_list|)\nexpr_stmt|;\ncomment|/* End of transaction */\nname|data\noperator|->\nname|oper_state\noperator|=\nname|NPCX_I2C_IDLE\nexpr_stmt|;\nreturn|return;\nblock|}\ncomment|/* A 'Slave Stop' Condition has been identified */\nif|if\ncondition|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* \t\t * Re-enable interrupts because they are turned off after the SMBus module \t\t * is reset above. \t\t */\n+name|inst\n+operator|->\n+name|SMBCTL1\n+operator||=\n+name|BIT\n+argument_list|(\n+name|NPCX_SMBCTL1_NMINTE\n+argument_list|)\n+operator||\n+name|BIT\n+argument_list|(\n+name|NPCX_SMBCTL1_INTEN\n+argument_list|)\n+expr_stmt|;\n+name|LOG_DBG\n+argument_list|(\n+literal|\"target: Bus error on port%02x!\"\n+argument_list|,\n+name|data\n+operator|->\n+name|port\n+argument_list|)\n+expr_stmt|;\nThe issue was with: driver: I2C: npcx: re-enable interrupts after bus error\n\nWhen the I2C is in the target mode and encounters the bus error, the\ndriver has to reset the bus to recover the I2C hardware. However, when\nthe hardware is disabled, the interrupt enable bits are also cleared\nautomatically by design. As a result, we need to enable the interrupts\nafter resetting the I2C hardware."
},{
  "instruction": "There is an issue in the following code. It relates to riscv: irq: Correct CLIC_INTATTR_TRIG_Msk\n\nThe trig field of clicintattr is indeed in bits 2:1. However, the mask\n`CLIC_INTATTR_TRIG_Msk` is only applied directly to the bitfield\n`INTATTR.b.trg`. Therefore it doesn't have to be shifted additionally. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_union\nDECL|union|CLICCFG\nunion|union\nname|CLICCFG\nblock|{\nDECL|struct|__anon2952a4880108\nstruct|struct\nblock|{\nDECL|member|_reserved0\nname|uint8_t\nname|_reserved0\nbegin_union\nDECL|union|CLICINFO\nunion|union\nname|CLICINFO\nblock|{\nDECL|struct|__anon2952a4880208\nstruct|struct\nblock|{\ncomment|/** number of max supported interrupts */\nDECL|member|numint\nname|uint32_t\nbegin_union\nDECL|union|CLICINTIP\nunion|union\nname|CLICINTIP\nblock|{\nDECL|struct|__anon2952a4880308\nstruct|struct\nblock|{\ncomment|/** Interrupt Pending */\nDECL|member|IP\nname|uint8_t\nbegin_union\nDECL|union|CLICINTIE\nunion|union\nname|CLICINTIE\nblock|{\nDECL|struct|__anon2952a4880408\nstruct|struct\nblock|{\ncomment|/** Interrupt Enabled */\nDECL|member|IE\nname|uint8_t\nbegin_union\nDECL|union|CLICINTATTR\nunion|union\nname|CLICINTATTR\nblock|{\nDECL|struct|__anon2952a4880508\nstruct|struct\nblock|{\ncomment|/** 0: non-vectored 1:vectored */\nDECL|member|shv\nname|uint8_t\ndirective|define\nname|ECLIC_MODE_MTVEC_Msk\nvalue|3U\nend_define\n\nbegin_comment\ncomment|/** CLIC INTATTR: TRIG Position */\nend_comment\n\nbegin_define\nDECL|macro|CLIC_INTATTR_TRIG_Pos\ndefine|#\ndirective|define\nname|CLIC_INTATTR_TRIG_Pos\nvalue|1U\nend_define\n\nbegin_comment\ncomment|/** CLIC INTATTR: TRIG Mask */\nend_comment\n\nbegin_define\nDECL|macro|CLIC_INTATTR_TRIG_Msk\ndefine|#\ndirective|define\nname|CLIC_INTATTR_TRIG_Msk\nvalue|(0x3UL<< CLIC_INTATTR_TRIG_Pos)\nend_define\n\nbegin_define\nDECL|macro|ECLIC_CFG\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2952a4880108\n+DECL|struct|__anon2a0f3d180108\n-DECL|struct|__anon2952a4880208\n+DECL|struct|__anon2a0f3d180208\n-DECL|struct|__anon2952a4880308\n+DECL|struct|__anon2a0f3d180308\n-DECL|struct|__anon2952a4880408\n+DECL|struct|__anon2a0f3d180408\n-DECL|struct|__anon2952a4880508\n+DECL|struct|__anon2a0f3d180508\n-begin_comment\n-comment|/** CLIC INTATTR: TRIG Position */\n-end_comment\n-\n-begin_define\n-DECL|macro|CLIC_INTATTR_TRIG_Pos\n-define|#\n-directive|define\n-name|CLIC_INTATTR_TRIG_Pos\n-value|1U\n-end_define\n-\n-value|(0x3UL<< CLIC_INTATTR_TRIG_Pos)\n+value|0x3U\nThe issue was with: riscv: irq: Correct CLIC_INTATTR_TRIG_Msk\n\nThe trig field of clicintattr is indeed in bits 2:1. However, the mask\n`CLIC_INTATTR_TRIG_Msk` is only applied directly to the bitfield\n`INTATTR.b.trg`. Therefore it doesn't have to be shifted additionally."
},{
  "instruction": "There is an issue in the following code. It relates to pm: console: Use async runtime put to minimize resumption/suspension\n\nWhen device runtime pm is enabled on console device, do not suspend\ndevice synchronously on each char transmission, but rather use asynchronous\nsuspension request.\nThis will save useless and costly suspension/resumption procedure, which\ncan involve uart device clock suspension but also pin configuration\nto sleep state (which itself involves gpio clock activation ...).\n\nOn STM32, using asynch device suspension allows to divide by 3 the\ntransmission time of a character chain. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|uart_console_dev\nargument_list|,\nname|c\nargument_list|)\nexpr_stmt|;\ncomment|/* As errors cannot be returned, ignore the return value */\noperator|(\nname|void\noperator|)\nname|pm_device_runtime_put\nargument_list|(\nname|uart_console_dev\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|c\nreturn|;\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_enum\nDECL|enum|__anon2761d49d0103\nenum|enum\nblock|{\nDECL|enumerator|ESC_ESC\nname|ESC_ESC\nblock|,\noperator|)\nname|err\nexpr_stmt|;\nname|cleanup\nlabel|:\ncomment|/* As errors cannot be returned, ignore the return value */\noperator|(\nname|void\noperator|)\nname|pm_device_runtime_put\nargument_list|(\nname|uart_dev\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|length\nreturn|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* As errors cannot be returned, ignore the return value */\n+comment|/* Use async put to avoid useless device suspension/resumption \t * when tranmiting chain of chars. \t * As errors cannot be returned, ignore the return value \t */\n-name|pm_device_runtime_put\n+name|pm_device_runtime_put_async\n+argument_list|,\n+name|K_MSEC\n+argument_list|(\n+literal|1\n+argument_list|)\n-DECL|enum|__anon2761d49d0103\n+DECL|enum|__anon2b8d23dc0103\n-comment|/* As errors cannot be returned, ignore the return value */\n+comment|/* Use async put to avoid useless device suspension/resumption \t * when tranmiting chain of chars. \t * As errors cannot be returned, ignore the return value \t */\n-name|pm_device_runtime_put\n+name|pm_device_runtime_put_async\n+argument_list|,\n+name|K_MSEC\n+argument_list|(\n+literal|1\n+argument_list|)\nThe issue was with: pm: console: Use async runtime put to minimize resumption/suspension\n\nWhen device runtime pm is enabled on console device, do not suspend\ndevice synchronously on each char transmission, but rather use asynchronous\nsuspension request.\nThis will save useless and costly suspension/resumption procedure, which\ncan involve uart device clock suspension but also pin configuration\nto sleep state (which itself involves gpio clock activation ...).\n\nOn STM32, using asynch device suspension allows to divide by 3 the\ntransmission time of a character chain."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: smp: put comment on SMP code\n\nAdds some comments to the SMP code to, hopefully, make it\na bit more clear to future readers. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|atomic_t\nname|global_lock\ndecl_stmt|;\nend_decl_stmt\n\nbegin_decl_stmt\nDECL|variable|cpu_start_flag\nspecifier|static\nname|atomic_t\nname|cpu_start_flag\ndecl_stmt|;\nend_decl_stmt\n\nbegin_decl_stmt\nDECL|variable|ready_flag\nspecifier|static\nname|atomic_t\nname|ready_flag\nmodifier|*\nname|csc\ninit|=\nname|arg\ndecl_stmt|;\noperator|(\nname|void\noperator|)\nname|atomic_set\nargument_list|(\nname|ready_flag\nargument_list|,\nliteral|1\nargument_list|)\nexpr_stmt|;\nname|wait_for_start_signal\nargument_list|(\noperator|&\nname|cpu_start_flag\nargument_list|)\nexpr_stmt|;\nname|z_dummy_thread_init\nargument_list|(\noperator|&\nname|dummy_thread\nargument_list|)\noperator|->\nname|arg\nargument_list|)\nexpr_stmt|;\nblock|}\nname|z_swap_unlocked\nargument_list|()\nexpr_stmt|;\nname|CODE_UNREACHABLE\nexpr_stmt|;\nname|cpu_start_cb\nmodifier|*\nname|csc\nparameter_list|)\nblock|{\nname|z_init_cpu\nargument_list|(\nname|id\nargument_list|)\nexpr_stmt|;\noperator|(\nname|void\noperator|)\nname|atomic_clear\nargument_list|(\noperator|&\nname|ready_flag\nargument_list|)\nexpr_stmt|;\nname|arch_start_cpu\nargument_list|(\nname|id\nargument_list|,\nname|z_interrupt_stacks\nname|smp_init_top\nargument_list|,\nname|csc\nargument_list|)\nexpr_stmt|;\nwhile|while\ncondition|(\noperator|!\nname|atomic_get\nargument_list|(\noperator|.\nname|arg\noperator|=\nname|arg\nexpr_stmt|;\noperator|(\nname|void\noperator|)\nname|atomic_set\nargument_list|(\nname|cpu_start_flag\nargument_list|,\nliteral|1\nargument_list|)\nexpr_stmt|;\ncomment|/* async, don't care */\nname|start_cpu\nargument_list|(\nname|id\nargument_list|,\noperator|&\nname|z_smp_init\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\noperator|(\nname|void\noperator|)\nname|atomic_clear\nargument_list|(\noperator|&\nname|cpu_start_flag\nargument_list|)\nexpr_stmt|;\nname|unsigned\nname|int\nname|num_cpus\ninit|=\nname|arch_num_cpus\nargument_list|,\nname|NULL\nargument_list|)\nexpr_stmt|;\nblock|}\noperator|(\nname|void\noperator|)\nname|atomic_set\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_comment\n+comment|/**  * Flag to tell recently powered up CPU to start  * initialization routine.  *  * 0 to tell powered up CPU to wait.  * 1 to tell powered up CPU to continue initialization.  */\n+end_comment\n+\n+begin_comment\n+comment|/**  * Flag to tell caller that the target CPU is now  * powered up and ready to be initialized.  *  * 0 if target CPU is not yet ready.  * 1 if target CPU has powered up and ready to be initialized.  */\n+end_comment\n+\n+comment|/* Let start_cpu() know that this CPU has powered up. */\n+comment|/* Wait for the CPU start caller to signal that \t * we can start initialization. \t */\n+comment|/* Initialize the dummy thread struct so that \t * the scheduler can schedule actual threads to run. \t */\n+comment|/* Let scheduler decide what thread to run next. */\n+comment|/* Initialize various CPU structs related to this CPU. */\n+comment|/* Clear the ready flag so the newly powered up CPU can \t * signal that it has powered up. \t */\n+comment|/* Power up the CPU */\n+comment|/* Wait until the newly powered up CPU to signal that \t * it has powered up. \t */\n+comment|/* We are only starting one CPU so we do not need to synchronize \t * across all CPUs using the start_flag. So just set it to 1. \t */\n-comment|/* async, don't care */\n+comment|/* Start the CPU! */\n+comment|/* We are powering up all CPUs and we want to synchronize their \t * entry into scheduler. So set the start flag to 0 here. \t */\n+comment|/* Just start CPUs one by one. */\n+comment|/* Let loose those CPUs so they can start scheduling \t * threads to run. \t */\nThe issue was with: kernel: smp: put comment on SMP code\n\nAdds some comments to the SMP code to, hopefully, make it\na bit more clear to future readers."
},{
  "instruction": "There is an issue in the following code. It relates to x86: add CODE_UNREACHABLE to z_x86_cpu_init\n\nFor some reason, unrelated code change triggered compiler\nwarning about this function returns even though it is\nmarked nonreturn. So add CODE_UNREACHABLE to silence\nthe warning, possibly to catch any errors. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|cpuboot\noperator|->\nname|arg\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nend_unit\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|CODE_UNREACHABLE\n+expr_stmt|;\n+comment|/* LCOV_EXCL_LINE */\nThe issue was with: x86: add CODE_UNREACHABLE to z_x86_cpu_init\n\nFor some reason, unrelated code change triggered compiler\nwarning about this function returns even though it is\nmarked nonreturn. So add CODE_UNREACHABLE to silence\nthe warning, possibly to catch any errors."
},{
  "instruction": "There is an issue in the following code. It relates to net: mgmt: Print correct TWT teardown status message\n\nPrint success message for TWT teardown successful case. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/* CONFIG_WIFI_MGMT_RAW_SCAN_RESULTS_ONLY */\nend_comment\n\nbegin_struct\nDECL|struct|__anon28b38d840108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\nname|struct\nname|shell\nmodifier|*\nname|sh\ndecl_stmt|;\nDECL|union|__anon28b38d84020a\nunion|union\nblock|{\nDECL|struct|__anon28b38d840308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\noperator|.\nname|sh\nargument_list|,\nname|SHELL_NORMAL\nargument_list|,\nliteral|\"TWT teardown received for flow ID %d\\n\"\nargument_list|,\nname|resp\noperator|->\nname|flow_id\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon28b38d840108\n+DECL|struct|__anon2b5cb0b30108\n-DECL|union|__anon28b38d84020a\n+DECL|union|__anon2b5cb0b3020a\n-DECL|struct|__anon28b38d840308\n+DECL|struct|__anon2b5cb0b30308\n-literal|\"TWT teardown received for flow ID %d\\n\"\n+literal|\"TWT teardown succeeded for flow ID %d\\n\"\nThe issue was with: net: mgmt: Print correct TWT teardown status message\n\nPrint success message for TWT teardown successful case."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: i2c: set 'i2c_driver_api' as 'static const'\n\nThis change marks each instance of the 'i2c_driver_api' as 'static const'.\nThe rationale is that 'i2c_driver_api' is used for declaring internal\nmodule interfaces and is not intended to be modified at runtime.\nBy using 'static const', we ensure immutability, leading to usage of only\n.rodata and a reduction in the .data area. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nend_function\n\nbegin_decl_stmt\nDECL|variable|gpio_i2c_switch_api_funcs\nspecifier|const\nname|struct\nname|i2c_driver_api\nname|gpio_i2c_switch_api_funcs\ninit|=\nend_function\n\nbegin_decl_stmt\nDECL|variable|i2c_ambiq_driver_api\nspecifier|static\nname|struct\nname|i2c_driver_api\nname|i2c_ambiq_driver_api\ninit|=\nblock|{\nend_comment\n\nbegin_decl_stmt\nDECL|variable|i2c_emul_api\nspecifier|static\nname|struct\nname|i2c_driver_api\nname|i2c_emul_api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|i2c_gd32_driver_api\nspecifier|static\nname|struct\nname|i2c_driver_api\nname|i2c_gd32_driver_api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|api\nspecifier|static\nname|struct\nname|i2c_driver_api\nname|api\ninit|=\nblock|{\nend_function_decl\n\nbegin_decl_stmt\nDECL|variable|i2c_nios2_driver_api\nspecifier|static\nname|struct\nname|i2c_driver_api\nname|i2c_nios2_driver_api\ninit|=\nblock|{\nbegin_struct\nDECL|struct|sbcon\nstruct|struct\nname|sbcon\nblock|{\nDECL|union|__anon2ac12646010a\nunion|union\nblock|{\nDECL|member|SB_CONTROLS\nspecifier|volatile\nname|uint32_t\nend_function\n\nbegin_decl_stmt\nDECL|variable|api\nspecifier|static\nname|struct\nname|i2c_driver_api\nname|api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|i2c_sifive_api\nspecifier|static\nname|struct\nname|i2c_driver_api\nname|i2c_sifive_api\ninit|=\nblock|{\nblock|}\nend_function\n\nbegin_decl_stmt\nDECL|variable|tca954x_api_funcs\nspecifier|const\nname|struct\nname|i2c_driver_api\nname|tca954x_api_funcs\ninit|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n+specifier|static\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\n-DECL|union|__anon2ac12646010a\n+DECL|union|__anon28c86911010a\n+specifier|const\n+specifier|const\n+specifier|static\nThe issue was with: drivers: i2c: set 'i2c_driver_api' as 'static const'\n\nThis change marks each instance of the 'i2c_driver_api' as 'static const'.\nThe rationale is that 'i2c_driver_api' is used for declaring internal\nmodule interfaces and is not intended to be modified at runtime.\nBy using 'static const', we ensure immutability, leading to usage of only\n.rodata and a reduction in the .data area."
},{
  "instruction": "There is an issue in the following code. It relates to tfm: Use PSA error codes instead of TFM error codes\n\nThe TFM error codes are no longer in the interface headers.\nAll TF-M functions return PSA status codes, so use this here as well. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nreturn|return\noperator|(\nname|int32_t\noperator|)\nname|TFM_ERROR_GENERIC\nreturn|;\nblock|}\nif|#\ndirective|if\noperator|!\nname|void\nparameter_list|)\nblock|{\ncomment|/* \t * The static K_MUTEX_DEFINE handles mutex initialization, \t * so this function may be implemented as no-op. \t */\nreturn|return\nname|TFM_SUCCESS\nreturn|;\nblock|}\nend_function\n\nbegin_if\nname|__ASSERT\nargument_list|(\nname|tfm_ns_interface_init\nargument_list|()\noperator|==\nname|TFM_SUCCESS\nargument_list|,\nliteral|\"TF-M NS interface init failed\"\nargument_list|)\nexpr_stmt|;\nreturn|return",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|TFM_ERROR_GENERIC\n+name|PSA_ERROR_GENERIC_ERROR\n-name|TFM_SUCCESS\n+name|PSA_SUCCESS\n-name|TFM_SUCCESS\n+name|PSA_SUCCESS\nThe issue was with: tfm: Use PSA error codes instead of TFM error codes\n\nThe TFM error codes are no longer in the interface headers.\nAll TF-M functions return PSA status codes, so use this here as well."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: bluetooth: ambiq: fix the naming of rx message buffer\n\nThis change renames the RX message buffer from g_hciRxMsg to rxmsg,\nas it does not follow the Zephyr coding style. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|SPI_MAX_RX_MSG_LEN\nvalue|258\nend_define\n\nbegin_decl_stmt\nDECL|variable|g_hciRxMsg\nspecifier|static\nname|uint8_t\nname|__noinit\nname|g_hciRxMsg\nindex|[\nname|SPI_MAX_RX_MSG_LEN\nindex|]\ndecl_stmt|;\nend_decl_stmt\nname|ret\noperator|=\nname|spi_receive_packet\nargument_list|(\noperator|&\nname|g_hciRxMsg\nindex|[\nliteral|0\nindex|]\nargument_list|,\noperator|&\nif|if\ncondition|(\nname|bt_apollo_vnd_rcv_ongoing\nargument_list|(\noperator|&\nname|g_hciRxMsg\nindex|[\nliteral|0\nindex|]\nargument_list|,\nname|len\nblock|{\nbreak|break;\nblock|}\nswitch|switch\ncondition|(\nname|g_hciRxMsg\nindex|[\nname|PACKET_TYPE\nindex|]\ncondition|)\nblock|{\nname|buf\noperator|=\nname|bt_hci_evt_recv\nargument_list|(\noperator|&\nname|g_hciRxMsg\nindex|[\nname|PACKET_TYPE\noperator|+\nname|PACKET_TYPE_SIZE\nindex|]\nname|buf\noperator|=\nname|bt_hci_acl_recv\nargument_list|(\noperator|&\nname|g_hciRxMsg\nindex|[\nname|PACKET_TYPE\noperator|+\nname|PACKET_TYPE_SIZE\nindex|]\nexpr_stmt|;\nname|LOG_WRN\nargument_list|(\nliteral|\"Unknown BT buf type %d\"\nargument_list|,\nname|g_hciRxMsg\nindex|[\nname|PACKET_TYPE\nindex|]\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|variable|g_hciRxMsg\n+DECL|variable|rxmsg\n-name|g_hciRxMsg\n+name|rxmsg\n-name|g_hciRxMsg\n+name|rxmsg\n-name|g_hciRxMsg\n+name|rxmsg\n-name|g_hciRxMsg\n+name|rxmsg\n-name|g_hciRxMsg\n+name|rxmsg\n-name|g_hciRxMsg\n+name|rxmsg\n-name|g_hciRxMsg\n+name|rxmsg\nThe issue was with: drivers: bluetooth: ambiq: fix the naming of rx message buffer\n\nThis change renames the RX message buffer from g_hciRxMsg to rxmsg,\nas it does not follow the Zephyr coding style."
},{
  "instruction": "There is an issue in the following code. It relates to bluetooth: hci: place tx/rx message buffer in .noinit section\n\nThis change relocates the tx/rx message buffer from the .bss section\nto the .noinit section. This adjustment is aimed at reducing boot time by\nlowering the size of the .bss section, without impacting the operational\nfunctionality of the buffer. Please fix this issue.",
  "input": "Faulty tokenized code:\n\nbegin_decl_stmt\nDECL|variable|g_hciRxMsg\nspecifier|static\nname|uint8_t\nname|g_hciRxMsg\nindex|[\nname|SPI_MAX_RX_MSG_LEN\nindex|]\ndecl_stmt|;\n\nbegin_decl_stmt\nDECL|variable|rxmsg\nspecifier|static\nname|uint8_t\nname|rxmsg\nindex|[\nname|SPI_MAX_MSG_LEN\nindex|]\ndecl_stmt|;\n\nbegin_decl_stmt\nDECL|variable|txmsg\nspecifier|static\nname|uint8_t\nname|txmsg\nindex|[\nname|SPI_MAX_MSG_LEN\nindex|]\ndecl_stmt|;\n\nbegin_decl_stmt\nDECL|variable|buffer\nspecifier|static\nname|uint32_t\nname|buffer\nindex|[\nname|DIVC\nargument_list|(\nname|BLE_DYN_ALLOC_SIZE\n\nbegin_decl_stmt\nDECL|variable|rxmsg\nspecifier|static\nname|uint8_t\nname|rxmsg\nindex|[\nname|SPI_MAX_MSG_LEN\nindex|]\ndecl_stmt|;\n\nbegin_decl_stmt\nDECL|variable|txmsg\nspecifier|static\nname|uint8_t\nname|txmsg\nindex|[\nname|SPI_MAX_MSG_LEN\nindex|]\ndecl_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|__noinit\n+name|__noinit\n+name|__noinit\n+name|__noinit\n+name|__noinit\n+name|__noinit\nThe issue was with: bluetooth: hci: place tx/rx message buffer in .noinit section\n\nThis change relocates the tx/rx message buffer from the .bss section\nto the .noinit section. This adjustment is aimed at reducing boot time by\nlowering the size of the .bss section, without impacting the operational\nfunctionality of the buffer."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: display: update otm8009a config\n\nOTM8009A_MCS_NO_DOC2(0xCFD0U) only write buf[0], but write length\nset to 3. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|OTM8009A_MCS_NO_DOC2\nargument_list|,\nname|buf\nargument_list|,\nliteral|3\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|ret",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|3\n+literal|1\nThe issue was with: drivers: display: update otm8009a config\n\nOTM8009A_MCS_NO_DOC2(0xCFD0U) only write buf[0], but write length\nset to 3."
},{
  "instruction": "There is an issue in the following code. It relates to wifi: esp_at: compile without `NET_NATIVE_IPV4`\n\nAllow the driver to compile without `CONFIG_NET_NATIVE_IPV4`. This can\nhappen if the driver is only desired for SSID scanning. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|esp_mode_switch_submit_if_needed\nargument_list|(\nname|dev\nargument_list|)\nexpr_stmt|;\nname|net_if_ipv4_addr_rm\nargument_list|(\nname|dev\noperator|->\nname|net_iface\nname|dev\noperator|->\nname|ip\nargument_list|)\nexpr_stmt|;\nname|net_if_dormant_on\nargument_list|(\nname|dev\noperator|->\nname|net_iface\nargument_list|)\nargument_list|)\nexpr_stmt|;\nreturn|return;\nblock|}\ncomment|/* update interface addresses */\nname|net_if_ipv4_set_gw\nargument_list|(\nname|dev\noperator|->\nliteral|0\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\nif|if\ncondition|(\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_WIFI_ESP_AT_DNS_USE\noperator|->\nname|mode\noperator|=\nliteral|0\nexpr_stmt|;\nname|net_if_ipv4_addr_rm\nargument_list|(\nname|dev\noperator|->\nname|net_iface\nname|dev\noperator|->\nname|ip\nargument_list|)\nexpr_stmt|;\nname|k_work_submit_to_queue\nargument_list|(\noperator|&\nname|dev\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|#\n+directive|if\n+name|defined\n+argument_list|(\n+name|CONFIG_NET_NATIVE_IPV4\n+argument_list|)\n+endif|#\n+directive|endif\n+if|#\n+directive|if\n+name|defined\n+argument_list|(\n+name|CONFIG_NET_NATIVE_IPV4\n+argument_list|)\n+endif|#\n+directive|endif\n+if|#\n+directive|if\n+name|defined\n+argument_list|(\n+name|CONFIG_NET_NATIVE_IPV4\n+argument_list|)\n+endif|#\n+directive|endif\nThe issue was with: wifi: esp_at: compile without `NET_NATIVE_IPV4`\n\nAllow the driver to compile without `CONFIG_NET_NATIVE_IPV4`. This can\nhappen if the driver is only desired for SSID scanning."
},{
  "instruction": "There is an issue in the following code. It relates to ace: use a 'switch' statement in pm_state_set()\n\nUse 'switch' to emphasise that we're handling different values of\n'state' in pm_state_set(). Please fix this issue.",
  "input": "Faulty tokenized code:\nname|z_xt_ints_off\nargument_list|(\nliteral|0xffffffff\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|state\noperator|==\nname|PM_STATE_SOFT_OFF\ncondition|)\nblock|{\nname|core_desc\nindex|[\nname|cpu\nindex|]\noperator|.\nargument_list|(\nname|cpu\nargument_list|)\nexpr_stmt|;\nblock|}\nblock|}\nif|else if\ncondition|(\nname|state\noperator|==\nname|PM_STATE_RUNTIME_IDLE\ncondition|)\nblock|{\nname|DSPCS\noperator|.\nname|bootctl\nindex|[\nname|cpu\nname|power_gate_entry\nargument_list|(\nname|cpu\nargument_list|)\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\nname|__ASSERT\nargument_list|(\nname|false\nargument_list|,\nliteral|\"invalid argument - unsupported power state\"",
  "result": "I corrected the issue in the code by changing the following tokens:\n-if|if\n+switch|switch\n-operator|==\n-name|PM_STATE_SOFT_OFF\n+case|case\n+name|PM_STATE_SOFT_OFF\n+case|:\n-block|}\n-if|else if\n-condition|(\n-name|state\n-operator|==\n+break|break;\n+case|case\n-condition|)\n-block|{\n+case|:\n-block|}\n-else|else\n-block|{\n+break|break;\n+default|default:\nThe issue was with: ace: use a 'switch' statement in pm_state_set()\n\nUse 'switch' to emphasise that we're handling different values of\n'state' in pm_state_set()."
},{
  "instruction": "There is an issue in the following code. It relates to ace: remove superfluous variable initialisation\n\n'ret' in pm_state_set() is always set before it's used, no need to\ninitialise it. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|arch_proc_id\nargument_list|()\ndecl_stmt|;\nname|int\nname|ret\ninit|=\nliteral|0\ndecl_stmt|;\nname|ARG_UNUSED\nargument_list|(\nname|ret\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-init|=\n-literal|0\nThe issue was with: ace: remove superfluous variable initialisation\n\n'ret' in pm_state_set() is always set before it's used, no need to\ninitialise it."
},{
  "instruction": "There is an issue in the following code. It relates to runtime-pm: remove a superfluous k_is_pre_kernel() test\n\nIf runtime_suspend() is called early during Zephyr initialisation,\nwhile k_is_pre_kernel() returns 'true,' 'async' is set to 'false,' so\nif 'async' is 'true,' Zephyr initialisation is definitely complete,\nso there is no need to check k_is_pre_kernel() again. Please fix this issue.",
  "input": "Faulty tokenized code:\ngoto|;\nblock|}\nif|if\ncondition|(\nname|async\noperator|&&\noperator|!\nname|k_is_pre_kernel\nargument_list|()\ncondition|)\nblock|{\ncomment|/* queue suspend */\nname|pm\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|&&\n-operator|!\n-name|k_is_pre_kernel\n-argument_list|()\nThe issue was with: runtime-pm: remove a superfluous k_is_pre_kernel() test\n\nIf runtime_suspend() is called early during Zephyr initialisation,\nwhile k_is_pre_kernel() returns 'true,' 'async' is set to 'false,' so\nif 'async' is 'true,' Zephyr initialisation is definitely complete,\nso there is no need to check k_is_pre_kernel() again."
},{
  "instruction": "There is an issue in the following code. It relates to intel-adsp: use proper error codes\n\nUse proper errno.h error codes in pd_intel_adsp_set_power_enable()\ninstead of -1. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\ncondition|)\nblock|{\nreturn|return\noperator|-\nliteral|1\nreturn|;\nblock|}\nblock|}\nelse|else\nblock|{\noperator|!=\nname|INTEL_ADSP_ACE15_MAGIC_KEY\ncondition|)\nreturn|return\noperator|-\nliteral|1\nreturn|;\nblock|}\nendif|#\ndirective|endif\nname|sys_write16",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|1\n+name|EIO\n-literal|1\n+name|EINVAL\nThe issue was with: intel-adsp: use proper error codes\n\nUse proper errno.h error codes in pd_intel_adsp_set_power_enable()\ninstead of -1."
},{
  "instruction": "There is an issue in the following code. It relates to net: openthread: fix `otLinkMetricsInit` usage\n\nRemove usage of `otPlatRadioGetReceiveSensitivity` without the\n`otInstance` parameter. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|PHR_DURATION_US\nvalue|32U\nend_define\n\nbegin_enum\nDECL|enum|pending_events\nenum|enum\nname|pending_events\nblock|{\nargument_list|(\nname|CONFIG_OPENTHREAD_LINK_METRICS_SUBJECT\nargument_list|)\nname|otLinkMetricsInit\nargument_list|(\nname|otPlatRadioGetReceiveSensitivity\nargument_list|()\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\nblock|}\nargument_list|(\nname|aInstance\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nliteral|100\nreturn|;\nblock|}\nend_function\n\nbegin_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_define\n+DECL|macro|DEFAULT_SENSITIVITY\n+define|#\n+directive|define\n+name|DEFAULT_SENSITIVITY\n+value|-100\n+end_define\n+\n-name|otPlatRadioGetReceiveSensitivity\n-argument_list|()\n+name|DEFAULT_SENSITIVITY\n-operator|-\n-literal|100\n+name|DEFAULT_SENSITIVITY\nThe issue was with: net: openthread: fix `otLinkMetricsInit` usage\n\nRemove usage of `otPlatRadioGetReceiveSensitivity` without the\n`otInstance` parameter."
},{
  "instruction": "There is an issue in the following code. It relates to shell: telnet: Don't close the connection on ENOBUFS error\n\nIf there's not enough networking buffers at certain moment,\nthey might become available later. So instead of closing connection\n(and failing assertation) sleep and retry. This avoid the following\nassertion failure when there's much of data to send:\n\n    net_pkt: Data buffer (1500) allocation failed.\n    net_tcp: conn: 0x20076024 packet allocation failed, len=1460\n    shell_telnet: Failed to send -105, shutting down\n    ASSERTION FAIL [err == 0] @ .../subsys/shell/shell_ops.c:416\n    os: r0/a1:  0x00000004  r1/a2:  0x000001a0  r2/a3:  0x00000004\n    os: r3/a4:  0x20044380 r12/ip:  0x00001958 r14/lr:  0x080c9027\n    os:  xpsr:  0x41000000\n    os: Faulting instruction address (r15/pc): 0x0811ed26\n    os: >>> ZEPHYR FATAL ERROR 4: Kernel panic on CPU 0\n    os: Current thread: 0x20045100 (shell_telnet)\n    os: Halting system Please fix this issue.",
  "input": "Faulty tokenized code:\ncondition|(\nname|ret\noperator|==\noperator|-\nname|EAGAIN\ncondition|)\nblock|{\nname|k_sleep\nargument_list|(\nname|K_MSEC\ncondition|(\nname|ret\noperator|==\noperator|-\nname|EAGAIN\ncondition|)\nblock|{\nname|k_sleep\nargument_list|(\nname|K_MSEC",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|||\n+name|ret\n+operator|==\n+operator|-\n+name|ENOBUFS\n+operator|||\n+name|ret\n+operator|==\n+operator|-\n+name|ENOBUFS\nThe issue was with: shell: telnet: Don't close the connection on ENOBUFS error\n\nIf there's not enough networking buffers at certain moment,\nthey might become available later. So instead of closing connection\n(and failing assertation) sleep and retry. This avoid the following\nassertion failure when there's much of data to send:\n\n    net_pkt: Data buffer (1500) allocation failed.\n    net_tcp: conn: 0x20076024 packet allocation failed, len=1460\n    shell_telnet: Failed to send -105, shutting down\n    ASSERTION FAIL [err == 0] @ .../subsys/shell/shell_ops.c:416\n    os: r0/a1:  0x00000004  r1/a2:  0x000001a0  r2/a3:  0x00000004\n    os: r3/a4:  0x20044380 r12/ip:  0x00001958 r14/lr:  0x080c9027\n    os:  xpsr:  0x41000000\n    os: Faulting instruction address (r15/pc): 0x0811ed26\n    os: >>> ZEPHYR FATAL ERROR 4: Kernel panic on CPU 0\n    os: Current thread: 0x20045100 (shell_telnet)\n    os: Halting system"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: pinctrl: ra: fix write-protect register access\n\nThe write protect register (PWPR) found on RA Microcontrollers is an 8-bit\nregister at an odd address. It was being accessed using a pointer to a\nuint32_t which causes a fault on some devices in the series. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|PIN_NUM\nvalue|16\nend_define\n\nbegin_enum\nDECL|enum|__anon28de40000103\nenum|enum\nblock|{\nDECL|enumerator|PWPR_PFSWE_POS\nname|PWPR_PFSWE_POS\ninit|=\n\nbegin_function\nDECL|function|pinctrl_ra_read_PMISC_PWPR (size_t port,size_t pin)\nspecifier|static\nspecifier|inline\nname|uint32_t\nname|pinctrl_ra_read_PMISC_PWPR\nparameter_list|(\nname|size_t\nname|port\nparameter_list|,\nname|size_t\nname|pin\nparameter_list|)\nblock|{\nreturn|return\nname|sys_read32\nargument_list|(\nname|DT_INST_REG_ADDR_BY_NAME\nargument_list|(\nliteral|0\nargument_list|,\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|pinctrl_ra_write_PMISC_PWPR (uint32_t value)\nspecifier|static\nspecifier|inline\nname|void\nname|pinctrl_ra_write_PMISC_PWPR\nparameter_list|(\nname|uint32_t\nname|value\nparameter_list|)\nblock|{\nname|sys_write32\nargument_list|(\nname|value\nargument_list|,\nname|DT_INST_REG_ADDR_BY_NAME\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon28de40000103\n+DECL|enum|__anon2ac5ebdd0103\n-name|uint32_t\n+name|uint8_t\n-name|sys_read32\n+name|sys_read8\n-DECL|function|pinctrl_ra_write_PMISC_PWPR (uint32_t value)\n+DECL|function|pinctrl_ra_write_PMISC_PWPR (uint8_t value)\n-name|uint32_t\n+name|uint8_t\n-name|sys_write32\n+name|sys_write8\nThe issue was with: drivers: pinctrl: ra: fix write-protect register access\n\nThe write protect register (PWPR) found on RA Microcontrollers is an 8-bit\nregister at an odd address. It was being accessed using a pointer to a\nuint32_t which causes a fault on some devices in the series."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: rtc: pcf8563: fix ifdef for alarm_set_callback\n\nThe callback should only be available when CONFIG_RTC_ALARM is defined. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|.\nname|alarm_is_pending\noperator|=\nname|pcf8563_alarm_is_pending\nblock|,\nendif|#\ndirective|endif\nifdef|#\ndirective|ifdef\nname|PCF8563_INT1_GPIOS_IN_USE\noperator|.\nname|alarm_set_callback\noperator|=\nname|pcf8563_alarm_set_callback\nblock|,\nendif|#\ndirective|endif\nblock|}\ndecl_stmt|;\nend_decl_stmt\n\nbegin_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-endif|#\n-directive|endif\n+endif|#\n+directive|endif\nThe issue was with: drivers: rtc: pcf8563: fix ifdef for alarm_set_callback\n\nThe callback should only be available when CONFIG_RTC_ALARM is defined."
},{
  "instruction": "There is an issue in the following code. It relates to wifi: shell: Fix typo in comparison\n\nThe length should be 3 for WMM not 4. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/* CONFIG_WIFI_MGMT_RAW_SCAN_RESULTS_ONLY */\nend_comment\n\nbegin_struct\nDECL|struct|__anon298072260108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\nname|struct\nname|shell\nmodifier|*\nname|sh\ndecl_stmt|;\nDECL|union|__anon29807226020a\nunion|union\nblock|{\nDECL|struct|__anon298072260308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\nliteral|1\nindex|]\nargument_list|,\nliteral|\"WMM\"\nargument_list|,\nliteral|4\nargument_list|)\ncondition|)\nblock|{\nname|params\noperator|.",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon298072260108\n+DECL|struct|__anon28b38d840108\n-DECL|union|__anon29807226020a\n+DECL|union|__anon28b38d84020a\n-DECL|struct|__anon298072260308\n+DECL|struct|__anon28b38d840308\n-literal|4\n+literal|3\nThe issue was with: wifi: shell: Fix typo in comparison\n\nThe length should be 3 for WMM not 4."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: BAP: Fix uninitialized variable in source_reconfig\n\nThe stream_in_subgroup variable in bt_bap_broadcast_source_reconfig\nmay have been uninitialized. Please fix this issue.",
  "input": "Faulty tokenized code:\nmodifier|*\nname|param_stream\ndecl_stmt|;\nname|bool\nname|stream_in_subgroup\ndecl_stmt|;\nname|param_stream\noperator|=\nname|subgroup_param\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n+init|=\n+name|false\nThe issue was with: Bluetooth: BAP: Fix uninitialized variable in source_reconfig\n\nThe stream_in_subgroup variable in bt_bap_broadcast_source_reconfig\nmay have been uninitialized."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: BAP: Add log of err in bt_bap_stream_detach\n\nWe can't really do anything about it if it fails, so we\nsimply log the value. Please fix this issue.",
  "input": "Faulty tokenized code:\ncondition|(\noperator|!\nname|is_broadcast\ncondition|)\nblock|{\nname|bt_bap_stream_disconnect\nargument_list|(\nname|stream\nargument_list|)\nexpr_stmt|;\nblock|}\nblock|}\nend_function\n\nbegin_function\nDECL|function|bt_bap_stream_disconnect (struct bt_bap_stream * stream)\nname|int",
  "result": "I corrected the issue in the code by changing the following tokens:\n+specifier|const\n+name|int\n+name|err\n+init|=\n+decl_stmt|;\n+if|if\n+condition|(\n+name|err\n+operator|!=\n+literal|0\n+condition|)\n+block|{\n+name|LOG_DBG\n+argument_list|(\n+literal|\"Failed to disconnect stream %p: %d\"\n+argument_list|,\n+name|stream\n+argument_list|,\n+name|err\n+argument_list|)\n+block|}\nThe issue was with: Bluetooth: BAP: Add log of err in bt_bap_stream_detach\n\nWe can't really do anything about it if it fails, so we\nsimply log the value."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: CAP: Shell: Fix channel allocation\n\nThe channel allocation was incorrect when setting up multiple\nstreams to a single device, in which case we should apply\nindividual bits to each stream. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|++\nexpr_stmt|;\nname|stream_cnt\noperator|++\nexpr_stmt|;\nif|if\ncondition|(\nname|param\noperator|->\nname|conn_cnt\noperator|>\nliteral|1\ncondition|)\nblock|{\nspecifier|const\nname|int\nname|err\noperator|++\nexpr_stmt|;\nname|stream_cnt\noperator|++\nexpr_stmt|;\nif|if\ncondition|(\nname|param\noperator|->\nname|conn_cnt\noperator|>\nliteral|1\ncondition|)\nblock|{\nspecifier|const\nname|int\nname|err",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* If we have more than 1 connection or stream in one direction, we set the \t\t\t * location bit accordingly \t\t\t */\n-literal|1\n+literal|1U\n+operator|||\n+name|param\n+operator|->\n+name|snk_cnt\n+index|[\n+name|i\n+index|]\n+operator|>\n+literal|1U\n+comment|/* If we have more than 1 connection or stream in one direction, we set the \t\t\t * location bit accordingly \t\t\t */\n-literal|1\n+literal|1U\n+operator|||\n+name|param\n+operator|->\n+name|src_cnt\n+index|[\n+name|i\n+index|]\n+operator|>\n+literal|1U\nThe issue was with: Bluetooth: CAP: Shell: Fix channel allocation\n\nThe channel allocation was incorrect when setting up multiple\nstreams to a single device, in which case we should apply\nindividual bits to each stream."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: uart_mcux_lpuart: Switch to using DT_INST_IRQN_BY_IDX\n\nAfter #63289, multi-level interrupts are now encoded using macro\nmagic. This means that using the generic DT_INST_IRQ_BY_IDX() to\nfetch the INTID is no longer an option as the queried INTID will\nbe the one specified through the node's `interrupts` properties.\nTo fix this, switch to using DT_INST_IRQN_BY_IDX() which will\nreturn the correctly encoded INTID. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|n\nparameter_list|,\nname|i\nparameter_list|)\ndefine|\\\nvalue|do {\t\t\t\t\t\t\t\t\\ \t\tIRQ_CONNECT(DT_INST_IRQ_BY_IDX(n, i, irq),\t\t\\ \t\t\t    DT_INST_IRQ_BY_IDX(n, i, priority),\t\t\\ \t\t\t    mcux_lpuart_isr, DEVICE_DT_INST_GET(n), 0);\t\\ \t\t\t\t\t\t\t\t\t\\ \t\tirq_enable(DT_INST_IRQ_BY_IDX(n, i, irq));\t\t\\ \t} while (false)\nend_define\n\nbegin_define\nDECL|macro|MCUX_LPUART_IRQ_INIT (n)\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|do {\t\t\t\t\t\t\t\t\\ \t\tIRQ_CONNECT(DT_INST_IRQ_BY_IDX(n, i, irq),\t\t\\ \t\t\t    DT_INST_IRQ_BY_IDX(n, i, priority),\t\t\\ \t\t\t    mcux_lpuart_isr, DEVICE_DT_INST_GET(n), 0);\t\\ \t\t\t\t\t\t\t\t\t\\ \t\tirq_enable(DT_INST_IRQ_BY_IDX(n, i, irq));\t\t\\ \t} while (false)\n+value|do {\t\t\t\t\t\t\t\t\\ \t\tIRQ_CONNECT(DT_INST_IRQN_BY_IDX(n, i),\t\t\t\\ \t\t\t    DT_INST_IRQ_BY_IDX(n, i, priority),\t\t\\ \t\t\t    mcux_lpuart_isr, DEVICE_DT_INST_GET(n), 0);\t\\ \t\t\t\t\t\t\t\t\t\\ \t\tirq_enable(DT_INST_IRQ_BY_IDX(n, i, irq));\t\t\\ \t} while (false)\nThe issue was with: drivers: serial: uart_mcux_lpuart: Switch to using DT_INST_IRQN_BY_IDX\n\nAfter #63289, multi-level interrupts are now encoded using macro\nmagic. This means that using the generic DT_INST_IRQ_BY_IDX() to\nfetch the INTID is no longer an option as the queried INTID will\nbe the one specified through the node's `interrupts` properties.\nTo fix this, switch to using DT_INST_IRQN_BY_IDX() which will\nreturn the correctly encoded INTID."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: sam u(s)art: correct interpretation of RXRDY flag\n\nThe receiver ready flag of the (channel) status register\nfor the sam controller was not being interpreted correctly\nfor both the uart and usart implementation,\naccording to the uart api.\nTested and confirmed using the sam4sa16ca. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|)\ncondition|)\nblock|{\nreturn|return\noperator|-\nname|EBUSY\nreturn|;\nblock|}\ncomment|/* got a character */\noperator|*\nname|c\noperator|)\ncondition|)\nblock|{\nreturn|return\noperator|-\nname|EBUSY\nreturn|;\nblock|}\ncomment|/* got a character */\noperator|*\nname|c",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|EBUSY\n+literal|1\n-name|EBUSY\n+literal|1\nThe issue was with: drivers: serial: sam u(s)art: correct interpretation of RXRDY flag\n\nThe receiver ready flag of the (channel) status register\nfor the sam controller was not being interpreted correctly\nfor both the uart and usart implementation,\naccording to the uart api.\nTested and confirmed using the sam4sa16ca."
},{
  "instruction": "There is an issue in the following code. It relates to pm: device_runtime: Fix domain mgmt in async put\n\nThe asynchronous put is not checking if the device was successfully\nsuspended before suspending its domain and it is not checking if the\ndomain was claimed. This patch adds these two checks. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\ncomment|/* \t * On async put, we have to suspend the domain when the device \t * finishes its operation \t */\nif|if\ncondition|(\nname|PM_DOMAIN\nargument_list|(\nname|pm\nargument_list|)\noperator|!=\nname|NULL\ncondition|)\nblock|{\noperator|(\nname|void\noperator|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|PM_DOMAIN\n+operator|(\n+name|ret\n+operator|==\n+literal|0\n+operator|)\n+operator|&&\n+name|atomic_test_bit\n+operator|&\n+operator|->\n+name|flags\n+argument_list|,\n+name|PM_DEVICE_FLAG_PD_CLAIMED\n-operator|!=\n-name|NULL\nThe issue was with: pm: device_runtime: Fix domain mgmt in async put\n\nThe asynchronous put is not checking if the device was successfully\nsuspended before suspending its domain and it is not checking if the\ndomain was claimed. This patch adds these two checks."
},{
  "instruction": "There is an issue in the following code. It relates to bmi160: Fix gyro range map\n\nThe range map was sorted wrong since the function\nbmi160_range_to_reg_val() that uses it checks for the user value less\nthan the range component of the bmi160_range struct. This means that\nno matter what range is set, the value will always end up 2000dps. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|bmi160_pmu_status\nmodifier|*\nname|pmu_sts\nparameter_list|)\nblock|{\nDECL|struct|__anon2ae89da10108\nstruct|struct\nblock|{\nDECL|member|cmd\nname|uint8_t\nname|cmd\nbegin_comment\ncomment|/*  * Output data rate map with allowed frequencies:  * freq = freq_int + freq_milli / 1000  *  * Since we don't need a finer frequency resolution than milliHz, use uint16_t  * to save some flash.  */\nend_comment\n\nbegin_struct\nDECL|struct|__anon2ae89da10208\nstruct|struct\nblock|{\nDECL|member|freq_int\nname|uint16_t\nname|freq_int\nname|bmi160_gyr_range_map\nindex|[]\ninit|=\nblock|{\nblock|{\nliteral|2000\nblock|,\nname|BMI160_GYR_RANGE_2000DPS\nblock|}\nblock|,\nblock|{\nliteral|1000\nblock|,\nname|BMI160_GYR_RANGE_1000DPS\nblock|}\nblock|,\nblock|{\nliteral|500\nblock|,\nname|BMI160_GYR_RANGE_500DPS\nblock|}\nblock|,\nblock|{\nliteral|250\nblock|,\nname|BMI160_GYR_RANGE_250DPS\nblock|}\nblock|,\nblock|{\nliteral|125\nblock|,\nname|BMI160_GYR_RANGE_125DPS\nblock|}\nblock|, }\ndecl_stmt|;\nend_decl_stmt\n\nname|sensor_value\nmodifier|*\nname|ofs\nparameter_list|)\nblock|{\nDECL|struct|__anon2ae89da10308\nstruct|struct\nblock|{\nDECL|member|lsb_addr\nname|uint8_t\nname|lsb_addr",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2ae89da10108\n+DECL|struct|__anon29d73e8d0108\n-DECL|struct|__anon2ae89da10208\n+DECL|struct|__anon29d73e8d0208\n-literal|2000\n+literal|125\n-name|BMI160_GYR_RANGE_2000DPS\n+name|BMI160_GYR_RANGE_125DPS\n-literal|1000\n+literal|250\n-name|BMI160_GYR_RANGE_1000DPS\n+name|BMI160_GYR_RANGE_250DPS\n-literal|250\n+literal|1000\n-name|BMI160_GYR_RANGE_250DPS\n+name|BMI160_GYR_RANGE_1000DPS\n-literal|125\n+literal|2000\n-name|BMI160_GYR_RANGE_125DPS\n+name|BMI160_GYR_RANGE_2000DPS\n-DECL|struct|__anon2ae89da10308\n+DECL|struct|__anon29d73e8d0308\nThe issue was with: bmi160: Fix gyro range map\n\nThe range map was sorted wrong since the function\nbmi160_range_to_reg_val() that uses it checks for the user value less\nthan the range component of the bmi160_range struct. This means that\nno matter what range is set, the value will always end up 2000dps."
},{
  "instruction": "There is an issue in the following code. It relates to test: bmi160: rename test directory\n\nRename the test directory to more accuratly reflect what's being\ntested. Please fix this issue.",
  "input": "Faulty tokenized code:\nsimilarity index 100%\nrename from tests/drivers/sensor/accel/CMakeLists.txt\nrename to tests/drivers/sensor/bmi160/CMakeLists.txt\nsimilarity index 100%\nrename from tests/drivers/sensor/accel/boards/native_sim.conf\nrename to tests/drivers/sensor/bmi160/boards/native_sim.conf\nsimilarity index 100%\nrename from tests/drivers/sensor/accel/boards/native_sim.overlay\nrename to tests/drivers/sensor/bmi160/boards/native_sim.overlay\nsimilarity index 100%\nrename from tests/drivers/sensor/accel/include/checks.h\nrename to tests/drivers/sensor/bmi160/include/checks.h\nsimilarity index 100%\nrename from tests/drivers/sensor/accel/include/fixture.h\nrename to tests/drivers/sensor/bmi160/include/fixture.h\nsimilarity index 100%\nrename from tests/drivers/sensor/accel/prj.conf\nrename to tests/drivers/sensor/bmi160/prj.conf\nsimilarity index 99%\nrename from tests/drivers/sensor/accel/src/fixture.c\nrename to tests/drivers/sensor/bmi160/src/fixture.c\nname|emul\nmodifier|*\nname|emulator\nparameter_list|)\nblock|{\nDECL|struct|__anon27cecdc10108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|channel\nname|enum\nsimilarity index 100%\nrename from tests/drivers/sensor/accel/src/i2c.c\nrename to tests/drivers/sensor/bmi160/src/i2c.c\nsimilarity index 100%\nrename from tests/drivers/sensor/accel/src/spi.c\nrename to tests/drivers/sensor/bmi160/src/spi.c\nsimilarity index 100%\nrename from tests/drivers/sensor/accel/testcase.yaml\nrename to tests/drivers/sensor/bmi160/testcase.yaml",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon27cecdc10108\n+DECL|struct|__anon2b86a2ff0108\nThe issue was with: test: bmi160: rename test directory\n\nRename the test directory to more accuratly reflect what's being\ntested."
},{
  "instruction": "There is an issue in the following code. It relates to net: shell: Avoid gcc warning print with string catenation\n\ngcc prints this warning message\n\n'strncat' specified bound 1 equals source length [-Wstringop-overflow=]\n   58 |                 strncat(fd, \\\"C\\\", 1);\n\nThere was no error in the code but avoid the warning by not using\nstrncat(). Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|=\nname|obj\noperator|->\nname|create_time\nexpr_stmt|;\nname|strncat\nargument_list|(\nname|fd\nargument_list|,\nliteral|\"C\"\nargument_list|,\nliteral|1\nargument_list|)\nexpr_stmt|;\nname|count\noperator|->\nname|closed\noperator|++",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|strncat\n-argument_list|(\n-argument_list|,\n-literal|\"C\"\n-argument_list|,\n+index|[\n+literal|0\n+index|]\n+operator|=\n+literal|'C'\n+expr_stmt|;\n+name|fd\n+index|[\n-argument_list|)\n+index|]\n+operator|=\n+literal|'\\0'\nThe issue was with: net: shell: Avoid gcc warning print with string catenation\n\ngcc prints this warning message\n\n'strncat' specified bound 1 equals source length [-Wstringop-overflow=]\n   58 |                 strncat(fd, \\\"C\\\", 1);\n\nThere was no error in the code but avoid the warning by not using\nstrncat()."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: adc: iadc_gecko: fix sample bits reading\n\nThe current driver initializes the IADC with the default configuration\n(IADC_INITSINGLE_DEFAULT), which aligns the data to the right.\nTo correctly read the 12-bit sample, it should be masked from the right\ninstead. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|GECKO_DATA_RES12BIT\nparameter_list|(\nname|DATA\nparameter_list|)\nvalue|((DATA& 0xFFF0)>> 4);\nend_define\n\nbegin_struct\nDECL|struct|adc_gecko_channel_config\nstruct|struct",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|((DATA& 0xFFF0)>> 4);\n+value|((DATA)& 0x0FFF)\nThe issue was with: drivers: adc: iadc_gecko: fix sample bits reading\n\nThe current driver initializes the IADC with the default configuration\n(IADC_INITSINGLE_DEFAULT), which aligns the data to the right.\nTo correctly read the 12-bit sample, it should be masked from the right\ninstead."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: ASCS: Add additional dbg info in state changes\n\nAdd additional debug information in some ASCS debug statements,\nso it is easier to follow the state when there is a potentional\nstate change. Please fix this issue.",
  "input": "Faulty tokenized code:\nexpr_stmt|;\nblock|}\nblock|}\nname|LOG_DBG\nargument_list|(\nliteral|\"ase %p id 0x%02x %s -> %s\"\nargument_list|,\nname|ase\nargument_list|,\nname|ase\noperator|->\nname|ep\noperator|.\nname|status\nexpr_stmt|;\nreturn|return;\nblock|}\nname|LOG_DBG\nargument_list|(\nliteral|\"stream %p ep %p reason 0x%02x\"\nargument_list|,\nname|stream\nargument_list|,\nname|stream\noperator|->\nname|ep\nargument_list|,\nname|reason\nargument_list|)\nexpr_stmt|;\ncomment|/* Cancel ASE disconnect work if pending */\noperator|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"ase %p id 0x%02x %s -> %s\"\n+literal|\"ase %p ep %p id 0x%02x %s -> %s\"\n+operator|&\n+name|ase\n+operator|->\n+name|ep\n+argument_list|,\n-literal|\"stream %p ep %p reason 0x%02x\"\n+literal|\"stream %p ep %p state %s reason 0x%02x\"\n+name|bt_bap_ep_state_str\n+argument_list|(\n+name|ep\n+operator|->\n+name|status\n+operator|.\n+name|state\n+argument_list|)\n+argument_list|,\nThe issue was with: Bluetooth: ASCS: Add additional dbg info in state changes\n\nAdd additional debug information in some ASCS debug statements,\nso it is easier to follow the state when there is a potentional\nstate change."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Audio: Fix len check in ltv_set_val\n\nThe length check in ltv_set_val did not consider the size of\nthe length or type fields. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|,\nname|size_t\nname|data_len\nparameter_list|)\nblock|{\nfor|for\ncontrol|(\nname|uint16_t\nname|i\ninit|=\noperator|+=\nname|value_len\nexpr_stmt|;\nblock|}\ncomment|/* If we reach here, we did not find the data in the buffer, so we simply add it */\nif|if\ncondition|(\noperator|(\nname|buf\noperator|->\nname|len\noperator|+\nname|data_len\noperator|)\noperator|<=\nname|buf\noperator|->\nname|size\ncondition|)\nargument_list|(\nname|type\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|net_buf_simple_add_u8\nargument_list|(\nname|buf\nargument_list|,\nname|type\nargument_list|)\nexpr_stmt|;\nif|if\ncondition|(\nname|data_len\noperator|>\nliteral|0\nname|data\nargument_list|,\nname|data_len\nargument_list|)\nexpr_stmt|;\nblock|}\nblock|}\nelse|else\nblock|{\nname|LOG_DBG",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|size_t\n+name|new_buf_len\n+decl_stmt|;\n-if|if\n-condition|(\n-operator|(\n+name|new_buf_len\n+operator|=\n+literal|1\n+comment|/* len */\n+operator|+\n+sizeof|sizeof\n+argument_list|(\n+name|type\n+argument_list|)\n+operator|+\n-operator|)\n+expr_stmt|;\n+if|if\n+condition|(\n+name|new_buf_len\n+comment|/* len */\n+comment|/* type */\n+comment|/* value */\nThe issue was with: Bluetooth: Audio: Fix len check in ltv_set_val\n\nThe length check in ltv_set_val did not consider the size of\nthe length or type fields."
},{
  "instruction": "There is an issue in the following code. It relates to net: sockets: prevent null pointer dereference\n\nAccording to the POSIX specification, null pointer\nis a valid value for the `address` argument\nof the `accept` function.\nThis commit adds a check to prevent a null pointer\ndereference inside `z_impl_zsock_accept`. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|addr\nargument_list|,\nname|addrlen\nargument_list|)\nexpr_stmt|;\noperator|(\nname|void\noperator|)\nname|sock_obj_core_alloc_find\nargument_list|(\nname|sa_family\nargument_list|,\nname|SOCK_STREAM\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|new_sock\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|addr\n+condition|)\n+block|{\n+block|}\nThe issue was with: net: sockets: prevent null pointer dereference\n\nAccording to the POSIX specification, null pointer\nis a valid value for the `address` argument\nof the `accept` function.\nThis commit adds a check to prevent a null pointer\ndereference inside `z_impl_zsock_accept`."
},{
  "instruction": "There is an issue in the following code. It relates to dai: intel: dmic: demote spurious LOG_ERR in dai_nhlt_get_clock_div()\n\nFix the log level of two LOG_ERR() statements which should have always\nbeen LOG_INF(). As confirmed by the author Adrian in #60172\n\nFixes commit 4f9064ce3f5a [formerly 3fbaed4de9b2] (\\\"dai: intel: ace: dmic: Refactor of\ndai_nhlt_dmic_dai_params_get function\\\") Please fix this issue.",
  "input": "Faulty tokenized code:\nname|dai_index\noperator|+\nname|FIR_CONFIG\nargument_list|)\nexpr_stmt|;\nname|LOG_ERR\nargument_list|(\nliteral|\"pdm = %d, FIR_CONFIG = 0x%08X\"\nargument_list|,\nname|pdm\nargument_list|,\noperator|*\nname|p_mcic\noperator|*\nname|p_mfir\nexpr_stmt|;\nname|LOG_ERR\nargument_list|(\nliteral|\"dai_index = %d, rate_div = %d, p_clkdiv = %d, p_mcic = %d, p_mfir = %d\"\nargument_list|,\nname|dmic\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|LOG_ERR\n+name|LOG_INF\n-name|LOG_ERR\n+name|LOG_INF\nThe issue was with: dai: intel: dmic: demote spurious LOG_ERR in dai_nhlt_get_clock_div()\n\nFix the log level of two LOG_ERR() statements which should have always\nbeen LOG_INF(). As confirmed by the author Adrian in #60172\n\nFixes commit 4f9064ce3f5a [formerly 3fbaed4de9b2] (\\\"dai: intel: ace: dmic: Refactor of\ndai_nhlt_dmic_dai_params_get function\\\")"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: i2c: correct spelling\n\nEmploy a code spell checking tool to scan and correct spelling errors\nin all files within the drivers/i2c directory. Please fix this issue.",
  "input": "Faulty tokenized code:\nconfig I2C_DW_LPSS_DMA\n\tbool \"Use I2C integrated DMA for asynchronous transfer\"\n\tselect DMA\n\tselect DMA_INTEL_LPSS\n\thelp\n\t  This option enables I2C DMA feature to be used for asynchrounous\n\t  data transfers. All Tx operaton are done using dma channel 0 and\n\t  all Rx operations are done using dma channel 1.\nargument_list|)\ncondition|)\nblock|{\nname|LOG_DBG\nargument_list|(\nliteral|\"Error trnasfer\"\nargument_list|)\nexpr_stmt|;\nreturn|return\noperator|-\nname|EIO\nname|reg_base\nargument_list|)\nexpr_stmt|;\nname|LOG_DBG\nargument_list|(\nliteral|\"I2C: Host registed as Slave Device\"\nargument_list|)\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\noperator|&\nname|I2C_MSG_RESTART\noperator|)\ncondition|)\nblock|{\ncomment|/* Send START conditon */\nname|cmd_type\noperator|=\noperator|(\noperator|(\nname|msg\nname|i2c\nargument_list|)\nexpr_stmt|;\nblock|}\nblock|}\ncomment|/* Send STOP conditon */\nif|if\ncondition|(\nname|msg\nindex|[\nname|msg_index\nname|bool\nname|target_attached\ndecl_stmt|;\nendif|#\ndirective|endif\nDECL|union|__anon2b828380010a\nunion|union\nblock|{\nifdef|#\ndirective|ifdef\nname|CONFIG_I2C_IT8XXX2_CQ_MODE\nname|CONFIG_I2C_TARGET_IT8XXX2_MAX_BUF_SIZE\ncondition|)\nblock|{\nname|LOG_ERR\nargument_list|(\nliteral|\"The bufffer size exceeds \"\nliteral|\"I2C_TARGET_IT8XXX2_MAX_BUF_SIZE: len=%d\"\nargument_list|,\nname|len\nargument_list|)\nexpr_stmt|;\ngoto|goto\nname|end\ngoto|;\nblock|}\nblock|}\ncomment|/* ADDR must be cleared before NACK generation. Either in 2 byte reception \t\t * byte 1 will be NACK'ed and slave wont sent the last byte \t\t */\nname|LL_I2C_ClearFlag_ADDR\nargument_list|(\nname|i2c\nargument_list|)\nexpr_stmt|;\nname|BIT\nargument_list|(\nname|NPCX_SMBST_NMATCH\nargument_list|)\nexpr_stmt|;\ncomment|/* Distinguish tje direction of i2c target mode by reading XMIT bit */\nif|if\ncondition|(\nname|IS_BIT_SET\nargument_list|(\nname|inst\nparameter_list|,\nname|uint8_t\nname|port\nparameter_list|)\nfunction_decl|;\ncomment|/**  * @brief Toggle the SCL to generate maxmium 9 clocks until the target release  * the SDA line and send a STOP condition.  *  * @param i2c_dev Pointer to the device structure for i2c controller instance.  *  * @retval 0 If successful.  * @retval -EBUSY fail to recover the bus.  */\nname|int\nname|npcx_i2c_ctrl_recover_bus\nparameter_list|(\nspecifier|const\nname|struct",
  "result": "I corrected the issue in the code by changing the following tokens:\n-\t  This option enables I2C DMA feature to be used for asynchrounous\n-\t  data transfers. All Tx operaton are done using dma channel 0 and\n+\t  This option enables I2C DMA feature to be used for asynchronous\n+\t  data transfers. All Tx operations are done using dma channel 0 and\n-literal|\"Error trnasfer\"\n+literal|\"Error transfer\"\n-literal|\"I2C: Host registed as Slave Device\"\n+literal|\"I2C: Host registered as Slave Device\"\n-comment|/* Send START conditon */\n+comment|/* Send START condition */\n-comment|/* Send STOP conditon */\n+comment|/* Send STOP condition */\n-DECL|union|__anon2b828380010a\n+DECL|union|__anon2c240994010a\n-literal|\"The bufffer size exceeds \"\n+literal|\"The buffer size exceeds \"\n-comment|/* ADDR must be cleared before NACK generation. Either in 2 byte reception \t\t * byte 1 will be NACK'ed and slave wont sent the last byte \t\t */\n+comment|/* ADDR must be cleared before NACK generation. Either in 2 byte reception \t\t * byte 1 will be NACK'ed and slave won't sent the last byte \t\t */\n-comment|/* Distinguish tje direction of i2c target mode by reading XMIT bit */\n+comment|/* Distinguish the direction of i2c target mode by reading XMIT bit */\n-comment|/**  * @brief Toggle the SCL to generate maxmium 9 clocks until the target release  * the SDA line and send a STOP condition.  *  * @param i2c_dev Pointer to the device structure for i2c controller instance.  *  * @retval 0 If successful.  * @retval -EBUSY fail to recover the bus.  */\n+comment|/**  * @brief Toggle the SCL to generate maximum 9 clocks until the target release  * the SDA line and send a STOP condition.  *  * @param i2c_dev Pointer to the device structure for i2c controller instance.  *  * @retval 0 If successful.  * @retval -EBUSY fail to recover the bus.  */\nThe issue was with: drivers: i2c: correct spelling\n\nEmploy a code spell checking tool to scan and correct spelling errors\nin all files within the drivers/i2c directory."
},{
  "instruction": "There is an issue in the following code. It relates to net: openthread: Print the actual assert location\n\nWhen OpenThread application is built with CONFIG_ASSERT\nand CONFIG_ASSERT_NO_MSG_INFO, OT_ASSERT() prints a location\nthat points to the otPlatAssertFail() function instead of\nthe code that actually failed an assertion.\n\nThis is confusing and CONFIG_ASSERT_NO_MSG_INFO sometimes\ncannot be disabled because of flash size limitations.\n\nMake otPlatAssertFail() always print the actual assert\nlocation. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|,\nname|int\nname|aLineNumber\nparameter_list|)\nblock|{\nname|__ASSERT\nargument_list|(\nname|false\nargument_list|,\nliteral|\"OpenThread ASSERT @ %s:%d\"\nargument_list|,\nname|aFilename\nargument_list|,\nname|aLineNumber\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nend_unit\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|__ASSERT\n+comment|/* \t * The code below is used instead of __ASSERT(false) to print the actual assert \t * location instead of __FILE__:__LINE__, which would point to this function. \t */\n+name|__ASSERT_PRINT\n-name|false\n-argument_list|,\n-literal|\"OpenThread ASSERT @ %s:%d\"\n+literal|\"OpenThread ASSERT @ %s:%d\\n\"\n+name|__ASSERT_POST_ACTION\n+argument_list|()\n+expr_stmt|;\nThe issue was with: net: openthread: Print the actual assert location\n\nWhen OpenThread application is built with CONFIG_ASSERT\nand CONFIG_ASSERT_NO_MSG_INFO, OT_ASSERT() prints a location\nthat points to the otPlatAssertFail() function instead of\nthe code that actually failed an assertion.\n\nThis is confusing and CONFIG_ASSERT_NO_MSG_INFO sometimes\ncannot be disabled because of flash size limitations.\n\nMake otPlatAssertFail() always print the actual assert\nlocation."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: b91: add missing RISC-V PLIC header\n\nDriver was using PLIC without including necessary headers. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/irq.h>\nend_include\n\nbegin_comment\ncomment|/* Driver dts compatibility: telink,b91_uart */\nend_comment\n\nbegin_define\nbegin_comment\ncomment|/* rxtimeout register enums */\nend_comment\n\nbegin_enum\nDECL|enum|__anon2c3d82700103\nenum|enum\nblock|{\nDECL|enumerator|UART_ERR_IRQ_MASK\nname|UART_ERR_IRQ_MASK\ninit|=\nbegin_comment\ncomment|/* ctrl0 register enums */\nend_comment\n\nbegin_enum\nDECL|enum|__anon2c3d82700203\nenum|enum\nblock|{\nDECL|enumerator|UART_RX_IRQ_MASK\nname|UART_RX_IRQ_MASK\ninit|=\nbegin_comment\ncomment|/* ctrl3 register enums */\nend_comment\n\nbegin_enum\nDECL|enum|__anon2c3d82700303\nenum|enum\nblock|{\nDECL|enumerator|FLD_UART_RX_IRQ_TRIQ_LEV_OFFSET\nname|FLD_UART_RX_IRQ_TRIQ_LEV_OFFSET\ninit|=\nbegin_comment\ncomment|/* bufcnt register enums */\nend_comment\n\nbegin_enum\nDECL|enum|__anon2c3d82700403\nenum|enum\nblock|{\nDECL|enumerator|FLD_UART_RX_BUF_CNT_OFFSET\nname|FLD_UART_RX_BUF_CNT_OFFSET\ninit|=\nbegin_comment\ncomment|/* status register enums */\nend_comment\n\nbegin_enum\nDECL|enum|__anon2c3d82700503\nenum|enum\nblock|{\nDECL|enumerator|UART_IRQ_STATUS\nname|UART_IRQ_STATUS\ninit|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/drivers/interrupt_controller/riscv_plic.h>\n+end_include\n+\n-DECL|enum|__anon2c3d82700103\n+DECL|enum|__anon2978fa580103\n-DECL|enum|__anon2c3d82700203\n+DECL|enum|__anon2978fa580203\n-DECL|enum|__anon2c3d82700303\n+DECL|enum|__anon2978fa580303\n-DECL|enum|__anon2c3d82700403\n+DECL|enum|__anon2978fa580403\n-DECL|enum|__anon2c3d82700503\n+DECL|enum|__anon2978fa580503\nThe issue was with: drivers: serial: b91: add missing RISC-V PLIC header\n\nDriver was using PLIC without including necessary headers."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: ieee802154: b91: add missing PLIC include\n\nDriver was using RISC-V PLIC API without including the necessary\nheaders. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_endif\nendif|#\ndirective|endif\nend_endif\n\nbegin_include\ninclude|#\ndirective|include\nfile|\"ieee802154_b91.h\"\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/drivers/interrupt_controller/riscv_plic.h>\n+end_include\n+\nThe issue was with: drivers: ieee802154: b91: add missing PLIC include\n\nDriver was using RISC-V PLIC API without including the necessary\nheaders."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: gpio: b91: add missing PLIC header\n\nDriver is using the RISC-V PLIC interrupt controller without including\nthe necessary headers. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/drivers/gpio/gpio_utils.h>\nend_include\n\nbegin_comment\ncomment|/* Driver dts compatibility: telink,b91_gpio */\nend_comment\n\nbegin_define",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/drivers/interrupt_controller/riscv_plic.h>\n+end_include\n+\nThe issue was with: drivers: gpio: b91: add missing PLIC header\n\nDriver is using the RISC-V PLIC interrupt controller without including\nthe necessary headers."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: gpio: sifive: add missing PLIC header\n\nDriver is using the PLIC API without including the right header. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/irq_multilevel.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/drivers/gpio/gpio_utils.h>\nend_include",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/drivers/interrupt_controller/riscv_plic.h>\n+end_include\n+\nThe issue was with: drivers: gpio: sifive: add missing PLIC header\n\nDriver is using the PLIC API without including the right header."
},{
  "instruction": "There is an issue in the following code. It relates to arch: riscv: irq_manage: add missing PLIC header\n\nModule uses RISC-V PLIC interrupt controller API without including the\nnecessary headers. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/irq_multilevel.h>\nend_include\n\nbegin_expr_stmt\nname|LOG_MODULE_DECLARE\nargument_list|(\nname|os\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_ifdef\n+ifdef|#\n+directive|ifdef\n+name|CONFIG_RISCV_HAS_PLIC\n+end_ifdef\n+\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/drivers/interrupt_controller/riscv_plic.h>\n+end_include\n+\n+begin_endif\n+endif|#\n+directive|endif\n+end_endif\n+\nThe issue was with: arch: riscv: irq_manage: add missing PLIC header\n\nModule uses RISC-V PLIC interrupt controller API without including the\nnecessary headers."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: correct spelling\n\nEmploy a code spell checking tool to scan and correct spelling errors\nin all files within the drivers/serial directory. Please fix this issue.",
  "input": "Faulty tokenized code:\nconfig UART_EMUL_WORK_Q_STACK_SIZE\n\tint \"UART emulator work queue stack size\"\n\tdefault 2048\n\nconfig UART_EMUL_WORK_Q_PRIORITY\n\tint \"UART emulator work queue tread priority\"\n\tdefault 1\n\nendif # UART_EMUL\nDECL|member|tx_fifo_trigger_level\nspecifier|volatile\nname|uint32_t\nname|tx_fifo_trigger_level\ndecl_stmt|;\ncomment|/* Transmiter FIFO trigger level */\nDECL|member|rbrs\nspecifier|volatile\nname|uint32_t\nname|rbrs\ndecl_stmt|;\nname|err\ncondition|)\nblock|{\nname|LOG_ERR\nargument_list|(\nliteral|\"Error stoping Tx DMA (%d)\"\nargument_list|,\nname|err\nargument_list|)\nexpr_stmt|;\ngoto|goto\nname|err\ncondition|)\nblock|{\nname|LOG_ERR\nargument_list|(\nliteral|\"Error stoping Rx DMA (%d)\"\nargument_list|,\nname|err\nargument_list|)\nexpr_stmt|;\ngoto|goto\nargument_list|)\nexpr_stmt|;\nname|compiler_barrier\nargument_list|()\nexpr_stmt|;\ncomment|/* This tells the debugger we have a command. \t * It is responsibility of debugger to set this back to HL_NOADDRESS \t * after receiving the packet. \t * Please note that we don't wait here because some implementations \t * use hl_blockedPeek() function as a signal that we send a messege. \t */\nname|hl_write32\nargument_list|(\noperator|&\nname|__HOSTLINK__\noperator|.\nvalue|(0x0E)\nend_define\n\nbegin_comment\nDECL|macro|USBSERIAL_TX_FIFO_GE_2\ncomment|/* 1110 Room for atleast 2 */\nend_comment\n\nbegin_define\nDECL|macro|USBSERIAL_TX_FIFO_GE_1\ndefine|#\nvalue|(0x0F)\nend_define\n\nbegin_comment\nDECL|macro|USBSERIAL_TX_FIFO_GE_1\ncomment|/* 1111 Room for atleast 1 */\nend_comment\n\nbegin_struct\nDECL|struct|fpga_usbserial_regs\nstruct|struct\nargument_list|)\nexpr_stmt|;\nendif|#\ndirective|endif\ncomment|/* CONFIG_UART_INTERRUPT_DRIVEN */\ncomment|/* Start trasmitter and receiver. */\noperator|*\nname|CCR0\nargument_list|(\nname|config\noperator|->\ncomment|/* Specifies the baudrate for the uart instance. */\nDECL|member|baud_rate\nname|uint32_t\nname|baud_rate\ndecl_stmt|;\ncomment|/* Specifies the port line contorl settings */\nDECL|member|line_ctrl\nname|sedi_uart_lc_t\nname|line_ctrl\ndecl_stmt|;\nDECL|member|mutex\nname|config\noperator|->\nname|usart\nargument_list|)\nexpr_stmt|;\ncomment|/* Set basic parmeters, such as data-/stop-bit, parity, and baudrate */\nname|uart_stm32_parameters_set\nargument_list|(\nname|dev\nargument_list|,\nname|cfg\nname|usart\nargument_list|,\nname|LL_USART_DIRECTION_TX_RX\nargument_list|)\nexpr_stmt|;\ncomment|/* Set basic parmeters, such as data-/stop-bit, parity, and baudrate */\nname|uart_stm32_parameters_set\nargument_list|(\nname|dev\nargument_list|,\nname|uart_cfg",
  "result": "I corrected the issue in the code by changing the following tokens:\n-\tint \"UART emulator work queue tread priority\"\n+\tint \"UART emulator work queue thread priority\"\n-comment|/* Transmiter FIFO trigger level */\n+comment|/* Transmitter FIFO trigger level */\n-literal|\"Error stoping Tx DMA (%d)\"\n+literal|\"Error stopping Tx DMA (%d)\"\n-literal|\"Error stoping Rx DMA (%d)\"\n+literal|\"Error stopping Rx DMA (%d)\"\n-comment|/* This tells the debugger we have a command. \t * It is responsibility of debugger to set this back to HL_NOADDRESS \t * after receiving the packet. \t * Please note that we don't wait here because some implementations \t * use hl_blockedPeek() function as a signal that we send a messege. \t */\n+comment|/* This tells the debugger we have a command. \t * It is responsibility of debugger to set this back to HL_NOADDRESS \t * after receiving the packet. \t * Please note that we don't wait here because some implementations \t * use hl_blockedPeek() function as a signal that we send a message. \t */\n-comment|/* 1110 Room for atleast 2 */\n+comment|/* 1110 Room for at least 2 */\n-comment|/* 1111 Room for atleast 1 */\n+comment|/* 1111 Room for at least 1 */\n-comment|/* Start trasmitter and receiver. */\n+comment|/* Start transmitter and receiver. */\n-comment|/* Specifies the port line contorl settings */\n+comment|/* Specifies the port line control settings */\n-comment|/* Set basic parmeters, such as data-/stop-bit, parity, and baudrate */\n+comment|/* Set basic parameters, such as data-/stop-bit, parity, and baudrate */\n-comment|/* Set basic parmeters, such as data-/stop-bit, parity, and baudrate */\n+comment|/* Set basic parameters, such as data-/stop-bit, parity, and baudrate */\nThe issue was with: drivers: serial: correct spelling\n\nEmploy a code spell checking tool to scan and correct spelling errors\nin all files within the drivers/serial directory."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: spi: correct spelling\n\nEmploy a code spell checking tool to scan and correct spelling errors\nin all files within the drivers/spi directory. Please fix this issue.",
  "input": "Faulty tokenized code:\n\t  Enable the SPI DMA mode for SPI instances\n\t  that enable dma channels in their device tree node.\n\nif SPI_RTIO\nconfig SPI_MCUX_RTIO_SQ_SIZE\n\tint \"number of avialable submission queue entries\"\n\tdefault 8 # sensible default that covers most common spi transactions\n\thelp\n\t  when rtio is use with spi each driver holds a context with which blocking\n\t  api calls use to perform spi transactions. this queue needs to be as deep\n\t  as the longest set of spi_buf_sets used, where normal spi operations are\n\t  Enable using DMA with SPI for SPI instances that enable dma channels in\n\t  their device tree node.\n\nif SPI_RTIO\nconfig SPI_SAM_RTIO_SQ_SIZE\n\tint \"Number of avialable submission queue entries\"\n\tdefault 8 # Sensible default that covers most common spi transactions\n\thelp\n\t  When RTIO is use with SPI each driver holds a context with which blocking\n\t  API calls use to perform SPI transactions. This queue needs to be as deep\n\t  as the longest set of spi_buf_sets used, where normal SPI operations are\nargument_list|,\nname|FLD_SPI_RXF_CLR\nargument_list|)\nexpr_stmt|;\nblock|}\ncomment|/* wait fot SPI is ready */\nwhile|while\ncondition|(\nname|spi_is_busy\nargument_list|(\nname|cfg\noperator|+\nname|SPI_HOST_TXDATA_REG_OFFSET\nargument_list|)\nexpr_stmt|;\nblock|}\ncomment|/* Keep CS asserted if another Tx segment remains or if two more Rx \t\t * segements remain (because we will handle one Rx segment after the \t\t * forthcoming transaction). \t\t */\nif|if\ncondition|(\nname|ctx\noperator|->\nname|tx_count\nreturn|;\nblock|}\nend_function\n\nbegin_comment\ncomment|/*  * SPI signalling mode: CPOL and CPHA  * CPOL = 0 is clock idles low, 1 is clock idle high  * CPHA = 0 Transmitter changes data on trailing of preceding clock cycle.  *          Receiver samples data on leading edge of clock cyle.  *        1 Transmitter changes data on leading edge of current clock cycle.  *          Receiver samples data on the trailing edge of clock cycle.  * SPI Mode nomenclature:  * Mode CPOL CPHA  *  0     0    0  *  1     0    1  *  2     1    0  *  3     1    1  * QMSPI has three controls, CPOL, CPHA for output and CPHA for input.  * SPI frequency< 48MHz  *\tMode 0: CPOL=0 CHPA=0 (CHPA_MISO=0 and CHPA_MOSI=0)  *\tMode 3: CPOL=1 CHPA=1 (CHPA_MISO=1 and CHPA_MOSI=1)  * Data sheet recommends when QMSPI set at max. SPI frequency (48MHz).  * SPI frequency == 48MHz sample and change data on same edge.  *  Mode 0: CPOL=0 CHPA=0 (CHPA_MISO=1 and CHPA_MOSI=0)  *  Mode 3: CPOL=1 CHPA=1 (CHPA_MISO=0 and CHPA_MOSI=1)  *  * There is an anomaly in MEC172x for SPI signalling mode 3. We must  * set CHPA_MISO=0 for SPI Mode 3 at all frequencies.  */\nend_comment\n\nbegin_decl_stmt\nDECL|variable|smode_tbl\nspecifier|const\nreturn|;\nblock|}\nend_function\n\nbegin_comment\ncomment|/* QMSPI Local-DMA transfer configuration:  * Support full and half(dual/quad) duplex transfers.  * Requires caller to have checked that only one direction was setup  * in the SPI context: TX or RX not both. (refer to qmspi_xfr_cm_init)  * Supports spi_buf's where data pointer is NULL and length non-zero.  * These buffers are used as TX tri-state I/O clock only generation or  * RX data discard for certain SPI command protocols using dual/quad I/O.  * 1. Get largest contiguous data size from SPI context.  * 2. If the SPI TX context has a non-zero length configure Local-DMA TX  *    channel 1 for contigous data size. If TX context has valid buffer  *    configure channel to use context buffer with address increment.  *    If the TX buffer pointer is NULL interpret byte length as the number  *    of clocks to generate with output line(s) tri-stated. NOTE: The controller  *    must be configured with TX disabled to not drive output line(s) during  *    clock generation. Also, no data should be written to TX FIFO. The unit  *    size can be set to bits. The number of units to transfer must be computed  *    based upon the number of output pins in the IOM field: full-duplex is one  *    bit per clock, dual is 2 bits per clock, and quad is 4 bits per clock.  *    For example, if I/O lines is 4 (quad) meaning 4 bits per clock and the  *    user wants 7 clocks then the number of bit units is 4 * 7 = 28.  * 3. If instead, the SPI RX context has a non-zero length configure Local-DMA  *    RX channel 1 for the contigous data size. If RX context has a valid  *    buffer configure channel to use buffer with address increment else  *    configure channel for driver data temporary buffer without address  *    increment.  * 4. Update QMSPI Control register.  */\nend_comment\n\nbegin_function\nDECL|function|qmspi_ldma_encode_unit_size (uint32_t maddr,size_t len)\nspecifier|static\nreturn|;\nblock|}\nend_function\n\nbegin_comment\ncomment|/* Wrapper to start asynchronous (interrupts enabled) SPI transction */\nend_comment\n\nbegin_function\nDECL|function|qmspi_xfr_async (const struct device * dev,const struct spi_config * config,const struct spi_buf_set * tx_bufs,const struct spi_buf_set * rx_bufs)\nspecifier|static",
  "result": "I corrected the issue in the code by changing the following tokens:\n-\tint \"number of avialable submission queue entries\"\n+\tint \"number of available submission queue entries\"\n-\tint \"Number of avialable submission queue entries\"\n+\tint \"Number of available submission queue entries\"\n-comment|/* wait fot SPI is ready */\n+comment|/* wait for SPI is ready */\n-comment|/* Keep CS asserted if another Tx segment remains or if two more Rx \t\t * segements remain (because we will handle one Rx segment after the \t\t * forthcoming transaction). \t\t */\n+comment|/* Keep CS asserted if another Tx segment remains or if two more Rx \t\t * segments remain (because we will handle one Rx segment after the \t\t * forthcoming transaction). \t\t */\n-comment|/*  * SPI signalling mode: CPOL and CPHA  * CPOL = 0 is clock idles low, 1 is clock idle high  * CPHA = 0 Transmitter changes data on trailing of preceding clock cycle.  *          Receiver samples data on leading edge of clock cyle.  *        1 Transmitter changes data on leading edge of current clock cycle.  *          Receiver samples data on the trailing edge of clock cycle.  * SPI Mode nomenclature:  * Mode CPOL CPHA  *  0     0    0  *  1     0    1  *  2     1    0  *  3     1    1  * QMSPI has three controls, CPOL, CPHA for output and CPHA for input.  * SPI frequency< 48MHz  *\tMode 0: CPOL=0 CHPA=0 (CHPA_MISO=0 and CHPA_MOSI=0)  *\tMode 3: CPOL=1 CHPA=1 (CHPA_MISO=1 and CHPA_MOSI=1)  * Data sheet recommends when QMSPI set at max. SPI frequency (48MHz).  * SPI frequency == 48MHz sample and change data on same edge.  *  Mode 0: CPOL=0 CHPA=0 (CHPA_MISO=1 and CHPA_MOSI=0)  *  Mode 3: CPOL=1 CHPA=1 (CHPA_MISO=0 and CHPA_MOSI=1)  *  * There is an anomaly in MEC172x for SPI signalling mode 3. We must  * set CHPA_MISO=0 for SPI Mode 3 at all frequencies.  */\n+comment|/*  * SPI signalling mode: CPOL and CPHA  * CPOL = 0 is clock idles low, 1 is clock idle high  * CPHA = 0 Transmitter changes data on trailing of preceding clock cycle.  *          Receiver samples data on leading edge of clock cycle.  *        1 Transmitter changes data on leading edge of current clock cycle.  *          Receiver samples data on the trailing edge of clock cycle.  * SPI Mode nomenclature:  * Mode CPOL CPHA  *  0     0    0  *  1     0    1  *  2     1    0  *  3     1    1  * QMSPI has three controls, CPOL, CPHA for output and CPHA for input.  * SPI frequency< 48MHz  *\tMode 0: CPOL=0 CHPA=0 (CHPA_MISO=0 and CHPA_MOSI=0)  *\tMode 3: CPOL=1 CHPA=1 (CHPA_MISO=1 and CHPA_MOSI=1)  * Data sheet recommends when QMSPI set at max. SPI frequency (48MHz).  * SPI frequency == 48MHz sample and change data on same edge.  *  Mode 0: CPOL=0 CHPA=0 (CHPA_MISO=1 and CHPA_MOSI=0)  *  Mode 3: CPOL=1 CHPA=1 (CHPA_MISO=0 and CHPA_MOSI=1)  *  * There is an anomaly in MEC172x for SPI signalling mode 3. We must  * set CHPA_MISO=0 for SPI Mode 3 at all frequencies.  */\n-comment|/* QMSPI Local-DMA transfer configuration:  * Support full and half(dual/quad) duplex transfers.  * Requires caller to have checked that only one direction was setup  * in the SPI context: TX or RX not both. (refer to qmspi_xfr_cm_init)  * Supports spi_buf's where data pointer is NULL and length non-zero.  * These buffers are used as TX tri-state I/O clock only generation or  * RX data discard for certain SPI command protocols using dual/quad I/O.  * 1. Get largest contiguous data size from SPI context.  * 2. If the SPI TX context has a non-zero length configure Local-DMA TX  *    channel 1 for contigous data size. If TX context has valid buffer  *    configure channel to use context buffer with address increment.  *    If the TX buffer pointer is NULL interpret byte length as the number  *    of clocks to generate with output line(s) tri-stated. NOTE: The controller  *    must be configured with TX disabled to not drive output line(s) during  *    clock generation. Also, no data should be written to TX FIFO. The unit  *    size can be set to bits. The number of units to transfer must be computed  *    based upon the number of output pins in the IOM field: full-duplex is one  *    bit per clock, dual is 2 bits per clock, and quad is 4 bits per clock.  *    For example, if I/O lines is 4 (quad) meaning 4 bits per clock and the  *    user wants 7 clocks then the number of bit units is 4 * 7 = 28.  * 3. If instead, the SPI RX context has a non-zero length configure Local-DMA  *    RX channel 1 for the contigous data size. If RX context has a valid  *    buffer configure channel to use buffer with address increment else  *    configure channel for driver data temporary buffer without address  *    increment.  * 4. Update QMSPI Control register.  */\n+comment|/* QMSPI Local-DMA transfer configuration:  * Support full and half(dual/quad) duplex transfers.  * Requires caller to have checked that only one direction was setup  * in the SPI context: TX or RX not both. (refer to qmspi_xfr_cm_init)  * Supports spi_buf's where data pointer is NULL and length non-zero.  * These buffers are used as TX tri-state I/O clock only generation or  * RX data discard for certain SPI command protocols using dual/quad I/O.  * 1. Get largest contiguous data size from SPI context.  * 2. If the SPI TX context has a non-zero length configure Local-DMA TX  *    channel 1 for contiguous data size. If TX context has valid buffer  *    configure channel to use context buffer with address increment.  *    If the TX buffer pointer is NULL interpret byte length as the number  *    of clocks to generate with output line(s) tri-stated. NOTE: The controller  *    must be configured with TX disabled to not drive output line(s) during  *    clock generation. Also, no data should be written to TX FIFO. The unit  *    size can be set to bits. The number of units to transfer must be computed  *    based upon the number of output pins in the IOM field: full-duplex is one  *    bit per clock, dual is 2 bits per clock, and quad is 4 bits per clock.  *    For example, if I/O lines is 4 (quad) meaning 4 bits per clock and the  *    user wants 7 clocks then the number of bit units is 4 * 7 = 28.  * 3. If instead, the SPI RX context has a non-zero length configure Local-DMA  *    RX channel 1 for the contiguous data size. If RX context has a valid  *    buffer configure channel to use buffer with address increment else  *    configure channel for driver data temporary buffer without address  *    increment.  * 4. Update QMSPI Control register.  */\n-comment|/* Wrapper to start asynchronous (interrupts enabled) SPI transction */\n+comment|/* Wrapper to start asynchronous (interrupts enabled) SPI transaction */\nThe issue was with: drivers: spi: correct spelling\n\nEmploy a code spell checking tool to scan and correct spelling errors\nin all files within the drivers/spi directory."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: gpio: correct spelling\n\nEmploy a code spell checking tool to scan and correct spelling errors\nin all files within the drivers/gpio directory. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|7\ncondition|)\nblock|{\nname|LOG_ERR\nargument_list|(\nliteral|\"invalid pin nummber %i\"\nargument_list|,\nname|pin\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|BSP_GPIO_INTERRUPT_LOW_ENABLE\nvalue|0x2c\nend_define\n\nbegin_comment\ncomment|/* efinix sapphire specefic gpio config struct */\nend_comment\n\nbegin_struct\nDECL|struct|gpio_efinix_sapphire_cfg\nstruct|struct\nblock|}\nstruct|;\nend_struct\n\nbegin_comment\ncomment|/* efinix sapphire specefic gpio data struct */\nend_comment\n\nbegin_struct\nDECL|struct|gpio_efinix_sapphire_data\nstruct|struct\nblock|}\nblock|}\nend_function\n\nbegin_comment\ncomment|/* To use the controller bare minimun as IO, Peripheral has to configure, */\nend_comment\n\nbegin_comment\ncomment|/* the Output enable register, b0 : Input, b1 : Output */\nend_comment\nname|TLE9104_GPIO_COUNT\ncondition|)\nblock|{\nname|LOG_ERR\nargument_list|(\nliteral|\"invalid pin nummber %i\"\nargument_list|,\nname|pin\nargument_list|)\nexpr_stmt|;\nreturn|return",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"invalid pin nummber %i\"\n+literal|\"invalid pin number %i\"\n-comment|/* efinix sapphire specefic gpio config struct */\n+comment|/* efinix sapphire specific gpio config struct */\n-comment|/* efinix sapphire specefic gpio data struct */\n+comment|/* efinix sapphire specific gpio data struct */\n-comment|/* To use the controller bare minimun as IO, Peripheral has to configure, */\n+comment|/* To use the controller bare minimum as IO, Peripheral has to configure, */\n-literal|\"invalid pin nummber %i\"\n+literal|\"invalid pin number %i\"\nThe issue was with: drivers: gpio: correct spelling\n\nEmploy a code spell checking tool to scan and correct spelling errors\nin all files within the drivers/gpio directory."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Mesh: Fix dereferencing before null pointer check\n\nDon't dereference pointer until it is checked on NULL.\n\nFixes: #66805\nCoverity-CID: 338098 Please fix this issue.",
  "input": "Faulty tokenized code:\nindex|]\nstruct|;\nend_struct\n\nbegin_struct\nDECL|struct|__anon2b7815370108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|busy_ctx\nname|sys_slist_t\nname|peek_pending_msg\nargument_list|()\ndecl_stmt|;\nname|uint16_t\nname|len\ninit|=\nname|msg\noperator|->\nname|len\ndecl_stmt|;\nname|int\nname|err\ndecl_stmt|;\nif|if\nblock|{\nreturn|return\nname|false\nreturn|;\nblock|}\nname|NET_BUF_SIMPLE_DEFINE\nargument_list|(\nname|buf\nargument_list|,\nname|BT_MESH_TX_SDU_MAX",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2b7815370108\n+DECL|struct|__anon29c710770108\n-init|=\n-name|msg\n-operator|->\n-name|len\n+name|len\n+operator|=\n+name|msg\n+operator|->\n+name|len\n+expr_stmt|;\nThe issue was with: Bluetooth: Mesh: Fix dereferencing before null pointer check\n\nDon't dereference pointer until it is checked on NULL.\n\nFixes: #66805\nCoverity-CID: 338098"
},{
  "instruction": "There is an issue in the following code. It relates to tests/drivers uart_pm: Fix for too fast targets\n\nOn the async configurations, the first part of the test\n(test_uart_pm_in_idle) can interfere with the second part\nof the test, if the device has a fast enough CPU.\nThis is due to the first part of the test ending\nas soon as it queues the last byte for transmission.\nIf the device is fast enough (and the simulated\nnrf52 is), the 2nd part of the test will start executing\nenabling the UART Rx, which can result in either\nthe Rx being enabled mid frame, which can result in a frame\nerror or even before the Tx HW started pushing the byte\nin the line (resulting in that byte being received).\nNeither of these cases are handled by the 2nd test,\nwhich sees a spurious error or received byte\nand fails.\n\nLet's just add a small delay at the end of the first test\nto allow the Tx of the last byte to be done. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|dev\nargument_list|,\nname|true\nargument_list|)\nexpr_stmt|;\nblock|}\nend_block\n\nbegin_macro\nDECL|function|ZTEST (uart_pm,test_uart_pm_poll_tx)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Let's give enough time for the last byte to be transmitted out */\n+name|k_busy_wait\n+argument_list|(\n+literal|500\n+argument_list|)\n+expr_stmt|;\nThe issue was with: tests/drivers uart_pm: Fix for too fast targets\n\nOn the async configurations, the first part of the test\n(test_uart_pm_in_idle) can interfere with the second part\nof the test, if the device has a fast enough CPU.\nThis is due to the first part of the test ending\nas soon as it queues the last byte for transmission.\nIf the device is fast enough (and the simulated\nnrf52 is), the 2nd part of the test will start executing\nenabling the UART Rx, which can result in either\nthe Rx being enabled mid frame, which can result in a frame\nerror or even before the Tx HW started pushing the byte\nin the line (resulting in that byte being received).\nNeither of these cases are handled by the 2nd test,\nwhich sees a spurious error or received byte\nand fails.\n\nLet's just add a small delay at the end of the first test\nto allow the Tx of the last byte to be done."
},{
  "instruction": "There is an issue in the following code. It relates to samples: drivers: display: fix mono buffer size\n\nRounding errors due to the division of non-integrally divisible\nbuffer sizes lead to the loss of one byte. This can be avoided\nwith the DIV_ROUND_UP() macro. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|fill_buffer_fnc\noperator|=\nname|fill_buffer_mono\nexpr_stmt|;\nname|buf_size\noperator|/=\nliteral|8\nexpr_stmt|;\nbreak|break;\ndefault|default:\nname|LOG_ERR\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|/=\n-literal|8\n+operator|=\n+name|DIV_ROUND_UP\n+argument_list|(\n+name|DIV_ROUND_UP\n+argument_list|(\n+name|buf_size\n+argument_list|,\n+name|NUM_BITS\n+argument_list|(\n+name|uint8_t\n+argument_list|)\n+argument_list|)\n+argument_list|,\n+sizeof|sizeof\n+argument_list|(\n+name|uint8_t\n+argument_list|)\n+argument_list|)\nThe issue was with: samples: drivers: display: fix mono buffer size\n\nRounding errors due to the division of non-integrally divisible\nbuffer sizes lead to the loss of one byte. This can be avoided\nwith the DIV_ROUND_UP() macro."
},{
  "instruction": "There is an issue in the following code. It relates to samples: hello_world_user: fail in compilation if userspace is not enabled\n\nThe sample depends on CONFIG_USERSPACE. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|USER_STACKSIZE\nvalue|2048\nend_define\n\nbegin_decl_stmt\nDECL|variable|user_thread\nname|struct\nname|k_thread\nname|user_thread",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_ifndef\n+ifndef|#\n+directive|ifndef\n+name|CONFIG_USERSPACE\n+end_ifndef\n+\n+begin_error\n+error|#\n+directive|error\n+error|This sample requires CONFIG_USERSPACE.\n+end_error\n+\n+begin_endif\n+endif|#\n+directive|endif\n+end_endif\n+\nThe issue was with: samples: hello_world_user: fail in compilation if userspace is not enabled\n\nThe sample depends on CONFIG_USERSPACE."
},{
  "instruction": "There is an issue in the following code. It relates to net: l2: wifi: wifi_utils: Resolve build warning with strncpy function\n\nARM GCC version 12.2.0 (Zephyr SDK 0.16.4) generates the following build\nwarning from the strncpy call in \\\"wifi_utils_parse_scan_bands\\\":\n\nwarning: '__builtin_strncpy' output truncated before terminating nul\ncopying as many bytes from a string as its length\n\nTo resolve this warning, pass the maximum length of the temporary\nparse_str buffer to strncpy. This also has the benefit of correctly null\nterminating parse_str, since we already verify the\nscan_bands_str is properly null terminated with the strlen() check in\nthis function. We can therefore remove the line adding a null terminator\nto parse_str as well. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|parse_str\nargument_list|,\nname|scan_bands_str\nargument_list|,\nname|len\nargument_list|)\nexpr_stmt|;\nname|parse_str\nindex|[\nname|len\nindex|]\noperator|=\nliteral|'\\0'\nexpr_stmt|;\nname|band_str\noperator|=\nname|strtok_r\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|len\n-argument_list|)\n-expr_stmt|;\n+sizeof|sizeof\n+argument_list|(\n-index|[\n-name|len\n-index|]\n-operator|=\n-literal|'\\0'\n+argument_list|)\n+argument_list|)\nThe issue was with: net: l2: wifi: wifi_utils: Resolve build warning with strncpy function\n\nARM GCC version 12.2.0 (Zephyr SDK 0.16.4) generates the following build\nwarning from the strncpy call in \\\"wifi_utils_parse_scan_bands\\\":\n\nwarning: '__builtin_strncpy' output truncated before terminating nul\ncopying as many bytes from a string as its length\n\nTo resolve this warning, pass the maximum length of the temporary\nparse_str buffer to strncpy. This also has the benefit of correctly null\nterminating parse_str, since we already verify the\nscan_bands_str is properly null terminated with the strlen() check in\nthis function. We can therefore remove the line adding a null terminator\nto parse_str as well."
},{
  "instruction": "There is an issue in the following code. It relates to Revert \\\"drivers: usb: device: add start of frame notifications to nxp mcux driver\\\"\n\nThis reverts commit fbe6b90190504882d214a6cb08b912f2fd4c2553 [formerly 21c9c4abfe5c858b1c5d6c45a2c919d81b12a02b]. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|NULL\nargument_list|)\nexpr_stmt|;\nbreak|break;\ncase|case\nname|kUSB_DeviceNotifySOF\ncase|:\nname|dev_state\noperator|.\nname|status_cb\nargument_list|(\nname|USB_DC_SOF\nargument_list|,\nname|NULL\nargument_list|)\nexpr_stmt|;\nbreak|break;\ndefault|default:\nname|ep_abs_idx\noperator|=\nname|EP_ABS_IDX\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-case|case\n-name|kUSB_DeviceNotifySOF\n-case|:\n-name|dev_state\n-operator|.\n-name|status_cb\n-argument_list|(\n-name|USB_DC_SOF\n-argument_list|,\n-name|NULL\n-argument_list|)\n-expr_stmt|;\n-break|break;\nThe issue was with: Revert \\\"drivers: usb: device: add start of frame notifications to nxp mcux driver\\\"\n\nThis reverts commit fbe6b90190504882d214a6cb08b912f2fd4c2553 [formerly 21c9c4abfe5c858b1c5d6c45a2c919d81b12a02b]."
},{
  "instruction": "There is an issue in the following code. It relates to arch: riscv: idle: trace idle and call wfi\n\nWhile going to idle may require SoC specific implementations, provide a\nmore sensible default implementation. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/irq.h>\nend_include\n\nbegin_comment\ncomment|/*  * In RISC-V there is no conventional way to handle CPU power save.  * Each RISC-V SOC handles it in its own way.  * Hence, by default, arch_cpu_idle and arch_cpu_atomic_idle functions just  * unlock interrupts and return to the caller, without issuing any CPU power  * saving instruction.  *  * Nonetheless, define the default arch_cpu_idle and arch_cpu_atomic_idle  * functions as weak functions, so that they can be replaced at the SOC-level.  */\nend_comment\n\nbegin_function\nDECL|function|arch_cpu_idle (void)\nname|void\nspecifier|__weak\nname|arch_cpu_idle\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nname|irq_unlock\nargument_list|(\nname|MSTATUS_IEN\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|arch_cpu_atomic_idle (unsigned int key)\nname|unsigned\nname|int\nname|key\nparameter_list|)\nblock|{\nname|irq_unlock\nargument_list|(\nname|key\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\nend_unit\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_comment\n-comment|/*  * In RISC-V there is no conventional way to handle CPU power save.  * Each RISC-V SOC handles it in its own way.  * Hence, by default, arch_cpu_idle and arch_cpu_atomic_idle functions just  * unlock interrupts and return to the caller, without issuing any CPU power  * saving instruction.  *  * Nonetheless, define the default arch_cpu_idle and arch_cpu_atomic_idle  * functions as weak functions, so that they can be replaced at the SOC-level.  */\n-end_comment\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/tracing/tracing.h>\n+end_include\n+name|sys_trace_idle\n+argument_list|()\n+expr_stmt|;\n+asm|__asm__\n+specifier|volatile\n+asm|(\"wfi\");\n+name|sys_trace_idle\n+argument_list|()\n+expr_stmt|;\n+asm|__asm__\n+specifier|volatile\n+asm|(\"wfi\");\nThe issue was with: arch: riscv: idle: trace idle and call wfi\n\nWhile going to idle may require SoC specific implementations, provide a\nmore sensible default implementation."
},{
  "instruction": "There is an issue in the following code. It relates to wifi: shell: Fix missing case sensitivity\n\nThis was missed in earlier that tried to fix all string comparisons to\nuse case insensitive comparison. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/* CONFIG_WIFI_MGMT_RAW_SCAN_RESULTS_ONLY */\nend_comment\n\nbegin_struct\nDECL|struct|__anon2c37f8920108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\nname|struct\nname|shell\nmodifier|*\nname|sh\ndecl_stmt|;\nDECL|union|__anon2c37f892020a\nunion|union\nblock|{\nDECL|struct|__anon2c37f8920308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\nliteral|'t'\ncase|:\nif|if\ncondition|(\noperator|!\nname|strcmp\nargument_list|(\nname|optarg\nargument_list|,\nliteral|\"passive\"\nargument_list|)\ncondition|)\nblock|{\nname|params\noperator|->\nexpr_stmt|;\nblock|}\nif|else if\ncondition|(\noperator|!\nname|strcmp\nargument_list|(\nname|optarg\nargument_list|,\nliteral|\"active\"\nargument_list|)\ncondition|)\nblock|{\nname|params\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2c37f8920108\n+DECL|struct|__anon2a2d72f10108\n-DECL|union|__anon2c37f892020a\n+DECL|union|__anon2a2d72f1020a\n-DECL|struct|__anon2c37f8920308\n+DECL|struct|__anon2a2d72f10308\n-name|strcmp\n+name|strncasecmp\n+argument_list|,\n+literal|7\n-name|strcmp\n+name|strncasecmp\n+argument_list|,\n+literal|6\nThe issue was with: wifi: shell: Fix missing case sensitivity\n\nThis was missed in earlier that tried to fix all string comparisons to\nuse case insensitive comparison."
},{
  "instruction": "There is an issue in the following code. It relates to net: wifi_shell: Add example of scan option\n\nAdd an example of the scan's -c parameter\nto help with understanding. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/* CONFIG_WIFI_MGMT_RAW_SCAN_RESULTS_ONLY */\nend_comment\n\nbegin_struct\nDECL|struct|__anon2b55de8d0108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\nname|struct\nname|shell\nmodifier|*\nname|sh\ndecl_stmt|;\nDECL|union|__anon2b55de8d020a\nunion|union\nblock|{\nDECL|struct|__anon2b55de8d0308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\nliteral|\"[-b, --bands<Comma separated list of band values (2/5/6)>] : Bands to be scanned where 2: 2.4 GHz, 5: 5 GHz, 6: 6 GHz\\n\"\nliteral|\"[-a, --dwell_time_active<val_in_ms>] : Active scan dwell time (in ms) on a channel. Range 5 ms to 1000 ms\\n\"\nliteral|\"[-p, --dwell_time_passive<val_in_ms>] : Passive scan dwell time (in ms) on a channel. Range 10 ms to 1000 ms\\n\"\nliteral|\"[-s, --ssid] : SSID to scan for. Can be provided multiple times\\n\"\nliteral|\"[-m, --max_bss<val>] : Maximum BSSes to scan for. Range 1 - 65535\\n\"\nliteral|\"[-c, --chans<Comma separated list of channel ranges>] : Channels to be scanned. The channels must be specified in the form band1:chan1,chan2_band2:chan3,..etc. band1, band2 must be valid band values and chan1, chan2, chan3 must be specified as a list of comma separated values where each value is either a single channel or a channel range specified as chan_start-chan_end. Each band channel set has to be separated by a _. For example, a valid channel specification can be 2:1,6_5:36\\n\"\nliteral|\"[-h, --help] : Print out the help for the scan command.\\n\"\nargument_list|,\nname|cmd_wifi_scan\nargument_list|,\nliteral|1",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2b55de8d0108\n+DECL|struct|__anon2c37f8920108\n-DECL|union|__anon2b55de8d020a\n+DECL|union|__anon2c37f892020a\n-DECL|struct|__anon2b55de8d0308\n+DECL|struct|__anon2c37f8920308\n-literal|\"[-c, --chans<Comma separated list of channel ranges>] : Channels to be scanned. The channels must be specified in the form band1:chan1,chan2_band2:chan3,..etc. band1, band2 must be valid band values and chan1, chan2, chan3 must be specified as a list of comma separated values where each value is either a single channel or a channel range specified as chan_start-chan_end. Each band channel set has to be separated by a _. For example, a valid channel specification can be 2:1,6_5:36\\n\"\n+literal|\"[-c, --chans<Comma separated list of channel ranges>] : Channels to be scanned. The channels must be specified in the form band1:chan1,chan2_band2:chan3,..etc. band1, band2 must be valid band values and chan1, chan2, chan3 must be specified as a list of comma separated values where each value is either a single channel or a channel range specified as chan_start-chan_end. Each band channel set has to be separated by a _. For example, a valid channel specification can be 2:1,6_5:36 or 2:1,6-11,14_5:36,163-177,52\\n\"\nThe issue was with: net: wifi_shell: Add example of scan option\n\nAdd an example of the scan's -c parameter\nto help with understanding."
},{
  "instruction": "There is an issue in the following code. It relates to xtensa: mmu: Fix mmu initialization\n\nThe constant used to calculate TLB entries for the way six was wrong\nand causing an integer overflow. Consequently only the first 512MB where\nbeing unmapped from the TLB. Please fix this issue.",
  "input": "Faulty tokenized code:\ncomment|/*<--- traps a ITLB miss */\nasm|:: \"r\"(regs.ptevaddr), \"r\"(regs.rasid), \t\t\t    \"r\"(regs.ptepin_at), \"r\"(regs.ptepin_as), \t\t\t    \"r\"(regs.vecpin_at), \"r\"(regs.vecpin_as), \t\t\t    \"r\"(idtlb_pte), \"r\"(idtlb_stk), \"r\"(iitlb_pc));\ncomment|/* Invalidate the remaining (unused by this function) \t * initialization entries. Now we're flying free with our own \t * page table. \t */\nfor|for\ncontrol|(\nname|int\nname|i\ninit|=\nliteral|0\ninit|;\nname|i\nname|ixtlb\ninit|=\noperator|(\nname|i\noperator|*\nliteral|0x2000000000\noperator|)\noperator||\nname|XCHAL_SPANNING_WAY\ndecl_stmt|;\nif|if",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|int\n+name|uint32_t\n-literal|0x2000000000\n+literal|0x20000000\nThe issue was with: xtensa: mmu: Fix mmu initialization\n\nThe constant used to calculate TLB entries for the way six was wrong\nand causing an integer overflow. Consequently only the first 512MB where\nbeing unmapped from the TLB."
},{
  "instruction": "There is an issue in the following code. It relates to wifi: Fix duplication\n\nUse a common set of events and then add specific ones as per the\nconfiguration. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|define\nname|WIFI_SHELL_MODULE\nvalue|\"wifi\"\nend_define\n\nbegin_ifdef\nifdef|#\ndirective|ifdef\nname|CONFIG_WIFI_MGMT_RAW_SCAN_RESULTS_ONLY\nend_ifdef\nbegin_define\nDECL|macro|WIFI_SHELL_MGMT_EVENTS\ndefine|#\ndirective|define\nname|WIFI_SHELL_MGMT_EVENTS\nvalue|(NET_EVENT_WIFI_RAW_SCAN_RESULT |        \\ \t\t\t\tNET_EVENT_WIFI_SCAN_DONE |              \\ \t\t\t\tNET_EVENT_WIFI_CONNECT_RESULT |         \\ \t\t\t\tNET_EVENT_WIFI_DISCONNECT_RESULT |  \\ \t\t\t\tNET_EVENT_WIFI_TWT)\nend_define\n\nbegin_else\nelse|#\ndirective|else\nbegin_define\nDECL|macro|WIFI_SHELL_MGMT_EVENTS\ndefine|#\ndirective|define\nname|WIFI_SHELL_MGMT_EVENTS\nvalue|(NET_EVENT_WIFI_SCAN_RESULT |\t\t\\ \t\t\t\tNET_EVENT_WIFI_SCAN_DONE |\t\t\\ \t\t\t\tNET_EVENT_WIFI_CONNECT_RESULT |\t\t\\ \t\t\t\tNET_EVENT_WIFI_DISCONNECT_RESULT |  \\ \t\t\t\tNET_EVENT_WIFI_TWT |\t\t\\ \t\t\t\tNET_EVENT_WIFI_RAW_SCAN_RESULT)\nend_define\n\nbegin_endif\nendif|#\ndirective|endif\nbegin_comment\ncomment|/* CONFIG_WIFI_MGMT_RAW_SCAN_RESULTS_ONLY */\nend_comment\n\nbegin_struct\nDECL|struct|__anon2ad5cf3a0108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\nname|struct\nname|shell\nmodifier|*\nname|sh\ndecl_stmt|;\nDECL|union|__anon2ad5cf3a020a\nunion|union\nblock|{\nDECL|struct|__anon2ad5cf3a0308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_define\n+DECL|macro|WIFI_SHELL_MGMT_EVENTS_COMMON\n+define|#\n+directive|define\n+name|WIFI_SHELL_MGMT_EVENTS_COMMON\n+value|(NET_EVENT_WIFI_SCAN_DONE   |\\ \t\t\t\tNET_EVENT_WIFI_CONNECT_RESULT     |\\ \t\t\t\tNET_EVENT_WIFI_DISCONNECT_RESULT  |  \\ \t\t\t\tNET_EVENT_WIFI_TWT                |\\ \t\t\t\tNET_EVENT_WIFI_RAW_SCAN_RESULT)\n+end_define\n+\n-value|(NET_EVENT_WIFI_RAW_SCAN_RESULT |        \\ \t\t\t\tNET_EVENT_WIFI_SCAN_DONE |              \\ \t\t\t\tNET_EVENT_WIFI_CONNECT_RESULT |         \\ \t\t\t\tNET_EVENT_WIFI_DISCONNECT_RESULT |  \\ \t\t\t\tNET_EVENT_WIFI_TWT)\n+value|(WIFI_SHELL_MGMT_EVENTS_COMMON)\n-value|(NET_EVENT_WIFI_SCAN_RESULT |\t\t\\ \t\t\t\tNET_EVENT_WIFI_SCAN_DONE |\t\t\\ \t\t\t\tNET_EVENT_WIFI_CONNECT_RESULT |\t\t\\ \t\t\t\tNET_EVENT_WIFI_DISCONNECT_RESULT |  \\ \t\t\t\tNET_EVENT_WIFI_TWT |\t\t\\ \t\t\t\tNET_EVENT_WIFI_RAW_SCAN_RESULT)\n+value|(WIFI_SHELL_MGMT_EVENTS_COMMON |\\ \t\t\t\tNET_EVENT_WIFI_SCAN_RESULT)\n-DECL|struct|__anon2ad5cf3a0108\n+DECL|struct|__anon2898b3960108\n-DECL|union|__anon2ad5cf3a020a\n+DECL|union|__anon2898b396020a\n-DECL|struct|__anon2ad5cf3a0308\n+DECL|struct|__anon2898b3960308\nThe issue was with: wifi: Fix duplication\n\nUse a common set of events and then add specific ones as per the\nconfiguration."
},{
  "instruction": "There is an issue in the following code. It relates to soc: arm: gigadevice: s/gigadevice/gd_gd32\n\nGigadevice was inconsistent with the convention established by other SoC\nfamilies, that is, use <vnd_prefix>_<family>. For example, ST STM32 uses\nst_stm32. Note that GD32VF103, under soc/riscv, has already been\nadjusted. Please fix this issue.",
  "input": "Faulty tokenized code:\n    - boards/riscv/gd32*/\n    - boards/riscv/longan_nano/\n    - drivers/*/*gd32*\n    - dts/*/gigadevice/\n    - dts/bindings/*/*gd32*\n   - soc/arm/gigadevice/\n   - soc/riscv/gd_gd32/\n    - scripts/west_commands/*/*gd32*\n  labels:\n    - \"platform: GD32\"\n  description: >-\n    GigaDevice GD32 SOCs, dts files and related drivers. Starter and eval\nsimilarity index 100%\nrename from soc/arm/gigadevice/CMakeLists.txt\nrename to soc/arm/gd_gd32/CMakeLists.txt\nsimilarity index 85%\nrename from soc/arm/gigadevice/Kconfig\nrename to soc/arm/gd_gd32/Kconfig\n\tselect BUILD_OUTPUT_HEX\n\tselect HAS_SEGGER_RTT if ZEPHYR_SEGGER_MODULE\n\nconfig SOC_FAMILY\n\tstring\n\tdefault \"gigadevice\"\n\tdepends on SOC_FAMILY_GD32\n\nconfig SOC_FAMILY_GD32_ARM\n\tbool\n\tselect SOC_FAMILY_GD32\n\nif SOC_FAMILY_GD32_ARM\n\nsource \"soc/arm/gigadevice/*/Kconfig.soc\"\n\nendif # SOC_FAMILY_GD32_ARM\nsimilarity index 79%\nrename from soc/arm/gigadevice/Kconfig.defconfig\nrename to soc/arm/gd_gd32/Kconfig.defconfig\n# Copyright (c) 2021, ATL Electronics\n# SPDX-License-Identifier: Apache-2.0\n\nif SOC_FAMILY_GD32\n\nsource \"soc/arm/gigadevice/*/Kconfig.defconfig.series\"\n\nconfig PINCTRL\n\tdefault y\n\nconfig RESET\nsimilarity index 63%\nrename from soc/arm/gigadevice/Kconfig.soc\nrename to soc/arm/gd_gd32/Kconfig.soc\n# Copyright (c) 2021, ATL Electronics\n# SPDX-License-Identifier: Apache-2.0\n\nsource \"soc/arm/gigadevice/*/Kconfig.series\"\nsimilarity index 100%\nrename from soc/arm/gigadevice/common/CMakeLists.txt\nrename to soc/arm/gd_gd32/common/CMakeLists.txt\nsimilarity index 100%\nrename from soc/arm/gigadevice/common/pinctrl_soc.h\nrename to soc/arm/gd_gd32/common/pinctrl_soc.h\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32a50x/CMakeLists.txt\nrename to soc/arm/gd_gd32/gd32a50x/CMakeLists.txt\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32a50x/Kconfig.defconfig.gd32a503\nrename to soc/arm/gd_gd32/gd32a50x/Kconfig.defconfig.gd32a503\nsimilarity index 75%\nrename from soc/arm/gigadevice/gd32a50x/Kconfig.defconfig.series\nrename to soc/arm/gd_gd32/gd32a50x/Kconfig.defconfig.series\n# Copyright (c) 2022 YuLong Yao <feilongphone@gmail.com>\n# SPDX-License-Identifier: Apache-2.0\n\nif SOC_SERIES_GD32A50X\n\nsource \"soc/arm/gigadevice/gd32a50x/Kconfig.defconfig.gd32*\"\n\nconfig SOC_SERIES\n\tdefault \"gd32a50x\"\n\nendif # SOC_SERIES_GD32A50X\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32a50x/Kconfig.series\nrename to soc/arm/gd_gd32/gd32a50x/Kconfig.series\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32a50x/Kconfig.soc\nrename to soc/arm/gd_gd32/gd32a50x/Kconfig.soc\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32a50x/gd32_regs.h\nrename to soc/arm/gd_gd32/gd32a50x/gd32_regs.h\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32a50x/soc.c\nrename to soc/arm/gd_gd32/gd32a50x/soc.c\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32a50x/soc.h\nrename to soc/arm/gd_gd32/gd32a50x/soc.h\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32e10x/CMakeLists.txt\nrename to soc/arm/gd_gd32/gd32e10x/CMakeLists.txt\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32e10x/Kconfig.defconfig.gd32e103\nrename to soc/arm/gd_gd32/gd32e10x/Kconfig.defconfig.gd32e103\nsimilarity index 75%\nrename from soc/arm/gigadevice/gd32e10x/Kconfig.defconfig.series\nrename to soc/arm/gd_gd32/gd32e10x/Kconfig.defconfig.series\n# Copyright (c) 2021 YuLong Yao <feilongphone@gmail.com>\n# SPDX-License-Identifier: Apache-2.0\n\nif SOC_SERIES_GD32E10X\n\nsource \"soc/arm/gigadevice/gd32e10x/Kconfig.defconfig.gd32*\"\n\nconfig SOC_SERIES\n\tdefault \"gd32e10x\"\n\nendif # SOC_SERIES_GD32E10X\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32e10x/Kconfig.series\nrename to soc/arm/gd_gd32/gd32e10x/Kconfig.series\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32e10x/Kconfig.soc\nrename to soc/arm/gd_gd32/gd32e10x/Kconfig.soc\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32e10x/gd32_regs.h\nrename to soc/arm/gd_gd32/gd32e10x/gd32_regs.h\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32e10x/soc.c\nrename to soc/arm/gd_gd32/gd32e10x/soc.c\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32e10x/soc.h\nrename to soc/arm/gd_gd32/gd32e10x/soc.h\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32e50x/CMakeLists.txt\nrename to soc/arm/gd_gd32/gd32e50x/CMakeLists.txt\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32e50x/Kconfig.defconfig.gd32e507\nrename to soc/arm/gd_gd32/gd32e50x/Kconfig.defconfig.gd32e507\nsimilarity index 74%\nrename from soc/arm/gigadevice/gd32e50x/Kconfig.defconfig.series\nrename to soc/arm/gd_gd32/gd32e50x/Kconfig.defconfig.series\n# Copyright (c) 2022, Teslabs Engineering S.L.\n# SPDX-License-Identifier: Apache-2.0\n\nif SOC_SERIES_GD32E50X\n\nsource \"soc/arm/gigadevice/gd32e50x/Kconfig.defconfig.gd32*\"\n\nconfig SOC_SERIES\n\tdefault \"gd32e50x\"\n\nendif # SOC_SERIES_GD32E50X\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32e50x/Kconfig.series\nrename to soc/arm/gd_gd32/gd32e50x/Kconfig.series\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32e50x/Kconfig.soc\nrename to soc/arm/gd_gd32/gd32e50x/Kconfig.soc\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32e50x/gd32_regs.h\nrename to soc/arm/gd_gd32/gd32e50x/gd32_regs.h\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32e50x/soc.c\nrename to soc/arm/gd_gd32/gd32e50x/soc.c\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32e50x/soc.h\nrename to soc/arm/gd_gd32/gd32e50x/soc.h\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32f3x0/CMakeLists.txt\nrename to soc/arm/gd_gd32/gd32f3x0/CMakeLists.txt\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32f3x0/Kconfig.defconfig.gd32f350\nrename to soc/arm/gd_gd32/gd32f3x0/Kconfig.defconfig.gd32f350\nsimilarity index 73%\nrename from soc/arm/gigadevice/gd32f3x0/Kconfig.defconfig.series\nrename to soc/arm/gd_gd32/gd32f3x0/Kconfig.defconfig.series\n# Copyright (c) 2021 BrainCo Inc.\n# SPDX-License-Identifier: Apache-2.0\n\nif SOC_SERIES_GD32F3X0\n\nsource \"soc/arm/gigadevice/gd32f3x0/Kconfig.defconfig.gd32*\"\n\nconfig SOC_SERIES\n\tdefault \"gd32f3x0\"\n\nendif # SOC_SERIES_GD32F3X0\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32f3x0/Kconfig.series\nrename to soc/arm/gd_gd32/gd32f3x0/Kconfig.series\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32f3x0/Kconfig.soc\nrename to soc/arm/gd_gd32/gd32f3x0/Kconfig.soc\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32f3x0/gd32_regs.h\nrename to soc/arm/gd_gd32/gd32f3x0/gd32_regs.h\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32f3x0/soc.c\nrename to soc/arm/gd_gd32/gd32f3x0/soc.c\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32f3x0/soc.h\nrename to soc/arm/gd_gd32/gd32f3x0/soc.h\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32f403/CMakeLists.txt\nrename to soc/arm/gd_gd32/gd32f403/CMakeLists.txt\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32f403/Kconfig.defconfig.gd32f403\nrename to soc/arm/gd_gd32/gd32f403/Kconfig.defconfig.gd32f403\nsimilarity index 72%\nrename from soc/arm/gigadevice/gd32f403/Kconfig.defconfig.series\nrename to soc/arm/gd_gd32/gd32f403/Kconfig.defconfig.series\n# Copyright (c) 2021, ATL Electronics\n# SPDX-License-Identifier: Apache-2.0\n\nif SOC_SERIES_GD32F403\n\nsource \"soc/arm/gigadevice/gd32f403/Kconfig.defconfig.gd32f403\"\n\nconfig SOC_SERIES\n\tdefault \"gd32f403\"\n\nendif   # SOC_SERIES_GD32F403\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32f403/Kconfig.series\nrename to soc/arm/gd_gd32/gd32f403/Kconfig.series\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32f403/Kconfig.soc\nrename to soc/arm/gd_gd32/gd32f403/Kconfig.soc\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32f403/gd32_regs.h\nrename to soc/arm/gd_gd32/gd32f403/gd32_regs.h\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32f403/soc.c\nrename to soc/arm/gd_gd32/gd32f403/soc.c\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32f403/soc.h\nrename to soc/arm/gd_gd32/gd32f403/soc.h\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32f4xx/CMakeLists.txt\nrename to soc/arm/gd_gd32/gd32f4xx/CMakeLists.txt\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32f4xx/Kconfig.defconfig.gd32f405\nrename to soc/arm/gd_gd32/gd32f4xx/Kconfig.defconfig.gd32f405\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32f4xx/Kconfig.defconfig.gd32f407\nrename to soc/arm/gd_gd32/gd32f4xx/Kconfig.defconfig.gd32f407\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32f4xx/Kconfig.defconfig.gd32f450\nrename to soc/arm/gd_gd32/gd32f4xx/Kconfig.defconfig.gd32f450\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32f4xx/Kconfig.defconfig.gd32f470\nrename to soc/arm/gd_gd32/gd32f4xx/Kconfig.defconfig.gd32f470\nsimilarity index 74%\nrename from soc/arm/gigadevice/gd32f4xx/Kconfig.defconfig.series\nrename to soc/arm/gd_gd32/gd32f4xx/Kconfig.defconfig.series\n# Copyright (c) 2021, Teslabs Engineering S.L.\n# SPDX-License-Identifier: Apache-2.0\n\nif SOC_SERIES_GD32F4XX\n\nsource \"soc/arm/gigadevice/gd32f4xx/Kconfig.defconfig.gd32*\"\n\nconfig SOC_SERIES\n\tdefault \"gd32f4xx\"\n\nendif # SOC_SERIES_GD32F4XX\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32f4xx/Kconfig.series\nrename to soc/arm/gd_gd32/gd32f4xx/Kconfig.series\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32f4xx/Kconfig.soc\nrename to soc/arm/gd_gd32/gd32f4xx/Kconfig.soc\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32f4xx/gd32_regs.h\nrename to soc/arm/gd_gd32/gd32f4xx/gd32_regs.h\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32f4xx/soc.c\nrename to soc/arm/gd_gd32/gd32f4xx/soc.c\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32f4xx/soc.h\nrename to soc/arm/gd_gd32/gd32f4xx/soc.h\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32l23x/CMakeLists.txt\nrename to soc/arm/gd_gd32/gd32l23x/CMakeLists.txt\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32l23x/Kconfig.defconfig.gd32l233\nrename to soc/arm/gd_gd32/gd32l23x/Kconfig.defconfig.gd32l233\nsimilarity index 73%\nrename from soc/arm/gigadevice/gd32l23x/Kconfig.defconfig.series\nrename to soc/arm/gd_gd32/gd32l23x/Kconfig.defconfig.series\n# Copyright (c) 2022 BrainCo Inc.\n# SPDX-License-Identifier: Apache-2.0\n\nif SOC_SERIES_GD32L23X\n\nsource \"soc/arm/gigadevice/gd32l23x/Kconfig.defconfig.gd32*\"\n\nconfig SOC_SERIES\n\tdefault \"gd32l23x\"\n\nendif # SOC_SERIES_GD32L23X\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32l23x/Kconfig.series\nrename to soc/arm/gd_gd32/gd32l23x/Kconfig.series\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32l23x/Kconfig.soc\nrename to soc/arm/gd_gd32/gd32l23x/Kconfig.soc\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32l23x/gd32_regs.h\nrename to soc/arm/gd_gd32/gd32l23x/gd32_regs.h\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32l23x/soc.c\nrename to soc/arm/gd_gd32/gd32l23x/soc.c\nsimilarity index 100%\nrename from soc/arm/gigadevice/gd32l23x/soc.h\nrename to soc/arm/gd_gd32/gd32l23x/soc.h",
  "result": "I corrected the issue in the code by changing the following tokens:\n-    - soc/arm/gigadevice/\n-    - soc/riscv/gd_gd32/\n+    - soc/*/gd_gd32/\n-\tdefault \"gigadevice\"\n+\tdefault \"gd_gd32\"\n-source \"soc/arm/gigadevice/*/Kconfig.soc\"\n+source \"soc/arm/gd_gd32/*/Kconfig.soc\"\n-source \"soc/arm/gigadevice/*/Kconfig.defconfig.series\"\n+source \"soc/arm/gd_gd32/*/Kconfig.defconfig.series\"\n-source \"soc/arm/gigadevice/*/Kconfig.series\"\n+source \"soc/arm/gd_gd32/*/Kconfig.series\"\n-source \"soc/arm/gigadevice/gd32a50x/Kconfig.defconfig.gd32*\"\n+source \"soc/arm/gd_gd32/gd32a50x/Kconfig.defconfig.gd32*\"\n-source \"soc/arm/gigadevice/gd32e10x/Kconfig.defconfig.gd32*\"\n+source \"soc/arm/gd_gd32/gd32e10x/Kconfig.defconfig.gd32*\"\n-source \"soc/arm/gigadevice/gd32e50x/Kconfig.defconfig.gd32*\"\n+source \"soc/arm/gd_gd32/gd32e50x/Kconfig.defconfig.gd32*\"\n-source \"soc/arm/gigadevice/gd32f3x0/Kconfig.defconfig.gd32*\"\n+source \"soc/arm/gd_gd32/gd32f3x0/Kconfig.defconfig.gd32*\"\n-source \"soc/arm/gigadevice/gd32f403/Kconfig.defconfig.gd32f403\"\n+source \"soc/arm/gd_gd32/gd32f403/Kconfig.defconfig.gd32f403\"\n-source \"soc/arm/gigadevice/gd32f4xx/Kconfig.defconfig.gd32*\"\n+source \"soc/arm/gd_gd32/gd32f4xx/Kconfig.defconfig.gd32*\"\n-source \"soc/arm/gigadevice/gd32l23x/Kconfig.defconfig.gd32*\"\n+source \"soc/arm/gd_gd32/gd32l23x/Kconfig.defconfig.gd32*\"\nThe issue was with: soc: arm: gigadevice: s/gigadevice/gd_gd32\n\nGigadevice was inconsistent with the convention established by other SoC\nfamilies, that is, use <vnd_prefix>_<family>. For example, ST STM32 uses\nst_stm32. Note that GD32VF103, under soc/riscv, has already been\nadjusted."
},{
  "instruction": "There is an issue in the following code. It relates to net: wifi_shell: Update scan argument shell\n\nUpdate the example of scan -c argument.\nDefault value for max channels is set to 3,\nSo, update the example according to that.\nAdd closing bracket in -s. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/* CONFIG_WIFI_MGMT_RAW_SCAN_RESULTS_ONLY */\nend_comment\n\nbegin_struct\nDECL|struct|__anon28b83ea10108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\nname|struct\nname|shell\nmodifier|*\nname|sh\ndecl_stmt|;\nDECL|union|__anon28b83ea1020a\nunion|union\nblock|{\nDECL|struct|__anon28b83ea10308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\nliteral|\"Scan for Wi-Fi APs\\n\"\nliteral|\"[-t, --type<active/passive>] : Preferred mode of scan. The actual mode of scan can depend on factors such as the Wi-Fi chip implementation, regulatory domain restrictions. Default type is active\\n\"\nliteral|\"[-b, --bands<Comma separated list of band values (2/5/6)>] : Bands to be scanned where 2: 2.4 GHz, 5: 5 GHz, 6: 6 GHz\\n\"\nliteral|\"[-a, --dwell_time_active<val_in_ms>] : Active scan dwell time (in ms) on a channel. Range 5 ms to 1000 ms\\n\"\nliteral|\"[-p, --dwell_time_passive<val_in_ms>] : Passive scan dwell time (in ms) on a channel. Range 10 ms to 1000 ms\\n\"\nliteral|\"[-s, --ssid : SSID to scan for. Can be provided multiple times\\n\"\nliteral|\"[-m, --max_bss<val>] : Maximum BSSes to scan for. Range 1 - 65535\\n\"\nliteral|\"[-c, --chans<Comma separated list of channel ranges>] : Channels to be scanned. The channels must be specified in the form band1:chan1,chan2_band2:chan3,..etc. band1, band2 must be valid band values and chan1, chan2, chan3 must be specified as a list of comma separated values where each value is either a single channel or a channel range specified as chan_start-chan_end. Each band channel set has to be separated by a _. For example, a valid channel specification can be 2:1,6-11,14_5:36,149-165,44\\n\"\nliteral|\"[-h, --help] : Print out the help for the scan command.\\n\"\nargument_list|,\nname|cmd_wifi_scan\nargument_list|,\nliteral|1",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon28b83ea10108\n+DECL|struct|__anon2ad5cf3a0108\n-DECL|union|__anon28b83ea1020a\n+DECL|union|__anon2ad5cf3a020a\n-DECL|struct|__anon28b83ea10308\n+DECL|struct|__anon2ad5cf3a0308\n-literal|\"[-s, --ssid : SSID to scan for. Can be provided multiple times\\n\"\n+literal|\"[-s, --ssid] : SSID to scan for. Can be provided multiple times\\n\"\n-literal|\"[-c, --chans<Comma separated list of channel ranges>] : Channels to be scanned. The channels must be specified in the form band1:chan1,chan2_band2:chan3,..etc. band1, band2 must be valid band values and chan1, chan2, chan3 must be specified as a list of comma separated values where each value is either a single channel or a channel range specified as chan_start-chan_end. Each band channel set has to be separated by a _. For example, a valid channel specification can be 2:1,6-11,14_5:36,149-165,44\\n\"\n+literal|\"[-c, --chans<Comma separated list of channel ranges>] : Channels to be scanned. The channels must be specified in the form band1:chan1,chan2_band2:chan3,..etc. band1, band2 must be valid band values and chan1, chan2, chan3 must be specified as a list of comma separated values where each value is either a single channel or a channel range specified as chan_start-chan_end. Each band channel set has to be separated by a _. For example, a valid channel specification can be 2:1,6_5:36\\n\"\nThe issue was with: net: wifi_shell: Update scan argument shell\n\nUpdate the example of scan -c argument.\nDefault value for max channels is set to 3,\nSo, update the example according to that.\nAdd closing bracket in -s."
},{
  "instruction": "There is an issue in the following code. It relates to net: wifi_utils: Fix max channels allow for scan\n\nFix the maximum channels allow for scan command\ninput. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|chan_val\noperator|-\nname|chan_start\noperator|)\noperator|)\noperator|>=\nname|max_channels\ncondition|)\nblock|{\nname|NET_ERR\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|>=\n+operator|>\nThe issue was with: net: wifi_utils: Fix max channels allow for scan\n\nFix the maximum channels allow for scan command\ninput."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: charger: bq24190: fix api and init functions references\n\nThere is no need to use & as a function reference, so remove it. Please fix this issue.",
  "input": "Faulty tokenized code:\ninit|=\nblock|{\noperator|.\nname|get_property\noperator|=\noperator|&\nname|bq24190_get_prop\nblock|,\noperator|.\nname|set_property\noperator|=\noperator|&\nname|bq24190_set_prop\nblock|, }\ndecl_stmt|;\nend_decl_stmt\n\nname|BQ24190_INIT\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\                                                                                                    \\\nvalue|static const struct bq24190_config bq24190_config_##inst = {                               \\ \t\t.i2c = I2C_DT_SPEC_INST_GET(inst),                                                 \\ \t};                                                                                         \\                                                                                                    \\ \tstatic struct bq24190_data bq24190_data_##inst = {                                         \\ \t\t.ichg_ua = DT_INST_PROP(inst, constant_charge_current_max_microamp),               \\ \t\t.vreg_uv = DT_INST_PROP(inst, constant_charge_voltage_max_microvolt),              \\ \t};                                                                                         \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst,&bq24190_init, NULL,&bq24190_data_##inst,                     \\&bq24190_config_##inst, POST_KERNEL, CONFIG_CHARGER_INIT_PRIORITY,   \\&bq24190_driver_api);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|&\n-operator|&\n-value|static const struct bq24190_config bq24190_config_##inst = {                               \\ \t\t.i2c = I2C_DT_SPEC_INST_GET(inst),                                                 \\ \t};                                                                                         \\                                                                                                    \\ \tstatic struct bq24190_data bq24190_data_##inst = {                                         \\ \t\t.ichg_ua = DT_INST_PROP(inst, constant_charge_current_max_microamp),               \\ \t\t.vreg_uv = DT_INST_PROP(inst, constant_charge_voltage_max_microvolt),              \\ \t};                                                                                         \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst,&bq24190_init, NULL,&bq24190_data_##inst,                     \\&bq24190_config_##inst, POST_KERNEL, CONFIG_CHARGER_INIT_PRIORITY,   \\&bq24190_driver_api);\n+value|static const struct bq24190_config bq24190_config_##inst = {                               \\ \t\t.i2c = I2C_DT_SPEC_INST_GET(inst),                                                 \\ \t};                                                                                         \\                                                                                                    \\ \tstatic struct bq24190_data bq24190_data_##inst = {                                         \\ \t\t.ichg_ua = DT_INST_PROP(inst, constant_charge_current_max_microamp),               \\ \t\t.vreg_uv = DT_INST_PROP(inst, constant_charge_voltage_max_microvolt),              \\ \t};                                                                                         \\                                                                                                    \\ \tDEVICE_DT_INST_DEFINE(inst, bq24190_init, NULL,&bq24190_data_##inst,                      \\&bq24190_config_##inst, POST_KERNEL, CONFIG_CHARGER_INIT_PRIORITY,   \\&bq24190_driver_api);\nThe issue was with: drivers: charger: bq24190: fix api and init functions references\n\nThere is no need to use & as a function reference, so remove it."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: i2c: i2c_mcux_lpi2c: fix unused variable warning\n\nWith commit 1d7476af, it fixed a build error with config\nstructure no longer having a base address field but left\nthe local variable defined. This resulted in a build warning\nof an unused variable 'config' in two places. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|device\nmodifier|*\nname|dev\nparameter_list|)\nblock|{\nspecifier|const\nname|struct\nname|mcux_lpi2c_config\nmodifier|*\nname|config\ninit|=\nname|dev\noperator|->\nname|config\ndecl_stmt|;\nname|struct\nname|mcux_lpi2c_data\nmodifier|*\nname|data\ninit|=\nname|i2c_target_config\nmodifier|*\nname|target_config\nparameter_list|)\nblock|{\nspecifier|const\nname|struct\nname|mcux_lpi2c_config\nmodifier|*\nname|config\ninit|=\nname|dev\noperator|->\nname|config\ndecl_stmt|;\nname|struct\nname|mcux_lpi2c_data\nmodifier|*\nname|data\ninit|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n-specifier|const\n-name|struct\n-name|mcux_lpi2c_config\n-modifier|*\n-name|config\n-init|=\n-name|dev\n-operator|->\n-name|config\n-decl_stmt|;\n-specifier|const\n-name|struct\n-name|mcux_lpi2c_config\n-modifier|*\n-name|config\n-init|=\n-name|dev\n-operator|->\n-name|config\n-decl_stmt|;\nThe issue was with: drivers: i2c: i2c_mcux_lpi2c: fix unused variable warning\n\nWith commit 1d7476af, it fixed a build error with config\nstructure no longer having a base address field but left\nthe local variable defined. This resulted in a build warning\nof an unused variable 'config' in two places."
},{
  "instruction": "There is an issue in the following code. It relates to usb: device: audio: fix compiler warning for usb audio microphone\n\naudio_receive_cb is only used by headphones and headset, it is unused in\nmicrophone-only configurations.  Gate compilation based on the device\ntree. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|in_frame_size\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|audio_receive_cb (uint8_t ep,enum usb_dc_ep_cb_status_code status)\nspecifier|static\nname|void\nname|audio_receive_cb\nexpr_stmt|;\nblock|}\nblock|}\nend_function\n\nbegin_function\nDECL|function|usb_audio_register (const struct device * dev,const struct usb_audio_ops * ops)\nname|void\nname|usb_audio_register\nparameter_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_if\n+if|#\n+directive|if\n+operator|(\n+name|HEADPHONES_DEVICE_COUNT\n+operator|>\n+literal|0\n+operator|||\n+name|HEADSET_DEVICE_COUNT\n+operator|>\n+literal|0\n+operator|)\n+end_if\n+\n+begin_endif\n+endif|#\n+directive|endif\n+end_endif\n+\n+begin_comment\n+comment|/* #if (HEADPHONES_DEVICE_COUNT> 0 || HEADSET_DEVICE_COUNT> 0) */\n+end_comment\n+\nThe issue was with: usb: device: audio: fix compiler warning for usb audio microphone\n\naudio_receive_cb is only used by headphones and headset, it is unused in\nmicrophone-only configurations.  Gate compilation based on the device\ntree."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: usb: device: add start of frame notifications to nxp mcux driver\n\nWhen usb middleware sends a start of frame notification to this driver,\ncall status_cb with USB_DC_SOF. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|NULL\nargument_list|)\nexpr_stmt|;\nbreak|break;\ndefault|default:\nname|ep_abs_idx\noperator|=\nname|EP_ABS_IDX\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+case|case\n+name|kUSB_DeviceNotifySOF\n+case|:\n+name|dev_state\n+operator|.\n+name|status_cb\n+argument_list|(\n+name|USB_DC_SOF\n+argument_list|,\n+name|NULL\n+argument_list|)\n+expr_stmt|;\n+break|break;\nThe issue was with: drivers: usb: device: add start of frame notifications to nxp mcux driver\n\nWhen usb middleware sends a start of frame notification to this driver,\ncall status_cb with USB_DC_SOF."
},{
  "instruction": "There is an issue in the following code. It relates to driver: usb: change function parameter name from class to base_class.\n\nChange function parameter name in function usbd_device_set_code_triple\nfrom `class` to `base_class` as `class` is a keyword in C++. Please fix this issue.",
  "input": "Faulty tokenized code:\nspecifier|const\nname|uint16_t\nname|pid\nparameter_list|)\nfunction_decl|;\ncomment|/**  * @brief Set USB device descriptor code triple Base Class, SubClass, and Protocol  *  * @param[in] uds_ctx  Pointer to USB device support context  * @param[in] class    bDeviceClass value  * @param[in] subclass bDeviceSubClass value  * @param[in] protocol bDeviceProtocol value  *  * @return 0 on success, other values on fail.  */\nname|int\nname|usbd_device_set_code_triple\nparameter_list|(\nname|struct\nname|usbd_contex\nspecifier|const\nname|uds_ctx\nparameter_list|,\nspecifier|const\nname|uint8_t\nname|class\nparameter_list|,\nspecifier|const\nname|uint8_t\nname|subclass\nparameter_list|,\nreturn|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|usbd_device_set_code_triple (struct usbd_contex * const uds_ctx,const uint8_t class,const uint8_t subclass,const uint8_t protocol)\nname|int\nname|usbd_device_set_code_triple\nparameter_list|(\nname|struct\nname|usbd_contex\nspecifier|const\nname|uds_ctx\nparameter_list|,\nspecifier|const\nname|uint8_t\nname|class\nparameter_list|,\nspecifier|const\nname|uint8_t\nname|subclass\nparameter_list|,\nblock|}\nname|desc\noperator|->\nname|bDeviceClass\noperator|=\nname|class\nexpr_stmt|;\nname|desc\noperator|->\nname|bDeviceSubClass\noperator|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/**  * @brief Set USB device descriptor code triple Base Class, SubClass, and Protocol  *  * @param[in] uds_ctx  Pointer to USB device support context  * @param[in] class    bDeviceClass value  * @param[in] subclass bDeviceSubClass value  * @param[in] protocol bDeviceProtocol value  *  * @return 0 on success, other values on fail.  */\n+comment|/**  * @brief Set USB device descriptor code triple Base Class, SubClass, and Protocol  *  * @param[in] uds_ctx    Pointer to USB device support context  * @param[in] base_class bDeviceClass value  * @param[in] subclass   bDeviceSubClass value  * @param[in] protocol   bDeviceProtocol value  *  * @return 0 on success, other values on fail.  */\n-name|class\n+name|base_class\n-DECL|function|usbd_device_set_code_triple (struct usbd_contex * const uds_ctx,const uint8_t class,const uint8_t subclass,const uint8_t protocol)\n+DECL|function|usbd_device_set_code_triple (struct usbd_contex * const uds_ctx,const uint8_t base_class,const uint8_t subclass,const uint8_t protocol)\n-name|class\n+name|base_class\n-name|class\n+name|base_class\nThe issue was with: driver: usb: change function parameter name from class to base_class.\n\nChange function parameter name in function usbd_device_set_code_triple\nfrom `class` to `base_class` as `class` is a keyword in C++."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: mfd: mfd_ad5592: fix typo\n\nFix a typo in `AD5592_REG_VAL_MASK` macro name. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|AD5592_SOFTWARE_RESET_MAGIC_VAL\nvalue|0x5AC\nend_define\n\nbegin_define\nDECL|macro|AD5592_REV_VAL_MASK\ndefine|#\ndirective|define\nname|AD5592_REV_VAL_MASK\nvalue|0x3FF\nend_define\n\nbegin_define\nDECL|macro|AD5592_REG_SHIFT_VAL\noperator|)\noperator||\noperator|(\nname|val\noperator|&\nname|AD5592_REV_VAL_MASK\noperator|)\nargument_list|)\ndecl_stmt|;\nreturn|return\nname|mfd_ad5592_write_raw",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|macro|AD5592_REV_VAL_MASK\n+DECL|macro|AD5592_REG_VAL_MASK\n-name|AD5592_REV_VAL_MASK\n+name|AD5592_REG_VAL_MASK\n-name|AD5592_REV_VAL_MASK\n+name|AD5592_REG_VAL_MASK\nThe issue was with: drivers: mfd: mfd_ad5592: fix typo\n\nFix a typo in `AD5592_REG_VAL_MASK` macro name."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: mfd: mfd_ad9952: fix reset magic value\n\nReset magic value equal 0xDAC is invalid. According to device\nspecification [1] a valid value is 0x5AC.\nUse proper value to make driver aligned with the spec.\n\n[1] https://www.analog.com/media/en/technical-documentation/data-sheets/ad5592r.pdf Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_define\nDECL|macro|AD5592_SOFTWARE_RESET_MAGIC_VAL\ndefine|#\ndirective|define\nname|AD5592_SOFTWARE_RESET_MAGIC_VAL\nvalue|0xDAC\nend_define\n\nbegin_define\nDECL|macro|AD5592_REV_VAL_MASK\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|0xDAC\n+value|0x5AC\nThe issue was with: drivers: mfd: mfd_ad9952: fix reset magic value\n\nReset magic value equal 0xDAC is invalid. According to device\nspecification [1] a valid value is 0x5AC.\nUse proper value to make driver aligned with the spec.\n\n[1] https://www.analog.com/media/en/technical-documentation/data-sheets/ad5592r.pdf"
},{
  "instruction": "There is an issue in the following code. It relates to tests/drivers uart_async_api: Fix build error with host gcc\n\nFor some reason the host gcc (11 & 12) does not believe\nrx_buf_size is constant. Let's work around it by using the\nsizeof() expression it is initialized to instead.\n\nThis fixes a build error when targetting native targets\nwhich use the host gcc:\n\ntests/drivers/uart/uart_async_api/src/test_uart_async.c:236:34:\nerror: expression in static assertion is not constant\n  236 |         BUILD_ASSERT(rx_buf_size <=\n  sizeof(tdata.rx_first_buffer), \\\"Invalid buf size\\\"); Please fix this issue.",
  "input": "Faulty tokenized code:\nname|int\nname|ret\ndecl_stmt|;\nname|BUILD_ASSERT\nargument_list|(\nname|rx_buf_size\noperator|<=\nsizeof|sizeof\nargument_list|(\nname|tdata\noperator|.",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|rx_buf_size\n+sizeof|sizeof\n+argument_list|(\n+name|tx_buf\n+argument_list|)\nThe issue was with: tests/drivers uart_async_api: Fix build error with host gcc\n\nFor some reason the host gcc (11 & 12) does not believe\nrx_buf_size is constant. Let's work around it by using the\nsizeof() expression it is initialized to instead.\n\nThis fixes a build error when targetting native targets\nwhich use the host gcc:\n\ntests/drivers/uart/uart_async_api/src/test_uart_async.c:236:34:\nerror: expression in static assertion is not constant\n  236 |         BUILD_ASSERT(rx_buf_size <=\n  sizeof(tdata.rx_first_buffer), \\\"Invalid buf size\\\");"
},{
  "instruction": "There is an issue in the following code. It relates to drivers uart_nrfx: Break infinite loops for simulation\n\nWhile waiting for the UART to be ready in ISR\nmode, for simulation only, add a tiny delay per\niteration of the busy wait loops to allow\ntime to pass.\nThis Z_SPIN_DELAY is an empty macro for any\nother target than simulation. Please fix this issue.",
  "input": "Faulty tokenized code:\nDECL|member|rx_timeout_timer\nname|struct\nname|k_timer\nname|rx_timeout_timer\ndecl_stmt|;\nDECL|union|__anon28caad40010a\nunion|union\nblock|{\nDECL|member|ppi\nname|gppi_channel_t\nname|ppi\nname|irq_unlock\nargument_list|(\nname|key\nargument_list|)\nexpr_stmt|;\nblock|}\nblock|}\nelse|else\nblock|{\nname|key\nname|NRF_UARTE_EVENT_ERROR\nargument_list|)\ncondition|)\nblock|{\ncomment|/* Busy wait for event to register */\nblock|}\nname|nrf_uarte_event_clear\nargument_list|(\nname|uarte\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon28caad40010a\n+DECL|union|__anon274d8355010a\n+name|Z_SPIN_DELAY\n+argument_list|(\n+literal|2\n+argument_list|)\n+expr_stmt|;\n+name|Z_SPIN_DELAY\n+argument_list|(\n+literal|2\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers uart_nrfx: Break infinite loops for simulation\n\nWhile waiting for the UART to be ready in ISR\nmode, for simulation only, add a tiny delay per\niteration of the busy wait loops to allow\ntime to pass.\nThis Z_SPIN_DELAY is an empty macro for any\nother target than simulation."
},{
  "instruction": "There is an issue in the following code. It relates to drivers counter_nrfx_timer: Get peripheral address from HAL\n\nInstead of getting the hardcoded address from the DT structure\nuse its symbolic name which will be resolved by the nRF HAL\ndefinitions to the same value.\n\nThis allows the TIMER peripherals' addresses to be redefined\nfor the simulated targets. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|idx\nparameter_list|)\ndefine|\\\nvalue|BUILD_ASSERT(DT_INST_PROP(idx, prescaler)<=\t\t\t\t\t\t\\ \t\t\tTIMER_PRESCALER_PRESCALER_Msk,\t\t\t\t\t\t\\ \t\t     \"TIMER prescaler out of range\");\t\t\t\t\t\t\\ \tCOND_CODE_1(DT_INST_PROP(idx, zli), (\t\t\t\t\t\t\t\\ \t\tISR_DIRECT_DECLARE(counter_timer##idx##_isr_wrapper)\t\t\t\t\\ \t\t{\t\t\t\t\t\t\t\t\t\t\\ \t\t\tirq_handler(DEVICE_DT_INST_GET(idx));\t\t\t\t\t\\\ncomment|/* No rescheduling, it shall not access zephyr primitives. */\nvalue|\\ \t\t\treturn 0;\t\t\t\t\t\t\t\t\\ \t\t}), ())\t\t\t\t\t\t\t\t\t\t\\ \tstatic int counter_##idx##_init(const struct device *dev)\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\t\t\t\\ \t\tTIMER_IRQ_CONNECT(idx);\t\t\t\t\t\t\t\t\\ \t\tstatic const struct counter_timer_config config = {\t\t\t\t\\ \t\t\t.prescaler = DT_INST_PROP(idx, prescaler),\t\t\t\t\\ \t\t\t.mode = NRF_TIMER_MODE_TIMER,\t\t\t\t\t\t\\ \t\t\t.bit_width = (DT_INST_PROP(idx, max_bit_width) == 32) ?\t\t\t\\ \t\t\t\t\tNRF_TIMER_BIT_WIDTH_32 : NRF_TIMER_BIT_WIDTH_16,\t\\ \t\t};\t\t\t\t\t\t\t\t\t\t\\ \t\treturn init_timer(dev,&config);\t\t\t\t\t\t\\ \t}\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct counter_nrfx_data counter_##idx##_data;\t\t\t\t\t\\ \tstatic struct counter_nrfx_ch_data\t\t\t\t\t\t\t\\ \t\tcounter##idx##_ch_data[CC_TO_ID(DT_INST_PROP(idx, cc_num))];\t\t\t\\ \tLOG_INSTANCE_REGISTER(LOG_MODULE_NAME, idx, CONFIG_COUNTER_LOG_LEVEL);\t\t\t\\ \tstatic const struct counter_nrfx_config nrfx_counter_##idx##_config = {\t\t\t\\ \t\t.info = {\t\t\t\t\t\t\t\t\t\\ \t\t\t.max_top_value = (uint32_t)BIT64_MASK(DT_INST_PROP(idx, max_bit_width)),\\ \t\t\t.freq = TIMER_CLOCK((NRF_TIMER_Type *)DT_INST_REG_ADDR(idx)) /\t\t\\ \t\t\t\tBIT(DT_INST_PROP(idx, prescaler)),\t\t\t\t\\ \t\t\t.flags = COUNTER_CONFIG_INFO_COUNT_UP,\t\t\t\t\t\\ \t\t\t.channels = CC_TO_ID(DT_INST_PROP(idx, cc_num)),\t\t\t\\ \t\t},\t\t\t\t\t\t\t\t\t\t\\ \t\t.ch_data = counter##idx##_ch_data,\t\t\t\t\t\t\\ \t\t.timer = (NRF_TIMER_Type *)DT_INST_REG_ADDR(idx),\t\t\t\t\\ \t\tLOG_INSTANCE_PTR_INIT(log, LOG_MODULE_NAME, idx)\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(idx,\t\t\t\t\t\t\t\t\\ \t\t\t    counter_##idx##_init,\t\t\t\t\t\t\\ \t\t\t    NULL,\t\t\t\t\t\t\t\t\\&counter_##idx##_data,\t\t\t\t\t\t\\&nrfx_counter_##idx##_config.info,\t\t\t\t\t\\ \t\t\t    PRE_KERNEL_1, CONFIG_COUNTER_INIT_PRIORITY,\t\t\t\t\\&counter_nrfx_driver_api);\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|\\ \t\t\treturn 0;\t\t\t\t\t\t\t\t\\ \t\t}), ())\t\t\t\t\t\t\t\t\t\t\\ \tstatic int counter_##idx##_init(const struct device *dev)\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\t\t\t\\ \t\tTIMER_IRQ_CONNECT(idx);\t\t\t\t\t\t\t\t\\ \t\tstatic const struct counter_timer_config config = {\t\t\t\t\\ \t\t\t.prescaler = DT_INST_PROP(idx, prescaler),\t\t\t\t\\ \t\t\t.mode = NRF_TIMER_MODE_TIMER,\t\t\t\t\t\t\\ \t\t\t.bit_width = (DT_INST_PROP(idx, max_bit_width) == 32) ?\t\t\t\\ \t\t\t\t\tNRF_TIMER_BIT_WIDTH_32 : NRF_TIMER_BIT_WIDTH_16,\t\\ \t\t};\t\t\t\t\t\t\t\t\t\t\\ \t\treturn init_timer(dev,&config);\t\t\t\t\t\t\\ \t}\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct counter_nrfx_data counter_##idx##_data;\t\t\t\t\t\\ \tstatic struct counter_nrfx_ch_data\t\t\t\t\t\t\t\\ \t\tcounter##idx##_ch_data[CC_TO_ID(DT_INST_PROP(idx, cc_num))];\t\t\t\\ \tLOG_INSTANCE_REGISTER(LOG_MODULE_NAME, idx, CONFIG_COUNTER_LOG_LEVEL);\t\t\t\\ \tstatic const struct counter_nrfx_config nrfx_counter_##idx##_config = {\t\t\t\\ \t\t.info = {\t\t\t\t\t\t\t\t\t\\ \t\t\t.max_top_value = (uint32_t)BIT64_MASK(DT_INST_PROP(idx, max_bit_width)),\\ \t\t\t.freq = TIMER_CLOCK((NRF_TIMER_Type *)DT_INST_REG_ADDR(idx)) /\t\t\\ \t\t\t\tBIT(DT_INST_PROP(idx, prescaler)),\t\t\t\t\\ \t\t\t.flags = COUNTER_CONFIG_INFO_COUNT_UP,\t\t\t\t\t\\ \t\t\t.channels = CC_TO_ID(DT_INST_PROP(idx, cc_num)),\t\t\t\\ \t\t},\t\t\t\t\t\t\t\t\t\t\\ \t\t.ch_data = counter##idx##_ch_data,\t\t\t\t\t\t\\ \t\t.timer = (NRF_TIMER_Type *)DT_INST_REG_ADDR(idx),\t\t\t\t\\ \t\tLOG_INSTANCE_PTR_INIT(log, LOG_MODULE_NAME, idx)\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(idx,\t\t\t\t\t\t\t\t\\ \t\t\t    counter_##idx##_init,\t\t\t\t\t\t\\ \t\t\t    NULL,\t\t\t\t\t\t\t\t\\&counter_##idx##_data,\t\t\t\t\t\t\\&nrfx_counter_##idx##_config.info,\t\t\t\t\t\\ \t\t\t    PRE_KERNEL_1, CONFIG_COUNTER_INIT_PRIORITY,\t\t\t\t\\&counter_nrfx_driver_api);\n+value|\\ \t\t\treturn 0;\t\t\t\t\t\t\t\t\\ \t\t}), ())\t\t\t\t\t\t\t\t\t\t\\ \tstatic int counter_##idx##_init(const struct device *dev)\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\t\t\t\\ \t\tTIMER_IRQ_CONNECT(idx);\t\t\t\t\t\t\t\t\\ \t\tstatic const struct counter_timer_config config = {\t\t\t\t\\ \t\t\t.prescaler = DT_INST_PROP(idx, prescaler),\t\t\t\t\\ \t\t\t.mode = NRF_TIMER_MODE_TIMER,\t\t\t\t\t\t\\ \t\t\t.bit_width = (DT_INST_PROP(idx, max_bit_width) == 32) ?\t\t\t\\ \t\t\t\t\tNRF_TIMER_BIT_WIDTH_32 : NRF_TIMER_BIT_WIDTH_16,\t\\ \t\t};\t\t\t\t\t\t\t\t\t\t\\ \t\treturn init_timer(dev,&config);\t\t\t\t\t\t\\ \t}\t\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct counter_nrfx_data counter_##idx##_data;\t\t\t\t\t\\ \tstatic struct counter_nrfx_ch_data\t\t\t\t\t\t\t\\ \t\tcounter##idx##_ch_data[CC_TO_ID(DT_INST_PROP(idx, cc_num))];\t\t\t\\ \tLOG_INSTANCE_REGISTER(LOG_MODULE_NAME, idx, CONFIG_COUNTER_LOG_LEVEL);\t\t\t\\ \tstatic const struct counter_nrfx_config nrfx_counter_##idx##_config = {\t\t\t\\ \t\t.info = {\t\t\t\t\t\t\t\t\t\\ \t\t\t.max_top_value = (uint32_t)BIT64_MASK(DT_INST_PROP(idx, max_bit_width)),\\ \t\t\t.freq = TIMER_CLOCK((NRF_TIMER_Type *)DT_INST_REG_ADDR(idx)) /\t\t\\ \t\t\t\tBIT(DT_INST_PROP(idx, prescaler)),\t\t\t\t\\ \t\t\t.flags = COUNTER_CONFIG_INFO_COUNT_UP,\t\t\t\t\t\\ \t\t\t.channels = CC_TO_ID(DT_INST_PROP(idx, cc_num)),\t\t\t\\ \t\t},\t\t\t\t\t\t\t\t\t\t\\ \t\t.ch_data = counter##idx##_ch_data,\t\t\t\t\t\t\\ \t\t.timer = (NRF_TIMER_Type *)_CONCAT(NRF_TIMER, idx),\t\t\t\t\\ \t\tLOG_INSTANCE_PTR_INIT(log, LOG_MODULE_NAME, idx)\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(idx,\t\t\t\t\t\t\t\t\\ \t\t\t    counter_##idx##_init,\t\t\t\t\t\t\\ \t\t\t    NULL,\t\t\t\t\t\t\t\t\\&counter_##idx##_data,\t\t\t\t\t\t\\&nrfx_counter_##idx##_config.info,\t\t\t\t\t\\ \t\t\t    PRE_KERNEL_1, CONFIG_COUNTER_INIT_PRIORITY,\t\t\t\t\\&counter_nrfx_driver_api);\nThe issue was with: drivers counter_nrfx_timer: Get peripheral address from HAL\n\nInstead of getting the hardcoded address from the DT structure\nuse its symbolic name which will be resolved by the nRF HAL\ndefinitions to the same value.\n\nThis allows the TIMER peripherals' addresses to be redefined\nfor the simulated targets."
},{
  "instruction": "There is an issue in the following code. It relates to drivers counter nrfx: Fix ISR prototype\n\nThe ISR prototype is not matching the\nsignature for interrupt handlers, which results in\nbuild warnings.\nLet's fix it. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|}\nblock|}\nend_function\n\nbegin_function\nDECL|function|irq_handler (const struct device * dev)\nspecifier|static\nname|void\nname|irq_handler\nparameter_list|(\nspecifier|const\nname|struct\nname|device\nmodifier|*\nname|dev\nparameter_list|)\nblock|{\nname|top_irq_handle\nargument_list|(\nname|dev\nargument_list|)\nexpr_stmt|;",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|function|irq_handler (const struct device * dev)\n+DECL|function|irq_handler (const void * arg)\n+name|void\n+modifier|*\n+name|arg\n+parameter_list|)\n+block|{\n+specifier|const\n-parameter_list|)\n-block|{\n+init|=\n+name|arg\n+decl_stmt|;\nThe issue was with: drivers counter nrfx: Fix ISR prototype\n\nThe ISR prototype is not matching the\nsignature for interrupt handlers, which results in\nbuild warnings.\nLet's fix it."
},{
  "instruction": "There is an issue in the following code. It relates to drivers uart_nrfx: Get peripheral address from HAL\n\nInstead of getting the hardcoded address from the DT structure\nuse its symbolic name which will be resolved by the nRF HAL\ndefinitions to the same value.\n\nThis allows the GPIO peripherals' addresses to be redefined\nfor the simulated targets. Please fix this issue.",
  "input": "Faulty tokenized code:\nDECL|member|rx_timeout_timer\nname|struct\nname|k_timer\nname|rx_timeout_timer\ndecl_stmt|;\nDECL|union|__anon2a34f298010a\nunion|union\nblock|{\nDECL|member|ppi\nname|gppi_channel_t\nname|ppi\nname|UART_NRF_UARTE_DEVICE\nparameter_list|(\nname|idx\nparameter_list|)\ndefine|\\\nvalue|NRF_DT_CHECK_NODE_HAS_PINCTRL_SLEEP(UARTE(idx));\t\t       \\ \tUARTE_INT_DRIVEN(idx);\t\t\t\t\t\t       \\ \tUARTE_ASYNC(idx);\t\t\t\t\t\t       \\ \tPINCTRL_DT_DEFINE(UARTE(idx));\t\t\t\t\t       \\ \tstatic uint8_t uarte##idx##_char_out UARTE_MEMORY_SECTION(idx);\t       \\ \tstatic uint8_t uarte##idx##_rx_data UARTE_MEMORY_SECTION(idx);\t       \\ \tstatic struct uarte_nrfx_data uarte_##idx##_data = {\t\t       \\ \t\tUARTE_CONFIG(idx),\t\t\t\t\t       \\ \t\tIF_ENABLED(CONFIG_UART_##idx##_ASYNC,\t\t\t       \\ \t\t\t    (.async =&uarte##idx##_async,))\t\t       \\ \t\tIF_ENABLED(CONFIG_UART_##idx##_INTERRUPT_DRIVEN,\t       \\ \t\t\t    (.int_driven =&uarte##idx##_int_driven,))\t       \\ \t};\t\t\t\t\t\t\t\t       \\ \tstatic const struct uarte_nrfx_config uarte_##idx##z_config = {\t       \\ \t\t.pcfg = PINCTRL_DT_DEV_CONFIG_GET(UARTE(idx)),\t\t       \\ \t\t.uarte_regs = (NRF_UARTE_Type *)DT_REG_ADDR(UARTE(idx)),       \\ \t\t.flags =\t\t\t\t\t\t       \\ \t\t\t(IS_ENABLED(CONFIG_UART_##idx##_GPIO_MANAGEMENT) ?     \\ \t\t\t\tUARTE_CFG_FLAG_GPIO_MGMT : 0) |\t\t       \\ \t\t\t(IS_ENABLED(CONFIG_UART_##idx##_ENHANCED_POLL_OUT) ?   \\ \t\t\t\tUARTE_CFG_FLAG_PPI_ENDTX : 0) |\t\t       \\ \t\t\tUSE_LOW_POWER(idx),\t\t\t\t       \\ \t\tUARTE_DISABLE_RX_INIT(UARTE(idx)),\t\t\t       \\ \t\tIF_ENABLED(CONFIG_UART_##idx##_NRF_HW_ASYNC,\t\t       \\ \t\t\t(.timer = NRFX_TIMER_INSTANCE(\t\t\t       \\ \t\t\t\tCONFIG_UART_##idx##_NRF_HW_ASYNC_TIMER),))     \\ \t};\t\t\t\t\t\t\t\t       \\ \tstatic int uarte_##idx##_init(const struct device *dev)\t\t       \\ \t{\t\t\t\t\t\t\t\t       \\ \t\tCOND_CODE_1(CONFIG_UART_##idx##_ASYNC,\t\t\t       \\ \t\t\t   (UARTE_IRQ_CONFIGURE(idx, uarte_nrfx_isr_async);),  \\ \t\t\t   (UARTE_IRQ_CONFIGURE(idx, uarte_nrfx_isr_int);))    \\ \t\treturn uarte_instance_init(\t\t\t\t       \\ \t\t\tdev,\t\t\t\t\t\t       \\ \t\t\tIS_ENABLED(CONFIG_UART_##idx##_INTERRUPT_DRIVEN));     \\ \t}\t\t\t\t\t\t\t\t       \\ \t\t\t\t\t\t\t\t\t       \\ \tPM_DEVICE_DT_DEFINE(UARTE(idx), uarte_nrfx_pm_action);\t\t       \\ \t\t\t\t\t\t\t\t\t       \\ \tDEVICE_DT_DEFINE(UARTE(idx),\t\t\t\t\t       \\ \t\t      uarte_##idx##_init,\t\t\t\t       \\ \t\t      PM_DEVICE_DT_GET(UARTE(idx)),\t\t\t       \\&uarte_##idx##_data,\t\t\t\t       \\&uarte_##idx##z_config,\t\t\t\t       \\ \t\t      PRE_KERNEL_1,\t\t\t\t\t       \\ \t\t      CONFIG_SERIAL_INIT_PRIORITY,\t\t\t       \\&uart_nrfx_uarte_driver_api)\nend_define\n\nbegin_define\nDECL|macro|UARTE_CONFIG (idx)\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon2a34f298010a\n+DECL|union|__anon2b67fb55010a\n-value|NRF_DT_CHECK_NODE_HAS_PINCTRL_SLEEP(UARTE(idx));\t\t       \\ \tUARTE_INT_DRIVEN(idx);\t\t\t\t\t\t       \\ \tUARTE_ASYNC(idx);\t\t\t\t\t\t       \\ \tPINCTRL_DT_DEFINE(UARTE(idx));\t\t\t\t\t       \\ \tstatic uint8_t uarte##idx##_char_out UARTE_MEMORY_SECTION(idx);\t       \\ \tstatic uint8_t uarte##idx##_rx_data UARTE_MEMORY_SECTION(idx);\t       \\ \tstatic struct uarte_nrfx_data uarte_##idx##_data = {\t\t       \\ \t\tUARTE_CONFIG(idx),\t\t\t\t\t       \\ \t\tIF_ENABLED(CONFIG_UART_##idx##_ASYNC,\t\t\t       \\ \t\t\t    (.async =&uarte##idx##_async,))\t\t       \\ \t\tIF_ENABLED(CONFIG_UART_##idx##_INTERRUPT_DRIVEN,\t       \\ \t\t\t    (.int_driven =&uarte##idx##_int_driven,))\t       \\ \t};\t\t\t\t\t\t\t\t       \\ \tstatic const struct uarte_nrfx_config uarte_##idx##z_config = {\t       \\ \t\t.pcfg = PINCTRL_DT_DEV_CONFIG_GET(UARTE(idx)),\t\t       \\ \t\t.uarte_regs = (NRF_UARTE_Type *)DT_REG_ADDR(UARTE(idx)),       \\ \t\t.flags =\t\t\t\t\t\t       \\ \t\t\t(IS_ENABLED(CONFIG_UART_##idx##_GPIO_MANAGEMENT) ?     \\ \t\t\t\tUARTE_CFG_FLAG_GPIO_MGMT : 0) |\t\t       \\ \t\t\t(IS_ENABLED(CONFIG_UART_##idx##_ENHANCED_POLL_OUT) ?   \\ \t\t\t\tUARTE_CFG_FLAG_PPI_ENDTX : 0) |\t\t       \\ \t\t\tUSE_LOW_POWER(idx),\t\t\t\t       \\ \t\tUARTE_DISABLE_RX_INIT(UARTE(idx)),\t\t\t       \\ \t\tIF_ENABLED(CONFIG_UART_##idx##_NRF_HW_ASYNC,\t\t       \\ \t\t\t(.timer = NRFX_TIMER_INSTANCE(\t\t\t       \\ \t\t\t\tCONFIG_UART_##idx##_NRF_HW_ASYNC_TIMER),))     \\ \t};\t\t\t\t\t\t\t\t       \\ \tstatic int uarte_##idx##_init(const struct device *dev)\t\t       \\ \t{\t\t\t\t\t\t\t\t       \\ \t\tCOND_CODE_1(CONFIG_UART_##idx##_ASYNC,\t\t\t       \\ \t\t\t   (UARTE_IRQ_CONFIGURE(idx, uarte_nrfx_isr_async);),  \\ \t\t\t   (UARTE_IRQ_CONFIGURE(idx, uarte_nrfx_isr_int);))    \\ \t\treturn uarte_instance_init(\t\t\t\t       \\ \t\t\tdev,\t\t\t\t\t\t       \\ \t\t\tIS_ENABLED(CONFIG_UART_##idx##_INTERRUPT_DRIVEN));     \\ \t}\t\t\t\t\t\t\t\t       \\ \t\t\t\t\t\t\t\t\t       \\ \tPM_DEVICE_DT_DEFINE(UARTE(idx), uarte_nrfx_pm_action);\t\t       \\ \t\t\t\t\t\t\t\t\t       \\ \tDEVICE_DT_DEFINE(UARTE(idx),\t\t\t\t\t       \\ \t\t      uarte_##idx##_init,\t\t\t\t       \\ \t\t      PM_DEVICE_DT_GET(UARTE(idx)),\t\t\t       \\&uarte_##idx##_data,\t\t\t\t       \\&uarte_##idx##z_config,\t\t\t\t       \\ \t\t      PRE_KERNEL_1,\t\t\t\t\t       \\ \t\t      CONFIG_SERIAL_INIT_PRIORITY,\t\t\t       \\&uart_nrfx_uarte_driver_api)\n+value|NRF_DT_CHECK_NODE_HAS_PINCTRL_SLEEP(UARTE(idx));\t\t       \\ \tUARTE_INT_DRIVEN(idx);\t\t\t\t\t\t       \\ \tUARTE_ASYNC(idx);\t\t\t\t\t\t       \\ \tPINCTRL_DT_DEFINE(UARTE(idx));\t\t\t\t\t       \\ \tstatic uint8_t uarte##idx##_char_out UARTE_MEMORY_SECTION(idx);\t       \\ \tstatic uint8_t uarte##idx##_rx_data UARTE_MEMORY_SECTION(idx);\t       \\ \tstatic struct uarte_nrfx_data uarte_##idx##_data = {\t\t       \\ \t\tUARTE_CONFIG(idx),\t\t\t\t\t       \\ \t\tIF_ENABLED(CONFIG_UART_##idx##_ASYNC,\t\t\t       \\ \t\t\t    (.async =&uarte##idx##_async,))\t\t       \\ \t\tIF_ENABLED(CONFIG_UART_##idx##_INTERRUPT_DRIVEN,\t       \\ \t\t\t    (.int_driven =&uarte##idx##_int_driven,))\t       \\ \t};\t\t\t\t\t\t\t\t       \\ \tstatic const struct uarte_nrfx_config uarte_##idx##z_config = {\t       \\ \t\t.pcfg = PINCTRL_DT_DEV_CONFIG_GET(UARTE(idx)),\t\t       \\ \t\t.uarte_regs = _CONCAT(NRF_UARTE, idx),                         \\ \t\t.flags =\t\t\t\t\t\t       \\ \t\t\t(IS_ENABLED(CONFIG_UART_##idx##_GPIO_MANAGEMENT) ?     \\ \t\t\t\tUARTE_CFG_FLAG_GPIO_MGMT : 0) |\t\t       \\ \t\t\t(IS_ENABLED(CONFIG_UART_##idx##_ENHANCED_POLL_OUT) ?   \\ \t\t\t\tUARTE_CFG_FLAG_PPI_ENDTX : 0) |\t\t       \\ \t\t\tUSE_LOW_POWER(idx),\t\t\t\t       \\ \t\tUARTE_DISABLE_RX_INIT(UARTE(idx)),\t\t\t       \\ \t\tIF_ENABLED(CONFIG_UART_##idx##_NRF_HW_ASYNC,\t\t       \\ \t\t\t(.timer = NRFX_TIMER_INSTANCE(\t\t\t       \\ \t\t\t\tCONFIG_UART_##idx##_NRF_HW_ASYNC_TIMER),))     \\ \t};\t\t\t\t\t\t\t\t       \\ \tstatic int uarte_##idx##_init(const struct device *dev)\t\t       \\ \t{\t\t\t\t\t\t\t\t       \\ \t\tCOND_CODE_1(CONFIG_UART_##idx##_ASYNC,\t\t\t       \\ \t\t\t   (UARTE_IRQ_CONFIGURE(idx, uarte_nrfx_isr_async);),  \\ \t\t\t   (UARTE_IRQ_CONFIGURE(idx, uarte_nrfx_isr_int);))    \\ \t\treturn uarte_instance_init(\t\t\t\t       \\ \t\t\tdev,\t\t\t\t\t\t       \\ \t\t\tIS_ENABLED(CONFIG_UART_##idx##_INTERRUPT_DRIVEN));     \\ \t}\t\t\t\t\t\t\t\t       \\ \t\t\t\t\t\t\t\t\t       \\ \tPM_DEVICE_DT_DEFINE(UARTE(idx), uarte_nrfx_pm_action);\t\t       \\ \t\t\t\t\t\t\t\t\t       \\ \tDEVICE_DT_DEFINE(UARTE(idx),\t\t\t\t\t       \\ \t\t      uarte_##idx##_init,\t\t\t\t       \\ \t\t      PM_DEVICE_DT_GET(UARTE(idx)),\t\t\t       \\&uarte_##idx##_data,\t\t\t\t       \\&uarte_##idx##z_config,\t\t\t\t       \\ \t\t      PRE_KERNEL_1,\t\t\t\t\t       \\ \t\t      CONFIG_SERIAL_INIT_PRIORITY,\t\t\t       \\&uart_nrfx_uarte_driver_api)\nThe issue was with: drivers uart_nrfx: Get peripheral address from HAL\n\nInstead of getting the hardcoded address from the DT structure\nuse its symbolic name which will be resolved by the nRF HAL\ndefinitions to the same value.\n\nThis allows the GPIO peripherals' addresses to be redefined\nfor the simulated targets."
},{
  "instruction": "There is an issue in the following code. It relates to drivers uart nrfx: Fix ISR prototype\n\nThe ISR prototype used when building without the\ninterrupt driven UART was not matching the\nsignature for interrupt handlers, which results in\nbuild warnings.\nLet's fix it. Please fix this issue.",
  "input": "Faulty tokenized code:\nDECL|member|rx_timeout_timer\nname|struct\nname|k_timer\nname|rx_timeout_timer\ndecl_stmt|;\nDECL|union|__anon2762011d010a\nunion|union\nblock|{\nDECL|member|ppi\nname|gppi_channel_t\nname|ppi\nexpr_stmt|;\nblock|}\nend_function\n\nbegin_function\nDECL|function|uarte_nrfx_isr_async (const struct device * dev)\nspecifier|static\nname|void\nname|uarte_nrfx_isr_async\nparameter_list|(\nspecifier|const\nname|struct\nname|device\nmodifier|*\nname|dev\nparameter_list|)\nblock|{\nname|NRF_UARTE_Type\nmodifier|*\nname|uarte\ninit|=\nname|get_uarte_instance",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon2762011d010a\n+DECL|union|__anon2a34f298010a\n-DECL|function|uarte_nrfx_isr_async (const struct device * dev)\n+DECL|function|uarte_nrfx_isr_async (const void * arg)\n+name|void\n+modifier|*\n+name|arg\n+parameter_list|)\n+block|{\n+specifier|const\n-parameter_list|)\n-block|{\n+init|=\n+name|arg\n+decl_stmt|;\nThe issue was with: drivers uart nrfx: Fix ISR prototype\n\nThe ISR prototype used when building without the\ninterrupt driven UART was not matching the\nsignature for interrupt handlers, which results in\nbuild warnings.\nLet's fix it."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: intc_plic: fix plic PLIC_TRIG_LEVEL define mistake\n\nInterrupt trigger type register each bit indicate the configured interrupt\ntype. bit value is 0 indicate level trigger interrupt, 1 indicate edge\ntrigger interrupt.\n\nThe level trigger defined to ~BIT(0) equal 0xfffffffe not equal 0. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_define\nDECL|macro|PLIC_TRIG_LEVEL\ndefine|#\ndirective|define\nname|PLIC_TRIG_LEVEL\nvalue|((uint32_t)~BIT(0))\nend_define\n\nbegin_define\nDECL|macro|PLIC_TRIG_EDGE\ndefine|#\ndirective|define\nname|PLIC_TRIG_EDGE\nvalue|((uint32_t)BIT(0))\nend_define\n\nbegin_define\nDECL|macro|PLIC_DRV_HAS_COMPAT (compat)\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|((uint32_t)~BIT(0))\n+value|((uint32_t)0)\n-value|((uint32_t)BIT(0))\n+value|((uint32_t)1)\nThe issue was with: drivers: intc_plic: fix plic PLIC_TRIG_LEVEL define mistake\n\nInterrupt trigger type register each bit indicate the configured interrupt\ntype. bit value is 0 indicate level trigger interrupt, 1 indicate edge\ntrigger interrupt.\n\nThe level trigger defined to ~BIT(0) equal 0xfffffffe not equal 0."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: usb_dc_native_posix: do callback for ZLPs\n\nA Zero Length Packet can be used by higher layer stack to discover when\nan endpoint is being processed by the host. An example of this was\nintroduced as part of a3b3b9d14475 [formerly 0127d000a287] (\\\"usb: device: cdc_acm: Use ZLP to\ndetect initial host read\\\") in the CDC ACM class.\n\nNot invoking the callback for ZLPs results in the higher layer stack not\nbeing informed when the packet is consumed. This manifests as a CDC ACM\nUSB-IP device that cannot transmit to the host while being able to\nreceive from the host. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|buf_len\nargument_list|,\nliteral|\">\"\nargument_list|)\nexpr_stmt|;\ncomment|/* \t\t * Call the callback only if data in usb_dc_ep_write() \t\t * is actually written to the intermediate buffer and sent. \t\t */\nif|if\ncondition|(\nname|ep_ctrl\noperator|->\nname|buf_len\noperator|!=\nliteral|0\ncondition|)\nblock|{\nname|ep_ctrl\noperator|->\nname|cb\nargument_list|(\nname|ep\nargument_list|,\nname|USB_DC_EP_DATA_IN\nargument_list|)\nexpr_stmt|;\nname|usbip_ctrl\noperator|.\nname|in_ep_ctrl\nindex|[\nname|ep_idx\nindex|]\noperator|.\nname|buf_len\noperator|=\nliteral|0\nexpr_stmt|;\nblock|}\nblock|}\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* \t\t * Call the callback only if data in usb_dc_ep_write() \t\t * is actually written to the intermediate buffer and sent. \t\t */\n-if|if\n-condition|(\n-name|ep_ctrl\n-operator|->\n-name|buf_len\n-operator|!=\n-literal|0\n-condition|)\n-block|{\n-name|usbip_ctrl\n-operator|.\n-name|in_ep_ctrl\n-index|[\n-name|ep_idx\n-index|]\n-operator|.\n+name|ep_ctrl\n+operator|->\n-block|}\nThe issue was with: drivers: usb_dc_native_posix: do callback for ZLPs\n\nA Zero Length Packet can be used by higher layer stack to discover when\nan endpoint is being processed by the host. An example of this was\nintroduced as part of a3b3b9d14475 [formerly 0127d000a287] (\\\"usb: device: cdc_acm: Use ZLP to\ndetect initial host read\\\") in the CDC ACM class.\n\nNot invoking the callback for ZLPs results in the higher layer stack not\nbeing informed when the packet is consumed. This manifests as a CDC ACM\nUSB-IP device that cannot transmit to the host while being able to\nreceive from the host."
},{
  "instruction": "There is an issue in the following code. It relates to arch: arm: core: cortex_m: fix cache disabling in init_arch_hw_at_boot\n\nUse the arch-cache functions instead of the sys-cache-functions\nin z_arm_init_arch_hw_at_boot to ensure that the caches are\ndisabled even when CONFIG_CACHE_MANAGEMENT is disabled. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/cache.h>\nend_include\n\nbegin_if\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|CCR\noperator|&\nname|SCB_CCR_DC_Msk\ncondition|)\nblock|{\nname|sys_cache_data_disable\nargument_list|()\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\nname|sys_cache_data_invd_all\nargument_list|()\nexpr_stmt|;\nblock|}\nendif|#\ndirective|endif\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_ICACHE\nargument_list|)\ncomment|/* Reset I-Cache settings. */\nname|sys_cache_instr_disable\nargument_list|()\nexpr_stmt|;\nendif|#\ndirective|endif\ncomment|/* CONFIG_ICACHE */",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/arch/cache.h>\n+end_include\n+\n-name|sys_cache_data_disable\n+comment|/* \t\t * Do not use sys_cache_data_disable at this point, but instead \t\t * the architecture specific function. This ensures that the \t\t * cache is disabled although CONFIG_CACHE_MANAGEMENT might be \t\t * disabled. \t\t */\n+name|SCB_DisableDCache\n-name|sys_cache_data_invd_all\n+name|SCB_InvalidateDCache\n-comment|/* Reset I-Cache settings. */\n-name|sys_cache_instr_disable\n+comment|/* \t * Reset I-Cache settings. \t * Do not use sys_cache_data_disable at this point, but instead \t * the architecture specific function. This ensures that the \t * cache is disabled although CONFIG_CACHE_MANAGEMENT might be \t * disabled. \t */\n+name|SCB_DisableICache\nThe issue was with: arch: arm: core: cortex_m: fix cache disabling in init_arch_hw_at_boot\n\nUse the arch-cache functions instead of the sys-cache-functions\nin z_arm_init_arch_hw_at_boot to ensure that the caches are\ndisabled even when CONFIG_CACHE_MANAGEMENT is disabled."
},{
  "instruction": "There is an issue in the following code. It relates to arch: arc: use sys_cache instead of arch-function for enabling the cache\n\nUse sys_cache_data_enable instead of arch_dcache_enable to enable\nthe cache. This will ensure that CONFIG_CACHE_MANAGEMENT\nis considered correctly. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|init_dcache\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nname|arch_dcache_enable\nargument_list|()\nexpr_stmt|;\nif|#\ndirective|if\nname|defined",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|arch_dcache_enable\n+name|sys_cache_data_enable\nThe issue was with: arch: arc: use sys_cache instead of arch-function for enabling the cache\n\nUse sys_cache_data_enable instead of arch_dcache_enable to enable\nthe cache. This will ensure that CONFIG_CACHE_MANAGEMENT\nis considered correctly."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: ns16550: Add IOPORT_ENABLED check condition\n\nio_map check to enable LPSS DMA initialization is kept under\ncondition IOPORT_ENABLED. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_struct\nDECL|struct|uart_ns16550_device_config\nstruct|struct\nname|uart_ns16550_device_config\nblock|{\nDECL|union|__anon2952fec4010a\nunion|union\nblock|{\nname|DEVICE_MMIO_ROM\nexpr_stmt|;\nDECL|member|port\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_UART_NS16550_INTEL_LPSS_DMA\nargument_list|)\nif|if\ncondition|(\noperator|!\nname|dev_cfg\noperator|->\nname|io_map\ncondition|)\nblock|{\nname|uintptr_t\nname|base\ndecl_stmt|;\nname|base",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon2952fec4010a\n+DECL|union|__anon292e4ef4010a\n+if|#\n+directive|if\n+name|UART_NS16550_IOPORT_ENABLED\n+endif|#\n+directive|endif\nThe issue was with: drivers: serial: ns16550: Add IOPORT_ENABLED check condition\n\nio_map check to enable LPSS DMA initialization is kept under\ncondition IOPORT_ENABLED."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: can: nuvoton: numaker: fix init function reference\n\nFix the reference to the init function. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|CAN_NUMAKER_INIT\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|NUMAKER_PINCTRL_DEFINE(inst);                                             \\ \tCAN_MCAN_DT_INST_CALLBACKS_DEFINE(inst, can_numaker_cbs_##inst);\t  \\ \t\t\t\t\t\t\t\t\t          \\ \tstatic void can_numaker_irq_config_func_##inst(const struct device *dev)  \\ \t{                                                                         \\ \t\tIRQ_CONNECT(DT_INST_IRQ_BY_NAME(inst, int0, irq),                 \\ \t\t\t\tDT_INST_IRQ_BY_NAME(inst, int0, priority),        \\ \t\t\t\tcan_mcan_line_0_isr,                              \\ \t\t\t\tDEVICE_DT_INST_GET(inst),                         \\ \t\t\t\t0);                                               \\ \t\tirq_enable(DT_INST_IRQ_BY_NAME(inst, int0, irq));                 \\ \t\tIRQ_CONNECT(DT_INST_IRQ_BY_NAME(inst, int1, irq),                 \\ \t\t\t\tDT_INST_IRQ_BY_NAME(inst, int1, priority),        \\ \t\t\t\tcan_mcan_line_1_isr,                              \\ \t\t\t\tDEVICE_DT_INST_GET(inst),                         \\ \t\t\t\t0);                                               \\ \t\tirq_enable(DT_INST_IRQ_BY_NAME(inst, int1, irq));                 \\ \t}                                                                         \\ \t\t\t\t\t\t\t\t\t\t  \\ \tstatic const struct can_numaker_config can_numaker_config_##inst = {      \\ \t\t.canfd_base = CAN_MCAN_DT_INST_MCAN_ADDR(inst),                   \\ \t\t.mrba = CAN_MCAN_DT_INST_MRBA(inst),\t\t\t          \\ \t\t.mram = CAN_MCAN_DT_INST_MRAM_ADDR(inst),\t\t\t  \\ \t\t.reset = RESET_DT_SPEC_INST_GET(inst),                            \\ \t\t.clk_modidx = DT_INST_CLOCKS_CELL(inst, clock_module_index),      \\ \t\t.clk_src = DT_INST_CLOCKS_CELL(inst, clock_source),               \\ \t\t.clk_div = DT_INST_CLOCKS_CELL(inst, clock_divider),              \\ \t\tNUMAKER_CLKCTRL_DEV_INIT(inst)                                    \\ \t\t.irq_config_func = can_numaker_irq_config_func_##inst,            \\ \t\tNUMAKER_PINCTRL_INIT(inst)                                        \\ \t};                                                                        \\                                                                                   \\ \tstatic const struct can_mcan_config can_mcan_config_##inst =              \\ \t\tCAN_MCAN_DT_CONFIG_INST_GET(inst,                                 \\&can_numaker_config_##inst,                               \\&can_numaker_ops,\t\t                          \\&can_numaker_cbs_##inst);\t                          \\                                                                                   \\ \tstatic uint32_t can_numaker_data_##inst;                                  \\                                                                                   \\ \tstatic struct can_mcan_data can_mcan_data_##inst =                        \\ \t\tCAN_MCAN_DATA_INITIALIZER(&can_numaker_data_ ## inst);            \\                                                                                   \\ \tCAN_DEVICE_DT_INST_DEFINE(inst,                                           \\&can_numaker_init,                                                \\ \t\tNULL,                                                             \\&can_mcan_data_##inst,                                            \\&can_mcan_config_##inst,                                          \\ \t\tPOST_KERNEL,                                                      \\ \t\tCONFIG_CAN_INIT_PRIORITY,                                         \\&can_numaker_driver_api);                                         \\  DT_INST_FOREACH_STATUS_OKAY(CAN_NUMAKER_INIT);\nend_define\n\nend_unit\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|NUMAKER_PINCTRL_DEFINE(inst);                                             \\ \tCAN_MCAN_DT_INST_CALLBACKS_DEFINE(inst, can_numaker_cbs_##inst);\t  \\ \t\t\t\t\t\t\t\t\t          \\ \tstatic void can_numaker_irq_config_func_##inst(const struct device *dev)  \\ \t{                                                                         \\ \t\tIRQ_CONNECT(DT_INST_IRQ_BY_NAME(inst, int0, irq),                 \\ \t\t\t\tDT_INST_IRQ_BY_NAME(inst, int0, priority),        \\ \t\t\t\tcan_mcan_line_0_isr,                              \\ \t\t\t\tDEVICE_DT_INST_GET(inst),                         \\ \t\t\t\t0);                                               \\ \t\tirq_enable(DT_INST_IRQ_BY_NAME(inst, int0, irq));                 \\ \t\tIRQ_CONNECT(DT_INST_IRQ_BY_NAME(inst, int1, irq),                 \\ \t\t\t\tDT_INST_IRQ_BY_NAME(inst, int1, priority),        \\ \t\t\t\tcan_mcan_line_1_isr,                              \\ \t\t\t\tDEVICE_DT_INST_GET(inst),                         \\ \t\t\t\t0);                                               \\ \t\tirq_enable(DT_INST_IRQ_BY_NAME(inst, int1, irq));                 \\ \t}                                                                         \\ \t\t\t\t\t\t\t\t\t\t  \\ \tstatic const struct can_numaker_config can_numaker_config_##inst = {      \\ \t\t.canfd_base = CAN_MCAN_DT_INST_MCAN_ADDR(inst),                   \\ \t\t.mrba = CAN_MCAN_DT_INST_MRBA(inst),\t\t\t          \\ \t\t.mram = CAN_MCAN_DT_INST_MRAM_ADDR(inst),\t\t\t  \\ \t\t.reset = RESET_DT_SPEC_INST_GET(inst),                            \\ \t\t.clk_modidx = DT_INST_CLOCKS_CELL(inst, clock_module_index),      \\ \t\t.clk_src = DT_INST_CLOCKS_CELL(inst, clock_source),               \\ \t\t.clk_div = DT_INST_CLOCKS_CELL(inst, clock_divider),              \\ \t\tNUMAKER_CLKCTRL_DEV_INIT(inst)                                    \\ \t\t.irq_config_func = can_numaker_irq_config_func_##inst,            \\ \t\tNUMAKER_PINCTRL_INIT(inst)                                        \\ \t};                                                                        \\                                                                                   \\ \tstatic const struct can_mcan_config can_mcan_config_##inst =              \\ \t\tCAN_MCAN_DT_CONFIG_INST_GET(inst,                                 \\&can_numaker_config_##inst,                               \\&can_numaker_ops,\t\t                          \\&can_numaker_cbs_##inst);\t                          \\                                                                                   \\ \tstatic uint32_t can_numaker_data_##inst;                                  \\                                                                                   \\ \tstatic struct can_mcan_data can_mcan_data_##inst =                        \\ \t\tCAN_MCAN_DATA_INITIALIZER(&can_numaker_data_ ## inst);            \\                                                                                   \\ \tCAN_DEVICE_DT_INST_DEFINE(inst,                                           \\&can_numaker_init,                                                \\ \t\tNULL,                                                             \\&can_mcan_data_##inst,                                            \\&can_mcan_config_##inst,                                          \\ \t\tPOST_KERNEL,                                                      \\ \t\tCONFIG_CAN_INIT_PRIORITY,                                         \\&can_numaker_driver_api);                                         \\  DT_INST_FOREACH_STATUS_OKAY(CAN_NUMAKER_INIT);\n+value|NUMAKER_PINCTRL_DEFINE(inst);                                             \\ \tCAN_MCAN_DT_INST_CALLBACKS_DEFINE(inst, can_numaker_cbs_##inst);\t  \\ \t\t\t\t\t\t\t\t\t          \\ \tstatic void can_numaker_irq_config_func_##inst(const struct device *dev)  \\ \t{                                                                         \\ \t\tIRQ_CONNECT(DT_INST_IRQ_BY_NAME(inst, int0, irq),                 \\ \t\t\t\tDT_INST_IRQ_BY_NAME(inst, int0, priority),        \\ \t\t\t\tcan_mcan_line_0_isr,                              \\ \t\t\t\tDEVICE_DT_INST_GET(inst),                         \\ \t\t\t\t0);                                               \\ \t\tirq_enable(DT_INST_IRQ_BY_NAME(inst, int0, irq));                 \\ \t\tIRQ_CONNECT(DT_INST_IRQ_BY_NAME(inst, int1, irq),                 \\ \t\t\t\tDT_INST_IRQ_BY_NAME(inst, int1, priority),        \\ \t\t\t\tcan_mcan_line_1_isr,                              \\ \t\t\t\tDEVICE_DT_INST_GET(inst),                         \\ \t\t\t\t0);                                               \\ \t\tirq_enable(DT_INST_IRQ_BY_NAME(inst, int1, irq));                 \\ \t}                                                                         \\ \t\t\t\t\t\t\t\t\t\t  \\ \tstatic const struct can_numaker_config can_numaker_config_##inst = {      \\ \t\t.canfd_base = CAN_MCAN_DT_INST_MCAN_ADDR(inst),                   \\ \t\t.mrba = CAN_MCAN_DT_INST_MRBA(inst),\t\t\t          \\ \t\t.mram = CAN_MCAN_DT_INST_MRAM_ADDR(inst),\t\t\t  \\ \t\t.reset = RESET_DT_SPEC_INST_GET(inst),                            \\ \t\t.clk_modidx = DT_INST_CLOCKS_CELL(inst, clock_module_index),      \\ \t\t.clk_src = DT_INST_CLOCKS_CELL(inst, clock_source),               \\ \t\t.clk_div = DT_INST_CLOCKS_CELL(inst, clock_divider),              \\ \t\tNUMAKER_CLKCTRL_DEV_INIT(inst)                                    \\ \t\t.irq_config_func = can_numaker_irq_config_func_##inst,            \\ \t\tNUMAKER_PINCTRL_INIT(inst)                                        \\ \t};                                                                        \\                                                                                   \\ \tstatic const struct can_mcan_config can_mcan_config_##inst =              \\ \t\tCAN_MCAN_DT_CONFIG_INST_GET(inst,                                 \\&can_numaker_config_##inst,                               \\&can_numaker_ops,\t\t                          \\&can_numaker_cbs_##inst);\t                          \\                                                                                   \\ \tstatic uint32_t can_numaker_data_##inst;                                  \\                                                                                   \\ \tstatic struct can_mcan_data can_mcan_data_##inst =                        \\ \t\tCAN_MCAN_DATA_INITIALIZER(&can_numaker_data_ ## inst);            \\                                                                                   \\ \tCAN_DEVICE_DT_INST_DEFINE(inst,                                           \\ \t\tcan_numaker_init,                                                 \\ \t\tNULL,                                                             \\&can_mcan_data_##inst,                                            \\&can_mcan_config_##inst,                                          \\ \t\tPOST_KERNEL,                                                      \\ \t\tCONFIG_CAN_INIT_PRIORITY,                                         \\&can_numaker_driver_api);                                         \\  DT_INST_FOREACH_STATUS_OKAY(CAN_NUMAKER_INIT);\nThe issue was with: drivers: can: nuvoton: numaker: fix init function reference\n\nFix the reference to the init function."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: can: nuvoton: numaker: use named IRQs\n\nSwitch to using named IRQs as index-based access makes no guarantees about\ndevicetree interrupt order. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|CAN_NUMAKER_INIT\nparameter_list|(\nname|inst\nparameter_list|)\ndefine|\\\nvalue|NUMAKER_PINCTRL_DEFINE(inst);                                             \\ \tCAN_MCAN_DT_INST_CALLBACKS_DEFINE(inst, can_numaker_cbs_##inst);\t  \\ \t\t\t\t\t\t\t\t\t          \\ \tstatic void can_numaker_irq_config_func_##inst(const struct device *dev)  \\ \t{                                                                         \\ \t\tIRQ_CONNECT(DT_INST_IRQ_BY_IDX(inst, 0, irq),                     \\ \t\t\t\tDT_INST_IRQ_BY_IDX(inst, 0, priority),            \\ \t\t\t\tcan_mcan_line_0_isr,                              \\ \t\t\t\tDEVICE_DT_INST_GET(inst),                         \\ \t\t\t\t0);                                               \\ \t\tirq_enable(DT_INST_IRQ_BY_IDX(inst, 0, irq));                     \\ \t\tIRQ_CONNECT(DT_INST_IRQ_BY_IDX(inst, 1, irq),                     \\ \t\t\t\tDT_INST_IRQ_BY_IDX(inst, 1, priority),            \\ \t\t\t\tcan_mcan_line_1_isr,                              \\ \t\t\t\tDEVICE_DT_INST_GET(inst),                         \\ \t\t\t\t0);                                               \\ \t\tirq_enable(DT_INST_IRQ_BY_IDX(inst, 1, irq));                     \\ \t}                                                                         \\ \t\t\t\t\t\t\t\t\t\t  \\ \tstatic const struct can_numaker_config can_numaker_config_##inst = {      \\ \t\t.canfd_base = CAN_MCAN_DT_INST_MCAN_ADDR(inst),                   \\ \t\t.mrba = CAN_MCAN_DT_INST_MRBA(inst),\t\t\t          \\ \t\t.mram = CAN_MCAN_DT_INST_MRAM_ADDR(inst),\t\t\t  \\ \t\t.reset = RESET_DT_SPEC_INST_GET(inst),                            \\ \t\t.clk_modidx = DT_INST_CLOCKS_CELL(inst, clock_module_index),      \\ \t\t.clk_src = DT_INST_CLOCKS_CELL(inst, clock_source),               \\ \t\t.clk_div = DT_INST_CLOCKS_CELL(inst, clock_divider),              \\ \t\tNUMAKER_CLKCTRL_DEV_INIT(inst)                                    \\ \t\t.irq_config_func = can_numaker_irq_config_func_##inst,            \\ \t\tNUMAKER_PINCTRL_INIT(inst)                                        \\ \t};                                                                        \\                                                                                   \\ \tstatic const struct can_mcan_config can_mcan_config_##inst =              \\ \t\tCAN_MCAN_DT_CONFIG_INST_GET(inst,                                 \\&can_numaker_config_##inst,                               \\&can_numaker_ops,\t\t                          \\&can_numaker_cbs_##inst);\t                          \\                                                                                   \\ \tstatic uint32_t can_numaker_data_##inst;                                  \\                                                                                   \\ \tstatic struct can_mcan_data can_mcan_data_##inst =                        \\ \t\tCAN_MCAN_DATA_INITIALIZER(&can_numaker_data_ ## inst);            \\                                                                                   \\ \tCAN_DEVICE_DT_INST_DEFINE(inst,                                           \\&can_numaker_init,                                                \\ \t\tNULL,                                                             \\&can_mcan_data_##inst,                                            \\&can_mcan_config_##inst,                                          \\ \t\tPOST_KERNEL,                                                      \\ \t\tCONFIG_CAN_INIT_PRIORITY,                                         \\&can_numaker_driver_api);                                         \\  DT_INST_FOREACH_STATUS_OKAY(CAN_NUMAKER_INIT);\nend_define\n\nend_unit\n\n    required: true\n\n  interrupts:\n    required: true\n\n  resets:\n    required: true\n\n  clocks:\n    required: true",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|NUMAKER_PINCTRL_DEFINE(inst);                                             \\ \tCAN_MCAN_DT_INST_CALLBACKS_DEFINE(inst, can_numaker_cbs_##inst);\t  \\ \t\t\t\t\t\t\t\t\t          \\ \tstatic void can_numaker_irq_config_func_##inst(const struct device *dev)  \\ \t{                                                                         \\ \t\tIRQ_CONNECT(DT_INST_IRQ_BY_IDX(inst, 0, irq),                     \\ \t\t\t\tDT_INST_IRQ_BY_IDX(inst, 0, priority),            \\ \t\t\t\tcan_mcan_line_0_isr,                              \\ \t\t\t\tDEVICE_DT_INST_GET(inst),                         \\ \t\t\t\t0);                                               \\ \t\tirq_enable(DT_INST_IRQ_BY_IDX(inst, 0, irq));                     \\ \t\tIRQ_CONNECT(DT_INST_IRQ_BY_IDX(inst, 1, irq),                     \\ \t\t\t\tDT_INST_IRQ_BY_IDX(inst, 1, priority),            \\ \t\t\t\tcan_mcan_line_1_isr,                              \\ \t\t\t\tDEVICE_DT_INST_GET(inst),                         \\ \t\t\t\t0);                                               \\ \t\tirq_enable(DT_INST_IRQ_BY_IDX(inst, 1, irq));                     \\ \t}                                                                         \\ \t\t\t\t\t\t\t\t\t\t  \\ \tstatic const struct can_numaker_config can_numaker_config_##inst = {      \\ \t\t.canfd_base = CAN_MCAN_DT_INST_MCAN_ADDR(inst),                   \\ \t\t.mrba = CAN_MCAN_DT_INST_MRBA(inst),\t\t\t          \\ \t\t.mram = CAN_MCAN_DT_INST_MRAM_ADDR(inst),\t\t\t  \\ \t\t.reset = RESET_DT_SPEC_INST_GET(inst),                            \\ \t\t.clk_modidx = DT_INST_CLOCKS_CELL(inst, clock_module_index),      \\ \t\t.clk_src = DT_INST_CLOCKS_CELL(inst, clock_source),               \\ \t\t.clk_div = DT_INST_CLOCKS_CELL(inst, clock_divider),              \\ \t\tNUMAKER_CLKCTRL_DEV_INIT(inst)                                    \\ \t\t.irq_config_func = can_numaker_irq_config_func_##inst,            \\ \t\tNUMAKER_PINCTRL_INIT(inst)                                        \\ \t};                                                                        \\                                                                                   \\ \tstatic const struct can_mcan_config can_mcan_config_##inst =              \\ \t\tCAN_MCAN_DT_CONFIG_INST_GET(inst,                                 \\&can_numaker_config_##inst,                               \\&can_numaker_ops,\t\t                          \\&can_numaker_cbs_##inst);\t                          \\                                                                                   \\ \tstatic uint32_t can_numaker_data_##inst;                                  \\                                                                                   \\ \tstatic struct can_mcan_data can_mcan_data_##inst =                        \\ \t\tCAN_MCAN_DATA_INITIALIZER(&can_numaker_data_ ## inst);            \\                                                                                   \\ \tCAN_DEVICE_DT_INST_DEFINE(inst,                                           \\&can_numaker_init,                                                \\ \t\tNULL,                                                             \\&can_mcan_data_##inst,                                            \\&can_mcan_config_##inst,                                          \\ \t\tPOST_KERNEL,                                                      \\ \t\tCONFIG_CAN_INIT_PRIORITY,                                         \\&can_numaker_driver_api);                                         \\  DT_INST_FOREACH_STATUS_OKAY(CAN_NUMAKER_INIT);\n+value|NUMAKER_PINCTRL_DEFINE(inst);                                             \\ \tCAN_MCAN_DT_INST_CALLBACKS_DEFINE(inst, can_numaker_cbs_##inst);\t  \\ \t\t\t\t\t\t\t\t\t          \\ \tstatic void can_numaker_irq_config_func_##inst(const struct device *dev)  \\ \t{                                                                         \\ \t\tIRQ_CONNECT(DT_INST_IRQ_BY_NAME(inst, int0, irq),                 \\ \t\t\t\tDT_INST_IRQ_BY_NAME(inst, int0, priority),        \\ \t\t\t\tcan_mcan_line_0_isr,                              \\ \t\t\t\tDEVICE_DT_INST_GET(inst),                         \\ \t\t\t\t0);                                               \\ \t\tirq_enable(DT_INST_IRQ_BY_NAME(inst, int0, irq));                 \\ \t\tIRQ_CONNECT(DT_INST_IRQ_BY_NAME(inst, int1, irq),                 \\ \t\t\t\tDT_INST_IRQ_BY_NAME(inst, int1, priority),        \\ \t\t\t\tcan_mcan_line_1_isr,                              \\ \t\t\t\tDEVICE_DT_INST_GET(inst),                         \\ \t\t\t\t0);                                               \\ \t\tirq_enable(DT_INST_IRQ_BY_NAME(inst, int1, irq));                 \\ \t}                                                                         \\ \t\t\t\t\t\t\t\t\t\t  \\ \tstatic const struct can_numaker_config can_numaker_config_##inst = {      \\ \t\t.canfd_base = CAN_MCAN_DT_INST_MCAN_ADDR(inst),                   \\ \t\t.mrba = CAN_MCAN_DT_INST_MRBA(inst),\t\t\t          \\ \t\t.mram = CAN_MCAN_DT_INST_MRAM_ADDR(inst),\t\t\t  \\ \t\t.reset = RESET_DT_SPEC_INST_GET(inst),                            \\ \t\t.clk_modidx = DT_INST_CLOCKS_CELL(inst, clock_module_index),      \\ \t\t.clk_src = DT_INST_CLOCKS_CELL(inst, clock_source),               \\ \t\t.clk_div = DT_INST_CLOCKS_CELL(inst, clock_divider),              \\ \t\tNUMAKER_CLKCTRL_DEV_INIT(inst)                                    \\ \t\t.irq_config_func = can_numaker_irq_config_func_##inst,            \\ \t\tNUMAKER_PINCTRL_INIT(inst)                                        \\ \t};                                                                        \\                                                                                   \\ \tstatic const struct can_mcan_config can_mcan_config_##inst =              \\ \t\tCAN_MCAN_DT_CONFIG_INST_GET(inst,                                 \\&can_numaker_config_##inst,                               \\&can_numaker_ops,\t\t                          \\&can_numaker_cbs_##inst);\t                          \\                                                                                   \\ \tstatic uint32_t can_numaker_data_##inst;                                  \\                                                                                   \\ \tstatic struct can_mcan_data can_mcan_data_##inst =                        \\ \t\tCAN_MCAN_DATA_INITIALIZER(&can_numaker_data_ ## inst);            \\                                                                                   \\ \tCAN_DEVICE_DT_INST_DEFINE(inst,                                           \\&can_numaker_init,                                                \\ \t\tNULL,                                                             \\&can_mcan_data_##inst,                                            \\&can_mcan_config_##inst,                                          \\ \t\tPOST_KERNEL,                                                      \\ \t\tCONFIG_CAN_INIT_PRIORITY,                                         \\&can_numaker_driver_api);                                         \\  DT_INST_FOREACH_STATUS_OKAY(CAN_NUMAKER_INIT);\n+  interrupt-names:\n+    required: true\n+\nThe issue was with: drivers: can: nuvoton: numaker: use named IRQs\n\nSwitch to using named IRQs as index-based access makes no guarantees about\ndevicetree interrupt order."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: can: nxp: mcan: use named IRQs\n\nSwitch to using named IRQs as index-based access makes no guarantees about\ndevicetree interrupt order. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|MCUX_MCAN_INIT\nparameter_list|(\nname|n\nparameter_list|)\ndefine|\\\nvalue|CAN_MCAN_DT_INST_BUILD_ASSERT_MRAM_CFG(n);\t\t\t\\ \tPINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic void mcux_mcan_irq_config_##n(const struct device *dev); \\ \t\t\t\t\t\t\t\t\t\\ \tCAN_MCAN_DT_INST_CALLBACKS_DEFINE(n, mcux_mcan_cbs_##n);\t\\ \tCAN_MCAN_DT_INST_MRAM_DEFINE(n, mcux_mcan_mram_##n);\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic const struct mcux_mcan_config mcux_mcan_config_##n = {\t\\ \t\t.base = CAN_MCAN_DT_INST_MCAN_ADDR(n),\t\t\t\\ \t\t.mram = (mem_addr_t)POINTER_TO_UINT(&mcux_mcan_mram_##n), \\ \t\t.clock_dev = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(n)),\t\\ \t\t.clock_subsys = (clock_control_subsys_t)\t\t\\ \t\t\tDT_INST_CLOCKS_CELL(n, name),\t\t\t\\ \t\t.irq_config_func = mcux_mcan_irq_config_##n,\t\t\\ \t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic const struct can_mcan_config can_mcan_config_##n =\t\\ \t\tCAN_MCAN_DT_CONFIG_INST_GET(n,&mcux_mcan_config_##n,\t\\&mcux_mcan_ops,\t\t\\&mcux_mcan_cbs_##n);\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic struct can_mcan_data can_mcan_data_##n =\t\t\t\\ \t\tCAN_MCAN_DATA_INITIALIZER(NULL);\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tCAN_DEVICE_DT_INST_DEFINE(n, mcux_mcan_init, NULL,\t\t\\&can_mcan_data_##n,\t\t\t\\&can_mcan_config_##n,\t\t\t\\ \t\t\t\t  POST_KERNEL,\t\t\t\t\\ \t\t\t\t  CONFIG_CAN_INIT_PRIORITY,\t\t\\&mcux_mcan_driver_api);\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic void mcux_mcan_irq_config_##n(const struct device *dev)\t\\ \t{\t\t\t\t\t\t\t\t\\ \t\tIRQ_CONNECT(DT_INST_IRQ_BY_IDX(n, 0, irq),\t\t\\ \t\t\t    DT_INST_IRQ_BY_IDX(n, 0, priority),\t\t\\ \t\t\t    can_mcan_line_0_isr,\t\t\t\\ \t\t\t    DEVICE_DT_INST_GET(n), 0);\t\t\t\\ \t\tirq_enable(DT_INST_IRQ_BY_IDX(n, 0, irq));\t\t\\ \t\t\t\t\t\t\t\t\t\\ \t\tIRQ_CONNECT(DT_INST_IRQ_BY_IDX(n, 1, irq),\t\t\\ \t\t\t    DT_INST_IRQ_BY_IDX(n, 1, priority),\t\t\\ \t\t\t    can_mcan_line_1_isr,\t\t\t\\ \t\t\t    DEVICE_DT_INST_GET(n), 0);\t\t\t\\ \t\tirq_enable(DT_INST_IRQ_BY_IDX(n, 1, irq));\t\t\\ \t}\nend_define\n\nbegin_macro\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(\n    required: true\n\n  interrupts:\n    required: true\n\n  clocks:\n    required: true",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|CAN_MCAN_DT_INST_BUILD_ASSERT_MRAM_CFG(n);\t\t\t\\ \tPINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic void mcux_mcan_irq_config_##n(const struct device *dev); \\ \t\t\t\t\t\t\t\t\t\\ \tCAN_MCAN_DT_INST_CALLBACKS_DEFINE(n, mcux_mcan_cbs_##n);\t\\ \tCAN_MCAN_DT_INST_MRAM_DEFINE(n, mcux_mcan_mram_##n);\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic const struct mcux_mcan_config mcux_mcan_config_##n = {\t\\ \t\t.base = CAN_MCAN_DT_INST_MCAN_ADDR(n),\t\t\t\\ \t\t.mram = (mem_addr_t)POINTER_TO_UINT(&mcux_mcan_mram_##n), \\ \t\t.clock_dev = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(n)),\t\\ \t\t.clock_subsys = (clock_control_subsys_t)\t\t\\ \t\t\tDT_INST_CLOCKS_CELL(n, name),\t\t\t\\ \t\t.irq_config_func = mcux_mcan_irq_config_##n,\t\t\\ \t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic const struct can_mcan_config can_mcan_config_##n =\t\\ \t\tCAN_MCAN_DT_CONFIG_INST_GET(n,&mcux_mcan_config_##n,\t\\&mcux_mcan_ops,\t\t\\&mcux_mcan_cbs_##n);\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic struct can_mcan_data can_mcan_data_##n =\t\t\t\\ \t\tCAN_MCAN_DATA_INITIALIZER(NULL);\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tCAN_DEVICE_DT_INST_DEFINE(n, mcux_mcan_init, NULL,\t\t\\&can_mcan_data_##n,\t\t\t\\&can_mcan_config_##n,\t\t\t\\ \t\t\t\t  POST_KERNEL,\t\t\t\t\\ \t\t\t\t  CONFIG_CAN_INIT_PRIORITY,\t\t\\&mcux_mcan_driver_api);\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic void mcux_mcan_irq_config_##n(const struct device *dev)\t\\ \t{\t\t\t\t\t\t\t\t\\ \t\tIRQ_CONNECT(DT_INST_IRQ_BY_IDX(n, 0, irq),\t\t\\ \t\t\t    DT_INST_IRQ_BY_IDX(n, 0, priority),\t\t\\ \t\t\t    can_mcan_line_0_isr,\t\t\t\\ \t\t\t    DEVICE_DT_INST_GET(n), 0);\t\t\t\\ \t\tirq_enable(DT_INST_IRQ_BY_IDX(n, 0, irq));\t\t\\ \t\t\t\t\t\t\t\t\t\\ \t\tIRQ_CONNECT(DT_INST_IRQ_BY_IDX(n, 1, irq),\t\t\\ \t\t\t    DT_INST_IRQ_BY_IDX(n, 1, priority),\t\t\\ \t\t\t    can_mcan_line_1_isr,\t\t\t\\ \t\t\t    DEVICE_DT_INST_GET(n), 0);\t\t\t\\ \t\tirq_enable(DT_INST_IRQ_BY_IDX(n, 1, irq));\t\t\\ \t}\n+value|CAN_MCAN_DT_INST_BUILD_ASSERT_MRAM_CFG(n);\t\t\t\\ \tPINCTRL_DT_INST_DEFINE(n);\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic void mcux_mcan_irq_config_##n(const struct device *dev); \\ \t\t\t\t\t\t\t\t\t\\ \tCAN_MCAN_DT_INST_CALLBACKS_DEFINE(n, mcux_mcan_cbs_##n);\t\\ \tCAN_MCAN_DT_INST_MRAM_DEFINE(n, mcux_mcan_mram_##n);\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic const struct mcux_mcan_config mcux_mcan_config_##n = {\t\\ \t\t.base = CAN_MCAN_DT_INST_MCAN_ADDR(n),\t\t\t\\ \t\t.mram = (mem_addr_t)POINTER_TO_UINT(&mcux_mcan_mram_##n), \\ \t\t.clock_dev = DEVICE_DT_GET(DT_INST_CLOCKS_CTLR(n)),\t\\ \t\t.clock_subsys = (clock_control_subsys_t)\t\t\\ \t\t\tDT_INST_CLOCKS_CELL(n, name),\t\t\t\\ \t\t.irq_config_func = mcux_mcan_irq_config_##n,\t\t\\ \t\t.pincfg = PINCTRL_DT_INST_DEV_CONFIG_GET(n),\t\t\\ \t};\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic const struct can_mcan_config can_mcan_config_##n =\t\\ \t\tCAN_MCAN_DT_CONFIG_INST_GET(n,&mcux_mcan_config_##n,\t\\&mcux_mcan_ops,\t\t\\&mcux_mcan_cbs_##n);\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic struct can_mcan_data can_mcan_data_##n =\t\t\t\\ \t\tCAN_MCAN_DATA_INITIALIZER(NULL);\t\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tCAN_DEVICE_DT_INST_DEFINE(n, mcux_mcan_init, NULL,\t\t\\&can_mcan_data_##n,\t\t\t\\&can_mcan_config_##n,\t\t\t\\ \t\t\t\t  POST_KERNEL,\t\t\t\t\\ \t\t\t\t  CONFIG_CAN_INIT_PRIORITY,\t\t\\&mcux_mcan_driver_api);\t\t\\ \t\t\t\t\t\t\t\t\t\\ \tstatic void mcux_mcan_irq_config_##n(const struct device *dev)\t\\ \t{\t\t\t\t\t\t\t\t\\ \t\tIRQ_CONNECT(DT_INST_IRQ_BY_NAME(n, int0, irq),\t\t\\ \t\t\t    DT_INST_IRQ_BY_NAME(n, int0, priority),\t\\ \t\t\t    can_mcan_line_0_isr,\t\t\t\\ \t\t\t    DEVICE_DT_INST_GET(n), 0);\t\t\t\\ \t\tirq_enable(DT_INST_IRQ_BY_NAME(n, int0, irq));\t\t\\ \t\t\t\t\t\t\t\t\t\\ \t\tIRQ_CONNECT(DT_INST_IRQ_BY_NAME(n, int1, irq),\t\t\\ \t\t\t    DT_INST_IRQ_BY_NAME(n, int1, priority),\t\\ \t\t\t    can_mcan_line_1_isr,\t\t\t\\ \t\t\t    DEVICE_DT_INST_GET(n), 0);\t\t\t\\ \t\tirq_enable(DT_INST_IRQ_BY_NAME(n, int1, irq));\t\t\\ \t}\n+  interrupt-names:\n+    required: true\n+\nThe issue was with: drivers: can: nxp: mcan: use named IRQs\n\nSwitch to using named IRQs as index-based access makes no guarantees about\ndevicetree interrupt order."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: usb_dc_rpi_pico: starting read on transfer EPs\n\nThis commit partially reverts a change which was introduced in the\nprevious commit 56bd8dfdce261863f8ca203143b309d26eacb229 [formerly 5b9a0e54569c8f128315de7c997f86d24ae178ee].\nusb_dc_ep_start_read() should also be called on transfer endpoints\nlike it has been before, otherwise the endpoint will not be armed\nafter it has been reconfigured. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\noperator|&&\nname|ep\noperator|!=\nname|USB_CONTROL_EP_OUT\noperator|&&\nname|ep_state\noperator|->\nname|cb\noperator|!=\nname|usb_transfer_ep_callback\ncondition|)\nblock|{\ncomment|/* Start reading now, except for transfer managed eps */\nreturn|return\nname|usb_dc_ep_start_read\nargument_list|(\nname|ep\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-operator|&&\n-name|ep_state\n-operator|->\n-name|cb\n-operator|!=\n-name|usb_transfer_ep_callback\n-comment|/* Start reading now, except for transfer managed eps */\nThe issue was with: drivers: usb_dc_rpi_pico: starting read on transfer EPs\n\nThis commit partially reverts a change which was introduced in the\nprevious commit 56bd8dfdce261863f8ca203143b309d26eacb229 [formerly 5b9a0e54569c8f128315de7c997f86d24ae178ee].\nusb_dc_ep_start_read() should also be called on transfer endpoints\nlike it has been before, otherwise the endpoint will not be armed\nafter it has been reconfigured."
},{
  "instruction": "There is an issue in the following code. It relates to samples: boards: nrfx: Use absolute pin numbers\n\nThis sample makes calls to the nrfx_gpiote driver functions that\nrequire absolute pin numbers, not relative to a given GPIO port,\nso instead of getting the numbers with the `DT_GPIO_PIN` macro,\nit should use `NRF_DT_GPIOS_TO_PSEL`. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_define\nDECL|macro|INPUT_PIN\ndefine|#\ndirective|define\nname|INPUT_PIN\nvalue|DT_GPIO_PIN(DT_ALIAS(sw0), gpios)\nend_define\n\nbegin_define\nDECL|macro|OUTPUT_PIN\ndefine|#\ndirective|define\nname|OUTPUT_PIN\nvalue|DT_GPIO_PIN(DT_ALIAS(led0), gpios)\nend_define\n\nbegin_define\nDECL|macro|GPIOTE_INST\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-value|DT_GPIO_PIN(DT_ALIAS(sw0), gpios)\n+value|NRF_DT_GPIOS_TO_PSEL(DT_ALIAS(sw0), gpios)\n-value|DT_GPIO_PIN(DT_ALIAS(led0), gpios)\n+value|NRF_DT_GPIOS_TO_PSEL(DT_ALIAS(led0), gpios)\nThe issue was with: samples: boards: nrfx: Use absolute pin numbers\n\nThis sample makes calls to the nrfx_gpiote driver functions that\nrequire absolute pin numbers, not relative to a given GPIO port,\nso instead of getting the numbers with the `DT_GPIO_PIN` macro,\nit should use `NRF_DT_GPIOS_TO_PSEL`."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: nrf_qspi_nor: Deactivate QSPI peripheral after initialization\n\nThis is a follow-up to commit 5e4c0a28975275db0a5b47c759494fd21436476d [formerly ea1be7f242b9348863a27adb17215014f15b318a].\n\nAfter the driver performs its initialization, it needs to deactivate\nthe QSPI peripheral. Otherwise, the peripheral would unnecessarily\nconsume power until some QSPI operation is performed (and only then\nit will get deactivated), what depending on the application may take\na significant amount of time. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nname|qspi_clock_div_restore\nargument_list|()\nexpr_stmt|;\nifdef|#\ndirective|ifdef\nname|CONFIG_PM_DEVICE_RUNTIME\nname|int\nname|rc2",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+operator|!\n+name|IS_ENABLED\n+argument_list|(\n+name|CONFIG_NORDIC_QSPI_NOR_XIP\n+argument_list|)\n+operator|&&\n+name|nrfx_qspi_init_check\n+argument_list|()\n+condition|)\n+block|{\n+operator|(\n+name|void\n+operator|)\n+name|nrfx_qspi_deactivate\n+argument_list|()\n+expr_stmt|;\n+block|}\nThe issue was with: drivers: nrf_qspi_nor: Deactivate QSPI peripheral after initialization\n\nThis is a follow-up to commit 5e4c0a28975275db0a5b47c759494fd21436476d [formerly ea1be7f242b9348863a27adb17215014f15b318a].\n\nAfter the driver performs its initialization, it needs to deactivate\nthe QSPI peripheral. Otherwise, the peripheral would unnecessarily\nconsume power until some QSPI operation is performed (and only then\nit will get deactivated), what depending on the application may take\na significant amount of time."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: i2c: i2c_mcux_lpi2c: fix base address declarations\n\nWith commit b143386e577 [formerly 734adf52c60], the MCUX LPI2C config structure no longer\ncontains a direct base address pointer. The base address must be\naccessed via DEVICE_MMIO_NAMED_GET. Some declarations in the LPCI2C\ntarget mode handler still used the old method of accessing the base\naddress, causing a build failure. Fix these accesses to use the local\ndeclaration of the \\\"base\\\" variable. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|i2c_data\noperator|=\noperator|(\nname|uint8_t\noperator|)\nname|config\noperator|->\nname|base\noperator|->\nname|SRDR\nexpr_stmt|;\nif|if\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\ncomment|/* Send I2C data */\nname|config\noperator|->\nname|base\noperator|->\nname|STDR\noperator|=\nname|i2c_data\nexpr_stmt|;\nblock|}\nelse|else\nblock|{\ncomment|/* Send I2C data */\nname|config\noperator|->\nname|base\noperator|->\nname|STDR\noperator|=\nname|i2c_data",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|config\n-operator|->\n-name|config\n-operator|->\n-name|config\n-operator|->\nThe issue was with: drivers: i2c: i2c_mcux_lpi2c: fix base address declarations\n\nWith commit b143386e577 [formerly 734adf52c60], the MCUX LPI2C config structure no longer\ncontains a direct base address pointer. The base address must be\naccessed via DEVICE_MMIO_NAMED_GET. Some declarations in the LPCI2C\ntarget mode handler still used the old method of accessing the base\naddress, causing a build failure. Fix these accesses to use the local\ndeclaration of the \\\"base\\\" variable."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: mdio: nxp_enet: Fix \\\"expected statement\\\" clangsa error\n\nclangsa reports the error\n\nmdio_nxp_enet.c:245:10: error: label at end of compound statement:\nexpected statement Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|=\nname|true\nexpr_stmt|;\nbreak|break;\ndefault|default:\nblock|}\nblock|}\nend_function\n\nbegin_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+break|break;\nThe issue was with: drivers: mdio: nxp_enet: Fix \\\"expected statement\\\" clangsa error\n\nclangsa reports the error\n\nmdio_nxp_enet.c:245:10: error: label at end of compound statement:\nexpected statement"
},{
  "instruction": "There is an issue in the following code. It relates to net: tcp: Reschedule FIN timer when entering FIN state\n\nThe FIN timer was not set when we entered the FIN_WAIT_1 state.\nThis could cause issues if we did not receive proper packets\nfrom peer. With this fix, the connection is always terminated\neven if peer does not respond. Please fix this issue.",
  "input": "Faulty tokenized code:\nparameter_list|,\nname|uint16_t\nname|dport\nparameter_list|)\nblock|{\nDECL|struct|__anon294a619a0108\nstruct|struct\nblock|{\nDECL|member|key\nname|uint8_t\nname|key\nparameter_list|,\nname|uint16_t\nname|dport\nparameter_list|)\nblock|{\nDECL|struct|__anon294a619a0208\nstruct|struct\nblock|{\nDECL|member|key\nname|uint8_t\nname|key\nexpr_stmt|;\nname|next\noperator|=\nname|TCP_FIN_WAIT_1\nexpr_stmt|;\nname|tcp_out\nargument_list|(\nname|conn\nargument_list|,\nname|FIN",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon294a619a0108\n+DECL|struct|__anon29c694330108\n-DECL|struct|__anon294a619a0208\n+DECL|struct|__anon29c694330208\n+name|k_work_reschedule_for_queue\n+argument_list|(\n+operator|&\n+name|tcp_work_q\n+argument_list|,\n+operator|&\n+name|conn\n+operator|->\n+name|fin_timer\n+argument_list|,\n+name|FIN_TIMEOUT\n+argument_list|)\n+expr_stmt|;\nThe issue was with: net: tcp: Reschedule FIN timer when entering FIN state\n\nThe FIN timer was not set when we entered the FIN_WAIT_1 state.\nThis could cause issues if we did not receive proper packets\nfrom peer. With this fix, the connection is always terminated\neven if peer does not respond."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: qspi: added operation timeout\n\nAdded Kconfig assignment of qspi timeout.\nPer nrfx v3.2 addition of qspi timeout in config\nstruct. Please fix this issue.",
  "input": "Faulty tokenized code:\n\t  stored in QSPI XIP region. Note that for this functionality to work,\n\t  the QSPI NOR init priority must be set so that no XIP code in the\n\t  QSPI NOR flash chip is executed until the driver has been setup.\n\t  This will also disable power management for the QSPI NOR flash chip.\n\nendif # NORDIC_QSPI_NOR\noperator|=\nname|INST_0_SPI_MODE\nblock|, \t}\nblock|,\noperator|.\nname|size\noperator|=\nname|INST_0_BYTES\nblock|,\noperator|.",
  "result": "I corrected the issue in the code by changing the following tokens:\n+config NORDIC_QSPI_NOR_TIMEOUT_MS\n+\tint \"Timeout for QSPI operations (ms)\"\n+\tdefault 500\n+\thelp\n+\t  The QSPI peripheral operation timeout in milliseconds.\n+\t  Primarily intended for long running operations such as\n+\t  a flash sector erase. The 500 ms default allows for\n+\t  most typical NOR flash chips to erase a sector.\n+\n+name|nrfx_cfg\n+operator|.\n+name|timeout\n+operator|=\n+name|CONFIG_NORDIC_QSPI_NOR_TIMEOUT_MS\n+block|,\n+operator|.\nThe issue was with: drivers: qspi: added operation timeout\n\nAdded Kconfig assignment of qspi timeout.\nPer nrfx v3.2 addition of qspi timeout in config\nstruct."
},{
  "instruction": "There is an issue in the following code. It relates to arch: arc rename arc_smp.c -> smp.c\n\nWe know this is SMP for arc, no need for the arc_ prefix. Please fix this issue.",
  "input": "Faulty tokenized code:\n\nzephyr_library_sources_ifdef(CONFIG_IRQ_OFFLOAD irq_offload.c)\n\nzephyr_library_sources_ifdef(CONFIG_USERSPACE userspace.S)\nzephyr_library_sources_ifdef(CONFIG_ARC_CONNECT arc_connect.c)\nzephyr_library_sources_ifdef(CONFIG_ARC_CONNECT arc_smp.c)\n\nzephyr_library_sources_ifdef(CONFIG_THREAD_LOCAL_STORAGE tls.c)\n\nadd_subdirectory_ifdef(CONFIG_ARC_CORE_MPU mpu)\nadd_subdirectory_ifdef(CONFIG_ARC_SECURE_FIRMWARE secureshield)\nsimilarity index 100%\nrename from arch/arc/core/arc_smp.c\nrename to arch/arc/core/smp.c",
  "result": "I corrected the issue in the code by changing the following tokens:\n-zephyr_library_sources_ifdef(CONFIG_ARC_CONNECT arc_smp.c)\n+zephyr_library_sources_ifdef(CONFIG_ARC_CONNECT smp.c)\nThe issue was with: arch: arc rename arc_smp.c -> smp.c\n\nWe know this is SMP for arc, no need for the arc_ prefix."
},{
  "instruction": "There is an issue in the following code. It relates to arch: ipi_handler -> sched_ipi_handler\n\nunifiy naming for ipi handler call and use the same signature\neverywhere. Please fix this issue.",
  "input": "Faulty tokenized code:\ndirective|include\nfile|<zephyr/drivers/pm_cpu_ops.h>\nend_include\n\nbegin_struct\nDECL|struct|__anon29abe8020108\nspecifier|volatile\nstruct|struct\nblock|{\nDECL|member|fn\nname|arch_cpustart_t\nendif|#\ndirective|endif\nend_endif\n\nbegin_function\nDECL|function|ipi_handler (const void * unused)\nspecifier|static\nname|void\nname|ipi_handler\nparameter_list|(\nspecifier|const\nname|void\nmodifier|*\nname|unused\nargument_list|(\nname|RISCV_MACHINE_SOFT_IRQ\nargument_list|,\nliteral|0\nargument_list|,\nname|ipi_handler\nargument_list|,\nname|NULL\nargument_list|,\nliteral|0\nargument_list|)",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon29abe8020108\n+DECL|struct|__anon2999b7080108\n-DECL|function|ipi_handler (const void * unused)\n+DECL|function|sched_ipi_handler (const void * unused)\n-name|ipi_handler\n+name|sched_ipi_handler\n-name|ipi_handler\n+name|sched_ipi_handler\nThe issue was with: arch: ipi_handler -> sched_ipi_handler\n\nunifiy naming for ipi handler call and use the same signature\neverywhere."
},{
  "instruction": "There is an issue in the following code. It relates to soc: riscv: virt: reorganize SoC folder\n\nMove out of riscv-privileged, and convert to single SoC (no\nfamily/series). Please fix this issue.",
  "input": "Faulty tokenized code:\n# SPDX-License-Identifier: Apache-2.0\n\nCONFIG_SOC_SERIES_RISCV_VIRT=y\nCONFIG_SOC_RISCV_VIRT=y\nCONFIG_BOARD_QEMU_RISCV32=y\nCONFIG_CONSOLE=y\nCONFIG_SERIAL=y\nCONFIG_UART_CONSOLE=y\n# SPDX-License-Identifier: Apache-2.0\n\nCONFIG_SOC_SERIES_RISCV_VIRT=y\nCONFIG_SOC_RISCV_VIRT=y\nCONFIG_BOARD_QEMU_RISCV32_SMP=y\nCONFIG_CONSOLE=y\nCONFIG_SERIAL=y\nCONFIG_UART_CONSOLE=y\n# SPDX-License-Identifier: Apache-2.0\n\nCONFIG_SOC_SERIES_RISCV_VIRT=y\nCONFIG_SOC_RISCV_VIRT=y\nCONFIG_BOARD_QEMU_RISCV32E=y\nCONFIG_CONSOLE=y\nCONFIG_SERIAL=y\nCONFIG_UART_CONSOLE=y\n# SPDX-License-Identifier: Apache-2.0\n\nCONFIG_SOC_SERIES_RISCV_VIRT=y\nCONFIG_SOC_RISCV_VIRT=y\nCONFIG_BOARD_QEMU_RISCV64=y\nCONFIG_PRIVILEGED_STACK_SIZE=2048\nCONFIG_CONSOLE=y\nCONFIG_SERIAL=y\n# SPDX-License-Identifier: Apache-2.0\n\nCONFIG_SOC_SERIES_RISCV_VIRT=y\nCONFIG_SOC_RISCV_VIRT=y\nCONFIG_BOARD_QEMU_RISCV64_SMP=y\nCONFIG_PRIVILEGED_STACK_SIZE=2048\nCONFIG_CONSOLE=y\nCONFIG_SERIAL=y\ndeleted file mode 100644\n# Copyright (c) 2020 Cobham Gaisler AB\n# SPDX-License-Identifier: Apache-2.0\n\nconfig SOC_SERIES_RISCV_VIRT\n\tbool \"QEMU RISC-V VirtIO Board\"\n\tselect RISCV\n\tselect RISCV_PRIVILEGED\nsimilarity index 100%\nrename from soc/riscv/riscv-privileged/virt/CMakeLists.txt\nrename to soc/riscv/virt/CMakeLists.txt\nsimilarity index 91%\nrename from soc/riscv/riscv-privileged/virt/Kconfig.defconfig.series\nrename to soc/riscv/virt/Kconfig.defconfig\n# Copyright (c) 2020 Cobham Gaisler AB\n# SPDX-License-Identifier: Apache-2.0\n\nif SOC_SERIES_RISCV_VIRT\n\nconfig SOC_SERIES\n\tdefault \"virt\"\n\nconfig SYS_CLOCK_HW_CYCLES_PER_SEC\n\tdefault 10000000\n\nsimilarity index 75%\nrename from soc/riscv/riscv-privileged/virt/Kconfig.soc\nrename to soc/riscv/virt/Kconfig.soc\n# Copyright (c) 2020 Cobham Gaisler AB\n# SPDX-License-Identifier: Apache-2.0\n\nchoice\n\tprompt \"QEMU RISC-V VirtIO Board\"\n\tdepends on SOC_SERIES_RISCV_VIRT\n\nconfig SOC_RISCV_VIRT\n\tbool \"QEMU RISC-V VirtIO Board\"\n\tselect ATOMIC_OPERATIONS_BUILTIN\n\tselect INCLUDE_RESET_VECTOR\n\tselect RISCV_ISA_EXT_M\n\tselect RISCV_ISA_EXT_A\n\tselect RISCV_ISA_EXT_C\n\nendchoice\nsimilarity index 100%\nrename from soc/riscv/riscv-privileged/virt/soc.c\nrename to soc/riscv/virt/soc.c\nsimilarity index 100%\nrename from soc/riscv/riscv-privileged/virt/soc.h\nrename to soc/riscv/virt/soc.h",
  "result": "I corrected the issue in the code by changing the following tokens:\n-CONFIG_SOC_SERIES_RISCV_VIRT=y\n-CONFIG_SOC_SERIES_RISCV_VIRT=y\n-CONFIG_SOC_SERIES_RISCV_VIRT=y\n-CONFIG_SOC_SERIES_RISCV_VIRT=y\n-CONFIG_SOC_SERIES_RISCV_VIRT=y\n-# Copyright (c) 2020 Cobham Gaisler AB\n-# SPDX-License-Identifier: Apache-2.0\n-\n-config SOC_SERIES_RISCV_VIRT\n-\tbool \"QEMU RISC-V VirtIO Board\"\n-\tselect RISCV\n-\tselect RISCV_PRIVILEGED\n-if SOC_SERIES_RISCV_VIRT\n+if SOC_RISCV_VIRT\n-config SOC_SERIES\n+config SOC\n-choice\n-\tprompt \"QEMU RISC-V VirtIO Board\"\n-\tdepends on SOC_SERIES_RISCV_VIRT\n-\n-\n-endchoice\n+\tselect RISCV\n+\tselect RISCV_PRIVILEGED\n+\tselect RISCV_PRIVILEGED_STANDALONE\nThe issue was with: soc: riscv: virt: reorganize SoC folder\n\nMove out of riscv-privileged, and convert to single SoC (no\nfamily/series)."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: i2c: i2c_dw: Fixed integer overflow in i2c_dw_data_ask().\n\nThe controller can implement a reception FIFO as deep as 256 bytes.\nHowever, the computation made by the driver code to determine how many\nbytes can be asked is stored in a signed 8-bit variable called rx_empty.\n\nIf the reception FIFO depth is greater or equal to 128 bytes and the FIFO\nis currently empty, the rx_empty value will be 128 (or more), which\nstands for a negative value as the variable is signed.\n\nThus, the later code checking if the FIFO is full will run while it should\nnot and exit from the i2c_dw_data_ask() function too early.\n\nThis hangs the controller in an infinite loop of interrupt storm because\nthe interrupt flags are never cleared.\n\nStoring the rx_empty empty on a signed 32-bit variable instead of a 8-bit\none solves the issue and is compliant with the controller hardware\nspecifications of a maximum FIFO depth of 256 bytes.\n\nIt has been agreed with upstream maintainers to change the type of the\nvariables tx_empty, rx_empty, cnt, rx_buffer_depth and tx_buffer_depth to\nplain int because it is most effectively handled by the CPUs. Using 8-bit\nor 16-bit variables had no meaning here. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|data\ndecl_stmt|;\nname|uint32_t\nname|data\ndecl_stmt|;\nname|uint8_t\nname|tx_empty\ndecl_stmt|;\nname|int8_t\nname|rx_empty\ndecl_stmt|;\nname|uint8_t\nname|cnt\ndecl_stmt|;\nname|uint8_t\nname|rx_buffer_depth\ndecl_stmt|,\nname|tx_buffer_depth\ndecl_stmt|;\nname|union",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|uint8_t\n+name|int\n-name|int8_t\n+name|int\n-name|uint8_t\n+name|int\n-name|uint8_t\n+name|int\nThe issue was with: drivers: i2c: i2c_dw: Fixed integer overflow in i2c_dw_data_ask().\n\nThe controller can implement a reception FIFO as deep as 256 bytes.\nHowever, the computation made by the driver code to determine how many\nbytes can be asked is stored in a signed 8-bit variable called rx_empty.\n\nIf the reception FIFO depth is greater or equal to 128 bytes and the FIFO\nis currently empty, the rx_empty value will be 128 (or more), which\nstands for a negative value as the variable is signed.\n\nThus, the later code checking if the FIFO is full will run while it should\nnot and exit from the i2c_dw_data_ask() function too early.\n\nThis hangs the controller in an infinite loop of interrupt storm because\nthe interrupt flags are never cleared.\n\nStoring the rx_empty empty on a signed 32-bit variable instead of a 8-bit\none solves the issue and is compliant with the controller hardware\nspecifications of a maximum FIFO depth of 256 bytes.\n\nIt has been agreed with upstream maintainers to change the type of the\nvariables tx_empty, rx_empty, cnt, rx_buffer_depth and tx_buffer_depth to\nplain int because it is most effectively handled by the CPUs. Using 8-bit\nor 16-bit variables had no meaning here."
},{
  "instruction": "There is an issue in the following code. It relates to x86: ia32/gdbstub: remove dead code\n\nThere is logically dead code which will never run. So remove.\n\nFixes #66848 Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|>=\nname|GDB_STUB_NUM_REGISTERS\ncondition|)\nblock|{\ncomment|/* Return hex string \"xx\" to tell GDB that this register \t\t * is not available. So GDB will continue probing other \t\t * registers instead of stopping in the middle of \t\t * \"info registers all\". \t\t */\nif|if\ncondition|(\nname|buflen\noperator|>=\nliteral|2\ncondition|)\nblock|{\nname|memcpy\nargument_list|(\nname|buf\nargument_list|,\nliteral|\"xx\"\nblock|}\nelse|else\nblock|{\nname|ret\noperator|=\nliteral|0\nexpr_stmt|;\nblock|}\nblock|}\nelse|else\nblock|{\nname|ret\noperator|=\nname|bin2hex\nargument_list|(\noperator|(\nspecifier|const\nname|uint8_t",
  "result": "I corrected the issue in the code by changing the following tokens:\n-if|if\n-condition|(\n-name|buflen\n-operator|>=\n-literal|2\n-condition|)\n-block|{\n-literal|0\n-expr_stmt|;\n-block|}\n-block|}\n-else|else\n-block|{\n-name|ret\n-operator|=\nThe issue was with: x86: ia32/gdbstub: remove dead code\n\nThere is logically dead code which will never run. So remove.\n\nFixes #66848"
},{
  "instruction": "There is an issue in the following code. It relates to icm42688: Capture the spi return value\n\nHandle the return value of the spi transaction.\n\nFixes #58582 Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|data_ready_trigger\noperator|=\nname|trig\nexpr_stmt|;\nname|icm42688_spi_read\nargument_list|(\noperator|&\nname|cfg\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|res\n+operator|=\nThe issue was with: icm42688: Capture the spi return value\n\nHandle the return value of the spi transaction.\n\nFixes #58582"
},{
  "instruction": "There is an issue in the following code. It relates to icm42688: Remove unnecessary locks\n\nThe entire switch statement is already wrapped in a lock which is\nacquired just before configuring the gpio pin. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|data_ready_trigger\noperator|=\nname|trig\nexpr_stmt|;\nname|icm42688_lock\nargument_list|(\nname|dev\nargument_list|)\nexpr_stmt|;\nname|icm42688_spi_read\nargument_list|(\noperator|&\nname|cfg\noperator|->\nname|status\nargument_list|,\nliteral|1\nargument_list|)\nexpr_stmt|;\nname|icm42688_unlock\nargument_list|(\nname|dev\nargument_list|)\nexpr_stmt|;\nbreak|break;\ndefault|default:\nname|res\noperator|=\noperator|-",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|icm42688_lock\n-argument_list|(\n-name|dev\n-argument_list|)\n-expr_stmt|;\n-name|icm42688_unlock\n-argument_list|(\n-name|dev\n-argument_list|)\n-expr_stmt|;\nThe issue was with: icm42688: Remove unnecessary locks\n\nThe entire switch statement is already wrapped in a lock which is\nacquired just before configuring the gpio pin."
},{
  "instruction": "There is an issue in the following code. It relates to tests: counter: counter_basic_api: Add support for ambiq_counter device\n\nUpdate counter test to test ambiq_counter devices Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nargument|raspberrypi_pico_timer\nargument_list|)\nendif|#\ndirective|endif\nblock|}\ndecl_stmt|;\nend_decl_stmt\n\nbegin_decl_stmt",
  "result": "I corrected the issue in the code by changing the following tokens:\n+ifdef|#\n+directive|ifdef\n+name|CONFIG_COUNTER_AMBIQ\n+name|DEVS_FOR_DT_COMPAT\n+argument_list|(\n+argument|ambiq_counter\n+argument_list|)\n+endif|#\n+directive|endif\nThe issue was with: tests: counter: counter_basic_api: Add support for ambiq_counter device\n\nUpdate counter test to test ambiq_counter devices"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: intc: plic: fix compilation warning\n\nChange the index variable type to `int` from `size_t` to compile\nacross 32bit and 64bit platforms without generating warnings. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|\"==================\"\nargument_list|)\nexpr_stmt|;\nfor|for\ncontrol|(\nname|size_t\nname|i\ninit|=\nliteral|0\ninit|;\nname|i",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|size_t\n+name|int\nThe issue was with: drivers: intc: plic: fix compilation warning\n\nChange the index variable type to `int` from `size_t` to compile\nacross 32bit and 64bit platforms without generating warnings."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: gpio: stm32: fix init power state\n\nSet suspended as initial power state, only when the\nCONFIG_PM_DEVICE_RUNTIME config is enabled.\n\nThe initial state was incorrect, when CONFIG_PM_DEVICE=y and\nCONFIG_PM_DEVICE_RUNTIME=n. In that case, the power state was SUSPENDED,\nbut the device was actually enabled. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nreturn|return\nname|ret\nreturn|;\nblock|}\nname|pm_device_init_suspended\nargument_list|(\nname|dev\nargument_list|)\nexpr_stmt|;\noperator|(\nname|void\noperator|)\nname|pm_device_runtime_enable\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|IS_ENABLED\n+argument_list|(\n+name|CONFIG_PM_DEVICE_RUNTIME\n+argument_list|)\n+condition|)\n+block|{\n+block|}\nThe issue was with: drivers: gpio: stm32: fix init power state\n\nSet suspended as initial power state, only when the\nCONFIG_PM_DEVICE_RUNTIME config is enabled.\n\nThe initial state was incorrect, when CONFIG_PM_DEVICE=y and\nCONFIG_PM_DEVICE_RUNTIME=n. In that case, the power state was SUSPENDED,\nbut the device was actually enabled."
},{
  "instruction": "There is an issue in the following code. It relates to boards: arm: nrf5340_audio_dk_cpunet_reset: switch to HAL\n\nChange the GPIOTE driver to HAL to prevent instantiation\nissues with a multi-instance GPIOTE driver. Please fix this issue.",
  "input": "Faulty tokenized code:\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<nrfx_gpiote.h>\nend_include\n\nbegin_expr_stmt\nname|LOG_MODULE_REGISTER\nargument_list|(\nname|nrf_gpiote_latency_t\nname|latency\ndecl_stmt|;\nname|latency\noperator|=\nname|nrfx_gpiote_latency_get\nargument_list|()\nexpr_stmt|;\nif|if\ncondition|(\nname|latency\noperator|!=\nname|LOG_DBG\nargument_list|(\nliteral|\"Setting gpiote latency to low power\"\nargument_list|)\nexpr_stmt|;\nname|nrfx_gpiote_latency_set\nargument_list|(\nname|NRF_GPIOTE_LATENCY_LOWPOWER\nargument_list|)\nexpr_stmt|;\nblock|}\nreturn|return",
  "result": "I corrected the issue in the code by changing the following tokens:\n-file|<nrfx_gpiote.h>\n+file|<hal/nrf_gpiote.h>\n-name|nrfx_gpiote_latency_get\n-argument_list|()\n+name|nrf_gpiote_latency_get\n+argument_list|(\n+name|NRF_GPIOTE\n+argument_list|)\n-name|nrfx_gpiote_latency_set\n+name|nrf_gpiote_latency_set\n+name|NRF_GPIOTE\n+argument_list|,\nThe issue was with: boards: arm: nrf5340_audio_dk_cpunet_reset: switch to HAL\n\nChange the GPIOTE driver to HAL to prevent instantiation\nissues with a multi-instance GPIOTE driver."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: usb: stm32U5 usb device controller\n\nLike the stm32H5, stm32u5 usb device has an independent\npower supply, but control bit is PWR_SVMCR_USV.\nThe control bit for the stm32H5 is PWR_USBSCR_USB33SV (no change) Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|return\noperator|-\nname|ENODEV\nreturn|;\nblock|}\nifdef|#\ndirective|ifdef\nname|PWR_USBSCR_USB33SV\ncomment|/* \t * VDDUSB independent USB supply (PWR clock is on) \t * with LL_PWR_EnableVDDUSB function (higher case) \t */\nname|LL_PWR_EnableVDDUSB\nargument_list|()\nexpr_stmt|;\nendif|#\ndirective|endif\ncomment|/* PWR_USBSCR_USB33SV */\nif|if\ncondition|(\nname|DT_INST_NUM_CLOCKS\nargument_list|(\nliteral|0\ndirective|if\nname|defined\nargument_list|(\nname|PWR_USBSCR_USB33SV\nargument_list|)\ncomment|/* \t * VDDUSB independent USB supply (PWR clock is on) \t * with LL_PWR_EnableVDDUSB function (higher case) \t */\nname|LL_PWR_EnableVDDUSB\nargument_list|()\nexpr_stmt|;\nendif|#\ndirective|endif\ncomment|/* PWR_USBSCR_USB33SV */\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|CONFIG_SOC_SERIES_STM32H7X",
  "result": "I corrected the issue in the code by changing the following tokens:\n-ifdef|#\n-directive|ifdef\n+if|#\n+directive|if\n+name|defined\n+argument_list|(\n+argument_list|)\n+operator|||\n+name|defined\n+argument_list|(\n+name|PWR_SVMCR_USV\n+argument_list|)\n-comment|/* PWR_USBSCR_USB33SV */\n+comment|/* PWR_USBSCR_USB33SV or PWR_SVMCR_USV */\n+operator|||\n+name|defined\n+argument_list|(\n+name|PWR_SVMCR_USV\n+argument_list|)\n-comment|/* PWR_USBSCR_USB33SV */\n+comment|/* PWR_USBSCR_USB33SV or PWR_SVMCR_USV */\nThe issue was with: drivers: usb: stm32U5 usb device controller\n\nLike the stm32H5, stm32u5 usb device has an independent\npower supply, but control bit is PWR_SVMCR_USV.\nThe control bit for the stm32H5 is PWR_USBSCR_USB33SV (no change)"
},{
  "instruction": "There is an issue in the following code. It relates to samples: ipc: multi_endpoint: Fix synchronisation of data receiving\n\nThe incorrect semaphore was used for the ipc1 instance to synchronise\nthe data receiving.\nThis commit fixes it. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|)\nexpr_stmt|;\nname|k_sem_give\nargument_list|(\noperator|&\nname|ipc0B_data_sem\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n\noperator|)\nexpr_stmt|;\nname|k_sem_give\nargument_list|(\noperator|&\nname|ipc0B_data_sem\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|ipc0B_data_sem\n+name|ipc1_data_sem\n-name|ipc0B_data_sem\n+name|ipc1_data_sem\nThe issue was with: samples: ipc: multi_endpoint: Fix synchronisation of data receiving\n\nThe incorrect semaphore was used for the ipc1 instance to synchronise\nthe data receiving.\nThis commit fixes it."
},{
  "instruction": "There is an issue in the following code. It relates to driver: display: sdl: Fix input together with SDL_DISPLAY_ZOOM_PCT\n\nUsing SDL_DISPLAY_ZOOM_PCT would cause mouse pointer/touch input\nto not click at the correct position. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|return\noperator|-\nliteral|1\nreturn|;\nblock|}\noperator|*\nname|texture\noperator|=\nname|SDL_CreateTexture\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|SDL_RenderSetLogicalSize\n+argument_list|(\n+operator|*\n+name|renderer\n+argument_list|,\n+name|width\n+argument_list|,\n+name|height\n+argument_list|)\n+expr_stmt|;\nThe issue was with: driver: display: sdl: Fix input together with SDL_DISPLAY_ZOOM_PCT\n\nUsing SDL_DISPLAY_ZOOM_PCT would cause mouse pointer/touch input\nto not click at the correct position."
},{
  "instruction": "There is an issue in the following code. It relates to intel_adsp: ipc: pm action in busy state\n\nCurrently SOF has disabled CONFIG_PM_DEVICE_RUNTIME_EXCLUSIVE option and\nuse pm_suspend_devices() to suspend and resume IPC device during D3\npower flow. The pm_suspend_devices() function skips suspending devices\nthat are busy. In very rare cases, the IPC device is busy during the\npower state transition, which results in the device not being restored\nduring reboot. This happens when FW sends a message to the HOST and\nwaits for ACK, and the HOST simultaneously sends a SET_DX message to the\nDSP. This suspend/resume logic in IPC driver does not work well when the\nsystem enters the D3 state because it is not a suspend state, but rather\na power-off. IPC does not require suspending, only reinitialization when\nexiting D3. We cannot avoid this one missing ACK and it cannot block the\nDSP from turning off.\n\nWhen FW receives a SET_DX message it checks whether it can enter the D3\nstate and then returns an error (via IPC) or calls the pm_state_force\nfunction. Success response is sent directly from power_down assembly and\nnot via ipc driver. This is because after receiving the response, the\nHOST will turn off the DSP.\n\nIn order for the transition to D3 to take place, only the primary core\ncan be active, all pipes must be stopped (and therefore all modules in\nFW). The only active thread at this time is the Idle thread. Driver on\nthe host will not send another ipc because is still waiting for\nresponse. FW can try to send only two notification:\n\n- FW exception: from this place there is no return to continue the power\n  transition,\n- log buffer status: skipped, they remain in the queue without being\n  sent.\n\nI'm moving pm_device_busy_clear(dev) from IRQ handler to\nintel_adsp_ipc_send_message function so the pending ACK does not block\npower transition. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|ida\noperator|=\nname|INTEL_ADSP_IPC_DONE\nexpr_stmt|;\nname|pm_device_busy_clear\nargument_list|(\nname|dev\nargument_list|)\nexpr_stmt|;\nblock|}\nname|k_spin_unlock\nargument_list|(\noperator|&\nname|devdata\nname|lock\nargument_list|,\nname|key\nargument_list|)\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|pm_device_busy_clear\n-argument_list|(\n-name|dev\n-argument_list|)\n-expr_stmt|;\n+name|pm_device_busy_clear\n+argument_list|(\n+name|dev\n+argument_list|)\n+expr_stmt|;\nThe issue was with: intel_adsp: ipc: pm action in busy state\n\nCurrently SOF has disabled CONFIG_PM_DEVICE_RUNTIME_EXCLUSIVE option and\nuse pm_suspend_devices() to suspend and resume IPC device during D3\npower flow. The pm_suspend_devices() function skips suspending devices\nthat are busy. In very rare cases, the IPC device is busy during the\npower state transition, which results in the device not being restored\nduring reboot. This happens when FW sends a message to the HOST and\nwaits for ACK, and the HOST simultaneously sends a SET_DX message to the\nDSP. This suspend/resume logic in IPC driver does not work well when the\nsystem enters the D3 state because it is not a suspend state, but rather\na power-off. IPC does not require suspending, only reinitialization when\nexiting D3. We cannot avoid this one missing ACK and it cannot block the\nDSP from turning off.\n\nWhen FW receives a SET_DX message it checks whether it can enter the D3\nstate and then returns an error (via IPC) or calls the pm_state_force\nfunction. Success response is sent directly from power_down assembly and\nnot via ipc driver. This is because after receiving the response, the\nHOST will turn off the DSP.\n\nIn order for the transition to D3 to take place, only the primary core\ncan be active, all pipes must be stopped (and therefore all modules in\nFW). The only active thread at this time is the Idle thread. Driver on\nthe host will not send another ipc because is still waiting for\nresponse. FW can try to send only two notification:\n\n- FW exception: from this place there is no return to continue the power\n  transition,\n- log buffer status: skipped, they remain in the queue without being\n  sent.\n\nI'm moving pm_device_busy_clear(dev) from IRQ handler to\nintel_adsp_ipc_send_message function so the pending ACK does not block\npower transition."
},{
  "instruction": "There is an issue in the following code. It relates to shell: Add a space after colon\n\nJust a cosmetic change, but IMHO the help looks much better now :). Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|sh\nargument_list|,\nname|SHELL_NORMAL\nargument_list|,\nliteral|\"%s:\"\nargument_list|,\nname|tabulator\nargument_list|)\nexpr_stmt|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"%s:\"\n+literal|\"%s: \"\nThe issue was with: shell: Add a space after colon\n\nJust a cosmetic change, but IMHO the help looks much better now :)."
},{
  "instruction": "There is an issue in the following code. It relates to wifi: shell: Remove the unnecessary text\n\nThe parameters heading is implied and doesn't have the newline, so, just\nremove it. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/* CONFIG_WIFI_MGMT_RAW_SCAN_RESULTS_ONLY */\nend_comment\n\nbegin_struct\nDECL|struct|__anon288778af0108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\nname|struct\nname|shell\nmodifier|*\nname|sh\ndecl_stmt|;\nDECL|union|__anon288778af020a\nunion|union\nblock|{\nDECL|struct|__anon288778af0308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\nargument_list|,\nname|NULL\nargument_list|,\nliteral|\"mode operational setting\\n\"\nliteral|\"This command may be used to set the Wi-Fi device into a specific mode of operation\\n\"\nliteral|\"parameters:\"\nliteral|\"[-i, --if-index<idx>] : Interface index.\\n\"\nliteral|\"[-s, --sta] : Station mode.\\n\"\nliteral|\"[-m, --monitor] : Monitor mode.\\n\"\nliteral|\"[-p, --promiscuous] : Promiscuous mode.\\n\"\nliteral|\"[-t, --tx-injection] : TX-Injection mode.\\n\"\nargument_list|,\nliteral|\"mode filter setting\\n\"\nliteral|\"This command is used to set packet filter setting when\\n\"\nliteral|\"monitor, TX-Injection and promiscuous mode is enabled.\\n\"\nliteral|\"The different packet filter modes are control, management, data and enable all filters\\n\"\nliteral|\"parameters:\"\nliteral|\"[-i, --if-index<idx>] : Interface index.\\n\"\nliteral|\"[-a, --all] : Enable all packet filter modes\\n\"\nliteral|\"[-m, --mgmt] : Enable management packets to allowed up the stack.\\n\"\nliteral|\"[-c, --ctrl] : Enable control packets to be allowed up the stack.\\n\"\nliteral|\"[-d, --data] : Enable Data packets to be allowed up the stack.\\n\"\nargument_list|,\nliteral|\"wifi channel setting\\n\"\nliteral|\"This command is used to set the channel when\\n\"\nliteral|\"monitor or TX-Injection mode is enabled.\\n\"\nliteral|\"Currently 20 MHz is only supported and no BW parameter is provided\\n\"\nliteral|\"parameters:\"\nliteral|\"[-i, --if-index<idx>] : Interface index.\\n\"\nliteral|\"[-c, --channel<chan>] : Set a specific channel number to the lower layer.\\n\"\nliteral|\"[-g, --get] : Get current set channel number from the lower layer.\\n\"\nliteral|\"[-h, --help] : Help.\\n\"\nliteral|\"Usage: Get operation example for interface index 1\\n\"",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon288778af0108\n+DECL|struct|__anon2c90359a0108\n-DECL|union|__anon288778af020a\n+DECL|union|__anon2c90359a020a\n-DECL|struct|__anon288778af0308\n+DECL|struct|__anon2c90359a0308\n-literal|\"parameters:\"\n-literal|\"parameters:\"\n-literal|\"parameters:\"\nThe issue was with: wifi: shell: Remove the unnecessary text\n\nThe parameters heading is implied and doesn't have the newline, so, just\nremove it."
},{
  "instruction": "There is an issue in the following code. It relates to wifi: shell: Fix the help for reg domain\n\nSeparate the two optional parameters and add help. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/* CONFIG_WIFI_MGMT_RAW_SCAN_RESULTS_ONLY */\nend_comment\n\nbegin_struct\nDECL|struct|__anon2bce7e0b0108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\nname|struct\nname|shell\nmodifier|*\nname|sh\ndecl_stmt|;\nDECL|union|__anon2bce7e0b020a\nunion|union\nblock|{\nDECL|struct|__anon2bce7e0b0308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\nname|reg_domain\nargument_list|,\nname|NULL\nargument_list|,\nliteral|\"Set or Get Wi-Fi regulatory domain\\n\"\nliteral|\"Usage: wifi reg_domain [ISO/IEC 3166-1 alpha2] [-f]\\n\"\nliteral|\"[-f]: Force to use this regulatory hint over any other regulatory hints\\n\"\nliteral|\"Note: This may cause regulatory compliance issues, use it at your own risk.\"\nargument_list|,\nname|cmd_wifi_reg_domain\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2bce7e0b0108\n+DECL|struct|__anon288778af0108\n-DECL|union|__anon2bce7e0b020a\n+DECL|union|__anon288778af020a\n-DECL|struct|__anon2bce7e0b0308\n+DECL|struct|__anon288778af0308\n-literal|\"Usage: wifi reg_domain [ISO/IEC 3166-1 alpha2] [-f]\\n\"\n+literal|\"[ISO/IEC 3166-1 alpha2]: Regulatory domain\\n\"\nThe issue was with: wifi: shell: Fix the help for reg domain\n\nSeparate the two optional parameters and add help."
},{
  "instruction": "There is an issue in the following code. It relates to wifi: shell: Remove the unnecessary text in scan\n\nWe are using standard notation to differentiate optional and mandatory,\nso, no need for a heading. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/* CONFIG_WIFI_MGMT_RAW_SCAN_RESULTS_ONLY */\nend_comment\n\nbegin_struct\nDECL|struct|__anon2c6603830108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\nname|struct\nname|shell\nmodifier|*\nname|sh\ndecl_stmt|;\nDECL|union|__anon2c660383020a\nunion|union\nblock|{\nDECL|struct|__anon2c6603830308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\nname|scan\nargument_list|,\nname|NULL\nargument_list|,\nliteral|\"Scan for Wi-Fi APs\\n\"\nliteral|\"OPTIONAL PARAMETERS:\\n\"\nliteral|\"[-t, --type<active/passive>] : Preferred mode of scan. The actual mode of scan can depend on factors such as the Wi-Fi chip implementation, regulatory domain restrictions. Default type is active.\\n\"\nliteral|\"[-b, --bands<Comma separated list of band values (2/5/6)>] : Bands to be scanned where 2: 2.4 GHz, 5: 5 GHz, 6: 6 GHz.\\n\"\nliteral|\"[-a, --dwell_time_active<val_in_ms>] : Active scan dwell time (in ms) on a channel. Range 5 ms to 1000 ms.\\n\"\nliteral|\"[-p, --dwell_time_passive<val_in_ms>] : Passive scan dwell time (in ms) on a channel. Range 10 ms to 1000 ms.\\n\"\nliteral|\"[-s, --ssid : SSID to scan for. Can be provided multiple times.\\n\"",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2c6603830108\n+DECL|struct|__anon2bce7e0b0108\n-DECL|union|__anon2c660383020a\n+DECL|union|__anon2bce7e0b020a\n-DECL|struct|__anon2c6603830308\n+DECL|struct|__anon2bce7e0b0308\n-literal|\"OPTIONAL PARAMETERS:\\n\"\nThe issue was with: wifi: shell: Remove the unnecessary text in scan\n\nWe are using standard notation to differentiate optional and mandatory,\nso, no need for a heading."
},{
  "instruction": "There is an issue in the following code. It relates to wifi: shell: Fix help for PS command\n\nClearly mark the args as optional. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/* CONFIG_WIFI_MGMT_RAW_SCAN_RESULTS_ONLY */\nend_comment\n\nbegin_struct\nDECL|struct|__anon2c3f9a620108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\nname|struct\nname|shell\nmodifier|*\nname|sh\ndecl_stmt|;\nDECL|union|__anon2c3f9a62020a\nunion|union\nblock|{\nDECL|struct|__anon2c3f9a620308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\nargument_list|(\nname|ps\nargument_list|,\nname|NULL\nargument_list|,\nliteral|\"Configure Wi-F PS on/off, no arguments will dump config\"\nargument_list|,\nname|cmd_wifi_ps\nargument_list|,\nliteral|1\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2c3f9a620108\n+DECL|struct|__anon2c6603830108\n-DECL|union|__anon2c3f9a62020a\n+DECL|union|__anon2c660383020a\n-DECL|struct|__anon2c3f9a620308\n+DECL|struct|__anon2c6603830308\n-literal|\"Configure Wi-F PS on/off, no arguments will dump config\"\n+literal|\"Configure or display Wi-Fi power save state\\n\"\n+literal|\"[on/off]\\n\"\nThe issue was with: wifi: shell: Fix help for PS command\n\nClearly mark the args as optional."
},{
  "instruction": "There is an issue in the following code. It relates to wifi: shell: Fix optional arg count for connect\n\nFix an extra optional arg. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/* CONFIG_WIFI_MGMT_RAW_SCAN_RESULTS_ONLY */\nend_comment\n\nbegin_struct\nDECL|struct|__anon28eb83cc0108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\nname|struct\nname|shell\nmodifier|*\nname|sh\ndecl_stmt|;\nDECL|union|__anon28eb83cc020a\nunion|union\nblock|{\nDECL|struct|__anon28eb83cc0308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\nargument_list|,\nname|cmd_wifi_connect\nargument_list|,\nliteral|2\nargument_list|,\nliteral|5\nargument_list|)\nargument_list|,\nname|SHELL_CMD_ARG\nargument_list|(\nname|disconnect",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon28eb83cc0108\n+DECL|struct|__anon2c3f9a620108\n-DECL|union|__anon28eb83cc020a\n+DECL|union|__anon2c3f9a62020a\n-DECL|struct|__anon28eb83cc0308\n+DECL|struct|__anon2c3f9a620308\n-literal|5\n+literal|4\nThe issue was with: wifi: shell: Fix optional arg count for connect\n\nFix an extra optional arg."
},{
  "instruction": "There is an issue in the following code. It relates to wifi: shell: Fix the arg count for reg domain\n\nMissed accounting for \\\"-f\\\" option. Please fix this issue.",
  "input": "Faulty tokenized code:\nbegin_comment\ncomment|/* CONFIG_WIFI_MGMT_RAW_SCAN_RESULTS_ONLY */\nend_comment\n\nbegin_struct\nDECL|struct|__anon2c1c93cf0108\nspecifier|static\nstruct|struct\nblock|{\nDECL|member|sh\nspecifier|const\nname|struct\nname|shell\nmodifier|*\nname|sh\ndecl_stmt|;\nDECL|union|__anon2c1c93cf020a\nunion|union\nblock|{\nDECL|struct|__anon2c1c93cf0308\nstruct|struct\nblock|{\nDECL|member|connecting\nname|uint8_t\nname|connecting\nargument_list|,\nname|cmd_wifi_reg_domain\nargument_list|,\nliteral|1\nargument_list|,\nliteral|1\nargument_list|)\nargument_list|,\nname|SHELL_CMD_ARG\nargument_list|(\nname|mode",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|struct|__anon2c1c93cf0108\n+DECL|struct|__anon28eb83cc0108\n-DECL|union|__anon2c1c93cf020a\n+DECL|union|__anon28eb83cc020a\n-DECL|struct|__anon2c1c93cf0308\n+DECL|struct|__anon28eb83cc0308\n-literal|1\n+literal|2\nThe issue was with: wifi: shell: Fix the arg count for reg domain\n\nMissed accounting for \\\"-f\\\" option."
},{
  "instruction": "There is an issue in the following code. It relates to lib/posix getopt: Fix include\n\nLet's try to use the host unistd.h when building with\nthe host library only, instead of assuming\nthat the native boards are always built with it.\nThis fixes a build error when building for native boards\nusing minimal libc. Please fix this issue.",
  "input": "Faulty tokenized code:\nend_include\n\nbegin_ifdef\nifdef|#\ndirective|ifdef\nname|CONFIG_ARCH_POSIX\nend_ifdef\n\nbegin_include\ninclude|#\ndirective|include",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_ARCH_POSIX\n+name|CONFIG_NATIVE_LIBC\nThe issue was with: lib/posix getopt: Fix include\n\nLet's try to use the host unistd.h when building with\nthe host library only, instead of assuming\nthat the native boards are always built with it.\nThis fixes a build error when building for native boards\nusing minimal libc."
},{
  "instruction": "There is an issue in the following code. It relates to tests: latency_measure: Tidy up header inclusions\n\nMoves the inclusion of the app_memdomain header file into the\ntests' utils.h so that any file that includes this can make\nuse of the BENCH_BMEM macro. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/timestamp.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/app_memory/app_memdomain.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|\"utils.h\"\nend_include\ninclude|#\ndirective|include\nfile|<zephyr/kernel.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|<zephyr/app_memory/app_memdomain.h>\nend_include\n\nbegin_include\ninclude|#\ndirective|include\nfile|\"utils.h\"\nend_include\ninclude|#\ndirective|include\nfile|<zephyr/timestamp.h>\nend_include\n\nbegin_define\nDECL|macro|START_STACK_SIZE\ndefine|#\ndirective|define\nname|START_STACK_SIZE",
  "result": "I corrected the issue in the code by changing the following tokens:\n-begin_include\n-include|#\n-directive|include\n-file|<zephyr/app_memory/app_memdomain.h>\n-end_include\n-\n-begin_include\n-include|#\n-directive|include\n-file|<zephyr/app_memory/app_memdomain.h>\n-end_include\n-\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/app_memory/app_memdomain.h>\n+end_include\n+\nThe issue was with: tests: latency_measure: Tidy up header inclusions\n\nMoves the inclusion of the app_memdomain header file into the\ntests' utils.h so that any file that includes this can make\nuse of the BENCH_BMEM macro."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: L2CAP: clarify BT_L2CAP_STATUS_OUT\n\nMakes it clearer what that bit means:\nIf set, the channel has capacity to send at least one PDU.\n\nIf unset, the channel ran out of credits and won't be able to send\nanything until the peer sends credits back.\n\nAlso add debug logs. Please fix this issue.",
  "input": "Faulty tokenized code:\nDECL|enum|bt_l2cap_chan_status\ntypedef|typedef\nenum|enum\nname|bt_l2cap_chan_status\nblock|{\ncomment|/** Channel output status */\nDECL|enumerator|BT_L2CAP_STATUS_OUT\nname|BT_L2CAP_STATUS_OUT\nblock|,\ncomment|/** @brief Channel shutdown status \t * \t * Once this status is notified it means the channel will no longer be \t * able to transmit or receive data. \t */\nDECL|enumerator|BT_L2CAP_STATUS_SHUTDOWN\noperator|.\nname|status\nargument_list|,\nname|BT_L2CAP_STATUS_OUT\nargument_list|)\noperator|&&\nname|chan\noperator|->\nname|chan\noperator|.\nname|ops\nname|status\nargument_list|)\nexpr_stmt|;\nblock|}\nblock|}\nend_function\n\nbegin_function\nDECL|function|l2cap_chan_destroy (struct bt_l2cap_chan * chan)\nspecifier|static\nblock|}\nreturn|return\nname|err\nreturn|;\nblock|}\ncomment|/* Check if there is no credits left clear output status and notify its \t * change. \t */\nif|if\ncondition|(\noperator|!\nname|atomic_get\nargument_list|(\noperator|.\nname|credits\nargument_list|)\ncondition|)\nblock|{\nname|atomic_clear_bit\nargument_list|(\nname|ch\noperator|->\nname|chan",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/** Channel output status */\n+comment|/** Channel can send at least one PDU */\n-operator|&&\n+condition|)\n+block|{\n+name|LOG_DBG\n+argument_list|(\n+literal|\"chan %p unpaused\"\n+argument_list|,\n+name|chan\n+argument_list|)\n+expr_stmt|;\n+if|if\n+condition|(\n+block|}\n-comment|/* Check if there is no credits left clear output status and notify its \t * change. \t */\n+comment|/* Notify channel user that it can't send anymore on this channel. */\n+name|LOG_DBG\n+argument_list|(\n+literal|\"chan %p paused\"\n+argument_list|,\n+name|ch\n+argument_list|)\n+expr_stmt|;\nThe issue was with: Bluetooth: L2CAP: clarify BT_L2CAP_STATUS_OUT\n\nMakes it clearer what that bit means:\nIf set, the channel has capacity to send at least one PDU.\n\nIf unset, the channel ran out of credits and won't be able to send\nanything until the peer sends credits back.\n\nAlso add debug logs."
},{
  "instruction": "There is an issue in the following code. It relates to net: lwm2m: Delay triggering registration update\n\nAdd short delay before triggering registration update. This allows\npostponing the update from application side if needed. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|next_update\nargument_list|()\noperator|)\ncondition|)\nblock|{\nname|set_sm_state\nargument_list|(\nname|ENGINE_UPDATE_REGISTRATION\nargument_list|)\nexpr_stmt|;\nblock|}\nif|else if\ncondition|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|set_sm_state\n+name|set_sm_state_delayed\n+argument_list|,\n+name|DELAY_FOR_ACK\nThe issue was with: net: lwm2m: Delay triggering registration update\n\nAdd short delay before triggering registration update. This allows\npostponing the update from application side if needed."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: spi: set 'spi_driver_api' as 'static const'\n\nThis change marks each instance of the 'spi_driver_api' as 'static const'.\nThe rationale is that 'spi_driver_api' is used for declaring internal\nmodule interfaces and is not intended to be modified at runtime.\nBy using 'static const', we ensure immutability, leading to usage of only\n.rodata and a reduction in the .data area. Please fix this issue.",
  "input": "Faulty tokenized code:\nend_function\n\nbegin_decl_stmt\nDECL|variable|mspi_ambiq_driver_api\nspecifier|static\nname|struct\nname|spi_driver_api\nname|mspi_ambiq_driver_api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|spi_ambiq_driver_api\nspecifier|static\nname|struct\nname|spi_driver_api\nname|spi_ambiq_driver_api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|spi_atcspi200_api\nspecifier|static\nname|struct\nname|spi_driver_api\nname|spi_atcspi200_api\ninit|=\nblock|{\nend_comment\n\nbegin_decl_stmt\nDECL|variable|spi_b91_api\nspecifier|static\nname|struct\nname|spi_driver_api\nname|spi_b91_api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|spi_bitbang_api\nspecifier|static\nname|struct\nname|spi_driver_api\nname|spi_bitbang_api\ninit|=\nblock|{\nend_comment\n\nbegin_decl_stmt\nDECL|variable|spi_emul_api\nspecifier|static\nname|struct\nname|spi_driver_api\nname|spi_emul_api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|spi_gd32_driver_api\nspecifier|static\nname|struct\nname|spi_driver_api\nname|spi_gd32_driver_api\ninit|=\nblock|{\nend_comment\n\nbegin_decl_stmt\nDECL|variable|spi_gecko_api\nspecifier|static\nname|struct\nname|spi_driver_api\nname|spi_gecko_api\ninit|=\nblock|{\nend_comment\n\nbegin_decl_stmt\nDECL|variable|spi_litespi_api\nspecifier|static\nname|struct\nname|spi_driver_api\nname|spi_litespi_api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|spi_numaker_driver_api\nspecifier|static\nname|struct\nname|spi_driver_api\nname|spi_numaker_driver_api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|spi_oc_simple_api\nspecifier|static\nname|struct\nname|spi_driver_api\nname|spi_oc_simple_api\ninit|=\nblock|{\nend_comment\n\nbegin_decl_stmt\nDECL|variable|spi_opentitan_api\nspecifier|static\nname|struct\nname|spi_driver_api\nname|spi_opentitan_api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|spi_pl022_api\nspecifier|static\nname|struct\nname|spi_driver_api\nname|spi_pl022_api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|spi_pico_pio_api\nspecifier|static\nname|struct\nname|spi_driver_api\nname|spi_pico_pio_api\ninit|=\nblock|{\nend_comment\n\nbegin_decl_stmt\nDECL|variable|spi_sifive_api\nspecifier|static\nname|struct\nname|spi_driver_api\nname|spi_sifive_api\ninit|=\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\nThe issue was with: drivers: spi: set 'spi_driver_api' as 'static const'\n\nThis change marks each instance of the 'spi_driver_api' as 'static const'.\nThe rationale is that 'spi_driver_api' is used for declaring internal\nmodule interfaces and is not intended to be modified at runtime.\nBy using 'static const', we ensure immutability, leading to usage of only\n.rodata and a reduction in the .data area."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: ieee802154: set 'ieee802154_radio_api' as 'static const'\n\nThis change marks each instance of the 'api' as 'static const'.\nThe rationale is that 'api' is used for declaring internal\nmodule interfaces and is not intended to be modified at runtime.\nBy using 'static const', we ensure immutability, leading to usage of only\n.rodata and a reduction in the .data area. Please fix this issue.",
  "input": "Faulty tokenized code:\nend_comment\n\nbegin_decl_stmt\nDECL|variable|b91_radio_api\nspecifier|static\nname|struct\nname|ieee802154_radio_api\nname|b91_radio_api\ninit|=\nblock|{\nend_decl_stmt\n\nbegin_decl_stmt\nDECL|variable|cc1200_radio_api\nspecifier|static\nname|struct\nname|ieee802154_radio_api\nname|cc1200_radio_api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|ieee802154_cc13xx_cc26xx_radio_api\nspecifier|static\nname|struct\nname|ieee802154_radio_api\nname|ieee802154_cc13xx_cc26xx_radio_api\ninit|=\nblock|{\nblock|}\nend_function\n\nbegin_decl_stmt\nspecifier|static\nname|struct\nname|ieee802154_radio_api\nDECL|variable|ieee802154_cc13xx_cc26xx_subg_radio_api\nname|ieee802154_cc13xx_cc26xx_subg_radio_api\ninit|=\nend_decl_stmt\n\nbegin_decl_stmt\nDECL|variable|cc2520_radio_api\nspecifier|static\nname|struct\nname|ieee802154_radio_api\nname|cc2520_radio_api\ninit|=\nblock|{\nbegin_comment\ncomment|/* driver-allocated attribute memory - constant across all driver instances */\nend_comment\n\nbegin_struct\nDECL|struct|__anon2a4095dc0108\nspecifier|static\nspecifier|const\nstruct|struct\nblock|{\nDECL|member|phy_channel_range\nend_function\n\nbegin_decl_stmt\nDECL|variable|dwt_radio_api\nspecifier|static\nname|struct\nname|ieee802154_radio_api\nname|dwt_radio_api\ninit|=\nblock|{\nbegin_comment\ncomment|/*  * Clear channel assessment types. Note that there is an extra one when  * bit 26 is included for \"No CCA before transmit\" if we are handling  * ACK frames but we will let the hardware handle that automatically.  */\nend_comment\n\nbegin_enum\nDECL|enum|__anon29080ea30103\nenum|enum\nblock|{\nDECL|enumerator|KW41Z_CCA_ED\nname|KW41Z_CCA_ED\nblock|,\nbegin_comment\ncomment|/*  * KW41Z has a sequencer that can run in any of the following states.  */\nend_comment\n\nbegin_enum\nDECL|enum|__anon29080ea30203\nenum|enum\nblock|{\nDECL|enumerator|KW41Z_STATE_IDLE\nname|KW41Z_STATE_IDLE\nblock|,\nend_function\n\nbegin_decl_stmt\nDECL|variable|kw41z_radio_api\nspecifier|static\nname|struct\nname|ieee802154_radio_api\nname|kw41z_radio_api\ninit|=\nblock|{\nend_decl_stmt\n\nbegin_decl_stmt\nDECL|variable|mcr20a_radio_api\nspecifier|static\nname|struct\nname|ieee802154_radio_api\nname|mcr20a_radio_api\ninit|=\nblock|{\nend_decl_stmt\n\nbegin_decl_stmt\nDECL|variable|nrf5_radio_api\nspecifier|static\nname|struct\nname|ieee802154_radio_api\nname|nrf5_radio_api\ninit|=\nblock|{\nend_function\n\nbegin_decl_stmt\nDECL|variable|rf2xx_radio_api\nspecifier|static\nname|struct\nname|ieee802154_radio_api\nname|rf2xx_radio_api\ninit|=\nblock|{\nend_decl_stmt\n\nbegin_decl_stmt\nDECL|variable|upipe_radio_api\nspecifier|static\nname|struct\nname|ieee802154_radio_api\nname|upipe_radio_api\ninit|=\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\n-DECL|struct|__anon2a4095dc0108\n+DECL|struct|__anon2773163d0108\n+specifier|const\n-DECL|enum|__anon29080ea30103\n+DECL|enum|__anon2c4842b70103\n-DECL|enum|__anon29080ea30203\n+DECL|enum|__anon2c4842b70203\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\n+specifier|const\nThe issue was with: drivers: ieee802154: set 'ieee802154_radio_api' as 'static const'\n\nThis change marks each instance of the 'api' as 'static const'.\nThe rationale is that 'api' is used for declaring internal\nmodule interfaces and is not intended to be modified at runtime.\nBy using 'static const', we ensure immutability, leading to usage of only\n.rodata and a reduction in the .data area."
},{
  "instruction": "There is an issue in the following code. It relates to tests: net: socket: tls: Fix race on TCP socket close\n\nOne of the tests closed the underlying TCP connection right after\nestablishing one. This caused a certain race between incoming TLS\nhandshake data and entering FIN1 state (experienced on nrF52840), where\nthe TLS handshake data could be received after the FIN1 state was\nentered, causing the server side to send RST packet. This disrupted the\ntest flow, as graceful TCP connection teardown was expected.\n\nFix this, by adding a small delay for such case to avoid the race. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|data\noperator|->\nname|reply\ncondition|)\nblock|{\ngoto|goto\nname|out\ngoto|;\nblock|}\nwhile|while",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Add small delay to avoid race between incoming data and \t\t * sending FIN. \t\t */\n+name|k_msleep\n+argument_list|(\n+literal|10\n+argument_list|)\n+expr_stmt|;\nThe issue was with: tests: net: socket: tls: Fix race on TCP socket close\n\nOne of the tests closed the underlying TCP connection right after\nestablishing one. This caused a certain race between incoming TLS\nhandshake data and entering FIN1 state (experienced on nrF52840), where\nthe TLS handshake data could be received after the FIN1 state was\nentered, causing the server side to send RST packet. This disrupted the\ntest flow, as graceful TCP connection teardown was expected.\n\nFix this, by adding a small delay for such case to avoid the race."
},{
  "instruction": "There is an issue in the following code. It relates to input: kbd_matrix: fail gracefully if changing an undefined key mask\n\nAdd a check to input_kbd_matrix_actual_key_mask_set() to return an error\nif trying to change a key mask but the device does not define a keymask\nin the first place. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}\nname|WRITE_BIT\nargument_list|(\nname|cfg\noperator|->\nname|actual_key_mask",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|cfg\n+operator|->\n+name|actual_key_mask\n+operator|==\n+name|NULL\n+condition|)\n+block|{\n+name|LOG_WRN\n+argument_list|(\n+literal|\"actual-key-mask not defined for %s\"\n+argument_list|,\n+name|dev\n+operator|->\n+name|name\n+argument_list|)\n+expr_stmt|;\n+return|return\n+operator|-\n+name|EINVAL\n+return|;\n+block|}\nThe issue was with: input: kbd_matrix: fail gracefully if changing an undefined key mask\n\nAdd a check to input_kbd_matrix_actual_key_mask_set() to return an error\nif trying to change a key mask but the device does not define a keymask\nin the first place."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: flash : stm32: STM32L4P5xx fix page calculation from offset\n\nThis fix adds the STM32L4P5xx to the list of devices that have an\noffset-to-page shift calculation of 12 bits. Previously, the driver\nwould only shift the offset by 11 bits when calculating the page to\nerase.\n\nThis would prevent the driver from erasing the correct page. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|!\nname|defined\nargument_list|(\nname|STM32L4Q5xx\nargument_list|)\nend_if\n\nbegin_define\nDECL|macro|STM32L4X_PAGE_SHIFT\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|&&\n+operator|!\n+name|defined\n+argument_list|(\n+name|STM32L4P5xx\n+argument_list|)\nThe issue was with: drivers: flash : stm32: STM32L4P5xx fix page calculation from offset\n\nThis fix adds the STM32L4P5xx to the list of devices that have an\noffset-to-page shift calculation of 12 bits. Previously, the driver\nwould only shift the offset by 11 bits when calculating the page to\nerase.\n\nThis would prevent the driver from erasing the correct page."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: rtc: stm32: Updated scope of hsem\n\nThis commit updates the scope of  hsem. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|->\nname|lock\nargument_list|)\nexpr_stmt|;\ncomment|/* Enable Backup access */\nname|z_stm32_hsem_lock\nargument_list|(\nname|CFG_HW_RCC_SEMID\nargument_list|,\nname|HSEM_LOCK_DEFAULT_RETRY\nargument_list|)\nexpr_stmt|;\nif|#\ndirective|if\nname|defined\nargument_list|(\nname|PWR_CR_DBP\nreturn|return\noperator|-\nname|EIO\nreturn|;\nblock|}\nname|LL_RCC_EnableRTC\nargument_list|()\nexpr_stmt|;\nname|z_stm32_hsem_unlock\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|z_stm32_hsem_lock\n-argument_list|(\n-name|CFG_HW_RCC_SEMID\n-argument_list|,\n-name|HSEM_LOCK_DEFAULT_RETRY\n-argument_list|)\n-expr_stmt|;\n+name|z_stm32_hsem_lock\n+argument_list|(\n+name|CFG_HW_RCC_SEMID\n+argument_list|,\n+name|HSEM_LOCK_DEFAULT_RETRY\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: rtc: stm32: Updated scope of hsem\n\nThis commit updates the scope of  hsem."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: regulator: max20335: fix unused-const-variable warnings\n\nThere can be a case where not all regulators are being used,\nresulting in an unused-const-variable warning,\nso let's add a __maybe_unused keyword to suppress it. Please fix this issue.",
  "input": "Faulty tokenized code:\nDECL|variable|buck1_desc\nspecifier|static\nspecifier|const\nname|struct\nname|regulator_max20335_desc\nname|buck1_desc\ninit|=\nblock|{\noperator|.\nname|vsel_reg\nDECL|variable|buck2_desc\nspecifier|static\nspecifier|const\nname|struct\nname|regulator_max20335_desc\nname|buck2_desc\ninit|=\nblock|{\noperator|.\nname|vsel_reg\nDECL|variable|ldo1_desc\nspecifier|static\nspecifier|const\nname|struct\nname|regulator_max20335_desc\nname|ldo1_desc\ninit|=\nblock|{\noperator|.\nname|vsel_reg\nDECL|variable|ldo2_desc\nspecifier|static\nspecifier|const\nname|struct\nname|regulator_max20335_desc\nname|ldo2_desc\ninit|=\nblock|{\noperator|.\nname|vsel_reg\nDECL|variable|ldo3_desc\nspecifier|static\nspecifier|const\nname|struct\nname|regulator_max20335_desc\nname|ldo3_desc\ninit|=\nblock|{\noperator|.\nname|vsel_reg",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|__maybe_unused\n+name|__maybe_unused\n+name|__maybe_unused\n+name|__maybe_unused\n+name|__maybe_unused\nThe issue was with: drivers: regulator: max20335: fix unused-const-variable warnings\n\nThere can be a case where not all regulators are being used,\nresulting in an unused-const-variable warning,\nso let's add a __maybe_unused keyword to suppress it."
},{
  "instruction": "There is an issue in the following code. It relates to kernel: need_swap zephyrproject-rtos#66299\n\nEnhancement on void z_reschedule_irqlock(uint32_t key)\nto avoid useless context switch\n\nsigned-off-by: Gaetan Perrot <gaetanperrotpro@gmail.com> Please fix this issue.",
  "input": "Faulty tokenized code:\ncondition|(\nname|resched\nargument_list|(\nname|key\nargument_list|)\ncondition|)\nblock|{\nname|z_swap_irqlock\nargument_list|(\nname|key",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|&&\n+name|need_swap\n+argument_list|()\nThe issue was with: kernel: need_swap zephyrproject-rtos#66299\n\nEnhancement on void z_reschedule_irqlock(uint32_t key)\nto avoid useless context switch\n\nsigned-off-by: Gaetan Perrot <gaetanperrotpro@gmail.com>"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: mbox: Add nxp mbox multi-channel support\n\nCurrent implementation of NXP mbox driver mbox_nxp_imx_mu\nis using only one channel 0.\nThis commit adds support for multiple mbox channels as is\nindented by mbox drivers.\n\nChange done in .send api signaling mode leveraging provided\nchannel id to select correct General Purpose Interrupt.\nAnother change done in IRQHandler to check and handle all\nchannels. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|cfg\noperator|->\nname|base\nargument_list|,\nname|kMU_GenInt0InterruptTrigger\nargument_list|)\nreturn|;\nblock|}\ncomment|/* Data transfer mode. */\nif|if\nname|MU_IRQ_HANDLER\nparameter_list|(\nname|idx\nparameter_list|)\ndefine|\\\nvalue|static uint32_t mu_##idx##_received_data;\t\t\t\t\\ \tvoid MU_##idx##_IRQHandler(void)\t\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\t\\ \t\tconst struct device *dev = DEVICE_DT_INST_GET(idx);\t\t\\ \t\tconst struct nxp_imx_mu_data *data = dev->data;\t\t\t\\ \t\tconst struct nxp_imx_mu_config *config = dev->config;\t\t\\ \t\tint channel = 0;\t\t\t\t\t\t\\ \t\tstruct mbox_msg msg;\t\t\t\t\t\t\\ \t\tstruct mbox_msg *callback_msg_ptr = NULL;\t\t\t\\ \t\tuint32_t flag = MU_GetStatusFlags(config->base);\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \t\tif ((flag& kMU_Rx0FullFlag) == kMU_Rx0FullFlag) {\t\t\\ \t\t\tmu_##idx##_received_data =\t\t\t\t\\ \t\t\t\tMU_ReceiveMsgNonBlocking(config->base, 0);\t\\ \t\t\tmsg.data = (const void *)&mu_##idx##_received_data;\t\\ \t\t\tmsg.size = MU_MBOX_SIZE;\t\t\t\t\\ \t\t\tcallback_msg_ptr =&msg;\t\t\t\t\\ \t\t} else if ((flag& kMU_GenInt0Flag) == kMU_GenInt0Flag) {\t\\ \t\t\tMU_ClearStatusFlags(config->base, kMU_GenInt0Flag);\t\\ \t\t\tcallback_msg_ptr = NULL;\t\t\t\t\\ \t\t}\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \t\tif (data->cb[channel]) {\t\t\t\t\t\\ \t\t\tdata->cb[channel](dev, channel,\t\t\t\t\\ \t\t\t\t\tdata->user_data[channel],\t\t\\ \t\t\t\t\tcallback_msg_ptr);\t\t\t\\ \t\t}\t\t\t\t\t\t\t\t\\ \t}\nend_define\n\nbegin_define\nDECL|macro|MU_INST (idx)\ndefine|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|>>\n+name|channel\n-value|static uint32_t mu_##idx##_received_data;\t\t\t\t\\ \tvoid MU_##idx##_IRQHandler(void)\t\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\t\\ \t\tconst struct device *dev = DEVICE_DT_INST_GET(idx);\t\t\\ \t\tconst struct nxp_imx_mu_data *data = dev->data;\t\t\t\\ \t\tconst struct nxp_imx_mu_config *config = dev->config;\t\t\\ \t\tint channel = 0;\t\t\t\t\t\t\\ \t\tstruct mbox_msg msg;\t\t\t\t\t\t\\ \t\tstruct mbox_msg *callback_msg_ptr = NULL;\t\t\t\\ \t\tuint32_t flag = MU_GetStatusFlags(config->base);\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \t\tif ((flag& kMU_Rx0FullFlag) == kMU_Rx0FullFlag) {\t\t\\ \t\t\tmu_##idx##_received_data =\t\t\t\t\\ \t\t\t\tMU_ReceiveMsgNonBlocking(config->base, 0);\t\\ \t\t\tmsg.data = (const void *)&mu_##idx##_received_data;\t\\ \t\t\tmsg.size = MU_MBOX_SIZE;\t\t\t\t\\ \t\t\tcallback_msg_ptr =&msg;\t\t\t\t\\ \t\t} else if ((flag& kMU_GenInt0Flag) == kMU_GenInt0Flag) {\t\\ \t\t\tMU_ClearStatusFlags(config->base, kMU_GenInt0Flag);\t\\ \t\t\tcallback_msg_ptr = NULL;\t\t\t\t\\ \t\t}\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \t\tif (data->cb[channel]) {\t\t\t\t\t\\ \t\t\tdata->cb[channel](dev, channel,\t\t\t\t\\ \t\t\t\t\tdata->user_data[channel],\t\t\\ \t\t\t\t\tcallback_msg_ptr);\t\t\t\\ \t\t}\t\t\t\t\t\t\t\t\\ \t}\n+value|static uint32_t mu_##idx##_received_data;\t\t\t\t\\ \tvoid MU_##idx##_IRQHandler(void)\t\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\t\\ \t\tconst struct device *dev = DEVICE_DT_INST_GET(idx);\t\t\\ \t\tconst struct nxp_imx_mu_data *data = dev->data;\t\t\t\\ \t\tconst struct nxp_imx_mu_config *config = dev->config;\t\t\\ \t\tstruct mbox_msg msg;\t\t\t\t\t\t\\ \t\tstruct mbox_msg *callback_msg_ptr = NULL;\t\t\t\\ \t\tuint32_t flag = MU_GetStatusFlags(config->base);\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \t\tfor (int i_channel = 0; i_channel< MU_MAX_CHANNELS; i_channel++) { \\ \t\t\tif ((flag& (kMU_Rx0FullFlag>> i_channel)) == \\ \t\t\t\t(kMU_Rx0FullFlag>> i_channel)) { \\ \t\t\t\tmu_##idx##_received_data =\t\t\t\t\\ \t\t\t\t\tMU_ReceiveMsgNonBlocking(config->base, 0);\t\\ \t\t\t\tmsg.data = (const void *)&mu_##idx##_received_data;\t\\ \t\t\t\tmsg.size = MU_MBOX_SIZE;\t\t\t\t\\ \t\t\t\tcallback_msg_ptr =&msg;\t\t\t\t\\ \t\t\t} else if ((flag& (kMU_GenInt0Flag>> i_channel)) == \\ \t\t\t\t\t\t(kMU_GenInt0Flag>> i_channel)) {\t\\ \t\t\t\tMU_ClearStatusFlags(config->base, \\ \t\t\t\t\t(kMU_GenInt0Flag>> i_channel)); \\ \t\t\t\tcallback_msg_ptr = NULL;\t\t\t\t\\ \t\t\t}\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\\ \t\t\tif (data->cb[i_channel]) {\t\t\t\t\t\\ \t\t\t\tdata->cb[i_channel](dev, i_channel,\t\t\t\t\\ \t\t\t\t\t\tdata->user_data[i_channel],\t\t\\ \t\t\t\t\t\tcallback_msg_ptr);\t\t\t\\ \t\t\t} \\ \t\t} \\ \t}\nThe issue was with: drivers: mbox: Add nxp mbox multi-channel support\n\nCurrent implementation of NXP mbox driver mbox_nxp_imx_mu\nis using only one channel 0.\nThis commit adds support for multiple mbox channels as is\nindented by mbox drivers.\n\nChange done in .send api signaling mode leveraging provided\nchannel id to select correct General Purpose Interrupt.\nAnother change done in IRQHandler to check and handle all\nchannels."
},{
  "instruction": "There is an issue in the following code. It relates to samples: zbus: fix samples to work with priority boost\n\nAdjust the sample to work with the priority boost. It illustrates zbus\nbeing used inside an ISR instead of into the main function. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|NULL\nargument_list|,\nname|NULL\nargument_list|,\nliteral|3\nargument_list|,\nliteral|0\nargument_list|,\nliteral|0\nargument_list|)\nargument_list|,\nname|NULL\nargument_list|,\nname|NULL\nargument_list|,\nliteral|3\nargument_list|,\nliteral|0\nargument_list|,\nliteral|0\nargument_list|)\nliteral|3\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_function\nDECL|function|main (void)\nname|int\nname|main\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nname|struct\nname|acc_msg\nname|acc\ninit|=\nblock|{\nname|z\noperator|=\nliteral|100\nblock|}\ndecl_stmt|;\nname|total_allocated\noperator|=\nliteral|0\nexpr_stmt|;\nif|#",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|3\n+literal|2\n-literal|3\n+literal|4\n-begin_function\n-DECL|function|main (void)\n-name|int\n-name|main\n-parameter_list|(\n-name|void\n-parameter_list|)\n-block|{\n+begin_decl_stmt\n+DECL|variable|acc\n+specifier|static\n+end_decl_stmt\n+\n+begin_function\n+DECL|function|main (void)\n+name|int\n+name|main\n+parameter_list|(\n+name|void\n+parameter_list|)\n+block|{\nThe issue was with: samples: zbus: fix samples to work with priority boost\n\nAdjust the sample to work with the priority boost. It illustrates zbus\nbeing used inside an ISR instead of into the main function."
},{
  "instruction": "There is an issue in the following code. It relates to tests: crypto: rand32: Check return code of sys_csrand_get\n\nCheck the return code of sys_csrand_get when testing the function.\n\nIgnoring it is bad practice and can also be a security issue if users\ncopy-paste this test code. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|buf\nargument_list|)\nargument_list|)\nexpr_stmt|;\nname|sys_csrand_get\nargument_list|(\nname|buf\nargument_list|,\nsizeof|sizeof\nargument_list|(\nname|buf\nargument_list|)\nargument_list|)\nexpr_stmt|;\nfor|for\ncontrol|(\nname|rnd_cnt\noperator|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|int\n+name|err\n+init|=\n+decl_stmt|;\n+name|zassert_true\n+argument_list|(\n+name|err\n+operator|==\n+literal|0\n+argument_list|,\n+literal|\"sys_csrand_get returned an error\"\n+argument_list|)\nThe issue was with: tests: crypto: rand32: Check return code of sys_csrand_get\n\nCheck the return code of sys_csrand_get when testing the function.\n\nIgnoring it is bad practice and can also be a security issue if users\ncopy-paste this test code."
},{
  "instruction": "There is an issue in the following code. It relates to posix: clock: check for invalid ns in clock_settime()\n\nThe clock_settime() function should not accept an input timespec\nwith nanosecond values < 0 or >= NSEC_PER_SEC. Please fix this issue.",
  "input": "Faulty tokenized code:\nreturn|return\noperator|-\nliteral|1\nreturn|;\nblock|}\nname|uint64_t\nname|elapsed_nsecs\ninit|=\nname|k_ticks_to_ns_floor64\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|tp\n+operator|->\n+name|tv_nsec\n+operator|<\n+literal|0\n+operator|||\n+name|tp\n+operator|->\n+name|tv_nsec\n+operator|>=\n+name|NSEC_PER_SEC\n+condition|)\n+block|{\n+name|errno\n+operator|=\n+name|EINVAL\n+expr_stmt|;\n+return|return\n+operator|-\n+literal|1\n+return|;\n+block|}\nThe issue was with: posix: clock: check for invalid ns in clock_settime()\n\nThe clock_settime() function should not accept an input timespec\nwith nanosecond values < 0 or >= NSEC_PER_SEC."
},{
  "instruction": "There is an issue in the following code. It relates to tests: net: ipv6: Adjust the source address of test pkt\n\nWe would drop the received packet if the source address is our\naddress so tweak the test and make source address different. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|,\nliteral|0\nblock|,\nliteral|0\nblock|,\nliteral|0x1\nblock|}\nblock|}\nblock|}\ndecl_stmt|;\nname|enum\nblock|,\nliteral|0\nblock|,\nliteral|0\nblock|,\nliteral|0x1\nblock|}\nblock|}\nblock|}\ndecl_stmt|;\nname|enum\nblock|,\nliteral|0\nblock|,\nliteral|0\nblock|,\nliteral|0x1\nblock|}\nblock|}\nblock|}\ndecl_stmt|;\nname|enum\nblock|,\nliteral|0\nblock|,\nliteral|0\nblock|,\nliteral|0x1\nblock|}\nblock|}\nblock|}\ndecl_stmt|;\nname|enum\nblock|,\nliteral|0\nblock|,\nliteral|0\nblock|,\nliteral|0x1\nblock|}\nblock|}\nblock|}\ndecl_stmt|;\nname|enum\nblock|,\nliteral|0\nblock|,\nliteral|0\nblock|,\nliteral|0x1\nblock|}\nblock|}\nblock|}\ndecl_stmt|;\nname|enum\nblock|,\nliteral|0\nblock|,\nliteral|0\nblock|,\nliteral|0x1\nblock|}\nblock|}\nblock|}\ndecl_stmt|;\nname|enum\nblock|,\nliteral|0\nblock|,\nliteral|0\nblock|,\nliteral|0x1\nblock|}\nblock|}\nblock|}\ndecl_stmt|;\nname|struct\nblock|,\nliteral|0\nblock|,\nliteral|0\nblock|,\nliteral|0x1\nblock|}\nblock|}\nblock|}\ndecl_stmt|;\nname|struct\nblock|,\nliteral|0\nblock|,\nliteral|0\nblock|,\nliteral|0x1\nblock|}\nblock|}\nblock|}\ndecl_stmt|;\nname|struct\nblock|,\nliteral|0\nblock|,\nliteral|0\nblock|,\nliteral|0x1\nblock|}\nblock|}\nblock|}\ndecl_stmt|;\nname|struct\nblock|,\nliteral|0\nblock|,\nliteral|0x99\nblock|,\nliteral|0x1\nblock|}\nblock|}\nblock|}\ndecl_stmt|;\nname|struct",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|0x1\n+literal|0x10\n-literal|0x1\n+literal|0x10\n-literal|0x1\n+literal|0x10\n-literal|0x1\n+literal|0x10\n-literal|0x1\n+literal|0x10\n-literal|0x1\n+literal|0x10\n-literal|0x1\n+literal|0x10\n-literal|0x1\n+literal|0x10\n-literal|0x1\n+literal|0x10\n-literal|0x1\n+literal|0x10\n-literal|0x1\n+literal|0x10\n-literal|0x1\n+literal|0x10\nThe issue was with: tests: net: ipv6: Adjust the source address of test pkt\n\nWe would drop the received packet if the source address is our\naddress so tweak the test and make source address different."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: pwm: stm32: Catch overflows in 2-channel capture\n\nWhen not using 4 channel capture, overflows were never reported\nto the application, because the check was in the\nfour_channel_capture_support branch. Please fix this issue.",
  "input": "Faulty tokenized code:\ncondition|)\nblock|{\ncomment|/* Still waiting for a complete capture */\nreturn|return;\nblock|}\nif|if\ncondition|(\nname|cpt\noperator|->\nname|overflows\noperator|=\noperator|-\nname|ERANGE\nexpr_stmt|;\nblock|}\nblock|}\nif|if\ncondition|(\noperator|!\nname|cpt\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n+block|}\n-block|}\nThe issue was with: drivers: pwm: stm32: Catch overflows in 2-channel capture\n\nWhen not using 4 channel capture, overflows were never reported\nto the application, because the check was in the\nfour_channel_capture_support branch."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: gpio: pca953x: check return values from I2C API functions\n\nCheck the return values from the I2C API functions called in init() and\nfail driver initialization if unsuccessful.\n\nFixes: #66827 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|drv_data\noperator|->\nname|gpio_cb\nargument_list|)\nexpr_stmt|;\ncomment|/* This may not present on all variants of device */\nif|if\ncondition|(\nname|cfg\noperator|->\noperator|>\noperator|-\nliteral|1\ncondition|)\nblock|{\nname|i2c_reg_write_byte_dt\nargument_list|(\noperator|&\nname|cfg\noperator|->\noperator|>\noperator|-\nliteral|1\ncondition|)\nblock|{\nname|i2c_reg_write_byte_dt\nargument_list|(\noperator|&\nname|cfg\noperator|->",
  "result": "I corrected the issue in the code by changing the following tokens:\n+if|if\n+condition|(\n+name|rc\n+condition|)\n+block|{\n+goto|goto\n+name|out\n+goto|;\n+block|}\n+name|rc\n+operator|=\n+name|rc\n+operator|=\nThe issue was with: drivers: gpio: pca953x: check return values from I2C API functions\n\nCheck the return values from the I2C API functions called in init() and\nfail driver initialization if unsuccessful.\n\nFixes: #66827"
},{
  "instruction": "There is an issue in the following code. It relates to lib: crc: address absence of crc4, crc4_ti in crc_types array\n\nAdded CRC4 and CRC4_TI to the supported crc_types[] array.\nOn some SoCs, like ESP32-S3, missing values can cause hardfaults\ndue to attempts to access the zero address. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|crc_types\nindex|[]\ninit|=\nblock|{\nindex|[\nname|CRC7_BE\nindex|]\noperator|=\nliteral|\"7_be\"\nblock|,\nliteral|\"8\"\nblock|,\nindex|[\nname|CRC8_CCITT\nindex|]\nliteral|\"8_ccitt\"\nblock|,\nindex|[\nname|CRC16\nindex|]",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|CRC4\n+index|]\n+operator|=\n+literal|\"4\"\n+block|,\n+index|[\n+name|CRC4_TI\n+index|]\n+operator|=\n+literal|\"4_ti\"\n+block|,\n+index|[\n+operator|=\nThe issue was with: lib: crc: address absence of crc4, crc4_ti in crc_types array\n\nAdded CRC4 and CRC4_TI to the supported crc_types[] array.\nOn some SoCs, like ESP32-S3, missing values can cause hardfaults\ndue to attempts to access the zero address."
},{
  "instruction": "There is an issue in the following code. It relates to net: lib: sockets: Initialize iovec to 0 at start of func\n\nMake sure iovec is initialized to a value so that there\nis no possibility that it is accessed uninitialized.\n\nFixes: #66838\nCoverity-CID: 334911 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|recv_len\ninit|=\nliteral|0\ndecl_stmt|,\nname|iovec\ndecl_stmt|,\nname|available_len\ndecl_stmt|,\nname|max_iovlen\ninit|=\nreturn|return\noperator|-\nname|EINVAL\nreturn|;\nblock|}\nname|iovec\noperator|=\nliteral|0\nexpr_stmt|;\nname|buf\noperator|=\nname|msg\noperator|->\nname|msg_iov",
  "result": "I corrected the issue in the code by changing the following tokens:\n+init|=\n+literal|0\n-name|iovec\n-operator|=\n-literal|0\n-expr_stmt|;\nThe issue was with: net: lib: sockets: Initialize iovec to 0 at start of func\n\nMake sure iovec is initialized to a value so that there\nis no possibility that it is accessed uninitialized.\n\nFixes: #66838\nCoverity-CID: 334911"
},{
  "instruction": "There is an issue in the following code. It relates to net: lib: mdns_responder: Fix interface count check\n\nThe original idea was to check that we have enough network\ninterfaces in the system. The check needs to verify max IPv4\nand IPv6 supported interfaces instead of always checking\nIPv6 one.\n\nFixes: #66843\nCoverity-CID: 334899 Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|\"You have %d interfaces configured but there \"\nliteral|\"are %d network interfaces in the system.\"\nargument_list|,\nname|MAX\nargument_list|(\nname|MAX_IPV6_IFACE_COUNT\nargument_list|,\nname|MAX_IPV6_IFACE_COUNT\nargument_list|)\nargument_list|,\nname|iface_count",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|MAX_IPV6_IFACE_COUNT\n+name|MAX_IPV4_IFACE_COUNT\nThe issue was with: net: lib: mdns_responder: Fix interface count check\n\nThe original idea was to check that we have enough network\ninterfaces in the system. The check needs to verify max IPv4\nand IPv6 supported interfaces instead of always checking\nIPv6 one.\n\nFixes: #66843\nCoverity-CID: 334899"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: ra: minor cleanups\n\n- Corrected indentation with clang-format Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_enum\nDECL|enum|__anon2a51f25d0103\nenum|enum\nblock|{\nDECL|enumerator|UART_RA_INT_RXI\nname|UART_RA_INT_RXI\nblock|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon2a51f25d0103\n+DECL|enum|__anon2bb1e4260103\nThe issue was with: drivers: serial: ra: minor cleanups\n\n- Corrected indentation with clang-format"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: interrupt_controller: ra_icu: minor cleanups\n\n- Corrected indentation with clang-format Please fix this issue.",
  "input": "Faulty tokenized code:\nname|IELSRn_IR_MASK\nvalue|BIT_MASK(1)\nend_define\n\nbegin_enum\nDECL|enum|__anon2a0c07300103\nenum|enum\nblock|{\nDECL|enumerator|IRQCRi_OFFSET\nname|IRQCRi_OFFSET\ninit|=",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon2a0c07300103\n+DECL|enum|__anon28e33e1f0103\nThe issue was with: drivers: interrupt_controller: ra_icu: minor cleanups\n\n- Corrected indentation with clang-format"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: interrupt_controller: ra_icu: Don't enable on irq connecting\n\nDon't execute `irq_enable` in process of the `ra_icu_irq_connect_dynamic`.\n\nThe caller of `ra_icu_irq_connect_dynamic` is only `gpio_ra_pin_configure`\nat this time. `gpio_ra_pin_configure` calls `irq_enable` just after called\n`ra_icu_irq_connect_dynamic`.\nSo removing 'irq_enable' from 'ra_icu_irq_connect_dynamic' has no effect\non behavior. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|IELSRn_IR_MASK\nvalue|BIT_MASK(1)\nend_define\n\nbegin_enum\nDECL|enum|__anon27e5a8f20103\nenum|enum\nblock|{\nDECL|enumerator|IRQCRi_OFFSET\nname|IRQCRi_OFFSET\ninit|=\nname|event\nargument_list|,\nname|intcfg\nargument_list|)\nexpr_stmt|;\nname|irq_enable\nargument_list|(\nname|irqn\nargument_list|)\nexpr_stmt|;\nreturn|return\nname|irqn\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon27e5a8f20103\n+DECL|enum|__anon2a0c07300103\n-name|irq_enable\n-argument_list|(\n-name|irqn\n-argument_list|)\n-expr_stmt|;\nThe issue was with: drivers: interrupt_controller: ra_icu: Don't enable on irq connecting\n\nDon't execute `irq_enable` in process of the `ra_icu_irq_connect_dynamic`.\n\nThe caller of `ra_icu_irq_connect_dynamic` is only `gpio_ra_pin_configure`\nat this time. `gpio_ra_pin_configure` calls `irq_enable` just after called\n`ra_icu_irq_connect_dynamic`.\nSo removing 'irq_enable' from 'ra_icu_irq_connect_dynamic' has no effect\non behavior."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: serial: ra: Cleaned up useless initialization and bad naming\n\nDEVICE_MMIO_MAP() is an unnecessary process, so delete it.\n\nI created uart_ra.c based on uart_rcar.c, but\nI forgot to correct the name. I fixed it. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nreturn|return\nname|ret\nreturn|;\nblock|}\nname|DEVICE_MMIO_MAP\nargument_list|(\nname|dev\nargument_list|,\nname|K_MEM_CACHE_NONE\nargument_list|)\nexpr_stmt|;\nname|ret\noperator|=\nname|uart_ra_configure\nargument_list|(\nname|dev\nbegin_comment\ncomment|/* Device Instantiation */\nend_comment\n\nbegin_define\nDECL|macro|UART_RCAR_INIT_CFG (n)\ndefine|#\ndirective|define\nname|UART_RCAR_INIT_CFG\nparameter_list|(\nname|n\nparameter_list|)\ndefine|\\\nvalue|PINCTRL_DT_DEFINE(DT_INST_PARENT(n));                                                      \\ \tstatic const struct uart_ra_cfg uart_ra_cfg_##n = {                                        \\ \t\t.regs = DT_REG_ADDR(DT_INST_PARENT(n)),                                            \\ \t\t.clock_dev = DEVICE_DT_GET(DT_CLOCKS_CTLR(DT_INST_PARENT(n))),                     \\ \t\t.clock_id =                                                                        \\ \t\t\t(clock_control_subsys_t)DT_CLOCKS_CELL_BY_IDX(DT_INST_PARENT(n), 0, id),   \\ \t\t.pcfg = PINCTRL_DT_DEV_CONFIG_GET(DT_INST_PARENT(n)),                              \\ \t}\nend_define\n\nbegin_define\nDECL|macro|UART_RCAR_INIT (n)\ndefine|#\ndirective|define\nname|UART_RCAR_INIT\nparameter_list|(\nname|n\nparameter_list|)\ndefine|\\\nvalue|UART_RCAR_INIT_CFG(n);                                                  \\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic struct uart_ra_data uart_ra_data_##n = {\t\t\t\t\\ \t\t.current_config = {\t\t\t\t\t\t\\ \t\t\t.baudrate = DT_INST_PROP(n, current_speed),\t\t\\ \t\t\t.parity = UART_CFG_PARITY_NONE,\t\t\t\t\\ \t\t\t.stop_bits = UART_CFG_STOP_BITS_1,\t\t\t\\ \t\t\t.data_bits = UART_CFG_DATA_BITS_8,\t\t\t\\ \t\t\t.flow_ctrl = UART_CFG_FLOW_CTRL_NONE,\t\t\t\\ \t\t},\t\t\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n,\t\t\t\t\t\t\\ \t\t\t      uart_ra_init,\t\t\t\t\t\\ \t\t\t      NULL,\t\t\t\t\t\t\\&uart_ra_data_##n,\t\t\t\t\\&uart_ra_cfg_##n,\t\t\t\t\t\\ \t\t\t      PRE_KERNEL_1, CONFIG_SERIAL_INIT_PRIORITY,\t\\&uart_ra_driver_api);\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\  DT_INST_FOREACH_STATUS_OKAY(UART_RCAR_INIT)\nend_define\n\nend_unit\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|DEVICE_MMIO_MAP\n-argument_list|(\n-name|dev\n-argument_list|,\n-name|K_MEM_CACHE_NONE\n-argument_list|)\n-expr_stmt|;\n-DECL|macro|UART_RCAR_INIT_CFG (n)\n+DECL|macro|UART_RA_INIT_CFG (n)\n-name|UART_RCAR_INIT_CFG\n+name|UART_RA_INIT_CFG\n-DECL|macro|UART_RCAR_INIT (n)\n+DECL|macro|UART_RA_INIT (n)\n-name|UART_RCAR_INIT\n+name|UART_RA_INIT\n-value|UART_RCAR_INIT_CFG(n);                                                  \\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic struct uart_ra_data uart_ra_data_##n = {\t\t\t\t\\ \t\t.current_config = {\t\t\t\t\t\t\\ \t\t\t.baudrate = DT_INST_PROP(n, current_speed),\t\t\\ \t\t\t.parity = UART_CFG_PARITY_NONE,\t\t\t\t\\ \t\t\t.stop_bits = UART_CFG_STOP_BITS_1,\t\t\t\\ \t\t\t.data_bits = UART_CFG_DATA_BITS_8,\t\t\t\\ \t\t\t.flow_ctrl = UART_CFG_FLOW_CTRL_NONE,\t\t\t\\ \t\t},\t\t\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n,\t\t\t\t\t\t\\ \t\t\t      uart_ra_init,\t\t\t\t\t\\ \t\t\t      NULL,\t\t\t\t\t\t\\&uart_ra_data_##n,\t\t\t\t\\&uart_ra_cfg_##n,\t\t\t\t\t\\ \t\t\t      PRE_KERNEL_1, CONFIG_SERIAL_INIT_PRIORITY,\t\\&uart_ra_driver_api);\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\  DT_INST_FOREACH_STATUS_OKAY(UART_RCAR_INIT)\n+value|UART_RA_INIT_CFG(n);                                                  \\ \t\t\t\t\t\t\t\t\t\t\\ \tstatic struct uart_ra_data uart_ra_data_##n = {\t\t\t\t\\ \t\t.current_config = {\t\t\t\t\t\t\\ \t\t\t.baudrate = DT_INST_PROP(n, current_speed),\t\t\\ \t\t\t.parity = UART_CFG_PARITY_NONE,\t\t\t\t\\ \t\t\t.stop_bits = UART_CFG_STOP_BITS_1,\t\t\t\\ \t\t\t.data_bits = UART_CFG_DATA_BITS_8,\t\t\t\\ \t\t\t.flow_ctrl = UART_CFG_FLOW_CTRL_NONE,\t\t\t\\ \t\t},\t\t\t\t\t\t\t\t\\ \t};\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\ \tDEVICE_DT_INST_DEFINE(n,\t\t\t\t\t\t\\ \t\t\t      uart_ra_init,\t\t\t\t\t\\ \t\t\t      NULL,\t\t\t\t\t\t\\&uart_ra_data_##n,\t\t\t\t\\&uart_ra_cfg_##n,\t\t\t\t\t\\ \t\t\t      PRE_KERNEL_1, CONFIG_SERIAL_INIT_PRIORITY,\t\\&uart_ra_driver_api);\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\\  DT_INST_FOREACH_STATUS_OKAY(UART_RA_INIT)\nThe issue was with: drivers: serial: ra: Cleaned up useless initialization and bad naming\n\nDEVICE_MMIO_MAP() is an unnecessary process, so delete it.\n\nI created uart_ra.c based on uart_rcar.c, but\nI forgot to correct the name. I fixed it."
},{
  "instruction": "There is an issue in the following code. It relates to tests: unit: util: Fix compliance check warnings\n\nAs code is moved from test.inc to main.c a compliance check is\nrun for the first time on that code. Fixing warnings. Please fix this issue.",
  "input": "Faulty tokenized code:\nDECL|macro|TEST_DEFINE_0\ndefine|#\ndirective|define\nname|TEST_DEFINE_0\nvalue|0\ncomment|/* Test validates that expected code has been injected. Failure would \t * be seen in compilation (lack of variable or ununsed variable. \t */\nname|COND_CODE_1\nargument_list|(\nliteral|1\nargument_list|,\nargument|(uint32_t x0 =\nend_macro\n\nbegin_block\nDECL|function|ZTEST (util,test_COND_CODE_0)\nblock|{\ncomment|/* Test validates that expected code has been injected. Failure would \t * be seen in compilation (lack of variable or ununsed variable. \t */\nname|COND_CODE_0\nargument_list|(\nliteral|0\nargument_list|,\nargument|(uint32_t x0 =",
  "result": "I corrected the issue in the code by changing the following tokens:\n-comment|/* Test validates that expected code has been injected. Failure would \t * be seen in compilation (lack of variable or ununsed variable. \t */\n+comment|/* Test validates that expected code has been injected. Failure would \t * be seen in compilation (lack of variable or unused variable). \t */\n-comment|/* Test validates that expected code has been injected. Failure would \t * be seen in compilation (lack of variable or ununsed variable. \t */\n+comment|/* Test validates that expected code has been injected. Failure would \t * be seen in compilation (lack of variable or unused variable). \t */\nThe issue was with: tests: unit: util: Fix compliance check warnings\n\nAs code is moved from test.inc to main.c a compliance check is\nrun for the first time on that code. Fixing warnings."
},{
  "instruction": "There is an issue in the following code. It relates to modem: cmux: fix frame data length encoding\n\nIn cases where the data is bigger than 127 bytes,\nthe first bit of the second byte of the data length field\nused to always be set.\n\nThis is wrong as according to the 3GPP 27.010 spec\nonly the first bit of the first byte is the EA bit;\nall the others denote the data length. Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|1\nargument_list|)\nexpr_stmt|;\nname|byte\noperator|=\nliteral|0x01\noperator||\noperator|(\nname|data_len\noperator|>>\nliteral|7\noperator|)\nexpr_stmt|;\nname|ring_buf_put\nargument_list|(\noperator|&\nname|cmux",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|0x01\n-operator||\n-operator|(\n-operator|)\nThe issue was with: modem: cmux: fix frame data length encoding\n\nIn cases where the data is bigger than 127 bytes,\nthe first bit of the second byte of the data length field\nused to always be set.\n\nThis is wrong as according to the 3GPP 27.010 spec\nonly the first bit of the first byte is the EA bit;\nall the others denote the data length."
},{
  "instruction": "There is an issue in the following code. It relates to logging: make CONFIG_LOG_ALWAYS_RUNTIME build check less ambiguous\n\nWhen these fails the compiler just prints \\\"Option must be enabled\\\" with\nno reference to what option, so one has to look at the code to find out.\nMention the actual option in the error to make these unambiguous. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_NO_OPTIMIZATIONS\nargument_list|)\nargument_list|,\nliteral|\"Option must be enabled when CONFIG_NO_OPTIMIZATIONS is set\"\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_expr_stmt\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_LOG_MODE_IMMEDIATE\nargument_list|)\nargument_list|,\nliteral|\"Option must be enabled when CONFIG_LOG_MODE_IMMEDIATE is set\"\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_endif",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|\"Option must be enabled when CONFIG_NO_OPTIMIZATIONS is set\"\n+literal|\"CONFIG_LOG_ALWAYS_RUNTIME must be enabled when \"\n+literal|\"CONFIG_NO_OPTIMIZATIONS is set\"\n-literal|\"Option must be enabled when CONFIG_LOG_MODE_IMMEDIATE is set\"\n+literal|\"CONFIG_LOG_ALWAYS_RUNTIME must be enabled when \"\n+literal|\"CONFIG_LOG_MODE_IMMEDIATE is set\"\nThe issue was with: logging: make CONFIG_LOG_ALWAYS_RUNTIME build check less ambiguous\n\nWhen these fails the compiler just prints \\\"Option must be enabled\\\" with\nno reference to what option, so one has to look at the code to find out.\nMention the actual option in the error to make these unambiguous."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: Use #if\n\nUse #if instead of IS_ENABLED for\nCONFIG_SOC_IT8XXX2_GPIO_GROUP_K_L_DEFAULT_PULL_DOWN, otherwise DTS files\nare required to provide gpiok and gpiol even if they are not used.\n\nBug #66401 Please fix this issue.",
  "input": "Faulty tokenized code:\nDECL|function|DT_INST_FOREACH_STATUS_OKAY (GPIO_ITE_DEV_CFG_DATA)\nname|DT_INST_FOREACH_STATUS_OKAY\nargument_list|(\nargument|GPIO_ITE_DEV_CFG_DATA\nargument_list|)\nspecifier|static\nname|int\nname|gpio_it8xxx2_init_set\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nif|if\ncondition|(\nname|IS_ENABLED\nargument_list|(\nname|CONFIG_SOC_IT8XXX2_GPIO_GROUP_K_L_DEFAULT_PULL_DOWN\nargument_list|)\ncondition|)\nblock|{\nspecifier|const\nname|struct\nname|device\nmodifier|*\nspecifier|const\noperator||\nname|GPIO_PULL_DOWN\nargument_list|)\nexpr_stmt|;\nblock|}\nblock|}\nreturn|return\nliteral|0\nreturn|;\nblock|}\nname|SYS_INIT\nname|CONFIG_GPIO_INIT_PRIORITY\nargument_list|)\nexpr_stmt|;\nend_function\n\nend_unit\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n+ifdef|#\n+directive|ifdef\n+name|CONFIG_SOC_IT8XXX2_GPIO_GROUP_K_L_DEFAULT_PULL_DOWN\n-if|if\n-condition|(\n-name|IS_ENABLED\n-argument_list|(\n-name|CONFIG_SOC_IT8XXX2_GPIO_GROUP_K_L_DEFAULT_PULL_DOWN\n-argument_list|)\n-condition|)\n-block|{\n-block|}\n+begin_endif\n+endif|#\n+directive|endif\n+end_endif\n+\n+begin_comment\n+comment|/* CONFIG_SOC_IT8XXX2_GPIO_GROUP_K_L_DEFAULT_PULL_DOWN */\n+end_comment\n+\nThe issue was with: drivers: Use #if\n\nUse #if instead of IS_ENABLED for\nCONFIG_SOC_IT8XXX2_GPIO_GROUP_K_L_DEFAULT_PULL_DOWN, otherwise DTS files\nare required to provide gpiok and gpiol even if they are not used.\n\nBug #66401"
},{
  "instruction": "There is an issue in the following code. It relates to LOG: DICT: Forward the User Context Void pointer to backend\n\nThe dictionary logging passed the full log_output structure\nto the backend instead of the user context void pointer. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|(\nname|void\noperator|*\noperator|)\nname|output\nargument_list|)\nexpr_stmt|;\nname|size_t\nname|len\ndecl_stmt|;\noperator|(\nname|void\noperator|*\noperator|)\nname|output\nargument_list|)\nexpr_stmt|;\nblock|}\nname|data\noperator|=\noperator|(\nname|void\noperator|*\noperator|)\nname|output\nargument_list|)\nexpr_stmt|;\nblock|}\nname|log_output_flush\nargument_list|(\noperator|(\nname|void\noperator|*\noperator|)\nname|output\nargument_list|)\nexpr_stmt|;\nblock|}\nend_function\n",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|->\n+name|control_block\n+operator|->\n+name|ctx\n+operator|->\n+name|control_block\n+operator|->\n+name|ctx\n+operator|->\n+name|control_block\n+operator|->\n+name|ctx\n+operator|->\n+name|control_block\n+operator|->\n+name|ctx\nThe issue was with: LOG: DICT: Forward the User Context Void pointer to backend\n\nThe dictionary logging passed the full log_output structure\nto the backend instead of the user context void pointer."
},{
  "instruction": "There is an issue in the following code. It relates to posix: timer: Fix timer_obj alignment\n\nThis makes sure the heap posix_timer_slab provides objects aligned\ncompatible with the type timer_obj. It was previously set to align at 4\nbytes. One example where this failed was on the SPARC which requires\naccess to int64_t to be 8-byte aligned.\n\nIn particular, struct timer_obj contains fields of type k_timer_t and\nstruct _timeout.\n\nWith this commit we now get the information on required alignment for\nstruct timer_obj from the compiler by using __alignof__(). Please fix this issue.",
  "input": "Faulty tokenized code:\nname|timer_obj\nargument_list|)\nargument_list|,\nname|CONFIG_MAX_TIMER_COUNT\nargument_list|,\nliteral|4\nargument_list|)\nexpr_stmt|;\nend_expr_stmt\n\nbegin_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|4\n+name|__alignof__\n+argument_list|(\n+expr|struct\n+name|timer_obj\n+argument_list|)\nThe issue was with: posix: timer: Fix timer_obj alignment\n\nThis makes sure the heap posix_timer_slab provides objects aligned\ncompatible with the type timer_obj. It was previously set to align at 4\nbytes. One example where this failed was on the SPARC which requires\naccess to int64_t to be 8-byte aligned.\n\nIn particular, struct timer_obj contains fields of type k_timer_t and\nstruct _timeout.\n\nWith this commit we now get the information on required alignment for\nstruct timer_obj from the compiler by using __alignof__()."
},{
  "instruction": "There is an issue in the following code. It relates to task_wdt: start feeding hardware watchdog immediately after init\n\nWithout this, the hardware watchdog would expire if no task watchdogs were\nregistered within one hardware watchdog period after init. Start the\nbackground channel immediately after init to avoid this. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|task_wdt_trigger\nargument_list|,\nname|NULL\nargument_list|)\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}\nend_function",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|schedule_next_timeout\n+argument_list|(\n+name|sys_clock_tick_get\n+argument_list|()\n+argument_list|)\n+expr_stmt|;\nThe issue was with: task_wdt: start feeding hardware watchdog immediately after init\n\nWithout this, the hardware watchdog would expire if no task watchdogs were\nregistered within one hardware watchdog period after init. Start the\nbackground channel immediately after init to avoid this."
},{
  "instruction": "There is an issue in the following code. It relates to lib: posix: tag the fallthrough case as __fallthrough\n\nUse the __fallthrough directive on the switch fallthrough case and drop\nthe comment instead. This informs the compiler that the fallthrough is\nintentional and silence any possible warning about it.\n\nDrop the not reached case as I think that that part can actually be\nreached since there are breaks in some of the cases. Please fix this issue.",
  "input": "Faulty tokenized code:\ninclude|#\ndirective|include\nfile|<zephyr/posix/fnmatch.h>\nend_include\n\nbegin_define\nDECL|macro|EOS\ndefine|#\ndirective|define\nname|EOS\noperator|--\nname|pattern\nexpr_stmt|;\nblock|}\nblock|}\ncomment|/* FALLTHROUGH */\ndefault|default:\nif|if\ncondition|(\nname|c\noperator|!=\nreturn|;\nblock|}\nbreak|break;\nblock|}\nblock|}\ncomment|/* NOTREACHED */\nblock|}\nend_function\n\nbegin_function\nDECL|function|fnmatch (const char * pattern,const char * string,int flags)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+begin_include\n+include|#\n+directive|include\n+file|<zephyr/toolchain.h>\n+end_include\n+\n-comment|/* FALLTHROUGH */\n+name|__fallthrough\n+expr_stmt|;\n-comment|/* NOTREACHED */\nThe issue was with: lib: posix: tag the fallthrough case as __fallthrough\n\nUse the __fallthrough directive on the switch fallthrough case and drop\nthe comment instead. This informs the compiler that the fallthrough is\nintentional and silence any possible warning about it.\n\nDrop the not reached case as I think that that part can actually be\nreached since there are breaks in some of the cases."
},{
  "instruction": "There is an issue in the following code. It relates to posix: pthread_setspecific: fix for coverity issue cid 334906\n\n* return EINVAL if pthread_self() is not a valid pthread Please fix this issue.",
  "input": "Faulty tokenized code:\ndecl_stmt|;\nname|struct\nname|posix_thread\nmodifier|*\nname|thread\ninit|=\nname|to_posix_thread\nargument_list|(\nname|pthread_self\nargument_list|()\nargument_list|)\ndecl_stmt|;\nname|struct\nname|pthread_key_data\nmodifier|*\nname|key_data\nname|int\nname|retval\ninit|=\nliteral|0\ndecl_stmt|;\ncomment|/* Traverse the list of keys set by the thread, looking for key. \t * If the key is already in the list, re-assign its value. \t * Else add the key to the thread's list. \t */\nname|key_key\noperator|=\nname|k_spin_lock\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-init|=\n-name|to_posix_thread\n-argument_list|(\n-name|pthread_self\n-argument_list|()\n-argument_list|)\n+name|thread\n+operator|=\n+name|to_posix_thread\n+argument_list|(\n+name|pthread_self\n+argument_list|()\n+argument_list|)\n+expr_stmt|;\n+if|if\n+condition|(\n+name|thread\n+operator|==\n+name|NULL\n+condition|)\n+block|{\n+return|return\n+name|EINVAL\n+return|;\n+block|}\nThe issue was with: posix: pthread_setspecific: fix for coverity issue cid 334906\n\n* return EINVAL if pthread_self() is not a valid pthread"
},{
  "instruction": "There is an issue in the following code. It relates to lib: os: cbprintf: Fix size miscalculation in cbprintf_convert\n\nWhen package contained RO string positions and flag indicates that\nthey shall not be kept, length was miscalculated which could lead\nto failures (e.g. memory corruption). Please fix this issue.",
  "input": "Faulty tokenized code:\nname|void\nmodifier|*\nname|buf\nparameter_list|)\nblock|{\nDECL|union|__anon28e377b3010a\nunion|union\nblock|{\nDECL|member|ap\nname|va_list\nname|ap\nname|void\nmodifier|*\nname|buf\nparameter_list|)\nblock|{\nDECL|union|__anon28e377b3020a\nunion|union\nblock|{\nDECL|member|ap\nname|va_list\nname|ap\nname|void\nmodifier|*\nname|buf\nparameter_list|)\nblock|{\nDECL|union|__anon28e377b3030a\nunion|union\nblock|{\nDECL|member|ap\nname|va_list\nname|ap\nname|void\nmodifier|*\nname|buf\nparameter_list|)\nblock|{\nDECL|union|__anon28e377b3040a\nunion|union\nblock|{\nDECL|member|ap\nname|va_list\nname|ap\ncase|case\nname|CBPRINTF_PACKAGE_ARG_TYPE_LONG_DOUBLE\ncase|:\nblock|{\ncomment|/* \t\t\t\t * Handle floats separately as they may be \t\t\t\t * held in a different register set. \t\t\t\t */\nDECL|union|__anon28e377b3050a\nDECL|member|d\nDECL|member|ld\nunion|union\nblock|{\nname|double\ncase|case\nliteral|'G'\ncase|:\nblock|{\ncomment|/* \t\t\t\t * Handle floats separately as they may be \t\t\t\t * held in a different register set. \t\t\t\t */\nDECL|union|__anon28e377b3060a\nDECL|member|d\nDECL|member|ld\nunion|union\nblock|{\nname|double\nexpr_stmt|;\nblock|}\nblock|}\nelse|else\nblock|{\nif|if\ncondition|(\nname|ros_nbr\noperator|&&\nname|flags\noperator|&\nname|CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR\ncondition|)\nblock|{\nname|str_pos\noperator|+=\nname|ros_nbr\nexpr_stmt|;\nblock|}\nblock|}\nname|bool\nname|drop_ro_str_pos\ninit|=\noperator|!\noperator|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|union|__anon28e377b3010a\n+DECL|union|__anon2b885fc0010a\n-DECL|union|__anon28e377b3020a\n+DECL|union|__anon2b885fc0020a\n-DECL|union|__anon28e377b3030a\n+DECL|union|__anon2b885fc0030a\n-DECL|union|__anon28e377b3040a\n+DECL|union|__anon2b885fc0040a\n-DECL|union|__anon28e377b3050a\n+DECL|union|__anon2b885fc0050a\n-DECL|union|__anon28e377b3060a\n+DECL|union|__anon2b885fc0060a\n-if|if\n-condition|(\n-name|ros_nbr\n-operator|&&\n-name|flags\n-operator|&\n-name|CBPRINTF_PACKAGE_CONVERT_KEEP_RO_STR\n-condition|)\n-block|{\n-block|}\nThe issue was with: lib: os: cbprintf: Fix size miscalculation in cbprintf_convert\n\nWhen package contained RO string positions and flag indicates that\nthey shall not be kept, length was miscalculated which could lead\nto failures (e.g. memory corruption)."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: pcie: Read register before actual usage\n\nMove reading PCIE_CONF_CMDSTAT before actual usage. There are four\nreturn branches before value is used. Please fix this issue.",
  "input": "Faulty tokenized code:\noperator|+\nname|PCIE_CONF_BAR0\ndecl_stmt|;\nname|uint32_t\nname|cmd_reg\ninit|=\nname|pcie_conf_read\nargument_list|(\nname|bdf\nargument_list|,\nname|PCIE_CONF_CMDSTAT\nargument_list|)\ndecl_stmt|;\nname|bool\nname|ret\ninit|=\nname|false\ncomment|/* Discard on invalid flags */\nreturn|return\nname|false\nreturn|;\nblock|}\ncomment|/* IO/memory decode should be disabled before sizing/update BAR. */\nname|pcie_conf_write\nargument_list|(\nname|bdf\nargument_list|,",
  "result": "I corrected the issue in the code by changing the following tokens:\n-init|=\n-name|pcie_conf_read\n-argument_list|(\n-name|bdf\n-argument_list|,\n-name|PCIE_CONF_CMDSTAT\n-argument_list|)\n+name|cmd_reg\n+operator|=\n+name|pcie_conf_read\n+argument_list|(\n+name|bdf\n+argument_list|,\n+name|PCIE_CONF_CMDSTAT\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: pcie: Read register before actual usage\n\nMove reading PCIE_CONF_CMDSTAT before actual usage. There are four\nreturn branches before value is used."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: pcie: Remove magic number\n\nUse definitions instead of magic numbers. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|cmd_reg\noperator|&\noperator|(\noperator|~\nliteral|0x3\noperator|)\nargument_list|)\nexpr_stmt|;\nname|pcie_conf_write\nargument_list|(",
  "result": "I corrected the issue in the code by changing the following tokens:\n-literal|0x3\n+operator|(\n+name|PCIE_CONF_CMDSTAT_IO\n+operator||\n+name|PCIE_CONF_CMDSTAT_MEM\n+operator|)\nThe issue was with: drivers: pcie: Remove magic number\n\nUse definitions instead of magic numbers."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: rtc: set 'rtc_driver_api' as 'static const'\n\nThis change marks each instance of the 'rtc_driver_api' as 'static const'.\nThe rationale is that 'rtc_driver_api' is used for declaring internal\nmodule interfaces and is not intended to be modified at runtime.\nBy using 'static const', we ensure immutability, leading to usage of only\n.rodata and a reduction in the .data area. Please fix this issue.",
  "input": "Faulty tokenized code:\ncomment|/* CONFIG_RTC_CALIBRATION */\nend_comment\n\nbegin_decl_stmt\nDECL|variable|rtc_emul_driver_api\nname|struct\nname|rtc_driver_api\nname|rtc_emul_driver_api\ninit|=\nblock|{\ncomment|/* CONFIG_ZTEST */\nend_comment\n\nbegin_decl_stmt\nDECL|variable|rtc_fake_driver_api\nname|struct\nname|rtc_driver_api\nname|rtc_fake_driver_api\ninit|=\nblock|{\ncomment|/* CONFIG_RTC_CALIBRATION */\nend_comment\n\nbegin_decl_stmt\nDECL|variable|rtc_stm32_driver_api\nname|struct\nname|rtc_driver_api\nname|rtc_stm32_driver_api\ninit|=\nblock|{\nblock|}\nend_function\n\nbegin_decl_stmt\nDECL|variable|rtc_mc146818_driver_api\nname|struct\nname|rtc_driver_api\nname|rtc_mc146818_driver_api\ninit|=\nblock|{\nend_comment\n\nbegin_decl_stmt\nDECL|variable|rtc_sam_driver_api\nspecifier|static\nname|struct\nname|rtc_driver_api\nname|rtc_sam_driver_api\ninit|=\nblock|{\ndirective|endif\nend_endif\n\nbegin_decl_stmt\nDECL|variable|rtc_smartbond_driver_api\nname|struct\nname|rtc_driver_api\nname|rtc_smartbond_driver_api\ninit|=\nblock|{",
  "result": "I corrected the issue in the code by changing the following tokens:\n+specifier|static\n+specifier|const\n+specifier|static\n+specifier|const\n+specifier|static\n+specifier|const\n+specifier|static\n+specifier|const\n+specifier|const\n+specifier|static\n+specifier|const\nThe issue was with: drivers: rtc: set 'rtc_driver_api' as 'static const'\n\nThis change marks each instance of the 'rtc_driver_api' as 'static const'.\nThe rationale is that 'rtc_driver_api' is used for declaring internal\nmodule interfaces and is not intended to be modified at runtime.\nBy using 'static const', we ensure immutability, leading to usage of only\n.rodata and a reduction in the .data area."
},{
  "instruction": "There is an issue in the following code. It relates to pm: increase coverage - add missing test assert\n\ncover missing lines reported by codecov Please fix this issue.",
  "input": "Faulty tokenized code:\nliteral|0\nargument_list|,\nliteral|\"\"\nargument_list|)\nexpr_stmt|;\nblock|}\nend_block\n\nbegin_function\nDECL|function|dev_pm_control (const struct device * dev,enum pm_device_action action)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|zassert_false\n+argument_list|(\n+name|pm_device_runtime_put_async\n+argument_list|(\n+name|dev\n+argument_list|)\n+argument_list|,\n+literal|\"\"\n+argument_list|)\n+expr_stmt|;\nThe issue was with: pm: increase coverage - add missing test assert\n\ncover missing lines reported by codecov"
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Shell: Fix coverity issue in cmd_adv_data\n\nFix wrong parameter type to avoid Unsigned compared against 0\n\nFixes: https://github.com/zephyrproject-rtos/zephyr/issues/65578 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|CONFIG_BT_BROADCASTER\nargument_list|)\nend_if\n\nbegin_enum\nDECL|enum|__anon2bdbaaa60103\nenum|enum\nblock|{\nDECL|enumerator|SHELL_ADV_OPT_CONNECTABLE\nname|SHELL_ADV_OPT_CONNECTABLE\nblock|,\nname|size_t\nname|sd_len\ninit|=\nliteral|0\ndecl_stmt|;\nname|size_t\nname|len\ninit|=\nliteral|0\ndecl_stmt|;\nname|bool",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon2bdbaaa60103\n+DECL|enum|__anon2a188a9c0103\n-name|size_t\n+name|ssize_t\nThe issue was with: Bluetooth: Shell: Fix coverity issue in cmd_adv_data\n\nFix wrong parameter type to avoid Unsigned compared against 0\n\nFixes: https://github.com/zephyrproject-rtos/zephyr/issues/65578"
},{
  "instruction": "There is an issue in the following code. It relates to input: use K_KERNEL_STACK_SIZEOF to set the thread stack size\n\nUse K_KERNEL_STACK_SIZEOF instead of the config directly to set the\nstack size in k_thread_create() calls. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|,\nname|data\noperator|->\nname|thread_stack\nargument_list|,\nname|CONFIG_INPUT_KBD_MATRIX_THREAD_STACK_SIZE\nargument_list|,\nname|input_kbd_matrix_polling_thread\nargument_list|,\noperator|(\nname|void\noperator|&\nname|linux_evdev_thread\nargument_list|,\nname|linux_evdev_thread_stack\nargument_list|,\nname|CONFIG_ARCH_POSIX_RECOMMENDED_STACK_SIZE\nargument_list|,\nname|linux_evdev_thread_fn\nargument_list|,\noperator|(\nname|void",
  "result": "I corrected the issue in the code by changing the following tokens:\n-name|CONFIG_INPUT_KBD_MATRIX_THREAD_STACK_SIZE\n+name|K_KERNEL_STACK_SIZEOF\n+argument_list|(\n+name|data\n+operator|->\n+name|thread_stack\n+argument_list|)\n-name|CONFIG_ARCH_POSIX_RECOMMENDED_STACK_SIZE\n+name|K_KERNEL_STACK_SIZEOF\n+argument_list|(\n+name|linux_evdev_thread_stack\n+argument_list|)\nThe issue was with: input: use K_KERNEL_STACK_SIZEOF to set the thread stack size\n\nUse K_KERNEL_STACK_SIZEOF instead of the config directly to set the\nstack size in k_thread_create() calls."
},{
  "instruction": "There is an issue in the following code. It relates to tests: usb: move bc12 tests under tests/drivers/usb\n\nMove bc12 under usb, this is not a standalone driver subsystem. Please fix this issue.",
  "input": "Faulty tokenized code:\nsimilarity index 100%\nrename from tests/drivers/bc12/CMakeLists.txt\nrename to tests/drivers/usb/bc12/CMakeLists.txt\nsimilarity index 100%\nrename from tests/drivers/bc12/boards/native_sim.conf\nrename to tests/drivers/usb/bc12/boards/native_sim.conf\nsimilarity index 100%\nrename from tests/drivers/bc12/boards/native_sim.overlay\nrename to tests/drivers/usb/bc12/boards/native_sim.overlay\nsimilarity index 100%\nrename from tests/drivers/bc12/prj.conf\nrename to tests/drivers/usb/bc12/prj.conf\nsimilarity index 100%\nrename from tests/drivers/bc12/src/charging_mode.c\nrename to tests/drivers/usb/bc12/src/charging_mode.c\nsimilarity index 100%\nrename from tests/drivers/bc12/src/pd_mode.c\nrename to tests/drivers/usb/bc12/src/pd_mode.c\nsimilarity index 100%\nrename from tests/drivers/bc12/testcase.yaml\nrename to tests/drivers/usb/bc12/testcase.yaml",
  "result": "I corrected the issue in the code by changing the following tokens:\n\nThe issue was with: tests: usb: move bc12 tests under tests/drivers/usb\n\nMove bc12 under usb, this is not a standalone driver subsystem."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: clock_control: stm32wba: set regu voltage after clk configuration\n\nCall to set_regu_voltage() is required also after the clock configuration\nhas been performed. Please fix this issue.",
  "input": "Faulty tokenized code:\nargument_list|(\nname|CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC\nargument_list|)\nexpr_stmt|;\nblock|}\nname|SystemCoreClock\noperator|=\nname|CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC\nexpr_stmt|;\ncomment|/* Set bus prescalers prescaler */",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* Set voltage regulator to comply with targeted system frequency */\n+name|set_regu_voltage\n+argument_list|(\n+name|CONFIG_SYS_CLOCK_HW_CYCLES_PER_SEC\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: clock_control: stm32wba: set regu voltage after clk configuration\n\nCall to set_regu_voltage() is required also after the clock configuration\nhas been performed."
},{
  "instruction": "There is an issue in the following code. It relates to drivers: clock_control: ra: fix initialization of the clock_hw_cycles\n\nWe should set the z_clock_hw_cycles_per_sec as the value of\nthe system clock frequency.\n\nThere was a mistake in referencing the clock source set before\ninitialization.\nI corrected it to reflect the clock value after initialization. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|z_clock_hw_cycles_per_sec\ndecl_stmt|;\nend_decl_stmt\n\nbegin_enum\nDECL|enum|__anon29639ab10103\nenum|enum\nblock|{\nDECL|enumerator|CLKSRC_hoco\nname|CLKSRC_hoco\ninit|=\nblock|, }\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon29639ab10203\nenum|enum\nblock|{\nDECL|enumerator|SCKDIV_1\nname|SCKDIV_1\ninit|=\nblock|}\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon29639ab10303\nenum|enum\nblock|{\nDECL|enumerator|SCKDIV_POS_pclkd\nname|SCKDIV_POS_pclkd\ninit|=\nblock|}\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon29639ab10403\nenum|enum\nblock|{\nDECL|enumerator|OSCSF_HOCOSF_POS\nname|OSCSF_HOCOSF_POS\ninit|=\nblock|, }\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon29639ab10503\nenum|enum\nblock|{\nDECL|enumerator|OPCCR_OPCMTSF_POS\nname|OPCCR_OPCMTSF_POS\ninit|=\nliteral|0x2U\ndecl_stmt|;\nend_decl_stmt\n\nbegin_enum\nDECL|enum|__anon29639ab10603\nenum|enum\nblock|{\nif|#\ndirective|if\nname|DT_INST_REG_SIZE_BY_NAME\nblock|, }\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon29639ab10703\nenum|enum\nblock|{\nDECL|enumerator|SCKDIVCR_OFFSET\nname|SCKDIVCR_OFFSET\ninit|=\nblock|, }\nenum|;\nend_enum\n\nbegin_enum\nDECL|enum|__anon29639ab10803\nenum|enum\nblock|{\nDECL|enumerator|SCRSCK_hoco\nname|SCRSCK_hoco\nblock|,\nname|SCKSCR_OFFSET\nargument_list|,\nname|SCKSCR_INIT_VALUE\nargument_list|)\nexpr_stmt|;\nname|z_clock_hw_cycles_per_sec\noperator|=\nname|clock_freqs\nindex|[\nname|sysclk",
  "result": "I corrected the issue in the code by changing the following tokens:\n-DECL|enum|__anon29639ab10103\n+DECL|enum|__anon2adfa0200103\n-DECL|enum|__anon29639ab10203\n+DECL|enum|__anon2adfa0200203\n-DECL|enum|__anon29639ab10303\n+DECL|enum|__anon2adfa0200303\n-DECL|enum|__anon29639ab10403\n+DECL|enum|__anon2adfa0200403\n-DECL|enum|__anon29639ab10503\n+DECL|enum|__anon2adfa0200503\n-DECL|enum|__anon29639ab10603\n+DECL|enum|__anon2adfa0200603\n-DECL|enum|__anon29639ab10703\n+DECL|enum|__anon2adfa0200703\n-DECL|enum|__anon29639ab10803\n+DECL|enum|__anon2adfa0200803\n+comment|/* re-read system clock setting and apply to hw_cycles */\n+name|sysclk\n+operator|=\n+name|SYSTEM_read8\n+argument_list|(\n+name|SCKSCR_OFFSET\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: clock_control: ra: fix initialization of the clock_hw_cycles\n\nWe should set the z_clock_hw_cycles_per_sec as the value of\nthe system clock frequency.\n\nThere was a mistake in referencing the clock source set before\ninitialization.\nI corrected it to reflect the clock value after initialization."
},{
  "instruction": "There is an issue in the following code. It relates to Bluetooth: Host: add hci error to errno translation for INVALID_PARAM\n\nnow returns -EINVAL if invalid parameters a are supplied Please fix this issue.",
  "input": "Faulty tokenized code:\ncase|:\nreturn|return\noperator|-\nname|ENOMEM\nreturn|;\ndefault|default:\nreturn|return\noperator|-\nname|EIO\nreturn|;\nname|hci_vs_init\nparameter_list|(\nname|void\nparameter_list|)\nblock|{\nDECL|union|__anon2c5fff5c010a\nunion|union\nblock|{\nDECL|member|info\nname|struct\nname|bt_hci_rp_vs_read_version_info",
  "result": "I corrected the issue in the code by changing the following tokens:\n+case|case\n+name|BT_HCI_ERR_INVALID_PARAM\n+case|:\n+return|return\n+operator|-\n+name|EINVAL\n+return|;\n-DECL|union|__anon2c5fff5c010a\n+DECL|union|__anon27afa355010a\nThe issue was with: Bluetooth: Host: add hci error to errno translation for INVALID_PARAM\n\nnow returns -EINVAL if invalid parameters a are supplied"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: can: native_linux: leave room for null termination of string\n\nOnly copy up to IFNAMSIZ - 1 number of characters of the interface name to\nleave room for null termination of string.\n\nFixes: #66777 Please fix this issue.",
  "input": "Faulty tokenized code:\nname|ifr_name\nargument_list|,\nname|if_name\nargument_list|,\nname|IFNAMSIZ\nargument_list|)\nexpr_stmt|;\nname|ret\noperator|=\nname|ioctl",
  "result": "I corrected the issue in the code by changing the following tokens:\n+operator|-\n+literal|1\nThe issue was with: drivers: can: native_linux: leave room for null termination of string\n\nOnly copy up to IFNAMSIZ - 1 number of characters of the interface name to\nleave room for null termination of string.\n\nFixes: #66777"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: can: native_linux: add missing return value check\n\nCheck return value from linux_socketcan_set_mode_fd() function call.\n\nFixes: #66798 Please fix this issue.",
  "input": "Faulty tokenized code:\ninit|=\nname|dev\noperator|->\nname|data\ndecl_stmt|;\nifdef|#\ndirective|ifdef\nname|CONFIG_CAN_FD_MODE\nif|if\ncondition|(\nname|CAN_MODE_FD\noperator|)\noperator|!=\nliteral|0\nexpr_stmt|;\nname|linux_socketcan_set_mode_fd\nargument_list|(\nname|data\noperator|->\nname|dev_fd\nname|data\noperator|->\nname|mode_fd\nargument_list|)\nexpr_stmt|;\nreturn|return\nliteral|0\nreturn|;\nblock|}\nDECL|function|can_native_linux_set_timing (const struct device * dev,const struct can_timing * timing)",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|int\n+name|err\n+decl_stmt|;\n+name|err\n+operator|=\n+if|if\n+condition|(\n+name|err\n+operator|!=\n+literal|0\n+condition|)\n+block|{\n+name|LOG_ERR\n+argument_list|(\n+literal|\"failed to set mode\"\n+argument_list|)\n+expr_stmt|;\n+return|return\n+operator|-\n+name|EIO\n+return|;\n+block|}\nThe issue was with: drivers: can: native_linux: add missing return value check\n\nCheck return value from linux_socketcan_set_mode_fd() function call.\n\nFixes: #66798"
},{
  "instruction": "There is an issue in the following code. It relates to drivers: usb_dc_rpi_pico: previosuly used endpoint may remain locked\n\nWhen reconfiguring a previously used endpoint, it may still be locked\nwhen a write was taking place when e.g. the host application crashed.\nThe call to udc_rpi_cancel_endpoint seems to do a proper cleanup of\nthe endpoint, i.e. the write semaphore will be released.\nFixes #66723. Please fix this issue.",
  "input": "Faulty tokenized code:\nblock|{\nreturn|return\nliteral|0\nreturn|;\nblock|}\nname|uint8_t\nname|val\ninit|=\noperator|*\nname|ep_state",
  "result": "I corrected the issue in the code by changing the following tokens:\n+comment|/* If this endpoint has previously been used and e.g. the host application \t * crashed, the endpoint may remain locked even after reconfiguration \t * because the write semaphore is never given back. \t * udc_rpi_cancel_endpoint() handles this so the endpoint can be written again. \t */\n+name|udc_rpi_cancel_endpoint\n+argument_list|(\n+name|ep\n+argument_list|)\n+expr_stmt|;\nThe issue was with: drivers: usb_dc_rpi_pico: previosuly used endpoint may remain locked\n\nWhen reconfiguring a previously used endpoint, it may still be locked\nwhen a write was taking place when e.g. the host application crashed.\nThe call to udc_rpi_cancel_endpoint seems to do a proper cleanup of\nthe endpoint, i.e. the write semaphore will be released.\nFixes #66723."
},{
  "instruction": "There is an issue in the following code. It relates to bluetooth: audio: broadcast: Fix missing update of meta_len\n\nThe length of the updated metadata was not updated.\nFixes the CAP/INI/BST/BV-13-C test case. Please fix this issue.",
  "input": "Faulty tokenized code:\nname|meta\nargument_list|,\nname|meta_len\nargument_list|)\nexpr_stmt|;\nblock|}\nreturn|return\nliteral|0\nreturn|;\nblock|}",
  "result": "I corrected the issue in the code by changing the following tokens:\n+name|subgroup\n+operator|->\n+name|codec_cfg\n+operator|->\n+name|meta_len\n+operator|=\n+name|meta_len\n+expr_stmt|;\nThe issue was with: bluetooth: audio: broadcast: Fix missing update of meta_len\n\nThe length of the updated metadata was not updated.\nFixes the CAP/INI/BST/BV-13-C test case."
}]
